[
    {
        "title": "3Sum Closest",
        "question_content": "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\nReturn the sum of the three integers.\nYou may assume that each input would have exactly one solution.\n&nbsp;\nExample 1:\n\nInput: nums = [-1,2,1,-4], target = 1\nOutput: 2\nExplanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n\nExample 2:\n\nInput: nums = [0,0,0], target = 1\nOutput: 0\nExplanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n\n&nbsp;\nConstraints:\n\n\t3 <= nums.length <= 500\n\t-1000 <= nums[i] <= 1000\n\t-104 <= target <= 104",
        "solutions": [
            {
                "id": 7883,
                "title": "c-solution-o-n-2-using-sort",
                "content": "Sort the vector and then no need to run *O(N^3)* algorithm as each index has a direction to move.\\n\\nThe code starts from this formation.\\n\\n    ----------------------------------------------------\\n    ^  ^                                               ^\\n    |  |                                               |\\n    |  +- second                                     third\\n    +-first\\n\\nif  *nums[first] + nums[second] + nums[third]* is smaller than the *target*, we know we have to increase the sum. so only choice is moving the second index forward.\\n\\n    ----------------------------------------------------\\n    ^    ^                                             ^\\n    |    |                                             |\\n    |    +- second                                   third\\n    +-first\\n\\n\\nif the *sum* is bigger than the *target*, we know that we need to reduce the *sum*. so only choice is moving '*third*' to backward. of course if the *sum* equals to *target*, we can immediately return the *sum*.\\n\\n    ----------------------------------------------------\\n    ^    ^                                          ^\\n    |    |                                          |\\n    |    +- second                                third\\n    +-first\\n\\n\\nwhen *second* and *third* cross, the round is done so start next round by moving '*first*' and resetting *second* and *third*.\\n\\n    ----------------------------------------------------\\n      ^    ^                                           ^\\n      |    |                                           |\\n      |    +- second                                 third\\n      +-first\\n\\nwhile doing this, collect the *closest sum* of each stage by calculating and comparing delta. Compare *abs(target-newSum)* and *abs(target-closest)*. At the end of the process the three indexes will eventually be gathered at the end of the array.\\n\\n    ----------------------------------------------------\\n                                             ^    ^    ^\\n                                             |    |    `- third\\n                                             |    +- second\\n                                             +-first\\n\\nif no exactly matching *sum* has been found so far, the value in *closest* will be the answer.\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        if(nums.size() < 3) return 0;\\n        int closest = nums[0]+nums[1]+nums[2];\\n        sort(nums.begin(), nums.end());\\n        for(int first = 0 ; first < nums.size()-2 ; ++first) {\\n            if(first > 0 && nums[first] == nums[first-1]) continue;\\n            int second = first+1;\\n            int third = nums.size()-1;            \\n            while(second < third) {\\n                int curSum = nums[first]+nums[second]+nums[third];\\n                if(curSum == target) return curSum;\\n                if(abs(target-curSum)<abs(target-closest)) {\\n                    closest = curSum;\\n                }\\n                if(curSum > target) {\\n                    --third;\\n                } else {\\n                    ++second;\\n                }\\n            }\\n        }\\n        return closest;\\n    }",
                "solutionTags": [],
                "code": "Sort the vector and then no need to run *O(N^3)* algorithm as each index has a direction to move.\\n\\nThe code starts from this formation.\\n\\n    ----------------------------------------------------\\n    ^  ^                                               ^\\n    |  |                                               |\\n    |  +- second                                     third\\n    +-first\\n\\nif  *nums[first] + nums[second] + nums[third]* is smaller than the *target*, we know we have to increase the sum. so only choice is moving the second index forward.\\n\\n    ----------------------------------------------------\\n    ^    ^                                             ^\\n    |    |                                             |\\n    |    +- second                                   third\\n    +-first\\n\\n\\nif the *sum* is bigger than the *target*, we know that we need to reduce the *sum*. so only choice is moving '*third*' to backward. of course if the *sum* equals to *target*, we can immediately return the *sum*.\\n\\n    ----------------------------------------------------\\n    ^    ^                                          ^\\n    |    |                                          |\\n    |    +- second                                third\\n    +-first\\n\\n\\nwhen *second* and *third* cross, the round is done so start next round by moving '*first*' and resetting *second* and *third*.\\n\\n    ----------------------------------------------------\\n      ^    ^                                           ^\\n      |    |                                           |\\n      |    +- second                                 third\\n      +-first\\n\\nwhile doing this, collect the *closest sum* of each stage by calculating and comparing delta. Compare *abs(target-newSum)* and *abs(target-closest)*. At the end of the process the three indexes will eventually be gathered at the end of the array.\\n\\n    ----------------------------------------------------\\n                                             ^    ^    ^\\n                                             |    |    `- third\\n                                             |    +- second\\n                                             +-first\\n\\nif no exactly matching *sum* has been found so far, the value in *closest* will be the answer.\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        if(nums.size() < 3) return 0;\\n        int closest = nums[0]+nums[1]+nums[2];\\n        sort(nums.begin(), nums.end());\\n        for(int first = 0 ; first < nums.size()-2 ; ++first) {\\n            if(first > 0 && nums[first] == nums[first-1]) continue;\\n            int second = first+1;\\n            int third = nums.size()-1;            \\n            while(second < third) {\\n                int curSum = nums[first]+nums[second]+nums[third];\\n                if(curSum == target) return curSum;\\n                if(abs(target-curSum)<abs(target-closest)) {\\n                    closest = curSum;\\n                }\\n                if(curSum > target) {\\n                    --third;\\n                } else {\\n                    ++second;\\n                }\\n            }\\n        }\\n        return closest;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 7871,
                "title": "python-o-n-2-solution",
                "content": "    class Solution:\\n        # @return an integer\\n        def threeSumClosest(self, num, target):\\n            num.sort()\\n            result = num[0] + num[1] + num[2]\\n            for i in range(len(num) - 2):\\n                j, k = i+1, len(num) - 1\\n                while j < k:\\n                    sum = num[i] + num[j] + num[k]\\n                    if sum == target:\\n                        return sum\\n                    \\n                    if abs(sum - target) < abs(result - target):\\n                        result = sum\\n                    \\n                    if sum < target:\\n                        j += 1\\n                    elif sum > target:\\n                        k -= 1\\n                \\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @return an integer\\n        def threeSumClosest(self, num, target):\\n            num.sort()\\n            result = num[0] + num[1] + num[2]\\n            for i in range(len(num) - 2):\\n                j, k = i+1, len(num) - 1\\n                while j < k:\\n                    sum = num[i] + num[j] + num[k]\\n                    if sum == target:\\n                        return sum\\n                    \\n                    if abs(sum - target) < abs(result - target):\\n                        result = sum\\n                    \\n                    if sum < target:\\n                        j += 1\\n                    elif sum > target:\\n                        k -= 1\\n                \\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 7873,
                "title": "a-n-2-solution-can-we-do-better",
                "content": "Here is a solution in Order(N^2). I got help from this post on \\n[stackoverflow][1] <br>\\nCan we improve this time complexity ?\\n\\n    int threeSumClosest(vector<int> &num, int target) {        \\n        vector<int> v(num.begin(), num.end()); // I didn't wanted to disturb original array.\\n        int n = 0;\\n        int ans = 0;\\n        int sum;\\n        \\n        sort(v.begin(), v.end());\\n        \\n        // If less then 3 elements then return their sum\\n        while (v.size() <= 3) {\\n            return accumulate(v.begin(), v.end(), 0);\\n        }\\n        \\n        n = v.size();\\n        \\n        /* v[0] v[1] v[2] ... v[i] .... v[j] ... v[k] ... v[n-2] v[n-1]\\n         *                    v[i]  <=  v[j]  <= v[k] always, because we sorted our array. \\n         * Now, for each number, v[i] : we look for pairs v[j] & v[k] such that \\n         * absolute value of (target - (v[i] + v[j] + v[k]) is minimised.\\n         * if the sum of the triplet is greater then the target it implies\\n         * we need to reduce our sum, so we do K = K - 1, that is we reduce\\n         * our sum by taking a smaller number.\\n         * Simillarly if sum of the triplet is less then the target then we\\n         * increase out sum by taking a larger number, i.e. J = J + 1.\\n         */\\n        ans = v[0] + v[1] + v[2];\\n        for (int i = 0; i < n-2; i++) {\\n            int j = i + 1;\\n            int k = n - 1;\\n            while (j < k) {\\n                sum = v[i] + v[j] + v[k];\\n                if (abs(target - ans) > abs(target - sum)) {\\n                    ans = sum;\\n                    if (ans == target) return ans;\\n                }\\n                (sum > target) ? k-- : j++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n<b>Edit:</b>Thanks @thr for pointing out that. I have corrected it and also renamed 'mx' by 'ans'.\\n  [1]: http://stackoverflow.com/questions/2070359/finding-three-elements-in-an-array-whose-sum-is-closest-to-an-given-number",
                "solutionTags": [],
                "code": "Here is a solution in Order(N^2). I got help from this post on \\n[stackoverflow][1] <br>\\nCan we improve this time complexity ?\\n\\n    int threeSumClosest(vector<int> &num, int target) {        \\n        vector<int> v(num.begin(), num.end()); // I didn't wanted to disturb original array.\\n        int n = 0;\\n        int ans = 0;\\n        int sum;\\n        \\n        sort(v.begin(), v.end());\\n        \\n        // If less then 3 elements then return their sum\\n        while (v.size() <= 3) {\\n            return accumulate(v.begin(), v.end(), 0);\\n        }\\n        \\n        n = v.size();\\n        \\n        /* v[0] v[1] v[2] ... v[i] .... v[j] ... v[k] ... v[n-2] v[n-1]\\n         *                    v[i]  <=  v[j]  <= v[k] always, because we sorted our array. \\n         * Now, for each number, v[i] : we look for pairs v[j] & v[k] such that \\n         * absolute value of (target - (v[i] + v[j] + v[k]) is minimised.\\n         * if the sum of the triplet is greater then the target it implies\\n         * we need to reduce our sum, so we do K = K - 1, that is we reduce\\n         * our sum by taking a smaller number.\\n         * Simillarly if sum of the triplet is less then the target then we\\n         * increase out sum by taking a larger number, i.e. J = J + 1.\\n         */\\n        ans = v[0] + v[1] + v[2];\\n        for (int i = 0; i < n-2; i++) {\\n            int j = i + 1;\\n            int k = n - 1;\\n            while (j < k) {\\n                sum = v[i] + v[j] + v[k];\\n                if (abs(target - ans) > abs(target - sum)) {\\n                    ans = sum;\\n                    if (ans == target) return ans;\\n                }\\n                (sum > target) ? k-- : j++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n<b>Edit:</b>Thanks @thr for pointing out that. I have corrected it and also renamed 'mx' by 'ans'.\\n  [1]: http://stackoverflow.com/questions/2070359/finding-three-elements-in-an-array-whose-sum-is-closest-to-an-given-number",
                "codeTag": "Unknown"
            },
            {
                "id": 8026,
                "title": "python-solution-two-pointer",
                "content": "        \\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        res = sum(nums[:3])\\n        for i in xrange(len(nums)):\\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                s = sum((nums[i], nums[l], nums[r]))\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s < target:\\n                    l += 1\\n                elif s > target:\\n                    r -= 1\\n                else: # break early \\n                    return res\\n        return res",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "        \\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        res = sum(nums[:3])\\n        for i in xrange(len(nums)):\\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                s = sum((nums[i], nums[l], nums[r]))\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s < target:\\n                    l += 1\\n                elif s > target:\\n                    r -= 1\\n                else: # break early \\n                    return res\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1042348,
                "title": "faster-solution-about-95-faster-and-easy-solution-with-comments",
                "content": "![image](https://assets.leetcode.com/users/images/9acbb0ae-649b-4891-bdb3-21d55ae09a3e_1612031949.8420494.png)\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());//I am going to use Two pointer for that i\\'m sorting it if you want to use some other approch feel free to do that;\\n        int n=nums.size();\\n\\n        int sum=nums[0]+nums[1]+nums[2];//Our Intial sum or assuption that intial three values are the closet sum\\n        for(int i=0;i<n-2;i++){ //n-2 Since we have taken n-1 in our point so no need to go beyond that\\n            //Implementing Two pointer technique\\n            int j=i+1;\\n            int k=n-1;\\n            while(j<k){\\n                int temp=nums[i]+nums[j]+nums[k];//Temparory sum for comaprison\\n                if(abs(temp-target) < abs(sum-target) ) sum=temp;//if we find batter or closer sum then we update the above sum value\\n                if(temp>target){\\n                    k--;                  // if value is greater than target one just come one point right to left\\n                } else if(temp<target){\\n                    j++;             //if value is lower than target just come one point left to right \\n                    \\n                }else return target;// if value already found no need to go for other just return \\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```Hey Folk I\\'m using Two Pointer technique technique if you really want to appreciate and fount it batter*** please Up vote Thank You:)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());//I am going to use Two pointer for that i\\'m sorting it if you want to use some other approch feel free to do that;\\n        int n=nums.size();\\n\\n        int sum=nums[0]+nums[1]+nums[2];//Our Intial sum or assuption that intial three values are the closet sum\\n        for(int i=0;i<n-2;i++){ //n-2 Since we have taken n-1 in our point so no need to go beyond that\\n            //Implementing Two pointer technique\\n            int j=i+1;\\n            int k=n-1;\\n            while(j<k){\\n                int temp=nums[i]+nums[j]+nums[k];//Temparory sum for comaprison\\n                if(abs(temp-target) < abs(sum-target) ) sum=temp;//if we find batter or closer sum then we update the above sum value\\n                if(temp>target){\\n                    k--;                  // if value is greater than target one just come one point right to left\\n                } else if(temp<target){\\n                    j++;             //if value is lower than target just come one point left to right \\n                    \\n                }else return target;// if value already found no need to go for other just return \\n            }\\n            \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778177,
                "title": "python3-runtime-52-ms-faster-than-99-77",
                "content": "Easy recursive solution, works for any k, not only for 3\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365626,
                "title": "c-python-two-pointers-clean-concise",
                "content": "**Idea**\\n- Sort `nums` in increasing order.\\n- Let\\'s fix `nums[i]` by iterating `i` in range `[0..n-2]`, we using 2 pointers to find 2 elements in range `[i+1..n-1]`, so that `nums[i] + nums[l] + nums[r]` will have minimum difference with our `target`.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        ans = nums[0] + nums[1] + nums[2]\\n        for i in range(n-2):\\n            l, r = i + 1, n - 1\\n            while l < r:\\n                sum3 = nums[i] + nums[l] + nums[r]\\n                if abs(ans - target) > abs(sum3 - target):\\n                    ans = sum3\\n                if sum3 == target: return target\\n                if sum3 > target:\\n                    r -= 1  # Sum3 is greater than the target, to minimize the difference, we have to decrease our sum3\\n                else:\\n                    l += 1  # Sum3 is lesser than the target, to minimize the difference, we have to increase our sum3\\n        return ans\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), ans = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n-2; ++i) {\\n            int l = i + 1, r = n - 1;\\n            while (l < r) {\\n                int sum3 = nums[i] + nums[l] + nums[r];\\n                if (abs(ans - target) > abs(sum3 - target)) // Update better ans\\n                    ans = sum3;\\n                if (sum3 == target) break;\\n                if (sum3 > target)\\n                    --r; // Sum3 is greater than the target, to minimize the difference, we have to decrease our sum3\\n                else\\n                    ++l; // Sum3 is lesser than the target, to minimize the difference, we have to increase our sum3\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Complexity**\\n- Time: `O(N^2)`, where `N <= 10^3` is number of elements in array `nums`.\\n- Space: from `O(sorting)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        ans = nums[0] + nums[1] + nums[2]\\n        for i in range(n-2):\\n            l, r = i + 1, n - 1\\n            while l < r:\\n                sum3 = nums[i] + nums[l] + nums[r]\\n                if abs(ans - target) > abs(sum3 - target):\\n                    ans = sum3\\n                if sum3 == target: return target\\n                if sum3 > target:\\n                    r -= 1  # Sum3 is greater than the target, to minimize the difference, we have to decrease our sum3\\n                else:\\n                    l += 1  # Sum3 is lesser than the target, to minimize the difference, we have to increase our sum3\\n        return ans\\n```\n```c++\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size(), ans = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n-2; ++i) {\\n            int l = i + 1, r = n - 1;\\n            while (l < r) {\\n                int sum3 = nums[i] + nums[l] + nums[r];\\n                if (abs(ans - target) > abs(sum3 - target)) // Update better ans\\n                    ans = sum3;\\n                if (sum3 == target) break;\\n                if (sum3 > target)\\n                    --r; // Sum3 is greater than the target, to minimize the difference, we have to decrease our sum3\\n                else\\n                    ++l; // Sum3 is lesser than the target, to minimize the difference, we have to increase our sum3\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147500,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        \\n        let sorted = nums.sorted()\\n        let length = sorted.count\\n        \\n        var diff: Int = .max\\n        var result = 0\\n        \\n        for i in 0..<length - 2 {\\n            var n = i + 1, q = length - 1\\n            while n < q {\\n                let sum = sorted[i] + sorted[n] + sorted[q]\\n                \\n                sum > target ? (q -= 1) : (n += 1)\\n                \\n                let value =  abs(sum - target)\\n                \\n                if value < diff {\\n                    diff = value\\n                    result = sum\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 1 test, with 0 failures (0 unexpected) in 0.004 (0.006) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test() {\\n        let value = solution.threeSumClosest([-1,2,1,-4], 1)\\n        XCTAssertEqual(value, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        \\n        let sorted = nums.sorted()\\n        let length = sorted.count\\n        \\n        var diff: Int = .max\\n        var result = 0\\n        \\n        for i in 0..<length - 2 {\\n            var n = i + 1, q = length - 1\\n            while n < q {\\n                let sum = sorted[i] + sorted[n] + sorted[q]\\n                \\n                sum > target ? (q -= 1) : (n += 1)\\n                \\n                let value =  abs(sum - target)\\n                \\n                if value < diff {\\n                    diff = value\\n                    result = sum\\n                }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test() {\\n        let value = solution.threeSumClosest([-1,2,1,-4], 1)\\n        XCTAssertEqual(value, 2)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352747,
                "title": "java-3-pointers-explained",
                "content": "**Idea:** Similar to [LC 15. 3Sum](https://leetcode.com/problems/3sum/discuss/339850/Java-or-Two-pointers-or-Time-beats-100-or-Memory-beats-93)\\n* Sort the array and have 3 pointers: at start, at end of the array and one moving from start + 1 to end - 1\\n* If sum of numbers at these 3 pointers equals target, then exit with target\\n* Else if sum < target, it means you need to add more to the sum, so move middle pointer forward\\n* Else move the end pointer backwards because the sum is too high\\n* Keep a running minimum difference to find the closest the sum gets to target\\n>**T/S:** O(n\\xB2)/O(n), where n = size(nums)\\nArrays.sort uses dual pivot quick sort which takes extra O(n) space\\n```\\npublic int threeSumClosest(int[] nums, int target) {\\n\\tvar closest = 0;\\n\\tvar n = nums.length;\\n\\tvar minDiff = Integer.MAX_VALUE;\\n\\tArrays.sort(nums);\\n\\n\\tfor (var i = 0; i < n - 2; i++) {\\n\\t\\tvar k = n - 1;\\n\\n\\t\\tfor (var j = i + 1; j < k;) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\n\\t\\t\\tif (sum == target)\\n\\t\\t\\t\\treturn target;\\n\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\tj++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk--;\\n\\n\\t\\t\\tvar diff = Math.abs(target - sum);\\n\\t\\t\\tif (diff < minDiff) {\\n\\t\\t\\t\\tminDiff = diff;\\n\\t\\t\\t\\tclosest = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn closest;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int threeSumClosest(int[] nums, int target) {\\n\\tvar closest = 0;\\n\\tvar n = nums.length;\\n\\tvar minDiff = Integer.MAX_VALUE;\\n\\tArrays.sort(nums);\\n\\n\\tfor (var i = 0; i < n - 2; i++) {\\n\\t\\tvar k = n - 1;\\n\\n\\t\\tfor (var j = i + 1; j < k;) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\n\\t\\t\\tif (sum == target)\\n\\t\\t\\t\\treturn target;\\n\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\tj++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk--;\\n\\n\\t\\t\\tvar diff = Math.abs(target - sum);\\n\\t\\t\\tif (diff < minDiff) {\\n\\t\\t\\t\\tminDiff = diff;\\n\\t\\t\\t\\tclosest = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn closest;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7987,
                "title": "12-lines-concise-and-easy-understand-c-solultion",
                "content": "    class Solution {\\n    public:\\n        int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(), nums.end());\\n            int res = nums[0] + nums[1] + nums[2];\\n            for(int i = 0; i < nums.size() - 2; i++){\\n                int j = i + 1, k = nums.size() - 1;\\n                while(j < k){\\n                    int num = nums[i] + nums[j] + nums[k];\\n                    if(abs(num - target) < abs(res - target)) res = num;\\n                    if(num < target) j++;\\n                    else k--;\\n                }\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(), nums.end());\\n            int res = nums[0] + nums[1] + nums[2];\\n            for(int i = 0; i < nums.size() - 2; i++){\\n                int j = i + 1, k = nums.size() - 1;\\n                while(j < k){\\n                    int num = nums[i] + nums[j] + nums[k];\\n                    if(abs(num - target) < abs(res - target)) res = num;\\n                    if(num < target) j++;\\n                    else k--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2194572,
                "title": "python-accepted-solution-getting-tle-now",
                "content": "It seems like ~250 new test cases have been added to the problem recently which are now causing TLEs to previously accepted programs. See this submission of mine from March 2022 - https://leetcode.com/submissions/detail/666408027/. The same is now getting a TLE even after adding the optimization of skipping computations for duplicate elements.  \\n\\n**Solution which got accepted before but now giving TLE**\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        if len(nums) == 3:\\n            return sum(nums)\\n        \\n        nums = sorted(nums)\\n        minSum, minDiff = None, float(\\'inf\\')\\n        \\n        for i in range(len(nums)-2):\\n            left, right = i+1, len(nums)-1\\n            \\n            while left < right:\\n                currSum = nums[i] + nums[left] + nums[right]\\n                currDiff = abs(target - currSum)\\n\\n                if currDiff < minDiff:\\n                    minDiff = currDiff\\n                    minSum = currSum\\n\\n                if minDiff == 0:\\n                    return minSum\\n\\n                if target > currSum:\\n                    left += 1\\n                else:\\n                    right -= 1\\n        \\n        return minSum\\n```\\n\\n\\n**Optimized solution - also giving TLE**\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        N = len(nums)\\n        if N == 3:\\n            return sum(nums)\\n        \\n        nums = sorted(nums)\\n        minSum, minDiff = None, inf\\n        \\n        for i in range(N-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n\\n            left, right = i+1, N-1\\n            \\n            while left < right:\\n                currSum = sum([nums[i], nums[left], nums[right]])\\n                currDiff = abs(target - currSum)\\n\\n                if currDiff < minDiff:\\n                    minDiff = currDiff\\n                    minSum = currSum\\n\\n                    if minDiff == 0:\\n                        return minSum\\n\\n                if target > currSum:\\n                    left += 1\\n                    while left < right and nums[left] == nums[left-1]:\\n                        left += 1\\n                else:\\n                    right -= 1\\n                    while left < right and nums[right] == nums[right+1]:\\n                        right -= 1\\n        \\n        return minSum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        if len(nums) == 3:\\n            return sum(nums)\\n        \\n        nums = sorted(nums)\\n        minSum, minDiff = None, float(\\'inf\\')\\n        \\n        for i in range(len(nums)-2):\\n            left, right = i+1, len(nums)-1\\n            \\n            while left < right:\\n                currSum = nums[i] + nums[left] + nums[right]\\n                currDiff = abs(target - currSum)\\n\\n                if currDiff < minDiff:\\n                    minDiff = currDiff\\n                    minSum = currSum\\n\\n                if minDiff == 0:\\n                    return minSum\\n\\n                if target > currSum:\\n                    left += 1\\n                else:\\n                    right -= 1\\n        \\n        return minSum\\n```\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        N = len(nums)\\n        if N == 3:\\n            return sum(nums)\\n        \\n        nums = sorted(nums)\\n        minSum, minDiff = None, inf\\n        \\n        for i in range(N-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n\\n            left, right = i+1, N-1\\n            \\n            while left < right:\\n                currSum = sum([nums[i], nums[left], nums[right]])\\n                currDiff = abs(target - currSum)\\n\\n                if currDiff < minDiff:\\n                    minDiff = currDiff\\n                    minSum = currSum\\n\\n                    if minDiff == 0:\\n                        return minSum\\n\\n                if target > currSum:\\n                    left += 1\\n                    while left < right and nums[left] == nums[left-1]:\\n                        left += 1\\n                else:\\n                    right -= 1\\n                    while left < right and nums[right] == nums[right+1]:\\n                        right -= 1\\n        \\n        return minSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7913,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**3Sum Closest** https://leetcode.com/problems/3sum-closest/\\n\\n**Brute-force: O(N^3)**\\n* Brute force solution will be O(N^3). We end up testing every subset and update the closest sum in every iteration.\\n\\n**Two Pointer Solution: O(N^2)**\\n* We can use the two pointer method to reduce complexity to O(N^2). We begin by sorting the array.\\n* Now we use three indices i,j and k. We iterate i from 0 to N (actually till N-2 is fine). We initialize j to i+1 and k to N-1.\\n* Now we compute curr_sum = nums[i]+nums[j]+nums[k]. If this equals target, we have the closest sum.\\n* Otherwise update closest_sum using the rule abs(curr_sum-target) < abs(closest_sum-target).\\n* Now what if curr_sum is less than target. Should we test (nums[i]+nums[j]+nums[k-1]), (nums[i]+nums[j]+nums[k-2]), (nums[i]+nums[j]+nums[k-3]) ? The answer is NO. All of these triplets will be less than curr_sum. And curr_sum is less than target - so there is no point testing these triplets. We must move forward by advancing j to j + 1 in the hope to get a larger triplet. This is the main intuition in this problem.\\n* You can visualize (6) by thinking all possible triplet sums sorted and arranged on a number line. When you find a curr_sum less than target, you increase curr_sum by increasing j. When you find a curr_sum less more than target, you reduce curr_sum by reducing k\\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        closest_sum = 2**31-1\\n        for i in range(len(nums)):\\n            j,k = i+1, len(nums)-1\\n            while j<k:\\n                curr_sum = nums[i] + nums[j] + nums[k]\\n                if curr_sum == target:\\n                    return curr_sum\\n                if abs(curr_sum-target) < abs(closest_sum-target):\\n                    closest_sum = curr_sum\\n                if curr_sum < target:\\n                    j = j+1\\n                else:\\n                    k = k-1\\n        return closest_sum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        closest_sum = 2**31-1\\n        for i in range(len(nums)):\\n            j,k = i+1, len(nums)-1\\n            while j<k:\\n                curr_sum = nums[i] + nums[j] + nums[k]\\n                if curr_sum == target:\\n                    return curr_sum\\n                if abs(curr_sum-target) < abs(closest_sum-target):\\n                    closest_sum = curr_sum\\n                if curr_sum < target:\\n                    j = j+1\\n                else:\\n                    k = k-1\\n        return closest_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365711,
                "title": "c-simple-and-concise-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size(), j, k, res = nums[0] + nums[1] + nums[2], curr;\\n        sort(nums.begin(), nums.end());\\n        \\n        for (int i = 0; i < n; i++) {\\n            j = i + 1, k = n - 1;\\n            \\n            while (j < k) {\\n                curr = nums[i] + nums[j] + nums[k];\\n                if (abs(curr - target) < abs(res - target)) \\n                    res = curr;\\n                \\n                if (curr < target) j++;\\n                else k--;\\n                    \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size(), j, k, res = nums[0] + nums[1] + nums[2], curr;\\n        sort(nums.begin(), nums.end());\\n        \\n        for (int i = 0; i < n; i++) {\\n            j = i + 1, k = n - 1;\\n            \\n            while (j < k) {\\n                curr = nums[i] + nums[j] + nums[k];\\n                if (abs(curr - target) < abs(res - target)) \\n                    res = curr;\\n                \\n                if (curr < target) j++;\\n                else k--;\\n                    \\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481580,
                "title": "javascript-solution",
                "content": "### The idea\\n1. Sort the input array\\n2. Use two pointers `left` & `right` to calculate a local sum, compare the target with the local sum\\n``` javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let closest = Infinity;\\n    for (let i=0;i<nums.length-2;i++) {\\n        let left = i+1; right = nums.length-1;\\n        while (left < right) {\\n            let localSum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(localSum - target) < Math.abs(closest - target)) closest = localSum;\\n            if (localSum > target) right--;\\n            else left++;\\n        }\\n    }\\n    return closest;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let closest = Infinity;\\n    for (let i=0;i<nums.length-2;i++) {\\n        let left = i+1; right = nums.length-1;\\n        while (left < right) {\\n            let localSum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(localSum - target) < Math.abs(closest - target)) closest = localSum;\\n            if (localSum > target) right--;\\n            else left++;\\n        }\\n    }\\n    return closest;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3736495,
                "title": "java-fastest-and-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/5c5c0ba7-1c0d-4826-9c1e-c86de4dcb9db_1688821081.4729018.png)\\n\\n\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closestSum = nums[0] + nums[1] + nums[2]; // Initialize closest sum with the sum of the first three elements\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n\\n            while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if (Math.abs(target - sum) < Math.abs(target - closestSum)) {\\n                    closestSum = sum; // Update closest sum if the current sum is closer to the target\\n                }\\n\\n                if (sum < target) {\\n                    j++; // Increment j to increase the sum\\n                } else {\\n                    k--; // Decrement k to decrease the sum\\n                }\\n            }\\n        }\\n\\n        return closestSum;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closestSum = nums[0] + nums[1] + nums[2]; // Initialize closest sum with the sum of the first three elements\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n\\n            while (j < k) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                if (Math.abs(target - sum) < Math.abs(target - closestSum)) {\\n                    closestSum = sum; // Update closest sum if the current sum is closer to the target\\n                }\\n\\n                if (sum < target) {\\n                    j++; // Increment j to increase the sum\\n                } else {\\n                    k--; // Decrement k to decrease the sum\\n                }\\n            }\\n        }\\n\\n        return closestSum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 164611,
                "title": "logical-thinking-with-code-beats-99-33",
                "content": "**Logical Thinking**\\nIf a candidate number `nums[pre]` is given, the problem is decreased to the **Two-sum Closest** problem -  find two integers in nums such that the sum is closest to `target - nums[pre]`. We need to try all possible `nums[pre]`.\\nWe\\'d better sort `nums[]` first. In this way, we can apply **Binary Search** in `2Sum Closest` rather than **Exhaustive Search**.\\n\\n**Trick**\\nThe condition to terminate **Binary Search** is not \\'`no searching space`\\' but \\'`not enough searching space`\\' for we need to maintain two valid candidates in the searching space `[lo, hi]` both inclusive.\\n\\n**Clear Code**\\n```\\n    public int threeSumClosest(int[] nums, int target) {\\n        \\n        if (nums == null || nums.length < 3) {\\n            throw new IllegalArgumentException();\\n        }\\n\\n        Arrays.sort(nums);\\n        int n = nums.length, minDiff = Integer.MAX_VALUE, sumClosest = -1;\\n        \\n        for (int pre = 0; pre < n; pre++) {\\n            int lo = pre + 1;\\n            int hi = n - 1;\\n            while (lo < hi) {\\n                int curTarget = target - nums[pre];\\n                int curSum = nums[lo] + nums[hi];\\n                if (curSum < curTarget) { \\n                    if (curTarget - curSum < minDiff) {\\n                        minDiff = curTarget - curSum;\\n                        sumClosest = curSum + nums[pre];\\n                    }\\n                    lo++;\\n                    continue;\\n                }\\n                if (curSum > curTarget) {\\n                    if (curSum - curTarget < minDiff) {\\n                        minDiff = curSum - curTarget;\\n                        sumClosest = curSum + nums[pre];\\n                    }\\n                    hi--;\\n                    continue;\\n                }\\n                return curSum + nums[pre];\\n            }\\n        }\\n        \\n        return sumClosest;\\n    }\\n```\\n**I would appreciate your VOTE UP ;)**",
                "solutionTags": [],
                "code": "```\\n    public int threeSumClosest(int[] nums, int target) {\\n        \\n        if (nums == null || nums.length < 3) {\\n            throw new IllegalArgumentException();\\n        }\\n\\n        Arrays.sort(nums);\\n        int n = nums.length, minDiff = Integer.MAX_VALUE, sumClosest = -1;\\n        \\n        for (int pre = 0; pre < n; pre++) {\\n            int lo = pre + 1;\\n            int hi = n - 1;\\n            while (lo < hi) {\\n                int curTarget = target - nums[pre];\\n                int curSum = nums[lo] + nums[hi];\\n                if (curSum < curTarget) { \\n                    if (curTarget - curSum < minDiff) {\\n                        minDiff = curTarget - curSum;\\n                        sumClosest = curSum + nums[pre];\\n                    }\\n                    lo++;\\n                    continue;\\n                }\\n                if (curSum > curTarget) {\\n                    if (curSum - curTarget < minDiff) {\\n                        minDiff = curSum - curTarget;\\n                        sumClosest = curSum + nums[pre];\\n                    }\\n                    hi--;\\n                    continue;\\n                }\\n                return curSum + nums[pre];\\n            }\\n        }\\n        \\n        return sumClosest;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1179560,
                "title": "c-two-pointer-approach-3-sum-variation",
                "content": "\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        int res = 0;\\n        int min_diff = INT_MAX;\\n        \\n        for(int i = 0; i < n - 2; i++)\\n        {\\n            int j = i + 1;\\n            int k = n - 1;\\n            \\n            while(j < k)\\n            {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(abs(target - sum) < min_diff)\\n                {\\n                    min_diff = abs(target - sum);\\n                    res = sum;\\n                }\\n                if(sum > target)\\n                    k--;\\n                else \\n                    j++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        \\n        int res = 0;\\n        int min_diff = INT_MAX;\\n        \\n        for(int i = 0; i < n - 2; i++)\\n        {\\n            int j = i + 1;\\n            int k = n - 1;\\n            \\n            while(j < k)\\n            {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(abs(target - sum) < min_diff)\\n                {\\n                    min_diff = abs(target - sum);\\n                    res = sum;\\n                }\\n                if(sum > target)\\n                    k--;\\n                else \\n                    j++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3116265,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int diff=INT_MAX;\\n        int ans=0;\\n     sort(nums.begin(), nums.end());\\n for(int i=0;i<nums.size()-2;i++){\\n     int low=i+1;\\n     int high=nums.size()-1;\\n     int first=nums[i];\\n     while(low<high){\\n         if(first+nums[low]+nums[high]==target){\\n             return target;\\n         }\\n         else if(abs(first+nums[low]+nums[high]-target)<diff){\\n             diff=abs(first+nums[low]+nums[high]-target);\\n             ans=first+nums[low]+nums[high];\\n         }\\n         if(first+nums[low]+nums[high]<target){\\n             low++; \\n         }\\n        else{ high--;\\n            }\\n     }\\n }              \\n        return ans;\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int diff=INT_MAX;\\n        int ans=0;\\n     sort(nums.begin(), nums.end());\\n for(int i=0;i<nums.size()-2;i++){\\n     int low=i+1;\\n     int high=nums.size()-1;\\n     int first=nums[i];\\n     while(low<high){\\n         if(first+nums[low]+nums[high]==target){\\n             return target;\\n         }\\n         else if(abs(first+nums[low]+nums[high]-target)<diff){\\n             diff=abs(first+nums[low]+nums[high]-target);\\n             ans=first+nums[low]+nums[high];\\n         }\\n         if(first+nums[low]+nums[high]<target){\\n             low++; \\n         }\\n        else{ high--;\\n            }\\n     }\\n }              \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159984,
                "title": "something-wrong-with-python3-interpreter",
                "content": "Something is wrong with the way the leetcode environment is processing python3 code! It is executing most code in far longer than it should.\\n\\nAt first I thought I just had a poor solution, but then I noticed that mine was functionally identical to the \\'correct\\' ones. I then copy and pasted previous examples of middle of the road times (~300ms): now they are exceeding time limit or are in the 9000ms+ range!\\n\\nConsider the following - its not my code, but an \"example 290ms\" one:\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = float(\\'inf\\')\\n        for i in range(len(nums)):\\n            l, r = i + 1, len(nums) - 1\\n            while l < r:\\n                s = nums[i] + nums[l] + nums[r]\\n                if abs(s - target) < abs(res - target):\\n                    res = s\\n                if s == target:\\n                    return target\\n                elif s < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return res\\n```\\n\\nThis code copy pasted in exceeds the time limit, rather than being in the ~300ms range.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = float(\\'inf\\')\\n        for i in range(len(nums)):\\n            l, r = i + 1, len(nums) - 1\\n            while l < r:\\n                s = nums[i] + nums[l] + nums[r]\\n                if abs(s - target) < abs(res - target):\\n                    res = s\\n                if s == target:\\n                    return target\\n                elif s < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7963,
                "title": "u3010python-u3011beating-95-solution-with-two-pointers-u3010o-n-2-u3011",
                "content": "Same algorithm as 3sum problem, where we sort `nums`, then use two pointers to check all the possible combinations, while fixing one element. \\n\\nIn this problem, we just need to add a new variable `diff` to track the difference between target and current best result. In addition, we move the pointers in terms of `diff` (be careful with the sign)\\n\\n    \\n    def threeSumClosest(self, nums, target):\\n        result, diff = 0, sys.maxint\\n        nums.sort()\\n        \\n        for i in xrange(len(nums) - 2):\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n            \\n            left, right = i + 1, len(nums) - 1\\n            \\n            while left < right:\\n                total = nums[i] + nums[left] + nums[right]\\n                hold_diff = abs (total - target)\\n                \\n                if not hold_diff:\\n                    return total\\n                    \\n                if hold_diff  < diff:\\n                    result = total\\n                    diff = hold_diff\\n                    \\n                if total < target:\\n                    left += 1\\n                \\n                else:\\n                    right -= 1\\n                    \\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "Same algorithm as 3sum problem, where we sort `nums`, then use two pointers to check all the possible combinations, while fixing one element. \\n\\nIn this problem, we just need to add a new variable `diff` to track the difference between target and current best result. In addition, we move the pointers in terms of `diff` (be careful with the sign)\\n\\n    \\n    def threeSumClosest(self, nums, target):\\n        result, diff = 0, sys.maxint\\n        nums.sort()\\n        \\n        for i in xrange(len(nums) - 2):\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                continue\\n            \\n            left, right = i + 1, len(nums) - 1\\n            \\n            while left < right:\\n                total = nums[i] + nums[left] + nums[right]\\n                hold_diff = abs (total - target)\\n                \\n                if not hold_diff:\\n                    return total\\n                    \\n                if hold_diff  < diff:\\n                    result = total\\n                    diff = hold_diff\\n                    \\n                if total < target:\\n                    left += 1\\n                \\n                else:\\n                    right -= 1\\n                    \\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 2674627,
                "title": "java-sorting-two-pointers-approach",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        int minDiff=Integer.MAX_VALUE;\\n        int ans=0;\\n        for(int i=0;i<n-2;i++){\\n            int low=i+1,high=n-1;\\n            while(low<high){\\n                int temp=nums[i]+nums[low]+nums[high];\\n                if(Math.abs(target-temp)<minDiff){\\n                    ans=temp;\\n                    minDiff=Math.abs(target-temp);\\n                }\\n                if(temp==target){\\n                    return target;\\n                }\\n                else if(temp>target){\\n                        high--;\\n                }\\n                else{\\n                    low++;\\n                }\\n            }\\n        }\\n        return ans;\\n            \\n    }       \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n=nums.length;\\n        int minDiff=Integer.MAX_VALUE;\\n        int ans=0;\\n        for(int i=0;i<n-2;i++){\\n            int low=i+1,high=n-1;\\n            while(low<high){\\n                int temp=nums[i]+nums[low]+nums[high];\\n                if(Math.abs(target-temp)<minDiff){\\n                    ans=temp;\\n                    minDiff=Math.abs(target-temp);\\n                }\\n                if(temp==target){\\n                    return target;\\n                }\\n                else if(temp>target){\\n                        high--;\\n                }\\n                else{\\n                    low++;\\n                }\\n            }\\n        }\\n        return ans;\\n            \\n    }       \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938326,
                "title": "most-efficient-python-code-that-beats-90-submissions-with-easiest-explanation",
                "content": "**Intution:**\\nWe\\'ll use **Three-pointer** approach in this question.\\nSort the given list in ascending order.\\nA pointer lets say \\'i\\' will be used to iterate through the given list nums.\\nWithin that loop, two more pointers lets say \\'start\\' and \\'end\\' would be initialised as follows:\\n\\tstart=i+1\\n\\tend=len(nums)-1\\nNow within this loop we will run another loop until the value of start in less than end.\\nTake a variable lets say \\'sum\\' to store value of nums[i]+nums[start]+nums[end].\\nIn this loop we would be checking for **3 conditions**.\\n**Condition 1:**\\nif **sum==target**, the sum contains the required answer as the minimum possible difference between any two numbers is 0 and sum-target will also give 0 in this case.\\n**Condition 2:**\\nif difference in target and sum is less than value contained by our \\'diff\\' variable(initialized with maximum possible value) the the diff would become equal to the absolute difference in target and sum and answer variable \\'ans\\' would be assigned the value of \\'sum\\', as this sum gives the minimum difference till now.\\n**Condition 3:\"**\\nWe\\'ll check if the value of sum is greater than target then the end will be decremented by one or else the start in incremented by one in case the sum is less than target.\\n**Code:**\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums=sorted(nums)\\n        diff=float(\\'inf\\')\\n        for i in range(len(nums)-1):\\n            start=i+1\\n            end=len(nums)-1\\n            while(start<end):\\n                sum=nums[i]+nums[start]+nums[end]\\n                if sum==target:\\n                    return target\\n                elif abs(target-sum)<diff:\\n                    diff=abs(target-sum)\\n                    ans=sum\\n                if sum>target:\\n                    end-=1\\n                else:\\n                    start+=1\\n        return ans\\n```\\n\\n**Complexity Analysis:**\\nTime Complexity:\\nO(n^2)\\nSpace Complexity:\\nO(1) [constant]\\n**PLEASE UPVOTE THE ANSWER TO MOTIVATE ME FOR CONTINUING THE COMMUNITY SUPPORT**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums=sorted(nums)\\n        diff=float(\\'inf\\')\\n        for i in range(len(nums)-1):\\n            start=i+1\\n            end=len(nums)-1\\n            while(start<end):\\n                sum=nums[i]+nums[start]+nums[end]\\n                if sum==target:\\n                    return target\\n                elif abs(target-sum)<diff:\\n                    diff=abs(target-sum)\\n                    ans=sum\\n                if sum>target:\\n                    end-=1\\n                else:\\n                    start+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493316,
                "title": "c-java-python-javascript-o-n-2logn-using-two-pointers",
                "content": "# Intuition:\\n\\nThe problem requires us to find a triplet of numbers in the given array, such that their sum is closest to the given target. We can use the two-pointer approach along with sorting the array to solve this problem.\\n\\n# Approach:\\n\\n1. Sort the given array in non-descending order.\\n2. Initialize a variable closest_sum to store the closest sum found so far. Set it initially to the sum of first three elements in the sorted array.\\n3. Loop over the array from i=0 to i=n-3, where n is the size of the array.\\n4. For each i, initialize two pointers, left and right, to i+1 and n-1 respectively.\\n5. While left < right, calculate the sum of the current triplet, sum = nums[i] + nums[left] + nums[right].\\n6. If sum is equal to the target, we have found the closest sum possible, so we can return it immediately.\\n7. If sum is less than target, increment left by 1. This will increase the sum, and we may get a closer sum.\\n8. If sum is greater than target, decrement right by 1. This will decrease the sum, and we may get a closer sum.\\n9. After each iteration of the inner loop, check if the absolute difference between sum and target is less than the absolute difference between closest_sum and target. If it is, update closest_sum to sum.\\n10. Return closest_sum after the loop ends.\\n# Complexity:\\n- Time Complexity: Sorting the array takes O(nlogn) time. The two-pointer approach runs in O(n^2) time. Therefore, the overall time complexity of the solution is O(n^2logn).\\n\\n- Space Complexity: We are not using any extra space in the solution. Therefore, the space complexity of the solution is O(1).\\n\\n---\\n\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) { // two-pointer approach\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum == target) { // sum equals target, return immediately\\n                    return sum;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                if (abs(sum - target) < abs(closest_sum - target)) { // update closest sum\\n                    closest_sum = sum;\\n                }\\n            }\\n        }\\n        return closest_sum;\\n    }\\n};\\n\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) { // two-pointer approach\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum == target) { // sum equals target, return immediately\\n                    return sum;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { // update closest sum\\n                    closest_sum = sum;\\n                }\\n            }\\n        }\\n        return closest_sum;\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        n = len(nums)\\n        closest_sum = nums[0] + nums[1] + nums[2] # initialize closest sum\\n        for i in range(n - 2):\\n            left, right = i + 1, n - 1\\n            while left < right: # two-pointer approach\\n                sum = nums[i] + nums[left] + nums[right]\\n                if sum == target: # sum equals target, return immediately\\n                    return sum\\n                elif sum < target:\\n                    left += 1\\n                else:\\n                    right -= 1\\n                if abs(sum - target) < abs(closest_sum - target): # update closest sum\\n                    closest_sum = sum\\n        return closest_sum\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let n = nums.length;\\n    let closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n    for (let i = 0; i < n - 2; i++) {\\n        let left = i + 1, right = n - 1;\\n        while (left < right) { // two-pointer approach\\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (sum == target) { // sum equals target, return immediately\\n                return sum;\\n            } else if (sum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n            if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { // update closest sum\\n                closest_sum = sum;\\n            }\\n        }\\n    }\\n    return closest_sum;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) { // two-pointer approach\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum == target) { // sum equals target, return immediately\\n                    return sum;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                if (abs(sum - target) < abs(closest_sum - target)) { // update closest sum\\n                    closest_sum = sum;\\n                }\\n            }\\n        }\\n        return closest_sum;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) { // two-pointer approach\\n                int sum = nums[i] + nums[left] + nums[right];\\n                if (sum == target) { // sum equals target, return immediately\\n                    return sum;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { // update closest sum\\n                    closest_sum = sum;\\n                }\\n            }\\n        }\\n        return closest_sum;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        n = len(nums)\\n        closest_sum = nums[0] + nums[1] + nums[2] # initialize closest sum\\n        for i in range(n - 2):\\n            left, right = i + 1, n - 1\\n            while left < right: # two-pointer approach\\n                sum = nums[i] + nums[left] + nums[right]\\n                if sum == target: # sum equals target, return immediately\\n                    return sum\\n                elif sum < target:\\n                    left += 1\\n                else:\\n                    right -= 1\\n                if abs(sum - target) < abs(closest_sum - target): # update closest sum\\n                    closest_sum = sum\\n        return closest_sum\\n\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let n = nums.length;\\n    let closest_sum = nums[0] + nums[1] + nums[2]; // initialize closest sum\\n    for (let i = 0; i < n - 2; i++) {\\n        let left = i + 1, right = n - 1;\\n        while (left < right) { // two-pointer approach\\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (sum == target) { // sum equals target, return immediately\\n                return sum;\\n            } else if (sum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n            if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { // update closest sum\\n                closest_sum = sum;\\n            }\\n        }\\n    }\\n    return closest_sum;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365598,
                "title": "3sum-closest-easy-w-approach-c-java",
                "content": "# **APPROACH:**\\n* Given an `array nums with n integers` and `one target`. We have to find `three integers` in nums such that the **sum is closest to the target**. We will return the sum of the three integers. \\n* We can take one assumption that each input would have exactly one solution. \\n\\n**TESTCASE:**\\nIf the given array is like `[-1,2,1,-4]` and the target is `1`, then the triplet will be `[-1,2,1]` this has the closest sum, that is `2`.\\n\\n# **ALGORITHM:**\\n\\n* Sort the array nums, ans := 0, diff := Infinity, n := size of nums\\n* for i in range 0 to n \\u2013 1\\n\\t* left := i + 1, right := n \\u2013 1\\n\\t* while left < right\\n\\t\\t* temp := nums[left] + nums[right] + nums[i]\\n\\t\\t* If `|target \\u2013 temp| < diff`, then ans := temp and diff := |target \\u2013 temp|\\n\\t\\t* If `temp = target`, then return temp, \\n\\t\\t* Otherwise when `temp > target`, then decrease right by 1, else increase left by 1\\n* return ans\\n\\n# **SOLUTION:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        int diff = INT_MAX ;\\n        int n = nums.size() ;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int left = i + 1;\\n            int right = n - 1;\\n            while(left < right)\\n            {\\n                int temp = nums[left] + nums[right] + nums[i];\\n                if(abs(target - temp) < diff)\\n                {\\n                   ans = temp;\\n                   diff = abs(target - temp);\\n                }\\n                if(temp == target) return temp;\\n                else if(temp > target) right--;\\n                else left++;\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```\\n`In Java`\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b) => a-b)\\n    let diff = Infinity;\\n\\n    for(var i = 0; i < nums.length; i++) {\\n        let j = i + 1;\\n        let k = nums.length - 1\\n    \\n        while(j < k) {\\n            let sum = nums[i]+nums[j]+nums[k]\\n        \\n            if(Math.abs(diff) > Math.abs(target-sum)) \\n\\t\\t\\t{\\n                diff = target - sum\\n            }\\n        \\n            if(sum < target) \\n\\t\\t\\t{\\n                j++\\n            } \\n\\t\\t\\telse \\n\\t\\t\\t{\\n                k--\\n            }\\n        }\\n    }\\n    return target - diff\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        int diff = INT_MAX ;\\n        int n = nums.size() ;\\n        for(int i = 0; i < n; i++)\\n        {\\n            int left = i + 1;\\n            int right = n - 1;\\n            while(left < right)\\n            {\\n                int temp = nums[left] + nums[right] + nums[i];\\n                if(abs(target - temp) < diff)\\n                {\\n                   ans = temp;\\n                   diff = abs(target - temp);\\n                }\\n                if(temp == target) return temp;\\n                else if(temp > target) right--;\\n                else left++;\\n            }\\n        }\\n      return ans;\\n    }\\n};\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b) => a-b)\\n    let diff = Infinity;\\n\\n    for(var i = 0; i < nums.length; i++) {\\n        let j = i + 1;\\n        let k = nums.length - 1\\n    \\n        while(j < k) {\\n            let sum = nums[i]+nums[j]+nums[k]\\n        \\n            if(Math.abs(diff) > Math.abs(target-sum)) \\n\\t\\t\\t{\\n                diff = target - sum\\n            }\\n        \\n            if(sum < target) \\n\\t\\t\\t{\\n                j++\\n            } \\n\\t\\t\\telse \\n\\t\\t\\t{\\n                k--\\n            }\\n        }\\n    }\\n    return target - diff\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848622,
                "title": "java-simple-and-readable-solution-two-pointer",
                "content": "We can regard this quesiton as : \\na+b+c+min(difference) ? target \\nsum = a+b+c\\nthen we transferred the question sucessfully as Two Pointers.\\n\\nSo what we need now is the minimum diff and return sum(which is target - diff) at last\\nWatch out that diff could be both positive and negative, thus just comparing diff is meaningless.\\nWe can slove this by updating the diff original value IFF its absolute value smaller.\\n\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int diff = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int left = i + 1;\\n            int right = nums.length - 1;\\n            \\n            while (left < right) {\\n                int sum  = nums[i] + nums[left] + nums[right];\\n                \\n                if (Math.abs(target - sum) < Math.abs(diff)) {\\n                    diff = target - sum;\\n                }\\n                \\n                if (sum > target) {\\n                    right--;\\n                }\\n                else {\\n                    left++;\\n                }\\n            }\\n        }\\n        return (target-diff);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int diff = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int left = i + 1;\\n            int right = nums.length - 1;\\n            \\n            while (left < right) {\\n                int sum  = nums[i] + nums[left] + nums[right];\\n                \\n                if (Math.abs(target - sum) < Math.abs(diff)) {\\n                    diff = target - sum;\\n                }\\n                \\n                if (sum > target) {\\n                    right--;\\n                }\\n                else {\\n                    left++;\\n                }\\n            }\\n        }\\n        return (target-diff);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430115,
                "title": "7-lines-code-with-detailed-explanation-of-approach-for-beginners-o-n-2-beginner-coders",
                "content": "**First of all the approach of this problem is very similar of 3 sum so i request you all to aleast try this problem.**\\nFirst of all sort the array because without sorting this array two pointer approach has no meaning.\\nuse two pointer approach\\nmake a left pointing next to i and a right pointer at the last element of the array\\nmake a sum variable also make a mini_diffrence variable which keep account of absolute diffrence of sum and target. \\ncheck for the condition if absolute value of \\n**abs**(target - curr_sum) < mini_diff\\nthen assign  target - curr_sum  to mini_diffrence\\n**if sum > target than decrement the right pointer\\nthis this this is the benifit of sorting of array because we can\\'t write this unless the array is sorted**\\n**else increment left pointer.\\nthis this this is the benifit of sorting of array because we can\\'t write this unless the array is sorted**\\n\\n**Time complexity - O(N^2)\\nspace complexity - O(1) as no extra space required**\\n**where N is the number of element in the array**\\n\\n\\n int threeSumClosest(vector<int>& nums, int target) {\\n      \\n     \\n    sort(nums.begin(), nums.end());\\n    \\n    int res = 0 ,  n = nums.size() ,  mini_diff = INT_MAX;\\n  \\n    \\n    for(int i = 0; i < n-2; i++)\\n    {\\n        int left = i + 1 , right = n - 1;\\n        \\n        \\n        while(left < right)\\n        {\\n            int sum = nums[i] + nums[left] + nums[right];\\n    if(abs(target - sum) < mini_diff)  mini_diff = abs(target - sum), res = sum;\\n            \\n            if(sum > target)  right--;\\n              \\n            else   left++;\\n              \\n        }\\n    }\\n    \\n    return res;\\n}\\n\\n\\n//Guys plz plz plz upvote my solution if you really like it and understand it.and comment here if there is any doubt or new suggestion.\\n//Stay Safe and Keep Coding Guys!!!!\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "**First of all the approach of this problem is very similar of 3 sum so i request you all to aleast try this problem.**\\nFirst of all sort the array because without sorting this array two pointer approach has no meaning.\\nuse two pointer approach\\nmake a left pointing next to i and a right pointer at the last element of the array\\nmake a sum variable also make a mini_diffrence variable which keep account of absolute diffrence of sum and target. \\ncheck for the condition if absolute value of \\n**abs**(target - curr_sum) < mini_diff\\nthen assign  target - curr_sum  to mini_diffrence\\n**if sum > target than decrement the right pointer\\nthis this this is the benifit of sorting of array because we can\\'t write this unless the array is sorted**\\n**else increment left pointer.\\nthis this this is the benifit of sorting of array because we can\\'t write this unless the array is sorted**\\n\\n**Time complexity - O(N^2)\\nspace complexity - O(1) as no extra space required**\\n**where N is the number of element in the array**\\n\\n\\n int threeSumClosest(vector<int>& nums, int target) {\\n      \\n     \\n    sort(nums.begin(), nums.end());\\n    \\n    int res = 0 ,  n = nums.size() ,  mini_diff = INT_MAX;\\n  \\n    \\n    for(int i = 0; i < n-2; i++)\\n    {\\n        int left = i + 1 , right = n - 1;\\n        \\n        \\n        while(left < right)\\n        {\\n            int sum = nums[i] + nums[left] + nums[right];\\n    if(abs(target - sum) < mini_diff)  mini_diff = abs(target - sum), res = sum;\\n            \\n            if(sum > target)  right--;\\n              \\n            else   left++;\\n              \\n        }\\n    }\\n    \\n    return res;\\n}\\n\\n\\n//Guys plz plz plz upvote my solution if you really like it and understand it.and comment here if there is any doubt or new suggestion.\\n//Stay Safe and Keep Coding Guys!!!!\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 7906,
                "title": "7ms-and-o-n-2-java-solution",
                "content": "My solution does not need compare each sum ,just need to compare possible sum ,so can save time.\\n\\n    public class Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closest=nums[0]+nums[1]+nums[2];\\n        int low,high;\\n        for(int i=0;i<nums.length-1;i++){\\n            low=i+1;\\n            high=nums.length-1;\\n            while(low<high){\\n                if(nums[low]+nums[high]==target-nums[i]) return target;\\n                else if(nums[low]+nums[high]>target-nums[i]){\\n                    while(low<high&&nums[low]+nums[high]>target-nums[i]) high--;\\n                    if(Math.abs(nums[i]+nums[low]+nums[high+1]-target)<Math.abs(closest-target))\\n                        closest=nums[i]+nums[low]+nums[high+1];\\n                }\\n                else{\\n                    while(low<high&&nums[low]+nums[high]<target-nums[i]) low++;\\n                    if(Math.abs(nums[i]+nums[low-1]+nums[high]-target)<Math.abs(closest-target))\\n                        closest=nums[i]+nums[low-1]+nums[high];\\n                }\\n            }\\n        }\\n        return closest;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closest=nums[0]+nums[1]+nums[2];\\n        int low,high;\\n        for(int i=0;i<nums.length-1;i++){\\n            low=i+1;\\n            high=nums.length-1;\\n            while(low<high){\\n                if(nums[low]+nums[high]==target-nums[i]) return target;\\n                else if(nums[low]+nums[high]>target-nums[i]){\\n                    while(low<high&&nums[low]+nums[high]>target-nums[i]) high--;\\n                    if(Math.abs(nums[i]+nums[low]+nums[high+1]-target)<Math.abs(closest-target))\\n                        closest=nums[i]+nums[low]+nums[high+1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3067315,
                "title": "faster-c-solution-o-n-3-o-n-2-40ms-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is a variation of 2Sum and especially 3Sum problem. In 3Sum, we choose a triplet and checks its sum equal to 0(target). here we have to find the sum of triplet closest to target. so use the same approach as we have used in 3Sum problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst thing is to think how you can get closest sum. For this sort the vector for easiness. \\nif sum is greater then target, but we need sum closest, that is ,**the minimum sum greater than equal to target** declare min1 variable with **min1 = INT_MAX - 10000;** we did -10000 so that we can get rid of TLE.  and same for when sum is smaller than target , that is, **the greatest sum smaller than equal to target** for this declare, **max1 = INT_MIN + 10000** . if sum is equal to target return the sum. \\n\\nnow the question is which variale min1, max1 we have to return, for this, find the absolute difference of min1, max1 with target and return min1 or max1 as per the minimum diff obtained.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        int  n= nums.size();\\n        int sum=0, j=0,k=0;\\n        int max1 = INT_MIN + 10000, min1 = INT_MAX - 10000;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i< (n-2); i++)\\n        {\\n            j= i+1;\\n            k= n-1;\\n            while(j < k)\\n            {\\n                sum= nums[i] + nums[j] + nums[k];\\n                \\n                if(sum == target)\\n                    return sum;\\n                \\n                else if(sum>target)\\n                {\\n                    min1= min(min1, sum);\\n                    k--;\\n                }\\n                else if(sum < target)\\n                {\\n                    max1= max( max1, sum);\\n                    j++;\\n                }\\n            }\\n        }\\n        // target =10, a=2, b=1;\\n\\n        int a= min1 - target;\\n        int b= target - max1;\\n\\n        if(a < b)\\n        return min1;\\n        else\\n        return max1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        int  n= nums.size();\\n        int sum=0, j=0,k=0;\\n        int max1 = INT_MIN + 10000, min1 = INT_MAX - 10000;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i< (n-2); i++)\\n        {\\n            j= i+1;\\n            k= n-1;\\n            while(j < k)\\n            {\\n                sum= nums[i] + nums[j] + nums[k];\\n                \\n                if(sum == target)\\n                    return sum;\\n                \\n                else if(sum>target)\\n                {\\n                    min1= min(min1, sum);\\n                    k--;\\n                }\\n                else if(sum < target)\\n                {\\n                    max1= max( max1, sum);\\n                    j++;\\n                }\\n            }\\n        }\\n        // target =10, a=2, b=1;\\n\\n        int a= min1 - target;\\n        int b= target - max1;\\n\\n        if(a < b)\\n        return min1;\\n        else\\n        return max1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173514,
                "title": "java-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Fix one var\\n- iterate the other two pointers nested\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int diff = Integer.MAX_VALUE;\\n        int sum = 0;\\n        Arrays.sort(nums);\\n        // make i fixed\\n        for (int i = 0; i < nums.length; i++) {\\n            // two pointers for comparing values greater than i \\n            int j = i+1;\\n            int k = nums.length-1;\\n            \\n            // use two pointers j and k for every i\\n            while (j < k) {\\n                sum = nums[i] + nums[j] + nums[k];\\n                if (Math.abs(target-sum) < Math.abs(diff)) {\\n                    diff = target-sum;\\n                }\\n                if (sum < target) { // if our sum is lower than target, we want to move closer\\n                    j++;\\n                }\\n                else{ // if our sum is farther than target, we want to move closer\\n                    k--;\\n                }          \\n            }\\n\\n        }\\n        return target-diff; // target - diff is the most optimal sum, or we can use extra variable to store Best sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int diff = Integer.MAX_VALUE;\\n        int sum = 0;\\n        Arrays.sort(nums);\\n        // make i fixed\\n        for (int i = 0; i < nums.length; i++) {\\n            // two pointers for comparing values greater than i \\n            int j = i+1;\\n            int k = nums.length-1;\\n            \\n            // use two pointers j and k for every i\\n            while (j < k) {\\n                sum = nums[i] + nums[j] + nums[k];\\n                if (Math.abs(target-sum) < Math.abs(diff)) {\\n                    diff = target-sum;\\n                }\\n                if (sum < target) { // if our sum is lower than target, we want to move closer\\n                    j++;\\n                }\\n                else{ // if our sum is farther than target, we want to move closer\\n                    k--;\\n                }          \\n            }\\n\\n        }\\n        return target-diff; // target - diff is the most optimal sum, or we can use extra variable to store Best sum\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899603,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        let sorted = nums.sorted()\\n        var i = 0\\n        var min = Int.max\\n        var res = Int.max\\n\\n        while i < sorted.count - 2 {\\n            var j = i + 1\\n            var k = sorted.count - 1\\n            while j < k {\\n                let sum = sorted[i] + sorted[j] + sorted[k]\\n                if sum == target {\\n                    return target\\n                }\\n                if sum < target {\\n                    j += 1\\n                } else {\\n                    k -= 1\\n                }\\n                let diff = abs(sum - target)\\n                if diff < min {\\n                    min = diff\\n                    res = sum\\n                }\\n            }\\n            i += 1\\n        }\\n        \\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        let sorted = nums.sorted()\\n        var i = 0\\n        var min = Int.max\\n        var res = Int.max\\n\\n        while i < sorted.count - 2 {\\n            var j = i + 1\\n            var k = sorted.count - 1\\n            while j < k {\\n                let sum = sorted[i] + sorted[j] + sorted[k]\\n                if sum == target {\\n                    return target\\n                }\\n                if sum < target {\\n                    j += 1\\n                } else {\\n                    k -= 1\\n                }\\n                let diff = abs(sum - target)\\n                if diff < min {\\n                    min = diff\\n                    res = sum\\n                }\\n            }\\n            i += 1\\n        }\\n        \\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1675008,
                "title": "c-solution-with-explanations-brute-force-to-optimal-solution-explained",
                "content": "\\n> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- A basic approach using 3loops.\\n- We calculate the sum of 3 elements & store the difference of sum and target.\\n- If the difference is less than the minimum value we expected, then we\\u2019ll store the sum as ans.\\n- **Time complexity:** O(n^3).\\n\\n### Solution 02\\n\\n- Here we sort the array & will use 2 pointers to get the sum.\\n- Fix an index ***i*** & ***left=i+1, right=n-1.***\\n- If the sum of the 3 elements is less than the target, then we\\u2019ll shift the left pointer which will increase the value.\\n- Else we will shift right to decrease sum value.\\n- Also, we\\u2019ll calculate the difference and store in ***mn*** & update ***ans.***\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum, diff, ans, i=0, j=0, k=0, x=INT_MAX;\\n        while(i<n-2){\\n            sum = nums[i];\\n            j=i+1;\\n            while(j<n-1){\\n                sum += nums[j];\\n                k=j+1;\\n                while(k<n){\\n                    sum += nums[k];\\n                    diff = abs(target-sum);\\n                    if(diff<x){\\n                        x = diff;\\n                        ans = sum;\\n                    }\\n                    sum -= nums[k];\\n                    k++;\\n                }\\n                sum -= nums[j];\\n                j++;\\n            }i++;\\n        }\\n       \\n        return ans;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        int ans, sum, mn= INT_MAX;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i=0; i<n-2; i++){\\n            int left = i+1;\\n            int right = n-1;\\n            while(left < right){\\n                sum = nums[i] + nums[left] + nums[right];\\n                if(sum == target)\\n                    return sum;\\n                else if(sum < target)\\n                    left++;\\n                else\\n                    right--;\\n                if( abs(sum - target) < mn){\\n                    ans = sum;\\n                    mn = abs(sum - target);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int sum, diff, ans, i=0, j=0, k=0, x=INT_MAX;\\n        while(i<n-2){\\n            sum = nums[i];\\n            j=i+1;\\n            while(j<n-1){\\n                sum += nums[j];\\n                k=j+1;\\n                while(k<n){\\n                    sum += nums[k];\\n                    diff = abs(target-sum);\\n                    if(diff<x){\\n                        x = diff;\\n                        ans = sum;\\n                    }\\n                    sum -= nums[k];\\n                    k++;\\n                }\\n                sum -= nums[j];\\n                j++;\\n            }i++;\\n        }\\n       \\n        return ans;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        int ans, sum, mn= INT_MAX;\\n        sort(nums.begin(), nums.end());\\n        \\n        for(int i=0; i<n-2; i++){\\n            int left = i+1;\\n            int right = n-1;\\n            while(left < right){\\n                sum = nums[i] + nums[left] + nums[right];\\n                if(sum == target)\\n                    return sum;\\n                else if(sum < target)\\n                    left++;\\n                else\\n                    right--;\\n                if( abs(sum - target) < mn){\\n                    ans = sum;\\n                    mn = abs(sum - target);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365863,
                "title": "python3-detailed-explanation-of-naive-2-pointer-solutions",
                "content": "## 0. Understanding the Problem\\nGiven:\\n- an array `nums`\\n- an integer `target`\\n\\nGoal: To find the sum of 3 numbers in `nums` that is closest to `target`.\\n\\nExample explaination:\\nnums = [-1,2,1,-4], target = 1\\n\\nThere are multiple possible combinations of which we have to find the minimum summing case. Infact there are nC3 total combinations.\\n\\nFor the given case, 2 is the solution, given by (-1, 2, 1).\\n\\n\\n## 1. Naive Solution\\nSince there are 3 numbers we need to take the sum of, we can simply loop and find the answer.\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        ans = float(\\'inf\\')\\n        \\n        # three loops of O(N) each, giving \\n        # O(N^3) total time complexity\\n        # Space complexity is O(1)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                for k in range(j+1, n):\\n                    temp_sum = nums[i]+nums[j]+nums[k]\\n                    ans = min(ans, temp_sum, key=lambda x: abs(target-x))\\n        \\n        return ans\\n```\\n\\n## 2. Observations\\n- The question asks for the `sum` and not the three numbers/indices themselves, this means operations like **sorting** could help us.\\n- The sort function takes `O(Nlog(N))` time. (The space complexity depends on what algorithm you choose to use. Heap sort takes `O(1)` space (its in-place). Merge sort takes `O(N)` space.) This time is also lesser than `O(N^3)` and `O(N^2)`.\\n- Considering the array sorted, what more can we derive?\\n\\nOne possible Solution:\\nInstead of 3 nested loops, we can have two nested loops and one binary search running, taking time complexity `O(N^2log(N) + Nlog(N))`. Which is the same as `O(N^2log(N))`. This is clearly better than `O(N^3).`\\n\\nThere\\'s one last observation needed for the best solution. \\nThe purpose of the loop is to \"specify\" one variable. When we do `for i in range(n)`, we specify the value for `i` for the loops nested inside of it (think about it, its trivial). Once we specify three of the values, we can make a comparison with `target` and decide whether to make it answer or not. This is the logic behind the three nested loops of the naive solution.\\n\\nBUT, note how once the array is sorted, we have a definite measurement of how the elements are palced. We can reuse this fact and have **two pointers**. One from `i+1`, called `l` and the other from `n-1`, called `r`, both going in the opposite directions. `l` goes to the right and `r` to the left. We can **greedily search for the answer**!\\n\\n*Since the array is sorted, we can always decide whether to move the `l` or the `r` pointer.*\\n\\nHow? Let\\'s see below!\\n\\n## 3. Optimal Solution\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        ans = float(\\'inf\\')\\n        for i in range(n-1):\\n            l, r = i+1, n-1 # starting the search\\n            while l < r:\\n                temp_sum = nums[l] + nums[r] + nums[i]\\n                # if we are above the target, reduce the bigger element\\n                if temp_sum > target: r -= 1\\n                # if we are below the target, increase the smaller element\\n                elif temp_sum < target: l += 1\\n                # if we are *at* the target, we have the best possible answer.\\n                else: return temp_sum\\n                ans = min(ans, temp_sum, key=lambda x: abs(target-x))\\n        return ans\\n```\\n\\nTime complexity: `O(Nlog(N) + N^2)`. `Nlog(N)` for the merge sort operation and `N^2` for the for loop & then the search from `l` to `r` (this will take up the entire range from `[i+1, n-1]`).\\n\\nSpace complexity: `O(N)` for the merge sort.\\n\\nQuestions? Feel free to ask below! Comments and criticisms are greatly appreciated. An upvote means this explaination helped you out :D\\n",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        ans = float(\\'inf\\')\\n        \\n        # three loops of O(N) each, giving \\n        # O(N^3) total time complexity\\n        # Space complexity is O(1)\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                for k in range(j+1, n):\\n                    temp_sum = nums[i]+nums[j]+nums[k]\\n                    ans = min(ans, temp_sum, key=lambda x: abs(target-x))\\n        \\n        return ans\\n```\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        ans = float(\\'inf\\')\\n        for i in range(n-1):\\n            l, r = i+1, n-1 # starting the search\\n            while l < r:\\n                temp_sum = nums[l] + nums[r] + nums[i]\\n                # if we are above the target, reduce the bigger element\\n                if temp_sum > target: r -= 1\\n                # if we are below the target, increase the smaller element\\n                elif temp_sum < target: l += 1\\n                # if we are *at* the target, we have the best possible answer.\\n                else: return temp_sum\\n                ans = min(ans, temp_sum, key=lambda x: abs(target-x))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7972,
                "title": "share-my-24-line-java-code-beats-94-57-run-times",
                "content": "    public class Solution {\\n        public int threeSumClosest(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            int diff = Integer.MAX_VALUE, closest = 0;\\n            for (int k=0; k<nums.length-2; ++k) {\\n                for (int i=k+1, j=nums.length-1; i<j; ) {\\n                    int sum = nums[k] + nums[i] + nums[j];\\n                    if (sum == target) { return target; }\\n                    else if (sum > target) {\\n                        if (sum-target < diff) {\\n                            diff = sum-target;\\n                            closest = sum;\\n                        }\\n                        --j;\\n                    } else {\\n                        if (target-sum < diff) {\\n                            diff = target-sum;\\n                            closest = sum;\\n                        }\\n                        ++i;\\n                    }\\n                }\\n            }\\n            return closest;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int threeSumClosest(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            int diff = Integer.MAX_VALUE, closest = 0;\\n            for (int k=0; k<nums.length-2; ++k) {\\n                for (int i=k+1, j=nums.length-1; i<j; ) {\\n                    int sum = nums[k] + nums[i] + nums[j];\\n                    if (sum == target) { return target; }",
                "codeTag": "Java"
            },
            {
                "id": 3471166,
                "title": "beats-93-beginner-friendly-cpp-and-python-code-easy-to-understand",
                "content": "# Intuition\\nPLZ upvote if you like this\\n\\n# Python Code\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n\\n        n=len(nums)\\n        nums.sort()\\n        diff=20001\\n        val=0\\n        for i in range(n):\\n            a=i+1\\n            b=n-1\\n            while(a<b):\\n                cc=nums[i]+nums[a]+nums[b]\\n                kk=abs(cc-target)\\n                if(kk<diff):\\n                    diff=kk\\n                    val=cc\\n                if(cc==target):\\n                    return target\\n                elif(cc<target):\\n                    a+=1\\n                else:\\n                    b-=1\\n            \\n        return val\\n```\\n\\n# CPP Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int diff=INT_MAX;\\n        int val=0;\\n        for (int i=0;i<n;i++){\\n            int a=i+1;\\n            int b=n-1;\\n            while(a<b){\\n                int cc=nums[i]+nums[a]+nums[b];\\n                int kk=abs(cc-target);\\n                if(kk<diff){\\n                    diff=kk;\\n                    val=cc;\\n                }\\n                if(cc==target){\\n                    return target;\\n                }\\n                else if(cc<target){\\n                    a++;\\n                }\\n                else{\\n                    b--;\\n                }\\n            }\\n        }\\n        return val;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n\\n        n=len(nums)\\n        nums.sort()\\n        diff=20001\\n        val=0\\n        for i in range(n):\\n            a=i+1\\n            b=n-1\\n            while(a<b):\\n                cc=nums[i]+nums[a]+nums[b]\\n                kk=abs(cc-target)\\n                if(kk<diff):\\n                    diff=kk\\n                    val=cc\\n                if(cc==target):\\n                    return target\\n                elif(cc<target):\\n                    a+=1\\n                else:\\n                    b-=1\\n            \\n        return val\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int diff=INT_MAX;\\n        int val=0;\\n        for (int i=0;i<n;i++){\\n            int a=i+1;\\n            int b=n-1;\\n            while(a<b){\\n                int cc=nums[i]+nums[a]+nums[b];\\n                int kk=abs(cc-target);\\n                if(kk<diff){\\n                    diff=kk;\\n                    val=cc;\\n                }\\n                if(cc==target){\\n                    return target;\\n                }\\n                else if(cc<target){\\n                    a++;\\n                }\\n                else{\\n                    b--;\\n                }\\n            }\\n        }\\n        return val;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3381792,
                "title": "easy-java-approach-two-pointer-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the input array nums to enable the two-pointer approach, which helps in efficiently finding the three integers with the closest sum to the target value.\\n\\nInitialize closestSum and minDiff to large values, as placeholders for the closest sum and minimum difference between sum and target, respectively.\\n\\nLoop through the array from index 0 to nums.length - 2, as the three-pointer approach requires at least three elements to find a sum.\\n\\nInside the loop, set up two pointers, left and right, to the elements immediately after the current element and the last element of the array, respectively.\\n\\nUse a while loop to continuously move the left and right pointers towards each other until they meet or cross each other.\\n\\nCalculate the current sum by adding the values at the current element, nums[left], and nums[right].\\n\\nCalculate the absolute difference between the current sum and the target value, and update minDiff and closestSum if the current difference is smaller than the previous minimum difference.\\n\\nIf the current sum is less than the target, increment the left pointer to consider a larger value.\\n\\nIf the current sum is greater than the target, decrement the right pointer to consider a smaller value.\\n\\nIf the current sum is equal to the target, return it as the closest sum.\\n\\nAfter the loop completes, return the closestSum as the final result, which represents the three integers in the array whose sum is closest to the target value. Note that the returned value may be greater or smaller than the target, depending on the input array and target value. Thus, the caller can check the actual difference between the returned sum and the target value if needed. Also, note that this code assumes that the input array nums has at least three elements. If that\\'s not guaranteed, appropriate error handling or input validation should be added. Additionally, the code assumes that the\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums); // Sort the array to enable two-pointer approach\\n        int closestSum = Integer.MAX_VALUE; // Initialize closest sum to a large value\\n        int minDiff = Integer.MAX_VALUE; // Initialize minimum difference to a large value\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int left = i + 1; // Pointer for the element on the left\\n            int right = nums.length - 1; // Pointer for the element on the right\\n\\n            while (left < right) {\\n                int sum = nums[i] + nums[left] + nums[right]; // Calculate the current sum\\n\\n                int diff = Math.abs(sum - target); // Calculate the absolute difference between current sum and target\\n                if (diff < minDiff) { // Update the minimum difference and closest sum if necessary\\n                    minDiff = diff;\\n                    closestSum = sum;\\n                }\\n\\n                if (sum < target) {\\n                    left++; // If current sum is less than target, increment the left pointer\\n                } else if (sum > target) {\\n                    right--; // If current sum is greater than target, decrement the right pointer\\n                } else {\\n                    return sum; // If current sum is equal to target, return it as the closest sum\\n                }\\n            }\\n        }\\n\\n        return closestSum; // Return the closest sum after traversing the entire array\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums); // Sort the array to enable two-pointer approach\\n        int closestSum = Integer.MAX_VALUE; // Initialize closest sum to a large value\\n        int minDiff = Integer.MAX_VALUE; // Initialize minimum difference to a large value\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int left = i + 1; // Pointer for the element on the left\\n            int right = nums.length - 1; // Pointer for the element on the right\\n\\n            while (left < right) {\\n                int sum = nums[i] + nums[left] + nums[right]; // Calculate the current sum\\n\\n                int diff = Math.abs(sum - target); // Calculate the absolute difference between current sum and target\\n                if (diff < minDiff) { // Update the minimum difference and closest sum if necessary\\n                    minDiff = diff;\\n                    closestSum = sum;\\n                }\\n\\n                if (sum < target) {\\n                    left++; // If current sum is less than target, increment the left pointer\\n                } else if (sum > target) {\\n                    right--; // If current sum is greater than target, decrement the right pointer\\n                } else {\\n                    return sum; // If current sum is equal to target, return it as the closest sum\\n                }\\n            }\\n        }\\n\\n        return closestSum; // Return the closest sum after traversing the entire array\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070001,
                "title": "easiest-c-solution-using-for-loop-and-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\nsort(nums.begin(), nums.end());\\nint n=nums.size();\\nint mn=INT_MAX;\\nint ans=0;\\n\\nfor(int i=0; i<nums.size(); i++){\\n    int start=i+1;\\n    int end=n-1;\\n    while(start<end){\\nint sum=nums[i]+nums[start]+nums[end];\\nint diff=abs(sum-target);\\n\\nif(diff<mn){\\nmn=diff;\\nans=sum;\\n    }\\nif(sum>target)\\nend--;\\n\\nelse start++;\\n\\n} \\n}\\n   return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\nsort(nums.begin(), nums.end());\\nint n=nums.size();\\nint mn=INT_MAX;\\nint ans=0;\\n\\nfor(int i=0; i<nums.size(); i++){\\n    int start=i+1;\\n    int end=n-1;\\n    while(start<end){\\nint sum=nums[i]+nums[start]+nums[end];\\nint diff=abs(sum-target);\\n\\nif(diff<mn){\\nmn=diff;\\nans=sum;\\n    }\\nif(sum>target)\\nend--;\\n\\nelse start++;\\n\\n} \\n}\\n   return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297535,
                "title": "python-two-pointer-solution-sped-up-with-binary-search-avoiding-tle",
                "content": "This solution runs in around 250ms to 300ms (faster than 80%) https://leetcode.com/submissions/detail/749879788/. Other two two-pointer solutions tend to be TLE since the new test cases were added. \\nIn the 3sum solution the update rule starts with\\n```\\nk = i+1\\nj = len(nums) - 1\\n```\\nand then increments these:\\n```\\nif nums[i] + nums[k] + nums[j] < target:\\n  k+=1\\nelse:\\n  j-=1\\n```\\nHowever, instead of updating these incrementally we can directly fast-forward them using binary search. i.e. at minimum nums[k] would have to be to flip the if statement is target - num[i] - nums[j]. The same logic can be applied to update j using binary search. \\n```\\ndef threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n \\n        best = None\\n        \\n        # The window is: [i, k, j]\\n        # Valid range for i:\\n        for i in range(0, len(nums) - 2):\\n            # Instead of incrementaly updating the j and k,\\n            # we can use binary search to find the next viable value\\n            # for each.\\n            # We pingpong between updating j and k\\n            pingpong = 0\\n            \\n            # Pick a k (j will be overriden on first pass)\\n            k = i+1\\n            j = len(nums)\\n\\n            while j > i + 2:\\n                if pingpong%2 == 0:\\n                    # Decrease j until sum can be less than target\\n                    targetVal = target - nums[i] - nums[k]\\n                    newj = bisect_left(nums, targetVal, k+1, j-1)\\n                    # There is no possible update to j, can stop\\n                    # searching\\n                    if newj == j:\\n                        break\\n                    j = newj\\n                    pingpong += 1\\n                else:\\n                    # Increase k until sum can exceed target\\n                    targetVal = target - nums[i] - nums[j]\\n                    k = bisect_left(nums, targetVal, i+1, j-1)\\n                    if nums[k] > targetVal and k > i+1:\\n                        k = k - 1\\n                    pingpong += 1\\n\\n                new = nums[i] + nums[k] + nums[j]\\n                if best is None or (abs(best - target) > abs(target - new)):\\n                    best = new\\n\\n                if best == target:\\n                    return target\\n\\n        return best",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nk = i+1\\nj = len(nums) - 1\\n```\n```\\nif nums[i] + nums[k] + nums[j] < target:\\n  k+=1\\nelse:\\n  j-=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2674384,
                "title": "python-solution-defeat-the-new-test-cases",
                "content": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    \\'\\'\\'\\n    First sort the nums\\n    Then use two pointer algorithm to find the closest 3 sum\\n    We can optimize the code by first checking the smallest and largest within the testing window [i+1:n]: nums[i] + (nums[i+1] + nums[i+2]) and nums[i] + (nums[n-2] + nums[n-1]) actually envelope target\\n    Otherwise we just proceed to the next i    \\n    \\'\\'\\'\\n\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        result, n = float(\\'inf\\'), len(nums)\\n        for i in range(n-2):\\n            S1 = nums[i] + nums[i+1] + nums[i+2]\\n            S2 = nums[i] + nums[n-2] + nums[n-1]\\n            candidates = [result, S1, S2]\\n            result = min(candidates, key = lambda x: abs(x-target))            \\n            if S1 <= target <= S2:\\n                left, right = i+1, n-1\\n                while left < right:\\n                    S = nums[i] + nums[left] + nums[right]\\n                    candidates = [result, S]\\n                    result = min(candidates, key = lambda x: abs(x-target))\\n                    if S == target:\\n                        return target\\n                    elif S < target:\\n                        left += 1\\n                    else:\\n                        right -= 1\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\n\\n\\nclass Solution:\\n    \\'\\'\\'\\n    First sort the nums\\n    Then use two pointer algorithm to find the closest 3 sum\\n    We can optimize the code by first checking the smallest and largest within the testing window [i+1:n]: nums[i] + (nums[i+1] + nums[i+2]) and nums[i] + (nums[n-2] + nums[n-1]) actually envelope target\\n    Otherwise we just proceed to the next i    \\n    \\'\\'\\'\\n\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        result, n = float(\\'inf\\'), len(nums)\\n        for i in range(n-2):\\n            S1 = nums[i] + nums[i+1] + nums[i+2]\\n            S2 = nums[i] + nums[n-2] + nums[n-1]\\n            candidates = [result, S1, S2]\\n            result = min(candidates, key = lambda x: abs(x-target))            \\n            if S1 <= target <= S2:\\n                left, right = i+1, n-1\\n                while left < right:\\n                    S = nums[i] + nums[left] + nums[right]\\n                    candidates = [result, S]\\n                    result = min(candidates, key = lambda x: abs(x-target))\\n                    if S == target:\\n                        return target\\n                    elif S < target:\\n                        left += 1\\n                    else:\\n                        right -= 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467590,
                "title": "javascript-99",
                "content": "Doing the Blind 75 List and posting all solutions.\\n\\n```\\nvar threeSumClosest = function(nums, target) {\\n  nums.sort((x, y) => x - y);\\n  let closest = Infinity;\\n  \\n  //Iterate through until 2 from end because there will be two pointers after\\n  //this idx to find threesums.\\n  for (let i = 0; i < nums.length - 2; i++) {\\n  \\n\\t//Stops us from doing repeat work.  If i is same as last, we have\\n\\t//Already checked all perms.\\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\\n    let left = i + 1, right = nums.length - 1;\\n    while (left < right) {\\n      const total = nums[i] + nums[left] + nums[right];\\n\\t  \\n\\t  //If found, return target.\\n      if (total === target) return target;\\n\\t  \\n\\t  //Otherwise set closest to min of distance between current total and target, or \\n\\t  //previous closest.\\n      closest = Math.abs(target - closest) < Math.abs(target - total) ? closest : total;\\n\\t  \\n\\t  //If current total is less than target, we know we need a higher number and arr\\n\\t  //is sorted.  Incrementing left pointer and looping until we find a unique val\\n\\t  //gives us the next highest number.  Side Note:  For this problem and the LC tests,\\n\\t  //we do not need the loop in this block.  For larger data sets, it could save us from\\n\\t  //a lot of repeat work though.  I left it in because I think it\\'s a nice addition.  Feel free\\n\\t  //to remove if you want though.  Won\\'t change performance on LC test cases much.\\n      if (total < target) {\\n        left++;\\n        while(left < right && nums[i] === nums[i - 1]) left++;\\n      } else {\\n        right--;\\n        while (left < right && nums[right] === nums[right + 1]) right--;\\n      }\\n    }\\n  }\\n  return closest;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar threeSumClosest = function(nums, target) {\\n  nums.sort((x, y) => x - y);\\n  let closest = Infinity;\\n  \\n  //Iterate through until 2 from end because there will be two pointers after\\n  //this idx to find threesums.\\n  for (let i = 0; i < nums.length - 2; i++) {\\n  \\n\\t//Stops us from doing repeat work.  If i is same as last, we have\\n\\t//Already checked all perms.\\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\\n    let left = i + 1, right = nums.length - 1;\\n    while (left < right) {\\n      const total = nums[i] + nums[left] + nums[right];\\n\\t  \\n\\t  //If found, return target.\\n      if (total === target) return target;\\n\\t  \\n\\t  //Otherwise set closest to min of distance between current total and target, or \\n\\t  //previous closest.\\n      closest = Math.abs(target - closest) < Math.abs(target - total) ? closest : total;\\n\\t  \\n\\t  //If current total is less than target, we know we need a higher number and arr\\n\\t  //is sorted.  Incrementing left pointer and looping until we find a unique val\\n\\t  //gives us the next highest number.  Side Note:  For this problem and the LC tests,\\n\\t  //we do not need the loop in this block.  For larger data sets, it could save us from\\n\\t  //a lot of repeat work though.  I left it in because I think it\\'s a nice addition.  Feel free\\n\\t  //to remove if you want though.  Won\\'t change performance on LC test cases much.\\n      if (total < target) {\\n        left++;\\n        while(left < right && nums[i] === nums[i - 1]) left++;\\n      } else {\\n        right--;\\n        while (left < right && nums[right] === nums[right + 1]) right--;\\n      }\\n    }\\n  }\\n  return closest;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1365667,
                "title": "python-two-pointers-2sum-explained",
                "content": "Very similar to the problem **15**, also 2 pointers idea. Now, instead of looking for sums equal to `target`, we perform 2 pointers and look for sums which are around `target`, that is if sum becomes bigger than `target` we move end pointer and in opposite case we move beg pointer. \\n\\n#### Complexity\\nTime complexity is `O(n^2)`, space is `O(n)` or `O(log n)` depening on sort function.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        n, ans = len(nums), float(\"inf\")\\n\\n        for i in range(n):\\n            beg, end = i + 1, n - 1\\n\\n            while beg < end:\\n                sm = nums[beg] + nums[end] + nums[i]\\n                ans = min(ans, sm, key = lambda x: abs(x - target))\\n        \\n                if sm <= target:\\n                    beg += 1\\n                elif sm > target:\\n                    end -= 1\\n\\n        return ans\\n```\\n\\n#### Remark\\nThere are couple of optimization to make it work faster: `if ans == target: break` before the last return statement, and not using lambda functions to get min.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        n, ans = len(nums), float(\"inf\")\\n\\n        for i in range(n):\\n            beg, end = i + 1, n - 1\\n\\n            while beg < end:\\n                sm = nums[beg] + nums[end] + nums[i]\\n                ans = min(ans, sm, key = lambda x: abs(x - target))\\n        \\n                if sm <= target:\\n                    beg += 1\\n                elif sm > target:\\n                    end -= 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317287,
                "title": "c-solution-with-proper-explaination",
                "content": "This problem is variation of **2 sum**  poblem where we need to find the pairs equivalent to the given target.\\nThe 2 sum problem is further extended to **3 sum** where we need to return the tripet of array which is equal to 0.\\nHow this problem 3 sum closest is extension of 3 sum : \\nhere we just need to find three integers of nums vector that has closest sum to the given target.**\\n\\n**Steps to find closest 3 sum to the given target:**\\n1) sort the array(through sorting we can increase the efficiency of the solution)\\n   unless and until the array is sorted applying two pointer doesn\\'t make sense.\\n2)  use two pointer approach \\n3)  make a left pointing next to i and a right pointer at the end of it\\n4)  make a curr_sum variable \\n5)  check for the condition if target - curr_sum < min_diff\\n6)  if curr_sum > target than decrement the right pointer \\n7)  else increment left pointer.\\n **Time complexity - O(N^2)** \\n **space complexity - O(1)** as no extra space required\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int min_difference = INT_MAX;\\n        int result =0;\\n        for(int i =0; i< nums.size() ; i++){\\n           int left = i +1; \\n            int right = nums.size()-1;\\n            \\n            while(left < right){\\n                \\n                int curr_sum = nums[i] + nums[left]+ nums[right];\\n                if(abs(target - curr_sum) < min_difference ){\\n                      min_difference = abs(target - curr_sum);\\n                      result = curr_sum;\\n                }\\n                if( curr_sum > target) right--;\\n                else{\\n                    left++;\\n                }\\n               if(target == curr_sum) return result;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n};\\n```\\n**please upvote if you like the  solution and do comment if have doubts**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int min_difference = INT_MAX;\\n        int result =0;\\n        for(int i =0; i< nums.size() ; i++){\\n           int left = i +1; \\n            int right = nums.size()-1;\\n            \\n            while(left < right){\\n                \\n                int curr_sum = nums[i] + nums[left]+ nums[right];\\n                if(abs(target - curr_sum) < min_difference ){\\n                      min_difference = abs(target - curr_sum);\\n                      result = curr_sum;\\n                }\\n                if( curr_sum > target) right--;\\n                else{\\n                    left++;\\n                }\\n               if(target == curr_sum) return result;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159459,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums = sorted(nums)\\n        curr = nums[0] + nums[1] + nums[len(nums)-1]\\n        for i in range(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            l = i+1\\n            r = len(nums) - 1\\n            while l < r:\\n                val = nums[i] + nums[l] + nums[r]\\n                if abs(val - target) < abs(curr - target):\\n                    curr = val\\n                if val == target:\\n                    return target\\n                elif val < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return curr\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        nums = sorted(nums)\\n        curr = nums[0] + nums[1] + nums[len(nums)-1]\\n        for i in range(len(nums)-2):\\n            if i > 0 and nums[i] == nums[i-1]:\\n                continue\\n            l = i+1\\n            r = len(nums) - 1\\n            while l < r:\\n                val = nums[i] + nums[l] + nums[r]\\n                if abs(val - target) < abs(curr - target):\\n                    curr = val\\n                if val == target:\\n                    return target\\n                elif val < target:\\n                    l += 1\\n                else:\\n                    r -= 1\\n        return curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8022,
                "title": "4-ms-c-solution-sample",
                "content": "    #define ABS(x) ((x)<0?-(x):(x))\\n    \\n    int comparefn( const void* a, const void* b)\\n    {\\n         int int_a = * ( (int*) a );\\n         int int_b = * ( (int*) b );\\n    \\n         if ( int_a == int_b ) return 0;\\n         else if ( int_a < int_b ) return -1;\\n         else return 1;\\n    }\\n    \\n    int threeSumClosest(int* nums, int numsSize, int target) {\\n        // sort the array\\n        qsort(nums, numsSize, sizeof(int), comparefn);\\n        int i, j, k, diff, min_diff = INT_MAX;\\n        for(i = 0 ; i < numsSize ; i++)\\n        {\\n            j = i + 1;\\n            k = numsSize - 1;\\n            while(j < k)\\n            {\\n                diff = nums[i] + nums[j] + nums[k] - target;\\n                //temp = ABS(temp);\\n                if(diff == 0)\\n                {\\n                    return target;\\n                }\\n                else\\n                {\\n                    if(ABS(diff) < ABS(min_diff))\\n                    {\\n                        min_diff = diff;\\n                    }\\n                    if(diff < 0)\\n                    {// increase value\\n                        j++;\\n                    }\\n                    else//>0\\n                    {\\n                        k--;\\n                    }\\n                }\\n            }\\n        }\\n        return target + min_diff;\\n    }",
                "solutionTags": [],
                "code": "    #define ABS(x) ((x)<0?-(x):(x))\\n    \\n    int comparefn( const void* a, const void* b)\\n    {\\n         int int_a = * ( (int*) a );\\n         int int_b = * ( (int*) b );\\n    \\n         if ( int_a == int_b ) return 0;\\n         else if ( int_a < int_b ) return -1;\\n         else return 1;\\n    }\\n    \\n    int threeSumClosest(int* nums, int numsSize, int target) {\\n        // sort the array\\n        qsort(nums, numsSize, sizeof(int), comparefn);\\n        int i, j, k, diff, min_diff = INT_MAX;\\n        for(i = 0 ; i < numsSize ; i++)\\n        {\\n            j = i + 1;\\n            k = numsSize - 1;\\n            while(j < k)\\n            {\\n                diff = nums[i] + nums[j] + nums[k] - target;\\n                //temp = ABS(temp);\\n                if(diff == 0)\\n                {\\n                    return target;\\n                }\\n                else\\n                {\\n                    if(ABS(diff) < ABS(min_diff))\\n                    {\\n                        min_diff = diff;\\n                    }\\n                    if(diff < 0)\\n                    {// increase value\\n                        j++;\\n                    }\\n                    else//>0\\n                    {\\n                        k--;\\n                    }\\n                }\\n            }\\n        }\\n        return target + min_diff;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3448416,
                "title": "c-very-easy-solution-beginner-friendly-two-pointers",
                "content": "<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int calcu = INT_MAX;\\n        int ans = 0;\\n        int n = nums.size() ;\\n        sort( nums.begin() , nums.end() );\\n        for( int i=0 ; i<n-2 ; i++ )\\n        {\\n            int l = i+1 ;\\n            int r = n-1 ;\\n            while( l<r )\\n            {\\n                int sum = nums[i]+nums[l]+nums[r];\\n                int temp = abs( sum - target );\\n                if( temp<calcu )\\n                {\\n                    calcu = temp ;\\n                    ans = sum;\\n                }\\n                if( sum==target )\\n                {\\n                    return sum;\\n                }\\n                else if( sum<target )\\n                {\\n                    l++;\\n                }\\n                else\\n                {\\n                    r--;\\n                }\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int calcu = INT_MAX;\\n        int ans = 0;\\n        int n = nums.size() ;\\n        sort( nums.begin() , nums.end() );\\n        for( int i=0 ; i<n-2 ; i++ )\\n        {\\n            int l = i+1 ;\\n            int r = n-1 ;\\n            while( l<r )\\n            {\\n                int sum = nums[i]+nums[l]+nums[r];\\n                int temp = abs( sum - target );\\n                if( temp<calcu )\\n                {\\n                    calcu = temp ;\\n                    ans = sum;\\n                }\\n                if( sum==target )\\n                {\\n                    return sum;\\n                }\\n                else if( sum<target )\\n                {\\n                    l++;\\n                }\\n                else\\n                {\\n                    r--;\\n                }\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404344,
                "title": "java-solution-two-pointer",
                "content": "# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int minDistance = Integer.MAX_VALUE;\\n        int closestSum = 0;\\n\\n        for(int i = 0; i < nums.length - 2; i++) {\\n            int start = i + 1;\\n            int end = nums.length - 1;\\n\\n            while(start < end) {\\n                int sum = nums[i] + nums[start] + nums[end];\\n                int distance = Math.abs(target - sum);\\n\\n                if(sum == target) {\\n                    return sum;\\n                }  \\n\\n                if(distance < minDistance) {\\n                    minDistance = distance;\\n                    closestSum = sum;\\n                }\\n\\n                if(sum < target) {\\n                    start++;\\n                } else {\\n                    end--;\\n                }\\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int minDistance = Integer.MAX_VALUE;\\n        int closestSum = 0;\\n\\n        for(int i = 0; i < nums.length - 2; i++) {\\n            int start = i + 1;\\n            int end = nums.length - 1;\\n\\n            while(start < end) {\\n                int sum = nums[i] + nums[start] + nums[end];\\n                int distance = Math.abs(target - sum);\\n\\n                if(sum == target) {\\n                    return sum;\\n                }  \\n\\n                if(distance < minDistance) {\\n                    minDistance = distance;\\n                    closestSum = sum;\\n                }\\n\\n                if(sum < target) {\\n                    start++;\\n                } else {\\n                    end--;\\n                }\\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678631,
                "title": "this-brute-force-solution-is-fast-and-here-is-why",
                "content": "## The solution\\n\\nMost solutions in the discussion are O(n^2) and take about 500ms+ in python3, some even got TLE if it lacks some early-stopping checks. However, the solution from here https://leetcode.com/problems/3sum-closest/discuss/778177/Python3-%3A-Runtime%3A-52-ms-faster-than-99.77, while using a brute-force approach, can reach under 200ms, which is significantly faster than other theoretically better O(n^2) solutions. His solution is as follow:\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest\\n```\\n\\n## Why on earth it is so fast ?\\nThe reason is smart prunning, more specifially these 2 checks speed up the code significantly:\\n```\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n```\\nAnd to understand this, let\\'s look at some math. \\n\\nMathematically, if elements in nums are uniformly distributed then the distribution of all possible 3sum would be a bell curve that looks look like this. This is called [Irwin\\u2013Hall distribution or uniform sum distribution.](https://en.wikipedia.org/wiki/Irwin\\u2013Hall_distribution)\\n\\n![image](https://assets.leetcode.com/users/images/9349442b-52d4-4d30-80c5-e82f93ffd73e_1665281362.0298378.png)\\n \\nSo a random target would likely to be close to the mean of all possible 3sum, which means it would lie near the middle of the bell curve. So these 2 above checks essentially bypass many candidates that are too big (sum of numbers near the end) or too small (sum of numbers near the start). And by using recursion, this logic is applied at every k, effectively pruning a lot of cases. \\n\\nYou can check this by counting the number of times these 2 checks help the function return early.\\n\\n## Make it even faster\\n\\nBut that\\'s not all, the solution can be further optimized by changing the linear search in the base case\\n```\\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n```\\nto binary search\\n```\\n        if k == 1:\\n            idx = bisect.bisect_right(nums, target)\\n            if idx == len(nums) or idx > 0 and nums[idx] - target > target - nums[idx - 1]:\\n                return nums[idx - 1]\\n            return nums[idx]\\n```\\nThis in theory is faster than the original solution. However for `len(nums) < 1000` which is small, the improvement is neligible.  \\n\\n## Final words\\nI think it is important to understand thoroughly why a solution is fast, rather than just judging it based solely on the big-O upper bound. \\n\\nIf you find this helpful, please leave  an upvote. Thank you",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest\\n```\n```\\n        # target too small\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        # target too big\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n```\n```\\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n```\n```\\n        if k == 1:\\n            idx = bisect.bisect_right(nums, target)\\n            if idx == len(nums) or idx > 0 and nums[idx] - target > target - nums[idx - 1]:\\n                return nums[idx - 1]\\n            return nums[idx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677097,
                "title": "java-sort-and-two-pointers",
                "content": "# Intuition\\nWe need to find the closest triplet that sums to target.\\n\\nThe brute force way is to iterate `O(n^3)` and to try all triplets. We can do better.\\n\\nIf we were working with pairs instead, we could do this with a two pointer technique if we had a monotonic order array. For example if our array is `[-2,0,1,3,4,6,7]` and our target is `2` we can initialize two pointers in the beginning and in the end. Then we would move left pointer up (increase sum) or move right pointer down (decrease sum) this way we would iterate over the search space trying to converge to target in `O(n)`.\\n\\nWe can extend this algorithm to search a triplet. To do this, we will iterate our array and by doing this we will fix an element `i` at every iteration. Then all we have to do is find a pair(+ the fixed element) that sum closest to the target. This is exactly the process we described above.\\n\\nTo make the two pointer technique work we need to sort our array, otherwise we can\\'t rely on getting closer to the target by moving the pointers left or right.\\n\\n# Code\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int n = nums.length;\\n        \\n        // Sort - nlogn\\n        Arrays.sort(nums);\\n        \\n        // Two pointer closing with fixed element\\n        int closest = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i <= n - 3; i++) {\\n            int left = i + 1;\\n            int right = n - 1;\\n            \\n            while (left < right) {\\n                int current_triplet_sum = nums[i] + nums[left] + nums[right];\\n                \\n                // Update\\n                if (Math.abs(target - closest) > Math.abs(target - current_triplet_sum)) {\\n                    closest = current_triplet_sum;\\n                }\\n                \\n                // Move pointers\\n                if (current_triplet_sum < target) {\\n                    left++;\\n                }\\n                else {\\n                    right--;\\n                }\\n            }\\n        }\\n        \\n        return closest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int n = nums.length;\\n        \\n        // Sort - nlogn\\n        Arrays.sort(nums);\\n        \\n        // Two pointer closing with fixed element\\n        int closest = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i <= n - 3; i++) {\\n            int left = i + 1;\\n            int right = n - 1;\\n            \\n            while (left < right) {\\n                int current_triplet_sum = nums[i] + nums[left] + nums[right];\\n                \\n                // Update\\n                if (Math.abs(target - closest) > Math.abs(target - current_triplet_sum)) {\\n                    closest = current_triplet_sum;\\n                }\\n                \\n                // Move pointers\\n                if (current_triplet_sum < target) {\\n                    left++;\\n                }\\n                else {\\n                    right--;\\n                }\\n            }\\n        }\\n        \\n        return closest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1810579,
                "title": "c-easy-to-understand-simple-tc-o-n-2-sc-o-1-100",
                "content": "**upvote if you like the solution**\\n````\\nint threeSumClosest(vector<int>& nums, int target) {\\n        int ans=0,mn=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>1;--i){\\n            int j=0,k=i-1;\\n            while(j<k){\\n                int sm=nums[i]+nums[j]+nums[k];\\n                if(abs(target-sm)<mn){\\n                    mn=abs(target-sm);\\n                    ans=sm;\\n                }\\n                if(sm>target) k--;\\n                else if(sm<target) j++;\\n                else return ans;\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "**upvote if you like the solution**\\n````\\nint threeSumClosest(vector<int>& nums, int target) {\\n        int ans=0,mn=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=nums.size()-1;i>1;--i){\\n            int j=0,k=i-1;\\n            while(j<k){\\n                int sm=nums[i]+nums[j]+nums[k];\\n                if(abs(target-sm)<mn){\\n                    mn=abs(target-sm);\\n                    ans=sm;\\n                }\\n                if(sm>target) k--;\\n                else if(sm<target) j++;\\n                else return ans;\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 451359,
                "title": "python-easy-approach-beats-100-memory",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return None\\n        \\n        diff=float(\\'inf\\')\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            p1=i+1\\n            p2=len(nums)-1\\n            \\n            while p1<p2:\\n                s=nums[i]+nums[p1]+nums[p2]\\n                if abs(s-target) < diff:\\n                    diff=abs(s-target)\\n                    output=s\\n                \\n                if s<target:\\n                    p1+=1\\n                elif s>target:\\n                    p2-=1\\n                else:\\n                    return target\\n        return output        \\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        if not nums:\\n            return None\\n        \\n        diff=float(\\'inf\\')\\n        nums.sort()\\n        \\n        for i in range(len(nums)-2):\\n            p1=i+1\\n            p2=len(nums)-1\\n            \\n            while p1<p2:\\n                s=nums[i]+nums[p1]+nums[p2]\\n                if abs(s-target) < diff:\\n                    diff=abs(s-target)\\n                    output=s\\n                \\n                if s<target:\\n                    p1+=1\\n                elif s>target:\\n                    p2-=1\\n                else:\\n                    return target\\n        return output        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 278202,
                "title": "c-two-pointers",
                "content": "```\\npublic class Solution {\\n    public int ThreeSumClosest(int[] nums, int target) {\\n        Array.Sort(nums);\\n        var n = nums.Length;\\n\\n        var globalClosest = int.MaxValue;\\n        var globalSum = 0;\\n        for (int i = 0; i < n; i++) {\\n            var left = i + 1;\\n            var right = n - 1;\\n\\n            while (left < right) {\\n                var sum = nums[i] + nums[left] + nums[right];\\n                var localClosest = Math.Abs(sum - target);\\n                if (sum == target) {\\n                    return target;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n\\n                if (globalClosest > localClosest) {\\n                    globalClosest = localClosest;\\n                    globalSum = sum;\\n                }\\n            }\\n\\n        }\\n\\n        return globalSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int ThreeSumClosest(int[] nums, int target) {\\n        Array.Sort(nums);\\n        var n = nums.Length;\\n\\n        var globalClosest = int.MaxValue;\\n        var globalSum = 0;\\n        for (int i = 0; i < n; i++) {\\n            var left = i + 1;\\n            var right = n - 1;\\n\\n            while (left < right) {\\n                var sum = nums[i] + nums[left] + nums[right];\\n                var localClosest = Math.Abs(sum - target);\\n                if (sum == target) {\\n                    return target;\\n                } else if (sum < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n\\n                if (globalClosest > localClosest) {\\n                    globalClosest = localClosest;\\n                    globalSum = sum;\\n                }\\n            }\\n\\n        }\\n\\n        return globalSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083996,
                "title": "best-o-n-2-solution",
                "content": "# Approach\\nSorting & Two Pointer \\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort (nums.begin(), nums.end());\\n        int sum = 0, prevDiff = INT_MAX;\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) {\\n                int curSum = nums[i] + nums[left] + nums[right];\\n                int diff = abs (target - curSum);\\n                if (diff < prevDiff) {\\n                    sum = curSum;\\n                    prevDiff = diff;\\n                }\\n                if (target > curSum)\\n                    left++;\\n                else\\n                    right--;    \\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort (nums.begin(), nums.end());\\n        int sum = 0, prevDiff = INT_MAX;\\n        for (int i = 0; i < n - 2; i++) {\\n            int left = i + 1, right = n - 1;\\n            while (left < right) {\\n                int curSum = nums[i] + nums[left] + nums[right];\\n                int diff = abs (target - curSum);\\n                if (diff < prevDiff) {\\n                    sum = curSum;\\n                    prevDiff = diff;\\n                }\\n                if (target > curSum)\\n                    left++;\\n                else\\n                    right--;    \\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812696,
                "title": "c-java-python-javascript",
                "content": "![Screenshot 2023-07-25 at 10.14.24 AM.png](https://assets.leetcode.com/users/images/7c652887-773d-4629-8591-0183ac74f26b_1690260281.8217592.png)\\n\\n\\n## \\uD83C\\uDF38\\uD83E\\uDDE9 Problem Statement \\uD83E\\uDDE9\\uD83C\\uDF38\\n- Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\\n\\n- Return the sum of the three integers.\\n\\n- *You may assume that each input would have **exactly one solution**.*\\n\\n#### \\uD83D\\uDD2E Example 1 :- \\n```\\nInput: nums = [-1,2,1,-4], target = 1\\nOutput: 2\\nExplanation: The sum that is closest to the target is \\n2. (-1 + 2 + 1 = 2).\\n\\n```\\n#### \\uD83D\\uDD2E Example 2 :- \\n```\\nInput: nums = [0,0,0], target = 1\\nOutput: 0\\nExplanation: The sum that is closest to the target is \\n0. (0 + 0 + 0 = 0).\\n\\n```\\n\\n## \\uD83E\\uDDE0 Optimal Approach Based on Sorting and Two Pointer\\n<!-- Describe your approach to solving the problem. -->\\n- The threeSumClosest function takes a vector nums and an integer target as input and returns an integer representing the sum of three elements closest to the target.\\n- It starts by sorting the input vector nums in ascending order using sort.\\n- Then, it iterates through the vector using a for-loop for each index i from 0 to n - 2, where n is the size of the vector.\\n- Inside the loop, it calls the Solve function, which uses a two-pointer approach to find the closest sum for the current index i.\\n- The Solve function uses two pointers, L and R, initialized to i + 1 and n - 1, respectively. It moves the pointers towards each other while calculating the sum of three elements (nums[x] + nums[L] + nums[R]) and updating the ans and mx variables based on the difference from the target.\\n- After iterating through all possible combinations of three elements, the function returns the final ans, which represents the sum of three elements closest to the target value.\\n\\n## \\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB Code \\n```\\nclass Solution\\n{\\n\\tpublic: int ans = 0;\\n\\tint mx = INT_MAX;\\n\\tvoid Solve(vector<int> &nums, int x, int i, int T)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tint L = i;\\n\\t\\tint R = n - 1;\\n\\t\\twhile (L < R)\\n\\t\\t{\\n\\t\\t\\tint val = (nums[x] + nums[L] + nums[R]);\\n\\t\\t\\tif (abs(T - val) < mx)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans = val;\\n\\t\\t\\t\\tmx = abs(T - val);\\n\\t\\t\\t}\\n\\t\\t\\telse if (val > T) R--;\\n\\t\\t\\telse L++;\\n\\t\\t}\\n\\t}\\n\\n\\tint threeSumClosest(vector<int> &nums, int target)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tsort(nums.begin(), nums.end());\\n\\t\\tfor (int i = 0; i < n - 2; i++)\\n\\t\\t{\\n\\t\\t\\tif (i == 0 || nums[i - 1] != nums[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tSolve(nums, i, i + 1, target);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n```\\n\\n#### \\uD83C\\uDF38 Complexity\\n- Time complexity : $$O(n^2)$$\\n- Space complexity : $$O(1)$$\\n\\n## \\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB All Code \\n\\n- Java\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    private int ans = 0;\\n    private int mx = Integer.MAX_VALUE;\\n    \\n    private void Solve(int[] nums, int x, int i, int T) {\\n        int n = nums.length;\\n        int L = i;\\n        int R = n - 1;\\n        while (L < R) {\\n            int val = (nums[x] + nums[L] + nums[R]);\\n            if (Math.abs(T - val) < mx) {\\n                ans = val;\\n                mx = Math.abs(T - val);\\n            } else if (val > T) {\\n                R--;\\n            } else {\\n                L++;\\n            }\\n        }\\n    }\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < n - 2; i++) {\\n            if (i == 0 || nums[i - 1] != nums[i]) {\\n                Solve(nums, i, i + 1, target);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n- Python\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.ans = 0\\n        self.mx = float(\\'inf\\')\\n\\n    def Solve(self, nums, x, i, T):\\n        n = len(nums)\\n        L = i\\n        R = n - 1\\n        while L < R:\\n            val = nums[x] + nums[L] + nums[R]\\n            if abs(T - val) < self.mx:\\n                self.ans = val\\n                self.mx = abs(T - val)\\n            elif val > T:\\n                R -= 1\\n            else:\\n                L += 1\\n\\n    def threeSumClosest(self, nums, target):\\n        n = len(nums)\\n        nums.sort()\\n        for i in range(n - 2):\\n            if i == 0 or nums[i - 1] != nums[i]:\\n                self.Solve(nums, i, i + 1, target)\\n        return self.ans\\n\\n```\\n- Javascript\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let n = nums.length;\\n    let closest_sum = nums[0] + nums[1] + nums[2]; \\n    for (let i = 0; i < n - 2; i++) {\\n        let left = i + 1, right = n - 1;\\n        while (left < right) { \\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (sum == target) { \\n                return sum;\\n            } else if (sum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n            if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { \\n                closest_sum = sum;\\n            }\\n        }\\n    }\\n    return closest_sum;\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nInput: nums = [-1,2,1,-4], target = 1\\nOutput: 2\\nExplanation: The sum that is closest to the target is \\n2. (-1 + 2 + 1 = 2).\\n\\n```\n```\\nInput: nums = [0,0,0], target = 1\\nOutput: 0\\nExplanation: The sum that is closest to the target is \\n0. (0 + 0 + 0 = 0).\\n\\n```\n```\\nclass Solution\\n{\\n\\tpublic: int ans = 0;\\n\\tint mx = INT_MAX;\\n\\tvoid Solve(vector<int> &nums, int x, int i, int T)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tint L = i;\\n\\t\\tint R = n - 1;\\n\\t\\twhile (L < R)\\n\\t\\t{\\n\\t\\t\\tint val = (nums[x] + nums[L] + nums[R]);\\n\\t\\t\\tif (abs(T - val) < mx)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans = val;\\n\\t\\t\\t\\tmx = abs(T - val);\\n\\t\\t\\t}\\n\\t\\t\\telse if (val > T) R--;\\n\\t\\t\\telse L++;\\n\\t\\t}\\n\\t}\\n\\n\\tint threeSumClosest(vector<int> &nums, int target)\\n\\t{\\n\\t\\tint n = nums.size();\\n\\t\\tsort(nums.begin(), nums.end());\\n\\t\\tfor (int i = 0; i < n - 2; i++)\\n\\t\\t{\\n\\t\\t\\tif (i == 0 || nums[i - 1] != nums[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tSolve(nums, i, i + 1, target);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n\\n```\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    private int ans = 0;\\n    private int mx = Integer.MAX_VALUE;\\n    \\n    private void Solve(int[] nums, int x, int i, int T) {\\n        int n = nums.length;\\n        int L = i;\\n        int R = n - 1;\\n        while (L < R) {\\n            int val = (nums[x] + nums[L] + nums[R]);\\n            if (Math.abs(T - val) < mx) {\\n                ans = val;\\n                mx = Math.abs(T - val);\\n            } else if (val > T) {\\n                R--;\\n            } else {\\n                L++;\\n            }\\n        }\\n    }\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for (int i = 0; i < n - 2; i++) {\\n            if (i == 0 || nums[i - 1] != nums[i]) {\\n                Solve(nums, i, i + 1, target);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def __init__(self):\\n        self.ans = 0\\n        self.mx = float(\\'inf\\')\\n\\n    def Solve(self, nums, x, i, T):\\n        n = len(nums)\\n        L = i\\n        R = n - 1\\n        while L < R:\\n            val = nums[x] + nums[L] + nums[R]\\n            if abs(T - val) < self.mx:\\n                self.ans = val\\n                self.mx = abs(T - val)\\n            elif val > T:\\n                R -= 1\\n            else:\\n                L += 1\\n\\n    def threeSumClosest(self, nums, target):\\n        n = len(nums)\\n        nums.sort()\\n        for i in range(n - 2):\\n            if i == 0 or nums[i - 1] != nums[i]:\\n                self.Solve(nums, i, i + 1, target)\\n        return self.ans\\n\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a, b) => a - b);\\n    let n = nums.length;\\n    let closest_sum = nums[0] + nums[1] + nums[2]; \\n    for (let i = 0; i < n - 2; i++) {\\n        let left = i + 1, right = n - 1;\\n        while (left < right) { \\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (sum == target) { \\n                return sum;\\n            } else if (sum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n            if (Math.abs(sum - target) < Math.abs(closest_sum - target)) { \\n                closest_sum = sum;\\n            }\\n        }\\n    }\\n    return closest_sum;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675029,
                "title": "optimal-o-n-2-o-n-two-sum-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& arr, int t) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        int ans = INT_MIN;\\n        for(int first = 0;first<=n-3;first++){\\n            int sec = first+1, third = n-1;\\n\\t\\t\\t// Two sum technique for second and third element\\n            while(sec < third){\\n                int sumtemp = arr[first] + arr[sec] + arr[third];\\n                if(sumtemp == t){\\n                    return sumtemp;\\n                }\\n                if(sumtemp < t ){\\n                    if(ans == INT_MIN) ans = sumtemp;\\n                    else{\\n                        if(abs(ans-t) > abs(sumtemp-t)) ans = sumtemp;\\n                    }\\n                    sec++;\\n                }\\n                else{\\n                    third--;\\n                    if(ans == INT_MIN) ans = sumtemp;\\n                    else{\\n                        if(abs(ans-t) > abs(sumtemp-t)) ans = sumtemp;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& arr, int t) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        int ans = INT_MIN;\\n        for(int first = 0;first<=n-3;first++){\\n            int sec = first+1, third = n-1;\\n\\t\\t\\t// Two sum technique for second and third element\\n            while(sec < third){\\n                int sumtemp = arr[first] + arr[sec] + arr[third];\\n                if(sumtemp == t){\\n                    return sumtemp;\\n                }\\n                if(sumtemp < t ){\\n                    if(ans == INT_MIN) ans = sumtemp;\\n                    else{\\n                        if(abs(ans-t) > abs(sumtemp-t)) ans = sumtemp;\\n                    }\\n                    sec++;\\n                }\\n                else{\\n                    third--;\\n                    if(ans == INT_MIN) ans = sumtemp;\\n                    else{\\n                        if(abs(ans-t) > abs(sumtemp-t)) ans = sumtemp;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282243,
                "title": "to-avoid-tle-in-python-optimization-tricks",
                "content": "You can optimize the classic approach to avoid TLE in Python. \\n\\nGiven the value of k, I pick the two rightmost numbers (which means it\\'s the largest value possible given k) and see if it\\'s still less than target. Ff it is, we use continue to avoid having the while loop run because it won\\'t get closer to the target than that.\\nSame logic can be applied to the other case where we pick the two left most points and if it\\'s greater than the target, we continue, but we can actually use break this time because we don\\'t need to even check larger values of k.\\n```\\nclass Solution:\\n   \\n   def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = float(\\'inf\\')\\n        for k in range(len(nums)-2):\\n            # largest 3sum given k\\n            s1 = nums[k] + nums[-2] + nums[-1]\\n            if s1 < target:\\n                if abs(s1-target) < abs(res-target):\\n                    res = s1\\n                continue\\n            \\n            # smallest 3sum given k\\n            s2 = nums[k] + nums[k+1] + nums[k+2]\\n            if s2 > target:\\n                if abs(s2-target) < abs(res-target):\\n                    res = s2\\n\\t\\t\\t\\tbreak\\n            \\n            i,j = k+1, len(nums)-1\\n            while i < j:\\n                s = nums[k] + nums[i] + nums[j]\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s == target:\\n                    return target\\n                if s < target:\\n                    i += 1\\n                else:\\n                    j -= 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n   \\n   def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = float(\\'inf\\')\\n        for k in range(len(nums)-2):\\n            # largest 3sum given k\\n            s1 = nums[k] + nums[-2] + nums[-1]\\n            if s1 < target:\\n                if abs(s1-target) < abs(res-target):\\n                    res = s1\\n                continue\\n            \\n            # smallest 3sum given k\\n            s2 = nums[k] + nums[k+1] + nums[k+2]\\n            if s2 > target:\\n                if abs(s2-target) < abs(res-target):\\n                    res = s2\\n\\t\\t\\t\\tbreak\\n            \\n            i,j = k+1, len(nums)-1\\n            while i < j:\\n                s = nums[k] + nums[i] + nums[j]\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s == target:\\n                    return target\\n                if s < target:\\n                    i += 1\\n                else:\\n                    j -= 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109008,
                "title": "python-easy-o-n-2",
                "content": "We assign the max and minimum value that we need to get.\\n**Sort the array.**\\n\\nWe iterate once to get one value. Then we put tw pointers , one at start and other at end.\\n\\n* If present value is in between min and max values we take that as answer and update min max.\\n* If value is less than min , increase the starting pointer\\n* If value is more than max, decrease the end pointer.\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, a: List[int], x: int) -> int:\\n        \\n        def find(i,j,k):\\n            if i>=j:\\n                return \\n            s=a[i]+a[j]+a[k]\\n            if s>=t[0]:\\n                find(i,j-1,k)\\n            elif s<t[1]:\\n                find(i+1,j,k)\\n            else:\\n                t[0]=x+abs(s-x)\\n                t[1]=x-abs(s-x)\\n                res[0]=s\\n                find(i+1,j,k)\\n                find(i,j-1,k)\\n                \\n        \\n        n=len(a)\\n        a.sort()\\n        res=[0]\\n        t=[math.inf,-math.inf]\\n        for k in range(n-2):\\n            i=k+1\\n            j=n-1\\n            find(i,j,k)\\n        return res[0]\\n```\\n\\n![image](https://assets.leetcode.com/users/images/2af13d6a-eaf0-491c-b710-ce227b31a353_1654332780.6307957.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, a: List[int], x: int) -> int:\\n        \\n        def find(i,j,k):\\n            if i>=j:\\n                return \\n            s=a[i]+a[j]+a[k]\\n            if s>=t[0]:\\n                find(i,j-1,k)\\n            elif s<t[1]:\\n                find(i+1,j,k)\\n            else:\\n                t[0]=x+abs(s-x)\\n                t[1]=x-abs(s-x)\\n                res[0]=s\\n                find(i+1,j,k)\\n                find(i,j-1,k)\\n                \\n        \\n        n=len(a)\\n        a.sort()\\n        res=[0]\\n        t=[math.inf,-math.inf]\\n        for k in range(n-2):\\n            i=k+1\\n            j=n-1\\n            find(i,j,k)\\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 498887,
                "title": "c-8-ms-faster-than-82-29",
                "content": "**Runtime: 8 ms, faster than 82.29% of C++ online submissions for 3Sum Closest.\\nMemory Usage: 8.7 MB, less than 77.36% of C++ online submissions for 3Sum Closest.**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int threeSumClosest(vector<int>& nums, int target) {\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int fix = 0 ;\\n        int tmp = nums[0]+nums[1]+nums[2] ;\\n        \\n        while( fix < nums.size() - 2 ){\\n            \\n            int left = fix + 1;\\n            int right = nums.size() - 1 ;\\n            \\n            while ( left < right ){\\n                \\n                int sum = nums[fix] + nums[left] + nums[right];\\n                if ( abs(sum-target) < abs(tmp-target) ) tmp = sum;\\n                if ( sum > target ) right -= 1;\\n                else if ( sum < target ) left += 1;\\n                else return target;\\n                \\n            }\\n            \\n            fix += 1;\\n            \\n        }\\n        return tmp;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int threeSumClosest(vector<int>& nums, int target) {\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        int fix = 0 ;\\n        int tmp = nums[0]+nums[1]+nums[2] ;\\n        \\n        while( fix < nums.size() - 2 ){\\n            \\n            int left = fix + 1;\\n            int right = nums.size() - 1 ;\\n            \\n            while ( left < right ){\\n                \\n                int sum = nums[fix] + nums[left] + nums[right];\\n                if ( abs(sum-target) < abs(tmp-target) ) tmp = sum;\\n                if ( sum > target ) right -= 1;\\n                else if ( sum < target ) left += 1;\\n                else return target;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 7961,
                "title": "simple-code-c",
                "content": "here is my code which is just similar to the code for previous problem 3Sum . but here we don't need to take consideration of duplicates.\\n\\n**threeSumClosest**\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(),nums.end());\\n            int n=nums.size(),ans;\\n            int min=INT_MAX;\\n            for(int i=0;i<n-2;i++){\\n                   int l=i+1, r= n-1;\\n                   while(l<r){\\n                       int sum =nums[i]+nums[l]+nums[r];\\n                       if(abs(sum-target)<min){  // updating the sum if sum  so far. is closest to target\\n                          min=abs(sum-target);\\n                          ans=sum;\\n                       }\\n                       if(sum<target) l++;        //\\n                       else if(sum>target)r--;\\n                       else {\\n                           return sum;  // we have sum equal to target which is closest so no need to check further \\n                       }\\n                   }\\n            }\\n            return ans;\\n        }\\n\\n**threeSum**\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n            sort(nums.begin(),nums.end());\\n            int n=nums.size();\\n            vector<vector<int>> res;\\n            for(int i=0;i<n-2;i++){\\n                   if(i>0 && (nums[i]==nums[i-1]) )continue;   // to avoid duplicates\\n                   int l=i+1, r= n-1;\\n                   while(l<r){\\n                       int sum =nums[i]+nums[l]+nums[r];\\n    \\n                       if(sum<0) l++;\\n                       else if(sum>0)r--;\\n                       else {\\n                           res.push_back(vector<int>{nums[i],nums[l],nums[r]});\\n                           while(l+1<r && nums[l]==nums[l+1])l++;    // to avoid duplicates\\n                           while(l<r-1 && nums[r]==nums[r-1]) r--;     // to avoid duplicates\\n                           l++; r--;\\n                       }\\n                   }\\n            }\\n    \\n            return res;\\n        }",
                "solutionTags": [],
                "code": "here is my code which is just similar to the code for previous problem 3Sum . but here we don't need to take consideration of duplicates.\\n\\n**threeSumClosest**\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(),nums.end());\\n            int n=nums.size(),ans;\\n            int min=INT_MAX;\\n            for(int i=0;i<n-2;i++){\\n                   int l=i+1, r= n-1;\\n                   while(l<r){\\n                       int sum =nums[i]+nums[l]+nums[r];\\n                       if(abs(sum-target)<min){  // updating the sum if sum  so far. is closest to target\\n                          min=abs(sum-target);\\n                          ans=sum;\\n                       }\\n                       if(sum<target) l++;        //\\n                       else if(sum>target)r--;\\n                       else {\\n                           return sum;  // we have sum equal to target which is closest so no need to check further \\n                       }\\n                   }\\n            }\\n            return ans;\\n        }\\n\\n**threeSum**\\n\\n    vector<vector<int>> threeSum(vector<int>& nums) {\\n            sort(nums.begin(),nums.end());\\n            int n=nums.size();\\n            vector<vector<int>> res;\\n            for(int i=0;i<n-2;i++){\\n                   if(i>0 && (nums[i]==nums[i-1]) )continue;   // to avoid duplicates\\n                   int l=i+1, r= n-1;\\n                   while(l<r){\\n                       int sum =nums[i]+nums[l]+nums[r];\\n    \\n                       if(sum<0) l++;\\n                       else if(sum>0)r--;\\n                       else {\\n                           res.push_back(vector<int>{nums[i],nums[l],nums[r]});\\n                           while(l+1<r && nums[l]==nums[l+1])l++;    // to avoid duplicates\\n                           while(l<r-1 && nums[r]==nums[r-1]) r--;     // to avoid duplicates\\n                           l++; r--;\\n                       }\\n                   }\\n            }\\n    \\n            return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 7915,
                "title": "sharing-my-java-optimized-solution-5ms-beats-99-9",
                "content": "It is just some optimized work after basic 3Sum structure.\\n\\n    public int threeSumClosest(int[] nums, int target) {\\n        if(nums.length<3) return 0;\\n        Arrays.sort(nums);\\n        int min = Integer.MAX_VALUE;int result =Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            if(3*nums[i]>target) \\n            {\\n                int sum3 = nums[i]+nums[i+1]+nums[i+2];\\n                if(Math.abs(sum3-target)<min)  return sum3;\\n                //break;           //should break here but seems slower after adding it\\n            }\\n            int left = i+1; \\n            int right = nums.length-1;\\n            int sum = target - nums[i];\\n            if(2*nums[right]<sum) {\\n                int sum2 = nums[i]+nums[right]+nums[right-1];\\n                 if(Math.abs(sum2-target)<min){\\n                     min = Math.abs(target-sum2);\\n                     result = sum2;\\n                 }\\n               continue;\\n            }\\n            while(left<right)\\n            {\\n                int temp = nums[i] + nums[left]+nums[right];\\n                if(temp==target) return target;\\n                if(2*nums[left]>sum) \\n                {\\n                  int sumsum = nums[i]+nums[left]+nums[left+1];\\n                  if(Math.abs(sumsum-target)<min){\\n                      min = Math.abs(target-sumsum);\\n                      result = sumsum;\\n                    }\\n                   break;\\n                }\\n                else if(Math.abs(target-temp)<min)\\n                {\\n                    min = Math.abs(target-temp);\\n                    result = temp;\\n                }\\n                if(temp<target) \\n                   left++;\\n                else right --;\\n            }\\n        }\\n        return result;\\n        }",
                "solutionTags": [],
                "code": "It is just some optimized work after basic 3Sum structure.\\n\\n    public int threeSumClosest(int[] nums, int target) {\\n        if(nums.length<3) return 0;\\n        Arrays.sort(nums);\\n        int min = Integer.MAX_VALUE;int result =Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            if(3*nums[i]>target) \\n            {\\n                int sum3 = nums[i]+nums[i+1]+nums[i+2];\\n                if(Math.abs(sum3-target)<min)  return sum3;\\n                //break;           //should break here but seems slower after adding it\\n            }\\n            int left = i+1; \\n            int right = nums.length-1;\\n            int sum = target - nums[i];\\n            if(2*nums[right]<sum) {\\n                int sum2 = nums[i]+nums[right]+nums[right-1];\\n                 if(Math.abs(sum2-target)<min){\\n                     min = Math.abs(target-sum2);\\n                     result = sum2;\\n                 }\\n               continue;\\n            }\\n            while(left<right)\\n            {\\n                int temp = nums[i] + nums[left]+nums[right];\\n                if(temp==target) return target;\\n                if(2*nums[left]>sum) \\n                {\\n                  int sumsum = nums[i]+nums[left]+nums[left+1];\\n                  if(Math.abs(sumsum-target)<min){\\n                      min = Math.abs(target-sumsum);\\n                      result = sumsum;\\n                    }\\n                   break;\\n                }\\n                else if(Math.abs(target-temp)<min)\\n                {\\n                    min = Math.abs(target-temp);\\n                    result = temp;\\n                }\\n                if(temp<target) \\n                   left++;\\n                else right --;\\n            }\\n        }\\n        return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3678639,
                "title": "shortest-sol-using-python-professional-code",
                "content": "\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        closet = float(\\'inf\\')\\n        nums.sort()\\n        for i in range(len(nums) - 2):\\n            l, r = i + 1, len(nums) - 1\\n            while l < r:\\n                sum3 = nums[i] + nums[l] + nums[r]\\n                print(sum3)\\n                if sum3 < target:\\n                    l += 1\\n                else:\\n                    r -=1\\n                if abs(sum3 - target) < abs(closet - target):\\n                    closet = sum3\\n        return closet\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        closet = float(\\'inf\\')\\n        nums.sort()\\n        for i in range(len(nums) - 2):\\n            l, r = i + 1, len(nums) - 1\\n            while l < r:\\n                sum3 = nums[i] + nums[l] + nums[r]\\n                print(sum3)\\n                if sum3 < target:\\n                    l += 1\\n                else:\\n                    r -=1\\n                if abs(sum3 - target) < abs(closet - target):\\n                    closet = sum3\\n        return closet\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953872,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int df=INT_MAX;\\n        int ans;\\n        for(int i=0;i<nums.size()-2;i++)\\n        {\\n            int s=i+1;\\n            int e=nums.size()-1;\\n            int sum=nums[i]+nums[s]+nums[e];\\n            while(s<e)\\n            {\\n                sum=nums[i]+nums[s]+nums[e];\\n                if(abs(sum-target)<df)\\n                {\\n                    df=abs(sum-target);\\n                    ans=sum;\\n                }\\n                    \\n                else if(sum<target)\\n                    s++;\\n                else\\n                    e--;    \\n            }\\n            while(i+1<nums.size() && nums[i+1]==nums[i])\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int df=INT_MAX;\\n        int ans;\\n        for(int i=0;i<nums.size()-2;i++)\\n        {\\n            int s=i+1;\\n            int e=nums.size()-1;\\n            int sum=nums[i]+nums[s]+nums[e];\\n            while(s<e)\\n            {\\n                sum=nums[i]+nums[s]+nums[e];\\n                if(abs(sum-target)<df)\\n                {\\n                    df=abs(sum-target);\\n                    ans=sum;\\n                }\\n                    \\n                else if(sum<target)\\n                    s++;\\n                else\\n                    e--;    \\n            }\\n            while(i+1<nums.size() && nums[i+1]==nums[i])\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792491,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int min_sum = INT_MAX, ans;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++) {\\n            int l = i + 1, r = nums.size() - 1; \\n            while (l < r) {\\n                int sum = nums[i] + nums[l] + nums[r];\\n                if(sum == target) {\\n                    return sum;\\n                }\\n                else if(sum < target) {\\n                    if(target - sum < min_sum) {\\n                        min_sum = target - sum;\\n                        ans = sum;\\n                    }\\n                    l++;\\n                }\\n                else if(sum > target) {\\n                    if(sum - target < min_sum) {\\n                        min_sum = sum - target;\\n                        ans = sum;\\n                    }\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int min_sum = INT_MAX, ans;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<nums.size(); i++) {\\n            int l = i + 1, r = nums.size() - 1; \\n            while (l < r) {\\n                int sum = nums[i] + nums[l] + nums[r];\\n                if(sum == target) {\\n                    return sum;\\n                }\\n                else if(sum < target) {\\n                    if(target - sum < min_sum) {\\n                        min_sum = target - sum;\\n                        ans = sum;\\n                    }\\n                    l++;\\n                }\\n                else if(sum > target) {\\n                    if(sum - target < min_sum) {\\n                        min_sum = sum - target;\\n                        ans = sum;\\n                    }\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693054,
                "title": "simple-java-solution-easy-to-understand",
                "content": "Upvote if you liked the solution\\n```\\n// We need to find the closest triplet that sums to target.\\n\\n// The brute force way is to iterate O(n^3) and to try all triplets. We can do better.\\n\\n// If we were working with pairs instead, we could do this with a two pointer technique if we had a monotonic order array. For example if our array is [-2,0,1,3,4,6,7] and our target is 2 we can initialize two pointers in the beginning and in the end. Then we would move left pointer up (increase sum) or move right pointer down (decrease sum) this way we would iterate over the search space trying to converge to target in O(n).\\n\\n// We can extend this algorithm to search a triplet. To do this, we will iterate our array and by doing this we will fix an element i at every iteration. Then all we have to do is find a pair(+ the fixed element) that sum closest to the target. This is exactly the process we described above.\\n\\n// To make the two pointer technique work we need to sort our array, otherwise we can\\'t rely on getting closer to the target by moving the pointers left or right.\\n\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n       \\n        Arrays.sort(nums);\\n        \\n        int closest=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            \\n            int low=i+1,high=nums.length-1;\\n            \\n            while(low<high)\\n            {\\n                int triplet=nums[i]+nums[low]+nums[high];\\n                if(Math.abs(target-closest)>Math.abs(target-triplet))\\n                    closest=triplet;\\n                \\n                if(triplet<target) low++;\\n                else high--;\\n            }\\n            \\n        }\\n        \\n        return closest;\\n    }\\n}",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n       \\n        Arrays.sort(nums);\\n        \\n        int closest=Integer.MAX_VALUE;\\n        \\n        for(int i=0;i<nums.length-2;i++)\\n        {\\n            \\n            int low=i+1,high=nums.length-1;\\n            \\n            while(low<high)\\n            {\\n                int triplet=nums[i]+nums[low]+nums[high];\\n                if(Math.abs(target-closest)>Math.abs(target-triplet))\\n                    closest=triplet;\\n                \\n                if(triplet<target) low++;\\n                else high--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2674362,
                "title": "python-implementation-with-two-pointers-open-question-about-runtime",
                "content": "**Python Implementation**\\nTwo pointers approach, similar with the solution of Question [_**3Sum**_](https://leetcode.com/problems/3sum/)\\n\\n```Python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        result = sum(nums[:3])\\n        for i in range(len(nums)-2):\\n            if i==0 and nums[i] == nums[i-1]:\\n                continue\\n            \\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                curr = nums[i] + nums[l] + nums[r]\\n                diff = curr - target\\n                if diff < 0:\\n                    l += 1\\n                elif diff > 0:\\n                    r -= 1\\n                else:\\n                    return curr\\n                \"\"\"\\n                TLE for block if statement\\n                \\n                if abs(result-target) > abs(diff):\\n                    result = curr\\n                \"\"\"\\n                result = curr if abs(result-target) > abs(diff) else result\\n\\n        \\n        return result\\n```\\n\\nBefore post this solution, I want to use the block if-statement to improve the readibility of the one-line statement. But it failed with TLE.\\n```\\nif abs(result-target) > abs(diff):\\n    result = curr\\n```\\n\\n### Open questions\\n - Do you have any idea on this?\\n - What\\'s the difference between the runtime of one-line if-statement and block if-statement in Python?\\n\\n![image](https://assets.leetcode.com/users/images/940686eb-abbd-42e0-91e3-cff4d8f88682_1665191244.2602255.png)\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```Python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        result = sum(nums[:3])\\n        for i in range(len(nums)-2):\\n            if i==0 and nums[i] == nums[i-1]:\\n                continue\\n            \\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                curr = nums[i] + nums[l] + nums[r]\\n                diff = curr - target\\n                if diff < 0:\\n                    l += 1\\n                elif diff > 0:\\n                    r -= 1\\n                else:\\n                    return curr\\n                \"\"\"\\n                TLE for block if statement\\n                \\n                if abs(result-target) > abs(diff):\\n                    result = curr\\n                \"\"\"\\n                result = curr if abs(result-target) > abs(diff) else result\\n\\n        \\n        return result\\n```\n```\\nif abs(result-target) > abs(diff):\\n    result = curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674295,
                "title": "daily-leetcoding-challenge-october-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/3sum-closest/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Two Pointers\n\n  \n**Approach 2:** Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/3sum-closest/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2253091,
                "title": "c-fully-explained-with-intuition-and-steps",
                "content": "**Intuition** \\n\\nThe first thing which comes to our mind is taking the sum of all possible triplets and finding which sum is nearest to the target. However, this method is brute force and hence time consuming. It has a time complexity of O(n^3).\\n\\nNow, let\\'s try to optimise it. \\n\\nForget about 3 sum closest, think about 2 sum closest first. If we had to find pair whose sum is closest to target, what would we have done? Again the brute force approach would have been to find all possible pairs and comparing the sums with the target. It will have time complexity  of O(n^2). However, we could solve it by just sorting the array and using double pointer approach. We could take 2 pointers and find the sum of those and then change the position of pointers by comparing the sum with target. This will cost us O(nlogn) time complexity. \\n\\nBetter, isn\\'t it?\\n\\nWhy not do the same thing in 3 sum closest? The worst time it could take is O(n^2)\\n\\n**Steps**\\n1. Sort the nums vector\\n2. Fix a particular element say ```nums[i]```\\n2. Now every time you fix one element in nums, take a starting pointer ```i+1``` and ending pointer ```nums.size()-1```\\n3. While the starting pointer is less than ending pointer, keep comparing the absolute difference of sum (```sum = nums[i] + nums[start] + nums[end]```) with target.\\n3. If  ```sum > target``` decrement end pointer ```end--```\\n4. If  ```sum < target``` increment start pointer ```start++```\\n5. If ```sum==target``` just return target\\n6. Keep a variable ans to store the sum which is closest to target and keep updating the ans in each iteration\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        sort (nums.begin(), nums.end());\\n        \\n        int mini = INT_MAX,ans, n = nums.size();\\n        \\n        for (int i=0; i<n-2; i++)\\n        {\\n            int comp = nums[i];\\n            \\n            int start = i+1, end = n-1;\\n            \\n            while(start<end)\\n            {\\n                int sum = nums[start]+nums[end]+comp;\\n                \\n                if (abs(sum - target)<mini)\\n                {\\n                    mini = abs(sum-target);\\n                    ans = sum;                \\n                }\\n                \\n                if (sum > target)\\n                    end--;\\n                else if (sum < target)\\n                    start++;\\n                else\\n                    return target;\\n                    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nFeel free to ask any question in the comment section.\\nI hope that you found the solution useful.\\nIf so, please do upvote and encourage me. \\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```nums[i]```\n```i+1```\n```nums.size()-1```\n```sum = nums[i] + nums[start] + nums[end]```\n```sum > target```\n```end--```\n```sum < target```\n```start++```\n```sum==target```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n        sort (nums.begin(), nums.end());\\n        \\n        int mini = INT_MAX,ans, n = nums.size();\\n        \\n        for (int i=0; i<n-2; i++)\\n        {\\n            int comp = nums[i];\\n            \\n            int start = i+1, end = n-1;\\n            \\n            while(start<end)\\n            {\\n                int sum = nums[start]+nums[end]+comp;\\n                \\n                if (abs(sum - target)<mini)\\n                {\\n                    mini = abs(sum-target);\\n                    ans = sum;                \\n                }\\n                \\n                if (sum > target)\\n                    end--;\\n                else if (sum < target)\\n                    start++;\\n                else\\n                    return target;\\n                    \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227046,
                "title": "python-tle-for-o-n2-new-test-cases",
                "content": "Last time I did this question was on 16-06-2022, there were 132 cases. Leetcode has added new cases (current total = 381) since then and now my same solution is TLE.\\n\\nI am using the sort + two-pointer approach, and there is proof by contradiction, there is no better solution possible. The question is giving TLE for other submitted (top-votes discussion) solutions as well.\\nMy Python Solution\\n```\\ndef threeSumClosest(self, nums: List[int], k: int) -> int:\\n        ans=float(\\'inf\\')\\n        nums.sort()\\n        a2=0\\n        for i in range(len(nums)):\\n            l=i+1\\n            r=len(nums)-1\\n            while l<r:\\n                x=nums[i]+nums[l]+nums[r]\\n                z=abs(k-x)\\n                if z<ans:\\n                    ans=z\\n                    a2=x\\n                if x<k:\\n                    l+=1\\n                else:\\n                    r-=1\\n        return a2\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\ndef threeSumClosest(self, nums: List[int], k: int) -> int:\\n        ans=float(\\'inf\\')\\n        nums.sort()\\n        a2=0\\n        for i in range(len(nums)):\\n            l=i+1\\n            r=len(nums)-1\\n            while l<r:\\n                x=nums[i]+nums[l]+nums[r]\\n                z=abs(k-x)\\n                if z<ans:\\n                    ans=z\\n                    a2=x\\n                if x<k:\\n                    l+=1\\n                else:\\n                    r-=1\\n        return a2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2193901,
                "title": "python-modified-3sum-approach",
                "content": "![image](https://assets.leetcode.com/users/images/10e73d09-7878-4a90-867d-fdf00e56ebc2_1656379823.6041436.jpeg)\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort();\\n        res=sum(nums[:3])\\n        for i in range(0,len(nums)):\\n            j=i+1\\n            k=len(nums)-1\\n            while(j<k):\\n                s = sum((nums[i], nums[j], nums[k]))\\n                if(abs(s-target) <abs(res-target)):\\n                    res=s\\n                if(s<target):\\n                    j+=1\\n                elif(s>target):\\n                    k-=1\\n                else:\\n                    return res\\n        return res\\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort();\\n        res=sum(nums[:3])\\n        for i in range(0,len(nums)):\\n            j=i+1\\n            k=len(nums)-1\\n            while(j<k):\\n                s = sum((nums[i], nums[j], nums[k]))\\n                if(abs(s-target) <abs(res-target)):\\n                    res=s\\n                if(s<target):\\n                    j+=1\\n                elif(s>target):\\n                    k-=1\\n                else:\\n                    return res\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169868,
                "title": "python-solution-beats-83-240ms",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.KSumClosest(nums, 3, target)\\n\\n    def KSumClosest(self, nums: List[int], k: int, target: int) -> int:\\n        N = len(nums)\\n        if N == k:\\n            return sum(nums[:k])\\n\\n        current = sum(nums[:k])\\n        if current >= target:\\n            return current\\n\\n        current = sum(nums[-k:])\\n        if current <= target:\\n            return current\\n        \\n        if k == 1:\\n            return min([(x, abs(target - x)) for x in nums], key = lambda x: x[1])[0]\\n\\n        closest = sum(nums[:k])\\n        for i, x in enumerate(nums[:-k+1]):\\n            if i>0 and x == nums[i-1]:\\n                continue\\n            current = self.KSumClosest(nums[i+1:], k-1, target - x) + x\\n            if abs(target - current) < abs(target - closest):\\n                if current == target:\\n                    return target\\n                else:\\n                    closest = current\\n\\n        return closest",
                "codeTag": "Java"
            },
            {
                "id": 1447243,
                "title": "c-solution-4ms-98-63-5-7mb-92-88",
                "content": "```\\n\\nint compare(const void *a, const void *b){\\n  return *(int*)a - *(int*)b;\\n}\\nint threeSumClosest(int* nums, int numsSize, int target){\\n  int result = nums[0] + nums[1] + nums[2];\\n  int limit = numsSize - 1, second, third, dis = abs(result - target), temp1, temp2;\\n  \\n  qsort(nums, numsSize, sizeof(int), compare);\\n  for(int first = 0; first < limit; first++){\\n    second = first + 1;\\n    third = limit;\\n    while(second < third){\\n      temp1 = nums[first] + nums[second] + nums[third];\\n      temp2 = abs(temp1 - target);\\n      if (temp2 < dis) {\\n        dis = temp2;\\n        result = temp1;\\n      }\\n      if (result == target) return result;\\n      else if (temp1 > target) third--;\\n      else if (temp1 < target) second++;\\n    }\\n  }\\n  return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nint compare(const void *a, const void *b){\\n  return *(int*)a - *(int*)b;\\n}\\nint threeSumClosest(int* nums, int numsSize, int target){\\n  int result = nums[0] + nums[1] + nums[2];\\n  int limit = numsSize - 1, second, third, dis = abs(result - target), temp1, temp2;\\n  \\n  qsort(nums, numsSize, sizeof(int), compare);\\n  for(int first = 0; first < limit; first++){\\n    second = first + 1;\\n    third = limit;\\n    while(second < third){\\n      temp1 = nums[first] + nums[second] + nums[third];\\n      temp2 = abs(temp1 - target);\\n      if (temp2 < dis) {\\n        dis = temp2;\\n        result = temp1;\\n      }\\n      if (result == target) return result;\\n      else if (temp1 > target) third--;\\n      else if (temp1 < target) second++;\\n    }\\n  }\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1366451,
                "title": "c-3-clean-approaches-go-from-naive-to-best",
                "content": "```\\n//Approach-1 (The first approach that comes to our mind) Time : O(n^3)\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int minDiff = INT_MAX;\\n        int result = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            for(int j = i+1; j<n-1; j++) {\\n                for(int k = j+1; k<n; k++) {\\n                    int sum  = nums[i]+nums[j]+nums[k];\\n                    int diff = abs(target-sum);\\n                    if(diff < minDiff) {\\n                        minDiff = diff;\\n                        result = sum;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Using Binary Search) (Time : O(n^2 logn))\\n//Think about fixing two numbers and finding best 3rd number using Binary Search\\nclass Solution {\\npublic:\\n    int n;\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        n = nums.size();\\n        sort(begin(nums), end(nums));\\n        \\n        int minDiff = INT_MAX;\\n        int sum     = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            for(int j = i + 1; j<n-1; j++) {\\n                int remain = target - (nums[i] + nums[j]);\\n                auto it    = upper_bound(begin(nums)+j+1, end(nums), remain); //returns iterator to a number > remain\\n                \\n                int r = it-begin(nums), l = r-1;\\n                \\n                if(r < n && abs(remain - nums[r]) < minDiff) {\\n                    minDiff = abs(remain - nums[r]);\\n                    sum     = nums[i] + nums[j] + nums[r];\\n                }\\n                \\n                if(l > j && abs(remain - nums[l]) < minDiff) {\\n                    minDiff = abs(remain - nums[l]);\\n                    sum     = nums[i] + nums[j] + nums[l];\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```\\n\\n```\\n/*Approach-2 (Using two pointers approach) Time : O(n^2)\\nSince we have to find closest sum, we can\\'t use hash map to our benefit. 2-pointers approach suits the best for this problem and it\\'s the best one\\n*/\\nclass Solution {\\npublic:\\n    int n;\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        n = nums.size();\\n        sort(begin(nums), end(nums));\\n        \\n        int minDiff = INT_MAX;\\n        int sum     = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            int l = i+1, r = n-1;\\n            \\n            while(l < r) {\\n                int temp = nums[i] + nums[l] + nums[r];\\n                int diff = abs(target-temp);\\n                \\n                if(diff < minDiff) {\\n                    minDiff = diff;\\n                    sum     = temp;\\n                    if(minDiff == 0) return sum;\\n                }\\n                \\n                if(temp < target) l++;\\n                else r--;\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (The first approach that comes to our mind) Time : O(n^3)\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int minDiff = INT_MAX;\\n        int result = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            for(int j = i+1; j<n-1; j++) {\\n                for(int k = j+1; k<n; k++) {\\n                    int sum  = nums[i]+nums[j]+nums[k];\\n                    int diff = abs(target-sum);\\n                    if(diff < minDiff) {\\n                        minDiff = diff;\\n                        result = sum;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2 (Using Binary Search) (Time : O(n^2 logn))\\n//Think about fixing two numbers and finding best 3rd number using Binary Search\\nclass Solution {\\npublic:\\n    int n;\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        n = nums.size();\\n        sort(begin(nums), end(nums));\\n        \\n        int minDiff = INT_MAX;\\n        int sum     = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            for(int j = i + 1; j<n-1; j++) {\\n                int remain = target - (nums[i] + nums[j]);\\n                auto it    = upper_bound(begin(nums)+j+1, end(nums), remain); //returns iterator to a number > remain\\n                \\n                int r = it-begin(nums), l = r-1;\\n                \\n                if(r < n && abs(remain - nums[r]) < minDiff) {\\n                    minDiff = abs(remain - nums[r]);\\n                    sum     = nums[i] + nums[j] + nums[r];\\n                }\\n                \\n                if(l > j && abs(remain - nums[l]) < minDiff) {\\n                    minDiff = abs(remain - nums[l]);\\n                    sum     = nums[i] + nums[j] + nums[l];\\n                }\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```\n```\\n/*Approach-2 (Using two pointers approach) Time : O(n^2)\\nSince we have to find closest sum, we can\\'t use hash map to our benefit. 2-pointers approach suits the best for this problem and it\\'s the best one\\n*/\\nclass Solution {\\npublic:\\n    int n;\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        n = nums.size();\\n        sort(begin(nums), end(nums));\\n        \\n        int minDiff = INT_MAX;\\n        int sum     = 0;\\n        \\n        for(int i = 0; i<n-2; i++) {\\n            int l = i+1, r = n-1;\\n            \\n            while(l < r) {\\n                int temp = nums[i] + nums[l] + nums[r];\\n                int diff = abs(target-temp);\\n                \\n                if(diff < minDiff) {\\n                    minDiff = diff;\\n                    sum     = temp;\\n                    if(minDiff == 0) return sum;\\n                }\\n                \\n                if(temp < target) l++;\\n                else r--;\\n            }\\n        }\\n        \\n        return sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362223,
                "title": "javascript-easy-clean-solution",
                "content": "\\n\\n    var threeSumClosest = function(nums, target) {\\n        nums.sort((a,b) => a-b)\\n        let diff = Infinity;\\n    \\n        for(var i = 0; i < nums.length; i++) {\\n            let j = i + 1;\\n            let k = nums.length - 1\\n        \\n            while(j < k) {\\n                let sum = nums[i]+nums[j]+nums[k]\\n            \\n                if(Math.abs(diff) > Math.abs(target-sum)) {\\n                    diff = target - sum\\n                }\\n            \\n                if(sum < target) {\\n                    j++\\n                } else {\\n                    k--\\n                }\\n            }\\n        }\\n        return target - diff\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n    var threeSumClosest = function(nums, target) {\\n        nums.sort((a,b) => a-b)\\n        let diff = Infinity;\\n    \\n        for(var i = 0; i < nums.length; i++) {\\n            let j = i + 1;\\n            let k = nums.length - 1\\n        \\n            while(j < k) {\\n                let sum = nums[i]+nums[j]+nums[k]\\n            \\n                if(Math.abs(diff) > Math.abs(target-sum)) {\\n                    diff = target - sum\\n                }\\n            \\n                if(sum < target) {\\n                    j++\\n                } else {\\n                    k--\\n                }\\n            }\\n        }\\n        return target - diff\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 447655,
                "title": "java-6ms-o-n-2-solution",
                "content": "```\\npublic int threeSumClosest(int[] nums, int target) {\\n        if(nums.length==3) return nums[0]+nums[1]+nums[2];\\n        Arrays.sort(nums);\\n\\t\\tint res = 0, diff = Integer.MAX_VALUE;\\n\\t\\tfor (int i = 0; i < nums.length - 2; i++) {\\n\\t\\t\\tint j = i + 1;\\n\\t\\t\\tint k = nums.length - 1;\\n\\t\\t\\twhile (j < k) {\\n\\t\\t\\t\\tint sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\t\\tif (Math.abs(sum - target) < diff) {\\n\\t\\t\\t\\t\\tdiff = Math.abs(sum - target);\\n\\t\\t\\t\\t\\tres = sum;\\n\\t\\t\\t\\t}\\n                if(sum > target){\\n                    k--;\\n                }else{\\n                    j++;\\n                }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int threeSumClosest(int[] nums, int target) {\\n        if(nums.length==3) return nums[0]+nums[1]+nums[2];\\n        Arrays.sort(nums);\\n\\t\\tint res = 0, diff = Integer.MAX_VALUE;\\n\\t\\tfor (int i = 0; i < nums.length - 2; i++) {\\n\\t\\t\\tint j = i + 1;\\n\\t\\t\\tint k = nums.length - 1;\\n\\t\\t\\twhile (j < k) {\\n\\t\\t\\t\\tint sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\t\\tif (Math.abs(sum - target) < diff) {\\n\\t\\t\\t\\t\\tdiff = Math.abs(sum - target);\\n\\t\\t\\t\\t\\tres = sum;\\n\\t\\t\\t\\t}\\n                if(sum > target){\\n                    k--;\\n                }else{\\n                    j++;\\n                }\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260076,
                "title": "python-clear-solution-with-comments-o-n-2",
                "content": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums, target: int) -> int:\\n        nums.sort()\\n\\n        # result cant be worse than sum of random 3 nums\\n        res = sum(nums[0: 3])\\n        diff = abs(res - target)\\n\\n        for i in range(len(nums) - 2):\\n            j, k = i + 1, len(nums) - 1\\n\\n            # if 3 * smallest num - target > diff, the rest bigger sum can be skipped\\n            if nums[i] * 3 - target > diff:\\n                break\\n\\n            while j < k:\\n                r = nums[i] + nums[j] + nums[k]\\n\\n                # if closer, update\\n                if abs(r - target) < diff:\\n                    res = r\\n                    diff = abs(r - target)\\n                \\n                # if larger than target, decrease\\n                if r > target:\\n                    k = k - 1\\n                \\n                # if smaller than target, increase\\n                elif r < target:\\n                    j = j + 1\\n                \\n                # just target\\n                else:\\n                    return r\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums, target: int) -> int:\\n        nums.sort()\\n\\n        # result cant be worse than sum of random 3 nums\\n        res = sum(nums[0: 3])\\n        diff = abs(res - target)\\n\\n        for i in range(len(nums) - 2):\\n            j, k = i + 1, len(nums) - 1\\n\\n            # if 3 * smallest num - target > diff, the rest bigger sum can be skipped\\n            if nums[i] * 3 - target > diff:\\n                break\\n\\n            while j < k:\\n                r = nums[i] + nums[j] + nums[k]\\n\\n                # if closer, update\\n                if abs(r - target) < diff:\\n                    res = r\\n                    diff = abs(r - target)\\n                \\n                # if larger than target, decrease\\n                if r > target:\\n                    k = k - 1\\n                \\n                # if smaller than target, increase\\n                elif r < target:\\n                    j = j + 1\\n                \\n                # just target\\n                else:\\n                    return r\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7885,
                "title": "12-lines-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int diff = INT_MAX, res = 0;\\n        for(int i = 0; i < nums.size() - 2; i++){\\n            int lo = i + 1, hi = nums.size() - 1;\\n            while(lo < hi){\\n                int sum = nums[i] + nums[lo] + nums[hi];\\n                if(sum == target) return target;\\n                if(abs(sum - target) < diff) diff = abs(sum - target), res = sum;\\n                (sum > target) ? hi-- : lo++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int diff = INT_MAX, res = 0;\\n        for(int i = 0; i < nums.size() - 2; i++){\\n            int lo = i + 1, hi = nums.size() - 1;\\n            while(lo < hi){\\n                int sum = nums[i] + nums[lo] + nums[hi];\\n                if(sum == target) return target;\\n                if(abs(sum - target) < diff) diff = abs(sum - target), res = sum;\\n                (sum > target) ? hi-- : lo++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 8004,
                "title": "self-explanatory-java-solution-using-two-pointers",
                "content": "      public int threeSumClosest(int[] nums, int target) {\\n            if(nums==null || nums.length<3)\\n                return -1;\\n            Arrays.sort(nums);\\n            int result = 0;\\n            int diff = Integer.MAX_VALUE;\\n            for(int i=0; i<nums.length-1; i++){\\n                if(i>0 && nums[i] == nums[i-1])\\n                    continue;\\n                int j = i+1;\\n                int k = nums.length-1;\\n                while(j<k){\\n                    int sum = nums[i]+nums[j]+nums[k];\\n                    if(diff> Math.abs(target-sum)){\\n                        result=sum;\\n                        diff = Math.abs(target-sum);\\n                    }if(sum==target){\\n                        return sum;\\n                    }else if(sum<target){\\n                        j++;\\n                    }else\\n                        k--;\\n                }\\n                \\n            }\\n            return result;\\n        }",
                "solutionTags": [],
                "code": "      public int threeSumClosest(int[] nums, int target) {\\n            if(nums==null || nums.length<3)\\n                return -1;\\n            Arrays.sort(nums);\\n            int result = 0;\\n            int diff = Integer.MAX_VALUE;\\n            for(int i=0; i<nums.length-1; i++){\\n                if(i>0 && nums[i] == nums[i-1])\\n                    continue;\\n                int j = i+1;\\n                int k = nums.length-1;\\n                while(j<k){\\n                    int sum = nums[i]+nums[j]+nums[k];\\n                    if(diff> Math.abs(target-sum)){\\n                        result=sum;\\n                        diff = Math.abs(target-sum);\\n                    }if(sum==target){\\n                        return sum;\\n                    }else if(sum<target){\\n                        j++;\\n                    }else\\n                        k--;\\n                }\\n                \\n            }\\n            return result;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 7921,
                "title": "my-enhanced-n-2-answer-could-be-n-logn-minimum-time-12ms",
                "content": "The outer loop is same as most people;\\nFor the inner while loop, instead of gradually doing left++, right--, I use binary search to find the closest match.  Binary search interval should be [left+1, right-1].  I use STL <algorithm> lower_bound function.\\n\\nIf current num[left]+num[right] is greater than target, then we want to move \"right\" to the left, because num[right] is too big.\\n\\nWe use lower_bound to find a number that is closest to the \"final target\". i.e., target - num[i] - num[left], \\nIf lower_bound return  the iterator points to num[right], then we simply do right--, because that means the biggest number we can try next is num[right-1]\\n\\nIf current num[left]+num[right] is less than target, then we want to move \"left\" to the right, because num[left] is too small. \\nSearch  the \"final target\". i.e., target - num[i] - num[right], \\nIf lower_bound return  the iterator points to num[right], then that means all numbers in interval [left+1, right-1] are all too small to meet the target. Thus, we only need to calculate num[i]+num[right-1]+num[right] and see how close it is to the target. Then we break the while loop.\\n\\n    class Solution {\\n    public:\\n        int threeSumClosest(vector<int> &num, int target) {\\n            if(num.size() == 0) return 0;\\n            if(num.size() == 1) return num[0];\\n            if(num.size() == 2) return num[0]+num[1];\\n            int closest = num[0]+num[1]+num[2];\\n            if(num.size() == 3) return closest;\\n            \\n            sort(num.begin(), num.end());\\n    \\n            for(int i = 0; i < num.size()-2; i++) {\\n                int new_target = target - num[i];\\n                int left = i+1, right = num.size()-1;\\n                \\n                while(right>left) {\\n                    int sum = num[left] + num[right];\\n                    if (sum == new_target)\\n                       return target;\\n                    \\n                    if ( std::abs(sum+num[i] - target) < std::abs(closest-target) ) {\\n                        closest = sum + num[i];\\n                    } \\n                    if(sum > new_target) {\\n                        vector<int>::iterator it = lower_bound(num.begin()+left+1, num.begin()+right, new_target-num[left]);\\n                        if (it == num.begin()+right) {\\n                            right--;\\n                        } else {\\n                          right = distance(num.begin(), it);\\n                        }\\n                      //  right--;     //original code\\n                    } else if (sum < new_target) {\\n                        vector<int>::iterator it = lower_bound(num.begin()+left+1, num.begin()+right, new_target-num[right]);\\n                        if( it == num.begin()+right) {  //cannot find anything big enough\\n                            left = right -1;\\n                            if ( std::abs(num[left]+num[right]+num[i] - target) < std::abs(closest-target) ) {\\n                                closest = num[left]+num[right]+num[i];\\n                            }                         \\n                            break;\\n                        } else {\\n                            left = distance(num.begin(), it);\\n                        }\\n                        \\n                        //  left++;   //original code\\n                    }\\n                    \\n                }\\n            }\\n            return closest;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int threeSumClosest(vector<int> &num, int target) {\\n            if(num.size() == 0) return 0;\\n            if(num.size() == 1) return num[0];\\n            if(num.size() == 2) return num[0]+num[1];\\n            int closest = num[0]+num[1]+num[2];\\n            if(num.size() == 3) return closest;\\n            \\n            sort(num.begin(), num.end());\\n    \\n            for(int i = 0; i < num.size()-2; i++) {\\n                int new_target = target - num[i];\\n                int left = i+1, right = num.size()-1;\\n                \\n                while(right>left) {\\n                    int sum = num[left] + num[right];\\n                    if (sum == new_target)\\n                       return target;\\n                    \\n                    if ( std::abs(sum+num[i] - target) < std::abs(closest-target) ) {\\n                        closest = sum + num[i];\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3938010,
                "title": "swift-c-python-java-easy-to-understand-and-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(|ans|)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Swift\\n```\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        var ans = nums[0] + nums[1] + nums[2]\\n        var (nums, len) = (nums.sorted(), nums.count)\\n\\n        for i in 0..<len - 2{\\n            if i > 0 && nums[i] == nums[i - 1] { continue }\\n            var (l, r) = (i + 1, len - 1)\\n\\n            while l < r {\\n                var sum = nums[i] + nums[l] + nums[r]\\n\\n                if sum == target { return sum }\\n                if abs(sum - target) < abs(ans - target) { ans = sum }\\n\\n                sum < target ? (l += 1) : (r -= 1)\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```\\n\\n# C++\\n```\\nclass Solution {\\n public:\\n  int threeSumClosest(vector<int>& nums, int target) {\\n    int ans = nums[0] + nums[1] + nums[2];\\n    sort(nums.begin(), nums.end());\\n\\n    for (int i = 0; i + 2 < nums.size(); ++i) {\\n      if (i > 0 && nums[i] == nums[i - 1])\\n        continue;\\n\\n      int l = i + 1;\\n      int r = nums.size() - 1;\\n\\n      while (l < r) {\\n        const int sum = nums[i] + nums[l] + nums[r];\\n        if (sum == target)\\n          return sum;\\n        if (abs(sum - target) < abs(ans - target))\\n          ans = sum;\\n        if (sum < target)\\n          ++l;\\n        else\\n          --r;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\\n# Python\\n```\\nclass Solution:\\n  def threeSumClosest(self, nums: List[int], target: int) -> int:\\n    ans = nums[0] + nums[1] + nums[2]\\n    nums.sort()\\n\\n    for i in range(len(nums) - 2):\\n      if i > 0 and nums[i] == nums[i - 1]:\\n        continue\\n\\n      l = i + 1\\n      r = len(nums) - 1\\n\\n      while l < r:\\n        summ = nums[i] + nums[l] + nums[r]\\n        if summ == target:\\n          return summ\\n        if abs(summ - target) < abs(ans - target):\\n          ans = summ\\n        if summ < target:\\n          l += 1\\n        else:\\n          r -= 1\\n\\n    return ans\\n```\\n# Java\\n```\\nclass Solution {\\n  public int threeSumClosest(int[] nums, int target) {\\n    int ans = nums[0] + nums[1] + nums[2];\\n    Arrays.sort(nums);\\n\\n    for (int i = 0; i + 2 < nums.length; ++i) {\\n      if (i > 0 && nums[i] == nums[i - 1])\\n        continue;\\n\\n      int l = i + 1;\\n      int r = nums.length - 1;\\n\\n      while (l < r) {\\n        final int sum = nums[i] + nums[l] + nums[r];\\n        if (sum == target)\\n          return sum;\\n        if (Math.abs(sum - target) < Math.abs(ans - target))\\n          ans = sum;\\n        if (sum < target)\\n          ++l;\\n        else\\n          --r;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Swift",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    func threeSumClosest(_ nums: [Int], _ target: Int) -> Int {\\n        var ans = nums[0] + nums[1] + nums[2]\\n        var (nums, len) = (nums.sorted(), nums.count)\\n\\n        for i in 0..<len - 2{\\n            if i > 0 && nums[i] == nums[i - 1] { continue }\\n            var (l, r) = (i + 1, len - 1)\\n\\n            while l < r {\\n                var sum = nums[i] + nums[l] + nums[r]\\n\\n                if sum == target { return sum }\\n                if abs(sum - target) < abs(ans - target) { ans = sum }\\n\\n                sum < target ? (l += 1) : (r -= 1)\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```\n```\\nclass Solution {\\n public:\\n  int threeSumClosest(vector<int>& nums, int target) {\\n    int ans = nums[0] + nums[1] + nums[2];\\n    sort(nums.begin(), nums.end());\\n\\n    for (int i = 0; i + 2 < nums.size(); ++i) {\\n      if (i > 0 && nums[i] == nums[i - 1])\\n        continue;\\n\\n      int l = i + 1;\\n      int r = nums.size() - 1;\\n\\n      while (l < r) {\\n        const int sum = nums[i] + nums[l] + nums[r];\\n        if (sum == target)\\n          return sum;\\n        if (abs(sum - target) < abs(ans - target))\\n          ans = sum;\\n        if (sum < target)\\n          ++l;\\n        else\\n          --r;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\n```\\nclass Solution:\\n  def threeSumClosest(self, nums: List[int], target: int) -> int:\\n    ans = nums[0] + nums[1] + nums[2]\\n    nums.sort()\\n\\n    for i in range(len(nums) - 2):\\n      if i > 0 and nums[i] == nums[i - 1]:\\n        continue\\n\\n      l = i + 1\\n      r = len(nums) - 1\\n\\n      while l < r:\\n        summ = nums[i] + nums[l] + nums[r]\\n        if summ == target:\\n          return summ\\n        if abs(summ - target) < abs(ans - target):\\n          ans = summ\\n        if summ < target:\\n          l += 1\\n        else:\\n          r -= 1\\n\\n    return ans\\n```\n```\\nclass Solution {\\n  public int threeSumClosest(int[] nums, int target) {\\n    int ans = nums[0] + nums[1] + nums[2];\\n    Arrays.sort(nums);\\n\\n    for (int i = 0; i + 2 < nums.length; ++i) {\\n      if (i > 0 && nums[i] == nums[i - 1])\\n        continue;\\n\\n      int l = i + 1;\\n      int r = nums.length - 1;\\n\\n      while (l < r) {\\n        final int sum = nums[i] + nums[l] + nums[r];\\n        if (sum == target)\\n          return sum;\\n        if (Math.abs(sum - target) < Math.abs(ans - target))\\n          ans = sum;\\n        if (sum < target)\\n          ++l;\\n        else\\n          --r;\\n      }\\n    }\\n\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889785,
                "title": "simple-solution-beats-95-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int ans;\\n        int dif;\\n        int n=0;\\n        for(int i=0;i<nums.size();i++){\\n            int j=i+1;\\n            int k=nums.size()-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(sum==target){\\n                    return sum;\\n                }\\n                int m=abs(target-sum);\\n                if(i==0||m<dif){\\n                    dif=m;\\n                    ans=sum;\\n                }\\n                if(sum<target)\\n                j++;\\n                else \\n                k--;\\n                if(ans+1==target||ans-1==target)\\n                n=ans;\\n            }\\n        }\\n        if(n!=0)\\n        return n;\\n        else\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int ans;\\n        int dif;\\n        int n=0;\\n        for(int i=0;i<nums.size();i++){\\n            int j=i+1;\\n            int k=nums.size()-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(sum==target){\\n                    return sum;\\n                }\\n                int m=abs(target-sum);\\n                if(i==0||m<dif){\\n                    dif=m;\\n                    ans=sum;\\n                }\\n                if(sum<target)\\n                j++;\\n                else \\n                k--;\\n                if(ans+1==target||ans-1==target)\\n                n=ans;\\n            }\\n        }\\n        if(n!=0)\\n        return n;\\n        else\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586091,
                "title": "three-sum-closest-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach is same as the three sum which is by using three pointers,the only difference here to find the closest sum to target is to check if the absolute difference between the sum and the target is smaller than the absolute difference between closest and the target. If so, update closest to the current sum.\\n\\n# Complexity\\n- Time complexity:\\n O(n^2)\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n       \\n       int closest= nums[0]+nums[1]+nums[2];\\n       sort(nums.begin(),nums.end());\\n        if(nums.size()<3)\\n        {\\n            return 0;\\n        }\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           int j=i+1;\\n           int k=nums.size()-1;\\n           while(j<k){\\n               int sum=nums[i]+nums[j]+nums[k];\\n               if(sum==target)\\n               {\\n                   j++;\\n                   k--;\\n               }\\n               if(abs(target-sum)<abs(target-closest))\\n               {\\n                   closest=sum;\\n               }\\n               if(sum<target){\\n                   j++;\\n               }\\n               else{\\n                   k--;\\n               }\\n           }\\n       }\\n\\n        return closest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n       \\n       int closest= nums[0]+nums[1]+nums[2];\\n       sort(nums.begin(),nums.end());\\n        if(nums.size()<3)\\n        {\\n            return 0;\\n        }\\n       for(int i=0;i<nums.size();i++)\\n       {\\n           int j=i+1;\\n           int k=nums.size()-1;\\n           while(j<k){\\n               int sum=nums[i]+nums[j]+nums[k];\\n               if(sum==target)\\n               {\\n                   j++;\\n                   k--;\\n               }\\n               if(abs(target-sum)<abs(target-closest))\\n               {\\n                   closest=sum;\\n               }\\n               if(sum<target){\\n                   j++;\\n               }\\n               else{\\n                   k--;\\n               }\\n           }\\n       }\\n\\n        return closest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335232,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        int closest = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n - 2; i++){\\n            int l = i + 1;\\n            int r = n - 1;\\n            while (l < r) {\\n                int curSum = nums[i] + nums[l] + nums[r];\\n                if (curSum == target) return curSum;\\n                if (abs(target - curSum) < abs(target - closest)) {\\n                    closest = curSum;\\n                }\\n\\n                if (target < curSum) {\\n                    r--;\\n                } else {\\n                    l++;\\n                }\\n            }\\n        }\\n\\n        return closest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n\\n        int closest = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n - 2; i++){\\n            int l = i + 1;\\n            int r = n - 1;\\n            while (l < r) {\\n                int curSum = nums[i] + nums[l] + nums[r];\\n                if (curSum == target) return curSum;\\n                if (abs(target - curSum) < abs(target - closest)) {\\n                    closest = curSum;\\n                }\\n\\n                if (target < curSum) {\\n                    r--;\\n                } else {\\n                    l++;\\n                }\\n            }\\n        }\\n\\n        return closest;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695684,
                "title": "c-binary-search-o-nlogn-faster-than-99",
                "content": "* Firstly, sort the vector.\\n* Then, take first and last pointers(here, i and j) as first and last elements of the vector.\\n* Now, binary search over the remaining vector and find when the difference of the target and the sum -- (nums[i] + nums[j] + nums[mid] ), where mid is from the binary search. \\n* Now, likewise increase or decrease the mid acc to requirement (less or more than target).\\n* Fix, where the abs dif. is least. Store it. \\n* Now, acc to the sign of dif., increment or decrement i or j. Continue until i>j. \\n\\nThe code - \\n\\n```\\n class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int i,j;\\n        int near=0;\\n        int dif=INT_MAX;\\n        int act=INT_MAX;\\n        i=0;\\n        j=nums.size()-1;\\n        while (i<j){\\n            int low=i+1;\\n            int high= j-1;\\n            while (low<=high){\\n                int mid=(low+high)/2;\\n                near=nums[i]+nums[j]+nums[mid];\\n                if (near==target){\\n                    return target;\\n                }\\n                else if (near < target){\\n                    low=mid+1;\\n                    if (abs(dif)>abs(near-target)) dif=near-target;\\n                }\\n                else {\\n                    high=mid-1;\\n                    if (abs(dif)>abs(near-target)) dif=near-target;\\n                }\\n            }\\n            act=abs(act)<abs(dif)?act:dif;\\n            if (dif>0){\\n                j--;\\n            }\\n            else i++;\\n            dif=INT_MAX;\\n        }\\n        return act+target;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\n class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int i,j;\\n        int near=0;\\n        int dif=INT_MAX;\\n        int act=INT_MAX;\\n        i=0;\\n        j=nums.size()-1;\\n        while (i<j){\\n            int low=i+1;\\n            int high= j-1;\\n            while (low<=high){\\n                int mid=(low+high)/2;\\n                near=nums[i]+nums[j]+nums[mid];\\n                if (near==target){\\n                    return target;\\n                }\\n                else if (near < target){\\n                    low=mid+1;\\n                    if (abs(dif)>abs(near-target)) dif=near-target;\\n                }\\n                else {\\n                    high=mid-1;\\n                    if (abs(dif)>abs(near-target)) dif=near-target;\\n                }\\n            }\\n            act=abs(act)<abs(dif)?act:dif;\\n            if (dif>0){\\n                j--;\\n            }\\n            else i++;\\n            dif=INT_MAX;\\n        }\\n        return act+target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676920,
                "title": "python-99-62-faster-with-comments",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.kSumClosest(nums, 3, target)\\n        \\n    def kSumClosest(self, nums, k, target):\\n        N = len(nums)\\n        # Special case where we only have k elements in nums. Return only option\\n        if N == k:\\n            return sum(nums[:k])\\n        \\n        # special case where the target is way too low\\n        # we give the lowest we can\\n        if sum(nums[:k]) >= target:\\n            return sum(nums[:k])\\n        \\n        # special case where the target is too high\\n        # we give the largest we can\\n        if sum(nums[-k:]) <= target:\\n            return sum(nums[-k:])\\n        \\n        # base case. look for the closest element\\n        if k == 1:\\n            # the element is the first and the delta is the second\\n            deltas = [(x, abs(target-x)) for x in nums]\\n            return min(deltas, key = lambda x: x[1])[0]\\n        \\n        # pick one element out and recursively search for closest match with k being one less\\n        closest = sum(nums[:k])\\n        for i,x in enumerate(nums):\\n            # small optimization to handle duplicate x values\\n            if i>0 and nums[i-1] == x:\\n                continue\\n                \\n            bestMatch = self.kSumClosest(nums[i+1:], k-1, target-x)\\n            current = x + bestMatch\\n            if abs(target-current) < abs(target-closest):\\n                if target == current:\\n                    return current\\n                else:\\n                    closest = current\\n                    \\n        return closest\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        return self.kSumClosest(nums, 3, target)\\n        \\n    def kSumClosest(self, nums, k, target):\\n        N = len(nums)\\n        # Special case where we only have k elements in nums. Return only option\\n        if N == k:\\n            return sum(nums[:k])\\n        \\n        # special case where the target is way too low\\n        # we give the lowest we can\\n        if sum(nums[:k]) >= target:\\n            return sum(nums[:k])\\n        \\n        # special case where the target is too high\\n        # we give the largest we can\\n        if sum(nums[-k:]) <= target:\\n            return sum(nums[-k:])\\n        \\n        # base case. look for the closest element\\n        if k == 1:\\n            # the element is the first and the delta is the second\\n            deltas = [(x, abs(target-x)) for x in nums]\\n            return min(deltas, key = lambda x: x[1])[0]\\n        \\n        # pick one element out and recursively search for closest match with k being one less\\n        closest = sum(nums[:k])\\n        for i,x in enumerate(nums):\\n            # small optimization to handle duplicate x values\\n            if i>0 and nums[i-1] == x:\\n                continue\\n                \\n            bestMatch = self.kSumClosest(nums[i+1:], k-1, target-x)\\n            current = x + bestMatch\\n            if abs(target-current) < abs(target-closest):\\n                if target == current:\\n                    return current\\n                else:\\n                    closest = current\\n                    \\n        return closest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676452,
                "title": "c-two-pointer-o-n-n-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int diff = INT_MAX;\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int first = nums[i];  //first element\\n            int start = i+1;\\n            int end  = nums.size()-1;\\n            while(start < end){\\n                if(first + nums[start] + nums[end] == target) return target;\\n                else if(abs(first + nums[start]+nums[end] - target) < diff)\\n                {\\n                    diff = abs(first + nums[start]+nums[end] - target);\\n                    ans = first + nums[start]+nums[end];\\n                }\\n                \\n                if(first + nums[start] + nums[end] > target)\\n                {\\n                    end--;\\n                }\\n                else{\\n                    start++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote the post, if it\\'s been any help to you**",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int diff = INT_MAX;\\n        int ans = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int first = nums[i];  //first element\\n            int start = i+1;\\n            int end  = nums.size()-1;\\n            while(start < end){\\n                if(first + nums[start] + nums[end] == target) return target;\\n                else if(abs(first + nums[start]+nums[end] - target) < diff)\\n                {\\n                    diff = abs(first + nums[start]+nums[end] - target);\\n                    ans = first + nums[start]+nums[end];\\n                }\\n                \\n                if(first + nums[start] + nums[end] > target)\\n                {\\n                    end--;\\n                }\\n                else{\\n                    start++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676281,
                "title": "java-98-23-two-pointers-binary-search",
                "content": "**Upvote  if you\\'re not greedy)))**\\n# Complexity\\n- Time complexity: n*log(n)\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        Arrays.sort(nums);\\n\\n        int bestRes = Integer.MAX_VALUE;\\n        int minDif = Integer.MAX_VALUE;\\n        while (left < right - 1) {\\n            int tempSum = nums[left] + nums[right];\\n            int midValue = binary(nums, target - tempSum, left+1, right-1);\\n            tempSum += midValue;\\n            int dif = Math.abs(target - tempSum);\\n\\n            if (dif < minDif) {\\n                minDif = dif;\\n                bestRes = tempSum;\\n            }\\n\\n            if (tempSum == target) {\\n                return tempSum;\\n            } else if (tempSum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        return bestRes;\\n    }\\n\\n    private int binary(int[] nums, int target, int left, int right) {\\n        int bestRes = Integer.MAX_VALUE;\\n        int minDif = Integer.MAX_VALUE;\\n        while (left <= right) {\\n            int mid = (right + left) / 2;\\n            int dif = Math.abs(target - nums[mid]);\\n            if (dif < minDif) {\\n                minDif = dif;\\n                bestRes = nums[mid];\\n            }\\n            if (target == nums[mid]) {\\n                return nums[mid];\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return bestRes;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        Arrays.sort(nums);\\n\\n        int bestRes = Integer.MAX_VALUE;\\n        int minDif = Integer.MAX_VALUE;\\n        while (left < right - 1) {\\n            int tempSum = nums[left] + nums[right];\\n            int midValue = binary(nums, target - tempSum, left+1, right-1);\\n            tempSum += midValue;\\n            int dif = Math.abs(target - tempSum);\\n\\n            if (dif < minDif) {\\n                minDif = dif;\\n                bestRes = tempSum;\\n            }\\n\\n            if (tempSum == target) {\\n                return tempSum;\\n            } else if (tempSum < target) {\\n                left++;\\n            } else {\\n                right--;\\n            }\\n        }\\n        return bestRes;\\n    }\\n\\n    private int binary(int[] nums, int target, int left, int right) {\\n        int bestRes = Integer.MAX_VALUE;\\n        int minDif = Integer.MAX_VALUE;\\n        while (left <= right) {\\n            int mid = (right + left) / 2;\\n            int dif = Math.abs(target - nums[mid]);\\n            if (dif < minDif) {\\n                minDif = dif;\\n                bestRes = nums[mid];\\n            }\\n            if (target == nums[mid]) {\\n                return nums[mid];\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return bestRes;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675165,
                "title": "python-95-fast-with-binary-search-fewer-steps-in-the-inner-loop-still-o-n-2-in-time",
                "content": "Determine the initial pointers at the value of half of \\'target\\' - \\'nums[i]\\' by binary search, instead of two edges. This should have fewer inner loop steps.\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        ans = 10**5\\n        nums.sort()\\n        for i in range(n-2):\\n            t = target - nums[i]\\n            left = bisect.bisect_left(nums[i+1:], t//2) + i+1\\n            if left >= n-1:\\n                left = n-2\\n            right = left + 1\\n            while left > i and right < n:\\n                eq = nums[left] + nums[right] - t\\n                if eq == 0:\\n                    return target\\n                elif eq > 0:\\n                    left -= 1\\n                else:\\n                    right += 1\\n                if abs(eq) < abs(ans):\\n                    ans = eq\\n        return target + ans\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        ans = 10**5\\n        nums.sort()\\n        for i in range(n-2):\\n            t = target - nums[i]\\n            left = bisect.bisect_left(nums[i+1:], t//2) + i+1\\n            if left >= n-1:\\n                left = n-2\\n            right = left + 1\\n            while left > i and right < n:\\n                eq = nums[left] + nums[right] - t\\n                if eq == 0:\\n                    return target\\n                elif eq > 0:\\n                    left -= 1\\n                else:\\n                    right += 1\\n                if abs(eq) < abs(ans):\\n                    ans = eq\\n        return target + ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674477,
                "title": "java-98-faster-code-easy-solution",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\npublic int threeSumClosest(int[] nums, int target) {\\nArrays.sort(nums);\\nint closestSum = nums[0] + nums[1] + nums[2];\\nint leastDifference = Math.abs(target - closestSum);\\nif (leastDifference == 0) {\\nreturn closestSum;\\n}\\nint length = nums.length - 1;\\nint i = 0;\\nint maxSum = nums[length] + nums[length - 1];\\nint len = length - 3;\\nwhile (i < len && maxSum + nums[i] < target) {\\nclosestSum = maxSum + nums[i];\\nleastDifference = Math.abs(target - closestSum);\\ni++;\\n}\\nfor (; i <= length; i++) {\\nint small = i + 1;\\nint large = length;\\nwhile (small < large) {\\nint sum = nums[i] + nums[small] + nums[large];\\nint difference = target - sum;\\nint absDiff = Math.abs(difference);\\nif (absDiff < leastDifference) {\\nleastDifference = absDiff;\\nclosestSum = sum;\\nif (leastDifference == 0) {\\nreturn closestSum;\\n}\\n}\\nif (sum > target) {\\nlarge--;\\n} else {\\nsmall++;\\n}\\n}\\nif (i < len && nums[i] + nums[i + 1] + nums[i + 2] > target) {\\nbreak;\\n}\\n}\\nreturn closestSum;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic int threeSumClosest(int[] nums, int target) {\\nArrays.sort(nums);\\nint closestSum = nums[0] + nums[1] + nums[2];\\nint leastDifference = Math.abs(target - closestSum);\\nif (leastDifference == 0) {\\nreturn closestSum;\\n}\\nint length = nums.length - 1;\\nint i = 0;\\nint maxSum = nums[length] + nums[length - 1];\\nint len = length - 3;\\nwhile (i < len && maxSum + nums[i] < target) {\\nclosestSum = maxSum + nums[i];\\nleastDifference = Math.abs(target - closestSum);\\ni++;\\n}\\nfor (; i <= length; i++) {\\nint small = i + 1;\\nint large = length;\\nwhile (small < large) {\\nint sum = nums[i] + nums[small] + nums[large];\\nint difference = target - sum;\\nint absDiff = Math.abs(difference);\\nif (absDiff < leastDifference) {\\nleastDifference = absDiff;\\nclosestSum = sum;\\nif (leastDifference == 0) {\\nreturn closestSum;\\n}\\n}\\nif (sum > target) {\\nlarge--;\\n} else {\\nsmall++;\\n}\\n}\\nif (i < len && nums[i] + nums[i + 1] + nums[i + 2] > target) {\\nbreak;\\n}\\n}\\nreturn closestSum;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674375,
                "title": "c-python-short-concise",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int d = INT_MAX, ans;\\n        for(int i=0; i<nums.size(); i++) {\\n            int s = i + 1, e = nums.size() - 1;\\n            while(s < e) {\\n                int sum = nums[i] + nums[s] + nums[e];\\n                if(sum == target) return sum;\\n                if(abs(sum - target) < d) d = abs(sum - target), ans = sum;\\n                sum < target ? s++ : e--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        d, ans = float(\"inf\"), 0\\n        for i in range(len(nums) - 2):\\n            s, e = i + 1, len(nums) - 1\\n            while(s < e):\\n                sum = nums[i] + nums[s] + nums[e]\\n                if sum == target: return sum\\n                if abs(sum - target) < d:\\n                    d = abs(sum - target)\\n                    ans = sum\\n                if sum < target: s += 1\\n                else: e -= 1\\n        \\n        return ans\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int d = INT_MAX, ans;\\n        for(int i=0; i<nums.size(); i++) {\\n            int s = i + 1, e = nums.size() - 1;\\n            while(s < e) {\\n                int sum = nums[i] + nums[s] + nums[e];\\n                if(sum == target) return sum;\\n                if(abs(sum - target) < d) d = abs(sum - target), ans = sum;\\n                sum < target ? s++ : e--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        nums.sort()\\n        d, ans = float(\"inf\"), 0\\n        for i in range(len(nums) - 2):\\n            s, e = i + 1, len(nums) - 1\\n            while(s < e):\\n                sum = nums[i] + nums[s] + nums[e]\\n                if sum == target: return sum\\n                if abs(sum - target) < d:\\n                    d = abs(sum - target)\\n                    ans = sum\\n                if sum < target: s += 1\\n                else: e -= 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546678,
                "title": "python-beginner-friendly-fast-two-pointers",
                "content": "Upvote if it helped. Thanks\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = 0\\n        diff = 10000\\n        for cur_ind in range (len (nums)-1):\\n            left, right = cur_ind + 1, len(nums)-1 \\n            while left < right :\\n                threesum = nums[cur_ind] + nums[left] + nums[right]\\n                if threesum == target :\\n                    return threesum\\n                if abs(threesum - target) < diff:\\n                    diff = abs(threesum - target)\\n                    ans = threesum\\n                if threesum < target :\\n                    left += 1\\n                elif threesum > target:\\n                    right -= 1\\n        return ans\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = 0\\n        diff = 10000\\n        for cur_ind in range (len (nums)-1):\\n            left, right = cur_ind + 1, len(nums)-1 \\n            while left < right :\\n                threesum = nums[cur_ind] + nums[left] + nums[right]\\n                if threesum == target :\\n                    return threesum\\n                if abs(threesum - target) < diff:\\n                    diff = abs(threesum - target)\\n                    ans = threesum\\n                if threesum < target :\\n                    left += 1\\n                elif threesum > target:\\n                    right -= 1\\n        return ans\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431292,
                "title": "python-c-java-kotlin-beginner-level-as-simple-as-u-think-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q16. 3Sum Closest***\\nGiven an integer array `nums` of length `n` and an integer `targe`t, find three integers in nums such that the sum is closest to `target`.\\n\\nReturn the sum of the three integers.\\n\\nYou may assume that each input would have exactly one solution.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = sum(nums[:3])\\n        for i in range(len(nums)):\\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                s = sum((nums[i], nums[l], nums[r]))\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s < target:\\n                    l += 1\\n                elif s > target:\\n                    r -= 1\\n                else: # break early \\n                    return res\\n        return res\\n```\\n**Runtime:**  53 ms\\t\\n**Memory Usage:**  13.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int output = nums[0] + nums[1] + nums[nums.length - 1];\\n        for(int i = 0; i < nums.length - 2; i++)\\n        {\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n            while(j < k)\\n            {\\n                int currSum = nums[i] + nums[j] + nums[k];\\n                if(currSum > target)\\n                    k--;\\n                else\\n                    j++;\\n                \\n                if(Math.abs(currSum - target) < Math.abs(output - target))\\n                    output = currSum;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```\\n**Runtime:**  174 ms\\t\\n**Memory Usage:**  48.6 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n            int l,r,f=0,ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int t=target-nums[i];\\n            l=i+1;\\n            r=nums.size()-1;\\n            int sum=0;\\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[r];\\n                if(abs(target-sum-nums[i])<abs(target-ans))\\n                    ans=sum+nums[i];\\n                if(sum==t)\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                else if(sum>t)\\n                    r--;\\n                else\\n                    l++;\\n            }\\n            if(f)\\n                break;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Runtime:**  247 ms\\t\\n**Memory Usage:**  16.4 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Kotlin  Code** :\\n**Your runtime beats 89.21 % of kotlin submissions.**\\n```\\nclass Solution {\\n    fun threeSumClosest(nums: IntArray, target: Int): Int {\\n        var closest = nums.first() + nums[1] + nums.last()\\n        val list = nums.sorted()\\n        (0..list.size - 2).forEach {\\n            var second = it + 1\\n            var end = list.size - 1\\n            while (second < end) {\\n                var sum = list[it] + list[second] + list[end]\\n                if (sum > target) end-- else second++\\n                if (Math.abs(sum - target) < Math.abs(closest - target)) closest = sum\\n            }\\n        }\\n\\n        return closest\\n    }\\n}\\n```\\n**Runtime:**  971 ms\\t\\n**Memory Usage:**  51.1 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Kotlin",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = sum(nums[:3])\\n        for i in range(len(nums)):\\n            l, r = i+1, len(nums)-1\\n            while l < r:\\n                s = sum((nums[i], nums[l], nums[r]))\\n                if abs(s-target) < abs(res-target):\\n                    res = s\\n                if s < target:\\n                    l += 1\\n                elif s > target:\\n                    r -= 1\\n                else: # break early \\n                    return res\\n        return res\\n```\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int output = nums[0] + nums[1] + nums[nums.length - 1];\\n        for(int i = 0; i < nums.length - 2; i++)\\n        {\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n            while(j < k)\\n            {\\n                int currSum = nums[i] + nums[j] + nums[k];\\n                if(currSum > target)\\n                    k--;\\n                else\\n                    j++;\\n                \\n                if(Math.abs(currSum - target) < Math.abs(output - target))\\n                    output = currSum;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n            int l,r,f=0,ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int t=target-nums[i];\\n            l=i+1;\\n            r=nums.size()-1;\\n            int sum=0;\\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[r];\\n                if(abs(target-sum-nums[i])<abs(target-ans))\\n                    ans=sum+nums[i];\\n                if(sum==t)\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                else if(sum>t)\\n                    r--;\\n                else\\n                    l++;\\n            }\\n            if(f)\\n                break;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun threeSumClosest(nums: IntArray, target: Int): Int {\\n        var closest = nums.first() + nums[1] + nums.last()\\n        val list = nums.sorted()\\n        (0..list.size - 2).forEach {\\n            var second = it + 1\\n            var end = list.size - 1\\n            while (second < end) {\\n                var sum = list[it] + list[second] + list[end]\\n                if (sum > target) end-- else second++\\n                if (Math.abs(sum - target) < Math.abs(closest - target)) closest = sum\\n            }\\n        }\\n\\n        return closest\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424972,
                "title": "c",
                "content": "```\\npublic class Solution\\n{\\n    public int ThreeSumClosest(int[] nums, int target) \\n    {\\n        Array.Sort(nums);\\n\\n        int closest = int.MaxValue, diff = int.MaxValue;\\n\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            int l = i + 1, r = nums.Length - 1;\\n\\n            while (l < r)\\n            {\\n                int s = nums[i] + nums[l] + nums[r];\\n                if (Math.Abs(s - target) < diff)\\n                {\\n                    diff = Math.Abs(s - target);\\n                    closest = s;\\n                }\\n\\n                if (s > target)\\n                {\\n                    r--;\\n                }\\n                else\\n                {\\n                    l++;\\n                }\\n            }                \\n        }\\n\\n        return closest;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int ThreeSumClosest(int[] nums, int target) \\n    {\\n        Array.Sort(nums);\\n\\n        int closest = int.MaxValue, diff = int.MaxValue;\\n\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            int l = i + 1, r = nums.Length - 1;\\n\\n            while (l < r)\\n            {\\n                int s = nums[i] + nums[l] + nums[r];\\n                if (Math.Abs(s - target) < diff)\\n                {\\n                    diff = Math.Abs(s - target);\\n                    closest = s;\\n                }\\n\\n                if (s > target)\\n                {\\n                    r--;\\n                }\\n                else\\n                {\\n                    l++;\\n                }\\n            }                \\n        }\\n\\n        return closest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2125533,
                "title": "easy-c-solution-0-n-2-two-pointer-approach",
                "content": "The Naive approach of this is used a three pointers and calculate the diff i.e` target-(nums[i] +nums[j] +nums[k])` and check if this is closet to target if yes then `update `else check another index...\\nIn this way We take 0(n^3) time complexity...\\n\\nCan We do better?? .......\\nYes We can\\n\\nNow suppose if i give u a problem to find the two integer which is closest to target and the array is sorted then how can you solve.......?\\n**Ans**- Obviously first thing come in my mind is use of two pointer `si,ei` where `si=0` and` ei=n-1`\\nand it takes 0(n) time complexity;...................Algo(1)\\n\\nNow we use two pointer approach in given array for every array index element how.? Lets understand..\\n\\nsuppose `target=x`\\nand i want to find three integers sum which is closest to target..\\nnow we break this into subproblem..\\nie. if at` index i` then our new target is find` target-(nums[i)` from `si=i+1` to `ei=n-1` by using Algo(1) we disscused previously \\nInitially our global` clsdiff `variable is used update when we find` diff` which is less than our` clsdiff` \\nand when we update then we store three integers in `a,b,c`\\n\\nHere is code...\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n      int a,b,c;\\n      int clsdiff=INT_MAX;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-2;i++){\\n            int si=i+1;\\n            int ei=n-1;\\n            int ntarget=target-nums[i];\\n            int na=nums[i];\\n            int nb,nc;\\n            int diff=INT_MAX;\\n            while(si<ei){\\n                if(abs(ntarget-(nums[si]+nums[ei]))<diff){\\n                    diff=abs(ntarget-(nums[si]+nums[ei]));\\n                    nb=nums[si];\\n                    nc=nums[ei];\\n                }\\n                \\n                if(nums[si]+nums[ei]>ntarget){\\n                    ei--;\\n                }\\n                else{\\n                    si++;\\n                }      \\n            }\\n            if(diff<clsdiff){\\n                clsdiff=diff;\\n                a=na;\\n                b=nb;\\n                c=nc;\\n            }\\n        } \\n        return a+b+c;\\n    }\\n};\\n```\\n** Time Complextiy-0(n^2) space complexity-0(1)**\\n\\n***Please upvote if you find helpful***\\n",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n      int a,b,c;\\n      int clsdiff=INT_MAX;\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n-2;i++){\\n            int si=i+1;\\n            int ei=n-1;\\n            int ntarget=target-nums[i];\\n            int na=nums[i];\\n            int nb,nc;\\n            int diff=INT_MAX;\\n            while(si<ei){\\n                if(abs(ntarget-(nums[si]+nums[ei]))<diff){\\n                    diff=abs(ntarget-(nums[si]+nums[ei]));\\n                    nb=nums[si];\\n                    nc=nums[ei];\\n                }\\n                \\n                if(nums[si]+nums[ei]>ntarget){\\n                    ei--;\\n                }\\n                else{\\n                    si++;\\n                }      \\n            }\\n            if(diff<clsdiff){\\n                clsdiff=diff;\\n                a=na;\\n                b=nb;\\n                c=nc;\\n            }\\n        } \\n        return a+b+c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899763,
                "title": "python-easy-to-read-and-understand-sorting",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans, diff = 0, float(\"inf\")\\n        n = len(nums)\\n        \\n        for i in range(n-2):\\n            j, k = i+1, n-1\\n            while j < k:\\n                sums = nums[i] + nums[j] + nums[k]\\n                if sums == target:\\n                    return sums\\n                if abs(sums-target) <= diff:\\n                    diff = abs(sums-target)\\n                    ans = sums\\n                if sums < target:\\n                    j += 1\\n                else:\\n                    k -= 1\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans, diff = 0, float(\"inf\")\\n        n = len(nums)\\n        \\n        for i in range(n-2):\\n            j, k = i+1, n-1\\n            while j < k:\\n                sums = nums[i] + nums[j] + nums[k]\\n                if sums == target:\\n                    return sums\\n                if abs(sums-target) <= diff:\\n                    diff = abs(sums-target)\\n                    ans = sums\\n                if sums < target:\\n                    j += 1\\n                else:\\n                    k -= 1\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1541433,
                "title": "c-simple-solution-beats-90",
                "content": "class Solution {\\npublic:\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int closest, min = INT_MAX;\\n        \\n        for(int i=0 ; i<n-2 ; ++i)\\n        {\\n            if(i==0 || nums[i]!=nums[i-1])\\n            {\\n                int low = i+1;\\n                int high = n-1;\\n                while(low<high)\\n                {\\n                    int sum = nums[i] + nums[low] + nums[high];\\n                    if(sum == target) return sum;\\n                    else if(sum > target) high--;\\n                    else low++;\\n                    \\n                    if(abs(sum-target)<min)\\n                    {\\n                        closest = sum;\\n                        min = abs(sum-target);\\n                    }\\n                }\\n            }\\n        }\\n        return closest;\\n    }\\n};\\n**leave a like.**",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int n = nums.size();\\n        int closest, min = INT_MAX;\\n        \\n        for(int i=0 ; i<n-2 ; ++i)\\n        {\\n            if(i==0 || nums[i]!=nums[i-1])\\n            {\\n                int low = i+1;\\n                int high = n-1;\\n                while(low<high)\\n                {\\n                    int sum = nums[i] + nums[low] + nums[high];\\n                    if(sum == target) return sum;\\n                    else if(sum > target) high--;\\n                    else low++;\\n                    \\n                    if(abs(sum-target)<min)\\n                    {\\n                        closest = sum;\\n                        min = abs(sum-target);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1453442,
                "title": "beginner-friendly-java-javascript-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closestsum = Integer.MAX_VALUE;\\n        for(int i=0; i < nums.length - 2; i++) {\\n            int l = i+1;\\n            int r = nums.length - 1;\\n            int sum = 0;\\n            while(l < r) {\\n                sum = nums[i] + nums[l] + nums[r];\\n                if(Math.abs(target - sum) < Math.abs(closestsum))\\n                    closestsum = target - sum;\\n                if( sum < target )\\n                    l++;\\n                else\\n                    r--;\\n            }\\n        }\\n        return target - closestsum;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b) => a-b)\\n    let closestSum = Number.MAX_VALUE\\n    for(let i=0; i<nums.length-2; i++){\\n        let l = i+1, r = nums.length-1, sum = 0\\n        while(l < r){\\n            sum = nums[i] + nums[l] + nums[r]\\n            if(Math.abs(target - sum) < Math.abs(closestSum))    closestSum = target - sum\\n            if(sum < target)    l++\\n            else    r--\\n        }\\n    }\\n    return target - closestSum\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        int closestsum = Integer.MAX_VALUE;\\n        for(int i=0; i < nums.length - 2; i++) {\\n            int l = i+1;\\n            int r = nums.length - 1;\\n            int sum = 0;\\n            while(l < r) {\\n                sum = nums[i] + nums[l] + nums[r];\\n                if(Math.abs(target - sum) < Math.abs(closestsum))\\n                    closestsum = target - sum;\\n                if( sum < target )\\n                    l++;\\n                else\\n                    r--;\\n            }\\n        }\\n        return target - closestsum;\\n    }\\n}\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b) => a-b)\\n    let closestSum = Number.MAX_VALUE\\n    for(let i=0; i<nums.length-2; i++){\\n        let l = i+1, r = nums.length-1, sum = 0\\n        while(l < r){\\n            sum = nums[i] + nums[l] + nums[r]\\n            if(Math.abs(target - sum) < Math.abs(closestSum))    closestSum = target - sum\\n            if(sum < target)    l++\\n            else    r--\\n        }\\n    }\\n    return target - closestSum\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186601,
                "title": "javascript-beats-99-60",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let min = Infinity;\\n    for (let i = 0; i < nums.length; i ++) {\\n        let left = i + 1,\\n            right = nums.length -1;\\n        while (left < right) {\\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(sum - target) < Math.abs(min - target)) min = sum;\\n            if (sum > target) {\\n                right --\\n            } else {\\n                left ++\\n            }\\n        }\\n    }\\n    return min;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let min = Infinity;\\n    for (let i = 0; i < nums.length; i ++) {\\n        let left = i + 1,\\n            right = nums.length -1;\\n        while (left < right) {\\n            let sum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(sum - target) < Math.abs(min - target)) min = sum;\\n            if (sum > target) {\\n                right --\\n            } else {\\n                left ++\\n            }\\n        }\\n    }\\n    return min;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 553528,
                "title": "java-o-n-2-solution-using-sort-adds-on-twosum",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        //base case\\n        if (nums == null) return -1;\\n        \\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ans = Integer.MAX_VALUE;\\n        int minDiff = Integer.MAX_VALUE;\\n        for(int i=0; i<n-2; i++){\\n            int sum = twoSum(nums, i, target, ans, minDiff);\\n            if(Math.abs(target - sum) == 0) return sum;\\n            if(Math.abs(target - sum) <= minDiff)\\n            {\\n                ans = sum;\\n                minDiff = Math.abs(target - sum);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private int twoSum(int[] nums, int rootIndex, int target, int summ, int minDiff){\\n        int left = rootIndex + 1;\\n        int right = nums.length - 1;\\n        while(left < right){\\n            int sum = nums[rootIndex] + nums[left] + nums[right];\\n            int diff = Math.abs(target - sum);\\n            if(diff <= minDiff) {\\n                minDiff = diff;\\n                summ = sum;\\n            }\\n            if(minDiff == 0)\\n                return sum;\\n            if(sum > target){\\n                right--;\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n        return summ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        //base case\\n        if (nums == null) return -1;\\n        \\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ans = Integer.MAX_VALUE;\\n        int minDiff = Integer.MAX_VALUE;\\n        for(int i=0; i<n-2; i++){\\n            int sum = twoSum(nums, i, target, ans, minDiff);\\n            if(Math.abs(target - sum) == 0) return sum;\\n            if(Math.abs(target - sum) <= minDiff)\\n            {\\n                ans = sum;\\n                minDiff = Math.abs(target - sum);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private int twoSum(int[] nums, int rootIndex, int target, int summ, int minDiff){\\n        int left = rootIndex + 1;\\n        int right = nums.length - 1;\\n        while(left < right){\\n            int sum = nums[rootIndex] + nums[left] + nums[right];\\n            int diff = Math.abs(target - sum);\\n            if(diff <= minDiff) {\\n                minDiff = diff;\\n                summ = sum;\\n            }\\n            if(minDiff == 0)\\n                return sum;\\n            if(sum > target){\\n                right--;\\n            }\\n            else{\\n                left++;\\n            }\\n        }\\n        return summ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550566,
                "title": "python-o-n-2-easy-to-follow-solution",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        closest = nums[0] + nums[1] + nums[2]\\n        nums.sort()\\n        \\n        for i in range(len(nums) - 2):\\n            l = i + 1\\n            r = len(nums) - 1\\n            \\n            while l < r:\\n                total = nums[i] + nums[l] + nums[r]\\n                if abs(target - total) < abs(target - closest):\\n                    closest = total\\n                    \\n                if total < target:\\n                    l += 1\\n                elif total > target:\\n                    r -= 1\\n                else:\\n                    return closest\\n                \\n        return closest \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        closest = nums[0] + nums[1] + nums[2]\\n        nums.sort()\\n        \\n        for i in range(len(nums) - 2):\\n            l = i + 1\\n            r = len(nums) - 1\\n            \\n            while l < r:\\n                total = nums[i] + nums[l] + nums[r]\\n                if abs(target - total) < abs(target - closest):\\n                    closest = total\\n                    \\n                if total < target:\\n                    l += 1\\n                elif total > target:\\n                    r -= 1\\n                else:\\n                    return closest\\n                \\n        return closest \\n```",
                "codeTag": "Java"
            },
            {
                "id": 419093,
                "title": "multiple-approaches-with-explanation",
                "content": "##### Approach 1: Brute Force Solution\\n```java\\n public int threeSumClosest(int[] nums, int target) {\\n        int min = nums[0] + nums[1] + nums[2];\\n        int len = nums.length;\\n        for(int i=0; i<len; i++) {\\n            for(int j=i+1; j<len; j++) {\\n                for(int k=j+1; k<len; k++) {\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    if(Math.abs(target - min) >  Math.abs(target - sum)) {\\n                        min = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n```\\n#####\\tAssumption: \\n- The min value is the sum of the first three elements in the given array and we use this as our starting point to look for the minimum value that is closest to the target\\n##### Complexity\\n- Time Complexity: O(n^3)\\n- Space Complexity: O(n)\\n\\n##### Approach 2:  Two Pointer Solution\\n```java\\n    public int threeSumClosest(int[] nums, int target) {\\n\\t    // sort the given input to make use of the two pointer solution\\n        Arrays.sort(nums);\\n\\t\\t// assumping our min value to be the sum of the first three elements\\n        int min = nums[0] + nums[1] + nums[2];\\n        for(int i=0; i<nums.length; i++) {\\n            int start = i+1;\\n            int end = nums.length-1;\\n            while(start < end) {\\n                int sum = nums[i] + nums[start] + nums[end];\\n\\t\\t\\t\\t// if the diff between the target and sum is minimum than the assumed then update the value with new minimum value\\n                if(Math.abs(target - min) > Math.abs(target - sum)) {\\n                    min = sum;\\n                }\\n                \\n\\t\\t\\t\\t// increment or decrement the pointers based on the sum that we found in the previous steps, return the result if the sum is neither greater than nor lesser than the target meaning that we found our closest value to the target\\n                if(sum > target) {\\n                    end--;\\n                } else if(sum < target){\\n                    start++;\\n                } else {\\n                    return target;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n```\\n##### Complexity\\n- Time Complexity: O(n^2)\\n- Space Complexity: O(n)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\n public int threeSumClosest(int[] nums, int target) {\\n        int min = nums[0] + nums[1] + nums[2];\\n        int len = nums.length;\\n        for(int i=0; i<len; i++) {\\n            for(int j=i+1; j<len; j++) {\\n                for(int k=j+1; k<len; k++) {\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    if(Math.abs(target - min) >  Math.abs(target - sum)) {\\n                        min = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n```\n```java\\n    public int threeSumClosest(int[] nums, int target) {\\n\\t    // sort the given input to make use of the two pointer solution\\n        Arrays.sort(nums);\\n\\t\\t// assumping our min value to be the sum of the first three elements\\n        int min = nums[0] + nums[1] + nums[2];\\n        for(int i=0; i<nums.length; i++) {\\n            int start = i+1;\\n            int end = nums.length-1;\\n            while(start < end) {\\n                int sum = nums[i] + nums[start] + nums[end];\\n\\t\\t\\t\\t// if the diff between the target and sum is minimum than the assumed then update the value with new minimum value\\n                if(Math.abs(target - min) > Math.abs(target - sum)) {\\n                    min = sum;\\n                }\\n                \\n\\t\\t\\t\\t// increment or decrement the pointers based on the sum that we found in the previous steps, return the result if the sum is neither greater than nor lesser than the target meaning that we found our closest value to the target\\n                if(sum > target) {\\n                    end--;\\n                } else if(sum < target){\\n                    start++;\\n                } else {\\n                    return target;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 395240,
                "title": "python-2-pointer-solution",
                "content": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = sum(nums[:3])\\n        \\n        for i in range(len(nums)-2):\\n            k = len(nums)-1 \\n            j = i + 1 \\n          \\n            while j < k:\\n                close_sum = nums[i] + nums[j] + nums[k]\\n                \\n                if close_sum == target:\\n                    return close_sum\\n                \\n                if abs(close_sum - target) < abs(ans - target):\\n                    ans = close_sum\\n                \\n                if close_sum < target:\\n                    j += 1\\n                elif close_sum > target: \\n                    k -= 1\\n                else: \\n                    break\\n                          \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = sum(nums[:3])\\n        \\n        for i in range(len(nums)-2):\\n            k = len(nums)-1 \\n            j = i + 1 \\n          \\n            while j < k:\\n                close_sum = nums[i] + nums[j] + nums[k]\\n                \\n                if close_sum == target:\\n                    return close_sum\\n                \\n                if abs(close_sum - target) < abs(ans - target):\\n                    ans = close_sum\\n                \\n                if close_sum < target:\\n                    j += 1\\n                elif close_sum > target: \\n                    k -= 1\\n                else: \\n                    break\\n                          \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301562,
                "title": "python-solution-40ms-beat-99",
                "content": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = sum(nums[:3])\\n        # ensure diff as a postive integer, so don\\'t need use abs().\\n        diff = target - res if target > res else res - target\\n        \\n        \\n        for i in range(len(nums) - 2):\\n\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                # skip adjadcent duplicates\\n                continue\\n                \\n            l, r = i + 1, len(nums) - 1\\n            if nums[i] + nums[r-1] + nums[r] <= target:\\n                # compare with the largest subset\\n                \\n                s = nums[i] + nums[r-1] + nums[r]\\n                if s == target:\\n                    return s\\n\\n                if target - s < diff:\\n                    res = s\\n                    diff = target - s\\n\\n            elif nums[i] + nums[l] + nums[l+1] >= target:\\n                # compare with the smallest subset\\n                \\n                s = nums[i] + nums[l] + nums[l+1]\\n                if s == target:\\n                    return s\\n\\n                if s - target < diff:\\n                    res = s\\n                    diff = s - target\\n            else:\\n                while l < r:\\n                    s = nums[i] + nums[l] + nums[r]\\n\\n                    if s == target:\\n                        return s\\n                    elif s < target:\\n                        l += 1\\n                        if target - s < diff:\\n                            res = s\\n                            diff = target - s\\n                    else:\\n                        r -= 1\\n                        if s - target < diff:\\n                            res = s\\n                            diff = s - target\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        res = sum(nums[:3])\\n        # ensure diff as a postive integer, so don\\'t need use abs().\\n        diff = target - res if target > res else res - target\\n        \\n        \\n        for i in range(len(nums) - 2):\\n\\n            if i > 0 and nums[i] == nums[i - 1]:\\n                # skip adjadcent duplicates\\n                continue\\n                \\n            l, r = i + 1, len(nums) - 1\\n            if nums[i] + nums[r-1] + nums[r] <= target:\\n                # compare with the largest subset\\n                \\n                s = nums[i] + nums[r-1] + nums[r]\\n                if s == target:\\n                    return s\\n\\n                if target - s < diff:\\n                    res = s\\n                    diff = target - s\\n\\n            elif nums[i] + nums[l] + nums[l+1] >= target:\\n                # compare with the smallest subset\\n                \\n                s = nums[i] + nums[l] + nums[l+1]\\n                if s == target:\\n                    return s\\n\\n                if s - target < diff:\\n                    res = s\\n                    diff = s - target\\n            else:\\n                while l < r:\\n                    s = nums[i] + nums[l] + nums[r]\\n\\n                    if s == target:\\n                        return s\\n                    elif s < target:\\n                        l += 1\\n                        if target - s < diff:\\n                            res = s\\n                            diff = target - s\\n                    else:\\n                        r -= 1\\n                        if s - target < diff:\\n                            res = s\\n                            diff = s - target\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229111,
                "title": "rust-0ms",
                "content": "Unfortunately with range iterators it\\'s much slower.\\n\\n```rust\\nimpl Solution {\\n    pub fn three_sum_closest(nums: Vec<i32>, target: i32) -> i32 {\\n        if nums.len() <= 3 {\\n            return nums.into_iter().sum();\\n        }\\n\\n        let mut nums = nums;\\n        nums.sort();\\n\\n        let mut closest = nums[0] + nums[1] + nums[2];\\n        let mut min_diff = (closest - target).abs();\\n        \\n        let mut a = 0;\\n\\t\\t\\n        while a < nums.len() - 2 {\\n\\t\\t\\n            let mut b = nums.len() - 1;\\n            let mut c = a + 1;\\n\\t\\t\\t\\n            while c < b {\\n                let sum = nums[a] + nums[b] + nums[c];\\n                let diff = (sum - target).abs();\\n\\n                if diff < min_diff {\\n                    closest = sum;\\n                    min_diff = diff;\\n                }\\n\\n                if sum > target {\\n                    b -= 1;\\n                } else if sum < target {\\n                    c += 1;\\n                } else {\\n                    return closest\\n                }\\n                \\n            }\\n                \\n            a += 1;\\n        }\\n\\n        closest\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn three_sum_closest(nums: Vec<i32>, target: i32) -> i32 {\\n        if nums.len() <= 3 {\\n            return nums.into_iter().sum();\\n        }\\n\\n        let mut nums = nums;\\n        nums.sort();\\n\\n        let mut closest = nums[0] + nums[1] + nums[2];\\n        let mut min_diff = (closest - target).abs();\\n        \\n        let mut a = 0;\\n\\t\\t\\n        while a < nums.len() - 2 {\\n\\t\\t\\n            let mut b = nums.len() - 1;\\n            let mut c = a + 1;\\n\\t\\t\\t\\n            while c < b {\\n                let sum = nums[a] + nums[b] + nums[c];\\n                let diff = (sum - target).abs();\\n\\n                if diff < min_diff {\\n                    closest = sum;\\n                    min_diff = diff;\\n                }\\n\\n                if sum > target {\\n                    b -= 1;\\n                } else if sum < target {\\n                    c += 1;\\n                } else {\\n                    return closest\\n                }\\n                \\n            }\\n                \\n            a += 1;\\n        }\\n\\n        closest\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 128797,
                "title": "python-44ms-beats-100-00",
                "content": "In each loop,\\nI judge if current number plus two largest numbers less than target,\\nor current number plus two lowest numbers greater than target.\\n\\n```python\\n        nums.sort()\\n        length = len(nums)\\n        closest = []\\n        \\n        for i, num in enumerate(nums[0:-2]):\\n            l,r = i+1, length-1\\n\\t\\t\\t\\t\\t\\t\\n            # different with others\\' solution\\n\\t\\t\\t\\t\\t\\t\\n            if num+nums[r]+nums[r-1] < target:\\n                closest.append(num+nums[r]+nums[r-1])\\n            elif num+nums[l]+nums[l+1] > target:\\n                closest.append(num+nums[l]+nums[l+1])\\n            else:\\n                while l < r:\\n                    closest.append(num+nums[l]+nums[r])\\n                    if num+nums[l]+nums[r] < target:\\n                        l += 1\\n                    elif num+nums[l]+nums[r] > target:\\n                        r -= 1\\n                    else:\\n                        return target\\n                    \\n        closest.sort(key=lambda x:abs(x-target))\\n        return closest[0]\\n```",
                "solutionTags": [],
                "code": "```python\\n        nums.sort()\\n        length = len(nums)\\n        closest = []\\n        \\n        for i, num in enumerate(nums[0:-2]):\\n            l,r = i+1, length-1\\n\\t\\t\\t\\t\\t\\t\\n            # different with others\\' solution\\n\\t\\t\\t\\t\\t\\t\\n            if num+nums[r]+nums[r-1] < target:\\n                closest.append(num+nums[r]+nums[r-1])\\n            elif num+nums[l]+nums[l+1] > target:\\n                closest.append(num+nums[l]+nums[l+1])\\n            else:\\n                while l < r:\\n                    closest.append(num+nums[l]+nums[r])\\n                    if num+nums[l]+nums[r] < target:\\n                        l += 1\\n                    elif num+nums[l]+nums[r] > target:\\n                        r -= 1\\n                    else:\\n                        return target\\n                    \\n        closest.sort(key=lambda x:abs(x-target))\\n        return closest[0]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7971,
                "title": "a-12ms-easy-understanding-solution",
                "content": "    class Solution {\\n    public:\\n        int threeSumClosest(vector<int>& nums, int target) {\\n            int len = nums.size();\\n            int sum = 0, minsum = 0;;\\n            int dif = INT_MAX;\\n            if(len < 3) {\\n                for(int i = 0; i < len; i++) sum += nums[i];\\n                return sum;\\n            }\\n            \\n            int left, right;\\n            sort(nums.begin(),nums.end());\\n            \\n            for(int i = 0; i < (len - 2); i++) {\\n                left = i + 1;\\n                right = len - 1;\\n                while(left < right) {\\n                    sum = nums[i] + nums[left] + nums[right];\\n                    if(abs(sum - target) <= dif) {\\n                        dif = abs(sum - target);\\n                        minsum = sum;\\n                    }\\n                    if(sum > target) right--;\\n                    if(sum < target) left++;\\n                    if(sum == target) return minsum;\\n                }\\n            }\\n            return minsum;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public:\\n        int threeSumClosest(vector<int>& nums, int target) {\\n            int len = nums.size();\\n            int sum = 0, minsum = 0;;\\n            int dif = INT_MAX;\\n            if(len < 3) {\\n                for(int i = 0; i < len; i++) sum += nums[i];\\n                return sum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 8011,
                "title": "java-o-n-2-clean-and-clear-solution",
                "content": "    public class Solution {\\n        public int threeSumClosest(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            int min_diff = Integer.MAX_VALUE;\\n            for(int i=0; i<nums.length-2; ++i){\\n                int p = i+1, q = nums.length-1;\\n                while(p<q){\\n                    int diff = nums[i]+nums[p]+nums[q] - target;\\n                    if(diff == 0)   return target;\\n                    min_diff = Math.abs(diff)<Math.abs(min_diff) ? diff: min_diff;\\n                    if(diff>0)  --q;\\n                    else    ++p;\\n                }\\n            }\\n            return target + min_diff;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n        public int threeSumClosest(int[] nums, int target) {\\n            Arrays.sort(nums);\\n            int min_diff = Integer.MAX_VALUE;\\n            for(int i=0; i<nums.length-2; ++i){\\n                int p = i+1, q = nums.length-1;\\n                while(p<q){\\n                    int diff = nums[i]+nums[p]+nums[q] - target;\\n                    if(diff == 0)   return target;\\n                    min_diff = Math.abs(diff)<Math.abs(min_diff) ? diff: min_diff;\\n                    if(diff>0)  --q;\\n                    else    ++p;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 8044,
                "title": "my-aceepted-o-n-2-solution-in-c",
                "content": "    class Solution {\\n    public:\\n        int threeSumClosest(vector<int> &num, int target)\\n        {\\n    \\t\\tint clostAbs=INT_MAX;\\n    \\t\\tint clostSum=num[0]+num[1]+num[2];\\n    \\t\\tint low;\\n        \\tint high;\\n        \\tint sum=0;\\n        \\tsort(num.begin(),num.end());\\n        \\tfor(int i=0;i<num.size()-2;i++)\\n        \\t{\\n        \\t\\tlow=i+1;\\n        \\t\\thigh=num.size()-1;\\n        \\t\\twhile(low<high)\\n        \\t\\t{\\n        \\t\\t\\tsum=num[low]+num[high];\\n    \\t\\t\\t\\tif(abs(sum+num[i]-target)<clostAbs)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tclostAbs=abs(sum+num[i]-target);\\n    \\t\\t\\t\\t\\tclostSum=sum+num[i];\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\t\\n        \\t\\t\\tif(sum>(target-num[i]))\\n    \\t\\t\\t\\t{\\n        \\t\\t\\t\\thigh--;\\n    \\t\\t\\t\\t}\\n        \\t\\t\\telse\\n    \\t\\t\\t\\t{\\n        \\t\\t\\t\\tlow++;\\n    \\t\\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\treturn clostSum;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int threeSumClosest(vector<int> &num, int target)\\n        {\\n    \\t\\tint clostAbs=INT_MAX;\\n    \\t\\tint clostSum=num[0]+num[1]+num[2];\\n    \\t\\tint low;\\n        \\tint high;\\n        \\tint sum=0;\\n        \\tsort(num.begin(),num.end());\\n        \\tfor(int i=0;i<num.size()-2;i++)\\n        \\t{\\n        \\t\\tlow=i+1;\\n        \\t\\thigh=num.size()-1;\\n        \\t\\twhile(low<high)\\n        \\t\\t{\\n        \\t\\t\\tsum=num[low]+num[high];\\n    \\t\\t\\t\\tif(abs(sum+num[i]-target)<clostAbs)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tclostAbs=abs(sum+num[i]-target);\\n    \\t\\t\\t\\t\\tclostSum=sum+num[i];\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3823730,
                "title": "java-python-c-js-solution-simple-and-explained-commented-multiple-language",
                "content": "# Intuition\\nOur aim is to find the three integers whose sum is closest to the given target value. To achieve this, the array is first sorted in ascending order, and then two pointers (j and k) are used to scan the array from the start and end while maintaining a variable closestSum to track the closest sum found so far.\\n\\n# Approach\\n1. Sort the input array nums in ascending order using Arrays.sort(nums).\\n2. Initialize the variable closestSum to store the closest sum of three integers found so far. Set it to the sum of the first three elements of the sorted array (nums[0] + nums[1] + nums[2]).\\n3. Iterate through the array using a loop with an index variable \\'i\\'. The loop runs from index 0 to \\'nums.length - 2\\' to ensure enough elements are available for forming triplets.\\n4. For each \\'i\\' index, initialize two pointers \\'j\\' and \\'k\\'. \\'j\\' starts from \\'i+1\\', and \\'k\\' starts from \\'nums.length - 1\\'.\\n5. Use a while loop with conditions \\'j < k\\' to explore all possible combinations of triplets.\\n6. Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n7. Check if the current sum is closer to the target than the previous closest sum using the helper function compare.\\n8. If the current sum is closer to the target, update the closestSum to the current sum.\\n9. If the sum is less than the target, increment \\'j\\' to move towards higher values and potentially get closer to the target sum.\\n10. If the sum is greater than the target, decrement \\'k\\' to move towards lower values and potentially get closer to the target sum.\\n11. Continue this process until \\'j\\' becomes greater than or equal to \\'k\\'.\\n12. The process is repeated for all \\'i\\' indices to find the three integers whose sum is closest to the target.\\n13. Return the closestSum, which represents the sum of the three integers that have the closest sum to the given target value.\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\nwhere n is number of elements in array\\n\\n- Space complexity:\\nO(1)\\n\\n# Request\\n![LeetCode Upvote Request.webp](https://assets.leetcode.com/users/images/2798aaa4-6440-43bb-9d13-a925e5491c2f_1690459953.7107084.webp)\\n\\n\\n# Code\\n- JAVA\\n```\\nclass Solution \\n{\\n    public int threeSumClosest(int[] nums, int target) \\n    {\\n        // Sort the input array in ascending order to use two pointers.\\n        Arrays.sort(nums);\\n        \\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        int closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the array to find the closest sum to the target.\\n        for (int i = 0; i < nums.length - 2; i++) \\n        {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) \\n            {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (compare(target, sum, closestSum))\\n                    closestSum = sum; \\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    private boolean compare(int target, int sum, int closestSum)\\n    {\\n        return Math.abs(target - sum) < Math.abs(target - closestSum);\\n    }\\n}\\n```\\n\\n- Python\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums, target):\\n        # Sort the input list in ascending order to use two pointers.\\n        nums.sort()\\n\\n        # Initialize a variable to store the closest sum of three integers found so far.\\n        closest_sum = nums[0] + nums[1] + nums[2]\\n\\n        # Iterate through the list to find the closest sum to the target.\\n        for i in range(len(nums) - 2):\\n            # Initialize two pointers \\'j\\' and \\'k\\'.\\n            j = i + 1\\n            k = len(nums) - 1\\n\\n            # Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while j < k:\\n                # Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                _sum = nums[i] + nums[j] + nums[k]\\n\\n                # Update the closest sum if the current sum is closer to the target.\\n                if self.compare(target, _sum, closest_sum):\\n                    closest_sum = _sum\\n\\n                # Adjust pointers based on the current sum compared to the target.\\n                if _sum < target:\\n                    j += 1  # Increment \\'j\\' to potentially get closer to the target sum.\\n                else:\\n                    k -= 1  # Decrement \\'k\\' to potentially get closer to the target sum.\\n\\n        # Return the closest sum of three integers to the target.\\n        return closest_sum\\n\\n    # Helper function to compare the distance of two sums to the target and return True if the current sum is closer.\\n    def compare(self, target, _sum, closest_sum):\\n        return abs(target - _sum) < abs(target - closest_sum)\\n\\n```\\n\\n- C++\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(std::vector<int>& nums, int target) {\\n        // Sort the input vector in ascending order to use two pointers.\\n        std::sort(nums.begin(), nums.end());\\n        \\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        int closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the vector to find the closest sum to the target.\\n        for (int i = 0; i < nums.size() - 2; i++) {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (compare(target, sum, closestSum))\\n                    closestSum = sum; \\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\nprivate:\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    bool compare(int target, int sum, int closestSum) {\\n        return abs(target - sum) < abs(target - closestSum);\\n    }\\n};\\n\\n```\\n\\n- JavaScript\\n```\\nclass Solution {\\n    threeSumClosest(nums, target) {\\n        // Sort the input array in ascending order to use two pointers.\\n        nums.sort((a, b) => a - b);\\n\\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        let closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the array to find the closest sum to the target.\\n        for (let i = 0; i < nums.length - 2; i++) {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            let j = i + 1;\\n            let k = nums.length - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                const sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (this.compare(target, sum, closestSum))\\n                    closestSum = sum;\\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    compare(target, sum, closestSum) {\\n        return Math.abs(target - sum) < Math.abs(target - closestSum);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int threeSumClosest(int[] nums, int target) \\n    {\\n        // Sort the input array in ascending order to use two pointers.\\n        Arrays.sort(nums);\\n        \\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        int closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the array to find the closest sum to the target.\\n        for (int i = 0; i < nums.length - 2; i++) \\n        {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            int j = i + 1;\\n            int k = nums.length - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) \\n            {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (compare(target, sum, closestSum))\\n                    closestSum = sum; \\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    private boolean compare(int target, int sum, int closestSum)\\n    {\\n        return Math.abs(target - sum) < Math.abs(target - closestSum);\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def threeSumClosest(self, nums, target):\\n        # Sort the input list in ascending order to use two pointers.\\n        nums.sort()\\n\\n        # Initialize a variable to store the closest sum of three integers found so far.\\n        closest_sum = nums[0] + nums[1] + nums[2]\\n\\n        # Iterate through the list to find the closest sum to the target.\\n        for i in range(len(nums) - 2):\\n            # Initialize two pointers \\'j\\' and \\'k\\'.\\n            j = i + 1\\n            k = len(nums) - 1\\n\\n            # Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while j < k:\\n                # Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                _sum = nums[i] + nums[j] + nums[k]\\n\\n                # Update the closest sum if the current sum is closer to the target.\\n                if self.compare(target, _sum, closest_sum):\\n                    closest_sum = _sum\\n\\n                # Adjust pointers based on the current sum compared to the target.\\n                if _sum < target:\\n                    j += 1  # Increment \\'j\\' to potentially get closer to the target sum.\\n                else:\\n                    k -= 1  # Decrement \\'k\\' to potentially get closer to the target sum.\\n\\n        # Return the closest sum of three integers to the target.\\n        return closest_sum\\n\\n    # Helper function to compare the distance of two sums to the target and return True if the current sum is closer.\\n    def compare(self, target, _sum, closest_sum):\\n        return abs(target - _sum) < abs(target - closest_sum)\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(std::vector<int>& nums, int target) {\\n        // Sort the input vector in ascending order to use two pointers.\\n        std::sort(nums.begin(), nums.end());\\n        \\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        int closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the vector to find the closest sum to the target.\\n        for (int i = 0; i < nums.size() - 2; i++) {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            int j = i + 1;\\n            int k = nums.size() - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                int sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (compare(target, sum, closestSum))\\n                    closestSum = sum; \\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\nprivate:\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    bool compare(int target, int sum, int closestSum) {\\n        return abs(target - sum) < abs(target - closestSum);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    threeSumClosest(nums, target) {\\n        // Sort the input array in ascending order to use two pointers.\\n        nums.sort((a, b) => a - b);\\n\\n        // Initialize a variable to store the closest sum of three integers found so far.\\n        let closestSum = nums[0] + nums[1] + nums[2];\\n\\n        // Iterate through the array to find the closest sum to the target.\\n        for (let i = 0; i < nums.length - 2; i++) {\\n            // Initialize two pointers \\'j\\' and \\'k\\'.\\n            let j = i + 1;\\n            let k = nums.length - 1;\\n\\n            // Use a while loop with two pointers to explore all possible combinations of triplets.\\n            while (j < k) {\\n                // Calculate the sum of elements at indices \\'i\\', \\'j\\', and \\'k\\'.\\n                const sum = nums[i] + nums[j] + nums[k];\\n\\n                // Update the closest sum if the current sum is closer to the target.\\n                if (this.compare(target, sum, closestSum))\\n                    closestSum = sum;\\n\\n                // Adjust pointers based on the current sum compared to the target.\\n                if (sum < target)\\n                    j++; // Increment \\'j\\' to potentially get closer to the target sum.\\n                else\\n                    k--; // Decrement \\'k\\' to potentially get closer to the target sum.\\n            }\\n        }\\n\\n        // Return the closest sum of three integers to the target.\\n        return closestSum;\\n    }\\n\\n    // Helper function to compare the distance of two sums to the target and return true if the current sum is closer.\\n    compare(target, sum, closestSum) {\\n        return Math.abs(target - sum) < Math.abs(target - closestSum);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748757,
                "title": "easy-solution-using-sorting-and-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int prev=nums[0]+nums[1]+nums[2];\\n        for(int i=0;i<nums.size()-1;i++){\\n            int j=i+1;\\n            int k=nums.size()-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(abs(sum-target)<abs(prev-target))\\n                prev=sum;\\n                \\n                if(sum<target)\\n                j++;\\n                else\\n                k--;\\n            }\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int prev=nums[0]+nums[1]+nums[2];\\n        for(int i=0;i<nums.size()-1;i++){\\n            int j=i+1;\\n            int k=nums.size()-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(abs(sum-target)<abs(prev-target))\\n                prev=sum;\\n                \\n                if(sum<target)\\n                j++;\\n                else\\n                k--;\\n            }\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682363,
                "title": "c-easy-solutions-simple-explanation-two-pointer-approach",
                "content": "# Intuition\\n- Sorting the array is crucial for applying the two-pointer technique. It allows us to efficiently move the pointers towards each other, converging on the closest sum to the target.\\n- By iterating over each element as the first element of the triplet, we ensure that we explore all possible combinations and find the closest sum.\\n- The two-pointer technique helps us explore different combinations of elements without having to consider every possible triplet, significantly reducing the time complexity.\\n- By updating the minimum difference (diff) and the closest sum (ans) whenever a closer sum is found, we ensure that we have the correct answer when the algorithm finishes.\\n- Overall, the intuition behind this approach is to use the sorted nature of the array and the two-pointer technique to efficiently explore different combinations of elements and find the closest sum to the target.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Sort the array in ascending order.\\n- Initialize variables for the minimum difference (diff) and the closest triplet sum (ans).\\n- Iterate over each element in the array.\\n- Use two pointers (left and right) to find the closest triplet sum to the target.\\n- Calculate the current triplet sum.\\n- Update diff and ans if the current sum is closer to the target.\\n- Adjust the pointers based on the value of the current sum.\\n- Repeat steps 5-7 until the pointers meet.\\n- Return the closest triplet sum (ans).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: The time complexity is O(n^2) due to the nested loops, where n is the size of the input array.\\n{ Sorting the array using sort(nums.begin(), nums.end()) takes O(n log n) time, where n is the size of the input array nums.\\nThe main part of the code consists of nested loops. The outer loop iterates n times, and the inner while loop, in the worst case, iterates n/2 times (when j and k start from the opposite ends of the array).\\nThus, the overall time complexity is O(n log n + n^2), which simplifies to O(n^2) since n^2 dominates n log n. }\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity is O(1) because the code uses a constant amount of additional space to store variables (diff, ans, n, i, j, k, and sum). The space required does not depend on the size of the input array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        \\n        // Step 1: Sort the array in ascending order\\n        sort(nums.begin(), nums.end());\\n        \\n        int diff = INT_MAX; // Initialize the minimum difference to a large value\\n        int ans; // Variable to store the closest triplet sum\\n        \\n        // Step 4: Iterate over each element in the array\\n        for(int i=0; i<n; i++){\\n            int j = i+1; // Initialize the left pointer\\n            int k = n-1; // Initialize the right pointer\\n            \\n            // Step 6: Find the closest triplet sum using two pointers\\n            while(j < k){\\n                int sum = nums[i] + nums[j] + nums[k]; // Calculate the current triplet sum\\n                \\n                // Step 8: Update the minimum difference and the closest sum if the current sum is closer to the target\\n                if(abs(sum - target) < diff){\\n                    diff = abs(sum - target);\\n                    ans = sum;\\n                }\\n                // If equal to sum, end function\\n                if(sum == target) return sum;\\n\\n                // Step 9: Adjust the pointers based on the value of the current sum\\n                if(sum < target) {\\n                    j++; // Increment the left pointer to consider a larger element\\n                } else {\\n                    k--; // Decrement the right pointer to consider a smaller element\\n                }\\n            }\\n        }\\n        \\n        // Step 11: Return the closest triplet sum\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        \\n        // Step 1: Sort the array in ascending order\\n        sort(nums.begin(), nums.end());\\n        \\n        int diff = INT_MAX; // Initialize the minimum difference to a large value\\n        int ans; // Variable to store the closest triplet sum\\n        \\n        // Step 4: Iterate over each element in the array\\n        for(int i=0; i<n; i++){\\n            int j = i+1; // Initialize the left pointer\\n            int k = n-1; // Initialize the right pointer\\n            \\n            // Step 6: Find the closest triplet sum using two pointers\\n            while(j < k){\\n                int sum = nums[i] + nums[j] + nums[k]; // Calculate the current triplet sum\\n                \\n                // Step 8: Update the minimum difference and the closest sum if the current sum is closer to the target\\n                if(abs(sum - target) < diff){\\n                    diff = abs(sum - target);\\n                    ans = sum;\\n                }\\n                // If equal to sum, end function\\n                if(sum == target) return sum;\\n\\n                // Step 9: Adjust the pointers based on the value of the current sum\\n                if(sum < target) {\\n                    j++; // Increment the left pointer to consider a larger element\\n                } else {\\n                    k--; // Decrement the right pointer to consider a smaller element\\n                }\\n            }\\n        }\\n        \\n        // Step 11: Return the closest triplet sum\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633271,
                "title": "easy-to-understand-c-solution-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int diff = INT_MAX, ans;\\n        for(int i=0; i<n; i++){\\n            int j = i+1;\\n            int k = n-1;\\n            while(j < k){\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(abs(sum - target) < diff){\\n                    diff = abs(sum - target);\\n                    ans = sum;\\n                }\\n                if(sum <= target) j++;\\n                else k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int diff = INT_MAX, ans;\\n        for(int i=0; i<n; i++){\\n            int j = i+1;\\n            int k = n-1;\\n            while(j < k){\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(abs(sum - target) < diff){\\n                    diff = abs(sum - target);\\n                    ans = sum;\\n                }\\n                if(sum <= target) j++;\\n                else k--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567201,
                "title": "bruteforce-o-n-3-to-optimized-o-nlog-n-n-2-code",
                "content": "# 1. Brute Force Code\\n### Approach\\nBrute Force Approach - Checking for all the possible triplets and then finding the closestSum be analysing the closeness of the currentSum by target. \\n\\n### Complexity\\n- Time complexity: O(n^3)\\n\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int closest = Integer.MAX_VALUE, closestSum = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length-2;i++){\\n            for(int j=i+1;j<nums.length-1;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    int close = Math.abs(sum-target);\\n                    if(close < closest){\\n                        closest = close;\\n                        closestSum = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n\\n// Brute Force Code \\n// Time Complexity : O(N^3)\\n// Space Complexity : O(1)\\n```\\n\\n# 2. Optimized 2 Pointers Code\\n### Approach\\n- Sort the array and have 3 pointers: at start, at end of the array and one moving from start + 1 to end - 1\\n- If sum of numbers at these 3 pointers equals target, then exit with target\\n- Else if sum < target, it means you need to add more to the sum, so move middle pointer forward\\n- Else move the end pointer backwards because the sum is too high\\n- Keep a running minimum difference to find the closest the sum gets to target \\n\\n### Complexity\\n- Time complexity: O(nlog(n) + n^2)\\n\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int closest = Integer.MAX_VALUE, closestSum = Integer.MAX_VALUE,i=-1,j=-1,k=-1;\\n        Arrays.sort(nums);                               // nlog(n)\\n        for(i=0;i<nums.length-2;i++){                    // O(n)\\n            j = i+1;\\n            k = nums.length-1;\\n            while(j < k){                                // O(n)\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(sum==target){return target;}\\n                else if(sum<target) {j++;}\\n                else {k--;}\\n                // Updating closestSum according to closest\\n                int close = Math.abs(sum - target);\\n                if(close<closest){\\n                    closest = close;\\n                    closestSum = sum;\\n                }               \\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n\\n// Optimized 2 Pointer Code \\n// Time Complexity : O(nlog(n) + n^2)\\n// Space Complexity : O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int closest = Integer.MAX_VALUE, closestSum = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length-2;i++){\\n            for(int j=i+1;j<nums.length-1;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    int sum = nums[i] + nums[j] + nums[k];\\n                    int close = Math.abs(sum-target);\\n                    if(close < closest){\\n                        closest = close;\\n                        closestSum = sum;\\n                    }\\n                }\\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n\\n// Brute Force Code \\n// Time Complexity : O(N^3)\\n// Space Complexity : O(1)\\n```\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int closest = Integer.MAX_VALUE, closestSum = Integer.MAX_VALUE,i=-1,j=-1,k=-1;\\n        Arrays.sort(nums);                               // nlog(n)\\n        for(i=0;i<nums.length-2;i++){                    // O(n)\\n            j = i+1;\\n            k = nums.length-1;\\n            while(j < k){                                // O(n)\\n                int sum = nums[i] + nums[j] + nums[k];\\n                if(sum==target){return target;}\\n                else if(sum<target) {j++;}\\n                else {k--;}\\n                // Updating closestSum according to closest\\n                int close = Math.abs(sum - target);\\n                if(close<closest){\\n                    closest = close;\\n                    closestSum = sum;\\n                }               \\n            }\\n        }\\n        return closestSum;\\n    }\\n}\\n\\n// Optimized 2 Pointer Code \\n// Time Complexity : O(nlog(n) + n^2)\\n// Space Complexity : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282146,
                "title": "java-runtime-17ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public int threeSumClosest(int[] nums, int target) \\n    {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        int temp=0;\\n        int temp1 = Integer.MAX_VALUE;\\n        int res=Integer.MAX_VALUE;\\n        int out=0;\\n        for (int i = 0; i < nums.length-1; i++)\\n        {\\n           int j=i+1;\\n           int k= nums.length-1;\\n           while(j<k)\\n           {\\n                sum = nums[i] + nums[j] + nums[k];\\n               temp = Math.abs((sum - target));\\n               if (temp < res)\\n               {\\n                   res = temp;\\n                   out = sum; \\n               }\\n               if (temp1<temp)\\n               {\\n                   j++;\\n                   k= nums.length-1;\\n                   temp1=Integer.MAX_VALUE;\\n               }\\n               else\\n               {\\n                   k--;\\n                   temp1 = temp;\\n               }\\n           }\\n           if (out==target) break;  \\n        }\\n        return out;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Sort"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int threeSumClosest(int[] nums, int target) \\n    {\\n        Arrays.sort(nums);\\n        int sum=0;\\n        int temp=0;\\n        int temp1 = Integer.MAX_VALUE;\\n        int res=Integer.MAX_VALUE;\\n        int out=0;\\n        for (int i = 0; i < nums.length-1; i++)\\n        {\\n           int j=i+1;\\n           int k= nums.length-1;\\n           while(j<k)\\n           {\\n                sum = nums[i] + nums[j] + nums[k];\\n               temp = Math.abs((sum - target));\\n               if (temp < res)\\n               {\\n                   res = temp;\\n                   out = sum; \\n               }\\n               if (temp1<temp)\\n               {\\n                   j++;\\n                   k= nums.length-1;\\n                   temp1=Integer.MAX_VALUE;\\n               }\\n               else\\n               {\\n                   k--;\\n                   temp1 = temp;\\n               }\\n           }\\n           if (out==target) break;  \\n        }\\n        return out;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275736,
                "title": "easy-intuitive-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans,cdiff,pdiff=0,0,100000\\n        for n,i in enumerate(nums):\\n            j,k=n+1,len(nums)-1\\n            if(n>0 and i==nums[n-1]): continue\\n            while(j<k):\\n                    summ=i+nums[j]+nums[k]\\n                    cdiff=abs(summ-target)\\n                    if pdiff>cdiff:\\n                        ans=summ\\n                        pdiff=cdiff\\n                    if(summ==target): return target\\n                    elif(summ<target):  \\n                        j+=1\\n                    else:\\n                        k-=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans,cdiff,pdiff=0,0,100000\\n        for n,i in enumerate(nums):\\n            j,k=n+1,len(nums)-1\\n            if(n>0 and i==nums[n-1]): continue\\n            while(j<k):\\n                    summ=i+nums[j]+nums[k]\\n                    cdiff=abs(summ-target)\\n                    if pdiff>cdiff:\\n                        ans=summ\\n                        pdiff=cdiff\\n                    if(summ==target): return target\\n                    elif(summ<target):  \\n                        j+=1\\n                    else:\\n                        k-=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3237073,
                "title": "javascript-best-way-explanation-easy-to-solve",
                "content": "\\n# Approach\\n i Use a two-pointer approach to find the three integers in nums that add up to the closest sum to target. The algorithm first sorts the input array in ascending order. It then initializes the closest sum to the sum of the first three elements in the sorted array.\\n\\nThe algorithm then iterates through each element of the array, treating it as the first element of a possible three-sum combination. For each first element, it uses two pointers, left and right, to search for the two other elements that sum to the closest possible value to target. The pointers start at the first element after the first element and at the last element of the array, respectively. The pointers move towards each other until they meet. For each combination of `nums[i]`, `nums[left`], and `nums[right]`, the algorithm computes the sum and checks if it is closer to target than the current closest sum. If it is, the closest sum is updated. Finally, the algorithm returns the closest sum found.\\n\\ni assume that the input array nums has at least three elements. If the input array has fewer than three elements, the implementation may produce incorrect results. To handle this case, additional logic would be needed to check the length of the input array before attempting to find the closest three-sum.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n     nums.sort((a, b) => a - b); // sort the array in ascending order\\n  let closestSum = nums[0] + nums[1] + nums[2]; // initialize closest sum to the sum of the first three elements\\n\\n  for (let i = 0; i < nums.length - 2; i++) {\\n    let left = i + 1;\\n    let right = nums.length - 1;\\n\\n    while (left < right) {\\n      const sum = nums[i] + nums[left] + nums[right];\\n\\n      if (Math.abs(sum - target) < Math.abs(closestSum - target)) {\\n        closestSum = sum;\\n      }\\n\\n      if (sum < target) {\\n        left++;\\n      } else {\\n        right--;\\n      }\\n    }\\n  }\\n\\n  return closestSum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar threeSumClosest = function(nums, target) {\\n     nums.sort((a, b) => a - b); // sort the array in ascending order\\n  let closestSum = nums[0] + nums[1] + nums[2]; // initialize closest sum to the sum of the first three elements\\n\\n  for (let i = 0; i < nums.length - 2; i++) {\\n    let left = i + 1;\\n    let right = nums.length - 1;\\n\\n    while (left < right) {\\n      const sum = nums[i] + nums[left] + nums[right];\\n\\n      if (Math.abs(sum - target) < Math.abs(closestSum - target)) {\\n        closestSum = sum;\\n      }\\n\\n      if (sum < target) {\\n        left++;\\n      } else {\\n        right--;\\n      }\\n    }\\n  }\\n\\n  return closestSum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3220908,
                "title": "triple-threat-finding-the-closest-three-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we can use a similar approach to the three sum problem. We first sort the input array and fix the first element in the triplet. Then, we use two pointers to search for the remaining two elements such that the sum is closest to the target.\\n# Algorithm\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the input array nums.\\n\\n- Initialize a variable diff to store the difference between the target and the sum of the triplet. Initialize a variable res to store the sum of the closest triplet found so far.\\n\\n- Loop over the input array nums from the first element to the second last element.\\n\\n- Initialize two pointers left and right to search for the remaining two elements such that the sum is closest to the target.\\n\\n- While left < right, calculate the sum of the triplet nums[i] + nums[left] + nums[right].\\n\\n- If the absolute difference between the target and the sum is less than the absolute difference between the target and the current value of res, update res to the sum.\\n\\n- If the sum is less than the target, increment the left pointer. Otherwise, decrement the right pointer.\\n- Return the value of res.\\n# Complexity\\n- Time complexity: The time complexity of the above algorithm is $$O(n^2)$$, where n is the length of the input array nums. This is because we have two nested loops to search for the remaining two elements such that the sum is closest to the target.\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the above algorithm is $$O(1)$$ because we are using constant extra space to store the variables diff and res.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        diff = float(\\'inf\\')\\n        res = 0\\n        for i in range(n - 2):\\n            left = i + 1\\n            right = n - 1\\n            while left < right:\\n                s = nums[i] + nums[left] + nums[right]\\n                if abs(target - s) < diff:\\n                    diff = abs(target - s)\\n                    res = s\\n                if s < target:\\n                    left += 1\\n                else:\\n                    right -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        diff = float(\\'inf\\')\\n        res = 0\\n        for i in range(n - 2):\\n            left = i + 1\\n            right = n - 1\\n            while left < right:\\n                s = nums[i] + nums[left] + nums[right]\\n                if abs(target - s) < diff:\\n                    diff = abs(target - s)\\n                    res = s\\n                if s < target:\\n                    left += 1\\n                else:\\n                    right -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811774,
                "title": "c-easy-to-understand-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int front;\\n        int sum=nums[0]+nums[1]+nums[2],sum1=0;\\n        for(int i=0;i<nums.size();i++){\\n            front=i+1;\\n            int back=nums.size()-1;\\n            while(front<back){\\n            sum1=nums[front]+nums[back]+nums[i];\\n            if(abs(sum1-target)<=abs(sum-target)){\\n                sum=sum1;\\n            }\\n            if(sum1>target) \\n                back--;\\n            else if(sum1<target) \\n               front++;\\n            else return sum1;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int front;\\n        int sum=nums[0]+nums[1]+nums[2],sum1=0;\\n        for(int i=0;i<nums.size();i++){\\n            front=i+1;\\n            int back=nums.size()-1;\\n            while(front<back){\\n            sum1=nums[front]+nums[back]+nums[i];\\n            if(abs(sum1-target)<=abs(sum-target)){\\n                sum=sum1;\\n            }\\n            if(sum1>target) \\n                back--;\\n            else if(sum1<target) \\n               front++;\\n            else return sum1;\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811445,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int ans=nums[0]+nums[1]+nums[nums.length-1];\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-2;i++){\\n            int left=i+1;\\n            int right=nums.length-1;\\n             while(left<right){\\n                 int sum=nums[i]+nums[left]+nums[right];\\n                 if(sum>target){\\n                     right--;\\n                 }else{\\n                     left++;\\n                 }\\n                 if(Math.abs(sum-target)<Math.abs(ans-target))\\n                     ans=sum;\\n             }\\n            \\n            }\\n        return ans;\\n        }\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        int ans=nums[0]+nums[1]+nums[nums.length-1];\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length-2;i++){\\n            int left=i+1;\\n            int right=nums.length-1;\\n             while(left<right){\\n                 int sum=nums[i]+nums[left]+nums[right];\\n                 if(sum>target){\\n                     right--;\\n                 }else{\\n                     left++;\\n                 }\\n                 if(Math.abs(sum-target)<Math.abs(ans-target))\\n                     ans=sum;\\n             }\\n            \\n            }\\n        return ans;\\n        }\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2753073,
                "title": "python-solution-two-pointers",
                "content": "class Solution:\\n\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        min_dif = math.inf\\n        \\n        \\n        for i in range(len(nums)-2):\\n            left = i + 1\\n            right = len(nums)-1\\n            while left < right:\\n                current_diff = target - nums[i] - nums[left]-nums[right]\\n\\n                if current_diff == 0:\\n                    return target\\n\\n                if abs(min_dif) > abs(current_diff) or (abs(min_dif) == abs(current_diff) and current_diff>min_dif):\\n                    min_dif = current_diff\\n\\n\\n                if current_diff >0:\\n                    left += 1\\n                else:\\n                    right -=1\\n                                                    \\n        return target - min_dif\\n",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        min_dif = math.inf\\n        \\n        \\n        for i in range(len(nums)-2):\\n            left = i + 1\\n            right = len(nums)-1\\n            while left < right:\\n                current_diff = target - nums[i] - nums[left]-nums[right]\\n\\n                if current_diff == 0:\\n                    return target\\n\\n                if abs(min_dif) > abs(current_diff) or (abs(min_dif) == abs(current_diff) and current_diff>min_dif):\\n                    min_dif = current_diff\\n\\n\\n                if current_diff >0:\\n                    left += 1\\n                else:\\n                    right -=1\\n                                                    \\n        return target - min_dif\\n",
                "codeTag": "Java"
            },
            {
                "id": 2677030,
                "title": "brute-force-optimized-faster-than-98",
                "content": "## Brute Force Solution: O(n^3)\\n```\\nvar threeSumClosest = function(nums, target) {\\n\\n    let closestSum = 9999999;\\n    nums.sort((a,b) => a-b);\\n    \\n    for(let i=0;i<nums.length-2;i++){\\n         for(let j=i+1;j<nums.length-1;j++){\\n             for(let k=j+1;k<nums.length;k++){\\n                 if(Math.abs(closestSum) > Math.abs(nums[i] + nums[j] + nums[k] - target)){\\n                     closestSum = nums[i] + nums[j] + nums[k] - target;\\n                 }\\n             }\\n         }\\n     }\\n}\\n```\\n\\n## Optimized Solution. Break problem into two sum. O(n^2)\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\n\\nvar threeSumClosest = function(nums, target) {\\n    let closestSum = 9999999;\\n    nums.sort((a,b) => a-b);\\n\\t\\n    for(let i=0; i<nums.length-2; i++){\\n        let j = i+1;\\n        let k = nums.length - 1;\\n        let closest = 9999999999;\\n        while(j<k){\\n            let x = nums[i];\\n            let y = nums[j];\\n            let z = nums[k];\\n            \\n            let currSum = x+y+z;\\n            if(Math.abs(currSum - target) < Math.abs(closest - target)){\\n                closest = currSum;\\n            }\\n            //means increase the current sum\\n            if(currSum > target){\\n                k--;\\n            } else if(currSum < target){//decrease the sum\\n                j++;\\n            } else {\\n                closest = currSum;\\n                return closest;\\n            }\\n        }\\n        if(Math.abs(closest - target) < Math.abs(closestSum - target)){\\n            closestSum = closest\\n        }\\n    }\\n    \\n    return closestSum;\\n};\\n```\\n\\n**Do give a rep if you find the solution helpful ^_^**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar threeSumClosest = function(nums, target) {\\n\\n    let closestSum = 9999999;\\n    nums.sort((a,b) => a-b);\\n    \\n    for(let i=0;i<nums.length-2;i++){\\n         for(let j=i+1;j<nums.length-1;j++){\\n             for(let k=j+1;k<nums.length;k++){\\n                 if(Math.abs(closestSum) > Math.abs(nums[i] + nums[j] + nums[k] - target)){\\n                     closestSum = nums[i] + nums[j] + nums[k] - target;\\n                 }\\n             }\\n         }\\n     }\\n}\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\n\\nvar threeSumClosest = function(nums, target) {\\n    let closestSum = 9999999;\\n    nums.sort((a,b) => a-b);\\n\\t\\n    for(let i=0; i<nums.length-2; i++){\\n        let j = i+1;\\n        let k = nums.length - 1;\\n        let closest = 9999999999;\\n        while(j<k){\\n            let x = nums[i];\\n            let y = nums[j];\\n            let z = nums[k];\\n            \\n            let currSum = x+y+z;\\n            if(Math.abs(currSum - target) < Math.abs(closest - target)){\\n                closest = currSum;\\n            }\\n            //means increase the current sum\\n            if(currSum > target){\\n                k--;\\n            } else if(currSum < target){//decrease the sum\\n                j++;\\n            } else {\\n                closest = currSum;\\n                return closest;\\n            }\\n        }\\n        if(Math.abs(closest - target) < Math.abs(closestSum - target)){\\n            closestSum = closest\\n        }\\n    }\\n    \\n    return closestSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2676496,
                "title": "python",
                "content": "**The Logic**:\\nFirst we sort `nums` in O(nLogn).\\nThen, we fix one number by looping through the `nums`. As soon as one number is fixed - we can iterate two other numbers simultaneously. How? Let `hi = len(nums) - 1` and `lo = i + 1` where `i` is fixed (first out of three numbers).\\nWe sum the numbers - `s`. If it is lower than the `target` - what can we do? We can only increase `lo` by one - because `nums` are sorted. By that, we are trying to increase the sum `s`. We keep moving `lo` by one until `s` is lower than the `target`. As soon as we got a number higher than the `target`, we can try to decrease it. Either we decrease `lo` by one - but we already had it before. Or we can decrease `hi` by one. So, the total sum should be decreased, because the array is sorted.\\nThus we have one loop and one nested loop - O(N^2).\\n\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = float(\\'inf\\')\\n        for i in range(len(nums) - 2):\\n            lo, hi = i + 1, len(nums) - 1\\n            \\n            while lo < hi:\\n                s = nums[i] + nums[lo] + nums[hi]\\n                if s == target:\\n                    return s\\n                elif s > target:\\n                    hi -= 1\\n                else:\\n                    lo += 1\\n                if abs(s - target) < abs(ans - target):\\n                    ans = s\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        ans = float(\\'inf\\')\\n        for i in range(len(nums) - 2):\\n            lo, hi = i + 1, len(nums) - 1\\n            \\n            while lo < hi:\\n                s = nums[i] + nums[lo] + nums[hi]\\n                if s == target:\\n                    return s\\n                elif s > target:\\n                    hi -= 1\\n                else:\\n                    lo += 1\\n                if abs(s - target) < abs(ans - target):\\n                    ans = s\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675865,
                "title": "rust-33-ms-fastest-100-two-pointers-solution-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/817764364/) employs a two-pointers approach with sorting. It demonstrated **33 ms runtime (100.00%)** and used **2.2 MB memory (15.46%)**. Time complexity is quadratic: **O(N\\\\*N)**. Space complexity is constant: **O(1)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn three_sum_closest(mut nums: Vec<i32>, target: i32) -> i32 \\n    {\\n        // [1] sorting would allow us to use two pointers\\n        nums.sort_unstable();\\n        let mut best_diff: i32 = i32::MAX;\\n        \\n        // [2] use two pointers \\'l\\' and \\'r\\' that converge towards \\n        //     one another for each first element \\'i\\'\\n        for i in 0..nums.len()\\n        {\\n            let mut l = i + 1;\\n            let mut r = nums.len() - 1;\\n            let pre_diff = nums[i] - target;\\n            while l < r\\n            {\\n                let diff = pre_diff + nums[l] + nums[r];\\n                if diff.abs() < best_diff.abs() { best_diff = diff; }\\n                match diff.signum()\\n                {\\n                    1  => r -= 1,\\n                    -1 => l += 1,\\n                    0  => return target,\\n                    _  => unreachable!()\\n                }\\n            }\\n        }\\n        \\n        return target + best_diff;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn three_sum_closest(mut nums: Vec<i32>, target: i32) -> i32 \\n    {\\n        // [1] sorting would allow us to use two pointers\\n        nums.sort_unstable();\\n        let mut best_diff: i32 = i32::MAX;\\n        \\n        // [2] use two pointers \\'l\\' and \\'r\\' that converge towards \\n        //     one another for each first element \\'i\\'\\n        for i in 0..nums.len()\\n        {\\n            let mut l = i + 1;\\n            let mut r = nums.len() - 1;\\n            let pre_diff = nums[i] - target;\\n            while l < r\\n            {\\n                let diff = pre_diff + nums[l] + nums[r];\\n                if diff.abs() < best_diff.abs() { best_diff = diff; }\\n                match diff.signum()\\n                {\\n                    1  => r -= 1,\\n                    -1 => l += 1,\\n                    0  => return target,\\n                    _  => unreachable!()\\n                }\\n            }\\n        }\\n        \\n        return target + best_diff;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2675826,
                "title": "easy-cpp-2-pointer-simple-approach",
                "content": "```\\n   int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(),nums.end());\\n        int ans = 0,n=nums.size();\\n        int diff = INT_MAX;\\n            for(int i=0;i<n;i++)\\n            {\\n                    int first = nums[i];\\n                    int s=i+1,e=n-1;\\n                    while(s<e)\\n                    {\\n                            if(first+nums[s]+nums[e]==target)\\n                                    return target;\\n                            else if(abs(first+nums[s]+nums[e]-target)<diff)\\n                            {\\n                                    diff = abs(first+nums[s]+nums[e]-target);\\n                                    ans = first+nums[s]+nums[e];\\n                            }\\n                            if(first+nums[s]+nums[e]>target)\\n                                    e--;\\n                            else\\n                                    s++;\\n                    }\\n            }\\n            return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n   int threeSumClosest(vector<int>& nums, int target) {\\n            sort(nums.begin(),nums.end());\\n        int ans = 0,n=nums.size();\\n        int diff = INT_MAX;\\n            for(int i=0;i<n;i++)\\n            {\\n                    int first = nums[i];\\n                    int s=i+1,e=n-1;\\n                    while(s<e)\\n                    {\\n                            if(first+nums[s]+nums[e]==target)\\n                                    return target;\\n                            else if(abs(first+nums[s]+nums[e]-target)<diff)\\n                            {\\n                                    diff = abs(first+nums[s]+nums[e]-target);\\n                                    ans = first+nums[s]+nums[e];\\n                            }\\n                            if(first+nums[s]+nums[e]>target)\\n                                    e--;\\n                            else\\n                                    s++;\\n                    }\\n            }\\n            return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2675529,
                "title": "python-two-pointer-solution-with-explanation",
                "content": "sort ```nums``` first, we can check the largest three and smallest three values,\\n\\nif the sum of smallest three values is greater than or equal to ```target```, return it\\nif the sum of largest three values is smaller than or equal to ```target```, return it\\n\\nand fix one value```pivot```, and find the other two value is the closet to the ``` target ``` in the ```[l, r]```.\\n\\nbecause ```nums``` is sorted,\\n\\nif the sum of the smallest two value ```nums[l] + nums[l+1]``` is greater than or equal to ```delta```, which means all the pair in the current and next iteration are greater than ```delta```, no need to check them, just return ```ans```\\n\\nif the sum of the largest two value ```nums[r-1] + nums[r]``` is smaller than or equal to ```delta```, which means all the pair in the current iteration are smaller than ```delta```, no need to check them, just go to the next iteration\\n\\ntc is ```O(N^2)```, sc is ```O(1)```\\n```python\\n# Runtime: 133 ms, faster than 99.96% of Python3 online submissions for 3Sum Closest.\\n# Memory Usage: 14.3 MB, less than 12.36% of Python3 online submissions for 3Sum Closest.\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        max3, min3 = sum(nums[-3:]), sum(nums[:3])\\n        if min3 >= target: return min3\\n        elif max3 <= target: return max3\\n        pivot, leng, ans = 0, len(nums), float(\\'inf\\')\\n        \\n        for pivot in range(leng-2):\\n            delta = target - nums[pivot]\\n            l, r = pivot+1, leng-1\\n            if nums[l] + nums[l+1] == delta:\\n                return nums[l] + nums[l+1] + nums[pivot]\\n            elif nums[r] + nums[r-1] == delta:\\n                 return nums[r] + nums[r-1] + nums[pivot]\\n            elif nums[l] + nums[l+1] > delta:\\n                if abs(target - ans) > abs(delta - nums[l] - nums[l+1]):\\n                    ans = nums[l] + nums[l+1] + nums[pivot]\\n                return ans\\n            elif nums[r] + nums[r-1] < delta:\\n                if abs(target - ans) > abs(delta - nums[r] - nums[r-1]):\\n                    ans = nums[r] + nums[r-1] + nums[pivot]\\n                continue\\n            while l < r:\\n                v = nums[l] + nums[r]\\n                if abs(target - ans) > abs(delta - v):\\n                    ans = v + nums[pivot]\\n                if v > delta:\\n                    r-=1\\n                elif v < delta:\\n                    l+=1\\n                else:\\n                    return ans\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```nums```\n```target```\n```target```\n```pivot```\n``` target ```\n```[l, r]```\n```nums```\n```nums[l] + nums[l+1]```\n```delta```\n```delta```\n```ans```\n```nums[r-1] + nums[r]```\n```delta```\n```delta```\n```O(N^2)```\n```O(1)```\n```python\\n# Runtime: 133 ms, faster than 99.96% of Python3 online submissions for 3Sum Closest.\\n# Memory Usage: 14.3 MB, less than 12.36% of Python3 online submissions for 3Sum Closest.\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        max3, min3 = sum(nums[-3:]), sum(nums[:3])\\n        if min3 >= target: return min3\\n        elif max3 <= target: return max3\\n        pivot, leng, ans = 0, len(nums), float(\\'inf\\')\\n        \\n        for pivot in range(leng-2):\\n            delta = target - nums[pivot]\\n            l, r = pivot+1, leng-1\\n            if nums[l] + nums[l+1] == delta:\\n                return nums[l] + nums[l+1] + nums[pivot]\\n            elif nums[r] + nums[r-1] == delta:\\n                 return nums[r] + nums[r-1] + nums[pivot]\\n            elif nums[l] + nums[l+1] > delta:\\n                if abs(target - ans) > abs(delta - nums[l] - nums[l+1]):\\n                    ans = nums[l] + nums[l+1] + nums[pivot]\\n                return ans\\n            elif nums[r] + nums[r-1] < delta:\\n                if abs(target - ans) > abs(delta - nums[r] - nums[r-1]):\\n                    ans = nums[r] + nums[r-1] + nums[pivot]\\n                continue\\n            while l < r:\\n                v = nums[l] + nums[r]\\n                if abs(target - ans) > abs(delta - v):\\n                    ans = v + nums[pivot]\\n                if v > delta:\\n                    r-=1\\n                elif v < delta:\\n                    l+=1\\n                else:\\n                    return ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675440,
                "title": "python-easy-o-n-2-solution-with-removed-iteration-for-same-set-of-3-values",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        result = float(\\'inf\\')\\n        for i in range(n-2):\\n\\t\\t\\t#  improve is to skip the i if i appears in the loop already. The runtime can be reduced to ~3000ms.\\n            if i!=0 and nums[i]==nums[i-1]:\\n                continue\\n            j, k = i+1, n-1\\n            while j<k:\\n                add = nums[i]+nums[j]+nums[k]\\n                if add==target:\\n                    return add\\n                elif abs(add-target)<abs(result-target):\\n                    result = add\\n                if add>target:\\n                    k-=1\\n                else:\\n                    j+=1\\n                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        result = float(\\'inf\\')\\n        for i in range(n-2):\\n\\t\\t\\t#  improve is to skip the i if i appears in the loop already. The runtime can be reduced to ~3000ms.\\n            if i!=0 and nums[i]==nums[i-1]:\\n                continue\\n            j, k = i+1, n-1\\n            while j<k:\\n                add = nums[i]+nums[j]+nums[k]\\n                if add==target:\\n                    return add\\n                elif abs(add-target)<abs(result-target):\\n                    result = add\\n                if add>target:\\n                    k-=1\\n                else:\\n                    j+=1\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675018,
                "title": "cpp-solution-notes-video-explanation-how-to-approach-this-problem",
                "content": "Please visit my channel, and support me by liking, sharing, and subscribing my channel.\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/CclNyWEnp2Y\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n# Notes:\\n\\n![image](https://assets.leetcode.com/users/images/d40168a9-8bde-4a33-a0a6-cf43e25fa7b2_1665209465.7496073.png)\\n![image](https://assets.leetcode.com/users/images/6af06b4f-60f2-4326-afb0-114902c92b05_1665209488.0175567.png)\\n** second ++;\\n\\n\\n# Code:\\n\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int first = 0;\\n        int second = 1;\\n        int third = nums.size()-1;\\n        \\n        int sum = nums[0]+nums[1]+nums[2];\\n        \\n        for(; first<nums.size()-2 ; first++){\\n            second = first + 1;\\n            third = nums.size()-1;\\n            \\n            while(second<third){\\n                int curr_sum = nums[first] + nums[second] + nums[third];\\n                \\n                if(abs(target-curr_sum)< abs(target-sum)){\\n                    sum = curr_sum;\\n                }\\n                if(curr_sum > target){\\n                    third--;\\n                }\\n                else if(curr_sum < target){\\n                    second++;\\n                }\\n                else {\\n                    return curr_sum;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int first = 0;\\n        int second = 1;\\n        int third = nums.size()-1;\\n        \\n        int sum = nums[0]+nums[1]+nums[2];\\n        \\n        for(; first<nums.size()-2 ; first++){\\n            second = first + 1;\\n            third = nums.size()-1;\\n            \\n            while(second<third){\\n                int curr_sum = nums[first] + nums[second] + nums[third];\\n                \\n                if(abs(target-curr_sum)< abs(target-sum)){\\n                    sum = curr_sum;\\n                }\\n                if(curr_sum > target){\\n                    third--;\\n                }\\n                else if(curr_sum < target){\\n                    second++;\\n                }\\n                else {\\n                    return curr_sum;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674491,
                "title": "c-python-short-concise-solution",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& arr, int sum) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        int diff = INT_MAX;\\n        int ans = 0;\\n\\t    for(int i=0; i<n-2; i++)\\n\\t    {\\n\\t        int j = i+1;\\n\\t        int k = n-1;\\n\\t        while(j<k)\\n\\t        {\\n                int res = arr[i] + arr[j] + arr[k];\\n                if(abs(res - sum) < diff){\\n                   ans = res;\\n                   diff = abs(sum - res);\\n                }\\n\\t            if(res < sum){\\n\\t                j++;\\n\\t            }\\n\\t            else if(res >= sum){\\n\\t                k--;\\n\\t            }\\n\\t        }\\n\\t    }\\n        \\n\\t  return ans;\\n    }\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        n = len(nums)\\n        nums.sort()\\n        ans = nums[0] + nums[1] + nums[2]\\n        diff = float(\"inf\")\\n        \\n        for i in range(0, n - 2):\\n            j = i + 1\\n            k = n - 1\\n            while j < k:\\n                sum = nums[i] + nums[j] + nums[k]\\n                if sum == target:\\n                    return sum\\n                \\n                if abs(sum - target) < diff:\\n                    ans = sum\\n                    diff = abs(sum - target)\\n                \\n                if sum > target:\\n                    k -= 1\\n                elif sum < target:\\n                    j += 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& arr, int sum) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        int diff = INT_MAX;\\n        int ans = 0;\\n\\t    for(int i=0; i<n-2; i++)\\n\\t    {\\n\\t        int j = i+1;\\n\\t        int k = n-1;\\n\\t        while(j<k)\\n\\t        {\\n                int res = arr[i] + arr[j] + arr[k];\\n                if(abs(res - sum) < diff){\\n                   ans = res;\\n                   diff = abs(sum - res);\\n                }\\n\\t            if(res < sum){\\n\\t                j++;\\n\\t            }\\n\\t            else if(res >= sum){\\n\\t                k--;\\n\\t            }\\n\\t        }\\n\\t    }\\n        \\n\\t  return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def threeSumClosest(self, nums, target):\\n        n = len(nums)\\n        nums.sort()\\n        ans = nums[0] + nums[1] + nums[2]\\n        diff = float(\"inf\")\\n        \\n        for i in range(0, n - 2):\\n            j = i + 1\\n            k = n - 1\\n            while j < k:\\n                sum = nums[i] + nums[j] + nums[k]\\n                if sum == target:\\n                    return sum\\n                \\n                if abs(sum - target) < diff:\\n                    ans = sum\\n                    diff = abs(sum - target)\\n                \\n                if sum > target:\\n                    k -= 1\\n                elif sum < target:\\n                    j += 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674469,
                "title": "daily-leetcode-solution-3-sum-closest",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans=INT_MAX;\\n        int prevdiff=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0&&nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            int lo=i+1,hi=n-1;\\n            while(lo<hi)\\n            {\\n                if(abs(nums[hi]+nums[lo]+nums[i]-target)<prevdiff)\\n                {\\n                    ans=nums[hi]+nums[lo]+nums[i];\\n                    prevdiff=abs(nums[hi]+nums[lo]+nums[i]-target);\\n                }\\n                else if(nums[hi]+nums[lo]+nums[i]<target) lo++;\\n                else hi--;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans=INT_MAX;\\n        int prevdiff=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0&&nums[i]==nums[i-1])\\n            {\\n                continue;\\n            }\\n            int lo=i+1,hi=n-1;\\n            while(lo<hi)\\n            {\\n                if(abs(nums[hi]+nums[lo]+nums[i]-target)<prevdiff)\\n                {\\n                    ans=nums[hi]+nums[lo]+nums[i];\\n                    prevdiff=abs(nums[hi]+nums[lo]+nums[i]-target);\\n                }\\n                else if(nums[hi]+nums[lo]+nums[i]<target) lo++;\\n                else hi--;\\n            }\\n        }\\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2674460,
                "title": "16-python-java-c-javascript-solutions",
                "content": "Python:\\n```\\ndef threeSumClosest(self, nums, target):\\n    nums.sort()\\n    res = sum(nums[:3])\\n    for i in xrange(len(nums)):\\n        l, r = i+1, len(nums)-1\\n        while l < r:\\n            s = sum((nums[i], nums[l], nums[r]))\\n            if abs(s-target) < abs(res-target):\\n                res = s\\n            if s < target:\\n                l += 1\\n            elif s > target:\\n                r -= 1\\n            else: # break early \\n                return res\\n    return res\\n```\\nJava:\\n```\\npublic int threeSumClosest(int[] nums, int target) {\\n\\tArrays.sort(nums);\\n\\tvar closest = 0;\\n\\n\\tfor (int i = 0, n = nums.length, minDiff = Integer.MAX_VALUE; i < n - 2; i++)\\n\\t\\tfor (int j = i + 1, k = n - 1; j < k;) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\tif (sum == target)\\n\\t\\t\\t\\treturn target;\\n\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\tj++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk--;\\n\\n\\t\\t\\tvar diff = Math.abs(target - sum);\\n\\t\\t\\tif (diff < minDiff) {\\n\\t\\t\\t\\tminDiff = diff;\\n\\t\\t\\t\\tclosest = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn closest;\\n}\\n```\\nC++:\\n```\\nint threeSumClosest(vector<int>& nums, int target) {\\n    if(nums.size() < 3) return 0;\\n    int closest = nums[0]+nums[1]+nums[2];\\n    sort(nums.begin(), nums.end());\\n    for(int first = 0 ; first < nums.size()-2 ; ++first) {\\n        if(first > 0 && nums[first] == nums[first-1]) continue;\\n        int second = first+1;\\n        int third = nums.size()-1;            \\n        while(second < third) {\\n            int curSum = nums[first]+nums[second]+nums[third];\\n            if(curSum == target) return curSum;\\n            if(abs(target-curSum)<abs(target-closest)) {\\n                closest = curSum;\\n            }\\n            if(curSum > target) {\\n                --third;\\n            } else {\\n                ++second;\\n            }\\n        }\\n    }\\n    return closest;\\n}\\n```\\nJavascript:\\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let closest = Infinity;\\n    for (let i=0;i<nums.length-2;i++) {\\n        let left = i+1; right = nums.length-1;\\n        while (left < right) {\\n            let localSum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(localSum - target) < Math.abs(closest - target)) closest = localSum;\\n            if (localSum > target) right--;\\n            else left++;\\n        }\\n    }\\n    return closest;\\n};\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Two Pointers",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\ndef threeSumClosest(self, nums, target):\\n    nums.sort()\\n    res = sum(nums[:3])\\n    for i in xrange(len(nums)):\\n        l, r = i+1, len(nums)-1\\n        while l < r:\\n            s = sum((nums[i], nums[l], nums[r]))\\n            if abs(s-target) < abs(res-target):\\n                res = s\\n            if s < target:\\n                l += 1\\n            elif s > target:\\n                r -= 1\\n            else: # break early \\n                return res\\n    return res\\n```\n```\\npublic int threeSumClosest(int[] nums, int target) {\\n\\tArrays.sort(nums);\\n\\tvar closest = 0;\\n\\n\\tfor (int i = 0, n = nums.length, minDiff = Integer.MAX_VALUE; i < n - 2; i++)\\n\\t\\tfor (int j = i + 1, k = n - 1; j < k;) {\\n\\t\\t\\tvar sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\tif (sum == target)\\n\\t\\t\\t\\treturn target;\\n\\t\\t\\tif (sum < target)\\n\\t\\t\\t\\tj++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tk--;\\n\\n\\t\\t\\tvar diff = Math.abs(target - sum);\\n\\t\\t\\tif (diff < minDiff) {\\n\\t\\t\\t\\tminDiff = diff;\\n\\t\\t\\t\\tclosest = sum;\\n\\t\\t\\t}\\n\\t\\t}\\n\\treturn closest;\\n}\\n```\n```\\nint threeSumClosest(vector<int>& nums, int target) {\\n    if(nums.size() < 3) return 0;\\n    int closest = nums[0]+nums[1]+nums[2];\\n    sort(nums.begin(), nums.end());\\n    for(int first = 0 ; first < nums.size()-2 ; ++first) {\\n        if(first > 0 && nums[first] == nums[first-1]) continue;\\n        int second = first+1;\\n        int third = nums.size()-1;            \\n        while(second < third) {\\n            int curSum = nums[first]+nums[second]+nums[third];\\n            if(curSum == target) return curSum;\\n            if(abs(target-curSum)<abs(target-closest)) {\\n                closest = curSum;\\n            }\\n            if(curSum > target) {\\n                --third;\\n            } else {\\n                ++second;\\n            }\\n        }\\n    }\\n    return closest;\\n}\\n```\n```\\nvar threeSumClosest = function(nums, target) {\\n    nums.sort((a,b)=>a-b);\\n    let closest = Infinity;\\n    for (let i=0;i<nums.length-2;i++) {\\n        let left = i+1; right = nums.length-1;\\n        while (left < right) {\\n            let localSum = nums[i] + nums[left] + nums[right];\\n            if (Math.abs(localSum - target) < Math.abs(closest - target)) closest = localSum;\\n            if (localSum > target) right--;\\n            else left++;\\n        }\\n    }\\n    return closest;\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2674413,
                "title": "c-two-pointer-beginner-friendly",
                "content": "class Solution {\\npublic:\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        \\n        int n=nums.size();\\n        int Res;\\n        int diff=INT_MAX;\\n        \\n        if(n<3) return {};\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int j=i+1;\\n            int k=n-1;\\n        \\n            while(j<k)\\n            {\\n                 int sum=nums[i]+nums[j]+nums[k];\\n                \\n                if(abs(sum-target) < diff)\\n                {\\n                    diff=abs(sum-target);\\n                    Res=sum;\\n                }\\n                \\n                if(sum > target) k--;\\n                \\n                else j++;\\n            }\\n        }        \\n        \\n       return Res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        \\n        int n=nums.size();\\n        int Res;\\n        int diff=INT_MAX;\\n        \\n        if(n<3) return {}",
                "codeTag": "Java"
            },
            {
                "id": 2594279,
                "title": "python-2-pointer-binary-search-beats-95",
                "content": "2 pointer solution with binary search in between both pointers:\\n\\n\\tdef threeSumClosest(self, nums: List[int], target: int) -> int:\\n\\n        nums.sort()\\n    \\n        left, right = 0, len(nums) - 1\\n        mid = left + 1\\n        \\n        result = nums[left] + nums[right] + nums[mid]\\n        \\n        while right - left > 1:\\n                        \\n            currSum = self.binSearch(nums, target, left, right)  \\n\\n            if currSum == target: return currSum\\n            \\n            if abs(currSum - target) < abs(result - target): result = currSum     \\n            \\n            if currSum < target: left += 1\\n            else: right -= 1\\n                \\n        return result\\n        \\n        \\n    def binSearch(self, nums, target, left, right):\\n        \\n        originalDistance = nums[left] + nums[right]\\n                \\n        left += 1\\n        right -= 1\\n        mid = (left + right)//2\\n        \\n        result = originalDistance + nums[mid]\\n                \\n        while left < right:\\n            mid = (left + right)//2\\n            \\n            currSum = originalDistance + nums[mid]\\n            \\n            if abs(currSum - target) < abs(result - target): result = currSum\\n                \\n            if currSum == target: return currSum\\n            elif currSum < target: left = mid + 1\\n            else: right = mid - 1\\n                \\n        return result",
                "solutionTags": [
                    "Two Pointers",
                    "Binary Tree"
                ],
                "code": "2 pointer solution with binary search in between both pointers:\\n\\n\\tdef threeSumClosest(self, nums: List[int], target: int) -> int:\\n\\n        nums.sort()\\n    \\n        left, right = 0, len(nums) - 1\\n        mid = left + 1\\n        \\n        result = nums[left] + nums[right] + nums[mid]\\n        \\n        while right - left > 1:\\n                        \\n            currSum = self.binSearch(nums, target, left, right)  \\n\\n            if currSum == target: return currSum\\n            \\n            if abs(currSum - target) < abs(result - target): result = currSum     \\n            \\n            if currSum < target: left += 1\\n            else: right -= 1\\n                \\n        return result\\n        \\n        \\n    def binSearch(self, nums, target, left, right):\\n        \\n        originalDistance = nums[left] + nums[right]\\n                \\n        left += 1\\n        right -= 1\\n        mid = (left + right)//2\\n        \\n        result = originalDistance + nums[mid]\\n                \\n        while left < right:\\n            mid = (left + right)//2\\n            \\n            currSum = originalDistance + nums[mid]\\n            \\n            if abs(currSum - target) < abs(result - target): result = currSum\\n                \\n            if currSum == target: return currSum\\n            elif currSum < target: left = mid + 1\\n            else: right = mid - 1\\n                \\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 2540163,
                "title": "java-simple-solution",
                "content": "https://www.youtube.com/watch?v=FJr3UfwtOKQ",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=FJr3UfwtOKQ",
                "codeTag": "Unknown"
            },
            {
                "id": 2437125,
                "title": "easy-to-understand-c-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        //BRUTE FORCE APPROACH...(but a little improved)\\n        //Applying two pointers on the sorted array for target-currnumber\\n        //time complexity O(N^2)\\n        \\n        \\n        int ans; //...Our Final sum(of all three integers) will be stored here\\n        int prevDiff = INT_MAX; //...this will be the closest difference between target and the sum we calculated...this will be changed each time it is compared with a sum that is found to be lower than the previous closest sum\\n        int temp = target;\\n        sort(nums.begin(),nums.end()); //sorting the array inorder to carry out our two pointer approach\\n        for(int i =0;i<nums.size()-2;i++){  //loop till nums.size()-2 because we always play with three pointers two of which we don\\'t want to get out of the array\\n                temp = target-nums[i]; //reducing the target to target-curr value(this curr value is one of the three integers we take into consideration)\\n                int start = i+1;        // starting from one index ahead of curr index\\n                int end = nums.size()-1;\\n                int x;                  // for calculating and comparing with the new target value(temp)...this is similar as two sum problem..\\n            \\n        // so the idea here is to get the sum of two integers as closest as (or equal to ) the new target(temp) which is done by \\n        // keeping two pointers and changing their positions so as to get as close as possible to our new target value.\\n                while(start<end){       \\n                     x = nums[start]+nums[end];\\n                    if(x==temp) break;      //breaking here ... cuz can\\'t get any closer than the TARGET ITSELF!\\n                    if(x<temp) start++;     //incase the sum is lower we shift start to right side so as to increase sum and get closer to our target value(temp)\\n                    else end--; \\n                }\\n            \\n            //now here after this traversal we have obtained a value of sum of three integers as close to temp as possible\\n            //this value is x + nums[i]\\n            //we take the difference of target value (original) with this sum and compare this difference with previous difference(because we need to be as close to target as possible right!)\\n            //if difference is less than prev diff we update our ans and prevDifference gets equal to this difference value..\\n                if(abs(target-(x+nums[i]))<prevDiff){   \\n                    ans = x+nums[i];\\n                    prevDiff = abs(target-(x+nums[i]));\\n                }\\n\\n        }\\n        return ans; //hooray!\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        //BRUTE FORCE APPROACH...(but a little improved)\\n        //Applying two pointers on the sorted array for target-currnumber\\n        //time complexity O(N^2)\\n        \\n        \\n        int ans; //...Our Final sum(of all three integers) will be stored here\\n        int prevDiff = INT_MAX; //...this will be the closest difference between target and the sum we calculated...this will be changed each time it is compared with a sum that is found to be lower than the previous closest sum\\n        int temp = target;\\n        sort(nums.begin(),nums.end()); //sorting the array inorder to carry out our two pointer approach\\n        for(int i =0;i<nums.size()-2;i++){  //loop till nums.size()-2 because we always play with three pointers two of which we don\\'t want to get out of the array\\n                temp = target-nums[i]; //reducing the target to target-curr value(this curr value is one of the three integers we take into consideration)\\n                int start = i+1;        // starting from one index ahead of curr index\\n                int end = nums.size()-1;\\n                int x;                  // for calculating and comparing with the new target value(temp)...this is similar as two sum problem..\\n            \\n        // so the idea here is to get the sum of two integers as closest as (or equal to ) the new target(temp) which is done by \\n        // keeping two pointers and changing their positions so as to get as close as possible to our new target value.\\n                while(start<end){       \\n                     x = nums[start]+nums[end];\\n                    if(x==temp) break;      //breaking here ... cuz can\\'t get any closer than the TARGET ITSELF!\\n                    if(x<temp) start++;     //incase the sum is lower we shift start to right side so as to increase sum and get closer to our target value(temp)\\n                    else end--; \\n                }\\n            \\n            //now here after this traversal we have obtained a value of sum of three integers as close to temp as possible\\n            //this value is x + nums[i]\\n            //we take the difference of target value (original) with this sum and compare this difference with previous difference(because we need to be as close to target as possible right!)\\n            //if difference is less than prev diff we update our ans and prevDifference gets equal to this difference value..\\n                if(abs(target-(x+nums[i]))<prevDiff){   \\n                    ans = x+nums[i];\\n                    prevDiff = abs(target-(x+nums[i]));\\n                }\\n\\n        }\\n        return ans; //hooray!\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372577,
                "title": "c-two-pointers-approach-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n                \\n        int mini = 1e8;\\n\\t\\t\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        int start, end, tgt;\\n        \\n        for(int i=0;i<n-2;i++){\\n            \\n            start = i+1;\\n            end = n-1;\\n            \\n            while(start<end){\\n                 \\n                int cur_sum = nums[i] + nums[start] + nums[end];\\n                \\n                if(cur_sum==target)\\n                    return cur_sum;\\n                \\n                if(abs(cur_sum-target)<abs(target-mini))\\n                    mini = cur_sum;\\n                \\n                if(cur_sum > target) end--;\\n                else start++;\\n            }\\n            \\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n                \\n        int mini = 1e8;\\n\\t\\t\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        int start, end, tgt;\\n        \\n        for(int i=0;i<n-2;i++){\\n            \\n            start = i+1;\\n            end = n-1;\\n            \\n            while(start<end){\\n                 \\n                int cur_sum = nums[i] + nums[start] + nums[end];\\n                \\n                if(cur_sum==target)\\n                    return cur_sum;\\n                \\n                if(abs(cur_sum-target)<abs(target-mini))\\n                    mini = cur_sum;\\n                \\n                if(cur_sum > target) end--;\\n                else start++;\\n            }\\n            \\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361234,
                "title": "easy-c-solution-with-explanation-two-pointers-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());    // Sort the given array to find sum easily. It is useful in last two statements of for loop.\\n        int min_diff = INT_MAX;          // To store the difference of target and sum of three integers\\n        int ans = 0;                     // to store sum of three Integers\\n        for(int i =0; i < nums.size(); i++)\\n        {\\n            if((i>0) && nums[i] == nums[i-1]) continue;      // If there are copied values continue;\\n            int l = i+1, h = nums.size()-1;   // Take two pointers\\n            while(l < h)\\n            {\\n                int final_sum = nums[i]+nums[l]+nums[h];      \\n                if(final_sum == target){          \\n                    return target;\\n                }\\n                if(abs(final_sum - target) < min_diff){     //if the difference between new sum value and target is lesser than previous one\\n                    min_diff = abs(final_sum - target);     // Change the main difference value\\n                    ans = final_sum;        // Make ans = sum of three integers\\n                } \\n                if( l < h && final_sum > target) h--;         // If sum is greater than target decrease high pointer as it is making the sum greater than target\\n                else if(l < h && final_sum < target) l++;    // If sum is lesser than target increase low pointer as it is making the sum lesser than target;             \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if you find it useful.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());    // Sort the given array to find sum easily. It is useful in last two statements of for loop.\\n        int min_diff = INT_MAX;          // To store the difference of target and sum of three integers\\n        int ans = 0;                     // to store sum of three Integers\\n        for(int i =0; i < nums.size(); i++)\\n        {\\n            if((i>0) && nums[i] == nums[i-1]) continue;      // If there are copied values continue;\\n            int l = i+1, h = nums.size()-1;   // Take two pointers\\n            while(l < h)\\n            {\\n                int final_sum = nums[i]+nums[l]+nums[h];      \\n                if(final_sum == target){          \\n                    return target;\\n                }\\n                if(abs(final_sum - target) < min_diff){     //if the difference between new sum value and target is lesser than previous one\\n                    min_diff = abs(final_sum - target);     // Change the main difference value\\n                    ans = final_sum;        // Make ans = sum of three integers\\n                } \\n                if( l < h && final_sum > target) h--;         // If sum is greater than target decrease high pointer as it is making the sum greater than target\\n                else if(l < h && final_sum < target) l++;    // If sum is lesser than target increase low pointer as it is making the sum lesser than target;             \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319319,
                "title": "java-runtime-6ms-faster-than-99-65",
                "content": "When we add two mathematical properties, we can shorten the time to reach the target.\\n```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        if (nums.length == 3) {\\n            return nums[0] + nums[1] + nums[2];\\n        }\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int sum = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n - 2; i++) {\\n            //This means the smallest element with two biggest elements can\\'t satisfity the target. There is no need to move the right pointer.\\n            if (nums[i] + nums[n - 1] + nums[n - 2] < target) {\\n                sum = nums[i] + nums[n - 1] + nums[n - 2];\\n                continue;\\n            }\\n            //These three smallest elements in the sums are the closest elements to target. We can\\'t find another possible.\\n            if (nums[i] + nums[i + 1] + nums[i + 2] > target) {\\n                int temp = nums[i] + nums[i + 1] + nums[i + 2];\\n                if(Math.abs(sum - target) < Math.abs(temp - target)){\\n                    return sum;\\n                }else{\\n                    return temp;\\n                }\\n            }\\n            //The ordinary seek with three pointers.\\n            int left = i + 1;\\n            int right = n - 1;\\n            while (left < right) {\\n                int temp = nums[i] + nums[left] + nums[right];\\n                if (temp == target) {\\n                    return target;\\n                }\\n                if (temp < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                \\n                if(Math.abs(sum - target) >= Math.abs(temp - target)){\\n                    sum = temp;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/4e41cbb9-f0db-441d-bd5d-bb8847d546d1_1658521667.3858693.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        if (nums.length == 3) {\\n            return nums[0] + nums[1] + nums[2];\\n        }\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int sum = nums[0] + nums[1] + nums[2];\\n        for (int i = 0; i < n - 2; i++) {\\n            //This means the smallest element with two biggest elements can\\'t satisfity the target. There is no need to move the right pointer.\\n            if (nums[i] + nums[n - 1] + nums[n - 2] < target) {\\n                sum = nums[i] + nums[n - 1] + nums[n - 2];\\n                continue;\\n            }\\n            //These three smallest elements in the sums are the closest elements to target. We can\\'t find another possible.\\n            if (nums[i] + nums[i + 1] + nums[i + 2] > target) {\\n                int temp = nums[i] + nums[i + 1] + nums[i + 2];\\n                if(Math.abs(sum - target) < Math.abs(temp - target)){\\n                    return sum;\\n                }else{\\n                    return temp;\\n                }\\n            }\\n            //The ordinary seek with three pointers.\\n            int left = i + 1;\\n            int right = n - 1;\\n            while (left < right) {\\n                int temp = nums[i] + nums[left] + nums[right];\\n                if (temp == target) {\\n                    return target;\\n                }\\n                if (temp < target) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n                \\n                if(Math.abs(sum - target) >= Math.abs(temp - target)){\\n                    sum = temp;\\n                }\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2257327,
                "title": "c-n-2-two-pointer",
                "content": "\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint threeSumClosest(vector<int>& nums, int target) {\\n\\t\\t\\tlong long int sum = INT_MAX;\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tint n = nums.size();\\n\\n\\t\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\t\\tint j = i+1;\\n\\t\\t\\t\\tint k = n-1;\\n\\n\\t\\t\\t\\twhile(j < k) {\\n\\t\\t\\t\\t\\tint curr_sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\t\\t\\tif(curr_sum == target) return target;\\n\\t\\t\\t\\t\\telse if(curr_sum < target) j++;\\n\\t\\t\\t\\t\\telse k--;\\n\\t\\t\\t\\t\\tsum = abs(curr_sum - target) > abs(sum - target) ? sum : curr_sum;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint threeSumClosest(vector<int>& nums, int target) {\\n\\t\\t\\tlong long int sum = INT_MAX;\\n\\t\\t\\tsort(nums.begin(), nums.end());\\n\\t\\t\\tint n = nums.size();\\n\\n\\t\\t\\tfor(int i=0;i<n;i++) {\\n\\t\\t\\t\\tint j = i+1;\\n\\t\\t\\t\\tint k = n-1;\\n\\n\\t\\t\\t\\twhile(j < k) {\\n\\t\\t\\t\\t\\tint curr_sum = nums[i] + nums[j] + nums[k];\\n\\t\\t\\t\\t\\tif(curr_sum == target) return target;\\n\\t\\t\\t\\t\\telse if(curr_sum < target) j++;\\n\\t\\t\\t\\t\\telse k--;\\n\\t\\t\\t\\t\\tsum = abs(curr_sum - target) > abs(sum - target) ? sum : curr_sum;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2227280,
                "title": "python-solution-for-381-test-cases",
                "content": "I got around 960 ms runtime for this solution with 381 test cases. I tried to handle some edge cases such as if target is less than sum of first 3 digits and if target is greater than sum of last 3 digits.\\nMy solution:\\n```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        length = len(nums)\\n        closest_diff = 10000000\\n        closest_sum = 0\\n        nums.sort()\\n        if (x := sum(nums[:3])) >= target:\\n            return x\\n        if (x := sum(nums[-3:])) <= target:\\n            return x\\n        for left in range(length-2):\\n            if left > 0 and nums[left] == nums[left-1]:\\n                continue\\n            mid = left + 1\\n            right = length - 1\\n            while mid < right:\\n                curr_sum = nums[left] + nums[mid] + nums[right]\\n                diff = abs(target-curr_sum)\\n                if diff < closest_diff:\\n                    closest_diff = diff\\n                    closest_sum = curr_sum\\n                if curr_sum < target:\\n                    mid += 1\\n                elif curr_sum > target:\\n                    right -= 1\\n                else:\\n                    return target\\n        return closest_sum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        length = len(nums)\\n        closest_diff = 10000000\\n        closest_sum = 0\\n        nums.sort()\\n        if (x := sum(nums[:3])) >= target:\\n            return x\\n        if (x := sum(nums[-3:])) <= target:\\n            return x\\n        for left in range(length-2):\\n            if left > 0 and nums[left] == nums[left-1]:\\n                continue\\n            mid = left + 1\\n            right = length - 1\\n            while mid < right:\\n                curr_sum = nums[left] + nums[mid] + nums[right]\\n                diff = abs(target-curr_sum)\\n                if diff < closest_diff:\\n                    closest_diff = diff\\n                    closest_sum = curr_sum\\n                if curr_sum < target:\\n                    mid += 1\\n                elif curr_sum > target:\\n                    right -= 1\\n                else:\\n                    return target\\n        return closest_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183372,
                "title": "go-o-n-2-clean-with-explanation",
                "content": "```\\nfunc threeSumClosest(nums []int, target int) int {\\n    if len(nums) < 3 {return -1}\\n    \\n    sort.Ints(nums)\\n    smallestDiff := 1 << 31\\n    \\n    for i := 0; i < len(nums) - 2; i++ {\\n        left, right := i + 1, len(nums) - 1\\n        \\n        for left < right {\\n            diff := target - nums[i] - nums[left] - nums[right]\\n            if diff == 0 {return target}\\n            \\n            if abs(diff) < abs(smallestDiff) || (abs(diff) == abs(smallestDiff) && diff > smallestDiff) {\\n                smallestDiff = diff\\n            }\\n            \\n            if diff > 0 {\\n                left++\\n            } else {\\n                right--\\n            }\\n        }\\n    }\\n    \\n    return target - smallestDiff\\n}\\n\\nfunc abs(x int) int {\\n    if x > 0 {\\n        return x\\n    }\\n    \\n    return -x\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc threeSumClosest(nums []int, target int) int {\\n    if len(nums) < 3 {return -1}\\n    \\n    sort.Ints(nums)\\n    smallestDiff := 1 << 31\\n    \\n    for i := 0; i < len(nums) - 2; i++ {\\n        left, right := i + 1, len(nums) - 1\\n        \\n        for left < right {\\n            diff := target - nums[i] - nums[left] - nums[right]\\n            if diff == 0 {return target}\\n            \\n            if abs(diff) < abs(smallestDiff) || (abs(diff) == abs(smallestDiff) && diff > smallestDiff) {\\n                smallestDiff = diff\\n            }\\n            \\n            if diff > 0 {\\n                left++\\n            } else {\\n                right--\\n            }\\n        }\\n    }\\n    \\n    return target - smallestDiff\\n}\\n\\nfunc abs(x int) int {\\n    if x > 0 {\\n        return x\\n    }\\n    \\n    return -x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2138304,
                "title": "simple-c-solution-using-two-pointer",
                "content": "```\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int sum=0;\\n        int ans=nums[0]+nums[1]+nums[2];\\n        for(int i=0;i<n;i++){\\n            int l=i+1,r=n-1;\\n            while(l<r){\\n                sum=nums[i]+nums[l]+nums[r];\\n                if(sum==target){\\n                    ans=target;\\n                    return ans;\\n                }\\n                else if(sum<target){\\n                    if(abs(target-ans)>abs(target-sum)){\\n                        ans=sum;\\n                    }\\n                    l++;\\n                }\\n                else{\\n                    if(abs(target-ans)>abs(target-sum)){\\n                        ans=sum;\\n                    }\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int sum=0;\\n        int ans=nums[0]+nums[1]+nums[2];\\n        for(int i=0;i<n;i++){\\n            int l=i+1,r=n-1;\\n            while(l<r){\\n                sum=nums[i]+nums[l]+nums[r];\\n                if(sum==target){\\n                    ans=target;\\n                    return ans;\\n                }\\n                else if(sum<target){\\n                    if(abs(target-ans)>abs(target-sum)){\\n                        ans=sum;\\n                    }\\n                    l++;\\n                }\\n                else{\\n                    if(abs(target-ans)>abs(target-sum)){\\n                        ans=sum;\\n                    }\\n                    r--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2137805,
                "title": "javascript-solution",
                "content": "\\tvar threeSumClosest = function(nums, tar) {\\n\\t   let closest=Infinity;\\n\\tnums= nums.sort((a,b)=> {return a-b})\\n\\tfor (let i = 0; i < nums.length-2; i++) {\\n\\t\\t\\tlet  a=i+1,b=nums.length-1;\\n\\t\\t\\twhile(a<b){\\n\\t\\t\\t\\t\\t  let target =nums[i]+nums[a]+nums[b];  \\n\\t\\t\\t\\t\\t  if(Math.abs(target - tar) < Math.abs(closest - tar))closest=target;\\n\\t\\t\\t\\t\\t  (target<tar)? a++:b--               \\n\\t\\t\\t} \\n\\t}\\n\\t\\treturn closest; \\n\\t};",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "\\tvar threeSumClosest = function(nums, tar) {\\n\\t   let closest=Infinity;\\n\\tnums= nums.sort((a,b)=> {return a-b})\\n\\tfor (let i = 0; i < nums.length-2; i++) {\\n\\t\\t\\tlet  a=i+1,b=nums.length-1;\\n\\t\\t\\twhile(a<b){\\n\\t\\t\\t\\t\\t  let target =nums[i]+nums[a]+nums[b];  \\n\\t\\t\\t\\t\\t  if(Math.abs(target - tar) < Math.abs(closest - tar))closest=target;\\n\\t\\t\\t\\t\\t  (target<tar)? a++:b--               \\n\\t\\t\\t} \\n\\t}\\n\\t\\treturn closest; \\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2133259,
                "title": "best-solution-fastest-easy-efficient-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int ans = nums[0] + nums[1] + nums[2];\\n        int closest = abs(target-ans);\\n         for(int i = 0 ; i< nums.size() ; i++){\\n             int start = i+1;\\n             int end = nums.size()-1;\\n             while(start<end){\\n                int sum = nums[start]+ nums[end] + nums[i];\\n                 if(sum == target){\\n                     return sum;\\n                 }\\n                 else if(sum>target ){\\n                     int temp =abs(target-sum);\\n                     if(temp<closest){\\n                         closest = temp;\\n                         ans = sum;\\n                     }\\n                     end--;\\n                 }\\n                 else{\\n                    int temp =abs(target-sum);\\n                     if(temp<closest){\\n                         closest = temp;\\n                         ans = sum;\\n                     }\\n                     start++;\\n                 }\\n             }\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());\\n        int ans = nums[0] + nums[1] + nums[2];\\n        int closest = abs(target-ans);\\n         for(int i = 0 ; i< nums.size() ; i++){\\n             int start = i+1;\\n             int end = nums.size()-1;\\n             while(start<end){\\n                int sum = nums[start]+ nums[end] + nums[i];\\n                 if(sum == target){\\n                     return sum;\\n                 }\\n                 else if(sum>target ){\\n                     int temp =abs(target-sum);\\n                     if(temp<closest){\\n                         closest = temp;\\n                         ans = sum;\\n                     }\\n                     end--;\\n                 }\\n                 else{\\n                    int temp =abs(target-sum);\\n                     if(temp<closest){\\n                         closest = temp;\\n                         ans = sum;\\n                     }\\n                     start++;\\n                 }\\n             }\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989154,
                "title": "java-two-pointers-solution",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        \\n        int closest = nums[0] + nums[1] + nums[2];\\n        \\n        Arrays.sort(nums);\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            \\n            int l = i+1, r = nums.length - 1;\\n            \\n            while(l < r) {\\n                \\n                int threeSum = nums[i] + nums[l] + nums[r];\\n                \\n                if(threeSum > target)\\n                    r--;\\n                \\n                else\\n                    l++;\\n                \\n                if(Math.abs(threeSum - target) < Math.abs(closest - target))\\n                    closest = threeSum;\\n            }\\n        }\\n        \\n        return closest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        \\n        int closest = nums[0] + nums[1] + nums[2];\\n        \\n        Arrays.sort(nums);\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            \\n            int l = i+1, r = nums.length - 1;\\n            \\n            while(l < r) {\\n                \\n                int threeSum = nums[i] + nums[l] + nums[r];\\n                \\n                if(threeSum > target)\\n                    r--;\\n                \\n                else\\n                    l++;\\n                \\n                if(Math.abs(threeSum - target) < Math.abs(closest - target))\\n                    closest = threeSum;\\n            }\\n        }\\n        \\n        return closest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985131,
                "title": "clean-python-solution-self-explained-easy-to-understand",
                "content": "```python\\n\"\"\"\\nTime: O(N^2)\\nSpace: O(1)\\n\"\"\"\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        N = len(nums)\\n        ans = float(\\'inf\\')\\n        \\n        for i in range(N):\\n            j = i+1\\n            k = N-1\\n            \\n            while j<k:\\n                total = nums[i]+nums[j]+nums[k]\\n                if total==target: return total\\n                if abs(target-ans)>abs(target-total): ans = total\\n\\t\\t\\t\\t\\n                if total>target:\\n                    k -= 1\\n                elif total<target:\\n                    j += 1\\n        return ans\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nTime: O(N^2)\\nSpace: O(1)\\n\"\"\"\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        \\n        N = len(nums)\\n        ans = float(\\'inf\\')\\n        \\n        for i in range(N):\\n            j = i+1\\n            k = N-1\\n            \\n            while j<k:\\n                total = nums[i]+nums[j]+nums[k]\\n                if total==target: return total\\n                if abs(target-ans)>abs(target-total): ans = total\\n\\t\\t\\t\\t\\n                if total>target:\\n                    k -= 1\\n                elif total<target:\\n                    j += 1\\n        return ans\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957202,
                "title": "c-easy-to-understand-solution-o-n-2-two-pointer",
                "content": "***Please upvote if you find the solution helpful to keep me motivated. : )***\\n```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());         //sorting the elements\\n        \\n        int l, r, f=0, ans;\\n        for(int i=0;i<nums.size();i++)\\n        {  \\n\\t\\t    //making one element fixed and setting a target for other two elements\\n\\t\\t\\t// a + b + c = target    ->    a + b = target - c = t\\n            int t = target - nums[i];              \\n\\t\\t\\t\\n\\t\\t\\t//considering all elements after the current one because if we\\'ll take all elements then many operations will be repeated\\n            l=i+1; r=nums.size()-1;\\n            int sum = 0;\\n            \\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[r];         //sum of two elements\\n                \\n\\t\\t\\t\\t//update the ans if current closet of 3 elements make the sum nearest to target than previous ans \\n                if(abs(target - sum - nums[i]) < abs(target - ans))\\n                        ans=sum+nums[i];\\n                \\n                if(sum==t)        //we get the sum = target, hence no need to proceed further\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                else if(sum > t)     //if sum is greater than target then move right pointer 1 step back\\n                    r--;\\n                else                      //if sum is smaller then move left pointer 1 step ahead\\n                    l++;\\n            }\\n            \\n            if(f)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(),nums.end());         //sorting the elements\\n        \\n        int l, r, f=0, ans;\\n        for(int i=0;i<nums.size();i++)\\n        {  \\n\\t\\t    //making one element fixed and setting a target for other two elements\\n\\t\\t\\t// a + b + c = target    ->    a + b = target - c = t\\n            int t = target - nums[i];              \\n\\t\\t\\t\\n\\t\\t\\t//considering all elements after the current one because if we\\'ll take all elements then many operations will be repeated\\n            l=i+1; r=nums.size()-1;\\n            int sum = 0;\\n            \\n            while(l<r)\\n            {\\n                sum=nums[l]+nums[r];         //sum of two elements\\n                \\n\\t\\t\\t\\t//update the ans if current closet of 3 elements make the sum nearest to target than previous ans \\n                if(abs(target - sum - nums[i]) < abs(target - ans))\\n                        ans=sum+nums[i];\\n                \\n                if(sum==t)        //we get the sum = target, hence no need to proceed further\\n                {\\n                    f=1;\\n                    break;\\n                }\\n                else if(sum > t)     //if sum is greater than target then move right pointer 1 step back\\n                    r--;\\n                else                      //if sum is smaller then move left pointer 1 step ahead\\n                    l++;\\n            }\\n            \\n            if(f)\\n                break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955777,
                "title": "clean-commented-java-solution",
                "content": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        // insert any value in nearest\\n        // it will get corrected in the end\\n        int nearest = nums[0] + nums[1] + nums[2];\\n        \\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int lo = i + 1;\\n            int hi = nums.length - 1;\\n                \\n            while (lo < hi) {\\n                int sum = nums[i] + nums[lo] + nums[hi];\\n                if (sum == target) return target;\\n\\n                // need to inc val as on lo-- it will keep going farther\\n                if (sum < target) lo++;\\n                // similar for hi\\n                else hi--;\\n\\n                // compare abs diff and update result\\n                if (Math.abs(sum - target) < Math.abs(nearest - target))\\n                    nearest = sum;\\n            }\\n        }\\n        return nearest;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int threeSumClosest(int[] nums, int target) {\\n        Arrays.sort(nums);\\n        // insert any value in nearest\\n        // it will get corrected in the end\\n        int nearest = nums[0] + nums[1] + nums[2];\\n        \\n        for (int i = 0; i < nums.length - 2; i++) {\\n            int lo = i + 1;\\n            int hi = nums.length - 1;\\n                \\n            while (lo < hi) {\\n                int sum = nums[i] + nums[lo] + nums[hi];\\n                if (sum == target) return target;\\n\\n                // need to inc val as on lo-- it will keep going farther\\n                if (sum < target) lo++;\\n                // similar for hi\\n                else hi--;\\n\\n                // compare abs diff and update result\\n                if (Math.abs(sum - target) < Math.abs(nearest - target))\\n                    nearest = sum;\\n            }\\n        }\\n        return nearest;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619838,
                "title": "python-3-pointer-solution-simple-explanation-96-faster-96-ms",
                "content": "![image](https://assets.leetcode.com/users/images/5c780459-a159-4be4-978c-72a4ec4609ab_1639058651.4989543.png)\\nFix one of the pointers at index `i` then do the typical two-sum problem with indices `j` and `k` on the remaining elements that is not at index `i`. After `i` loops through the entire array once or when you find a difference of `0`, then you have the 3sum solution.\\n```\\nclass Solution:\\n    def threeSumClosest(self, A: List[int], target: int) -> int:\\n        A = sorted(A)\\n        smallestDiff = 10001\\n        closestSum = 0\\n        \\n        for i in range(len(A)-2):\\n            j = i + 1\\n            k = len(A) - 1\\n            \\n            while j < k:\\n                threeSum = A[i] + A[j] + A[k]\\n                \\n                if abs(threeSum - target) < smallestDiff:\\n                    smallestDiff = abs(threeSum - target)\\n                    closestSum = threeSum\\n                    \\n                if threeSum < target:\\n                    j += 1\\n                elif threeSum > target:\\n                    k -= 1\\n                else:\\n                    return threeSum\\n                \\n        return closestSum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, A: List[int], target: int) -> int:\\n        A = sorted(A)\\n        smallestDiff = 10001\\n        closestSum = 0\\n        \\n        for i in range(len(A)-2):\\n            j = i + 1\\n            k = len(A) - 1\\n            \\n            while j < k:\\n                threeSum = A[i] + A[j] + A[k]\\n                \\n                if abs(threeSum - target) < smallestDiff:\\n                    smallestDiff = abs(threeSum - target)\\n                    closestSum = threeSum\\n                    \\n                if threeSum < target:\\n                    j += 1\\n                elif threeSum > target:\\n                    k -= 1\\n                else:\\n                    return threeSum\\n                \\n        return closestSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1609485,
                "title": "c-similar-to-3sum",
                "content": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int ans=INT_MAX,diff=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            if(i>0 and nums[i]==nums[i-1])continue;\\n            int j=i+1,k=n-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(abs(sum-target)<diff){\\n                    diff=abs(sum-target);\\n                    ans=sum;\\n                }\\n                \\n                if(sum==target){\\n                    return sum;\\n                }\\n                else if(sum>target)k--;\\n                else j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int n=nums.size();\\n        int ans=INT_MAX,diff=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            if(i>0 and nums[i]==nums[i-1])continue;\\n            int j=i+1,k=n-1;\\n            while(j<k){\\n                int sum=nums[i]+nums[j]+nums[k];\\n                if(abs(sum-target)<diff){\\n                    diff=abs(sum-target);\\n                    ans=sum;\\n                }\\n                \\n                if(sum==target){\\n                    return sum;\\n                }\\n                else if(sum>target)k--;\\n                else j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546228,
                "title": "simple-to-understand-using-2-pointer-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n```\\npublic class Solution {\\n    public int ThreeSumClosest(int[] nums, int target) { \\n        var result = 0;\\n        \\n        // Keep track of the solution closest to the target\\n        var closestDifference = int.MaxValue;        \\n        \\n        // Sort the array\\n        Array.Sort(nums);\\n        \\n        // Loop through numbers\\n        for (int index = 0; index < nums.Length; ++index) {     \\n            // Skip duplicates\\n            if (index > 0 && nums[index] == nums[index - 1]) {\\n                continue;\\n            }\\n            \\n            // Find 3 sum combination closest to the target value\\n            var startIndex = index + 1;\\n            var endIndex = nums.Length - 1;\\n            while (startIndex < endIndex) {\\n                // Get the sum\\n                var sum = nums[index] + nums[startIndex] + nums[endIndex];\\n                \\n                // Determine how close the sum is to the target value\\n                var difference = Math.Abs(target - sum);\\n                if (difference < closestDifference) {\\n                    closestDifference = difference;\\n                    result = sum;\\n                }\\n                \\n                // An exact match is found, exit\\n                if (difference == 0) {\\n                    break;\\n                    \\n                // Sum is less than target\\n                } else if (sum < target) {                \\n                    ++startIndex;\\n                    \\n                // Sum is greater than target\\n                } else {               \\n                    --endIndex;\\n                }                 \\n            }\\n            \\n            // An exact match is found, exit\\n            if (closestDifference == 0) {\\n                break;\\n            }\\n        }\\n                \\n        return result;\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int ThreeSumClosest(int[] nums, int target) { \\n        var result = 0;\\n        \\n        // Keep track of the solution closest to the target\\n        var closestDifference = int.MaxValue;        \\n        \\n        // Sort the array\\n        Array.Sort(nums);\\n        \\n        // Loop through numbers\\n        for (int index = 0; index < nums.Length; ++index) {     \\n            // Skip duplicates\\n            if (index > 0 && nums[index] == nums[index - 1]) {\\n                continue;\\n            }\\n            \\n            // Find 3 sum combination closest to the target value\\n            var startIndex = index + 1;\\n            var endIndex = nums.Length - 1;\\n            while (startIndex < endIndex) {\\n                // Get the sum\\n                var sum = nums[index] + nums[startIndex] + nums[endIndex];\\n                \\n                // Determine how close the sum is to the target value\\n                var difference = Math.Abs(target - sum);\\n                if (difference < closestDifference) {\\n                    closestDifference = difference;\\n                    result = sum;\\n                }\\n                \\n                // An exact match is found, exit\\n                if (difference == 0) {\\n                    break;\\n                    \\n                // Sum is less than target\\n                } else if (sum < target) {                \\n                    ++startIndex;\\n                    \\n                // Sum is greater than target\\n                } else {               \\n                    --endIndex;\\n                }                 \\n            }\\n            \\n            // An exact match is found, exit\\n            if (closestDifference == 0) {\\n                break;\\n            }\\n        }\\n                \\n        return result;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1542595,
                "title": "very-easy-js-solution",
                "content": "TC: O(N*N)\\nSC: O(1)\\n\\n```\\nvar threeSumClosest = function(A, target) {\\n    A.sort((a, b) => a - b);\\n    \\n    let closestSum = 0;\\n    let minSoFar = Infinity;\\n\\n    for(let i = 0; i <A.length -2; i++) {\\n        let j = i + 1;\\n        let k = A.length - 1;\\n        \\n        while(j < k) {\\n            const sum = A[i] + A[j] + A[k];\\n            \\n            const diff = Math.abs(sum - target);\\n\\t\\t\\t//If minimum is found, update it in \"minSoFar\".\\n            if (diff < minSoFar) {\\n                minSoFar = diff;\\n                closestSum = sum;\\n            } \\n            \\n            if(sum < target) {\\n               j++;\\n             } else {\\n                k--;\\n            }\\n        }\\n    }\\n    \\n    return closestSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar threeSumClosest = function(A, target) {\\n    A.sort((a, b) => a - b);\\n    \\n    let closestSum = 0;\\n    let minSoFar = Infinity;\\n\\n    for(let i = 0; i <A.length -2; i++) {\\n        let j = i + 1;\\n        let k = A.length - 1;\\n        \\n        while(j < k) {\\n            const sum = A[i] + A[j] + A[k];\\n            \\n            const diff = Math.abs(sum - target);\\n\\t\\t\\t//If minimum is found, update it in \"minSoFar\".\\n            if (diff < minSoFar) {\\n                minSoFar = diff;\\n                closestSum = sum;\\n            } \\n            \\n            if(sum < target) {\\n               j++;\\n             } else {\\n                k--;\\n            }\\n        }\\n    }\\n    \\n    return closestSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1402681,
                "title": "3sum-closest-two-pointers-python3",
                "content": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        minDiff = 4001\\n        minSum = sum(nums[:3])\\n        for i in range(n-2):\\n            l=i+1\\n            r=n-1\\n            while l<r:\\n                currSum = nums[i]+nums[l]+nums[r]\\n                if currSum > target:r-=1\\n                elif currSum == target: return currSum\\n                else: l+=1\\n                    \\n                if minDiff>abs(currSum-target):\\n                    minDiff = abs(currSum-target)\\n                    minSum = currSum\\n        return minSum\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def threeSumClosest(self, nums: List[int], target: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        minDiff = 4001\\n        minSum = sum(nums[:3])\\n        for i in range(n-2):\\n            l=i+1\\n            r=n-1\\n            while l<r:\\n                currSum = nums[i]+nums[l]+nums[r]\\n                if currSum > target:r-=1\\n                elif currSum == target: return currSum\\n                else: l+=1\\n                    \\n                if minDiff>abs(currSum-target):\\n                    minDiff = abs(currSum-target)\\n                    minSum = currSum\\n        return minSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366055,
                "title": "3sum-closest-easy-to-understand-c",
                "content": "Store all possible sum and then find the answer\\'s index using upperbound.\\nTime Complexity O(n^2)\\nwhere n = size of the nums vector.\\n\\nclass Solution {\\npublic:\\nint threeSumClosest(vector<int>& nums, int target) {\\n\\n    vector<int>store;\\n    sort(nums.begin(),nums.end());\\t\\t\\n    for(int i=0;i<nums.size();i++){\\n        int first = nums[i];\\n        int low = i+1;\\n        int high = nums.size()-1;\\n        while(low<high){\\n            int sum = nums[low]+nums[high]+first;\\n            store.push_back(sum);\\n            if(sum<target) low++;\\n            else high--;\\n        }\\n    }\\n    sort(store.begin(),store.end());\\n    int ind = upper_bound(store.begin(),store.end(),target)-store.begin();\\n\\t\\n    if(ind==store.size())  return store[ind-1];\\n    if(ind==0) return store[0];\\n    int dif1 = abs(store[ind]-target);\\n    int dif2 = abs(target-store[ind-1]);\\n    if(min(dif1,dif2)==dif1) return store[ind];\\n    return store[ind-1];\\n}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\nint threeSumClosest(vector<int>& nums, int target) {\\n\\n    vector<int>store;\\n    sort(nums.begin(),nums.end());\\t\\t\\n    for(int i=0;i<nums.size();i++){\\n        int first = nums[i];\\n        int low = i+1;\\n        int high = nums.size()-1;\\n        while(low<high){\\n            int sum = nums[low]+nums[high]+first;\\n            store.push_back(sum);\\n            if(sum<target) low++;\\n            else high--;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575345,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1572344,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1571044,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1567805,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1572237,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1803731,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1636149,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1574774,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1575058,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1786501,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1575345,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1572344,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1571044,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1567805,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1572237,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1803731,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1636149,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1574774,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1575058,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1786501,
                "content": [
                    {
                        "username": "porwalu",
                        "content": "What does closest to target specify.\\ne.g. for this input-\\n[-1,-1,2,4]\\n1 -- target\\nShould the closest be 0 or 2"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Test Case Invalid!\\n\"You may assume that each input would have exactly one solution\".\\n\\nBut if allowed both should pass the testcase.\\nYou can try: Return the Closest target(s) in an array for all possible combinations. "
                    },
                    {
                        "username": "eliuttth-dev",
                        "content": "Taking this input \"You may assume that each input would have exactly one solution and Return the sum of the three integers.\" so, thats means\\nthe two possible sums are 0 === (-1 + -1 + 2)  and 5 === (-1 + 2 + 4).\\n\\nso assuming that each input would have exactly one solution we have that the closest number is actually 0 \\'cause u have a diference of 1 but with 5 the diference is 4. basically u need just one closest number solution no 2 like this case, in my case, i iterated one index per time until get the end of the array, like [-1,-1,2] => [-1,2,4]."
                    },
                    {
                        "username": "Deep_down",
                        "content": "we can take anyone of them.\\n"
                    },
                    {
                        "username": "sambhavkaushik376",
                        "content": "you can assume any of answer to be correct"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "2 will clear the testcase.\\nQuestion says there will be exactly one solution so there should not be cases like this or it should have mentioned about taking the greater value in these cases . "
                    },
                    {
                        "username": "vandelaay",
                        "content": "\"You may assume that each input would have exactly one solution.\"\\n\\nSince both 0 and 2 are valid solution, the testcase would not be valid for this question."
                    },
                    {
                        "username": "utopian_coder",
                        "content": "0 ig"
                    },
                    {
                        "username": "fantasyfish667",
                        "content": "If the target is 1, we have two solutions 0 and 2. Which should we pick?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "You may assume that each input would have exactly one solution"
                    },
                    {
                        "username": "vian_thaku_r",
                        "content": "you can\\'t get 0 in the test case\\n"
                    },
                    {
                        "username": "prince1724",
                        "content": "[@ManjeetYdv](/ManjeetYdv) \\uD83D\\uDE02\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "ManjeetYdv",
                        "content": "Pick 2 to pass the testcase ."
                    },
                    {
                        "username": "pgkr98",
                        "content": "Even, I have the same doubt., but it was mentioned in the question to assume that there is only one valid solution."
                    },
                    {
                        "username": "rabeeh",
                        "content": "I got the wrong answer for this testcase:\\n\\n    Input: [1,1,1,0], -100\\n    Output: 3\\n    Expected: 2 \\n\\nto me the output is correct as  diff= fabs(-100+3)=97 which is smaller than diff=fabs(-100+2)=98 to me closeness means having the absolute difference smaller.  So what does closeness mean here?"
                    },
                    {
                        "username": "s_sneh",
                        "content": "miss, absolute diff is not abs(a+b), rather its abs(a-b). SILLY (<-;)"
                    },
                    {
                        "username": "gkucmierz",
                        "content": "How is that possible, that you solved 39 hard problems, and you can\\'t do simple subtraction."
                    },
                    {
                        "username": "pappupandit852151",
                        "content": "[@Codingchamp_23](/Codingchamp_23)  you should to substract abs(-100-2) = 102 "
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "[@meozdemir](/meozdemir) yes"
                    },
                    {
                        "username": "meozdemir",
                        "content": "Diff is a-b, not a+b, so fabs(-100-2) is smaller than fabs(-100-3)"
                    },
                    {
                        "username": "bluething",
                        "content": "if this was an interview, then I have just blackboxed FFT to solve this in n log n + n time. Did anybody actually implement this, so I can take a peep at it?"
                    },
                    {
                        "username": "saitejapln",
                        "content": "[@Amal_Dubey](/Amal_Dubey) fast fourier transform, which is used for signal filtering. Not sure, how it is relevant here"
                    },
                    {
                        "username": "Amal_Dubey",
                        "content": "What is FFT??\\n"
                    },
                    {
                        "username": "yosief1",
                        "content": "would also love to know"
                    },
                    {
                        "username": "stevenzhang0",
                        "content": "Is it a variation on sliding window or is a greedy algo?"
                    },
                    {
                        "username": "koolfy",
                        "content": "[@piyush0004](/piyush0004) I fell head first into that intuition as well. After many hours trying to find the fault in the code, I found it in my initial logic.\n\nIt cannot be a binary search approach, as I am now understanding that either a binary search yields a result (the exact item you look for is found), or you have garbage in your hands that is not guaranteed to be the closest candidate to your target in the tree.\n\nThis could work in a greedy algorithm, but this problem requires exact solutions.\n\nIt's actually easy to see:\n\n             6\n           /   \\\n         -5     9\n        /   \\\n      -9     2\n           /   \\\n         -3     5\n\nas far as I can tell, this is a perfectly valid binary search tree.\n\nHowever, if I'm looking for the value \"3\", I will likely never get a binary search implementation that will always give me the closest result.\n\nThis is in because the closest result might actually NOT be at a leaf.\nWhen traversing the tree, at one level we might get closer to the target value, and then get way further, then wildly get back very close, and at the last level get a lot further. This is especially true when values are very different and far apart.\n\nIt stems from the fact that a binary search looks for \"bigger/smaller\" on child nodes, but never takes distance into account. If you try tweaking it to take distance-to-target into account instead of \"bigger/smaller\", you broke the binary search approach, and you will not be able to overcome the problem of \"do I need to traverse down the children, or am I better off returning the current node if both children get me further away from the target?\"\n\nIn the example binary search tree, we see that in that case we would never traverse past the first root node, because going to -5 or 9 would get me further away from 3 than staying at 6. This would be a mistake as I would have no way of knowing that a closer candidate \"2\" lives further down. And it is absolutely not a leaf either. So the binary search would get me nowhere at all.\n\nThere is no proximity relationship to be found on a binary search tree for \"non-exact-matches\", and no such relationship between levels… and I must now accept that I realized this only after finishing a full implementation…\n\nBetter now than at the interview, I guess ;)\n\nEDIT:\naaaaaaaand I'm actually both correct but reaching the wrong conclusion.\n\nTurns out, for this problem, while the binary search won't give us the closest approach when it concludes, its traversal will still give us a O(log n) short list of candidates of which we can simply pick the closest.\n\nIt's not immediate but it's not entirely useless.\nStill, it requires a n² preparation so it's not the fastest approach."
                    },
                    {
                        "username": "Codingchamp_23",
                        "content": "it can be solved using two-pointers. In that case, time complexity will be O(nlogn)."
                    },
                    {
                        "username": "piyush0004",
                        "content": "i think its binary search approach"
                    },
                    {
                        "username": "niknov",
                        "content": "what do you think guys, what is closest to target result in this case?\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2"
                    },
                    {
                        "username": "rna_0004",
                        "content": "[@itsjayant](/itsjayant) as you got 0 from the upper limit , there is no need to get 3!\\n"
                    },
                    {
                        "username": "PradhumnJadhav",
                        "content": "-2\\n"
                    },
                    {
                        "username": "sfatektas",
                        "content": "[@itsthejayant](/itsthejayant) \\nwhy we didn\\'t take -4 "
                    },
                    {
                        "username": "itsjayant",
                        "content": "-2 can be closet [0,-5,3]"
                    },
                    {
                        "username": "still2095",
                        "content": "the keyword is the sum not a number"
                    },
                    {
                        "username": "Woors",
                        "content": "TLE Python folks... switch to C instead"
                    },
                    {
                        "username": "yancyYancy",
                        "content": "![image](https://assets.leetcode.com/users/images/c54fa3e1-8372-4a69-aeed-e4b293e35678_1609887292.874328.png)\\n\\n"
                    },
                    {
                        "username": "shourjya_chakraborty000",
                        "content": "Line 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000090 overflowed to 0x60200000008c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:34"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@SILICON-HAWK](/SILICON-HAWK) don\\'t use int .. use long long .. this occured cause you added a bigger value in vector int memory and that value overflowed causing dataloss"
                    },
                    {
                        "username": "SILICON-HAWK",
                        "content": "mate i have been getting the same error in some other problem, idk what the problem here is either, when i complie and run it on my system it works perfectly fine, no error or warning, but on LC it fails to do anything, i have tried many thing but cant seem to find the issue, i hope someone kind enough to explain would tell me what and how to fix it. "
                    },
                    {
                        "username": "HelenaBond",
                        "content": "\nAnyone who is going to solve this problem. Pay attention to the limits for the array values."
                    }
                ]
            },
            {
                "id": 1744801,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1729330,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 2017604,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 2010783,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1946972,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1838611,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1749948,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1746883,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1733038,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 1576653,
                "content": [
                    {
                        "username": "drash99",
                        "content": "Python3 n^2 log n with little optimization solution accepted\\nMay need stronger testcases"
                    },
                    {
                        "username": "austinsparky1",
                        "content": "lmao, that\\'s the type of solution I have now and I\\'ve been getting consistent TLE\\'s -- if only I did this problem earlier "
                    },
                    {
                        "username": "maxmustermann",
                        "content": "can someone please explain why sorting is necessary for the two pointer solution?"
                    },
                    {
                        "username": "Normal_Coder",
                        "content": "It helps for the increment of left and decrement of right pointers. If the sum is less then incrementing left pointer in a sorted array  guarantees you to get higher sum than the previous sum and if the sum is more then decrementing the right pointer helps you  to get lower sum than the previous one.\\nThis is why we set the left to second element and and right to last element. The same approach can be used in container with most water problem. \\nThis is not possible in an unsorted array"
                    },
                    {
                        "username": "adrian_marcelo",
                        "content": "Huge tip: I think you should solve 3Sum before this one. It will help a lot"
                    },
                    {
                        "username": "vishal_donda",
                        "content": "Does this include duplicates or not??"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am i dumb? or everyone looked at the answer?\\n"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "nums =\\n[4,0,5,-5,3,3,0,-4,-5]\\ntarget =\\n-2\\nUse Testcase\\nOutput\\n-1\\nExpected\\n-2\\nthe above test case is wrong we can not find -2 but we can find closet -1 but compiler give wrong answer\\n "
                    },
                    {
                        "username": "manasi2510",
                        "content": "[@gulllak](/gulllak) But 0, -5, 3  are not in sequence, so we have to use combination here?"
                    },
                    {
                        "username": "Deep_anshu7",
                        "content": "[@gulllak](/gulllak)  but there is double 3\\n"
                    },
                    {
                        "username": "gulllak",
                        "content": "0, -5, 3 = -2"
                    },
                    {
                        "username": "yaduwanshib650",
                        "content": "my code for this question giving TLE.. how can i improve it??\\n int threeSumClosest(vector<int>& nums, int target) {\\n        sort(nums.begin(), nums.end());\\n        int closestsum=1000000000;\\n        for(int i =0 ; nums.size()-2; i++){\\n            int low = i+1;\\n            int high = nums.size()-1;\\n            while(low<high){\\n                int sum =nums[i]+nums[low]+nums[high];\\n            if(sum==target) return sum;\\n            if(abs(target-sum)< abs(target-closestsum)){\\n                closestsum = sum;\\n            }\\n            else if(sum>target)high--;\\n            else low++;\\n\\n            }\\n        }\\n        return closestsum;\\n    }"
                    },
                    {
                        "username": "vaishali_p14",
                        "content": "I did the same thing but I didn\\'t get TLE...\\uD83D\\uDE05\\uD83E\\uDD14"
                    },
                    {
                        "username": "Viacheslav1985",
                        "content": "I have got this:\\nTime Limit Exceeded\\n98 / 98 testcases passed\\nLast Executed Input\\nnums =\\n\\nWhat does it mean ?"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "It means, you passed all test cases individually but total time of all test cases is more than expected."
                    },
                    {
                        "username": "dhruvpatel0401",
                        "content": "=================================================================\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000000500 at pc 0x000000346525 bp 0x7ffeed331a50 sp 0x7ffeed331a48\nREAD of size 4 at 0x602000000500 thread T0\n    #2 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\n0x602000000500 is located 0 bytes to the right of 16-byte region [0x6020000004f0,0x602000000500)\nallocated by thread T0 here:\n    #6 0x7fcda90e20b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\nShadow bytes around the buggy address:\n  0x0c047fff8050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8060: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c047fff8070: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\n  0x0c047fff8080: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\n  0x0c047fff8090: fa fa fd fa fa fa fd fa fa fa fd fa fa fa 00 00\n=>0x0c047fff80a0:[fa]fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80d0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80e0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c047fff80f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\nShadow byte legend (one shadow byte represents 8 application bytes):\n  Addressable:           00\n  Partially addressable: 01 02 03 04 05 06 07 \n  Heap left redzone:       fa\n  Freed heap region:       fd\n  Stack left redzone:      f1\n  Stack mid redzone:       f2\n  Stack right redzone:     f3\n  Stack after return:      f5\n  Stack use after scope:   f8\n  Global redzone:          f9\n  Global init order:       f6\n  Poisoned by user:        f7\n  Container overflow:      fc\n  Array cookie:            ac\n  Intra object redzone:    bb\n  ASan internal:           fe\n  Left alloca redzone:     ca\n  Right alloca redzone:    cb\n  Shadow gap:              cc\n==34==ABORTING\n\n\n\n\n\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        sort(nums.begin(),nums.end());\n\n        int comp=INT_MAX,n=nums.size(),res=0;\n        \n        for(int i=0; i<n-2; i++)\n        {\n            int j = i+1, k = n-1;\n\n            while(j<k)\n            {\n                int sum = nums[i]+nums[j]+nums[k];\n                if(comp > abs(sum-target))\n                {\n                    comp = abs(sum-target);\n                    res = sum;\n                }\n\n                if(sum < target)\n                {\n                    j++;\n                }\n                else if(sum > target)\n                {\n                    k--;\n                }\n                else\n                {\n                    return res;\n                }\n            }\n            while(nums[i+1] == nums[i] && i+1 < n) i++;\n        }\n        return res;\n    }\n};\n\n\nWhy am I getting this error?"
                    },
                    {
                        "username": "Himanshu_Singh11",
                        "content": "same error"
                    },
                    {
                        "username": "COdeGun007",
                        "content": "https://www.nileshblog.tech/2022/04/21/leet-code-median-of-two-sorted-arrays-using-c-java-javascript-c-python-%ef%bf%bc%ef%bf%bc/"
                    }
                ]
            },
            {
                "id": 2039112,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 2018257,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 2008595,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 2005976,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1975228,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1965422,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1902008,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1900256,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1898570,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1835746,
                "content": [
                    {
                        "username": "hanzlasaqib2023",
                        "content": "How to know that this specific sum is closest number?"
                    },
                    {
                        "username": "cjdcoy",
                        "content": "can someone tell me the difference between \n1:\n`diff := abs(target - tmp)\n            if diff == 0 {\n                return tmp\n            }\n            if diff < minDiff {\n                minDiff = diff\n                closest = tmp\n            }`\n\nand 2:\n`diff := target - tmp\n            if diff == 0 {\n                return tmp\n            }\n            if abs(diff) < abs(minDiff) {\n                minDiff = diff\n                closest = tmp\n            }`\n\nI was stuck for a while using 1 and when I swtiched to 2 it worked but i don't understand why shouldn't they provide the same result ? @"
                    },
                    {
                        "username": "astra29",
                        "content": "instead comparing differences could we use\\nsum == target || sum == ++target || sum == --target\\nin if statement? what are your views???\\n"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "My time limit is exceeded for very large inputs ,can anyone suggest some amendments in my code so time should not be exceeded in large datasets."
                    },
                    {
                        "username": "apjo2009",
                        "content": "do we need to define for ourselves what \"closeness\" means? is there a threshold?"
                    },
                    {
                        "username": "vishal_2806",
                        "content": "//why i am not able to access that  threeSum[it] value\\n sort(threeSum.begin(),threeSum.end());\\n       auto it = lower_bound(threeSum.begin(),threeSum.end(),target) - threeSum.begin();\\n       cout<<it<<endl;\\n       cout<<threeSum[it]; ///only threeSum[0] will not showing the erroe other value will give me runtime erroe why\\n"
                    },
                    {
                        "username": "Jain0804",
                        "content": "for input  {1,1,1,1} and target 0 , why the output is coming 3 ?"
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "acnpssyy",
                        "content": "you have to choose 3 elements no matter what the target is . So it is obvious that the answer should be 3 "
                    },
                    {
                        "username": "imt2022073",
                        "content": "what should be the time complexity"
                    },
                    {
                        "username": "Blatogh",
                        "content": "A easy version of 15"
                    },
                    {
                        "username": "Rmsa77",
                        "content": "Can anyone say when will be target equals to output??"
                    },
                    {
                        "username": "manasi2510",
                        "content": "When sum of 3 integers will be equal to target value"
                    }
                ]
            },
            {
                "id": 1819662,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1807387,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1807374,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1798513,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1798512,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1797041,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1779724,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1767723,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1761945,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1753078,
                "content": [
                    {
                        "username": "Kinszs",
                        "content": "For this problem would the output be the closest number to the target? I would assume that 0 would be the closest number to 1 and not 2. "
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on my IDE but the Same Test Cases Fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "js_27",
                        "content": "//This Code Works Absolutely Fine on IDE but the same test cases fail on LC\\n//Why is it so?\\n\\n```\\nclass Solution {\\n    static int minDiff = Integer.MAX_VALUE;\\n    static int minAns = Integer.MAX_VALUE;\\n    \\n    public int threeSumClosest(int[] nums, int target) {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int a = nums[i];\\n            helper1(nums,target,i+1,a);\\n        }        \\n        return minAns;\\n    }\\n    void helper1(int[] nums,int target,int start,int a)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int b = nums[i];\\n            helper2(nums,target,i+1,a,b);\\n        }\\n    }\\n    void helper2(int[] nums,int target,int start,int a,int b)\\n    {\\n        for(int i=start;i<nums.length;i++)\\n        {\\n            int sum = nums[i] + a + b;\\n            int diff = Math.abs(target-sum);\\n            if(diff < minDiff)\\n            {\\n                minDiff = diff;\\n                minAns = sum;\\n            }\\n        }\\n    }\\n}\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "best beat 100%"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n\\n\\n    \\nint threeSumClosest(vector<int>&nums,int target)\\n{\\n    sort(nums.begin(),nums.end());\\n\\n    int closedifff = INT_MAX;\\n    int closesum;\\n\\n    for(int i=0;i<nums.size()-2;i++)\\n    {\\n        int sum =0;\\n        int j=i+1,k=nums.size()-1;\\n        sum+=nums[i]+nums[j]+nums[k];\\n        \\n        while(j<k)\\n        {\\n            if(abs(sum-target)<closedifff)\\n            {\\n                closedifff = abs(sum-target);\\n                closesum=sum;\\n            }\\n            if(sum<target)\\n            {\\n                sum -=nums[j];\\n                j++;\\n                sum+=nums[j];\\n            }\\n            else if(sum > target){\\n                   sum -=nums[k];\\n                k--;\\n                sum+=nums[k];\\n            }\\n             else\\n             {\\n                 break;\\n             }\\n        }\\n    }\\n    return closesum;\\n\\n}\\n\\n    \\n};"
                    },
                    {
                        "username": "sanjaykumardas7399008072",
                        "content": "Procedure to Solve 3 Sum Closest\\n\\n1. Sort the array in ascending order\\n2. variables : arraySize, i, start, end, difference, temp, ans\\n3. i=0, difference = intMax\\n4. \\nwhile(i<arraySize) \\n{\\n____ start = i+1; end = arraySize-1;\\n____ while(start<end)\\n____ {\\n________ temp = arr[i] + arr[start]+arr[end];\\n________if( |target-temp| <difference)\\n________ {\\n____________ ans = temp;\\n____________ difference = |target-temp|\\n________ }\\n________ if(temp == target)\\n________ {\\n____________ return target\\n________ }\\n________ if(target<temp)\\n________ {\\n____________ end--;\\n________ }\\n________ else\\n________ {\\n____________ start ++\\n________ }\\n____ }\\n}\\nreturn ans;"
                    },
                    {
                        "username": "ankush920",
                        "content": "Best and easiest solution of this problem \\nS.C. =O(1) , T.C. =O(1)\\njust like 3sum problem :-\\nclass Solution {\\npublic:\\n\\n int mod (int a)\\n {\\n     if( a<0)\\n     {\\n          return (-a);\\n     }\\n\\n     return a;\\n  }\\n\\n\\n    int threeSumClosest(vector<int>& nums, int target) {\\n\\n\\n         int ans =0 ;\\n         int minima= INT_MAX;\\n        int n =nums.size();\\n        int result=0;  \\n           \\n      sort(nums.begin() ,nums.end()); //sorting array to use two pointer approach \\n\\n\\n      for( int i = 0; i< n-1; i++)\\n      { \\n         \\n              \\n          int sum = nums[i];\\n           int p1 =i+1;\\n           int p2= n-1 ;\\n\\n         while(p1<p2)\\n          {\\n           \\n\\n            sum =nums[i]+nums[p1]+nums[p2];    \\n\\n            int diff =target-sum;\\n\\n             \\n             if(mod(diff) < mod(minima) )  /////for finding nearst greater or lower \\n             {\\n                \\n                 minima=diff;\\n                  result= sum;\\n             }\\n\\n            if(sum > target)\\n            {\\n                 p2--;\\n                 continue;\\n            }\\n\\n            if(sum <target )\\n            {\\n                p1++;\\n                continue;\\n            }\\n            \\n      \\n            ans++; ///// if the taget hit we return it \\n               p1++;\\n            p2--;\\n              break; \\n           \\n          }\\n     \\n\\n      }\\n\\n     if(! ans)\\n     {\\n          return result;\\n     }  \\n        \\n    \\n      return target;\\n      }\\n};"
                    },
                    {
                        "username": "08sahil_lamba",
                        "content": "\"I have recently solved a problem using the traditional two-pointer approach, but I am not satisfied with its time complexity of O(n^2). Can you please provide suggestions on how I can improve it?\"\\nThis is my solution : --->\\n `class Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) {\\n        int ans = 0;\\n        int min = INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0; i<nums.size(); i++){\\n            int start=i+1;\\n            int end = nums.size()-1;\\n            while(start < end){\\n                int sum = nums[i]+nums[start]+nums[end];\\n                if( abs(sum - target) < min ){\\n                    min = abs(sum - target);\\n                    ans = sum;\\n                    cout<<min<<\" \"<<ans<<endl;\\n                }\\n                if( sum == target )return sum;\\n                else if ( sum  < target )start++;\\n                else end--;\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "can someone tell the issue in my code , it is failing on input [-1,2,1,-4] target =1\\ncode:\\nclass Solution {\\npublic:\\n    int threeSumClosest(vector<int>& nums, int target) \\n    {\\n         sort(nums.begin(),nums.end());\\n        int n1,n2,n3,gap=INT_MAX,t_gap,sum;\\n        int size = nums.size();\\n        int count =1;\\n        int i =0,j=1,k=2;\\n         n1= nums[i];\\n         n2= nums[j];\\n         n3= nums[k];\\n         sum = n1+n2+n3;\\n         int ans;\\n         t_gap= abs(target - sum);\\n         if (n1+n2+n3==target)\\n         {\\n             return target;\\n         }\\n        while(count<=size/2)\\n        {\\n            if (t_gap<gap)\\n            {\\n                gap = t_gap;\\n                ans= sum;\\n            }\\n            if(sum!=target)\\n            {\\n                while(k<=size-1)\\n                {\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    k++;\\n                }\\n                k=j+1;\\n                while(j<=size-1)\\n                {\\n                    if (j==k)\\n                    {\\n                        j++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    j++;\\n                }\\n                j=i+1;\\n                while(i<=size-1)\\n                {\\n                    if (i==j || i==k)\\n                    {\\n                        i++;\\n                        continue;\\n                    }\\n                    if (t_gap<gap)\\n                    {\\n                        gap = t_gap;\\n                        ans= sum;\\n                    }\\n                    i++;\\n                }\\n                i=j-1;\\n                count++;\\n                i++;\\n                j++;\\n                k++;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "sachingg",
                        "content": "1) How is difference counted. Is it on the number Line or by Actual subtraction\\nfor eg. if target is 1 and 2 diffs are -1 and 5. Which is closest\\n\\n2) How should the difference be calculated. target-sum or sum-target"
                    }
                ]
            },
            {
                "id": 1752585,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1715276,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1714059,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1713632,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1701042,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1696065,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1671256,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1648663,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1637889,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            },
            {
                "id": 1636388,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "randeepbydesign",
                        "content": "As of right now, the N^3 solution can pass verification using Java.\\n```\\npublic int threeSumClosestN3(int[] nums, int target) {\\n    int distance = nums[0] + nums[1] + nums[2];\\n    for(int i=0; i<nums.length-2; i++) {\\n        for(int j = i+1; j<nums.length-1; j++) {\\n            for(int k = j + 1; k<nums.length; k++) {\\n                int sum = nums[i] + nums[j] + nums[k];\\n                distance = (Math.abs(distance-target) > Math.abs(sum-target)) ? sum : distance;\\n            }\\n        }\\n    }\\n    return distance;\\n}\\n```"
                    },
                    {
                        "username": "RaghavMittal56",
                        "content": "import java.util.*;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int threeSumClosest(int[] arr, int target) {\\n        \\n\\nint arr1=0;\\n\\n\\n\\n        // List<List<Integer>> arr1=new ArrayList<>();\\nHashMap<Integer,Integer> map= new HashMap<>();\\n\\nfor(int i=0;i<arr.length;i++){\\n    map.put(i,arr[i]);\\n}\\n\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                for(int k=j+1;k<arr.length;k++){\\n                    int ans=map.get(i)+map.get(j)+map.get(k);\\nif(Math.max(target-ans,ans-target)<Math.max(target-arr1,arr1-target)){\\n    //  List<Integer> arr2=new ArrayList<>();\\n    //  arr2.add(i);\\n    //  arr2.add(j);\\n    //  arr2.add(k);\\n    //  arr1.add(arr2);\\n  arr1=map.get(i)+map.get(j)+map.get(k);\\n}\\n            }\\n            }\\n        }\\n        return arr1;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n// plz somebody tell error in my code\\n"
                    },
                    {
                        "username": "Mohamad-Badr",
                        "content": "nums =[-1,2,1,-4]\\ntarget =1\\nOutput\\n-1 // the wrong is here in my IDE it is =2\\nExpected\\n2\\nin this test case, it gave me the output as -1 but I tested the code and the result with my IDE and the result was 2, not -1 so my code is right and there is a wrong in the test case of this case I don\\'t the why."
                    },
                    {
                        "username": "cosh_7411",
                        "content": "I got wrong test case.How is 2 nearer to -100 than 1??\\nnums =[1,1,1,0]\\ntarget =-100\\nOutput\\n1\\nExpected\\n2\\n\\nmore over for list with len 1 I tried list1[0] it gave index out error.\\n"
                    },
                    {
                        "username": "akm07",
                        "content": "the answer must be a sum of 3 numbers from the array 0+1+1"
                    },
                    {
                        "username": "vishal1810",
                        "content": "leetcode accepts only case sensitive solutions,\\nso remember to use curly braces.\\nwe can solve it by two approaches \\n   1) Bruttle force appr (T.C = O(n^3))\\n   2) Two pointers appr(T.C = O(n^2))"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and c programming.\\n[https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-3sum-closest-problem-solution.html)"
                    },
                    {
                        "username": "Bhautikbhalala123",
                        "content": "Full OPTIMAL solution in Java , Python , C++ , C \\n\\npython , c++ , c , java \\n\\n\\nhttps://zeroplusfour.com/3sum-closest-leetcode-solution/"
                    },
                    {
                        "username": "Roshan_kumar_",
                        "content": "nums =[4,0,5,-5,3,3,0,-4,-5]\\ntarget = -2\\nOutput= -1\\nExpected = -2\\nwhy it is giving me the wrong answer \\n"
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The expected answer is indeed -2 because by taking the triplet (-5, 0, 3) and by adding them, it gives the output -2"
                    },
                    {
                        "username": "Raj_Gurjar",
                        "content": "nums =\\n[4,0,5,3,3,0,-4]\\ntarget =\\n-2\\nOutput\\n-4\\nExpected\\n-1\\n\\n\\nis the above test case correct ? I think it is wrong."
                    },
                    {
                        "username": "Nawvoid",
                        "content": "The testcase is correct.\n\nThe result -1 is obtained by adding 0, 3 and -4 together; and the result -1 is closer to the target that is -2 than the result -4"
                    }
                ]
            }
        ]
    },
    {
        "title": "Populating Next Right Pointers in Each Node",
        "question_content": "<p>You are given a <strong>perfect binary tree</strong> where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>\n\n<pre>\nstruct Node {\n  int val;\n  Node *left;\n  Node *right;\n  Node *next;\n}\n</pre>\n\n<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to <code>NULL</code>.</p>\n\n<p>Initially, all next pointers are set to <code>NULL</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/02/14/116_sample.png\" style=\"width: 500px; height: 171px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,3,4,5,6,7]\n<strong>Output:</strong> [1,#,2,3,#,4,5,6,7,#]\n<strong>Explanation: </strong>Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#39;#&#39; signifying the end of each level.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2<sup>12</sup> - 1]</code>.</li>\n\t<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong></p>\n\n<ul>\n\t<li>You may only use constant extra space.</li>\n\t<li>The recursive approach is fine. You may assume implicit stack space does not count as extra space for this problem.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 37472,
                "title": "a-simple-accepted-solution",
                "content": "    void connect(TreeLinkNode *root) {\\n        if (root == NULL) return;\\n        TreeLinkNode *pre = root;\\n        TreeLinkNode *cur = NULL;\\n        while(pre->left) {\\n            cur = pre;\\n            while(cur) {\\n                cur->left->next = cur->right;\\n                if(cur->next) cur->right->next = cur->next->left;\\n                cur = cur->next;\\n            }\\n            pre = pre->left;\\n        }\\n    }\\nyou need two additional pointer.",
                "solutionTags": [],
                "code": "    void connect(TreeLinkNode *root) {\\n        if (root == NULL) return;\\n        TreeLinkNode *pre = root;\\n        TreeLinkNode *cur = NULL;\\n        while(pre->left) {\\n            cur = pre;\\n            while(cur) {\\n                cur->left->next = cur->right;\\n                if(cur->next) cur->right->next = cur->next->left;\\n                cur = cur->next;\\n            }\\n            pre = pre->left;\\n        }\\n    }\\nyou need two additional pointer.",
                "codeTag": "Unknown"
            },
            {
                "id": 1654181,
                "title": "c-python-java-simple-solution-w-images-explanation-bfs-dfs-o-1-optimized-bfs",
                "content": "We are given a perfect binary tree and we need to populate next pointers in each node of the tree\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (BFS - Right to Left)***\\n\\nIt\\'s important to see that the given tree is a **perfect binary tree**. This means that each node will always have both children and only the last level of nodes will have no children.\\n\\n<p align=middle><img src=https://assets.leetcode.com/uploads/2019/02/14/116_sample.png width=500 />\\n\\nNow, we need to populate next pointers of each node with nodes that occur to its immediate right on the same level. This can easily be done with BFS. Since for each node, we require the right node on the same level, we will perform a **right-to-left BFS** instead of the standard left-to-right BFS.\\n\\nBefore starting the traversal of each level, we would initialize a `rightNode` variable set to NULL. Then, since we are performing right-to-left BFS, we would be starting at rightmost node of each level. We set the next node of `cur` as `rightNode` and update `rightNode = cur`. This would ensure that each node would be assigned its `rightNode` properly while traversing from right to left. \\nAlso, if `cur` has a child, we would first push its right child and only then its left child (since we are doing right-to-left BFS). Once BFS is completed (after queue becomes empty), all next node would be populated and we can finally return `root`.\\n\\nThe process is illustrated below -\\n\\n<table>\\n<tr>\\n<td colspan=4>\\n<p align=middle>\\n<img src=https://assets.leetcode.com/users/images/01e68f51-4905-4f58-b2dd-061aa64c8a91_1640764834.4913242.png width=350   />\\n</p>\\n</td>\\n</tr>\\n\\n<tr></tr>\\n\\n<tr>\\n<td colspan=4>\\n<p align=middle>\\n<img src=https://assets.leetcode.com/users/images/e2a49b2c-1493-4e3f-bb36-28b89153bf73_1640768916.6068268.png  width=350  />\\n<img src=https://assets.leetcode.com/users/images/67ff2271-2b5d-4b5f-8e31-6e14809146ad_1640765277.2783518.png  width=350   />\\n</p>\\n</td>\\n\\n</tr>\\n\\n<tr></tr>\\n\\n<tr>\\n<td colspan=4>\\n<p align=middle>\\n<img src=https://assets.leetcode.com/users/images/e1067d5d-3c94-4efc-b202-f4d18b93a0ac_1640765388.5706594.png  width=350  />\\n<img src=https://assets.leetcode.com/users/images/d8a07cf0-aa8c-44b9-ab35-98a2e1422d43_1640765420.4366648.png  width=350  />\\n<img src=https://assets.leetcode.com/users/images/ce1046fb-3212-46a5-b2f7-445ab32df816_1640765451.180103.png  width=350  />\\n<img src=https://assets.leetcode.com/users/images/bd5a4aff-19fe-4aad-b4e6-5dee5156536f_1640765483.7865818.png  width=350  />\\n</p>\\n\\n</tr>\\n\\n</table>\\n\\n\\n\\n\\n\\n\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return nullptr;\\n        queue<Node*> q;\\n        q.push(root);        \\n        while(size(q)) {\\n            Node* rightNode = nullptr;                    // set rightNode to null initially\\n            for(int i = size(q); i; i--) {                // traversing each level\\n                auto cur = q.front(); q.pop();            // pop a node from current level and,\\n                cur -> next = rightNode;                  // set its next pointer to rightNode\\n                rightNode = cur;                          // update rightNode as cur for next iteration\\n                if(cur -> right)                          // if a child exists\\n                    q.push(cur -> right),                 // IMP: push right first to do right-to-left BFS\\n                    q.push(cur -> left);                  // then push left\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def connect(self, root):\\n        if not root: return None\\n        q = deque([root])\\n        while q:\\n            rightNode = None\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                cur.next, rightNode = rightNode, cur\\n                if cur.right:\\n                    q.extend([cur.right, cur.left])\\n        return root\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Queue<Node> q = new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()) {\\n            Node rightNode = null;\\n            for(int i = q.size(); i > 0; i--) {\\n                Node cur = q.poll();\\n                cur.next = rightNode;\\n                rightNode = cur;\\n                if(cur.right != null) {\\n                    q.offer(cur.right);\\n                    q.offer(cur.left);\\n                }\\n            }\\n        }\\n        return root;        \\n    }\\n}\\n```\\n\\n***Time Complexity :*** `O(N)`, where `N` is the number of nodes in the given tree. We only traverse the tree once using BFS which  requires `O(N)`.\\n***Space Complexity :*** `O(W) = O(N)`, where `W` is the width of given tree. This is required to store the nodes in queue. Since the given tree is a perfect binary tree, its width is given as `W = (N+1)/2 \\u2248 O(N)`\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (DFS)***\\n\\nWe can also populate the next pointers recursively using DFS. This is slightly different logic than above but relies on the fact that the given tree is a perfect binary tree.\\n\\nIn the above solution, we had access to right nodes since we traversed in level-order. But in DFS, once we go to the next level, we cant get access to right node. So, we must update next pointers of the child of each node from the its parent\\'s level itself. Thus at each recursive call -\\n* If child node exists:\\n\\t* assign next of left child node as right child node: `root -> left -> next = root -> right`. Note that, if once child exists, the other exists as well.\\n\\t* assign next of right child node as left child of root\\'s next (if root\\'s next exists): `root -> right -> next = root -> next -> left`. \\n\\t**How?** We need right immediate node of right child. This wont exist if current root\\'s next node doesnt exists. If next node of current root is present (the next pointer of root would already be populated in above level) , the right immediate node of root\\'s right child must be root\\'s next\\'s left child because if child of root exists, then the child of root\\'s next must also exist.\\n\\n* If child node doesn\\'t exist, we have reached the last level, we can directly return since there\\'s no child nodes to populate their next pointers\\n\\nThe process is very similar to the one illustrated in the image below with just the difference that we are traversing with DFS instead of BFS shown below.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return nullptr;\\n        auto L = root -> left, R = root -> right, N = root -> next;\\n        if(L) {\\n            L -> next = R;                                // next of root\\'s left is assigned as root\\'s right\\n            if(N) R -> next = N -> left;                  // next of root\\'s right is assigned as root\\'s next\\'s left (if root\\'s next exist)\\n            connect(L);                                   // recurse left  - simple DFS \\n            connect(R);                                   // recurse right\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def connect(self, root):\\n        if not root: return None\\n        L, R, N = root.left, root.right, root.next\\n        if L:\\n            L.next = R\\n            if N: R.next = N.left\\n            self.connect(L)\\n            self.connect(R)\\n        return root\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Node L = root.left, R = root.right, N = root.next;\\n        if(L != null) {\\n            L.next = R;\\n            if(N != null) R.next = N.left;\\n            connect(L);\\n            connect(R);\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\n***Time Complexity :*** `O(N)`, each node is only traversed once\\n***Space Complexity :*** `O(logN)`, required for recursive stack. The maximum depth of recursion is equal to the height of tree which in this case of perfect binary tree is equal to `O(logN)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (BFS - Space-Optimized Appraoch)***\\n\\nThis is a combination of logic of above logics- we will traverse in BFS manner but populate the next pointers of bottom level just as we did in the DFS solution.\\n\\nUsually standard DFS/BFS takes `O(N)` space, but since we are given the next pointers in each node, we can use them to space-optimize our traversal to `O(1)`. \\n* We first populate the next pointers of child nodes of current level. This makes it possible to traverse the next level without using a queue. To populate next pointers of child, the exact same logic as above is used\\n* We simply traverse to root\\'s left child and repeat the process - traverse current level, fill next pointers of child nodes and then again update `root = root -> left`. So, we are basically performing standard BFS traversal in `O(1)` space by using next pointers to our advantage\\n* The process continues till we reach the last level of tree\\n\\n\\nThe process is illustrated in images below -\\n\\n\\n<table>\\n  <tr>\\n    <th>Image</th>\\n    <th>Description</th>\\n  </tr>\\n  \\n  <tr>\\n    <td><img src=https://assets.leetcode.com/users/images/b681da39-4c99-4e52-8cb8-779583022898_1640761933.124148.png  width=500 /></td>\\n    <td>We start with a perfect binary tree with all next pointers initially NULL</td>\\n  </tr>\\n  \\n  <tr></tr>\\n  \\n  <tr>\\n    <td>\\n<img src=https://assets.leetcode.com/users/images/ebbbfada-bd94-4432-ac4b-e0326fc34fd4_1640761979.3636644.png  width=500 /></td>\\n    <td>We start traversal level-by-level, from left to right on each level</br>\\n\\t\\n```cpp\\ncur = root\\n```\\t\\n\\nEvery iteration, the next pointers of a node\\'s child will be updated</br> \\n\\n```cpp\\nif(cur -> left) {\\n\\tcur -> left -> next = cur -> right;\\n\\tif(cur -> next) cur -> right -> next = cur -> next -> left;\\n}\\n```\\n\\n</td>\\n\\n  </tr>\\n  \\n  <tr></tr>\\n  \\n  <tr>\\n    <td><img src=https://assets.leetcode.com/users/images/4935430e-af1b-4fe1-9fc7-c5d35be45b90_1640761999.0506494.png  width=500 /></td>\\n    <td>Move to next level</br>\\n\\n```cpp\\nroot = root -> left\\n// next iteration\\ncur = root\\n```\\n\\n& repeat:</br>\\n\\t\\n```cpp\\nif(cur -> left) {\\n\\tcur -> left -> next = cur -> right;\\n\\tif(cur -> next) cur -> right -> next = cur -> next -> left;\\n}\\n```\\n\\t\\n</td>\\n  </tr>\\n  \\n  <tr></tr>\\n  \\n  <tr>\\n    <td><img src=https://assets.leetcode.com/users/images/9ada5f9e-34f7-4c0b-b513-2bd6ff758cbc_1640762014.5024235.png  width=500 /></td>\\n    <td>Continue the same process with all nodes on current level</br>\\n\\t\\n```cpp\\nfor(; cur; cur = cur -> next)\\n    // ...\\n```\\n\\t\\n</td>\\n  </tr>\\n  \\n  <tr></tr>\\n  \\n  <tr>\\n    <td><img src=https://assets.leetcode.com/users/images/8656dc5e-93fb-4260-87a7-a2261171b70d_1640762030.292751.png  width=500 /></td>\\n    <td>No child node exists</br>\\n\\n```cpp\\nif(cur -> left)\\n    // ...\\nelse break\\n```\\n\\nSo, we break here. On the next iteration, root becomes NULL as well and we stop the process.\\n</td>\\n  </tr>\\n</table>\\n\\n\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        auto head = root;\\n        for(; root; root = root -> left) \\n            for(auto cur = root; cur; cur = cur -> next)   // traverse each level - it\\'s just BFS taking advantage of next pointers          \\n                if(cur -> left) {                          // update next pointers of children if they exist               \\n                    cur -> left -> next = cur -> right;\\n                    if(cur -> next) cur -> right -> next = cur -> next -> left;\\n                }\\n                else break;                                // if no children exist, stop iteration                                                  \\n        \\n        return head;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def connect(self, root):\\n        head = root\\n        while root:\\n            cur, root = root, root.left\\n            while cur:\\n                if cur.left:\\n                    cur.left.next = cur.right\\n                    if cur.next: cur.right.next = cur.next.left\\n                else: break\\n                cur = cur.next\\n                \\n        return head\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node head = root;\\n        for(; root != null; root = root.left) \\n            for(Node cur = root; cur != null; cur = cur.next) \\n                if(cur.left != null) {\\n                    cur.left.next = cur.right;\\n                    if(cur.next != null) cur.right.next = cur.next.left;\\n                } else break;\\n        \\n        return head;\\n    }\\n}\\n```\\n\\n***Time Complexity :*** `O(N)`, we only traverse each node once, basically doing a standard BFS.\\n***Space Complexity :*** `O(1)`, only constant extra space is being used\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return nullptr;\\n        queue<Node*> q;\\n        q.push(root);        \\n        while(size(q)) {\\n            Node* rightNode = nullptr;                    // set rightNode to null initially\\n            for(int i = size(q); i; i--) {                // traversing each level\\n                auto cur = q.front(); q.pop();            // pop a node from current level and,\\n                cur -> next = rightNode;                  // set its next pointer to rightNode\\n                rightNode = cur;                          // update rightNode as cur for next iteration\\n                if(cur -> right)                          // if a child exists\\n                    q.push(cur -> right),                 // IMP: push right first to do right-to-left BFS\\n                    q.push(cur -> left);                  // then push left\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def connect(self, root):\\n        if not root: return None\\n        q = deque([root])\\n        while q:\\n            rightNode = None\\n            for _ in range(len(q)):\\n                cur = q.popleft()\\n                cur.next, rightNode = rightNode, cur\\n                if cur.right:\\n                    q.extend([cur.right, cur.left])\\n        return root\\n```\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Queue<Node> q = new LinkedList<>();\\n        q.offer(root);\\n        while(!q.isEmpty()) {\\n            Node rightNode = null;\\n            for(int i = q.size(); i > 0; i--) {\\n                Node cur = q.poll();\\n                cur.next = rightNode;\\n                rightNode = cur;\\n                if(cur.right != null) {\\n                    q.offer(cur.right);\\n                    q.offer(cur.left);\\n                }\\n            }\\n        }\\n        return root;        \\n    }\\n}\\n```\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return nullptr;\\n        auto L = root -> left, R = root -> right, N = root -> next;\\n        if(L) {\\n            L -> next = R;                                // next of root\\'s left is assigned as root\\'s right\\n            if(N) R -> next = N -> left;                  // next of root\\'s right is assigned as root\\'s next\\'s left (if root\\'s next exist)\\n            connect(L);                                   // recurse left  - simple DFS \\n            connect(R);                                   // recurse right\\n        }\\n        return root;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def connect(self, root):\\n        if not root: return None\\n        L, R, N = root.left, root.right, root.next\\n        if L:\\n            L.next = R\\n            if N: R.next = N.left\\n            self.connect(L)\\n            self.connect(R)\\n        return root\\n```\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Node L = root.left, R = root.right, N = root.next;\\n        if(L != null) {\\n            L.next = R;\\n            if(N != null) R.next = N.left;\\n            connect(L);\\n            connect(R);\\n        }\\n        return root;\\n    }\\n}\\n```\n```cpp\\ncur = root\\n```\n```cpp\\nif(cur -> left) {\\n\\tcur -> left -> next = cur -> right;\\n\\tif(cur -> next) cur -> right -> next = cur -> next -> left;\\n}\\n```\n```cpp\\nroot = root -> left\\n// next iteration\\ncur = root\\n```\n```cpp\\nif(cur -> left) {\\n\\tcur -> left -> next = cur -> right;\\n\\tif(cur -> next) cur -> right -> next = cur -> next -> left;\\n}\\n```\n```cpp\\nfor(; cur; cur = cur -> next)\\n    // ...\\n```\n```cpp\\nif(cur -> left)\\n    // ...\\nelse break\\n```\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        auto head = root;\\n        for(; root; root = root -> left) \\n            for(auto cur = root; cur; cur = cur -> next)   // traverse each level - it\\'s just BFS taking advantage of next pointers          \\n                if(cur -> left) {                          // update next pointers of children if they exist               \\n                    cur -> left -> next = cur -> right;\\n                    if(cur -> next) cur -> right -> next = cur -> next -> left;\\n                }\\n                else break;                                // if no children exist, stop iteration                                                  \\n        \\n        return head;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def connect(self, root):\\n        head = root\\n        while root:\\n            cur, root = root, root.left\\n            while cur:\\n                if cur.left:\\n                    cur.left.next = cur.right\\n                    if cur.next: cur.right.next = cur.next.left\\n                else: break\\n                cur = cur.next\\n                \\n        return head\\n```\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node head = root;\\n        for(; root != null; root = root.left) \\n            for(Node cur = root; cur != null; cur = cur.next) \\n                if(cur.left != null) {\\n                    cur.left.next = cur.right;\\n                    if(cur.next != null) cur.right.next = cur.next.left;\\n                } else break;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37461,
                "title": "java-solution-with-o-1-memory-o-n-time",
                "content": "\\n\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            TreeLinkNode level_start=root;\\n            while(level_start!=null){\\n                TreeLinkNode cur=level_start;\\n                while(cur!=null){\\n                    if(cur.left!=null) cur.left.next=cur.right;\\n                    if(cur.right!=null && cur.next!=null) cur.right.next=cur.next.left;\\n                    \\n                    cur=cur.next;\\n                }\\n                level_start=level_start.left;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            TreeLinkNode level_start=root;\\n            while(level_start!=null){\\n                TreeLinkNode cur=level_start;\\n                while(cur!=null){\\n                    if(cur.left!=null) cur.left.next=cur.right;\\n                    if(cur.right!=null && cur.next!=null) cur.right.next=cur.next.left;\\n                    \\n                    cur=cur.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 37484,
                "title": "7-lines-iterative-real-o-1-space",
                "content": "Simply do it level by level, using the `next`-pointers of the current level to go through the current level and set the `next`-pointers of the next level.\\n\\nI say \"real\" O(1) space because of the many recursive solutions ignoring that recursion management needs space.\\n\\n    def connect(self, root):\\n        while root and root.left:\\n            next = root.left\\n            while root:\\n                root.left.next = root.right\\n                root.right.next = root.next and root.next.left\\n                root = root.next\\n            root = next",
                "solutionTags": [
                    "Python"
                ],
                "code": "Simply do it level by level, using the `next`-pointers of the current level to go through the current level and set the `next`-pointers of the next level.\\n\\nI say \"real\" O(1) space because of the many recursive solutions ignoring that recursion management needs space.\\n\\n    def connect(self, root):\\n        while root and root.left:\\n            next = root.left\\n            while root:\\n                root.left.next = root.right\\n                root.right.next = root.next and root.next.left\\n                root = root.next\\n            root = next",
                "codeTag": "Python3"
            },
            {
                "id": 37473,
                "title": "my-recursive-solution-java",
                "content": "\\n    public void connect(TreeLinkNode root) {\\n        if(root == null)\\n            return;\\n            \\n        if(root.left != null){\\n            root.left.next = root.right;\\n            if(root.next != null)\\n                root.right.next = root.next.left;\\n        }\\n        \\n        connect(root.left);\\n        connect(root.right);\\n    }",
                "solutionTags": [],
                "code": "\\n    public void connect(TreeLinkNode root) {\\n        if(root == null)\\n            return;\\n            \\n        if(root.left != null){\\n            root.left.next = root.right;\\n            if(root.next != null)\\n                root.right.next = root.next.left;\\n        }\\n        \\n        connect(root.left);\\n        connect(root.right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37578,
                "title": "my-simple-non-iterative-c-code-with-o-1-memory",
                "content": "    void connect(TreeLinkNode *root) {\\n        if(!root)\\n            return;\\n        while(root -> left)\\n        {\\n            TreeLinkNode *p = root;\\n            while(p)\\n            {\\n                p -> left -> next = p -> right;\\n                if(p -> next)\\n                    p -> right -> next = p -> next -> left;\\n                p = p -> next;\\n            }\\n            root = root -> left;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    void connect(TreeLinkNode *root) {\\n        if(!root)\\n            return;\\n        while(root -> left)\\n        {\\n            TreeLinkNode *p = root;\\n            while(p)\\n            {\\n                p -> left -> next = p -> right;\\n                if(p -> next)\\n                    p -> right -> next = p -> next -> left;\\n                p = p -> next;\\n            }\\n            root = root -> left;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1653846,
                "title": "c-easy-to-solve-beginner-friendly-with-detailed-explanations-and-dry-run",
                "content": "> # **Behold the legendary battle between Recursive and Interative Approaches** \\n***\\n***Fight!!!***\\n***\\n**Intuition:-**\\n* We are given a prefect binary tree that means every parent has two children and all the    leaves are on the same level . \\n* This question is an superior version of binary level order traversal .\\n* In level order traversal you will traverse each level of binary tree while outputting the data in that form . So the only difference is that somehow we need to connect the previous levels rightmost node to the next level\\'s leftmost node and that\\'s it .\\n\\n**Algorithm:-**\\n1. Base case: if the root is null than return null\\n2. Now to connect the left subtree of same level with right subtree of that level \\n3. The only new line that differentiate from level order traversing is that we need to connect the rightmost node of a level to the leftmost node of the next level.\\n4. Now just repeat the steps over and over for every level of tree . \\n\\n![image](https://assets.leetcode.com/users/images/6a41f9e5-3ba0-4116-ac09-f7e4a4bfdb19_1640748379.9406984.png) *Image credit goes to @Stargarth*\\n\\n**We can code this approach by two methods:**\\n1. By recursive \\n2. Iterative\\n<mark>Both solution has time complexity and space complexity as O(n) and O(1) in a virtual manner but if we consider in a true sense than in recursion we use a recursive stack which has some space complexity .<mark>\\nSo in a real sense the iterative solution is the best since it has truly O(1) space complexity .\\n***\\n**Recursive Approach Code:-**\\n```\\n//Upvote and Comment \\n\\nclass Solution {\\npublic:\\nNode* connect(Node* root) {\\n    //base case\\n    if(root == NULL) return NULL;\\n    //connects the left subtree of same level with right subtree of that same level \\n    if(root->left != NULL) root->left->next = root->right;\\n    //connect the rightmost node of a level to the leftmost node of the next level.\\n    if(root->right != NULL && root->next != NULL) root->right->next = root->next->left;\\n    //recursive calls for left and right subtrees.\\n    connect(root->left);\\n    connect(root->right);\\n    return root;\\n   }\\n};\\n```\\n***\\n**Iterative Approach:-**\\nIn iterative approach we will be needing two more pointers named as `curr` and `prev` for linking of left and right nodes\\n```\\n//Upvote and Comment\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        //Initialize pointers\\n        Node *prev = root, *curr;\\n        while (prev) {\\n            curr = prev;\\n            while (curr && curr->left) { \\n                //connects the left subtree of same level with right subtree of that same level \\n                curr->left->next = curr->right;\\n                //connect the rightmost node of a level to the leftmost node of the next level.\\n                if (curr -> next) curr->right->next = curr->next->left;\\n                curr = curr->next;\\n            }\\n            prev = prev -> left;\\n        }\\n        return root;\\n    }\\n};\\n```\\n**That was a intense battle and the winner is our iterative approach!!!** \\uD83C\\uDF8A\\uD83C\\uDF8A\\n***\\n\\n***\\n\\n**[My Github Repo](https://github.com/Jatin-Shihora/LeetCode-Solutions) where I keep track of my solutions :)))**\\n\\n***\\n\\n\\n>**Feel free to comment or upvote if you liked my post ;)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n//Upvote and Comment \\n\\nclass Solution {\\npublic:\\nNode* connect(Node* root) {\\n    //base case\\n    if(root == NULL) return NULL;\\n    //connects the left subtree of same level with right subtree of that same level \\n    if(root->left != NULL) root->left->next = root->right;\\n    //connect the rightmost node of a level to the leftmost node of the next level.\\n    if(root->right != NULL && root->next != NULL) root->right->next = root->next->left;\\n    //recursive calls for left and right subtrees.\\n    connect(root->left);\\n    connect(root->right);\\n    return root;\\n   }\\n};\\n```\n```\\n//Upvote and Comment\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        //Initialize pointers\\n        Node *prev = root, *curr;\\n        while (prev) {\\n            curr = prev;\\n            while (curr && curr->left) { \\n                //connects the left subtree of same level with right subtree of that same level \\n                curr->left->next = curr->right;\\n                //connect the rightmost node of a level to the leftmost node of the next level.\\n                if (curr -> next) curr->right->next = curr->next->left;\\n                curr = curr->next;\\n            }\\n            prev = prev -> left;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37715,
                "title": "python-solutions-recursively-bfs-queue-dfs-stack",
                "content": "    def connect1(self, root):\\n        if root and root.left and root.right:\\n            root.left.next = root.right\\n            if root.next:\\n                root.right.next = root.next.left\\n            self.connect(root.left)\\n            self.connect(root.right)\\n     \\n    # BFS       \\n    def connect2(self, root):\\n        if not root:\\n            return \\n        queue = [root]\\n        while queue:\\n            curr = queue.pop(0)\\n            if curr.left and curr.right:\\n                curr.left.next = curr.right\\n                if curr.next:\\n                    curr.right.next = curr.next.left\\n                queue.append(curr.left)\\n                queue.append(curr.right)\\n        \\n    # DFS \\n    def connect(self, root):\\n        if not root:\\n            return \\n        stack = [root]\\n        while stack:\\n            curr = stack.pop()\\n            if curr.left and curr.right:\\n                curr.left.next = curr.right\\n                if curr.next:\\n                    curr.right.next = curr.next.left\\n                stack.append(curr.right)\\n                stack.append(curr.left)",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "    def connect1(self, root):\\n        if root and root.left and root.right:\\n            root.left.next = root.right\\n            if root.next:\\n                root.right.next = root.next.left\\n            self.connect(root.left)\\n            self.connect(root.right)\\n     \\n    # BFS       \\n    def connect2(self, root):\\n        if not root:\\n            return \\n        queue = [root]\\n        while queue:\\n            curr = queue.pop(0)\\n            if curr.left and curr.right:\\n                curr.left.next = curr.right\\n                if curr.next:\\n                    curr.right.next = curr.next.left\\n                queue.append(curr.left)\\n                queue.append(curr.right)\\n        \\n    # DFS \\n    def connect(self, root):\\n        if not root:\\n            return \\n        stack = [root]\\n        while stack:\\n            curr = stack.pop()\\n            if curr.left and curr.right:\\n                curr.left.next = curr.right\\n                if curr.next:\\n                    curr.right.next = curr.next.left\\n                stack.append(curr.right)\\n                stack.append(curr.left)",
                "codeTag": "Python3"
            },
            {
                "id": 37465,
                "title": "python-solution-with-explaintion",
                "content": "I want to share how I come up with this solution with you:\\n\\nSince we are manipulating tree nodes on the same level, it's easy to come up with\\na very standard BFS solution using  queue.  But because of next pointer, we actually\\ndon't  need a queue to store the order of tree nodes at each level, we just use a next\\npointer like it's a link list at each level;  In addition, we can borrow the idea used  in\\nthe Binary Tree level order traversal problem, which use cur and next pointer to store \\nfirst node at each level; we exchange cur and next every time when cur is the last node\\nat each level. \\n\\n\\n      class Solution(object):\\n        def connect(self, root):\\n            \"\"\"\\n            :type root: TreeLinkNode\\n            :rtype: nothing\\n            \"\"\"\\n            \\n            if not root:\\n                return None\\n            cur  = root\\n            next = root.left\\n    \\n            while cur.left :\\n                cur.left.next = cur.right\\n                if cur.next:\\n                    cur.right.next = cur.next.left\\n                    cur = cur.next\\n                else:\\n                    cur = next\\n                    next = cur.left",
                "solutionTags": [
                    "Python"
                ],
                "code": "I want to share how I come up with this solution with you:\\n\\nSince we are manipulating tree nodes on the same level, it's easy to come up with\\na very standard BFS solution using  queue.  But because of next pointer, we actually\\ndon't  need a queue to store the order of tree nodes at each level, we just use a next\\npointer like it's a link list at each level;  In addition, we can borrow the idea used  in\\nthe Binary Tree level order traversal problem, which use cur and next pointer to store \\nfirst node at each level; we exchange cur and next every time when cur is the last node\\nat each level. \\n\\n\\n      class Solution(object):\\n        def connect(self, root):\\n            \"\"\"\\n            :type root: TreeLinkNode\\n            :rtype: nothing\\n            \"\"\"\\n            \\n            if not root:\\n                return None\\n            cur  = root\\n            next = root.left\\n    \\n            while cur.left :\\n                cur.left.next = cur.right\\n                if cur.next:\\n                    cur.right.next = cur.next.left\\n                    cur = cur.next\\n                else:\\n                    cur = next\\n                    next = cur.left",
                "codeTag": "Java"
            },
            {
                "id": 37503,
                "title": "c-iterative-recursive",
                "content": "**Recursive**\\n\\nSimilar to a level-order traversal, even you are not allowed to use a `queue`, the `next` pointer provides you with a way to move to the next node in the same level.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        Node *pre = root, *cur;\\n        while (pre) {\\n            cur = pre;\\n            while (cur && cur -> left) { \\n                cur -> left -> next = cur -> right;\\n                if (cur -> next) {\\n                    cur -> right -> next = cur -> next -> left;\\n                }\\n                cur = cur -> next;\\n            }\\n            pre = pre -> left;\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\n**Recursive**\\n\\nRecursively connect the left and right subtrees.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return NULL;\\n        }\\n        if (root -> left) {\\n            root -> left -> next = root -> right;\\n            if (root -> next) {\\n                root -> right -> next = root -> next -> left;\\n            }\\n            connect(root -> left);\\n            connect(root -> right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        Node *pre = root, *cur;\\n        while (pre) {\\n            cur = pre;\\n            while (cur && cur -> left) { \\n                cur -> left -> next = cur -> right;\\n                if (cur -> next) {\\n                    cur -> right -> next = cur -> next -> left;\\n                }\\n                cur = cur -> next;\\n            }\\n            pre = pre -> left;\\n        }\\n        return root;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return NULL;\\n        }\\n        if (root -> left) {\\n            root -> left -> next = root -> right;\\n            if (root -> next) {\\n                root -> right -> next = root -> next -> left;\\n            }\\n            connect(root -> left);\\n            connect(root -> right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 962728,
                "title": "java-0ms-with-visual-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/a3197575-43d6-474a-b6b7-f7005723828e_1607299930.3256361.png)\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        if(root.left != null) root.left.next = root.right;\\n        if(root.right != null && root.next != null) root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        if(root.left != null) root.left.next = root.right;\\n        if(root.right != null && root.next != null) root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934111,
                "title": "c-bfs-iterative-queue",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root)return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                Node* x=q.front();\\n                q.pop();\\n                if(i!=n-1)x->next=q.front();\\n                if(x->left)q.push(x->left);\\n                if(x->right)q.push(x->right);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root)return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                Node* x=q.front();\\n                q.pop();\\n                if(i!=n-1)x->next=q.front();\\n                if(x->left)q.push(x->left);\\n                if(x->right)q.push(x->right);\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654101,
                "title": "python-two-solutions-bfs-and-dfs-image-explanation-beginner-friendly",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n* **Solution 1**\\n\\t* Standard BFS with mantaining `pre_level` and `pre_node` as the previous node in BFS sequence\\n\\t\\t* `level == pre_level` means current `node` is not the first node of `level`, then `pre_node.next = node` and update `pre_node = node`\\n\\t\\t* `else` means `pre_level < level` and `node` is the first node of `level`, then no need to update `pre_node.next`, leave it as `None`, update `pre_node = node` only.\\n\\t\\t* standard BFS, append `node.left` and `node.right` to the queue\\n\\t```\\n\\tTime  Complexity: O(N)\\n\\tSpace Complexity: O(N)\\n\\t```\\n\\t```\\n\\tclass Solution(object):\\n    def connect(self, root):\\n        if root is None: return None\\n        dq, pre_level, pre_node = deque([(1, root)]), 0, None\\n        while dq:\\n            level, node = dq.popleft()\\n            if level == pre_level:  # current node is not the first node of level\\n                pre_node.next = node\\n                pre_node = node\\n            else:  # pre_level < level and node is the first node of level, then no need to update pre_node.next, \\n                # leave it as None, update pre_node = node only.\\n                pre_level, pre_node = level, node\\n            if node.left:  # root is a perfect binary tree, once left exists, right must also exist\\n                dq.append((level + 1, node.left))\\n                dq.append((level + 1, node.right))\\n        return root\\n\\t```\\n\\n* **Solution 2**\\n\\t* Recursive DFS, the current root node is responsible for linking the nodes on both sides closest to the central axis for all levels.\\n\\t![image](https://assets.leetcode.com/users/images/4e546a8b-d11e-49a9-859d-6c7e5092e8cb_1640762771.0732064.jpeg)\\n\\n\\t\\n\\t```\\n\\tTime  Complexity: O(N)\\n\\tSpace Complexity: O(1)\\n\\t```\\n\\t```\\n\\tclass Solution(object):\\n    def connect(self, root):\\n        if not root: return root\\n        if root.left: \\n            left, right = root.left, root.right\\n            self.connect(left)\\n            self.connect(right)\\n            while left:\\n                left.next = right\\n                left, right = left.right, right.left\\n        return root\\n\\t```\\n\\t\\n**PLEASE UPVOTE if you like \\uD83D\\uDE01 If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\tTime  Complexity: O(N)\\n\\tSpace Complexity: O(N)\\n\\t```\n```\\n\\tclass Solution(object):\\n    def connect(self, root):\\n        if root is None: return None\\n        dq, pre_level, pre_node = deque([(1, root)]), 0, None\\n        while dq:\\n            level, node = dq.popleft()\\n            if level == pre_level:  # current node is not the first node of level\\n                pre_node.next = node\\n                pre_node = node\\n            else:  # pre_level < level and node is the first node of level, then no need to update pre_node.next, \\n                # leave it as None, update pre_node = node only.\\n                pre_level, pre_node = level, node\\n            if node.left:  # root is a perfect binary tree, once left exists, right must also exist\\n                dq.append((level + 1, node.left))\\n                dq.append((level + 1, node.right))\\n        return root\\n\\t```\n```\\n\\tTime  Complexity: O(N)\\n\\tSpace Complexity: O(1)\\n\\t```\n```\\n\\tclass Solution(object):\\n    def connect(self, root):\\n        if not root: return root\\n        if root.left: \\n            left, right = root.left, root.right\\n            self.connect(left)\\n            self.connect(right)\\n            while left:\\n                left.next = right\\n                left, right = left.right, right.left\\n        return root\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 934066,
                "title": "python-o-n-time-o-log-n-space-recursion-explained",
                "content": "In this problem we are given that our tree is perfect binary tree, which will help us a lot. Let us use recursion: imagine, that for left and right subtees we already make all connections, what we need to connect now? See the image and it will become very clear: we need to connect just `O(log n)` pairs now: we go the the left and to the right children. Then from left children we go as right as possible and from right children we go as left as possible.\\n\\n![image](https://assets.leetcode.com/users/images/b838445a-d58e-420b-889e-208d6813beec_1605257150.2922277.png)\\n\\n\\n**Complexity**: time complexity can be found, using Master theorem: `F(n) = 2*F(n/2) + log n`, from here `F(n) = O(n)`. Space complexity is `O(log n)`, because we use recursion. Note, that space complexity can be reduced to `O(1)`, because we know the structure of our tree!\\n\\n```\\nclass Solution:\\n    def connect(self, root):\\n        if not root or not root.left: return root\\n        \\n        self.connect(root.left)\\n        self.connect(root.right)\\n        \\n        lft = root.left\\n        rgh = root.right\\n        lft.next = rgh\\n\\n        while lft.right: \\n            lft = lft.right\\n            rgh = rgh.left\\n            lft.next = rgh\\n        \\n        return root\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root):\\n        if not root or not root.left: return root\\n        \\n        self.connect(root.left)\\n        self.connect(root.right)\\n        \\n        lft = root.left\\n        rgh = root.right\\n        lft.next = rgh\\n\\n        while lft.right: \\n            lft = lft.right\\n            rgh = rgh.left\\n            lft.next = rgh\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37603,
                "title": "java-solution-traversing-by-level-without-extra-space",
                "content": "    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if(root==null) return;\\n            TreeLinkNode cur = root;\\n            TreeLinkNode nextLeftmost = null;\\n\\n            while(cur.left!=null){\\n                nextLeftmost = cur.left; // save the start of next level\\n                while(cur!=null){\\n                    cur.left.next=cur.right;\\n                    cur.right.next = cur.next==null? null : cur.next.left;\\n                    cur=cur.next;\\n                }\\n                cur=nextLeftmost;  // point to next level \\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if(root==null) return;\\n            TreeLinkNode cur = root;\\n            TreeLinkNode nextLeftmost = null;\\n\\n            while(cur.left!=null){\\n                nextLeftmost = cur.left; // save the start of next level\\n                while(cur!=null){\\n                    cur.left.next=cur.right;\\n                    cur.right.next = cur.next==null? null : cur.next.left;\\n                    cur=cur.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 420632,
                "title": "javascript-bfs-dfs-solution",
                "content": "#### The Idea - BFS\\n1. BFS using queue\\n2. as we are shifing node, connect it to the next in queue\\n``` javascript\\nvar connectBFS = function(root) {\\n    if (root == null) return root;\\n    let queue = [root];\\n    while(queue.length!=0) {\\n        let next = [];\\n        while(queue.length!=0) {\\n            let node = queue.shift();\\n            node.next = queue[0]||null;\\n            if (node.left!=null) {\\n                next.push(node.left);\\n                next.push(node.right);\\n            }\\n        }\\n        queue = next;\\n    }\\n    return root;\\n};\\n```\\n#### The Idea - DFS\\n1. pre order scan \\n2. set child nodes arrangement before resursion\\n``` javascript\\nvar connect = function(root) {\\n    if (root == null || root.left == null) return root;\\n    root.left.next = root.right;\\n    root.right.next = root.next ? root.next.left:null;\\n    connect(root.left);\\n    connect(root.right);\\n    return root;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar connectBFS = function(root) {\\n    if (root == null) return root;\\n    let queue = [root];\\n    while(queue.length!=0) {\\n        let next = [];\\n        while(queue.length!=0) {\\n            let node = queue.shift();\\n            node.next = queue[0]||null;\\n            if (node.left!=null) {\\n                next.push(node.left);\\n                next.push(node.right);\\n            }\\n        }\\n        queue = next;\\n    }\\n    return root;\\n};\\n```\n``` javascript\\nvar connect = function(root) {\\n    if (root == null || root.left == null) return root;\\n    root.left.next = root.right;\\n    root.right.next = root.next ? root.next.left:null;\\n    connect(root.left);\\n    connect(root.right);\\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 515985,
                "title": "python-3-approaches-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: BFS**\\n```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n\\n        q = deque([root])\\n        while q:\\n            prev = None\\n            for _ in range(len(q)):\\n                curr = q.popleft()\\n                if prev != None:\\n                    prev.next = curr\\n                prev = curr\\n\\n                if curr.left != None:\\n                    q.append(curr.left)\\n                if curr.right != None:\\n                    q.append(curr.right)\\n        return root\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N` is number of nodes in the Perfect Binary Tree.\\n- Space: `O(N/2)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: DFS**\\n```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n        self.connect2Nodes(root.left, root.right)\\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root\\n        \\n    def connect2Nodes(self, root1, root2):\\n        if root1 == None or root2 == None: return\\n        root1.next = root2\\n        self.connect2Nodes(root1.right, root2.left)\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N` is number of nodes in the Perfect Binary Tree.\\n- Space: `O(logN)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 3: Using previously established next pointers**\\n```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n        \\n        leftMost = root\\n        while leftMost.left:\\n            head = leftMost\\n            leftMost = head.left\\n            while head:\\n                head.left.next = head.right\\n                if head.next != None:\\n                    head.right.next = head.next.left\\n                head = head.next\\n        return root\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N` is number of nodes in the Perfect Binary Tree.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n\\n        q = deque([root])\\n        while q:\\n            prev = None\\n            for _ in range(len(q)):\\n                curr = q.popleft()\\n                if prev != None:\\n                    prev.next = curr\\n                prev = curr\\n\\n                if curr.left != None:\\n                    q.append(curr.left)\\n                if curr.right != None:\\n                    q.append(curr.right)\\n        return root\\n```\n```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n        self.connect2Nodes(root.left, root.right)\\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root\\n        \\n    def connect2Nodes(self, root1, root2):\\n        if root1 == None or root2 == None: return\\n        root1.next = root2\\n        self.connect2Nodes(root1.right, root2.left)\\n```\n```python\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if root == None: return None\\n        \\n        leftMost = root\\n        while leftMost.left:\\n            head = leftMost\\n            leftMost = head.left\\n            while head:\\n                head.left.next = head.right\\n                if head.next != None:\\n                    head.right.next = head.next.left\\n                head = head.next\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195108,
                "title": "bfs-c-iterative-explanation-level-order-traversal",
                "content": "\\nBasically this is purely level order travsersal code with slight modification for the  root -> next value \\n\\nYou just have to think 2 things in this question.\\n\\n1.How to get the last val to NULL ?.\\n2.How to get connect with the current node to previous one ?.\\n\\nIf you are able to find the ans of these two questions mentioned above then you will reach the solution \\nalso if you are here to see the solution i would recommend you to pause for a while \\nand think about these questions i am sure you willl find the ans otherwise ans \\nis just right below you can see anytime you want just give it a though for a whlle.\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n```\\nif(root == NULL) return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size(); // get size of queue \\n            for(int i=0 ; i < size ; i++){\\n                Node* item = q.front(); \\n                if(size - 1 == i) // checking the last value of the level\\n                     item -> next = NULL; \\n                \\n                q.pop();\\n                \\n                if(size - 1 != i) // if this is not the last value then previous value will point to next one\\n                     item -> next = q.front(); \\n                \\n                if(item -> left != NULL)\\n                    q.push(item -> left);\\n                if(item -> right != NULL)\\n                    q.push(item -> right);\\n            }\\n        } \\n        return root; \\n\\t\\t\\n\\n```\\n**In an interview there will be a follow up question in which you might be asked to solve this question with recursion so better be prepared for this bomb !!!!**\\n```\\n\\n\\nBefore you see the solution as per rituals please please please think of a solution by yourself you might be right or wrong doesn\\'t matter you fought hard with the question !!!\\n\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n.\\n\\n Node* connect(Node* root) {\\n        if(root == NULL) return NULL;\\n        \\n        //now part-1 - connect Left node with right node\\n        if(root->left!=NULL) root->left->next = root->right;\\n        \\n        //now part-2 - connect right node with next subtree left node\\n        if(root->right!=NULL && root->next!=NULL) root->right->next = root->next->left;\\n        \\n        //Now do the same job for subtrees\\n        connect(root->left); \\n        connect(root->right);\\n        \\n        return root; \\n        // every time return is made, but at last the same root is retured to main\\n    }\\n\\n\\n*** IF YOU LOVED THE SOLUTION PLEASE CLICK ON THE UPVOTE BUTTON ***\\n\\n\\n\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nif(root == NULL) return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size(); // get size of queue \\n            for(int i=0 ; i < size ; i++){\\n                Node* item = q.front(); \\n                if(size - 1 == i) // checking the last value of the level\\n                     item -> next = NULL; \\n                \\n                q.pop();\\n                \\n                if(size - 1 != i) // if this is not the last value then previous value will point to next one\\n                     item -> next = q.front(); \\n                \\n                if(item -> left != NULL)\\n                    q.push(item -> left);\\n                if(item -> right != NULL)\\n                    q.push(item -> right);\\n            }\\n        } \\n        return root; \\n\\t\\t\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37520,
                "title": "simple-recursive-java-solution-o-1-space-o-n-time",
                "content": "    public void connect(TreeLinkNode root) {\\n        \\n        if(root==null) return ;\\n        \\n        link(root.left,root.right);\\n    }\\n    \\n    //HELPER FUNCTION TO LINK TWO NODES TOGETHER\\n    public void link(TreeLinkNode left, TreeLinkNode right){\\n        \\n        if(left==null && right==null) return ;\\n        \\n        left.next = right;\\n        link(left.left,left.right);\\n        link(left.right,right.left);\\n        link(right.left,right.right);\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "    public void connect(TreeLinkNode root) {\\n        \\n        if(root==null) return ;\\n        \\n        link(root.left,root.right);\\n    }\\n    \\n    //HELPER FUNCTION TO LINK TWO NODES TOGETHER\\n    public void link(TreeLinkNode left, TreeLinkNode right){\\n        \\n        if(left==null && right==null) return ;\\n        \\n        left.next = right;\\n        link(left.left,left.right);\\n        link(left.right,right.left);\\n        link(right.left,right.right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 379177,
                "title": "python3-bfs-and-dfs",
                "content": "* BFS\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, left, right, next):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.next = next\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \"\"\"\\n      1 (1)\\n    2 (2)->    3(1)\\n 4(4) -> 5(3) -> 6(2) -> 7(1)\\n\\n\"\"\"\\n        if root ==  None:\\n            return None\\n        q = deque([root])\\n        while q:  # [1] [3,4,5]\\n            size = len(q) # 1 2\\n            while size > 0: #  > 0\\n                node = q.popleft() # node =1,2,3\\n                if size > 1 :# \\n                    node.next = q[0] #  2.next = 3\\n                size -= 1          # size =1\\n                \\n                if node.left:         \\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n        return root\\n```\\n* DFS\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, left, right, next):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.next = next\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \"\"\"\\n      1 (1)\\n    2 (2)->    3(1)\\n 4(4) -> 5(3) -> 6(2) -> 7(1)\\n\\n\"\"\"\\n        self.dfs(root)\\n        return root\\n    \\n    ## (1). left child -> right child\\n    ## (2). right child -> next.left child\\n    def dfs(self,root):\\n        if root == None or root.left == None:\\n            return\\n        root.left.next = root.right\\n        if root.next != None: \\n            root.right.next = root.next.left\\n        self.dfs(root.left)\\n        self.dfs(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, left, right, next):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.next = next\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \"\"\"\\n      1 (1)\\n    2 (2)->    3(1)\\n 4(4) -> 5(3) -> 6(2) -> 7(1)\\n\\n\"\"\"\\n        if root ==  None:\\n            return None\\n        q = deque([root])\\n        while q:  # [1] [3,4,5]\\n            size = len(q) # 1 2\\n            while size > 0: #  > 0\\n                node = q.popleft() # node =1,2,3\\n                if size > 1 :# \\n                    node.next = q[0] #  2.next = 3\\n                size -= 1          # size =1\\n                \\n                if node.left:         \\n                    q.append(node.left)\\n                if node.right:\\n                    q.append(node.right)\\n        return root\\n```\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, left, right, next):\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n        self.next = next\\n\"\"\"\\nfrom collections import deque\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \"\"\"\\n      1 (1)\\n    2 (2)->    3(1)\\n 4(4) -> 5(3) -> 6(2) -> 7(1)\\n\\n\"\"\"\\n        self.dfs(root)\\n        return root\\n    \\n    ## (1). left child -> right child\\n    ## (2). right child -> next.left child\\n    def dfs(self,root):\\n        if root == None or root.left == None:\\n            return\\n        root.left.next = root.right\\n        if root.next != None: \\n            root.right.next = root.next.left\\n        self.dfs(root.left)\\n        self.dfs(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1634140,
                "title": "java-step-by-step-explanation",
                "content": "## Please upvote if this helps! Thx :D\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n        connectTwoNodes(root.left, root.right);\\n        return root;\\n    }\\n    \\n    private void connectTwoNodes(Node n1, Node n2){\\n        if (n1 == null || n2 == null) return;\\n        n1.next = n2;\\n        //Connect two child nodes from the same parent node. \\n        connectTwoNodes(n1.left, n1.right);\\n        connectTwoNodes(n2.left, n2.right);\\n        //Connect two child nodes aside from each other but from different parent nodes . \\n        connectTwoNodes(n1.right, n2.left);\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n        connectTwoNodes(root.left, root.right);\\n        return root;\\n    }\\n    \\n    private void connectTwoNodes(Node n1, Node n2){\\n        if (n1 == null || n2 == null) return;\\n        n1.next = n2;\\n        //Connect two child nodes from the same parent node. \\n        connectTwoNodes(n1.left, n1.right);\\n        connectTwoNodes(n2.left, n2.right);\\n        //Connect two child nodes aside from each other but from different parent nodes . \\n        connectTwoNodes(n1.right, n2.left);\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934042,
                "title": "java-clean-code-o-n-time-complexity-100-faster-solution",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        \\n        if (root == null || root.left == null) {\\n            return root;\\n        }\\n        \\n        root.left.next = root.right;\\n        if (root.next != null) {\\n            root.right.next = root.next.left;\\n        }\\n        \\n        connect (root.left);\\n        connect (root.right);\\n        \\n        return root;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        \\n        if (root == null || root.left == null) {\\n            return root;\\n        }\\n        \\n        root.left.next = root.right;\\n        if (root.next != null) {\\n            root.right.next = root.next.left;\\n        }\\n        \\n        connect (root.left);\\n        connect (root.right);\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059966,
                "title": "c-short-recursive-solution-no-extra-space-needed",
                "content": "Key points:\\n* Use parent\\'s next arrow to find right children\\'s next buddy in the neighboring tree.\\n* In short: root->right->next = root->next->left.\\n* Take care of current level\\'s children\\'s next arrow problem before move down to children subtree.\\n```\\n  Node* connect(Node* root) {\\n    if (root) {\\n      if (root->left) {\\n        root->left->next = root->right;\\n        if (root->next)\\n          root->right->next = root->next->left;\\n        connect(root->left);\\n        connect(root->right);\\n      }\\n    }\\n    return root;\\n  }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n  Node* connect(Node* root) {\\n    if (root) {\\n      if (root->left) {\\n        root->left->next = root->right;\\n        if (root->next)\\n          root->right->next = root->next->left;\\n        connect(root->left);\\n        connect(root->right);\\n      }\\n    }\\n    return root;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37703,
                "title": "5-lines-c-simple-solution",
                "content": "    class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            if (!root) return;\\n            if (root->left) root->left->next = root->right;\\n            if (root->right && root->next) root->right->next = root->next->left;\\n            connect(root->left);\\n            connect(root->right);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            if (!root) return;\\n            if (root->left) root->left->next = root->right;\\n            if (root->right && root->next) root->right->next = root->next->left;\\n            connect(root->left);\\n            connect(root->right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 758779,
                "title": "javascript-o-1-space-o-n-time",
                "content": "We iteratively move from each node to the next node, while fixing the next pointers of their children. \\n```\\nvar connect = function(root) {\\n    let ptr = root;\\n    while(root && root.left){\\n        let temp = root;\\n        while(temp) {\\n            temp.left.next = temp.right;\\n            temp.right.next = temp.next ? temp.next.left : null;\\n            temp = temp.next;\\n        }\\n        root = root.left;\\n    }\\n    return ptr;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar connect = function(root) {\\n    let ptr = root;\\n    while(root && root.left){\\n        let temp = root;\\n        while(temp) {\\n            temp.left.next = temp.right;\\n            temp.right.next = temp.next ? temp.next.left : null;\\n            temp = temp.next;\\n        }\\n        root = root.left;\\n    }\\n    return ptr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37469,
                "title": "another-simple-javascript-solution",
                "content": "Since it's a full binary tree, our job is much simpler, at each node, connects its left and right child, and try to connect the right child with the left child of node's next. A simple preorder traversal should be able to help us solve this problem.\\n```\\n/**\\n * @param {TreeLinkNode} root\\n * @return {void} Do not return anything, modify tree in-place instead.\\n */\\nvar connect = function(root) {\\n    if (!root || !root.left) { // sanity check\\n        return;\\n    }\\n    \\n    root.left.next = root.right;                         // connect left -> right\\n    root.right.next = root.next ? root.next.left : null; // connect right -> next's left\\n    \\n    connect(root.left);\\n    connect(root.right);\\n};\\n```\\nTime complexity: `O(n)`\\nSpace complexity: `O(1)`",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {TreeLinkNode} root\\n * @return {void} Do not return anything, modify tree in-place instead.\\n */\\nvar connect = function(root) {\\n    if (!root || !root.left) { // sanity check\\n        return;\\n    }\\n    \\n    root.left.next = root.right;                         // connect left -> right\\n    root.right.next = root.next ? root.next.left : null; // connect right -> next's left\\n    \\n    connect(root.left);\\n    connect(root.right);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 747756,
                "title": "very-easy-to-understand-recursive-method",
                "content": "Simple recursive solution accepted\\n```\\nclass Solution {\\npublic:\\n    \\n    void solve(Node* l, Node* r){\\n        \\n        if(l == NULL || r == NULL) return;\\n        \\n        l->next = r;\\n        r->next = NULL;\\n        \\n        solve(l->left, l->right);\\n        solve(l->right, r->left);\\n        solve(r->left, r->right);\\n    }\\n    \\n    \\n    Node* connect(Node* root) {\\n        if(root == NULL) return NULL;\\n        if(root->left == NULL) return root;\\n        \\n        solve(root->left, root->right);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void solve(Node* l, Node* r){\\n        \\n        if(l == NULL || r == NULL) return;\\n        \\n        l->next = r;\\n        r->next = NULL;\\n        \\n        solve(l->left, l->right);\\n        solve(l->right, r->left);\\n        solve(r->left, r->right);\\n    }\\n    \\n    \\n    Node* connect(Node* root) {\\n        if(root == NULL) return NULL;\\n        if(root->left == NULL) return root;\\n        \\n        solve(root->left, root->right);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153086,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    # @param root, a tree link node\\n    # @return nothing\\n    def helper(self, left, right):\\n        if not left or not right:\\n            return\\n        \\n        left.next = right\\n        self.helper(left.right, right.left)\\n        self.helper(left.left, left.right)\\n        self.helper(right.left, right.right)\\n    \\n    def connect(self, root):\\n        if not root:\\n            return\\n    \\n        self.helper(root.left, root.right)\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # @param root, a tree link node\\n    # @return nothing\\n    def helper(self, left, right):\\n        if not left or not right:\\n            return\\n        \\n        left.next = right\\n        self.helper(left.right, right.left)\\n        self.helper(left.left, left.right)\\n        self.helper(right.left, right.right)\\n    \\n    def connect(self, root):\\n        if not root:\\n            return\\n    \\n        self.helper(root.left, root.right)\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 37458,
                "title": "c-recursive-solution",
                "content": "```\\n    void connect(TreeLinkNode *root) {\\n        if(!root) return;\\n        if(root->left){\\n            root->left->next = root->right;\\n            root->right->next = root->next? root->next->left : NULL;\\n        }\\n        connect(root->left);\\n        connect(root->right);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void connect(TreeLinkNode *root) {\\n        if(!root) return;\\n        if(root->left){\\n            root->left->next = root->right;\\n            root->right->next = root->next? root->next->left : NULL;\\n        }\\n        connect(root->left);\\n        connect(root->right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37705,
                "title": "python-accepted-code",
                "content": "    def connect(self, root):\\n        if not root: return\\n        while root.left:\\n            cur = root.left\\n            prev = None\\n            while root:\\n                if prev: prev.next = root.left\\n                root.left.next = root.right\\n                prev = root.right\\n                root = root.next\\n            root = cur",
                "solutionTags": [],
                "code": "    def connect(self, root):\\n        if not root: return\\n        while root.left:\\n            cur = root.left\\n            prev = None\\n            while root:\\n                if prev: prev.next = root.left\\n                root.left.next = root.right\\n                prev = root.right\\n                root = root.next\\n            root = cur",
                "codeTag": "Python3"
            },
            {
                "id": 37663,
                "title": "an-iterative-java-solution",
                "content": "    public void connect(TreeLinkNode root) {\\n        \\n        TreeLinkNode n = root;\\n        \\n        while(n != null && n.left != null) {\\n            TreeLinkNode pre = null;\\n            \\n            for(TreeLinkNode p = n; p != null; p = p.next) {\\n                if(pre != null) pre.next = p.left;\\n                p.left.next = p.right;\\n                pre = p.right;\\n            }\\n            n = n.left;\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public void connect(TreeLinkNode root) {\\n        \\n        TreeLinkNode n = root;\\n        \\n        while(n != null && n.left != null) {\\n            TreeLinkNode pre = null;\\n            \\n            for(TreeLinkNode p = n; p != null; p = p.next) {\\n                if(pre != null) pre.next = p.left;\\n                p.left.next = p.right;\\n                pre = p.right;\\n            }\\n            n = n.left;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1480173,
                "title": "javascript-dfs-extremely-simple-and-understandable",
                "content": "DFS, pass down rightnode\\'s left pointer if it exists, otherwise null.\\n```\\nvar connect = function(root, rightNode = null) {\\n    if (!root) return root;\\n    \\n    root.next = rightNode;\\n    connect(root.left, root.right);\\n    connect(root.right, rightNode ? rightNode.left : null);\\n    \\n    return root;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar connect = function(root, rightNode = null) {\\n    if (!root) return root;\\n    \\n    root.next = rightNode;\\n    connect(root.left, root.right);\\n    connect(root.right, rightNode ? rightNode.left : null);\\n    \\n    return root;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 156384,
                "title": "javascript-bfs",
                "content": "```\\nvar connect = function(root) {\\n    if(!root) return;\\n    const queue = [root];\\n    \\n    while(queue.length) {\\n        const size  = queue.length;\\n        const level = queue.slice();\\n\\n        for(let i = 0; i < size; i++) {\\n            const currentNode = queue.shift();\\n            currentNode.next  = level[i + 1];\\n            if(currentNode.left)  queue.push(currentNode.left);\\n            if(currentNode.right) queue.push(currentNode.right);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar connect = function(root) {\\n    if(!root) return;\\n    const queue = [root];\\n    \\n    while(queue.length) {\\n        const size  = queue.length;\\n        const level = queue.slice();\\n\\n        for(let i = 0; i < size; i++) {\\n            const currentNode = queue.shift();\\n            currentNode.next  = level[i + 1];\\n            if(currentNode.left)  queue.push(currentNode.left);\\n            if(currentNode.right) queue.push(currentNode.right);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37600,
                "title": "5-line-1ms-java-iterative-solution-o-n-time-o-1-space",
                "content": "    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) { return; }\\n            for (TreeLinkNode head=root; head.left!=null; head=head.left) {\\n                for (TreeLinkNode parent=head; parent!=null; parent=parent.next) {\\n                    parent.left.next = parent.right;\\n                    if (parent.next != null) { parent.right.next = parent.next.left; }\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) { return; }",
                "codeTag": "Java"
            },
            {
                "id": 1932092,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for a Node.\\n * public class Node {\\n *     public var val: Int\\n *     public var left: Node?\\n *     public var right: Node?\\n *\\t   public var next: Node?\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.left = nil\\n *         self.right = nil\\n *         self.next = nil\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(1), only constant space is used.\\n\\n    func connect(_ root: Node?) -> Node? {\\n        var leftMost = root\\n\\n        while leftMost?.left != nil {\\n            var head = leftMost\\n            while head != nil {\\n                head?.left?.next = head?.right\\n                if let next = head?.next {\\n                    head?.right?.next = next.left\\n                }\\n                head = head?.next\\n            }\\n            leftMost = leftMost?.left\\n        }\\n\\n        return root\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * public class Node {\\n *     public var val: Int\\n *     public var left: Node?\\n *     public var right: Node?\\n *\\t   public var next: Node?\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.left = nil\\n *         self.right = nil\\n *         self.next = nil\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(1), only constant space is used.\\n\\n    func connect(_ root: Node?) -> Node? {\\n        var leftMost = root\\n\\n        while leftMost?.left != nil {\\n            var head = leftMost\\n            while head != nil {\\n                head?.left?.next = head?.right\\n                if let next = head?.next {\\n                    head?.right?.next = next.left\\n                }\\n                head = head?.next\\n            }\\n            leftMost = leftMost?.left\\n        }\\n\\n        return root\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653811,
                "title": "python-solution-recursive-elegant-solution",
                "content": "I thought that this solution was a little different to the others posted, most of them doing a level order search using the next pointer. However here, I have recursively split the tree into \\'pincer\\' segments (this is what I call them because I don\\'t know the name), at each level the pair is made up of 1. the right most node of that level in the left node\\'s subtree & 2. the left most node of that level in the right node\\'s subtree - and then connected node 1 to node 2 at each level.\\n\\n```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root:\\n            return\\n        \\n        c1, c2 = root.left, root.right\\n        \\n        while c1 and c2:\\n            c1.next = c2\\n            c1, c2 = c1.right, c2.left\\n        \\n        self.connect(root.left)\\n        self.connect(root.right)\\n        \\n        return root\\n```\\n\\t\\nThe idea being, that I could simply connect a node\\'s left child to it\\'s right child, with the only difficulty being to find the \\'next\\' node of a right child. The \\'pincer\\' segments help resolve this issue, as the \\'next\\' node of a right child is simply the other node in that level of the \\'pincer\\'\\n\\nI\\'m not quite sure the if there is a specific name for this general idea, and would be very appreciative if anyone knows what it is Hope this helps!\\n\\nEDIT: A diagram illustrating the \\'pincer segments\\' of each of the first three nodes, and the pointers created by each - in red, blue and green respectively. Note that each node not on the left or right \\'boundary\\' is visited by two other \\'pincer segments\\', as is necessary since each node should have a pointer coming in and one coming out.\\n\\n![image](https://assets.leetcode.com/users/images/3e380898-de6f-4ab5-89e6-8a618ff56199_1640908417.4581368.jpeg)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root:\\n            return\\n        \\n        c1, c2 = root.left, root.right\\n        \\n        while c1 and c2:\\n            c1.next = c2\\n            c1, c2 = c1.right, c2.left\\n        \\n        self.connect(root.left)\\n        self.connect(root.right)\\n        \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37719,
                "title": "accepted-java-recursive-solution",
                "content": "The recursive solution of my last post, although the space is not O(1) (due to recursion), the solution is still elegant.\\n\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) return;\\n            \\n            if (root.left != null) {\\n                root.left.next = root.right;\\n            }\\n            \\n            if (root.right != null) {\\n                root.right.next = root.next != null ? root.next.left : null;\\n            }\\n            \\n            connect(root.left);\\n            connect(root.right);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) return;\\n            \\n            if (root.left != null) {\\n                root.left.next = root.right;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 37744,
                "title": "a-concise-o-1-space-complexity-solution",
                "content": "it fits problem 1 and 2, any comments will be welcome, thanks\\n\\n    void connect(TreeLinkNode *root) {\\n        TreeLinkNode *head = root; // the left first node in every level\\n        TreeLinkNode *cur = NULL;  // the current node in the upper level\\n        TreeLinkNode *pre = NULL;  // the prev node in the downer level\\n        \\n        while (head) {\\n            cur = head;\\n            head = pre = NULL;\\n            // travel one level in a loop\\n            while (cur) {\\n                // left child exist\\n                if (cur->left) {\\n                    if (pre) pre = pre->next = cur->left;\\n                    else head = pre = cur->left;\\n                    \\n                }\\n                // right child exist\\n                if (cur->right) {\\n                    if (pre) pre = pre->next = cur->right;\\n                    else head = pre = cur->right;\\n                }\\n                // next node in the same level\\n                cur = cur->next;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "it fits problem 1 and 2, any comments will be welcome, thanks\\n\\n    void connect(TreeLinkNode *root) {\\n        TreeLinkNode *head = root; // the left first node in every level\\n        TreeLinkNode *cur = NULL;  // the current node in the upper level\\n        TreeLinkNode *pre = NULL;  // the prev node in the downer level\\n        \\n        while (head) {\\n            cur = head;\\n            head = pre = NULL;\\n            // travel one level in a loop\\n            while (cur) {\\n                // left child exist\\n                if (cur->left) {\\n                    if (pre) pre = pre->next = cur->left;\\n                    else head = pre = cur->left;\\n                    \\n                }\\n                // right child exist\\n                if (cur->right) {\\n                    if (pre) pre = pre->next = cur->right;\\n                    else head = pre = cur->right;\\n                }\\n                // next node in the same level\\n                cur = cur->next;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2191294,
                "title": "java-solution-simple-bfs-traversal-very-easy-iterative-solution",
                "content": "```\\nclass Solution {\\n\\n    public Node connect(Node root) {\\n        if (root == null) return root;\\n        Queue<Node> q = new LinkedList<>();\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Node curr = q.poll();\\n                if (curr.left != null) q.add(curr.left);\\n                if (curr.right != null) q.add(curr.right);\\n                if (i == size - 1) curr.next = null; else curr.next = q.peek();\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n\\n    public Node connect(Node root) {\\n        if (root == null) return root;\\n        Queue<Node> q = new LinkedList<>();\\n        q.add(root);\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Node curr = q.poll();\\n                if (curr.left != null) q.add(curr.left);\\n                if (curr.right != null) q.add(curr.right);\\n                if (i == size - 1) curr.next = null; else curr.next = q.peek();\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040150,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        if(root.left != null) root.left.next = root.right;\\n        if(root.right != null && root.next != null) root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root && root->left != NULL) {\\n            root->left->next = root->right;\\n            connect(root->left);\\n            if(root->next != NULL) root->right->next = root->next->left;\\n            connect(root->right);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # edge case check\\n        if not root:\\n            return None\\n        \\n        node = root # create a pointer to the root node\\n        \\n        # iterate only until we have a new level (because the connections for Nth level are done when we are at N-1th level)\\n        while node.left:\\n            head = node\\n            while head:\\n                head.left.next = head.right\\n                if head.next:\\n                    head.right.next = head.next.left\\n                    \\n                head = head.next\\n                \\n            node = node.left\\n\\n        return root\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar connect = function(root) {\\n    let ptr = root;\\n    while(root && root.left){\\n        let temp = root;\\n        while(temp) {\\n            temp.left.next = temp.right;\\n            temp.right.next = temp.next ? temp.next.left : null;\\n            temp = temp.next;\\n        }\\n        root = root.left;\\n    }\\n    return ptr;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun connect(root: Node?): Node? =\\n        if (root?.left == null && root?.right == null) root  //at bottom of tree      \\n        else root?.apply {  //connect next and recurse downwards\\n            left?.next = right\\n            right?.next = next?.left\\n            connect(left)\\n            connect(right)\\n        }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(1), only constant space is used.\\n\\n    func connect(_ root: Node?) -> Node? {\\n        var leftMost = root\\n\\n        while leftMost?.left != nil {\\n            var head = leftMost\\n            while head != nil {\\n                head?.left?.next = head?.right\\n                if let next = head?.next {\\n                    head?.right?.next = next.left\\n                }\\n                head = head?.next\\n            }\\n            leftMost = leftMost?.left\\n        }\\n\\n        return root\\n    }\\n\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        if(root.left != null) root.left.next = root.right;\\n        if(root.right != null && root.next != null) root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root && root->left != NULL) {\\n            root->left->next = root->right;\\n            connect(root->left);\\n            if(root->next != NULL) root->right->next = root->next->left;\\n            connect(root->right);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # edge case check\\n        if not root:\\n            return None\\n        \\n        node = root # create a pointer to the root node\\n        \\n        # iterate only until we have a new level (because the connections for Nth level are done when we are at N-1th level)\\n        while node.left:\\n            head = node\\n            while head:\\n                head.left.next = head.right\\n                if head.next:\\n                    head.right.next = head.next.left\\n                    \\n                head = head.next\\n                \\n            node = node.left\\n\\n        return root\\n```\n```\\n```\n```\\n```\n```\\nvar connect = function(root) {\\n    let ptr = root;\\n    while(root && root.left){\\n        let temp = root;\\n        while(temp) {\\n            temp.left.next = temp.right;\\n            temp.right.next = temp.next ? temp.next.left : null;\\n            temp = temp.next;\\n        }\\n        root = root.left;\\n    }\\n    return ptr;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun connect(root: Node?): Node? =\\n        if (root?.left == null && root?.right == null) root  //at bottom of tree      \\n        else root?.apply {  //connect next and recurse downwards\\n            left?.next = right\\n            right?.next = next?.left\\n            connect(left)\\n            connect(right)\\n        }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the binary tree.\\n    //   - space: O(1), only constant space is used.\\n\\n    func connect(_ root: Node?) -> Node? {\\n        var leftMost = root\\n\\n        while leftMost?.left != nil {\\n            var head = leftMost\\n            while head != nil {\\n                head?.left?.next = head?.right\\n                if let next = head?.next {\\n                    head?.right?.next = next.left\\n                }\\n                head = head?.next\\n            }\\n            leftMost = leftMost?.left\\n        }\\n\\n        return root\\n    }\\n\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719347,
                "title": "python-solution-o-1-and-o-n-memory",
                "content": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # edge case check\\n        if not root:\\n            return None\\n        \\n        # initialize the queue with root node (for level order traversal)\\n        queue = collections.deque([root])\\n        \\n        # start the traversal\\n        while queue:\\n            size = len(queue) # get number of nodes on the current level\\n            for i in range(size):\\n                node = queue.popleft() # pop the node\\n                \\n                # An important check so that we do not wire the node to the node on the next level.\\n                if i < size-1:\\n                    node.next = queue[0] # because the right node of the popped node would be the next in the queue. \\n                    \\n                if node.left:\\n                    queue.append(node.left) \\n                if node.right:\\n                    queue.append(node.right)           \\n                \\n        return root\\n```\\n\\nO(1) Memory solution:\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # edge case check\\n        if not root:\\n            return None\\n        \\n        node = root # create a pointer to the root node\\n        \\n        # iterate only until we have a new level (because the connections for Nth level are done when we are at N-1th level)\\n        while node.left:\\n            head = node\\n            while head:\\n                head.left.next = head.right\\n                if head.next:\\n                    head.right.next = head.next.left\\n                    \\n                head = head.next\\n                \\n            node = node.left\\n\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # edge case check\\n        if not root:\\n            return None\\n        \\n        # initialize the queue with root node (for level order traversal)\\n        queue = collections.deque([root])\\n        \\n        # start the traversal\\n        while queue:\\n            size = len(queue) # get number of nodes on the current level\\n            for i in range(size):\\n                node = queue.popleft() # pop the node\\n                \\n                # An important check so that we do not wire the node to the node on the next level.\\n                if i < size-1:\\n                    node.next = queue[0] # because the right node of the popped node would be the next in the queue. \\n                    \\n                if node.left:\\n                    queue.append(node.left) \\n                if node.right:\\n                    queue.append(node.right)           \\n                \\n        return root\\n```\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        # edge case check\\n        if not root:\\n            return None\\n        \\n        node = root # create a pointer to the root node\\n        \\n        # iterate only until we have a new level (because the connections for Nth level are done when we are at N-1th level)\\n        while node.left:\\n            head = node\\n            while head:\\n                head.left.next = head.right\\n                if head.next:\\n                    head.right.next = head.next.left\\n                    \\n                head = head.next\\n                \\n            node = node.left\\n\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37606,
                "title": "java-recursive-and-iterative-solutions",
                "content": "        \\n    // dfs iteratively \\n    public void connect1(TreeLinkNode root) {\\n        Stack<TreeLinkNode> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeLinkNode n = stack.pop();\\n            if (n != null) {\\n                if (n.right != null) {\\n                    n.left.next = n.right;\\n                    if (n.next != null) {\\n                        n.right.next = n.next.left;\\n                    }\\n                }\\n                stack.push(n.right);\\n                stack.push(n.left);\\n            }\\n        }\\n    }\\n    \\n    // bfs iteratively\\n    public void connect2(TreeLinkNode root) {\\n        Queue<TreeLinkNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty()) {\\n            TreeLinkNode n = queue.poll();\\n            if (n != null) {\\n                if (n.right != null) {\\n                    n.left.next = n.right;\\n                    if (n.next != null) {\\n                        n.right.next = n.next.left;\\n                    }\\n                }\\n                queue.add(n.left);\\n                queue.add(n.right);\\n            }\\n        }\\n    }\\n    \\n    // dfs recursively\\n    public void connect(TreeLinkNode root) {\\n        if (root != null) {\\n            if (root.right != null) {\\n                root.left.next = root.right;\\n                if (root.next != null) {\\n                    root.right.next = root.next.left;\\n                } \\n            }\\n            connect(root.left);\\n            connect(root.right);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // dfs iteratively \\n    public void connect1(TreeLinkNode root) {\\n        Stack<TreeLinkNode> stack = new Stack<>();\\n        stack.push(root);\\n        while (!stack.isEmpty()) {\\n            TreeLinkNode n = stack.pop();\\n            if (n != null) {\\n                if (n.right != null) {\\n                    n.left.next = n.right;\\n                    if (n.next != null) {\\n                        n.right.next = n.next.left;\\n                    }\\n                }\\n                stack.push(n.right);\\n                stack.push(n.left);\\n            }\\n        }\\n    }\\n    \\n    // bfs iteratively\\n    public void connect2(TreeLinkNode root) {\\n        Queue<TreeLinkNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(!queue.isEmpty()) {\\n            TreeLinkNode n = queue.poll();\\n            if (n != null) {\\n                if (n.right != null) {\\n                    n.left.next = n.right;\\n                    if (n.next != null) {\\n                        n.right.next = n.next.left;\\n                    }\\n                }\\n                queue.add(n.left);\\n                queue.add(n.right);\\n            }\\n        }\\n    }\\n    \\n    // dfs recursively\\n    public void connect(TreeLinkNode root) {\\n        if (root != null) {\\n            if (root.right != null) {\\n                root.left.next = root.right;\\n                if (root.next != null) {\\n                    root.right.next = root.next.left;\\n                } \\n            }\\n            connect(root.left);\\n            connect(root.right);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3617528,
                "title": "o-1-space-simple-bfs-java-solution-and-without-recursion",
                "content": "Intution: Treating level of tree is as linked list.\\n1. From parent level connect children level node as linked list and parent level is already connected so we can move to next node of parent to connect other children node.\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node head = root;\\n         for(head = root; head != null;){\\n             \\n             if(head.left == null){                  // if left is null then it means no children nodes to connect now\\n                 return root;\\n             }\\n             Node prev = null;\\n             Node curr = head;                      //curr always pointing starting node of every level in starting\\n             \\n             while(curr != null){\\n                 \\n                if(prev != null)                             //  for first node of every level, prev pointing to null\\n                prev.right.next = curr.left;          //connect prev node right to curr left node\\n                curr.left.next = curr.right;          // connect same children nodes of parent \\n                 \\n                 prev = curr;                              // move prev and curr node to next node\\n                 curr = curr.next;\\n             }\\n             head = head.left;                        // move head to next level\\n         }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node head = root;\\n         for(head = root; head != null;){\\n             \\n             if(head.left == null){                  // if left is null then it means no children nodes to connect now\\n                 return root;\\n             }\\n             Node prev = null;\\n             Node curr = head;                      //curr always pointing starting node of every level in starting\\n             \\n             while(curr != null){\\n                 \\n                if(prev != null)                             //  for first node of every level, prev pointing to null\\n                prev.right.next = curr.left;          //connect prev node right to curr left node\\n                curr.left.next = curr.right;          // connect same children nodes of parent \\n                 \\n                 prev = curr;                              // move prev and curr node to next node\\n                 curr = curr.next;\\n             }\\n             head = head.left;                        // move head to next level\\n         }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954109,
                "title": "c-java-python-bfs-o-n-time-o-1-space",
                "content": "I hope the comments are explicit enough to tell about the iterative BFS approach that is used here.\\nTime complexity - O(n)\\nSpace complexity - O(1)\\n\\nC++ \\n\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        Node* current = root;\\n        while(current) {\\n            // this will always be the first node of any level\\n            Node* level1stNode = current;\\n            // this runs until we iterate over all the nodes of any level\\n            while(current) {\\n                // this links the child nodes (L child -> next = R child) of the same parent node\\n                if(current->left) {\\n                    current->left->next = current->right;\\n                }\\n                // this checks whether there are more nodes towards right at the same level\\n                if(current->right && current->next) {\\n                    current->right->next = current->next->left;\\n                }\\n                // move on the next node of the current level (L -> R)\\n                current = current->next;\\n            }\\n            // move onto the first node of the next level\\n            current = level1stNode->left;\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\nJava\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Node current = root;\\n        while(current != null) {\\n\\t\\t\\t// this will always be the first node of any level\\n            Node level1stNode = current;\\n\\t\\t\\t// this runs until we iterate over all the nodes of any level\\n            while(current != null) {\\n\\t\\t\\t\\t// this links the child nodes (L child -> next = R child) of the same parent node\\n                if(current.left != null) {\\n                    current.left.next = current.right;\\n                }\\n\\t\\t\\t\\t// this checks whether there are more nodes towards right at the same level\\n                if(current.right != null && current.next != null) {\\n                    current.right.next = current.next.left;\\n                }\\n\\t\\t\\t\\t// move on the next node of the current level (L -> R)\\n                current = current.next;\\n            }\\n\\t\\t\\t// move onto the first node of the next level\\n            current = level1stNode.left;\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\nPython\\n\\n```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root: return root\\n        \\n        self.current = root\\n        \\n        while self.current:\\n            \\n            # this will always be the first node of any level\\n            self.level1stNode = self.current\\n            \\n            # this runs until we iterate over all the nodes of any level\\n            while self.current:\\n                \\n                # this links the child nodes (L child -> next = R child) of the same parent node\\n                if self.current.left:\\n                    self.current.left.next = self.current.right\\n                    \\n                # this checks whether there are more nodes towards right at the same level\\n                if self.current.right and self.current.next:\\n                    self.current.right.next = self.current.next.left\\n                    \\n                # move on the next node of the current level (L -> R)\\n                self.current = self.current.next\\n            \\n            # move onto the first node of the next level\\n            self.current = self.level1stNode.left\\n            \\n        return root\\n```\\n\\n\\uD83D\\uDE80 Thanks for reading. \\nAn upvote would be appreciated.  ^_^\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        Node* current = root;\\n        while(current) {\\n            // this will always be the first node of any level\\n            Node* level1stNode = current;\\n            // this runs until we iterate over all the nodes of any level\\n            while(current) {\\n                // this links the child nodes (L child -> next = R child) of the same parent node\\n                if(current->left) {\\n                    current->left->next = current->right;\\n                }\\n                // this checks whether there are more nodes towards right at the same level\\n                if(current->right && current->next) {\\n                    current->right->next = current->next->left;\\n                }\\n                // move on the next node of the current level (L -> R)\\n                current = current->next;\\n            }\\n            // move onto the first node of the next level\\n            current = level1stNode->left;\\n        }\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Node current = root;\\n        while(current != null) {\\n\\t\\t\\t// this will always be the first node of any level\\n            Node level1stNode = current;\\n\\t\\t\\t// this runs until we iterate over all the nodes of any level\\n            while(current != null) {\\n\\t\\t\\t\\t// this links the child nodes (L child -> next = R child) of the same parent node\\n                if(current.left != null) {\\n                    current.left.next = current.right;\\n                }\\n\\t\\t\\t\\t// this checks whether there are more nodes towards right at the same level\\n                if(current.right != null && current.next != null) {\\n                    current.right.next = current.next.left;\\n                }\\n\\t\\t\\t\\t// move on the next node of the current level (L -> R)\\n                current = current.next;\\n            }\\n\\t\\t\\t// move onto the first node of the next level\\n            current = level1stNode.left;\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root: return root\\n        \\n        self.current = root\\n        \\n        while self.current:\\n            \\n            # this will always be the first node of any level\\n            self.level1stNode = self.current\\n            \\n            # this runs until we iterate over all the nodes of any level\\n            while self.current:\\n                \\n                # this links the child nodes (L child -> next = R child) of the same parent node\\n                if self.current.left:\\n                    self.current.left.next = self.current.right\\n                    \\n                # this checks whether there are more nodes towards right at the same level\\n                if self.current.right and self.current.next:\\n                    self.current.right.next = self.current.next.left\\n                    \\n                # move on the next node of the current level (L -> R)\\n                self.current = self.current.next\\n            \\n            # move onto the first node of the next level\\n            self.current = self.level1stNode.left\\n            \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934059,
                "title": "c-99-100-memory-5-liner-recursively-crispy-af",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root and root->left) {\\n            root->left->next = root->right;\\n            auto c1 = root->left, c2 = root->right;\\n            while(c1->right) c1->right->next = c2->left, c1 = c1->right, c2 = c2->left;\\n            root->left = connect(root->left), root->right = connect(root->right);\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\nExplanation -\\n1. Traverse tree\\n2. Make given connections\\n3. ???\\n4. Profit!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root and root->left) {\\n            root->left->next = root->right;\\n            auto c1 = root->left, c2 = root->right;\\n            while(c1->right) c1->right->next = c2->left, c1 = c1->right, c2 = c2->left;\\n            root->left = connect(root->left), root->right = connect(root->right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956337,
                "title": "c-beats-97-explained-using-level-order-traversal",
                "content": "# Best Solution for Beginners\\nWe can solve this using Level order Traversal.\\n\\n    Runtime - 97.14%\\uD83D\\uDD25 \\n\\n# Approach\\n1. Firstly We will do Level Order Travesal.\\n2. Then at Each Level we will join all nodes present at that Level.\\n\\n#  If you like the solution and understand it then Please Upvote.\\u2B06\\uFE0F\\u2764\\uFE0F \\n\\t* PEACE OUT LUV\\u270C\\uFE0F*\\n\\n# Code\\n```\\n/*\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL){\\n            return root;\\n        }\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<Node*>ans;\\n            for(int i=0; i<size; i++){\\n                Node* node = q.front();\\n                q.pop();\\n                if(node ->left)q.push(node ->left);\\n                if(node ->right)q.push(node ->right);\\n                ans.push_back(node);\\n            }\\n            for(int i=1; i<ans.size(); i++){\\n                ans[i-1] ->next = ans[i];\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL){\\n            return root;\\n        }\\n        queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size();\\n            vector<Node*>ans;\\n            for(int i=0; i<size; i++){\\n                Node* node = q.front();\\n                q.pop();\\n                if(node ->left)q.push(node ->left);\\n                if(node ->right)q.push(node ->right);\\n                ans.push_back(node);\\n            }\\n            for(int i=1; i<ans.size(); i++){\\n                ans[i-1] ->next = ans[i];\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779810,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node*> q;\\n        if (root) q.push(root);\\n        while (q.size()) {\\n            int len = q.size();\\n            Node* curr;\\n            while (len--) {\\n                curr = q.front(), q.pop();\\n                curr->next = len ? q.front():NULL;\\n                if (curr->left) q.push(curr->left);\\n                if (curr->right) q.push(curr->right);         \\n            }\\n        }         \\n        return root;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node*> q;\\n        if (root) q.push(root);\\n        while (q.size()) {\\n            int len = q.size();\\n            Node* curr;\\n            while (len--) {\\n                curr = q.front(), q.pop();\\n                curr->next = len ? q.front():NULL;\\n                if (curr->left) q.push(curr->left);\\n                if (curr->right) q.push(curr->right);         \\n            }\\n        }         \\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720678,
                "title": "0ms-100-faster-java-code",
                "content": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Node left = root.left;\\n        Node right = root.right;\\n        while(left != null){\\n            left.next = right;\\n            left = left.right;\\n            right = right.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Node left = root.left;\\n        Node right = root.right;\\n        while(left != null){\\n            left.next = right;\\n            left = left.right;\\n            right = right.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764851,
                "title": "java-bfs-and-dfs-4-solutions",
                "content": "```\\n\\t//DFS\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(log n), for recursion stack of a perfect BST\\n\\tpublic Node connect(Node root) {\\n        if(root == null)\\n            return root;\\n        dfs(root);\\n        return root;\\n    }\\n    \\n    private void dfs(Node root) {\\n        // base\\n        if(root.left == null)\\n            return;\\n        \\n        root.left.next = root.right;\\n        dfs(root.left);\\n        if(root.next != null)\\n            root.right.next = root.next.left;\\n        dfs(root.right);\\n    }\\n```\\n```\\n\\t//DFS\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(log n), for recursion stack of a perfect BST\\n\\tpublic Node connect1(Node root) {\\n        if(root == null)\\n            return root;\\n        conn(root.left, root.right);\\n        return root;\\n    }\\n    \\n    private void conn(Node left, Node right) {\\n        if(left == null)\\n            return;\\n        \\n        left.next = right;\\n        conn(left.left, left. right);\\n        conn(left.right, right.left);\\n        conn(right.left, right.right);\\n    }\\n```\\n```\\n    //BFS\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(1)\\n\\tpublic Node connect2(Node root) {\\n        if(root == null)\\n            return root;\\n        \\n        Node level = root;\\n        while(level.left != null) {\\n            Node curr = level;\\n            while(curr != null) {\\n                curr.left.next = curr.right;\\n                if(curr.next != null)\\n                    curr.right.next = curr.next.left;\\n                curr = curr.next;\\n            }\\n            level = level.left;\\n        }\\n        return root;\\n    }\\n```\\n```\\n\\t//BFS using Queue\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(n), for queue\\n\\tpublic Node connect3(Node root) {\\n\\t\\tif(root == null)\\n\\t\\t\\treturn root;\\n\\t\\tQueue<Node> q = new LinkedList<>();\\n\\t\\tq.offer(root);\\n\\n\\t\\twhile(!q.isEmpty()) {\\n\\t\\t\\tint size = q.size();\\n\\t\\t\\tNode prev = q.poll();\\n\\t\\t\\tif(prev.left != null) {\\n\\t\\t\\t\\tq.offer(prev.left);\\n\\t\\t\\t\\tq.offer(prev.right);\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=1; i<size; i++) {\\n\\t\\t\\t\\tNode curr = q.poll();\\n\\t\\t\\t\\tprev.next = curr;\\n\\t\\t\\t\\tif(curr.left != null) {\\n\\t\\t\\t\\t\\tq.offer(curr.left);\\n\\t\\t\\t\\t\\tq.offer(curr.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tprev = curr;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn root;\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n\\t//DFS\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(log n), for recursion stack of a perfect BST\\n\\tpublic Node connect(Node root) {\\n        if(root == null)\\n            return root;\\n        dfs(root);\\n        return root;\\n    }\\n    \\n    private void dfs(Node root) {\\n        // base\\n        if(root.left == null)\\n            return;\\n        \\n        root.left.next = root.right;\\n        dfs(root.left);\\n        if(root.next != null)\\n            root.right.next = root.next.left;\\n        dfs(root.right);\\n    }\\n```\n```\\n\\t//DFS\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(log n), for recursion stack of a perfect BST\\n\\tpublic Node connect1(Node root) {\\n        if(root == null)\\n            return root;\\n        conn(root.left, root.right);\\n        return root;\\n    }\\n    \\n    private void conn(Node left, Node right) {\\n        if(left == null)\\n            return;\\n        \\n        left.next = right;\\n        conn(left.left, left. right);\\n        conn(left.right, right.left);\\n        conn(right.left, right.right);\\n    }\\n```\n```\\n    //BFS\\n\\t//Time Complexity : O(n), where n is the number of elements in root\\n\\t//Space Complexity : O(1)\\n\\tpublic Node connect2(Node root) {\\n        if(root == null)\\n            return root;\\n        \\n        Node level = root;\\n        while(level.left != null) {\\n            Node curr = level;\\n            while(curr != null) {\\n                curr.left.next = curr.right;\\n                if(curr.next != null)\\n                    curr.right.next = curr.next.left;\\n                curr = curr.next;\\n            }\\n            level = level.left;\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 934355,
                "title": "populating-next-right-pointer-in-each-node-c-easy-to-understand",
                "content": "```\\nclass Solution {\\n\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL || root->left == NULL) return root;\\n        \\n        \\n        if(root->next != NULL){\\n            root->right->next=root->next->left;\\n        }\\n        \\n        root->left->next = root->right;\\n        \\n        connect(root->left);\\n        connect(root->right);\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL || root->left == NULL) return root;\\n        \\n        \\n        if(root->next != NULL){\\n            root->right->next=root->next->left;\\n        }\\n        \\n        root->left->next = root->right;\\n        \\n        connect(root->left);\\n        connect(root->right);\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934184,
                "title": "python-time-o-n-space-o-1-concise-real-o-1-solution",
                "content": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if (head:=root):\\n            while (start:=root.left):\\n                while root:\\n                    root.left.next = root.right\\n                    root.right.next = root.next.left if root.next else None\\n                    root = root.next\\n                root = start\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if (head:=root):\\n            while (start:=root.left):\\n                while root:\\n                    root.left.next = root.right\\n                    root.right.next = root.next.left if root.next else None\\n                    root = root.next\\n                root = start\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561417,
                "title": "go-recursive-and-iterative",
                "content": "Recursive:\\n```\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    if root.Left != nil {\\n        root.Left.Next = root.Right\\n        if root.Next != nil {\\n            root.Right.Next = root.Next.Left\\n        }\\n    }\\n    \\n    connect(root.Left)\\n    connect(root.Right)\\n    \\n    return root\\n}\\n```\\n\\nIterative (BFS with Queue):\\n```\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    type entry struct{\\n        level int\\n        node *Node\\n    }\\n    \\n    var queue []entry\\n    \\n    var prev *Node\\n    currLevel := -1\\n    \\n    queue = append(queue, entry{level: 0, node: root})\\n    \\n    for len(queue) != 0 {\\n        curr := queue[0]\\n        queue = queue[1:]\\n        \\n        if currLevel != curr.level {\\n            if prev != nil {\\n                prev.Next = nil\\n            }\\n            currLevel = curr.level\\n        } else {\\n            prev.Next = curr.node\\n        }\\n        \\n        prev = curr.node\\n        \\n        if curr.node.Left != nil {\\n            queue = append(queue, entry{level: curr.level+1, node: curr.node.Left})\\n        }\\n        \\n        if curr.node.Right != nil {\\n            queue = append(queue, entry{level: curr.level+1, node: curr.node.Right})\\n        }\\n    }\\n    \\n    return root\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    if root.Left != nil {\\n        root.Left.Next = root.Right\\n        if root.Next != nil {\\n            root.Right.Next = root.Next.Left\\n        }\\n    }\\n    \\n    connect(root.Left)\\n    connect(root.Right)\\n    \\n    return root\\n}\\n```\n```\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    type entry struct{\\n        level int\\n        node *Node\\n    }\\n    \\n    var queue []entry\\n    \\n    var prev *Node\\n    currLevel := -1\\n    \\n    queue = append(queue, entry{level: 0, node: root})\\n    \\n    for len(queue) != 0 {\\n        curr := queue[0]\\n        queue = queue[1:]\\n        \\n        if currLevel != curr.level {\\n            if prev != nil {\\n                prev.Next = nil\\n            }\\n            currLevel = curr.level\\n        } else {\\n            prev.Next = curr.node\\n        }\\n        \\n        prev = curr.node\\n        \\n        if curr.node.Left != nil {\\n            queue = append(queue, entry{level: curr.level+1, node: curr.node.Left})\\n        }\\n        \\n        if curr.node.Right != nil {\\n            queue = append(queue, entry{level: curr.level+1, node: curr.node.Right})\\n        }\\n    }\\n    \\n    return root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2991023,
                "title": "c-2-methods-with-logic-bfs-traversal-clean-code",
                "content": "***Method -1 [Naive Method]***\\n\\n![image](https://assets.leetcode.com/users/images/c1e0a6f5-6652-42c9-be2d-d4dd6b797b16_1672731185.2271147.png)\\n\\n**n==Number of Nodes \\nT->O(n) && S->O(n) [For storing all the Nodes after BFS] + O(n/2) [For queue, worst Case as it\\'s a Perfect Binary Tree]**\\n\\n***Logic -> Level Order Traversal and connect adjacent Nodes!***\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tNode* connect(Node* root) {\\n\\t\\t\\t\\tif(!root) return NULL;\\n\\n\\t\\t\\t\\tvector<vector<Node*>> lvl;\\n\\t\\t\\t\\tqueue <Node*> q;\\n\\t\\t\\t\\tq.push(root);\\n\\n\\t\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\t\\tint size = q.size();\\n\\t\\t\\t\\t\\tvector <Node*> temp;\\n\\n\\t\\t\\t\\t\\tfor(int i = 0 ; i < size ; i++){\\n\\t\\t\\t\\t\\t\\tNode* node = q.front();\\n\\t\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\t\\tif(node -> left) q.push(node -> left);\\n\\t\\t\\t\\t\\t\\tif(node -> right) q.push(node -> right);\\n\\t\\t\\t\\t\\t\\ttemp.push_back(node);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttemp.push_back(NULL);\\n\\t\\t\\t\\t\\tlvl.push_back(temp);\\n\\t\\t\\t\\t} \\n\\n\\t\\t\\t\\tfor(int i = 0 ; i < lvl.size() ; i++){\\n\\t\\t\\t\\t\\tfor(int j = 0 ; j < lvl[i].size() - 1 ; j++) lvl[i][j] -> next = lvl[i][j + 1];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn root;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n**Method - 2 [Optimized]**\\n\\n![image](https://assets.leetcode.com/users/images/2bedfde0-1ab4-4a19-b754-0fb7656b6c84_1672755793.910553.png)\\n\\n**n==Number of Nodes\\nT->O(n) && S->O(n) [Recursive Stack Space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(Node* l,Node* r){\\n\\t\\t\\tif(!l && !r) return;\\n\\n\\t\\t\\tl -> next = r;\\n\\t\\t\\tr -> next = NULL;\\n\\n\\t\\t\\tdfs(l -> left , l -> right);\\n\\t\\t\\tdfs(l -> right , r -> left);\\n\\t\\t\\tdfs(r -> left , r -> right);\\n\\t\\t}\\n\\n\\t\\tNode* connect(Node* root) {\\n\\t\\t\\tif(!root) return NULL;\\n\\t\\t\\tdfs(root -> left , root -> right);\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tNode* connect(Node* root) {\\n\\t\\t\\t\\tif(!root) return NULL;\\n\\n\\t\\t\\t\\tvector<vector<Node*>> lvl;\\n\\t\\t\\t\\tqueue <Node*> q;\\n\\t\\t\\t\\tq.push(root);\\n\\n\\t\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\t\\tint size = q.size();\\n\\t\\t\\t\\t\\tvector <Node*> temp;\\n\\n\\t\\t\\t\\t\\tfor(int i = 0 ; i < size ; i++){\\n\\t\\t\\t\\t\\t\\tNode* node = q.front();\\n\\t\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\t\\tif(node -> left) q.push(node -> left);\\n\\t\\t\\t\\t\\t\\tif(node -> right) q.push(node -> right);\\n\\t\\t\\t\\t\\t\\ttemp.push_back(node);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1466306,
                "title": "c-o-n-time-o-1-space-no-recursion-space-0ms-faster-than-100",
                "content": "The idea is to fix the next pointer for child nodes while traversing through parent node. \\nOnce you fixed the next pointer then you can traverse this level in O(1) space.\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n       if(!root)return root;\\n       Node* curr=root;\\n       while(curr->left){\\n            Node* currLeft=curr->left;\\n            while(curr){\\n                curr->left->next=curr->right;\\n                curr->right->next=curr->next?curr->next->left:NULL;\\n                curr=curr->next;\\n            }\\n            curr=currLeft;\\n       }\\n       return root;\\n    }\\n};\\n```\\nFeel free to ask doubt in comments and please don\\'t forget to upvote if you like the solution.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n       if(!root)return root;\\n       Node* curr=root;\\n       while(curr->left){\\n            Node* currLeft=curr->left;\\n            while(curr){\\n                curr->left->next=curr->right;\\n                curr->right->next=curr->next?curr->next->left:NULL;\\n                curr=curr->next;\\n            }\\n            curr=currLeft;\\n       }\\n       return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357656,
                "title": "python-simple-solution-easy-to-understand-o-n-and-constant-memory",
                "content": "```\\n def helper(self, root, parent=None, isleftChild=True):\\n        if root is None:\\n            return None\\n        \\n        if parent == None:\\n            #we are at root\\n            root.next = None\\n        else:\\n            #we are at some node other than root\\n            if isleftChild:\\n                root.next = parent.right\\n            else:\\n                root.next = None\\n                if parent.next != None:\\n                    root.next = parent.next.left\\n                    \\n        root.left = self.helper(root.left, root, True)\\n        root.right = self.helper(root.right, root, False)\\n        \\n        return root\\n    \\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        return self.helper(root)\\n```\\nplease upvote !",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n def helper(self, root, parent=None, isleftChild=True):\\n        if root is None:\\n            return None\\n        \\n        if parent == None:\\n            #we are at root\\n            root.next = None\\n        else:\\n            #we are at some node other than root\\n            if isleftChild:\\n                root.next = parent.right\\n            else:\\n                root.next = None\\n                if parent.next != None:\\n                    root.next = parent.next.left\\n                    \\n        root.left = self.helper(root.left, root, True)\\n        root.right = self.helper(root.right, root, False)\\n        \\n        return root\\n    \\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        return self.helper(root)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 934979,
                "title": "easy-bfs-python-solution",
                "content": "```\\n\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \\n        if not root:\\n            return None\\n        \\n        q=collections.deque()\\n        \\n        q.append(root)\\n        \\n        while q:\\n            for i in range(1,len(q)):\\n                q[i-1].next=q[i]\\n            q[-1].next=None    \\n            newLevel=deque()\\n            for node in q:\\n                if node.left:\\n                    newLevel.append(node.left)\\n                if node.right:\\n                    newLevel.append(node.right)\\n                    \\n            q=newLevel\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \\n        if not root:\\n            return None\\n        \\n        q=collections.deque()\\n        \\n        q.append(root)\\n        \\n        while q:\\n            for i in range(1,len(q)):\\n                q[i-1].next=q[i]\\n            q[-1].next=None    \\n            newLevel=deque()\\n            for node in q:\\n                if node.left:\\n                    newLevel.append(node.left)\\n                if node.right:\\n                    newLevel.append(node.right)\\n                    \\n            q=newLevel\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934124,
                "title": "python-constant-space",
                "content": "Use the already-populated next pointers of the row above to fill the row below:\\n```\\ndef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\tif not root: return\\n\\t\\n\\tabove, below = root, root.left\\n\\twhile below:\\n\\t\\tcur = below\\n\\t\\twhile above:\\n\\t\\t\\tif cur == above.left:\\n\\t\\t\\t\\tcur.next = above.right\\n\\t\\t\\t\\tabove = above.next\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcur.next = above.left\\n\\t\\t\\tcur = cur.next\\n\\n\\t\\tabove = below\\n\\t\\tbelow = below.left\\n\\n\\treturn root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\tif not root: return\\n\\t\\n\\tabove, below = root, root.left\\n\\twhile below:\\n\\t\\tcur = below\\n\\t\\twhile above:\\n\\t\\t\\tif cur == above.left:\\n\\t\\t\\t\\tcur.next = above.right\\n\\t\\t\\t\\tabove = above.next\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcur.next = above.left\\n\\t\\t\\tcur = cur.next\\n\\n\\t\\tabove = below\\n\\t\\tbelow = below.left\\n\\n\\treturn root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 557405,
                "title": "2-different-simple-recursion-o-n-time-beats-100",
                "content": "The first solution\\'s idea is only on about the fact that `root.right.next = root.next.left`\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root or not root.left:\\n            return root\\n        root.left.next = root.right\\n        if root.next:\\n            root.right.next = root.next.left\\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root\\n```\\n\\nThe 2nd solution is as simple as stiching nodes recursively, 3 pairs at a time\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root or not root.left:\\n            return root\\n        def stich(left, right):\\n            if not left:\\n                return\\n            if left.next:\\n                # optimize, save huge time\\n                return\\n            left.next = right\\n            stich(left.left, left.right)\\n            stich(left.right, right.left)\\n            stich(right.left, right.right)\\n        stich(root.left, root.right)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root or not root.left:\\n            return root\\n        root.left.next = root.right\\n        if root.next:\\n            root.right.next = root.next.left\\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root\\n```\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root or not root.left:\\n            return root\\n        def stich(left, right):\\n            if not left:\\n                return\\n            if left.next:\\n                # optimize, save huge time\\n                return\\n            left.next = right\\n            stich(left.left, left.right)\\n            stich(left.right, right.left)\\n            stich(right.left, right.right)\\n        stich(root.left, root.right)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37622,
                "title": "share-my-loop-java-1ms-solution-easy-understand",
                "content": "    //Just remember to use result from the last step\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if(root==null) return;\\n            while(root.left!=null){\\n                TreeLinkNode tmp = root;\\n                while(tmp!=null){\\n                    tmp.left.next = tmp.right;\\n                    if(tmp.next!=null) tmp.right.next = tmp.next.left;\\n                    tmp = tmp.next;\\n                }\\n                root = root.left;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if(root==null) return;\\n            while(root.left!=null){\\n                TreeLinkNode tmp = root;\\n                while(tmp!=null){\\n                    tmp.left.next = tmp.right;\\n                    if(tmp.next!=null) tmp.right.next = tmp.next.left;\\n                    tmp = tmp.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 37675,
                "title": "c-easy-recursive-solution",
                "content": "    class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            if(!root)\\n                return;\\n            if(root->left)\\n                root->left->next = root->right;\\n            if(root->next && root->right)\\n                root->right->next = root->next->left;\\n            connect(root->left);\\n            connect(root->right);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            if(!root)\\n                return;\\n            if(root->left)\\n                root->left->next = root->right;\\n            if(root->next && root->right)\\n                root->right->next = root->next->left;\\n            connect(root->left);\\n            connect(root->right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3689095,
                "title": "easy-bfs-java-python-c",
                "content": "# * Extra space but clean code\\n---\\n```java []\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null)\\n            return root;\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(queue.size() > 0)\\n        {\\n            Deque<Node> dq = new ArrayDeque<>();\\n            int length = queue.size();\\n            for(int i = 0;i<length;i++)\\n            {\\n                Node curr = queue.poll();\\n                dq.addLast(curr);\\n                if(curr.left!=null)\\n                    queue.add(curr.left);\\n                if(curr.right!=null)\\n                    queue.add(curr.right);\\n            }\\n            while(dq.size() > 1)\\n            {\\n                Node popped = dq.removeFirst();\\n                popped.next = dq.getFirst();\\n            }\\n            Node popped = dq.removeFirst();\\n            popped.next = null;\\n        }\\n        return root;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == nullptr)\\n            return root;\\n        queue<Node*> queue;\\n        queue.push(root);\\n        while(queue.size() > 0)\\n        {\\n            deque<Node*> dq;\\n            int length = queue.size();\\n            for(int i = 0;i<length;i++)\\n            {\\n                Node* curr = queue.front();\\n                queue.pop();\\n                dq.push_back(curr);\\n                if(curr->left!=nullptr)\\n                    queue.push(curr->left);\\n                if(curr->right!=nullptr)\\n                    queue.push(curr->right);\\n            }\\n            while(dq.size() > 1)\\n            {\\n                Node* popped = dq.front();\\n                dq.pop_front();\\n                popped->next = dq.front();\\n            }\\n            Node* popped = dq.front();\\n            dq.pop_front();\\n            popped->next = nullptr;\\n        }\\n        return root;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return root\\n        queue = []\\n        queue.append(root)\\n        while queue:\\n            dq = collections.deque()\\n            length = len(queue)\\n            for i in range(length):\\n                curr = queue.pop(0)\\n                dq.append(curr)\\n                if curr.left:\\n                    queue.append(curr.left)\\n                if curr.right:\\n                    queue.append(curr.right)\\n            while len(dq) > 1:\\n                popped = dq.popleft()\\n                popped.next = dq[0]\\n            popped = dq.popleft()\\n            popped.next = None\\n        return root\\n```\\n---\\n>### *Please don\\'t forget to upvote if you\\'ve liked my solution.* \\u2B06\\uFE0F\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```java []\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null)\\n            return root;\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        while(queue.size() > 0)\\n        {\\n            Deque<Node> dq = new ArrayDeque<>();\\n            int length = queue.size();\\n            for(int i = 0;i<length;i++)\\n            {\\n                Node curr = queue.poll();\\n                dq.addLast(curr);\\n                if(curr.left!=null)\\n                    queue.add(curr.left);\\n                if(curr.right!=null)\\n                    queue.add(curr.right);\\n            }\\n            while(dq.size() > 1)\\n            {\\n                Node popped = dq.removeFirst();\\n                popped.next = dq.getFirst();\\n            }\\n            Node popped = dq.removeFirst();\\n            popped.next = null;\\n        }\\n        return root;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == nullptr)\\n            return root;\\n        queue<Node*> queue;\\n        queue.push(root);\\n        while(queue.size() > 0)\\n        {\\n            deque<Node*> dq;\\n            int length = queue.size();\\n            for(int i = 0;i<length;i++)\\n            {\\n                Node* curr = queue.front();\\n                queue.pop();\\n                dq.push_back(curr);\\n                if(curr->left!=nullptr)\\n                    queue.push(curr->left);\\n                if(curr->right!=nullptr)\\n                    queue.push(curr->right);\\n            }\\n            while(dq.size() > 1)\\n            {\\n                Node* popped = dq.front();\\n                dq.pop_front();\\n                popped->next = dq.front();\\n            }\\n            Node* popped = dq.front();\\n            dq.pop_front();\\n            popped->next = nullptr;\\n        }\\n        return root;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return root\\n        queue = []\\n        queue.append(root)\\n        while queue:\\n            dq = collections.deque()\\n            length = len(queue)\\n            for i in range(length):\\n                curr = queue.pop(0)\\n                dq.append(curr)\\n                if curr.left:\\n                    queue.append(curr.left)\\n                if curr.right:\\n                    queue.append(curr.right)\\n            while len(dq) > 1:\\n                popped = dq.popleft()\\n                popped.next = dq[0]\\n            popped = dq.popleft()\\n            popped.next = None\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577380,
                "title": "java-100-fast-0ms-easy-recursion-node",
                "content": "If you find my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community,\\nif you have any queries or any improvements please feel free to comment and share your views.\\n\\n       class Solution {\\n    public Node connect(Node root) {\\n        if(root == null){\\n              return root;\\n        }\\n        if(root.left != null) root.left.next = root.right;\\n        if(root.right != null && root.next != null){\\n                root.right.next = root.next.left;\\n            }\\n        connect(root.left);\\n        connect (root.right);\\n        return root;\\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public Node connect(Node root) {\\n        if(root == null){\\n              return root;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2534439,
                "title": "python-with-simple-recursion-explanation-with-drawing",
                "content": "I divide the code into four part, check out the hashtag. \\n`#part1`: if root is None, we want to just return None.\\n`#part2:` : if cur.left is not None, we want to build a connection between cur.left and cur.right. See pic:\\n![image](https://assets.leetcode.com/users/images/cfeb76d0-09c7-4598-bc2f-2b366fe46eca_1662378412.3597903.png)\\n`#part3`:we want to build connection between node 5 and 6(see pic), if cur.next and cur.left not None.\\n![image](https://assets.leetcode.com/users/images/a315abd7-21a7-43cf-ad9b-31ab3af73219_1662378740.7180765.png)\\n`#part4` call left node and right node do the same thing\\n\\nIf this is helpful, don\\'t forget give me a star and vote\\n\\n\\n```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root : return None      #part1\\n        def recursion(cur):\\n            if cur.left:                   #part2\\n                cur.left.next = cur.right\\n\\n            if cur.next and cur.left:     #part3\\n                cur.right.next = cur.next.left\\n\\n            recursion(cur.left) if cur.left else None        #part4\\n            recursion(cur.right) if cur.right else None\\n        \\n        recursion(root)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root : return None      #part1\\n        def recursion(cur):\\n            if cur.left:                   #part2\\n                cur.left.next = cur.right\\n\\n            if cur.next and cur.left:     #part3\\n                cur.right.next = cur.next.left\\n\\n            recursion(cur.left) if cur.left else None        #part4\\n            recursion(cur.right) if cur.right else None\\n        \\n        recursion(root)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774841,
                "title": "c-efficient-recursive-iterative-using-queue-2-solutions",
                "content": "##### If you understand the approach please please upvote!!!\\uD83D\\uDC4D\\n***Thanks :)***\\n##### Recursive Approach :-\\n* Base case: if the root is null than return null\\n* Now to connect the left subtree of same level with right subtree of that level\\n* The only new line that differentiate from level order traversing is that we need to connect the rightmost node of a level to the leftmost node of the next level.\\n* Now just repeat the steps over and over for every level of tree .*\\n##### Recursive Code:-\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n    if(root == NULL) return NULL;\\n    //connects the left subtree of same level with right subtree of that same level \\n    if(root->left != NULL) root->left->next = root->right;\\n    //connect the rightmost node of a level to the leftmost node of the next level.\\n    if(root->right != NULL && root->next != NULL) root->right->next = root->next->left;\\n    //recursive calls for left and right subtrees.\\n    connect(root->left);\\n    connect(root->right);\\n    return root;\\n    }\\n};\\n```\\n\\n##### Iterative Approach using Queue(like level-order-traversal):-\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL) return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size(); // get size of queue \\n            for(int i=0 ; i < size ; i++){\\n                Node* item = q.front(); \\n                if(size - 1 == i) // checking the last value of the level\\n                     item -> next = NULL; \\n                q.pop();\\n                \\n                if(size - 1 != i) // if this is not the last value then previous value will point to next one\\n                     item -> next = q.front(); \\n                \\n                if(item -> left != NULL)\\n                    q.push(item -> left);\\n                if(item -> right != NULL)\\n                    q.push(item -> right);\\n            }\\n        } \\n        return root;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n    if(root == NULL) return NULL;\\n    //connects the left subtree of same level with right subtree of that same level \\n    if(root->left != NULL) root->left->next = root->right;\\n    //connect the rightmost node of a level to the leftmost node of the next level.\\n    if(root->right != NULL && root->next != NULL) root->right->next = root->next->left;\\n    //recursive calls for left and right subtrees.\\n    connect(root->left);\\n    connect(root->right);\\n    return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL) return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size = q.size(); // get size of queue \\n            for(int i=0 ; i < size ; i++){\\n                Node* item = q.front(); \\n                if(size - 1 == i) // checking the last value of the level\\n                     item -> next = NULL; \\n                q.pop();\\n                \\n                if(size - 1 != i) // if this is not the last value then previous value will point to next one\\n                     item -> next = q.front(); \\n                \\n                if(item -> left != NULL)\\n                    q.push(item -> left);\\n                if(item -> right != NULL)\\n                    q.push(item -> right);\\n            }\\n        } \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1360246,
                "title": "simple-preorder-traversal",
                "content": "```class Solution {\\n    private void helper(Node root)\\n    {\\n        if(root == null)\\n            return;\\n        //since it is a leaf node it wont have any child \\n        if(root.left == null && root.right == null)\\n            return;\\n        //stand on parent and connect left child to right child\\n        root.left.next = root.right;\\n        \\n        //after connecting left child to right , connect parent\\'s right child via the next link we created above to left child of adjacent subtree.\\n        if(root.next != null)\\n            root.right.next = root.next.left;\\n        \\n        helper(root.left);\\n        helper(root.right);\\n    }\\n    public Node connect(Node root) {\\n        helper(root);\\n        return root;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    private void helper(Node root)\\n    {\\n        if(root == null)\\n            return;\\n        //since it is a leaf node it wont have any child \\n        if(root.left == null && root.right == null)\\n            return;\\n        //stand on parent and connect left child to right child\\n        root.left.next = root.right;\\n        \\n        //after connecting left child to right , connect parent\\'s right child via the next link we created above to left child of adjacent subtree.\\n        if(root.next != null)\\n            root.right.next = root.next.left;\\n        \\n        helper(root.left);\\n        helper(root.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1114796,
                "title": "python-recursion-constant-space-beats-98-short-solution",
                "content": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root or not root.left:\\n            return root\\n        \\n        root.left.next = root.right\\n        \\n        if root.next:\\n            root.right.next = root.next.left\\n        \\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root or not root.left:\\n            return root\\n        \\n        root.left.next = root.right\\n        \\n        if root.next:\\n            root.right.next = root.next.left\\n        \\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934104,
                "title": "c-easy-iterative-solution",
                "content": "```\\nstruct Node* connect(struct Node* root) {\\n\\tif (!root)\\n        return root;\\n    \\n    struct Node* ptr_node = root;\\n    struct Node* first = ptr_node;\\n    \\n    while (ptr_node->left) {\\n        \\n        while (ptr_node) {\\n            \\n            ptr_node->left->next = ptr_node->right;\\n            \\n            if (ptr_node->next) {\\n                ptr_node->right->next = ptr_node->next->left;\\n            }\\n            \\n            ptr_node = ptr_node->next;\\n        }\\n        \\n        first = first->left;\\n        ptr_node = first;\\n    }\\n    \\n    return root;\\n}\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nstruct Node* connect(struct Node* root) {\\n\\tif (!root)\\n        return root;\\n    \\n    struct Node* ptr_node = root;\\n    struct Node* first = ptr_node;\\n    \\n    while (ptr_node->left) {\\n        \\n        while (ptr_node) {\\n            \\n            ptr_node->left->next = ptr_node->right;\\n            \\n            if (ptr_node->next) {\\n                ptr_node->right->next = ptr_node->next->left;\\n            }\\n            \\n            ptr_node = ptr_node->next;\\n        }\\n        \\n        first = first->left;\\n        ptr_node = first;\\n    }\\n    \\n    return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 508672,
                "title": "java-recursive-solution-100-o-n-time-o-1-space-o-n-stack-call",
                "content": "Feel free to discuss Big-O analysis :)\\n```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n        if (root.left != null) root.left.next = root.right;\\n        if (root.right != null) root.right.next = root.next == null ? null : root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n        if (root.left != null) root.left.next = root.right;\\n        if (root.right != null) root.right.next = root.next == null ? null : root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 286540,
                "title": "c-while",
                "content": "```\\npublic class Solution {\\n    public Node Connect(Node root) {\\n        var preMostLeft = root;\\n        while (preMostLeft != null) {\\n            var cur = preMostLeft;\\n            while (cur != null && cur.left != null) {\\n                cur.left.next = cur.right;\\n                if (cur.next != null) {\\n                    cur.right.next = cur.next.left;\\n                }\\n                cur = cur.next;\\n            }\\n\\n            preMostLeft = preMostLeft.left;\\n        }\\n\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public Node Connect(Node root) {\\n        var preMostLeft = root;\\n        while (preMostLeft != null) {\\n            var cur = preMostLeft;\\n            while (cur != null && cur.left != null) {\\n                cur.left.next = cur.right;\\n                if (cur.next != null) {\\n                    cur.right.next = cur.next.left;\\n                }\\n                cur = cur.next;\\n            }\\n\\n            preMostLeft = preMostLeft.left;\\n        }\\n\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163183,
                "title": "java-c-c-solutions-elegant-iterative-solutions-4-lines-and-recursive-solutions-5-lines",
                "content": "# **C++**\\n## Recursive\\nSetting the _next_ pointer from the parent node makes for a clean solution. The only thing to worry about is how to handle the far right node of each level, which doesn\\'t have a _next_. This is easy to check for too, just check if the parent node has a _next_ pointer, if it doesn\\'t, then you\\'re at the far right.\\n```cpp\\n  void connect(TreeLinkNode *root) {\\n    if (root && root->left) {\\n      root->left->next = root->right;\\n      root->right->next = (root->next) ? root->next->left : nullptr;\\n      connect(root->left);\\n      connect(root->right);\\n    }\\n  }\\n```\\t\\n## Iterative\\nSet the _next_ pointer starting from the left of each level, then you can use the _next_ pointer to progress from left to right to complete the level. Once a level is finshed, advance down the left branch and do it again.\\n```cpp\\n  void connect(TreeLinkNode *root) {\\n    for (; root && root->left; root = root->left) {\\n      for (TreeLinkNode* pos = root; pos; pos = pos->next) {\\n        pos->left->next = pos->right;\\n        pos->right->next = (pos->next) ? pos->next->left : nullptr;\\n      }\\n    }\\n  }\\n```\\t\\n# **Java**\\n## Recursive\\n```java\\n    public void connect(TreeLinkNode root) {\\n      if (null != root && null != root.left) {\\n        root.left.next = root.right;\\n        root.right.next = (null != root.next) ? root.next.left : null;\\n        connect(root.left);\\n        connect(root.right);\\n      }\\n    }\\n```\\n## Iterative\\n```java\\n    public void connect(TreeLinkNode root) {\\n      for (; null != root && null != root.left; root = root.left) {\\n        for (TreeLinkNode pos = root; null != pos; pos = pos.next) {\\n          pos.left.next = pos.right;\\n          pos.right.next = (null != pos.next) ? pos.next.left : null;\\n        }\\n      }\\n    }\\n```\\n# **C**\\nSince a c solution would look very much like the c++ solution, I did it slightly differently, but is essentially the same.\\n```c\\nstruct Node* connect(struct Node* root) {\\n  if (root) {\\n    for (struct Node* row_start = root; row_start->left; row_start = row_start->left) {\\n      struct Node* pos = row_start;\\n      for (; pos->next; pos = pos->next) {\\n        pos->left->next = pos->right;\\n        pos->right->next = pos->next->left;\\n      }\\n      pos->left->next = pos->right;\\n    }\\n  }\\n  return root;\\n}\\n```\\n\\n**Note that all solutions abuse the fact that the tree is by definition a perfect binary tree. [Solutions that don\\'t require perfect tree can be found here](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/discuss/163809/C++-iterative-O(1)-space.-Short-and-easy-to-understand-with-detail.-Bonus-2-line-solution-for-fun)**\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\n  void connect(TreeLinkNode *root) {\\n    if (root && root->left) {\\n      root->left->next = root->right;\\n      root->right->next = (root->next) ? root->next->left : nullptr;\\n      connect(root->left);\\n      connect(root->right);\\n    }\\n  }\\n```\n```cpp\\n  void connect(TreeLinkNode *root) {\\n    for (; root && root->left; root = root->left) {\\n      for (TreeLinkNode* pos = root; pos; pos = pos->next) {\\n        pos->left->next = pos->right;\\n        pos->right->next = (pos->next) ? pos->next->left : nullptr;\\n      }\\n    }\\n  }\\n```\n```java\\n    public void connect(TreeLinkNode root) {\\n      if (null != root && null != root.left) {\\n        root.left.next = root.right;\\n        root.right.next = (null != root.next) ? root.next.left : null;\\n        connect(root.left);\\n        connect(root.right);\\n      }\\n    }\\n```\n```java\\n    public void connect(TreeLinkNode root) {\\n      for (; null != root && null != root.left; root = root.left) {\\n        for (TreeLinkNode pos = root; null != pos; pos = pos.next) {\\n          pos.left.next = pos.right;\\n          pos.right.next = (null != pos.next) ? pos.next.left : null;\\n        }\\n      }\\n    }\\n```\n```c\\nstruct Node* connect(struct Node* root) {\\n  if (root) {\\n    for (struct Node* row_start = root; row_start->left; row_start = row_start->left) {\\n      struct Node* pos = row_start;\\n      for (; pos->next; pos = pos->next) {\\n        pos->left->next = pos->right;\\n        pos->right->next = pos->next->left;\\n      }\\n      pos->left->next = pos->right;\\n    }\\n  }\\n  return root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37642,
                "title": "a-simple-0-ms-recursive-solution-without-helper-function",
                "content": "    public void connect(TreeLinkNode root) {\\n        if (root == null){\\n            return;\\n        }\\n        \\n        if (root.left != null){\\n            root.left.next = root.right;\\n            if (root.next != null){\\n                root.right.next = root.next.left;\\n            }\\n        }\\n        \\n        connect(root.left);\\n        connect(root.right);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void connect(TreeLinkNode root) {\\n        if (root == null){\\n            return;\\n        }\\n        \\n        if (root.left != null){\\n            root.left.next = root.right;\\n            if (root.next != null){\\n                root.right.next = root.next.left;\\n            }\\n        }\\n        \\n        connect(root.left);\\n        connect(root.right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37720,
                "title": "another-accepted-java-solution",
                "content": "Basically, we use the next pointer to help level traversal. No recursion is needed, O(1) constant space, O(n) running time.\\n\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) return;\\n            \\n            while (root.left != null) {\\n                TreeLinkNode curr = root;\\n                \\n                while (curr != null) {\\n                    curr.left.next = curr.right;\\n                    curr.right.next = curr.next != null ? curr.next.left : null;\\n                    curr = curr.next;\\n                }\\n                \\n                root = root.left;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null) return;\\n            \\n            while (root.left != null) {\\n                TreeLinkNode curr = root;\\n                \\n                while (curr != null) {\\n                    curr.left.next = curr.right;\\n                    curr.right.next = curr.next != null ? curr.next.left : null;\\n                    curr = curr.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 37749,
                "title": "sharing-my-java-o-1-extra-space-code",
                "content": "    public void connect(TreeLinkNode root) {\\n        TreeLinkNode cur;\\n        TreeLinkNode nextLevel = root;\\n        while (nextLevel != null) {\\n            cur = nextLevel;\\n            // at each level, connects the children nodes\\n            while (cur != null && \\n                    cur.left != null // checking for leaf nodes\\n                    ) \\n            {\\n                cur.left.next = cur.right;\\n                if (cur.next != null) {\\n                    cur.right.next = cur.next.left;\\n                }\\n                cur = cur.next; \\n            }\\n            \\n            nextLevel = nextLevel.left;\\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void connect(TreeLinkNode root) {\\n        TreeLinkNode cur;\\n        TreeLinkNode nextLevel = root;\\n        while (nextLevel != null) {\\n            cur = nextLevel;\\n            // at each level, connects the children nodes\\n            while (cur != null && \\n                    cur.left != null // checking for leaf nodes\\n                    ) \\n            {\\n                cur.left.next = cur.right;\\n                if (cur.next != null) {\\n                    cur.right.next = cur.next.left;\\n                }\\n                cur = cur.next; \\n            }\\n            \\n            nextLevel = nextLevel.left;\\n            \\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37787,
                "title": "simple-iterative-solution",
                "content": "Populate the levels one by one. curLevel points to node whose children will be linked, nextLevel points to the first node in the next level.\\n\\n    class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            if(!root)return;\\n            TreeLinkNode*curLevel=root,*nextLevel=root->left;\\n            root->next=NULL;\\n            while(curLevel->left){\\n                curLevel->left->next=curLevel->right;\\n                if (curLevel->next){\\n                    curLevel->right->next = curLevel->next->left;\\n                    curLevel=curLevel->next;\\n                }\\n                else {\\n                    curLevel->right->next=NULL;\\n                    curLevel=nextLevel;\\n                    nextLevel=nextLevel->left;\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            if(!root)return;\\n            TreeLinkNode*curLevel=root,*nextLevel=root->left;\\n            root->next=NULL;\\n            while(curLevel->left){\\n                curLevel->left->next=curLevel->right;\\n                if (curLevel->next){\\n                    curLevel->right->next = curLevel->next->left;\\n                    curLevel=curLevel->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 37793,
                "title": "my-recursive-solution",
                "content": "    void connect(TreeLinkNode *root) {\\n        if( root == NULL || root->left == NULL && root->right == NULL )        //{} \\\\ {0}\\n        {\\n           return;\\n        }\\n        \\n        TreeLinkNode *p, *q;\\n        p = root->left;\\n        q = root->right;\\n        p->next = q;\\n        while( p->right != NULL )\\n        {\\n            p = p->right;\\n            q = q->left;\\n            p->next = q;\\n        }\\n        \\n        connect( root->left );\\n        connect( root->right );\\n    }",
                "solutionTags": [],
                "code": "    void connect(TreeLinkNode *root) {\\n        if( root == NULL || root->left == NULL && root->right == NULL )        //{} \\\\ {0}\\n        {\\n           return;\\n        }\\n        \\n        TreeLinkNode *p, *q;\\n        p = root->left;\\n        q = root->right;\\n        p->next = q;\\n        while( p->right != NULL )\\n        {\\n            p = p->right;\\n            q = q->left;\\n            p->next = q;\\n        }\\n        \\n        connect( root->left );\\n        connect( root->right );\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3687361,
                "title": "2-ms-easy-to-understand-using-queue-level-order-traversal-java-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe approach used here is based on level-order traversal of the tree using a queue. The intuition behind the solution is that by traversing the tree level by level, we can keep track of the next right node for each node in the current level and establish the connections.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA while loop processes each level. Inside the loop, a for loop iterates through each node, connecting it to the next node in the same level if applicable. Nodes with children are added to the queue for the next level. The process continues until all nodes in the current level are processed.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n    (n is number of nodes)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m)$$ \\n  (m is maximum number of nodes in a level)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) {\\n            return null;\\n        }\\n\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size(); // Store the size of the current level\\n\\n            for (int i = 0; i < size; i++) {\\n                Node node = queue.remove(); // Remove a node from the queue\\n\\n                if (i < size - 1) {\\n                    node.next = queue.peek(); // Set the next pointer to the node at the front of the queue\\n                }\\n\\n                if (node.left != null) {\\n                    queue.add(node.left); // Add the left child to the queue\\n                }\\n                if (node.right != null) {\\n                    queue.add(node.right); // Add the right child to the queue\\n                }\\n            }\\n        }\\n\\n        return root; // Return the modified root node\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (root == nullptr) return nullptr;\\n\\n        queue<Node*> queue;\\n        queue.push(root);\\n\\n        while (!queue.empty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                Node* node = queue.front();\\n                queue.pop();\\n\\n                if (i < size - 1) \\n                    node->next = queue.front();\\n                \\n                if (node->left != nullptr) \\n                    queue.push(node->left);\\n                \\n                if (node->right != nullptr) \\n                    queue.push(node->right);              \\n            }\\n        }\\n\\n        return root;\\n    }\\n};\\n\\n```\\nPLease upvote if u found it useful :)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```Java []\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) {\\n            return null;\\n        }\\n\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n\\n        while (!queue.isEmpty()) {\\n            int size = queue.size(); // Store the size of the current level\\n\\n            for (int i = 0; i < size; i++) {\\n                Node node = queue.remove(); // Remove a node from the queue\\n\\n                if (i < size - 1) {\\n                    node.next = queue.peek(); // Set the next pointer to the node at the front of the queue\\n                }\\n\\n                if (node.left != null) {\\n                    queue.add(node.left); // Add the left child to the queue\\n                }\\n                if (node.right != null) {\\n                    queue.add(node.right); // Add the right child to the queue\\n                }\\n            }\\n        }\\n\\n        return root; // Return the modified root node\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (root == nullptr) return nullptr;\\n\\n        queue<Node*> queue;\\n        queue.push(root);\\n\\n        while (!queue.empty()) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                Node* node = queue.front();\\n                queue.pop();\\n\\n                if (i < size - 1) \\n                    node->next = queue.front();\\n                \\n                if (node->left != nullptr) \\n                    queue.push(node->left);\\n                \\n                if (node->right != nullptr) \\n                    queue.push(node->right);              \\n            }\\n        }\\n\\n        return root;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753478,
                "title": "java-beauty-and-easy-solution-explained-visualized-o-n-algo-o-1-memo",
                "content": "The task boils down to understanding the structure of the tree and how to traverse it.\\nThe solution is that we create a method that **contains the right and left nodes of the same level**.\\n1. We connect the left node with the right one using the `next` field.\\n2. The **next** left node of the current left one is combined with the **next** right one.\\n3. The **next** left node of the current right node is combined with the **next** right node.\\n4. And we also take **the next right node of the left one** and combine it with **the left node of the right one**. This is the most difficult step and is the key to solving the problem.\\n\\n**See the image below!** It turns out that we first connected two nodes and then connected their next level. Moreover, first they combined the \"children\" of the left, then the \"children\" of the right, and then they were united.\\n\\n```java\\nclass Solution {\\n        public static Node connect(Node root) {\\n        if (root == null || (root.left == null && root.right == null)) return root;\\n\\n        connectNext(root.left, root.right);\\n\\n        return root;\\n    }\\n\\n    private static void connectNext(Node left, Node right) {\\n        if (left == null || right == null) return;\\n        left.next = right; // Step 1 - comments only for the image below!\\n\\t\\t\\n        connectNext(left.left, left.right); // Step 2\\n        connectNext(left.right, right.left); // Step 3\\n        connectNext(right.left, right.right); // Step 4\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/1f554560-3085-44a7-b2e8-b16c0958a069_1666979901.3168855.png)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n        public static Node connect(Node root) {\\n        if (root == null || (root.left == null && root.right == null)) return root;\\n\\n        connectNext(root.left, root.right);\\n\\n        return root;\\n    }\\n\\n    private static void connectNext(Node left, Node right) {\\n        if (left == null || right == null) return;\\n        left.next = right; // Step 1 - comments only for the image below!\\n\\t\\t\\n        connectNext(left.left, left.right); // Step 2\\n        connectNext(left.right, right.left); // Step 3\\n        connectNext(right.left, right.right); // Step 4\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424026,
                "title": "python-c-java-beginner-level-solution-100-faster-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q116. Populating Next Right Pointers in Each Node***\\n\\nYou are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:\\n```\\nstruct Node {\\n  int val;\\n  Node *left;\\n  Node *right;\\n  Node *next;\\n}\\n```\\nPopulate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\\nInitially, all next pointers are set to NULL.\\n____________________________________________________________________________________________________________________\\n\\n***Time complexity*** - O(n)\\n***Space complexity*** - O(1)\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Java Code** :\\n**Runtime**: 0 ms, faster than 100.00% of Java online submissions for Populating Next Right Pointers in Each Node.\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Node current = root;\\n        while(current != null) {\\n            Node level1stNode = current;\\n            while(current != null) \\n            {\\n                if(current.left != null) \\n                    current.left.next = current.right;\\n                if(current.right != null && current.next != null) \\n                    current.right.next = current.next.left;\\n\\n                current = current.next;\\n            }\\n            current = level1stNode.left;\\n        }\\n        return root;\\n    }\\n}\\n```\\n**Runtime:**  0ms\\n**Memory Usage:**  42.2 MB\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n\\n```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root: return root        \\n        self.current = root\\n        while self.current:\\n            self.level1stNode = self.current\\n            while self.current:\\n                if self.current.left:\\n                    self.current.left.next = self.current.right\\n                    \\n                if self.current.right and self.current.next:\\n                    self.current.right.next = self.current.next.left\\n                    \\n                self.current = self.current.next\\n            self.current = self.level1stNode.left\\n        return root\\n```\\n**Runtime:**  131ms\\n**Memory Usage:**  13.8 MB\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n\\n```\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        Node* current = root;\\n        while(current) {\\n            Node* level1stNode = current;\\n            while(current) \\n            {\\n                if(current->left)\\n                    current->left->next = current->right;\\n                if(current->right && current->next)\\n                    current->right->next = current->next->left;\\n\\n                current = current->next;\\n            }\\n            current = level1stNode->left;\\n        }\\n        return root;\\n    }\\n};\\n```\\n**Runtime:**  41ms\\n**Memory Usage:**  69.7MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nstruct Node {\\n  int val;\\n  Node *left;\\n  Node *right;\\n  Node *next;\\n}\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Node current = root;\\n        while(current != null) {\\n            Node level1stNode = current;\\n            while(current != null) \\n            {\\n                if(current.left != null) \\n                    current.left.next = current.right;\\n                if(current.right != null && current.next != null) \\n                    current.right.next = current.next.left;\\n\\n                current = current.next;\\n            }\\n            current = level1stNode.left;\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not root: return root        \\n        self.current = root\\n        while self.current:\\n            self.level1stNode = self.current\\n            while self.current:\\n                if self.current.left:\\n                    self.current.left.next = self.current.right\\n                    \\n                if self.current.right and self.current.next:\\n                    self.current.right.next = self.current.next.left\\n                    \\n                self.current = self.current.next\\n            self.current = self.level1stNode.left\\n        return root\\n```\n```\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        Node* current = root;\\n        while(current) {\\n            Node* level1stNode = current;\\n            while(current) \\n            {\\n                if(current->left)\\n                    current->left->next = current->right;\\n                if(current->right && current->next)\\n                    current->right->next = current->next->left;\\n\\n                current = current->next;\\n            }\\n            current = level1stNode->left;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808896,
                "title": "c-5-lines-code-very-easy-dfs-simple-explanation",
                "content": "This solution implements a recursive function - it takes a node, connects the NEXT pointers of it\\'s left & right children, and repeats the process for the children. So the algorithm is :\\nFor each non-leaf node, we do -\\n(1) NEXT of Left child is pointed to Right child. Easy.\\n(2) NEXT of Right child is pointed to NEXT node in the same level (i.e., parent\\'s NEXT\\'s left child).\\n\\nLet\\'s consider the below example. Assume we are at the node \"2\".\\n```\\n\\t\\t\\t\\t   1\\nwe are here\\t=>   2 -> 3\\n\\t\\t\\t   3  4  5  6\\n```\\n\\nSince we\\'re at 2, we would already have our NEXT pointer pointing to the node 3 (should have been done at node 1).\\nNow, we need to correctly set NEXT pointers of our children, i.e, 3 and 4. We follow the said algorithm here.\\nStep 1 : 3\\'s NEXT pointer should simply be set to 4.\\nStep 2 : We know 4\\'s NEXT pointer should now be set to 5. How do we do that? Remember we have 2\\'s NEXT set to 3 already? We\\'re going to use that to get reference of 3, and then reference of 5 - then we just use it! 4\\'s NEXT is set to 2\\'s NEXT\\'s left, which is 5.\\n\\nSo the tree now becomes -\\n\\n```\\n\\t\\t\\t\\t      1\\nwe are here\\t=>    2   ->   3\\n\\t\\t\\t   3 -> 4 -> 5    6\\n```\\n\\nWe repeat this process until all NEXT nodes are set. \\n\\nIn case of last node of a level (for ex: 6), we don\\'t have NEXT of our parent (3) anyway, so it\\'s defaulted to NULL as required already.\\nFor leaf nodes, we don\\'t have children to set so we return.\\n\\n\\nSolution Code in C++ \\n```\\nNode* connect(Node* root) {\\n\\tif(!root || !root->left) return root;                     // if given empty tree OR root is leaf node\\n\\troot->left->next = root->right;                           // making left child\\'s next point to right child\\n\\tif(root->next) root->right->next = root->next->left;      // right child\\'s next point to its parent\\'s next\\'s left node\\n\\troot->left = connect(root->left);                         // connect all next pointers in left subtree\\n\\troot->right = connect(root->right);                       // connect all next pointers in right subtree\\n\\treturn root;\\n}\\n```\\n\\nThanks! Upvote if this helped you!",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\t\\t\\t\\t   1\\nwe are here\\t=>   2 -> 3\\n\\t\\t\\t   3  4  5  6\\n```\n```\\n\\t\\t\\t\\t      1\\nwe are here\\t=>    2   ->   3\\n\\t\\t\\t   3 -> 4 -> 5    6\\n```\n```\\nNode* connect(Node* root) {\\n\\tif(!root || !root->left) return root;                     // if given empty tree OR root is leaf node\\n\\troot->left->next = root->right;                           // making left child\\'s next point to right child\\n\\tif(root->next) root->right->next = root->next->left;      // right child\\'s next point to its parent\\'s next\\'s left node\\n\\troot->left = connect(root->left);                         // connect all next pointers in left subtree\\n\\troot->right = connect(root->right);                       // connect all next pointers in right subtree\\n\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1783750,
                "title": "level-order-easy-implementation",
                "content": "```\\nimport queue\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if root is None:\\n            return\\n        myqueue=queue.Queue()\\n        myqueue.put(root)\\n        myqueue.put(None)\\n        small=[]\\n        while myqueue.empty()==False:\\n            front=myqueue.get()\\n            if front!=None:\\n                if front.left!=None:\\n                    myqueue.put(front.left)\\n                if front.right!=None:\\n                    myqueue.put(front.right)\\n                small.append(front)\\n            else:\\n                if myqueue.empty()==True:\\n                    if len(small)==1:\\n                        front=small[0]\\n                        front.next=None\\n                    else:\\n                        for i in range(len(small)):\\n                            j=i+1\\n                            if j<=len(small)-1:\\n                                small[i].next=small[j]\\n                            if i==len(small)-1:\\n                                small[i].next=None\\n                    break\\n                else:\\n                    if len(small)==1:\\n                        small[0].next=None\\n                    else:\\n                        for i in range(len(small)):\\n                            j=i+1\\n                            if j<=len(small)-1:\\n                                small[i].next=small[j]\\n                            if i==len(small)-1:\\n                                small[i].next=None\\n                small=[]\\n                myqueue.put(None)    \\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nimport queue\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if root is None:\\n            return\\n        myqueue=queue.Queue()\\n        myqueue.put(root)\\n        myqueue.put(None)\\n        small=[]\\n        while myqueue.empty()==False:\\n            front=myqueue.get()\\n            if front!=None:\\n                if front.left!=None:\\n                    myqueue.put(front.left)\\n                if front.right!=None:\\n                    myqueue.put(front.right)\\n                small.append(front)\\n            else:\\n                if myqueue.empty()==True:\\n                    if len(small)==1:\\n                        front=small[0]\\n                        front.next=None\\n                    else:\\n                        for i in range(len(small)):\\n                            j=i+1\\n                            if j<=len(small)-1:\\n                                small[i].next=small[j]\\n                            if i==len(small)-1:\\n                                small[i].next=None\\n                    break\\n                else:\\n                    if len(small)==1:\\n                        small[0].next=None\\n                    else:\\n                        for i in range(len(small)):\\n                            j=i+1\\n                            if j<=len(small)-1:\\n                                small[i].next=small[j]\\n                            if i==len(small)-1:\\n                                small[i].next=None\\n                small=[]\\n                myqueue.put(None)    \\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653771,
                "title": "java-o-1-memory-solution-recursive-iterative-faster-than-100",
                "content": "**1. Recurisve**\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null)\\n            return root;\\n        if(root.left != null){\\n            if(root.next != null)\\n                root.right.next = root.next.left;\\n            else\\n                root.right.next = null;\\n            root.left.next = root.right;\\n            connect(root.left);\\n            connect(root.right);\\n        }\\n        return root;\\n    }\\n}\\n```\\n\\n**2. Iterative**\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node leftest = root;\\n        while(leftest != null && leftest.left != null) {\\n        \\tNode curr = leftest;\\n        \\twhile(true) {\\n        \\t\\tcurr.left.next = curr.right;\\n        \\t\\tif(curr.next != null)\\n        \\t\\t\\tcurr.right.next = curr.getNextSibling().left;\\n        \\t\\telse\\n        \\t\\t\\tbreak;\\n        \\t}\\n        \\tcurr = curr.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null)\\n            return root;\\n        if(root.left != null){\\n            if(root.next != null)\\n                root.right.next = root.next.left;\\n            else\\n                root.right.next = null;\\n            root.left.next = root.right;\\n            connect(root.left);\\n            connect(root.right);\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node leftest = root;\\n        while(leftest != null && leftest.left != null) {\\n        \\tNode curr = leftest;\\n        \\twhile(true) {\\n        \\t\\tcurr.left.next = curr.right;\\n        \\t\\tif(curr.next != null)\\n        \\t\\t\\tcurr.right.next = curr.getNextSibling().left;\\n        \\t\\telse\\n        \\t\\t\\tbreak;\\n        \\t}\\n        \\tcurr = curr.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600990,
                "title": "very-easy-bfs-solution-c-hint-for-constant-space",
                "content": "Hint for constant space -> is to use the next links that you just created \\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL) return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            int j=0;\\n            for(int i=0;i<n;i++){\\n                Node* node = q.front();\\n                q.pop();\\n                j++;\\n                if(j<n){\\n                    Node* x = q.front();\\n                    node->next = x;\\n                }else{\\n                    node->next = NULL;\\n                }\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n                \\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL) return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int n=q.size();\\n            int j=0;\\n            for(int i=0;i<n;i++){\\n                Node* node = q.front();\\n                q.pop();\\n                j++;\\n                if(j<n){\\n                    Node* x = q.front();\\n                    node->next = x;\\n                }else{\\n                    node->next = NULL;\\n                }\\n                if(node->left) q.push(node->left);\\n                if(node->right) q.push(node->right);\\n                \\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497972,
                "title": "c-o-1-space-o-n-time-7-lines-solution",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root && root->left != NULL) {\\n            root->left->next = root->right;\\n            connect(root->left);\\n            if(root->next != NULL) root->right->next = root->next->left;\\n            connect(root->right);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root && root->left != NULL) {\\n            root->left->next = root->right;\\n            connect(root->left);\\n            if(root->next != NULL) root->right->next = root->next->left;\\n            connect(root->right);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136720,
                "title": "java-solution-10-lines-code-o-n-time-and-constant-space",
                "content": "Idea here to take advantage of already set values of next. When going to child, parent will already have their next value. We can take advantage of that. This is the minimize solution.\\n\\n```\\npublic Node connect(Node root) {\\n        if(root == null) return root;\\n        modify(root);\\n        \\n        return root;\\n    }\\n    public void modify(Node root){\\n        if(root.left == null && root.right == null){\\n            return;\\n        }\\n        root.left.next = root.right;\\n        if(root.next !=null ){\\n            root.right.next = root.next.left;    \\n        }\\n        modify(root.left);\\n        modify(root.right);  \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic Node connect(Node root) {\\n        if(root == null) return root;\\n        modify(root);\\n        \\n        return root;\\n    }\\n    public void modify(Node root){\\n        if(root.left == null && root.right == null){\\n            return;\\n        }\\n        root.left.next = root.right;\\n        if(root.next !=null ){\\n            root.right.next = root.next.left;    \\n        }\\n        modify(root.left);\\n        modify(root.right);  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 953162,
                "title": "python-jump-game-iii-with-queue-deque-visited-set",
                "content": "BFS to iterate through all indexes connected to starting index. Storing already explored indices allows us to ensure that we only explore each index a single time.\\n\\t\\n\\tdef canReach(self, arr, start):\\n        \\n        q = collections.deque()\\n        q.append(start)\\n        visited = set()\\n        \\n        while q:\\n            cur_i = q.popleft()\\n            \\n            if arr[cur_i] == 0:\\n                return True\\n            \\n            a, b = cur_i + arr[cur_i], cur_i - arr[cur_i]\\n            \\n            if a < len(arr) and a not in visited:\\n                q.append(a)\\n                visited.add(a)\\n            if b >= 0 and b not in visited:\\n                q.append(b)\\n                visited.add(b)\\n                \\n        return False",
                "solutionTags": [],
                "code": "BFS to iterate through all indexes connected to starting index. Storing already explored indices allows us to ensure that we only explore each index a single time.\\n\\t\\n\\tdef canReach(self, arr, start):\\n        \\n        q = collections.deque()\\n        q.append(start)\\n        visited = set()\\n        \\n        while q:\\n            cur_i = q.popleft()\\n            \\n            if arr[cur_i] == 0:\\n                return True\\n            \\n            a, b = cur_i + arr[cur_i], cur_i - arr[cur_i]\\n            \\n            if a < len(arr) and a not in visited:\\n                q.append(a)\\n                visited.add(a)\\n            if b >= 0 and b not in visited:\\n                q.append(b)\\n                visited.add(b)\\n                \\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 935186,
                "title": "c-constant-space-iterative-recursive",
                "content": "Iteraitve Solution \\n\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root || !root->left) return root;\\n        Node *current = root;\\n        while(current->left) {\\n            Node *temp = current;\\n            while(current) {\\n                current->left->next = current->right;\\n                if(current->next) current->right->next = current->next->left;\\n                current = current->next;\\n            }\\n            current = temp->left;\\n        }\\n        return root;\\n    }\\n};\\n```\\n\\nRecursive Solution \\n\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root || !root->left) return root;\\n        root->left->next = root->right;\\n        if(root->next) root->right->next = root->next->left;\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root || !root->left) return root;\\n        Node *current = root;\\n        while(current->left) {\\n            Node *temp = current;\\n            while(current) {\\n                current->left->next = current->right;\\n                if(current->next) current->right->next = current->next->left;\\n                current = current->next;\\n            }\\n            current = temp->left;\\n        }\\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root || !root->left) return root;\\n        root->left->next = root->right;\\n        if(root->next) root->right->next = root->next->left;\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762896,
                "title": "5-lines-recursive-python-solution",
                "content": "\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\', next=None) -> \\'Node\\':\\n        if root is None: return None\\n        root.next = next\\n        self.connect(root.left, root.right)\\n        self.connect(root.right, root.next.left if root.next else None)\\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\', next=None) -> \\'Node\\':\\n        if root is None: return None\\n        root.next = next\\n        self.connect(root.left, root.right)\\n        self.connect(root.right, root.next.left if root.next else None)\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 629881,
                "title": "go-golang-dfs-bfs",
                "content": "1. DFS\\n```golang\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Left *Node\\n *     Right *Node\\n *     Next *Node\\n * }\\n */\\n\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    if root.Left != nil {\\n        root.Left.Next = root.Right\\n        \\n        if root.Next != nil {\\n            root.Right.Next = root.Next.Left\\n        }\\n    }\\n    \\n    connect(root.Left)\\n    connect(root.Right)\\n    \\n    return root\\n}\\n```\\n2. BFS\\n```golang\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Left *Node\\n *     Right *Node\\n *     Next *Node\\n * }\\n */\\n\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    q := []*Node{ root }\\n    \\n    for len(q) > 0 {\\n        var pre *Node\\n        \\n        for _, n := range q {\\n            q = q[1:]\\n            \\n            if pre != nil {\\n                pre.Next = n\\n            }\\n            \\n            pre = n\\n            \\n            if n.Left != nil {\\n                q = append(q, n.Left)\\n            }\\n            \\n            if n.Right != nil {\\n                q = append(q, n.Right)\\n            }\\n        }\\n    }\\n    \\n    return root\\n}\\n```",
                "solutionTags": [],
                "code": "```golang\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Left *Node\\n *     Right *Node\\n *     Next *Node\\n * }\\n */\\n\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    if root.Left != nil {\\n        root.Left.Next = root.Right\\n        \\n        if root.Next != nil {\\n            root.Right.Next = root.Next.Left\\n        }\\n    }\\n    \\n    connect(root.Left)\\n    connect(root.Right)\\n    \\n    return root\\n}\\n```\n```golang\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Left *Node\\n *     Right *Node\\n *     Next *Node\\n * }\\n */\\n\\nfunc connect(root *Node) *Node {\\n    if root == nil {\\n        return nil\\n    }\\n    \\n    q := []*Node{ root }\\n    \\n    for len(q) > 0 {\\n        var pre *Node\\n        \\n        for _, n := range q {\\n            q = q[1:]\\n            \\n            if pre != nil {\\n                pre.Next = n\\n            }\\n            \\n            pre = n\\n            \\n            if n.Left != nil {\\n                q = append(q, n.Left)\\n            }\\n            \\n            if n.Right != nil {\\n                q = append(q, n.Right)\\n            }\\n        }\\n    }\\n    \\n    return root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 504940,
                "title": "easy-understand-python-solution",
                "content": "class Solution(object):\\n\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        if not root.left:\\n            return root\\n        root.left.next = root.right\\n        if root.next:\\n            root.right.next = root.next.left\\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root",
                "solutionTags": [],
                "code": "class Solution(object):\\n\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        if not root.left:\\n            return root\\n        root.left.next = root.right\\n        if root.next:\\n            root.right.next = root.next.left\\n        self.connect(root.left)\\n        self.connect(root.right)\\n        return root",
                "codeTag": "Java"
            },
            {
                "id": 307621,
                "title": "simple-recursive-preorder-traversal",
                "content": "```\\npublic void connectHelper(Node root){\\n\\tif(root == null) return;\\n\\tif(root.left != null) root.left.next = root.right;\\n\\tif(root.right != null) root.right.next = (root.next == null) ? null: root.next.left;\\n\\tconnectHelper(root.left);\\n\\tconnectHelper(root.right);\\n\\n}\\npublic Node connect(Node root) {\\n\\tconnectHelper(root);\\n\\treturn root;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic void connectHelper(Node root){\\n\\tif(root == null) return;\\n\\tif(root.left != null) root.left.next = root.right;\\n\\tif(root.right != null) root.right.next = (root.next == null) ? null: root.next.left;\\n\\tconnectHelper(root.left);\\n\\tconnectHelper(root.right);\\n\\n}\\npublic Node connect(Node root) {\\n\\tconnectHelper(root);\\n\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 291622,
                "title": "python-recursive-solution",
                "content": "\\u5728\\u8FD9\\u4E2Arecursion chapter\\u5B66\\u4E60\\u81EA\\u5DF1\\u609F\\u51FA\\u6765\\u7684\\u4E00\\u4E2A\\u65B9\\u6CD5\\u3002\\n\\u4ECEexample\\u53EF\\u4EE5\\u53D1\\u73B0\\u7ED9\\u7684\\u89C4\\u5F8B\\u5C31\\u662F\\n\\u6BCF\\u4E2A\\u8282\\u70B9\\uFF08\\u975E\\u53F6\\u5B50\\u7ED3\\u70B9\\uFF09\\u5FC5\\u6709\\u4E24\\u4E2A\\u5B50\\u8282\\u70B9\\n\\u5BF9\\u6BCF\\u4E00level\\u7684\\u8282\\u70B9\\u90FD\\u8FDB\\u884C\\u5982\\u4E0B\\u64CD\\u4F5C\\nleft.next = right\\nright.next = None\\n\\u4F46\\u662F\\u8FD9\\u91CC\\u53EA\\u662F\\u8FDE\\u63A5\\u4E86\\u4E24\\u4E2A\\u8282\\u70B9\\uFF0C\\u4E00\\u5C42level\\u91CC\\u9762\\u8282\\u70B9\\u4E0D\\u6B62\\u8FD9\\u4E48\\u591A\\uFF0C\\u8FD8\\u6709\\u4E2D\\u95F4\\u7684\\uFF0C\\u5C31\\u662F\\u5DE6\\u5B50\\u6811\\u548C\\u53F3\\u5B50\\u6811\\u7684\\u4E4B\\u95F4\\u7684\\u5DE6\\u5B50\\u6811\\u7684\\u53F3\\u8282\\u70B9\\uFF0C\\u548C\\u53F3\\u5B50\\u6811\\u7684\\u5DE6\\u8282\\u70B9\\u8981\\u8FDE\\u63A5\\u8D77\\u6765\\uFF0C\\u6240\\u4EE5\\u9012\\u5F52\\u5199\\u4E86\\u4E2D\\u95F4\\u7684\\nconnect(left.right,right,left)\\n\\u867D\\u7136\\u6700\\u540E\\u5B9E\\u73B0\\u4E86\\u7A0B\\u5E8F\\uFF0C\\u4F46\\u662F\\u6539\\u8FDB\\u7684\\u5730\\u65B9\\u8FD8\\u662F\\u6709\\u5E8F\\u591A\\n\\u5C31\\u6BD4\\u5982\\uFF0C\\u8FD9\\u4E2Aright.next = None\\uFF0C\\u8FD9\\u91CC\\u64CD\\u4F5C\\u4E86\\u591A\\u6B21\\uFF0C\\u5982\\u679C\\u53EF\\u4EE5\\u53EA\\u8981\\u8FDE\\u63A5\\u4E00\\u6B21\\u5C31\\u8FDE\\u4E0A\\u7684\\u8BDD\\u662F\\u6700\\u597D\\u7684\\u4E86\\u3002\\n```\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        root.next = None\\n        def connect(left,right):\\n            if left and right:\\n                left.next = right\\n                right.next = None\\n                connect(left.left,left.right)\\n                connect(left.right,right.left)\\n                connect(right.left,right.right)\\n        connect(root.left,root.right)\\n        return root\\n```\\n\\u5F88\\u660E\\u663E\\u8FD9\\u4E2A\\u4E5F\\u53EF\\u4EE5\\u7528BFS\\u6765\\u505A\\uFF0C\\u540C\\u6837\\uFF0C\\u4E5F\\u662F\\u4E4B\\u524D\\u4ECE\\u8BC4\\u8BBA\\u91CC\\u9762\\u5B66\\u5230\\u7684queue\\u5B9E\\u73B0\\u7684BFS\\u6765\\u89E3\\u51B3\\u8FD9\\u91CC\\u7684\\u95EE\\u9898\\n```\\nfrom collections import deque\\n\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        root.next = None\\n        queue = deque([root])\\n        while queue:\\n            temp,size=[],len(queue)\\n            for i in range(size):\\n                node = queue.popleft()\\n                if node:\\n                    temp.append(node)\\n                if node.left and node.right:\\n                    queue.append(node.left)\\n                    queue.append(node.right)\\n            for index,node in enumerate(temp[:-1]):\\n                node.next = temp[index+1]\\n            temp[-1].next = None\\n        return root\\n```\\n\\u4ECE\\u8BC4\\u8BBA\\u91CC\\u9762\\u5B66\\u5230\\u7684\\u4E00\\u4E2A\\u65B9\\u6CD5\\uFF0C\\u786E\\u5B9E\\uFF0CBFS\\u53EF\\u4EE5\\u4F7F\\u7528\\uFF0C\\u4F46\\u662F\\u6211\\u4EEC\\u6CA1\\u6709\\u5FC5\\u8981\\u7528\\u4E00\\u4E2Aqueue\\u6765\\u5B58\\u50A8node\\uFF0C\\n\\u56E0\\u4E3Anode\\u6709next\\u8282\\u70B9\\uFF0C\\u5F53\\u6211\\u4EEC\\u6709\\u4E00\\u4E2A\\u5934\\u7ED3\\u70B9\\u4E4B\\u540E\\uFF0C\\u5C31\\u53EF\\u4EE5\\u50CF\\u94FE\\u8868\\u4E00\\u6837\\u53BB\\u8BBF\\u95EE\\u4E86\\u3002\\nreference\\uFF1A\\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/37465/Python-Solution-With-Explaintion\\n```\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        cur = root\\n        nex = cur.left\\n        while cur.left:\\n            cur.left.next = cur.right\\n            if cur.next:\\n                cur.right.next = cur.next.left\\n                cur = cur.next\\n            else:\\n                cur = nex\\n                nex = cur.left\\n        return root\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        root.next = None\\n        def connect(left,right):\\n            if left and right:\\n                left.next = right\\n                right.next = None\\n                connect(left.left,left.right)\\n                connect(left.right,right.left)\\n                connect(right.left,right.right)\\n        connect(root.left,root.right)\\n        return root\\n```\n```\\nfrom collections import deque\\n\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        root.next = None\\n        queue = deque([root])\\n        while queue:\\n            temp,size=[],len(queue)\\n            for i in range(size):\\n                node = queue.popleft()\\n                if node:\\n                    temp.append(node)\\n                if node.left and node.right:\\n                    queue.append(node.left)\\n                    queue.append(node.right)\\n            for index,node in enumerate(temp[:-1]):\\n                node.next = temp[index+1]\\n            temp[-1].next = None\\n        return root\\n```\n```\\nclass Solution(object):\\n    def connect(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not root:\\n            return None\\n        cur = root\\n        nex = cur.left\\n        while cur.left:\\n            cur.left.next = cur.right\\n            if cur.next:\\n                cur.right.next = cur.next.left\\n                cur = cur.next\\n            else:\\n                cur = nex\\n                nex = cur.left\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37658,
                "title": "a-simple-java-recursive-solution-in-6-lines",
                "content": "    public void connect(TreeLinkNode root) {\\n        if (root == null || root.left ==null) return;\\n        root.left.next = root.right;\\n        if (root.next!=null)\\n        root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n    }",
                "solutionTags": [],
                "code": "    public void connect(TreeLinkNode root) {\\n        if (root == null || root.left ==null) return;\\n        root.left.next = root.right;\\n        if (root.next!=null)\\n        root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37668,
                "title": "9-line-fast-c-without-recursion",
                "content": "    class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            while (root) {\\n                TreeLinkNode *a = root;\\n                while (a) {\\n                    if (a->left) {\\n                        a->left->next = a->right;\\n                        if (a->next)\\n                            a->right->next = a->next->left;\\n                    }\\n                    a=a->next;\\n                }\\n                root=root->left;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void connect(TreeLinkNode *root) {\\n            while (root) {\\n                TreeLinkNode *a = root;\\n                while (a) {\\n                    if (a->left) {\\n                        a->left->next = a->right;\\n                        if (a->next)\\n                            a->right->next = a->next->left;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3482395,
                "title": "easy-o-n-intutive-c-solution-by-bfs-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        int i,j,k,c=0;\\n        int d1,d2;\\n        queue<Node*>q;\\n        vector<int>ans;\\n\\n        if(!root)\\n        return 0;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            int n=q.size();\\n\\n            for(i=0;i<n;i++){\\n                Node* curr=q.front();\\n                q.pop();\\n                if(i<n-1){\\n                    curr->next=q.front();\\n                } else{\\n                    curr->next=NULL;\\n                }\\n                if(curr->left){\\n                    q.push(curr->left);\\n                }\\n                if(curr->right){\\n                    q.push(curr->right);\\n                }\\n            }\\n            \\n        }\\n      return root;\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        int i,j,k,c=0;\\n        int d1,d2;\\n        queue<Node*>q;\\n        vector<int>ans;\\n\\n        if(!root)\\n        return 0;\\n        q.push(root);\\n\\n        while(!q.empty()){\\n            int n=q.size();\\n\\n            for(i=0;i<n;i++){\\n                Node* curr=q.front();\\n                q.pop();\\n                if(i<n-1){\\n                    curr->next=q.front();\\n                } else{\\n                    curr->next=NULL;\\n                }\\n                if(curr->left){\\n                    q.push(curr->left);\\n                }\\n                if(curr->right){\\n                    q.push(curr->right);\\n                }\\n            }\\n            \\n        }\\n      return root;\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3298937,
                "title": "python-4-diffrent-solutions-bfs-dfs",
                "content": "# 1. Iterative BFS | Space:O(n)\\n```\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if( root == None ):\\n            return root;\\n        q = deque();\\n        q.append(root);\\n        while( len(q) > 0 ):\\n            prev = None ;\\n            size = len(q);\\n            while(size > 0 ):\\n                node = q.popleft();\\n                node.next = prev;\\n                prev = node;\\n                if(node.right):q.append(node.right);\\n                if(node.left):q.append(node.left);\\n                size -= 1;\\n        return root;\\n```\\n\\n# 2.Recursive DFS | Space: O(n)\\n\\n```\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        hmap = defaultdict(list);\\n\\n        def dfs(node,h):\\n            if( node == None ):\\n                return;\\n            else:\\n                hmap[h].append(node);\\n                dfs(node.left,h+1);\\n                dfs(node.right,h+1);\\n        \\n        dfs(root,0);\\n        for key in hmap.keys():\\n            for i in range(0, len(hmap[key])-1 ):\\n                hmap[key][i].next = hmap[key][i+1]\\n            hmap[key][-1].next = None\\n        return root\\n```\\n\\n# 3.Recusive DFS | Space:O(logn)\\n\\n```\\ndef connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if( root == None ):\\n            return;\\n        root.next = None;\\n        def dfs(node):\\n            if( node == None or node.left == None ):\\n                return;\\n            node.left.next = node.right;\\n            if(node.next):\\n                node.right.next =node.next.left;\\n            dfs(node.left);\\n            dfs(node.right);    \\n\\n        dfs(root);\\n        return root;\\n\\n```\\n\\n# 4. Iterative Optimized BFS or Level order traversal | O(1)\\n```\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        prev = root;\\n        cur = root;\\n        while(prev):\\n            cur = prev;\\n            while( cur ):\\n                if(cur.left):\\n                    cur.left.next = cur.right;\\n                    if(cur.next):\\n                        cur.right.next = cur.next.left;\\n                cur = cur.next;\\n            prev = prev.left;\\n\\n        return root;\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if( root == None ):\\n            return root;\\n        q = deque();\\n        q.append(root);\\n        while( len(q) > 0 ):\\n            prev = None ;\\n            size = len(q);\\n            while(size > 0 ):\\n                node = q.popleft();\\n                node.next = prev;\\n                prev = node;\\n                if(node.right):q.append(node.right);\\n                if(node.left):q.append(node.left);\\n                size -= 1;\\n        return root;\\n```\n```\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        hmap = defaultdict(list);\\n\\n        def dfs(node,h):\\n            if( node == None ):\\n                return;\\n            else:\\n                hmap[h].append(node);\\n                dfs(node.left,h+1);\\n                dfs(node.right,h+1);\\n        \\n        dfs(root,0);\\n        for key in hmap.keys():\\n            for i in range(0, len(hmap[key])-1 ):\\n                hmap[key][i].next = hmap[key][i+1]\\n            hmap[key][-1].next = None\\n        return root\\n```\n```\\ndef connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if( root == None ):\\n            return;\\n        root.next = None;\\n        def dfs(node):\\n            if( node == None or node.left == None ):\\n                return;\\n            node.left.next = node.right;\\n            if(node.next):\\n                node.right.next =node.next.left;\\n            dfs(node.left);\\n            dfs(node.right);    \\n\\n        dfs(root);\\n        return root;\\n\\n```\n```\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        prev = root;\\n        cur = root;\\n        while(prev):\\n            cur = prev;\\n            while( cur ):\\n                if(cur.left):\\n                    cur.left.next = cur.right;\\n                    if(cur.next):\\n                        cur.right.next = cur.next.left;\\n                cur = cur.next;\\n            prev = prev.left;\\n\\n        return root;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3195670,
                "title": "beats-96-94-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses a level-order traversal of the binary tree and a queue to keep track of the nodes. For each level, it sets the next pointers of the nodes to the next node in the queue, except for the last node in the level. It then adds the node\\'s children to the queue if they exist, and continues with the next level. The function returns the root node of the binary tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return root\\n        \\n        # Start with the root node\\n        queue = [root]\\n        \\n        while queue:\\n            # Get the number of nodes in the current level\\n            size = len(queue)\\n            \\n            # Traverse through the nodes in the current level\\n            for i in range(size):\\n                # Get the first node from the queue\\n                node = queue.pop(0)\\n                \\n                # If it\\'s not the last node in the level, set its next to the next node in the queue\\n                if i < size - 1:\\n                    node.next = queue[0]\\n                \\n                # Add the node\\'s children to the queue if they exist\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n        \\n        # Return the root node\\n        return root\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return root\\n        \\n        # Start with the root node\\n        queue = [root]\\n        \\n        while queue:\\n            # Get the number of nodes in the current level\\n            size = len(queue)\\n            \\n            # Traverse through the nodes in the current level\\n            for i in range(size):\\n                # Get the first node from the queue\\n                node = queue.pop(0)\\n                \\n                # If it\\'s not the last node in the level, set its next to the next node in the queue\\n                if i < size - 1:\\n                    node.next = queue[0]\\n                \\n                # Add the node\\'s children to the queue if they exist\\n                if node.left:\\n                    queue.append(node.left)\\n                if node.right:\\n                    queue.append(node.right)\\n        \\n        # Return the root node\\n        return root\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301718,
                "title": "c-both-recursive-and-iterative-solution",
                "content": "**Iterative approach - same concept as level order traversal**\\n```\\n Node* connect(Node* root) {\\n        if(!root)\\n            return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while(!q.empty()){\\n            Node* curr = q.front();\\n            q.pop();\\n            if(curr==NULL){\\n                if(q.size()>0)\\n                    q.push(NULL);\\n            }\\n            else{\\n                curr->next = q.front();\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n        }\\n        return root;     \\n    }\\n```\\n**Recursive code**\\n```\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return root;\\n        if(root->left){\\n            root->left->next = root->right;\\n            if(root->next)\\n                root->right->next = root->next->left;\\n        }\\n        connect(root->left);\\n        connect(root->right);\\n        return root;     \\n    }\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Queue"
                ],
                "code": "```\\n Node* connect(Node* root) {\\n        if(!root)\\n            return NULL;\\n        queue<Node*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        while(!q.empty()){\\n            Node* curr = q.front();\\n            q.pop();\\n            if(curr==NULL){\\n                if(q.size()>0)\\n                    q.push(NULL);\\n            }\\n            else{\\n                curr->next = q.front();\\n                if(curr->left)\\n                    q.push(curr->left);\\n                if(curr->right)\\n                    q.push(curr->right);\\n            }\\n        }\\n        return root;     \\n    }\\n```\n```\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return root;\\n        if(root->left){\\n            root->left->next = root->right;\\n            if(root->next)\\n                root->right->next = root->next->left;\\n        }\\n        connect(root->left);\\n        connect(root->right);\\n        return root;     \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1598642,
                "title": "simplest-solution-you-can-find-java-beats-100",
                "content": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        populate(root);\\n        return root;\\n    }\\n    \\n    public void populate(Node root){\\n        \\n        if(root==null)\\n            return;\\n        // fill left\\'s next\\n        if(root.left != null)\\n            root.left.next = root.right;\\n     \\n        // fill right\\'s next based on the next of current node\\n        // this will work simply cuz the root\\'s next\\n        // will always be filled before coming at this line \\n        // Or it will be null in case if the root is the most\\n        // right on it\\'s level\\n        if(root.right!=null && root.next !=null)\\n            root.right.next = root.next.left;\\n        \\n        // Do the same for left and right branches\\n        populate(root.left);\\n        populate(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        populate(root);\\n        return root;\\n    }\\n    \\n    public void populate(Node root){\\n        \\n        if(root==null)\\n            return;\\n        // fill left\\'s next\\n        if(root.left != null)\\n            root.left.next = root.right;\\n     \\n        // fill right\\'s next based on the next of current node\\n        // this will work simply cuz the root\\'s next\\n        // will always be filled before coming at this line \\n        // Or it will be null in case if the root is the most\\n        // right on it\\'s level\\n        if(root.right!=null && root.next !=null)\\n            root.right.next = root.next.left;\\n        \\n        // Do the same for left and right branches\\n        populate(root.left);\\n        populate(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510637,
                "title": "dfs-bfs-approach-java-easy-to-understand-commented-explanation",
                "content": "Method 1: **DFS**\\n\\n\\tpublic Node connect(Node root) {\\n        dfs(root);\\n        return root;\\n    }\\n\\n    private void dfs(Node root) {\\n        // base case\\n        if (root == null) return;\\n        // if root is not a leaf node\\n        if (root.left != null) {\\n            // add reference of immediate right node in current depth level\\n            root.left.next = root.right;\\n            if (root.next != null) {\\n                root.right.next = root.next.left;\\n            }\\n        }\\n        // traverse left and right subtree\\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n\\t\\nMethod 2: **BFS**\\n\\n\\tpublic Node connect(Node root) {\\n        if (root == null) return root;\\n\\n        Queue<Node> q = new LinkedList<>();\\n        int depth = 0;  // current depth level in binary tree\\n        q.add(root);    // adding root of the binary tree\\n        while (!q.isEmpty()) {\\n            Node prev = q.poll();   // take out the left most element of current depth\\n            // adding their children into the queue\\n            if (prev.left != null && prev.right != null) {\\n                q.add(prev.left);\\n                q.add(prev.right);\\n            }\\n            // depth \"d\" has 2^d number of nodes\\n            for (int i = 1; i < (1 << depth); i++) {\\n                Node curr = q.poll();\\n                prev.next = curr;   // adding next to previous node in current depth level\\n                prev = curr;        // making current as previous\\n                // adding children into the queue\\n                if (prev.left != null && prev.right != null) {\\n                    q.add(prev.left);\\n                    q.add(prev.right);\\n                }\\n            }\\n            // going one level deep\\n            depth++;\\n        }\\n        // returning root of the binary tree\\n        return root;\\n    }\\n\\t\\nFor more solution like this visit my [github repo](https://github.com/Pandit98himanshu/SwitchJob).",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "Method 1: **DFS**\\n\\n\\tpublic Node connect(Node root) {\\n        dfs(root);\\n        return root;\\n    }\\n\\n    private void dfs(Node root) {\\n        // base case\\n        if (root == null) return;\\n        // if root is not a leaf node\\n        if (root.left != null) {\\n            // add reference of immediate right node in current depth level\\n            root.left.next = root.right;\\n            if (root.next != null) {\\n                root.right.next = root.next.left;\\n            }\\n        }\\n        // traverse left and right subtree\\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n\\t\\nMethod 2: **BFS**\\n\\n\\tpublic Node connect(Node root) {\\n        if (root == null) return root;\\n\\n        Queue<Node> q = new LinkedList<>();\\n        int depth = 0;  // current depth level in binary tree\\n        q.add(root);    // adding root of the binary tree\\n        while (!q.isEmpty()) {\\n            Node prev = q.poll();   // take out the left most element of current depth\\n            // adding their children into the queue\\n            if (prev.left != null && prev.right != null) {\\n                q.add(prev.left);\\n                q.add(prev.right);\\n            }\\n            // depth \"d\" has 2^d number of nodes\\n            for (int i = 1; i < (1 << depth); i++) {\\n                Node curr = q.poll();\\n                prev.next = curr;   // adding next to previous node in current depth level\\n                prev = curr;        // making current as previous\\n                // adding children into the queue\\n                if (prev.left != null && prev.right != null) {\\n                    q.add(prev.left);\\n                    q.add(prev.right);\\n                }\\n            }\\n            // going one level deep\\n            depth++;\\n        }\\n        // returning root of the binary tree\\n        return root;\\n    }\\n\\t\\nFor more solution like this visit my [github repo](https://github.com/Pandit98himanshu/SwitchJob).",
                "codeTag": "Unknown"
            },
            {
                "id": 1424191,
                "title": "easy-java-solution-o-1-space-100-fastest",
                "content": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n    if(root == null || root.left == null || root.right == null)\\n        return root;\\n    root.left.next = root.right;\\n        if(root.next!=null)\\n        {\\n            root.right.next = root.next.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n    if(root == null || root.left == null || root.right == null)\\n        return root;\\n    root.left.next = root.right;\\n        if(root.next!=null)\\n        {\\n            root.right.next = root.next.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326340,
                "title": "c-16ms-16-7mb-easy-recursive-solution",
                "content": "Please upvote this solution to give me validation :)\\n```\\nNode* connect(Node* root) {\\n        if (root != nullptr) helper(root->left, root->right);\\n        return root;\\n    }\\n    \\n    void helper(Node*& leftNode, Node*& rightNode) {\\n        if (!leftNode) {\\n            return;\\n        }\\n        leftNode->next = rightNode;\\n        helper(leftNode->left, leftNode->right);\\n        helper(leftNode->right, rightNode->left);\\n        helper(rightNode->left, rightNode->right);\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "Please upvote this solution to give me validation :)\\n```\\nNode* connect(Node* root) {\\n        if (root != nullptr) helper(root->left, root->right);\\n        return root;\\n    }\\n    \\n    void helper(Node*& leftNode, Node*& rightNode) {\\n        if (!leftNode) {\\n            return;\\n        }\\n        leftNode->next = rightNode;\\n        helper(leftNode->left, leftNode->right);\\n        helper(leftNode->right, rightNode->left);\\n        helper(rightNode->left, rightNode->right);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1317964,
                "title": "c-solution-easy-o-n-time-o-1-space",
                "content": "***Please Upvote the solution, if you like it.***\\n```\\nclass Solution {\\npublic:\\n    void dfs(Node* a,Node* b)\\n    {\\n        if(a==NULL&&b==NULL)\\n            return;\\n        a->next=b;\\n        b->next=NULL;\\n\\t\\t//the below function calls are just simulations, as told in the question.\\n        dfs(a->left,a->right);\\n        dfs(a->right,b->left);\\n        dfs(b->left,b->right);\\n    }\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return NULL;\\n        root->next=NULL;\\n        dfs(root->left,root->right);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(Node* a,Node* b)\\n    {\\n        if(a==NULL&&b==NULL)\\n            return;\\n        a->next=b;\\n        b->next=NULL;\\n\\t\\t//the below function calls are just simulations, as told in the question.\\n        dfs(a->left,a->right);\\n        dfs(a->right,b->left);\\n        dfs(b->left,b->right);\\n    }\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return NULL;\\n        root->next=NULL;\\n        dfs(root->left,root->right);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234428,
                "title": "c-self-explanatory-code",
                "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL || root->left == NULL) return root;\\n        if(root->next != NULL){\\n            root->right->next=root->next->left;\\n        }\\n        root->left->next = root->right;\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root == NULL || root->left == NULL) return root;\\n        if(root->next != NULL){\\n            root->right->next=root->next->left;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1019039,
                "title": "c-two-approaches-bfs-using-queue-recursive",
                "content": "## Iterative BFS approach using Queue\\n***Level Order Traversal***\\n### T = O(n) & S = O(n) where n is total number of nodes\\n```\\n    Node* connect(Node* root) {\\n          if(!root)return root;\\n        queue<Node*> Q;\\n        Q.push(root);\\n        while(!Q.empty()){\\n            int n=Q.size();\\n            for(int i=0;i<n;i++){\\n                Node* x=Q.front();\\n                Q.pop();\\n                if(i!=n-1)x->next=q.front();\\n                if(x->left)Q.push(x->left);\\n                if(x->right)Q.push(x->right);\\n            }\\n        }\\n        return root;\\n    }\\n```\\n## Recursive approach\\n```\\t\\nprivate: \\n    void connectLeftToRight(Node* L, Node* R) {\\n        if(L == NULL) {\\n            return;\\n        }\\n        L->next = R;\\n        connectLeftToRight(L->left, L->right);\\n        connectLeftToRight(L->right, R->left);\\n        connectLeftToRight(R->left, R->right);\\n    }    \\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        connectLeftToRight(root->left, root->right);\\n        return root;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    Node* connect(Node* root) {\\n          if(!root)return root;\\n        queue<Node*> Q;\\n        Q.push(root);\\n        while(!Q.empty()){\\n            int n=Q.size();\\n            for(int i=0;i<n;i++){\\n                Node* x=Q.front();\\n                Q.pop();\\n                if(i!=n-1)x->next=q.front();\\n                if(x->left)Q.push(x->left);\\n                if(x->right)Q.push(x->right);\\n            }\\n        }\\n        return root;\\n    }\\n```\n```\\t\\nprivate: \\n    void connectLeftToRight(Node* L, Node* R) {\\n        if(L == NULL) {\\n            return;\\n        }\\n        L->next = R;\\n        connectLeftToRight(L->left, L->right);\\n        connectLeftToRight(L->right, R->left);\\n        connectLeftToRight(R->left, R->right);\\n    }    \\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        connectLeftToRight(root->left, root->right);\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 955215,
                "title": "iterative-go-w-comments",
                "content": "```go\\nfunc connect(root *Node) *Node {\\n\\t// guard against edge case\\n\\tif root == nil {\\n\\t\\treturn root\\n\\t}\\n\\t// initialize nxt as root\\n\\tnxt := root\\n\\n\\t// loop over every level\\n\\tfor nxt.Left != nil {\\n\\t\\t// point current at next\\n\\t\\tcur := nxt\\n\\n\\t\\t// loop over this level\\n\\t\\tfor cur != nil {\\n\\t\\t\\t// point current\\'s left at current\\'s right\\n\\t\\t\\tcur.Left.Next = cur.Right\\n\\n\\t\\t\\t// if current has a next, point current\\'s right\\n\\t\\t\\t// at the left of the current\\'s next\\n\\t\\t\\tif cur.Next != nil {\\n\\t\\t\\t\\tcur.Right.Next = cur.Next.Left\\n\\t\\t\\t}\\n\\n\\t\\t\\t// move current to the next node in its level\\n\\t\\t\\tcur = cur.Next\\n\\t\\t}\\n\\n\\t\\t// move down a level to the left\\n\\t\\tnxt = nxt.Left\\n\\t}\\n\\n\\t// return root\\n\\treturn root\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc connect(root *Node) *Node {\\n\\t// guard against edge case\\n\\tif root == nil {\\n\\t\\treturn root\\n\\t}\\n\\t// initialize nxt as root\\n\\tnxt := root\\n\\n\\t// loop over every level\\n\\tfor nxt.Left != nil {\\n\\t\\t// point current at next\\n\\t\\tcur := nxt\\n\\n\\t\\t// loop over this level\\n\\t\\tfor cur != nil {\\n\\t\\t\\t// point current\\'s left at current\\'s right\\n\\t\\t\\tcur.Left.Next = cur.Right\\n\\n\\t\\t\\t// if current has a next, point current\\'s right\\n\\t\\t\\t// at the left of the current\\'s next\\n\\t\\t\\tif cur.Next != nil {\\n\\t\\t\\t\\tcur.Right.Next = cur.Next.Left\\n\\t\\t\\t}\\n\\n\\t\\t\\t// move current to the next node in its level\\n\\t\\t\\tcur = cur.Next\\n\\t\\t}\\n\\n\\t\\t// move down a level to the left\\n\\t\\tnxt = nxt.Left\\n\\t}\\n\\n\\t// return root\\n\\treturn root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 934256,
                "title": "java-2-approaches-bfs-recursion",
                "content": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            \\n            while(size--!=0){\\n               Node node = queue.poll();\\n\\t\\t\\t   \\n               if(size == 0){\\n                   node.next = null;\\n               }else{\\n                   node.next = queue.peek();\\n               }\\n\\t\\t\\t   \\n                if(node.left != null)\\n                queue.offer(node.left);\\n\\t\\t\\t\\t\\n                 if(node.right != null)\\n                queue.offer(node.right);\\n\\t\\t\\t\\t\\n            }\\n        }\\n        \\n        return root;\\n        \\n    }\\n}\\n```\\n\\nMore Optimal approach. Inspired by this post - https://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/934042/JAVA-Clean-Code-O(N)-Time-Complexity-100-Faster-Solution\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null || root.left == null) return root;\\n        \\n        root.left.next = root.right;\\n        \\n        if(root.next !=null)\\n        root.right.next = root.next.left;\\n        \\n        \\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(root);\\n        \\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            \\n            while(size--!=0){\\n               Node node = queue.poll();\\n\\t\\t\\t   \\n               if(size == 0){\\n                   node.next = null;\\n               }else{\\n                   node.next = queue.peek();\\n               }\\n\\t\\t\\t   \\n                if(node.left != null)\\n                queue.offer(node.left);\\n\\t\\t\\t\\t\\n                 if(node.right != null)\\n                queue.offer(node.right);\\n\\t\\t\\t\\t\\n            }\\n        }\\n        \\n        return root;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null || root.left == null) return root;\\n        \\n        root.left.next = root.right;\\n        \\n        if(root.next !=null)\\n        root.right.next = root.next.left;\\n        \\n        \\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745081,
                "title": "java-recursive-and-iterative-solutions-clear",
                "content": "- Recursive\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n        if (root.left != null) root.left.next = root.right;\\n        if (root.right != null && root.next != null) root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```\\n- Iterative\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node p = root;\\n        while (p != null) {\\n            Node cur = p;\\n            while (cur != null) {\\n                if (cur.left != null) cur.left.next = cur.right;\\n                if (cur.right != null && cur.next != null) cur.right.next = cur.next.left;\\n                cur = cur.next;\\n            }\\n            p = p.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if (root == null) return null;\\n        if (root.left != null) root.left.next = root.right;\\n        if (root.right != null && root.next != null) root.right.next = root.next.left;\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node p = root;\\n        while (p != null) {\\n            Node cur = p;\\n            while (cur != null) {\\n                if (cur.left != null) cur.left.next = cur.right;\\n                if (cur.right != null && cur.next != null) cur.right.next = cur.next.left;\\n                cur = cur.next;\\n            }\\n            p = p.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678158,
                "title": "java-3-different-solutions-without-queue-recursion-using-queue",
                "content": "**Using Queue(Breadth-First Search) :**\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n \\xA0 \\xA0public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n \\xA0 \\xA0 \\xA0 \\xA0queue.add(root); \\xA0 \\xA0 \\xA0 \\xA0\\n        while(!queue.isEmpty()){\\n            queue.add(new Node(Integer.MIN_VALUE));\\n            int size = queue.size();\\n            while(size-- > 0){\\n                Node node = queue.remove();\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(node.val == Integer.MIN_VALUE){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0break;\\n                }\\n                \\n                node.next = (queue.peek().val == Integer.MIN_VALUE) ? null : queue.peek();\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n                if(node.left != null){\\n                    queue.add(node.left);\\n                }\\n                \\n                if(node.right != null){\\n                    queue.add(node.right);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0} \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```\\n**Using Recursion(Depth-First Search) :**\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n \\xA0 \\xA0 \\xA0 \\xA0if(root == null) return root; \\xA0 \\xA0 \\xA0 \\xA0\\n        connectUtility(root);\\n        return root;\\n    }\\n    \\n    public void connectUtility(Node root){\\n        if(root == null) return;\\n        \\n        if(root.left != null){\\n            root.left.next = root.right;\\n            if(root.next != null){\\n                root.right.next = root.next.left;\\n            }\\n \\xA0 \\xA0 \\xA0 \\xA0} \\xA0 \\xA0 \\xA0 \\xA0\\n        connectUtility(root.left);\\n        connectUtility(root.right);\\n    }\\n}\\n```\\n**Without Queue(Breadth-First Traversal) :**\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        \\n        Node levelNodes = root;\\n        while(levelNodes != null){\\n            //to traverse all the nodes of the current level\\n            Node currentNode = levelNodes;\\n            while(currentNode != null){\\n                if(currentNode.left != null){\\n                    currentNode.left.next = currentNode.right;\\n                    //connect the right_node of the left-subtree to the left_node of the right-subtree of the parent tree\\n                    if(currentNode.next != null){\\n                        currentNode.right.next = currentNode.next.left;\\n                    }\\n                }\\n                currentNode = currentNode.next;\\n            }\\n            levelNodes = levelNodes.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n \\xA0 \\xA0public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        \\n        Queue<Node> queue = new LinkedList<>();\\n \\xA0 \\xA0 \\xA0 \\xA0queue.add(root); \\xA0 \\xA0 \\xA0 \\xA0\\n        while(!queue.isEmpty()){\\n            queue.add(new Node(Integer.MIN_VALUE));\\n            int size = queue.size();\\n            while(size-- > 0){\\n                Node node = queue.remove();\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if(node.val == Integer.MIN_VALUE){\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0break;\\n                }\\n                \\n                node.next = (queue.peek().val == Integer.MIN_VALUE) ? null : queue.peek();\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n                if(node.left != null){\\n                    queue.add(node.left);\\n                }\\n                \\n                if(node.right != null){\\n                    queue.add(node.right);\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0} \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0\\n            }\\n        }\\n        return root;\\n    }\\n}\\n```\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n \\xA0 \\xA0 \\xA0 \\xA0if(root == null) return root; \\xA0 \\xA0 \\xA0 \\xA0\\n        connectUtility(root);\\n        return root;\\n    }\\n    \\n    public void connectUtility(Node root){\\n        if(root == null) return;\\n        \\n        if(root.left != null){\\n            root.left.next = root.right;\\n            if(root.next != null){\\n                root.right.next = root.next.left;\\n            }\\n \\xA0 \\xA0 \\xA0 \\xA0} \\xA0 \\xA0 \\xA0 \\xA0\\n        connectUtility(root.left);\\n        connectUtility(root.right);\\n    }\\n}\\n```\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return root;\\n        \\n        Node levelNodes = root;\\n        while(levelNodes != null){\\n            //to traverse all the nodes of the current level\\n            Node currentNode = levelNodes;\\n            while(currentNode != null){\\n                if(currentNode.left != null){\\n                    currentNode.left.next = currentNode.right;\\n                    //connect the right_node of the left-subtree to the left_node of the right-subtree of the parent tree\\n                    if(currentNode.next != null){\\n                        currentNode.right.next = currentNode.next.left;\\n                    }\\n                }\\n                currentNode = currentNode.next;\\n            }\\n            levelNodes = levelNodes.left;\\n        }\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439405,
                "title": "c-simple-recursive-solution",
                "content": "```\\npublic class Solution {\\n\\tprotected void Connect(Node left, Node right) {\\n\\t\\tif (left == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tleft.next = right;\\n\\n\\t\\tConnect(left.left, left.right);\\n\\t\\tif (right != null) {\\n\\t\\t\\tConnect(right.left, right.right);\\n\\t\\t\\tConnect(left.right, right.left);\\n\\t\\t}  \\n\\t}\\n    \\n    public Node Connect(Node root) {\\n        Connect(root, null);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n\\tprotected void Connect(Node left, Node right) {\\n\\t\\tif (left == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tleft.next = right;\\n\\n\\t\\tConnect(left.left, left.right);\\n\\t\\tif (right != null) {\\n\\t\\t\\tConnect(right.left, right.right);\\n\\t\\t\\tConnect(left.right, right.left);\\n\\t\\t}  \\n\\t}\\n    \\n    public Node Connect(Node root) {\\n        Connect(root, null);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 232382,
                "title": "c-well-commented-solution-o-n-time-o-1-space-100-works-for-all-binary-trees",
                "content": "```\\n/* Please note that this solution works for all types of trees, whether complete or not*/\\n\\n/* Idea---- Before going to any level, make sure that all next of that level is set */\\n/* Maintain this invariant and then solve level by level */\\n\\nclass Solution\\n{\\npublic:\\n    TreeLinkNode* firstNodeJustBelow(TreeLinkNode* root);\\n    void connect(TreeLinkNode *root);\\n};\\n\\n\\n/* Returns the firstNodeJustBelow root */\\nTreeLinkNode* Solution :: firstNodeJustBelow(TreeLinkNode* root)\\n{\\n    // If root is not present, return nullptr\\n    if(!root) return root;\\n    \\n    // Keep Moving right till you find the answer\\n    while(root)\\n    {\\n        // If the left child is present, it is the answer\\n        if(root->left) return root->left;\\n        \\n        // Else if the right child is present, it is the answer\\n        else if(root->right) return root->right;\\n    \\n        // If none of them are present, move to the right of root and then go down\\n        else root = root->next;\\n    }\\n    \\n    return root;\\n}\\n\\n/* Populates the next Pointers */\\nvoid Solution :: connect(TreeLinkNode *root)\\n{\\n    // If no root, nothing to Populate\\n    if(!root) return;\\n    \\n    // Declare it outside to prevent memory wastage. It stores the node whose child is being corrected\\n    TreeLinkNode* current;\\n    \\n    while(root)\\n    {\\n        // Store the address of the first node in the level to get down to the first node in the next level\\n        current = root;\\n        \\n        // Correct all the nodes in the next level before getting down\\n        while(current)\\n        {\\n            // If the left child exits, connect it to the right child, if it exists, else connect it further\\n            if(current->left)\\n                (current->left)->next = (current->right) ? current->right : firstNodeJustBelow(current->next);\\n            \\n            // If the right child exists, connect it to the next node\\n            if(current->right)\\n                (current->right)->next = firstNodeJustBelow(current->next);\\n            \\n            // Correct the children of the next nodes in this level    \\n            current = current->next;    \\n        }\\n        \\n        // Move down to the first node in the next level\\n        root = firstNodeJustBelow(root);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/* Please note that this solution works for all types of trees, whether complete or not*/\\n\\n/* Idea---- Before going to any level, make sure that all next of that level is set */\\n/* Maintain this invariant and then solve level by level */\\n\\nclass Solution\\n{\\npublic:\\n    TreeLinkNode* firstNodeJustBelow(TreeLinkNode* root);\\n    void connect(TreeLinkNode *root);\\n};\\n\\n\\n/* Returns the firstNodeJustBelow root */\\nTreeLinkNode* Solution :: firstNodeJustBelow(TreeLinkNode* root)\\n{\\n    // If root is not present, return nullptr\\n    if(!root) return root;\\n    \\n    // Keep Moving right till you find the answer\\n    while(root)\\n    {\\n        // If the left child is present, it is the answer\\n        if(root->left) return root->left;\\n        \\n        // Else if the right child is present, it is the answer\\n        else if(root->right) return root->right;\\n    \\n        // If none of them are present, move to the right of root and then go down\\n        else root = root->next;\\n    }\\n    \\n    return root;\\n}\\n\\n/* Populates the next Pointers */\\nvoid Solution :: connect(TreeLinkNode *root)\\n{\\n    // If no root, nothing to Populate\\n    if(!root) return;\\n    \\n    // Declare it outside to prevent memory wastage. It stores the node whose child is being corrected\\n    TreeLinkNode* current;\\n    \\n    while(root)\\n    {\\n        // Store the address of the first node in the level to get down to the first node in the next level\\n        current = root;\\n        \\n        // Correct all the nodes in the next level before getting down\\n        while(current)\\n        {\\n            // If the left child exits, connect it to the right child, if it exists, else connect it further\\n            if(current->left)\\n                (current->left)->next = (current->right) ? current->right : firstNodeJustBelow(current->next);\\n            \\n            // If the right child exists, connect it to the next node\\n            if(current->right)\\n                (current->right)->next = firstNodeJustBelow(current->next);\\n            \\n            // Correct the children of the next nodes in this level    \\n            current = current->next;    \\n        }\\n        \\n        // Move down to the first node in the next level\\n        root = firstNodeJustBelow(root);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231526,
                "title": "c-well-commented-solution",
                "content": "```\\n/*Idea borrowed from  */\\n/* https://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/37473/My-recursive-solution(Java) */\\n\\n/* Please note that this solution only works for complete binary trees */\\n\\nclass Solution\\n{\\npublic:\\n    void connect(TreeLinkNode *root);\\n};\\n\\n/* Connects the nodes at the same level */\\nvoid Solution :: connect(TreeLinkNode* root)\\n{\\n    // If root is empty, nothing to connect\\n    if(!root) return;\\n    \\n    /* Correct the next and right pointers of the root of the left subtree and right subtree */\\n    // This is necessary as we require this to correct the next pointer of the right child of the left subtree\\n    if(root->left)\\n        root->left->next = root->right;\\n    \\n    /* The left child corrected */\\n    \\n    // If the right child exists, move to the right of root. Now, if right neighbour of root exists,\\n    // Connect the right child of root to the left child of root->next\\n    if(root->right)\\n        root->right->next = (root->next) ? (root->next)->left : nullptr;\\n    \\n    /* The above part is very tricky and powerful at the same time */\\n    \\n    /* Recursively correct both trees */\\n    connect(root->left);\\n    connect(root->right);\\n}\\n\\n/* Further ideas */\\n/* We assume that whenever we reach a node, it\\'s next pointer is already set */\\n/* To maintain this invariant, we need to set the next pointers of left and right child before moving down */\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/*Idea borrowed from  */\\n/* https://leetcode.com/problems/populating-next-right-pointers-in-each-node/discuss/37473/My-recursive-solution(Java) */\\n\\n/* Please note that this solution only works for complete binary trees */\\n\\nclass Solution\\n{\\npublic:\\n    void connect(TreeLinkNode *root);\\n};\\n\\n/* Connects the nodes at the same level */\\nvoid Solution :: connect(TreeLinkNode* root)\\n{\\n    // If root is empty, nothing to connect\\n    if(!root) return;\\n    \\n    /* Correct the next and right pointers of the root of the left subtree and right subtree */\\n    // This is necessary as we require this to correct the next pointer of the right child of the left subtree\\n    if(root->left)\\n        root->left->next = root->right;\\n    \\n    /* The left child corrected */\\n    \\n    // If the right child exists, move to the right of root. Now, if right neighbour of root exists,\\n    // Connect the right child of root to the left child of root->next\\n    if(root->right)\\n        root->right->next = (root->next) ? (root->next)->left : nullptr;\\n    \\n    /* The above part is very tricky and powerful at the same time */\\n    \\n    /* Recursively correct both trees */\\n    connect(root->left);\\n    connect(root->right);\\n}\\n\\n/* Further ideas */\\n/* We assume that whenever we reach a node, it\\'s next pointer is already set */\\n/* To maintain this invariant, we need to set the next pointers of left and right child before moving down */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 163181,
                "title": "easy-java-solution",
                "content": "a lot of solution is over killed here.\\nPlease realize this is full binary tree\\n```\\npublic void connect(TreeLinkNode root) {\\n        if (root == null) return;\\n        connect(root.left, root.right);\\n    }\\n    \\n    private void connect(TreeLinkNode n1, TreeLinkNode n2) {\\n        if (n1 == null) return;\\n        n1.next = n2;\\n        connect(n1.left, n1.right);\\n        connect(n1.right, n2.left);\\n        connect(n2.left, n2.right);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic void connect(TreeLinkNode root) {\\n        if (root == null) return;\\n        connect(root.left, root.right);\\n    }\\n    \\n    private void connect(TreeLinkNode n1, TreeLinkNode n2) {\\n        if (n1 == null) return;\\n        n1.next = n2;\\n        connect(n1.left, n1.right);\\n        connect(n1.right, n2.left);\\n        connect(n2.left, n2.right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37706,
                "title": "o-n-java-solution-very-easy-to-understand",
                "content": "    public void connect(TreeLinkNode root) {\\n        if(root == null) return;\\n        TreeLinkNode le = root.left;\\n        TreeLinkNode ri = root.right;\\n        while(le != null) {\\n            le.next = ri;\\n            le = le.right;\\n            ri = ri.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n    }\\n\\n\\nEvery root only takes care of connecting the rightmost nodes in its left child to the leftmost nodes in its right child. Then recurse.",
                "solutionTags": [],
                "code": "    public void connect(TreeLinkNode root) {\\n        if(root == null) return;\\n        TreeLinkNode le = root.left;\\n        TreeLinkNode ri = root.right;\\n        while(le != null) {\\n            le.next = ri;\\n            le = le.right;\\n            ri = ri.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n    }\\n\\n\\nEvery root only takes care of connecting the rightmost nodes in its left child to the leftmost nodes in its right child. Then recurse.",
                "codeTag": "Unknown"
            },
            {
                "id": 37518,
                "title": "java-a-5-line-iterative-space-o-1-and-a-short-iterative-bfssolution",
                "content": "    // Iterative Space O(1) Solution\\n    public void connect(TreeLinkNode root) {\\n        for(TreeLinkNode lead = root; lead != null; lead = lead.left)\\n            for(TreeLinkNode cur = lead; cur != null; cur = cur.next){\\n                if(cur.left != null) cur.left.next = cur.right;\\n                if(cur.right != null && cur.next != null) cur.right.next = cur.next.left;\\n            }\\n    }\\n\\n    // Iterative BFS Solution\\n    public void connect(TreeLinkNode root) {\\n        Queue<TreeLinkNode> queue = new LinkedList<TreeLinkNode>();\\n        if(root != null) queue.offer(root);\\n        TreeLinkNode next = null, cur = null;\\n        for(int n = 1; !queue.isEmpty(); n *= 2, next = null, cur = null)\\n            for(int i = 0; i < n; i++){\\n                cur = queue.poll();\\n                cur.next = next;\\n                next = cur;\\n                if(cur.right != null){\\n                    queue.offer(cur.right);\\n                    queue.offer(cur.left);\\n                }\\n            }\\n    }",
                "solutionTags": [],
                "code": "    // Iterative Space O(1) Solution\\n    public void connect(TreeLinkNode root) {\\n        for(TreeLinkNode lead = root; lead != null; lead = lead.left)\\n            for(TreeLinkNode cur = lead; cur != null; cur = cur.next){\\n                if(cur.left != null) cur.left.next = cur.right;\\n                if(cur.right != null && cur.next != null) cur.right.next = cur.next.left;\\n            }\\n    }\\n\\n    // Iterative BFS Solution\\n    public void connect(TreeLinkNode root) {\\n        Queue<TreeLinkNode> queue = new LinkedList<TreeLinkNode>();\\n        if(root != null) queue.offer(root);\\n        TreeLinkNode next = null, cur = null;\\n        for(int n = 1; !queue.isEmpty(); n *= 2, next = null, cur = null)\\n            for(int i = 0; i < n; i++){\\n                cur = queue.poll();\\n                cur.next = next;\\n                next = cur;\\n                if(cur.right != null){\\n                    queue.offer(cur.right);\\n                    queue.offer(cur.left);\\n                }\\n            }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37728,
                "title": "4ms-c-solution-in-4loc",
                "content": "     void helper(struct TreeLinkNode *root,struct TreeLinkNode* r){\\n        if(!root)   return;\\n        root->next = r;\\n        helper(root->left,root->right);\\n        helper(root->right,r?r->left:NULL);\\n    }   \\n    void connect(struct TreeLinkNode *root) {\\n        helper(root,NULL);\\n    }",
                "solutionTags": [],
                "code": "     void helper(struct TreeLinkNode *root,struct TreeLinkNode* r){\\n        if(!root)   return;\\n        root->next = r;\\n        helper(root->left,root->right);\\n        helper(root->right,r?r->left:NULL);\\n    }   \\n    void connect(struct TreeLinkNode *root) {\\n        helper(root,NULL);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37782,
                "title": "my-java-recursive-solution",
                "content": "I like recursive \\n\\n    public class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null)\\n                return;\\n            connect(root.left);\\n            connect(root.right);\\n            connect(root.left, root.right);\\n        }\\n\\n        public void connect(TreeLinkNode left, TreeLinkNode right) {\\n            while (left != null) {\\n                left.next = right;\\n                left = left.right;\\n                right = right.left;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public void connect(TreeLinkNode root) {\\n            if (root == null)\\n                return;\\n            connect(root.left);\\n            connect(root.right);\\n            connect(root.left, root.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3858980,
                "title": "easy-c-level-order-traversal-bfs",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple level Order traverse BFS \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        queue<Node *> nodes;\\n        nodes.push(root);\\n        Node * cur;\\n        while(!nodes.empty()){\\n            int size = nodes.size();            \\n            while(size--){\\n                cur= nodes.front();\\n                nodes.pop();\\n                if(!nodes.empty()) cur->next = nodes.front(); \\n                if(cur->left) nodes.push(cur->left);\\n                if(cur->right) nodes.push(cur->right);\\n                if(size==0) cur->next=NULL;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        queue<Node *> nodes;\\n        nodes.push(root);\\n        Node * cur;\\n        while(!nodes.empty()){\\n            int size = nodes.size();            \\n            while(size--){\\n                cur= nodes.front();\\n                nodes.pop();\\n                if(!nodes.empty()) cur->next = nodes.front(); \\n                if(cur->left) nodes.push(cur->left);\\n                if(cur->right) nodes.push(cur->right);\\n                if(size==0) cur->next=NULL;\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424002,
                "title": "beats-100-recursion",
                "content": "\\n\\n# Approach\\n\\n![WhatsApp Image 2023-04-16 at 21.05.32.jpeg](https://assets.leetcode.com/users/images/f2599a43-e066-47aa-a828-c886d4b357f5_1681659374.0166218.jpeg)\\n\\nThe nodes will point to :-\\n\\nRoot -> null\\n\\nRoot.left -> Root.right\\n\\nRoot.right(Right subtree) -> null\\n\\nRoot.right(Left subtree) -> Root.left(Right subtree)\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root==null)\\n        return root;\\n\\n    if(root!=null)\\n    {\\n        if(root.left!=null)\\n        root.left.next=root.right;\\n\\n        if(root.right!=null && root.next!=null)\\n        root.right.next=root.next.left;\\n    }\\n        connect(root.left);\\n        connect(root.right);\\n\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root==null)\\n        return root;\\n\\n    if(root!=null)\\n    {\\n        if(root.left!=null)\\n        root.left.next=root.right;\\n\\n        if(root.right!=null && root.next!=null)\\n        root.right.next=root.next.left;\\n    }\\n        connect(root.left);\\n        connect(root.right);\\n\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401091,
                "title": "java-binary-tree-connect",
                "content": "\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node answ = root;\\n        Node tmpLeft;\\n        while (root != null) {\\n            tmpLeft = root.left;\\n            while (root != null && root.left != null) {\\n                    root.left.next = root.right;\\n                if (root.next != null)\\n                    root.right.next = root.next.left;\\n                root = root.next;\\n            }\\n            root = tmpLeft;\\n        }\\n        return answ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n    \\n    public Node(int _val) {\\n        val = _val;\\n    }\\n\\n    public Node(int _val, Node _left, Node _right, Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n\\nclass Solution {\\n    public Node connect(Node root) {\\n        Node answ = root;\\n        Node tmpLeft;\\n        while (root != null) {\\n            tmpLeft = root.left;\\n            while (root != null && root.left != null) {\\n                    root.left.next = root.right;\\n                if (root.next != null)\\n                    root.right.next = root.next.left;\\n                root = root.next;\\n            }\\n            root = tmpLeft;\\n        }\\n        return answ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966856,
                "title": "python-simple-bfs-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- I used a BFS to explore the tree.\\n- At the step *n* of the loop, the queue will contain all the nodes of the level *n* of the tree.\\n- We can then easily connect all the nodes of the same level by iterating over the queue **at the beginning of the loop** (before running the next step of the BFS).\\n\\n\\nUpvote if it helps! \\uD83D\\uDE42 \\n\\n# Code\\n```\\nclass Solution(object):\\n    def connect(self, root):\\n        queue = [root]\\n\\n        while queue:\\n            for i in range(len(queue) - 1):\\n                queue[i].next = queue[i+1]\\n           \\n            for _ in range(len(queue)):\\n                current = queue.pop(0)\\n                if current and current.left:\\n                    queue.append(current.left)\\n                    queue.append(current.right)\\n        return root\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def connect(self, root):\\n        queue = [root]\\n\\n        while queue:\\n            for i in range(len(queue) - 1):\\n                queue[i].next = queue[i+1]\\n           \\n            for _ in range(len(queue)):\\n                current = queue.pop(0)\\n                if current and current.left:\\n                    queue.append(current.left)\\n                    queue.append(current.right)\\n        return root\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953919,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n    if(root==NULL)\\n    return NULL;\\n    queue<Node*>q;\\n    q.push(root);\\n    q.push(NULL);\\n    while(q.size()>1)\\n    {\\n        int size=q.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            Node* node=q.front();\\n            q.pop();\\n            if(node==NULL)\\n            {\\n                q.push(NULL);\\n                continue;\\n            }\\n            if(node->left)\\n            q.push(node->left);\\n            if(node->right)\\n            q.push(node->right);\\n\\n            node->next=q.front();\\n        }\\n    }\\n    return root;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n    if(root==NULL)\\n    return NULL;\\n    queue<Node*>q;\\n    q.push(root);\\n    q.push(NULL);\\n    while(q.size()>1)\\n    {\\n        int size=q.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            Node* node=q.front();\\n            q.pop();\\n            if(node==NULL)\\n            {\\n                q.push(NULL);\\n                continue;\\n            }\\n            if(node->left)\\n            q.push(node->left);\\n            if(node->right)\\n            q.push(node->right);\\n\\n            node->next=q.front();\\n        }\\n    }\\n    return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795148,
                "title": "o-1-space-and-o-n-time-simple-code-in-python",
                "content": "```\\ndef dfs(root):\\n    if root:\\n        if root.left:\\n            root.left.next=root.right\\n        if root.next and root.right:\\n            root.right.next=root.next.left\\n        dfs(root.left)\\n        dfs(root.right)\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        dfs(root)\\n        return  root\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef dfs(root):\\n    if root:\\n        if root.left:\\n            root.left.next=root.right\\n        if root.next and root.right:\\n            root.right.next=root.next.left\\n        dfs(root.left)\\n        dfs(root.right)\\nclass Solution:\\n    def connect(self, root: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        dfs(root)\\n        return  root\\n",
                "codeTag": "Java"
            },
            {
                "id": 2750019,
                "title": "java-100-faster-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n     if(root == null) return null;\\n        Node left = root.left;\\n        Node right = root.right;\\n        while(left != null){\\n            left.next = right;\\n            left = left.right;\\n            right = right.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;   \\n    }\\n}\\n```\\n## PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n     if(root == null) return null;\\n        Node left = root.left;\\n        Node right = root.right;\\n        while(left != null){\\n            left.next = right;\\n            left = left.right;\\n            right = right.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661106,
                "title": "c-o-n-easy-solution",
                "content": "\\nclass Solution {\\npublic:\\n\\n    Node* connect(Node* root) {\\n        \\n         if(root == NULL)\\n              return NULL;\\n \\n          if(root->left != NULL) \\n              root->left->next = root->right;\\n  \\n          if(root->right != NULL && root->next != NULL)\\n                root->right->next = root->next->left;\\n  \\n            connect(root->left);\\n            connect(root->right);\\n        \\n       return root; \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    Node* connect(Node* root) {\\n        \\n         if(root == NULL)\\n              return NULL;\\n \\n          if(root->left != NULL) \\n              root->left->next = root->right;\\n  \\n          if(root->right != NULL && root->next != NULL)\\n                root->right->next = root->next->left;\\n  \\n            connect(root->left);\\n            connect(root->right);\\n        \\n       return root; \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2424367,
                "title": "c-three-recursive-solutions-with-visual-explanation",
                "content": "**Solution 1**\\n![image](https://assets.leetcode.com/users/images/11f92bfd-f5a6-4de1-b904-6e5806ec1d38_1660477598.609047.jpeg)\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return nullptr;\\n        }\\n        \\n        if (root->left) {\\n            root->left->next = root->right;\\n            if (root->next)\\n                root->right->next = root->next->left;\\n\\t\\t\\t\\t\\n            connect(root->left);\\n            connect(root->right);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```\\n\\n**Solution 2**\\n![image](https://assets.leetcode.com/users/images/edff067d-eb96-4e06-a970-2c6f16008f75_1660477773.2009048.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return nullptr;\\n        }\\n        connectTwoNodes(root->left, root->right);\\n        return root;\\n    }\\nprivate:\\n    \\n    void connectTwoNodes(Node* n1, Node* n2) {\\n        if (!n1 || !n2) {\\n            return;\\n        }\\n        \\n\\t\\t// this is to avoid duplicate connection (check the graph below)\\n        if (!n1->next) {\\n            n1->next = n2;\\n        }\\n        \\n        connectTwoNodes(n1->left, n1->right);\\n        connectTwoNodes(n1->right, n2->left);\\n        connectTwoNodes(n2->left, n2->right);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/951f8263-5bba-450e-b649-8ed5b3c7d401_1660478186.5010526.jpeg)\\n\\n**Solution 3**\\n![image](https://assets.leetcode.com/users/images/486cc146-7333-499b-9666-2d43882065a5_1660900827.6746473.jpeg)\\n```\\nNode* connect(Node* root) {\\n\\tif (!root){\\n\\t\\treturn nullptr;\\n\\t}\\n\\n\\tconnect(root->left);\\n\\tconnect(root->right);\\n\\n\\tNode *left = root->left;\\n\\tNode *right = root->right;\\n\\twhile (left != nullptr) {\\n\\t\\tleft->next = right;\\n\\t\\tleft = left->right;\\n\\t\\tright = right->left;\\n\\t}\\n\\n\\treturn root;\\n}\\n```\\n\\nPlease let me know if anything could be improved. Happy coding!",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return nullptr;\\n        }\\n        \\n        if (root->left) {\\n            root->left->next = root->right;\\n            if (root->next)\\n                root->right->next = root->next->left;\\n\\t\\t\\t\\t\\n            connect(root->left);\\n            connect(root->right);\\n        }\\n        \\n        return root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root) {\\n            return nullptr;\\n        }\\n        connectTwoNodes(root->left, root->right);\\n        return root;\\n    }\\nprivate:\\n    \\n    void connectTwoNodes(Node* n1, Node* n2) {\\n        if (!n1 || !n2) {\\n            return;\\n        }\\n        \\n\\t\\t// this is to avoid duplicate connection (check the graph below)\\n        if (!n1->next) {\\n            n1->next = n2;\\n        }\\n        \\n        connectTwoNodes(n1->left, n1->right);\\n        connectTwoNodes(n1->right, n2->left);\\n        connectTwoNodes(n2->left, n2->right);\\n    }\\n};\\n```\n```\\nNode* connect(Node* root) {\\n\\tif (!root){\\n\\t\\treturn nullptr;\\n\\t}\\n\\n\\tconnect(root->left);\\n\\tconnect(root->right);\\n\\n\\tNode *left = root->left;\\n\\tNode *right = root->right;\\n\\twhile (left != nullptr) {\\n\\t\\tleft->next = right;\\n\\t\\tleft = left->right;\\n\\t\\tright = right->left;\\n\\t}\\n\\n\\treturn root;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384432,
                "title": "c-solution-o-n-comments-explained-no-extra-space",
                "content": "```\\nclass Solution {\\npublic:\\n// function for nodes to connect to the right of its node\\n    void Connect(Node* parent, Node* root, int L){\\n\\t\\t// if leaf node, we exit the loop\\n        if(root==NULL)  return;\\n\\t\\t\\n\\t\\t// to check if the node is a left child, we directly connect with right node\\n        if(L)   root->next = parent->right;\\n\\t\\t\\n\\t\\t// there can be two cases if it is right child\\n\\t\\t// 1. its parent-> next is null, then this right child has next also null\\n\\t\\t// 2. its parent-> next is not null, we can get the right node \\n\\t\\t// using the next connected to parent node\\n        else{\\n            if(parent->next==NULL)  root->next = nullptr;\\n            else    root->next = parent->next->left;\\n        }\\n\\t\\t\\n\\t\\t// then we call the same function for both the left and right child.\\n        Connect(root, root->left, 1);\\n        Connect(root, root->right, 0);\\n    }\\n    \\n    Node* connect(Node* root) {\\n\\t\\t// if root is null, return null\\n        if(root==NULL)  return NULL;\\n\\t\\t\\n\\t\\t// the first root node will always have next as null.\\n        root->next=NULL;\\n\\t\\t\\n\\t\\t// then we call our connect function to traverse all nodes and connect them.\\n        Connect(root, root->left, 1);\\n        Connect(root, root->right, 0);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n// function for nodes to connect to the right of its node\\n    void Connect(Node* parent, Node* root, int L){\\n\\t\\t// if leaf node, we exit the loop\\n        if(root==NULL)  return;\\n\\t\\t\\n\\t\\t// to check if the node is a left child, we directly connect with right node\\n        if(L)   root->next = parent->right;\\n\\t\\t\\n\\t\\t// there can be two cases if it is right child\\n\\t\\t// 1. its parent-> next is null, then this right child has next also null\\n\\t\\t// 2. its parent-> next is not null, we can get the right node \\n\\t\\t// using the next connected to parent node\\n        else{\\n            if(parent->next==NULL)  root->next = nullptr;\\n            else    root->next = parent->next->left;\\n        }\\n\\t\\t\\n\\t\\t// then we call the same function for both the left and right child.\\n        Connect(root, root->left, 1);\\n        Connect(root, root->right, 0);\\n    }\\n    \\n    Node* connect(Node* root) {\\n\\t\\t// if root is null, return null\\n        if(root==NULL)  return NULL;\\n\\t\\t\\n\\t\\t// the first root node will always have next as null.\\n        root->next=NULL;\\n\\t\\t\\n\\t\\t// then we call our connect function to traverse all nodes and connect them.\\n        Connect(root, root->left, 1);\\n        Connect(root, root->right, 0);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359491,
                "title": "simple-recursion-o-1-space-o-n-time-c",
                "content": "class Solution {\\npublic:\\n\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return NULL;\\n        Node* ptr1=connect(root->left);\\n        Node* ptr2=connect(root->right);\\n        while(ptr1!=NULL)\\n        {\\n            ptr1->next=ptr2;\\n            ptr1=ptr1->right;\\n            ptr2=ptr2->left;\\n        }\\n        return root;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n\\n    Node* connect(Node* root) {\\n        if(root==NULL)\\n            return NULL;\\n        Node* ptr1=connect(root->left);\\n        Node* ptr2=connect(root->right);\\n        while(ptr1!=NULL)\\n        {\\n            ptr1->next=ptr2;\\n            ptr1=ptr1->right;\\n            ptr2=ptr2->left;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2177257,
                "title": "c-bfs-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        \\n        if( !root ) return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        Node* pre = NULL;\\n        while( !q.empty() ) {\\n            int siz = q.size();\\n            while ( siz-- ) {\\n                Node* p = q.front();\\n                q.pop();\\n                if(siz>0) p->next = q.front();\\n                else p->next = NULL;\\n                if( p->left ){\\n                    q.push(p->left);\\n                }\\n                if( p->right ){\\n                    q.push( p->right );\\n                }\\n            }\\n\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        \\n        if( !root ) return root;\\n        queue<Node*> q;\\n        q.push(root);\\n        Node* pre = NULL;\\n        while( !q.empty() ) {\\n            int siz = q.size();\\n            while ( siz-- ) {\\n                Node* p = q.front();\\n                q.pop();\\n                if(siz>0) p->next = q.front();\\n                else p->next = NULL;\\n                if( p->left ){\\n                    q.push(p->left);\\n                }\\n                if( p->right ){\\n                    q.push( p->right );\\n                }\\n            }\\n\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003544,
                "title": "c-recursive-approach-faster-than-97",
                "content": "```\\n\\nclass Solution {\\n    public:\\n    \\n    Node* connect(Node* root) {\\n        if(!root){\\n            return nullptr;\\n        }\\n        if(root->left){\\n            if(root->right){\\n                root->left->next=root->right;\\n            }\\n\\n        }\\n        if(root->right){\\n            if(root->next){\\n                root->right->next=root->next->left;\\n            }\\n        }\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\n    public:\\n    \\n    Node* connect(Node* root) {\\n        if(!root){\\n            return nullptr;\\n        }\\n        if(root->left){\\n            if(root->right){\\n                root->left->next=root->right;\\n            }\\n\\n        }\\n        if(root->right){\\n            if(root->next){\\n                root->right->next=root->next->left;\\n            }\\n        }\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718160,
                "title": "c-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    Node* connect(Node* r) {\\n        Node* root = r;\\n        while(root) {\\n            Node* tNode = root;\\n            while(tNode) {\\n                if(tNode->left) tNode->left->next = tNode->right;\\n                if(tNode->next && tNode->right) tNode->right->next = tNode->next->left;\\n                tNode = tNode->next;\\n            }\\n            root = root->left;\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    Node* connect(Node* r) {\\n        Node* root = r;\\n        while(root) {\\n            Node* tNode = root;\\n            while(tNode) {\\n                if(tNode->left) tNode->left->next = tNode->right;\\n                if(tNode->next && tNode->right) tNode->right->next = tNode->next->left;\\n                tNode = tNode->next;\\n            }\\n            root = root->left;\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605783,
                "title": "python3-elegant-implementation",
                "content": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \\n        dq = deque()\\n        dq.append(root)\\n        dq.append(None)\\n        \\n        while dq:\\n            for i in range(len(dq)):\\n                x = dq.popleft()\\n                if x is not None:\\n                    x.next = dq[0]\\n                    dq.append(x.left)\\n                    dq.append(x.right)\\n            if dq: dq.append(None)\\n            \\n        return root\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        \\n        dq = deque()\\n        dq.append(root)\\n        dq.append(None)\\n        \\n        while dq:\\n            for i in range(len(dq)):\\n                x = dq.popleft()\\n                if x is not None:\\n                    x.next = dq[0]\\n                    dq.append(x.left)\\n                    dq.append(x.right)\\n            if dq: dq.append(None)\\n            \\n        return root\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516608,
                "title": "easy-recursive-python-solution-with-o-1-space-and-no-helper-function",
                "content": "There\\'s no official recursive solution, but it\\'s quite simple and doesn\\'t require a helper function. The main thing to keep in mind is that the recursion operates on the children *after* the parents have already been previously connected, if necessary.\\n\\n```\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return None\\n        \\n        if root.right:\\n            # the easier connection\\n            if root.left:\\n                root.left.next = root.right\\n            # the harder one between nodes of different parents\\n            # we can do this because we already did the easier connection between the \"parents\"\\n            if root.next:\\n                root.right.next = root.next.left            \\n            \\n        root.left = self.connect(root.left)\\n        root.right = self.connect(root.right)\\n        \\n        return root\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n    def connect(self, root: \\'Node\\') -> \\'Node\\':\\n        if not root:\\n            return None\\n        \\n        if root.right:\\n            # the easier connection\\n            if root.left:\\n                root.left.next = root.right\\n            # the harder one between nodes of different parents\\n            # we can do this because we already did the easier connection between the \"parents\"\\n            if root.next:\\n                root.right.next = root.next.left            \\n            \\n        root.left = self.connect(root.left)\\n        root.right = self.connect(root.right)\\n        \\n        return root\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1395379,
                "title": "simple-dfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(Node* root)\\n    {\\n        if(root->left==nullptr && root->right==nullptr)\\n            return;\\n        if(root->left)\\n            root->left->next=root->right;\\n        if(root->right && root->next)\\n            root->right->next=root->next->left;\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    \\n    Node* connect(Node* root) {\\n        if(root==nullptr)\\n            return nullptr;\\n        dfs(root);\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(Node* root)\\n    {\\n        if(root->left==nullptr && root->right==nullptr)\\n            return;\\n        if(root->left)\\n            root->left->next=root->right;\\n        if(root->right && root->next)\\n            root->right->next=root->next->left;\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    \\n    Node* connect(Node* root) {\\n        if(root==nullptr)\\n            return nullptr;\\n        dfs(root);\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333044,
                "title": "c-bfs",
                "content": "You may find this code extremely similar to level order traversal.\\n```\\nNode* connect(Node* root) {\\n        if(!root) return root;\\n\\n        queue<Node*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int n = q.size();\\n            \\n            for(int i=0; i<n; i++){\\n                Node* node = q.front();\\n                q.pop();\\n                if(i == n-1)\\n                    node->next = NULL;\\n                else\\n                    node->next = q.front();\\n                    \\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nNode* connect(Node* root) {\\n        if(!root) return root;\\n\\n        queue<Node*> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int n = q.size();\\n            \\n            for(int i=0; i<n; i++){\\n                Node* node = q.front();\\n                q.pop();\\n                if(i == n-1)\\n                    node->next = NULL;\\n                else\\n                    node->next = q.front();\\n                    \\n                if(node->left)\\n                    q.push(node->left);\\n                if(node->right)\\n                    q.push(node->right);\\n            }\\n        }\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1147102,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        Node *p = root, *c;     \\n        while(p)\\n        {\\n            c = p;\\n            while(c && c -> left)\\n            {\\n                c -> left -> next = c -> right;\\n                if(c -> next)\\n                {\\n                    c -> right -> next = c -> next -> left;\\n                }\\n                c = c -> next;\\n            }\\n            p = p -> left;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        Node *p = root, *c;     \\n        while(p)\\n        {\\n            c = p;\\n            while(c && c -> left)\\n            {\\n                c -> left -> next = c -> right;\\n                if(c -> next)\\n                {\\n                    c -> right -> next = c -> next -> left;\\n                }\\n                c = c -> next;\\n            }\\n            p = p -> left;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126811,
                "title": "java-recursive-with-comments-0ms-faster-than-100",
                "content": "Observation : The tree is **Perfect**. This means all nodes have 2 childs or no childs, across the tree. \\nWe will use this observation to make changes to **next** based on state of the node itself or both its children\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        \\n\\t\\t// In case the node itself is null, or any of its children are null we return the root. Both childs are null when we reach the leaf node \\n        if(root ==null || root.left == null || root.right == null) {\\n            return root;\\n        }\\n        \\n\\t\\t// The left child will always point to the right child\\n        root.left.next = root.right;\\n        \\n\\t\\t// If the node has a right sibling on same level, then node\\'s right child should always point to the sibling\\'s left child and so on across the level\\n        if(root.next != null) {\\n            root.right.next = root.next.left;\\n        }\\n        \\n\\t\\t// We call the function recursively on both left and right children so that the same operations are performed at each level\\n        connect(root.left); \\n        connect(root.right);\\n        \\n\\t\\t// Returning the root for the modified sub-tree/tree\\n        return root;\\n    }\\n}\\n```\\n\\n*Thank you for reading my post!\\nIf you found it helpful, please upvote or comment.*",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        \\n\\t\\t// In case the node itself is null, or any of its children are null we return the root. Both childs are null when we reach the leaf node \\n        if(root ==null || root.left == null || root.right == null) {\\n            return root;\\n        }\\n        \\n\\t\\t// The left child will always point to the right child\\n        root.left.next = root.right;\\n        \\n\\t\\t// If the node has a right sibling on same level, then node\\'s right child should always point to the sibling\\'s left child and so on across the level\\n        if(root.next != null) {\\n            root.right.next = root.next.left;\\n        }\\n        \\n\\t\\t// We call the function recursively on both left and right children so that the same operations are performed at each level\\n        connect(root.left); \\n        connect(root.right);\\n        \\n\\t\\t// Returning the root for the modified sub-tree/tree\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065116,
                "title": "java-easy-to-understand-o-n-time-and-o-1-space-solution-with-explanations",
                "content": "Algorithm:\\n1. We have to travel all cells by recursion\\n2. If the node is null then we return, that will be the base case.\\n2. Then we will check if the node have a parent or not, if it doesn\\'t have parent then we know it is root and the next will be null\\n3. Then we check if it is left or right\\n4. If it is left then the next will be the parent\\'s right\\n5. If it is right then we check if parent\\'s next is null or not if it is null then it is means it is the rightmost then it\\'s next will also be null\\n6. And if the parent\\'s next is not null then the next will be paren\\'t next left.\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        util(null, root, true);\\n        return root;\\n    }\\n    \\n    public void util(Node parent, Node node, boolean isLeft) {\\n        if (node == null) return;\\n\\t\\tif (parent == null) node.next = null;\\n        else {\\n            if(isLeft)  node.next = parent.right;\\n            else  node.next = parent.next == null ? null : parent.next.left;\\n        }\\n        util(node, node.left, true);\\n        util(node, node.right, false);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        util(null, root, true);\\n        return root;\\n    }\\n    \\n    public void util(Node parent, Node node, boolean isLeft) {\\n        if (node == null) return;\\n\\t\\tif (parent == null) node.next = null;\\n        else {\\n            if(isLeft)  node.next = parent.right;\\n            else  node.next = parent.next == null ? null : parent.next.left;\\n        }\\n        util(node, node.left, true);\\n        util(node, node.right, false);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976388,
                "title": "c-solution-o-1-space-o-n-time",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void populateLowerLevel(Node* root){\\n        Node* iter=root;\\n        while(iter!=NULL){\\n            iter->left->next=iter->right;\\n            if(iter->next!=NULL){\\n                iter->right->next=iter->next->left;\\n            }\\n            iter=iter->next;\\n        }\\n    }\\n    Node* connect(Node* root) {\\n       \\n        Node* curr=root;\\n        while(curr!=NULL && curr->left!=NULL){\\n            populateLowerLevel(curr);\\n            curr=curr->left;\\n        }\\n    return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* left;\\n    Node* right;\\n    Node* next;\\n\\n    Node() : val(0), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}\\n\\n    Node(int _val, Node* _left, Node* _right, Node* _next)\\n        : val(_val), left(_left), right(_right), next(_next) {}\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    void populateLowerLevel(Node* root){\\n        Node* iter=root;\\n        while(iter!=NULL){\\n            iter->left->next=iter->right;\\n            if(iter->next!=NULL){\\n                iter->right->next=iter->next->left;\\n            }\\n            iter=iter->next;\\n        }\\n    }\\n    Node* connect(Node* root) {\\n       \\n        Node* curr=root;\\n        while(curr!=NULL && curr->left!=NULL){\\n            populateLowerLevel(curr);\\n            curr=curr->left;\\n        }\\n    return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934830,
                "title": "go-golang-clean-solutions",
                "content": ">Runtime: 4 ms, faster than 94.42% of Go online submissions for Populating Next Right Pointers in Each Node.\\nMemory Usage: 6.2 MB, less than 8.12% of Go online submissions for Populating Next Right Pointers in Each Node.\\n\\n```go\\nfunc connect(root *Node) *Node {\\n    if root == nil { return root }\\n    queue := []*Node{ root }\\n    for len(queue) != 0 {\\n        pop := queue[0]\\n        queue = queue[1:]\\n        if pop.Left != nil && pop.Right != nil {\\n            pop.Left.Next = pop.Right\\n            if pop.Next != nil {\\n                pop.Right.Next = pop.Next.Left\\n            }\\n            queue = append(queue, pop.Left)\\n            queue = append(queue, pop.Right)\\n        }\\n    }\\n    return root\\n}\\n```\\n\\n>Runtime: 4 ms, faster than 94.42% of Go online submissions for Populating Next Right Pointers in Each Node.\\nMemory Usage: 6.1 MB, less than 25.38% of Go online submissions for Populating Next Right Pointers in Each Node.\\n\\n```go\\nfunc connect(root *Node) *Node {\\n    if root == nil { return root }\\n    var pre, cur *Node\\n    pre = root\\n    for pre.Left != nil {\\n        cur = pre\\n        for cur != nil {\\n            cur.Left.Next = cur.Right\\n            if cur.Next != nil { cur.Right.Next = cur.Next.Left }\\n            cur = cur.Next\\n        }\\n        pre = pre.Left\\n    }\\n    return root\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc connect(root *Node) *Node {\\n    if root == nil { return root }\\n    queue := []*Node{ root }\\n    for len(queue) != 0 {\\n        pop := queue[0]\\n        queue = queue[1:]\\n        if pop.Left != nil && pop.Right != nil {\\n            pop.Left.Next = pop.Right\\n            if pop.Next != nil {\\n                pop.Right.Next = pop.Next.Left\\n            }\\n            queue = append(queue, pop.Left)\\n            queue = append(queue, pop.Right)\\n        }\\n    }\\n    return root\\n}\\n```\n```go\\nfunc connect(root *Node) *Node {\\n    if root == nil { return root }\\n    var pre, cur *Node\\n    pre = root\\n    for pre.Left != nil {\\n        cur = pre\\n        for cur != nil {\\n            cur.Left.Next = cur.Right\\n            if cur.Next != nil { cur.Right.Next = cur.Next.Left }\\n            cur = cur.Next\\n        }\\n        pre = pre.Left\\n    }\\n    return root\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 934260,
                "title": "java-shortest-clean-solution-o-n-time-and-o-1-space-beats-100-easy-to-understand",
                "content": "The code is self explaining.\\n\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        \\n        if (root != null && root.left != null) {\\n            \\n            root.left.next = root.right;\\n            \\n            if(root.next != null) {\\n                root.right.next = root.next.left;\\n            }\\n            \\n            connect(root.left);\\n            connect(root.right);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        \\n        if (root != null && root.left != null) {\\n            \\n            root.left.next = root.right;\\n            \\n            if(root.next != null) {\\n                root.right.next = root.next.left;\\n            }\\n            \\n            connect(root.left);\\n            connect(root.right);\\n        }\\n        \\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934232,
                "title": "from-zero-to-hero-three-approaches-python-3",
                "content": "Hi there! I would like to share my thoughts and solutions to that great problem. As I pointed in the title I will present you with three solutions that take ```O(n)``` time, but different amount of space.\\n\\n\\n**Breadth-first search: O(n) time/space**\\nFrom the beginning I had two thoughts:\\n1. I have to traverse the tree and I am quite happy to know how to do that\\n2. I have to connect all the nodes on the same level\\n\\nAnd after those thoughts, I immediately come up with the idea to use a Deque data structure to collect all the nodes. So the first solution is quite straightforward:\\n```\\nclass Solution:\\n    def connect(self, root: Node) -> Union[Node, None]:\\n        if root is None:\\n            return root\\n\\n        q = deque([root])\\n        while q:\\n            size = len(q)\\n            for i in range(size):\\n                node = q.popleft()\\n\\n                if i + 1 < size:\\n                    node.next = q[0]\\n\\n                if node.left is not None:\\n                    q.append(node.left)\\n                    q.append(node.right)\\n\\n        return root\\n```\\n\\n\\n**Recursion: O(n) time, O(log (n)) space**\\nThe second step was to try to solve the problem by using recursion. One thing I mentioned is that without checking if there is an already existing link between two nodes the algorithm repeats the work he already did before. So pay attention to that!\\n```\\nclass Solution:\\n    def connect(self, root: Node) -> Union[Node, None]:\\n        def traverse(left: Node, right: Node):\\n            if left is None or left.next is right:\\n                return\\n\\n            left.next = right\\n            traverse(left.left, left.right)\\n            traverse(left.right, right.left)\\n            traverse(right.left, right.right)\\n\\n        if root is not None:\\n            traverse(root.left, root.right)\\n\\n        return root\\n```\\n\\n\\n**With Linked List in mind: O(n) time, O(1) space**\\nAnd here is the last one! I should admit this is remarkably elegant and clean code. The way I came up with this algorithm is by observing that actually in the first solution I have used unnecessary space to collect the nodes. But the thing is that when we come to a certain level all the nodes on this level are already connected with the ```next``` link. That gives us the possibility to iterate through the level as if it were a Linked List.\\n```\\nclass Solution:\\n    def connect(self, root: Node) -> Union[Node, None]:\\n        if root is None:\\n            return root\\n\\n        head = tail = root\\n        while tail.left is not None:\\n            tail.left.next = tail.right\\n            if tail.next is not None:\\n                tail.right.next = tail.next.left\\n                tail = tail.next\\n            else:\\n                head = tail = head.left\\n\\n        return root\\n```\\n\\n*\\uD83D\\uDCE2 If you think these solutions are good enough to be recommended to other LeetCoders then upvote.*",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Queue"
                ],
                "code": "```O(n)```\n```\\nclass Solution:\\n    def connect(self, root: Node) -> Union[Node, None]:\\n        if root is None:\\n            return root\\n\\n        q = deque([root])\\n        while q:\\n            size = len(q)\\n            for i in range(size):\\n                node = q.popleft()\\n\\n                if i + 1 < size:\\n                    node.next = q[0]\\n\\n                if node.left is not None:\\n                    q.append(node.left)\\n                    q.append(node.right)\\n\\n        return root\\n```\n```\\nclass Solution:\\n    def connect(self, root: Node) -> Union[Node, None]:\\n        def traverse(left: Node, right: Node):\\n            if left is None or left.next is right:\\n                return\\n\\n            left.next = right\\n            traverse(left.left, left.right)\\n            traverse(left.right, right.left)\\n            traverse(right.left, right.right)\\n\\n        if root is not None:\\n            traverse(root.left, root.right)\\n\\n        return root\\n```\n```next```\n```\\nclass Solution:\\n    def connect(self, root: Node) -> Union[Node, None]:\\n        if root is None:\\n            return root\\n\\n        head = tail = root\\n        while tail.left is not None:\\n            tail.left.next = tail.right\\n            if tail.next is not None:\\n                tail.right.next = tail.next.left\\n                tail = tail.next\\n            else:\\n                head = tail = head.left\\n\\n        return root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 934097,
                "title": "c-easy-solution-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root || !root->left)\\n            return root;\\n        \\n        connect(root->left);\\n        connect(root->right);\\n        \\n        Node* right_ptr = root->right;\\n        Node* left_ptr = root->left;\\n        left_ptr->next = right_ptr;\\n        \\n        while (left_ptr->right) {\\n            left_ptr = left_ptr->right;\\n            right_ptr = right_ptr->left;\\n            left_ptr->next = right_ptr;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (!root || !root->left)\\n            return root;\\n        \\n        connect(root->left);\\n        connect(root->right);\\n        \\n        Node* right_ptr = root->right;\\n        Node* left_ptr = root->left;\\n        left_ptr->next = right_ptr;\\n        \\n        while (left_ptr->right) {\\n            left_ptr = left_ptr->right;\\n            right_ptr = right_ptr->left;\\n            left_ptr->next = right_ptr;\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923575,
                "title": "easy-cpp-8-line-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (root == NULL)\\n            return root;\\n        connectLR(root->left,root->right);\\n        return root;\\n    }\\n    void connectLR(Node* l, Node* r) {\\n        if (l == NULL)\\n            return;\\n        l->next = r;\\n        connectLR(l->left,l->right);\\n        connectLR(l->right,r->left);\\n        connectLR(r->left,r->right);\\n    }\\n};\\n```\\n\\nExplanation:\\n![image](https://assets.leetcode.com/users/images/58c720ed-0429-42e0-8590-04d9022b0caa_1604770737.4726672.png)\\n\\n\\nFor each node:\\n1. Connect left child of its left child with right child of its left child (green)\\n2. Connect right child of its left child with left child of its right child (blue)\\n3. Connect left child of its right child with right child of its right child (red)\\n4. Connect left child to the right child (black)\\n\\nMain trick is that we iterate over two subtrees at the same time (left and right). This trivializes whole problem into four cases mentioned above. \\nFor base case we check if left node is null, since we can\\'t link null node. Due to the fact that trees are guaranteed to be perfectly balanced, we might as well check if right node is null. It doesn\\'t matter.\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if (root == NULL)\\n            return root;\\n        connectLR(root->left,root->right);\\n        return root;\\n    }\\n    void connectLR(Node* l, Node* r) {\\n        if (l == NULL)\\n            return;\\n        l->next = r;\\n        connectLR(l->left,l->right);\\n        connectLR(l->right,r->left);\\n        connectLR(r->left,r->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821882,
                "title": "a-small-recursive-solution-c",
                "content": "A really efficient recursive approach:\\n \\n ```\\n Node* connect(Node* root) {\\n        if(root == NULL)\\n            return NULL;\\n        if(root->left != NULL)\\n            root->left->next = root->right;\\n        if(root->right != NULL && root->next != NULL)\\n            root->right->next = root->next->left;\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n",
                "solutionTags": [],
                "code": "A really efficient recursive approach:\\n \\n ```\\n Node* connect(Node* root) {\\n        if(root == NULL)\\n            return NULL;\\n        if(root->left != NULL)\\n            root->left->next = root->right;\\n        if(root->right != NULL && root->next != NULL)\\n            root->right->next = root->next->left;\\n        connect(root->left);\\n        connect(root->right);\\n        return root;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 710100,
                "title": "c-bfs-solution-easy",
                "content": "Just playing around with the pointers.Here is the code\\n```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root==nullptr) return NULL;\\n        queue<Node *> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size-->0){\\n                Node *front=q.front();\\n                q.pop();\\n                \\n                if(front->left!=nullptr){\\n                        front->left->next=front->right;\\n                    \\n                    q.push(front->left);\\n                }\\n                if(front->right!=nullptr){\\n                    if(front->next!=NULL){\\n                        front->right->next=front->next->left;\\n                    }\\n                    \\n                    q.push(front->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(root==nullptr) return NULL;\\n        queue<Node *> q;\\n        q.push(root);\\n        \\n        while(!q.empty()){\\n            int size=q.size();\\n            while(size-->0){\\n                Node *front=q.front();\\n                q.pop();\\n                \\n                if(front->left!=nullptr){\\n                        front->left->next=front->right;\\n                    \\n                    q.push(front->left);\\n                }\\n                if(front->right!=nullptr){\\n                    if(front->next!=NULL){\\n                        front->right->next=front->next->left;\\n                    }\\n                    \\n                    q.push(front->right);\\n                }\\n            }\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507105,
                "title": "python-bfs-image-attached",
                "content": "#### 116 | Populating Next Right Pointers in Each Node\\n\\n#### BFS Solution\\n\\n```python\\nclass Solution(object):\\n    def connect(self, root):\\n        if not root:\\n            return \\n        queue = collections.deque([root])\\n        while queue:\\n            curr = queue.popleft()\\n            if curr.left and curr.right:\\n                curr.left.next = curr.right\\n                if curr.next:\\n                    curr.right.next = curr.next.left\\n                queue.append(curr.left)\\n                queue.append(curr.right)\\n```\\n\\n![image](https://user-images.githubusercontent.com/6414741/74363006-88872e00-4d7e-11ea-8091-ab49e4a3efc3.png)\\n\\n----\\n\\n![image](https://user-images.githubusercontent.com/6414741/74363019-8f15a580-4d7e-11ea-87d4-a4181f22de05.png)\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def connect(self, root):\\n        if not root:\\n            return \\n        queue = collections.deque([root])\\n        while queue:\\n            curr = queue.popleft()\\n            if curr.left and curr.right:\\n                curr.left.next = curr.right\\n                if curr.next:\\n                    curr.right.next = curr.next.left\\n                queue.append(curr.left)\\n                queue.append(curr.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 433945,
                "title": "easy-java-solution-runtime-0ms-beat-100",
                "content": "For each node, it has two subtree, left subtree and right subtree. At every level, connect the rightmost node of left subtree to the leftmost node of right subtree. \\nAnd do this loop for each node.\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Node left = root.left;\\n        Node right = root.right;\\n        while(left != null) {\\n            left.next = right;\\n            left = left.right;\\n            right = right.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) return null;\\n        Node left = root.left;\\n        Node right = root.right;\\n        while(left != null) {\\n            left.next = right;\\n            left = left.right;\\n            right = right.left;\\n        }\\n        connect(root.left);\\n        connect(root.right);\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405732,
                "title": "java-simple-recursive-solution-beat-100",
                "content": "You just need to iterate the tree from right to left.\\n\\t1. If current node is not leaf node then\\n\\t\\t- set root.left.next = root.right\\n\\t\\t- if root.next is not null, we will set root.right.next = root.next.left\\n\\n```\\nclass Solution {\\n\\tpublic void connectRec(Node root) {\\n\\t\\tif (root == null || root.left == null || root.right == null) return;\\n\\t\\troot.left.next = root.right;\\n\\t\\tif (root.next != null) root.right.next = root.next.left;\\n\\t\\tconnectRec(root.right);\\n\\t\\tcoonectRec(root.left);\\n\\t}\\n\\t\\n\\tpublic Node connect(Node root) {\\n\\t\\tconnectRec(root);\\n\\t\\treturn root;\\n\\t}\\n}\\n```\\nTime Complexity O(N) \\nSpace Complexity O(1)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tpublic void connectRec(Node root) {\\n\\t\\tif (root == null || root.left == null || root.right == null) return;\\n\\t\\troot.left.next = root.right;\\n\\t\\tif (root.next != null) root.right.next = root.next.left;\\n\\t\\tconnectRec(root.right);\\n\\t\\tcoonectRec(root.left);\\n\\t}\\n\\t\\n\\tpublic Node connect(Node root) {\\n\\t\\tconnectRec(root);\\n\\t\\treturn root;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 346354,
                "title": "my-easy-to-understand-recursive-solution-cpp-beat-97",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        if(root->left) {\\n            root->left->next = root->right;\\n            if(root->next) root->right->next = root->next->left;\\n            connect(root->left);\\n            connect(root->right);\\n        }\\n        return root;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        if(!root) return root;\\n        if(root->left) {\\n            root->left->next = root->right;\\n            if(root->next) root->right->next = root->next->left;\\n            connect(root->left);\\n            connect(root->right);\\n        }\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339375,
                "title": "simple-java-recursive-solution-beats-100",
                "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    public int val;\\n    public Node left;\\n    public Node right;\\n    public Node next;\\n\\n    public Node() {}\\n\\n    public Node(int _val,Node _left,Node _right,Node _next) {\\n        val = _val;\\n        left = _left;\\n        right = _right;\\n        next = _next;\\n    }\\n};\\n*/\\n```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) {\\n            return root;\\n        }\\n        root.next = null;\\n        helper(root.left, root.right);\\n        return root;\\n    }\\n    \\n    public void helper(Node root1, Node root2) {\\n        if (root1 == null && root2==null) {\\n            return;\\n        }\\n        root1.next = root2;\\n        helper(root1.left, root1.right);\\n        helper(root1.right, root2.left);\\n        helper(root2.left, root2.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node connect(Node root) {\\n        if(root == null) {\\n            return root;\\n        }\\n        root.next = null;\\n        helper(root.left, root.right);\\n        return root;\\n    }\\n    \\n    public void helper(Node root1, Node root2) {\\n        if (root1 == null && root2==null) {\\n            return;\\n        }\\n        root1.next = root2;\\n        helper(root1.left, root1.right);\\n        helper(root1.right, root2.left);\\n        helper(root2.left, root2.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564620,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1565418,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1568485,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1565480,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1569347,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1572089,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1772435,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1763411,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1569568,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1569567,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1564620,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1565418,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1568485,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1565480,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1569347,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1572089,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1772435,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1763411,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1569568,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1569567,
                "content": [
                    {
                        "username": "stefan",
                        "content": "If you don't want a solution for O(1) space but just a hint, here it is: you need to make use of the *next* links that you're creating."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 29.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Level Order Traversal\n\n  \n**Approach 2:** Using previously established next pointers\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "StephenLalor",
                        "content": "**Think:** what do I need to do, to get to the nodes I want to set as `next`. \\n![image](https://assets.leetcode.com/users/images/e2a321fc-5e45-4c51-a1e7-e86b067aa808_1607295577.9996867.png)\\nWhen I drew this, the solution became obvious!"
                    },
                    {
                        "username": "mvalpha",
                        "content": "woah! This was helpful.. Thank you."
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Great. Thanks to your drawing, I quickly solved the problem. =)"
                    },
                    {
                        "username": "DGanger",
                        "content": "[@Curious12](/Curious12) If you go with DFS and connect root.left.next->root.right than root already has next which helps you connect the blue line."
                    },
                    {
                        "username": "vivekrajsundar",
                        "content": "That\\'s a good hint!"
                    },
                    {
                        "username": "vigneshvicky98",
                        "content": "genius"
                    },
                    {
                        "username": "Curious12",
                        "content": "Ok, So i came up with analogy and draw it on paper, but didn't get. How to do implement this approach, DFS can't applied on this and, BFS questions are mostly done by queue which take 0(n) space. Then how can we implement this in recursive manner. ?"
                    },
                    {
                        "username": "qingdihaian",
                        "content": "Does anyone have an iteration method with constant space solution?"
                    },
                    {
                        "username": "daily2432121",
                        "content": "Downvoted for No C# option"
                    },
                    {
                        "username": "majestic_coder",
                        "content": "Now it has come dear."
                    },
                    {
                        "username": "needmoresleep",
                        "content": "is my leetcode broken or it\\'s just how it is?"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "Its just an application of level order traversal in binary tree. If you know the level order traversal then you can easily do it."
                    },
                    {
                        "username": "salimshamim",
                        "content": "[@nikalinov](/nikalinov)  what about implicit stack space? wouldnt that cover the space used in BFS"
                    },
                    {
                        "username": "nikalinov",
                        "content": "[@lakshyasinghchouhan2509](/lakshyasinghchouhan2509) bruv follow up says to do it with constant space (stack space is ok). BFS is O(n) space"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "[@aryan_upadhyay](/aryan_upadhyay)  brother I get 90.16% faster solution by just using level order traversal\\n"
                    },
                    {
                        "username": "aryan_upadhyay",
                        "content": "bro but what about time complexity\\n"
                    },
                    {
                        "username": "atul1503",
                        "content": "It is the responsibility of the question setter to also mention what to return in the problem statements. It literally takes 2 seconds to type. For some dynamic languages you just can't figure out the return type by looking at the function definition because the sytax does not require you to write the return type."
                    },
                    {
                        "username": "gary16",
                        "content": "Just a minor notice, \\n\\nhow come none of thse posts here bother to even add a ``return`` statement ?"
                    },
                    {
                        "username": "zemgyifei",
                        "content": "Its been 3 years, and still not fixed. The problem asked for no return and actully the test want you to return the root."
                    },
                    {
                        "username": "gary16",
                        "content": "For those who like me had a hard time trying to read the inputs in the example, here\\'s a cleaner version of it, if it helps...\\n![image](https://assets.leetcode.com/users/gary16/image_1563520301.png)\\n"
                    }
                ]
            },
            {
                "id": 1766045,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1729331,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1673798,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1574581,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1572733,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 2062298,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 2045129,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 2002558,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1995070,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1953589,
                "content": [
                    {
                        "username": "aashima19",
                        "content": "can someone please help and tell me what is wrong with my solution?\\nIt is giving me NULL ptr error.\\nThank you :))\\n\\n_________________________________________________________________________\\nclass Solution {\\npublic:\\n    Node* connect(Node* root) {\\n     queue<Node*>q;\\n     q.push(root);\\n     while(!q.empty())\\n     {\\n         int size=q.size();\\n       \\n         for(int i=0;i<size;i++)\\n         {   auto node=q.front();\\n             if(i==size-1)\\n         { // cout<<i<<size-1;\\n                if(node->left!=NULL) \\n                {q.push(node->left); }\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n         }\\n         else  \\n           {           \\n                if(node->left!=NULL) q.push(node->left);\\n                if(node->right!=NULL) q.push(node->right);\\n                q.pop();\\n                Node* node2=q.front();\\n               node->next=node2;\\n              // cout<<node->val;  \\n           }\\n         }\\n     }   \\n     return root;\\n    }\\n};\\n\\n_______________________________________________________________________"
                    },
                    {
                        "username": "uday06",
                        "content": "just add this condition it will work fine\\n\\nif(root==NULL)\\nreturn root;"
                    },
                    {
                        "username": "AdityaPawar1510",
                        "content": "I'm writing pythin solution,\nIn that facing strange issue where queue getting added with extra None in last iteration.\n\n `     \n    \n\n        nodeQueue = [root]\n        height=2\n        ctr=1\n        while nodeQueue:\n            node = nodeQueue.pop(0)\n            if not node:\n                break\n            if node.left:\n                nodeQueue.append(node.left)\n            if node.right:\n                nodeQueue.append(node.right)\n            if ctr==height:\n                height*=2\n                ctr=1\n            else:\n                if nodeQueue:\n                    nodeQueue[0].next=nodeQueue[1]\n                ctr+=1\n        return root\n`\n\nIn above code if below piece is removed it shows error, but we already check None before inserting, I validated by printing queue at each steps, there also i last iterattion it shows None automatically.\n\n`\n\n            if not node:\n                break\n\n`\n "
                    },
                    {
                        "username": "roshan_agr",
                        "content": "somehow connect method is getting called twice, second time with root as None\\ni added this condition in the beginning of connect method to pass all the test cases\\n        if root is None:\\n            return root"
                    },
                    {
                        "username": "Aditya-Sood",
                        "content": "for Go (v1.17.6 as runtime at the time of writing) with BFS using a \\'queue\\' slice (I know, not constant space), I noticed that the runtime was adding a nil element to my \\'queue\\' slice after processing the last element - thereby causing an infinite loop since the size automatically became > 1\\n\\nI\\'ve been through my code multiple times and even printed the state variables to verify the same\\n\\nif anyone else faces the same issue do let me know, I\\'m curious as to why this is happening\\n"
                    },
                    {
                        "username": "nessieyang",
                        "content": "I met the same issue, it already took me half an hour to figure out the reason but I am still wondering why"
                    },
                    {
                        "username": "itaiyz97",
                        "content": "The official solution suggests using O(N) space complexity, but doesn\\'t it say we can only use O(1) space complexity?"
                    },
                    {
                        "username": "abhishekgwal",
                        "content": "I just solved 117 and I found that 116 is also the same ? Why did they post two question which are same? Or did I miss anything ?"
                    },
                    {
                        "username": "ihost",
                        "content": "Don\\u2019t understand, why the default output is [number,#,number,#,number,#\\u2026]. I don\\u2019t know what the default output mean??\\nLet\\u2019s say the test case: [1,2,3,4,5,7,9]\\nThe output is : [1,#,2,#,4,#]\\nDo i have to understand what is going on here to start coding or not? Any suggestion have be grateful!"
                    },
                    {
                        "username": "ihost",
                        "content": "I think i might understood now, it need to point left node to right node at the same level?"
                    },
                    {
                        "username": "Zefick",
                        "content": "Does pre-allocated array of 6000 elements counted as \"constant extra space\"?\\nIn fact as the tree is perfect in this problem, I only need the array of log2(6000) elements, which is just 13."
                    },
                    {
                        "username": "nitissssh",
                        "content": "whys is it medium ?\\n\\n\\n\\n"
                    },
                    {
                        "username": "cjbot1998",
                        "content": "tried to rack my brain to use DFS because saw this problem under DFS. Realized this would be much easier with BFS and saved the effort. smh"
                    },
                    {
                        "username": "namankandol",
                        "content": "Why am I not able to traverse by level order. My code somehow gives TLE. Can someone explain."
                    }
                ]
            },
            {
                "id": 1950680,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1879520,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1872271,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1869170,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1863726,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1863718,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1848647,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1833871,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1825265,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1785371,
                "content": [
                    {
                        "username": "21Cash",
                        "content": "You gotta be kidding me if u expect me to give you the O(1) memory solution without having seen the problem before"
                    },
                    {
                        "username": "rajat_171",
                        "content": "IT\\'s this just BFS ?? with saperator."
                    },
                    {
                        "username": "21Cash",
                        "content": "O(1) memory, how about that?? Still easy??\\n"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n         queue<Node*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            if(size==0){\\n                return root;\\n            }\\n           \\n            while(size>0){\\n                 Node* temp;\\n                 if(size>1){\\n                     temp=q.front();\\n                     q.pop();\\n                     Node * newadd=q.front();\\n\\n                     temp->next=newadd;\\n                 }else{\\n                     temp=q.front();\\n                     q.pop();\\n                 }\\n                 if(temp->left != nullptr){  //----ERROR LINE-------\\n                     q.push(temp->left);\\n                 }\\n                 \\n                 if(temp->right!=nullptr){\\n                     q.push(temp->right);\\n                 }\\n                 size--;\\n                   \\n            }\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\n//   I am unable to understand error in inserting the temp left node if it is not null\\n"
                    },
                    {
                        "username": "ayush_ag",
                        "content": "Why is there a return type in the method. There\\'s nothing mentioned in the question on what needs to be returned."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I think bfs is the best way to visualize a tree in best efficient manner\\n\\n\\uD83D\\uDFE2 it needs only the O(N) extra space in the worst case"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 isn\\'t it same as the Populating Next Right Pointers in Each Node II"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "Very easy question. If you know level order traversal (BFS), this question is a cake walk for you.\nJust perform BFS and for every node, think of how you can connect it with its next node at the same level.\n\nMy solution-\nhttps://leetcode.com/problems/populating-next-right-pointers-in-each-node/solutions/3360359/c-simplest-bfs-solution-o-n-time/\nPLEASE HAVE A LOOK AND UPVOTE.. 🫱🏼‍🫲🏼😇"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who bother what the return object is: the return object should be a Node object of the first level, and the object in other levels should be linked together, yet different layers are not needed to be linked to the node of other levels, and the only return object is the Node of the first level."
                    },
                    {
                        "username": "smbody",
                        "content": "Coding in java,\\n\\nI am able to perform level order traversal, but i am not able to include multiple null values in my answer. How can one do it ?"
                    },
                    {
                        "username": "tdf56f756bg56r8iohgwexu",
                        "content": "Why is there no option for using RUST?\\n"
                    }
                ]
            },
            {
                "id": 1761008,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1749449,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1749358,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1726567,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1723359,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1717320,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1693207,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1682295,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1673850,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            },
            {
                "id": 1671845,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "gekh",
                        "content": "Why is there no Rust?"
                    },
                    {
                        "username": "thannerusaiharshith",
                        "content": "The hint is to use the level order traversal!"
                    },
                    {
                        "username": "gekh",
                        "content": "thanks"
                    },
                    {
                        "username": "Thakur_aman_cs",
                        "content": "This solution uses a queue to store the nodes at each level of the tree, and iterates through the queue to set the next pointers of the nodes. It starts by adding the root node to the queue, and then iterates through the queue until it is empty. For each node in the queue, it sets the next pointer to the next node in the queue (if it exists), and adds the left and right children of the node to the queue. This ensures that the next pointers are set in a breadth-first order."
                    },
                    {
                        "username": "devKangM",
                        "content": " ```\nvar connect = function(root) {\n    let queue = [root];\n    while (queue.length != 0) {\n        console.log(\"start: \", queue.length)\n        const len = queue.length;\n        let nextQueue = [];\n        for (let i = 0; i < len; i++) {\n            const target = queue.shift();\n            if (target.left) nextQueue.push(target.left);\n            if (target.right) nextQueue.push(target.right);\n            if (i === len-1) target.next = null;\n            else target.next = queue[0];\n        }\n        queue = nextQueue;\n        console.log(\"last: \", queue.length);\n\n    }\n    return root;\n};\n```\n\nstart:  1\nlast:  2\nstart:  2\nlast:  4\nstart:  4\nlast:  0\nstart:  1\n\nhere is my code, and Stdout.\nbut some error happen.\n```\nLine 22 in solution.js\n            if (target.left) nextQueue.push(target.left);\n                       ^\nTypeError: Cannot read properties of null (reading 'left')\n    Line 22: Char 24 in solution.js (connect)\n    Line 94: Char 19 in solution.js (Object.<anonymous>)\n    Line 16: Char 8 in runner.js (Object.runner)\n    Line 33: Char 26 in solution.js (Object.<anonymous>)\n    at Module._compile (node:internal/modules/cjs/loader:1101:14)\n    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1153:10)\n    at Module.load (node:internal/modules/cjs/loader:981:32)\n    at Function.Module._load (node:internal/modules/cjs/loader:822:12)\n    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:81:12)\n    at node:internal/main/run_main_module:17:47\n```\nIn this case, i got a problem that i can't understand.\nwhy the queue.length became from 0 to 1 like Stdout?\nI can't understand.... help me"
                    },
                    {
                        "username": "shivamgcoder",
                        "content": "simple recursion solution\\nclass Solution:\\n\\tdef connect(self, root: \\'Node\\') -> \\'Node\\':\\n\\t\\tif not root or not root.left:\\n\\t\\t\\treturn root\\n\\t\\troot.left.next=root.right\\n\\t\\tif root.next:\\n\\t\\t\\troot.right.next=root.next.left\\n\\t\\tself.connect(root.left)\\n\\t\\tself.connect(root.right)\\n\\t\\treturn root\\n"
                    },
                    {
                        "username": "AmanJaiSingh",
                        "content": "class Solution {\\npublic:\\n    Node* connect(Node* root) {\\n        queue<Node* > q1;\\n        q1.push(root);\\n        q1.push(NULL);\\n        while(q1.size()>1){\\n            Node* curr=q1.front();\\n            q1.pop();\\n            if(curr==NULL){\\n                q1.push(NULL);\\n                continue;\\n            }\\n            curr->next=q1.front();\\n            if(curr->left) q1.push(curr->left);\\n            if(curr->right) q1.push(curr->right);\\n        }\\n        return root;\\n        \\n    }\\n};\\n\\nwhy this shows runtime error .. it doesnot pop the null why is this happning,.."
                    },
                    {
                        "username": "Ayush142",
                        "content": "Just add boundry condition , it will work fine\\n        if(root==NULL){\\n            return root;\\n        } "
                    },
                    {
                        "username": "conway22",
                        "content": "so the key point is perfect binary tree!!!"
                    },
                    {
                        "username": "matans844",
                        "content": "I tried to write a solution in C (which was accepted), but I had a problem when using dynamic memory allocation in debug vs non-debug mode.\\n\\nI want to maintain a static array of pointers to the yet unconnected TreeNodes in the tail of each row in the given perfect binary tree so that I can use it and update it while traversing the tree in-order. For this, I need the tree height. I can use the problem constraints to find an upper bound for it, `12`, which is good enough. However, I was aiming at a more general solution in which I can also practice dynamic memory allocation.\\n\\nI came up with the following attempt (which was accepted):\\n```\\n/**\\n * Definition for a Node.\\n * struct Node {\\n *     int val;\\n *     struct Node *left;\\n *     struct Node *right;\\n *     struct Node *next;\\n * };\\n */\\n\\nint curr_height = 0;\\nint height = 0;\\nint have_height = 0;\\n\\nstruct Node ** ptr_to_table = NULL;\\n\\nvoid allocate_direct_table(){\\n\\tint SIZE = height + 9;\\n\\tptr_to_table = calloc(SIZE, sizeof(struct Node *));\\n\\n\\tstruct Node * arr[SIZE];\\n\\tfor(int i=0; i<SIZE; i++){\\n\\t\\tarr[i] = NULL;\\n\\t}\\n\\n\\t*ptr_to_table = arr;\\n\\n\\t\\n\\t// ptr_to_table = malloc((height + 1) * sizeof(struct Node *));\\n\\t// memset(ptr_to_table, 0, (height + 1) * sizeof(struct Node *));\\n}\\n\\nvoid process(struct Node* root){\\n\\tint index = curr_height;\\n\\tif(ptr_to_table[index]){\\n\\t\\tptr_to_table[index] -> next = root;\\n\\t}\\n\\tptr_to_table[index] = root;\\n\\troot -> next = NULL;\\n}\\n\\nvoid preprocess(){\\n\\theight = curr_height;\\n\\tallocate_direct_table();\\n}\\n\\nstruct Node* connect(struct Node* root) {\\n\\tif(!root && !have_height){\\n\\t\\tpreprocess();\\n\\t\\thave_height = 1;\\n\\t\\treturn NULL;\\n\\t}\\n\\tif(!root) return NULL;\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> left);\\n\\tcurr_height --;\\n\\n\\tprocess(root);\\n\\n\\tcurr_height ++;\\n\\tconnect(root -> right);\\n\\tcurr_height --;\\n\\n\\treturn root;\\n    \\n}\\n```\\nI found a behavior of this code that I could not explain. It involves the dynamic memory allocation in the `allocate_direct_table()` function: \\n1. When debugging, I can use `SIZE = height`, and everything works.\\n2. When submitting, I get an `AddressSanitizer: heap-buffer-overflow` error, so I have to increase the height. I have no idea why, and I have no idea why `9` is enough. It probably has to do with the problem constraints, which means my solution is not general.\\n\\nHere is the error when submitting the version with `SIZE = height`:\\n\\nProblematic input:\\n\\n    [-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13]\\n\\nRuntime Error:\\n\\n    =================================================================\\n    ==30==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000178 at pc 0x55979bc921c2 bp 0x7ffd997833a0 sp 0x7ffd99783390\\n    READ of size 8 at 0x603000000178 thread T0\\n        #5 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    0x603000000178 is located 0 bytes to the right of 24-byte region [0x603000000160,0x603000000178)\\n    allocated by thread T0 here:\\n        #0 0x7f179ec8bdc6 in calloc (/lib/x86_64-linux-gnu/libasan.so.5+0x10ddc6)\\n        #7 0x7f179e0460b2 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n    Shadow bytes around the buggy address:\\n      0x0c067fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n      0x0c067fff8000: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8010: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    =>0x0c067fff8020: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00[fa]\\n      0x0c067fff8030: fa fa 00 00 06 fa fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8040: 00 fa fa fa 00 00 00 fa fa fa 00 00 00 00 fa fa\\n      0x0c067fff8050: 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00\\n      0x0c067fff8060: fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa 00 00\\n      0x0c067fff8070: 00 00 fa fa 00 00 00 00 fa fa 00 00 00 00 fa fa\\n    Shadow byte legend (one shadow byte represents 8 application bytes):\\n      Addressable:           00\\n      Partially addressable: 01 02 03 04 05 06 07 \\n      Heap left redzone:       fa\\n      Freed heap region:       fd\\n      Stack left redzone:      f1\\n      Stack mid redzone:       f2\\n      Stack right redzone:     f3\\n      Stack after return:      f5\\n      Stack use after scope:   f8\\n      Global redzone:          f9\\n      Global init order:       f6\\n      Poisoned by user:        f7\\n      Container overflow:      fc\\n      Array cookie:            ac\\n      Intra object redzone:    bb\\n      ASan internal:           fe\\n      Left alloca redzone:     ca\\n      Right alloca redzone:    cb\\n      Shadow gap:              cc\\n    ==30==ABORTING\\n\\n\\n**Questions:**\\n1. Why does `SIZE = height` not work in debug mode?\\n2. Why is it `9` or more that I need to add?\\n\\nAny help is much appreciated!"
                    },
                    {
                        "username": "vdsyrocks",
                        "content": "Do level order traversal with a \"prev\" variable "
                    }
                ]
            }
        ]
    },
    {
        "title": "Combination Sum III",
        "question_content": "<p>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true:</p>\n\n<ul>\n\t<li>Only numbers <code>1</code> through <code>9</code> are used.</li>\n\t<li>Each number is used <strong>at most once</strong>.</li>\n</ul>\n\n<p>Return <em>a list of all possible valid combinations</em>. The list must not contain the same combination twice, and the combinations may be returned in any order.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, n = 7\n<strong>Output:</strong> [[1,2,4]]\n<strong>Explanation:</strong>\n1 + 2 + 4 = 7\nThere are no other valid combinations.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 3, n = 9\n<strong>Output:</strong> [[1,2,6],[1,3,5],[2,3,4]]\n<strong>Explanation:</strong>\n1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\nThere are no other valid combinations.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> k = 4, n = 1\n<strong>Output:</strong> []\n<strong>Explanation:</strong> There are no valid combinations.\nUsing 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 &gt; 1, there are no valid combination.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= k &lt;= 9</code></li>\n\t<li><code>1 &lt;= n &lt;= 60</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 60614,
                "title": "simple-and-clean-java-code-backtracking",
                "content": "     public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        combination(ans, new ArrayList<Integer>(), k, 1, n);\\n        return ans;\\n    }\\n\\n\\tprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\t\\tif (comb.size() == k && n == 0) {\\n\\t\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\t\\tans.add(li);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = start; i <= 9; i++) {\\n\\t\\t\\tcomb.add(i);\\n\\t\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\t\\tcomb.remove(comb.size() - 1);\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "     public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        combination(ans, new ArrayList<Integer>(), k, 1, n);\\n        return ans;\\n    }\\n\\n\\tprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\t\\tif (comb.size() == k && n == 0) {\\n\\t\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\t\\tans.add(li);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = start; i <= 9; i++) {\\n\\t\\t\\tcomb.add(i);\\n\\t\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\t\\tcomb.remove(comb.size() - 1);\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 60805,
                "title": "easy-to-understand-python-solution-backtracking",
                "content": "```\\nclass Solution(object):\\n    def combinationSum3(self, k, n):\\n        ret = []\\n        self.dfs(list(range(1, 10)), k, n, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, k, n, path, ret):\\n        if k < 0 or n < 0:\\n            return \\n        if k == 0 and n == 0:\\n            ret.append(path)\\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], k-1, n-nums[i], path+[nums[i]], ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def combinationSum3(self, k, n):\\n        ret = []\\n        self.dfs(list(range(1, 10)), k, n, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, k, n, path, ret):\\n        if k < 0 or n < 0:\\n            return \\n        if k == 0 and n == 0:\\n            ret.append(path)\\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], k-1, n-nums[i], path+[nums[i]], ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60621,
                "title": "my-c-solution-backtracking",
                "content": "    class Solution {\\n    public:\\n      void combination(vector<vector<int>>& result, vector<int> sol, int k, int n) {\\n        if (sol.size() == k && n == 0) { result.push_back(sol); return ; }\\n        if (sol.size() < k) {\\n          for (int i = sol.empty() ? 1 : sol.back() + 1; i <= 9; ++i) {\\n            if (n - i < 0) break;\\n            sol.push_back(i);\\n            combination(result, sol, k, n - i);\\n            sol.pop_back();\\n          }\\n        }\\n      }\\n    \\n      vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> result;\\n        vector<int> sol;\\n        combination(result, sol, k, n);\\n        return result;\\n      }\\n    };",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public:\\n      void combination(vector<vector<int>>& result, vector<int> sol, int k, int n) {\\n        if (sol.size() == k && n == 0) { result.push_back(sol); return ; }",
                "codeTag": "Java"
            },
            {
                "id": 60624,
                "title": "clean-1-6-7-liners-ac",
                "content": "**Batteries Included**  \\nAC in 44ms\\n\\nFirst the obligatory *\"use the darn library\"* solution. Create all k-combinations of digits and keep those with sum n:\\n\\n    from itertools import combinations\\n\\n    class Solution:\\n        def combinationSum3(self, k, n):\\n            return [c for c in combinations(range(1, 10), k) if sum(c) == n]\\n\\n---\\n\\n**Recursive**  \\nAC in 48 ms\\n\\nBut it's more interesting to do it on your own. Here I use a recursive helper function getting the same k and n as the main function, and an additional cap under which all the numbers have to be:\\n\\n    class Solution:\\n        def combinationSum3(self, k, n):\\n            def combs(k, n, cap):\\n                if not k:\\n                    return [[]] * (not n)\\n                return [comb + [last]\\n                        for last in range(1, cap)\\n                        for comb in combs(k-1, n-last, last)]\\n            return combs(k, n, 10)\\n\\n---\\n\\n**Iterative**  \\nAC in 56 ms\\n\\nAnd an iterative version doing pretty much the same thing, except this time I prepend elements on the left, and use the first element of a partial combination as the cap.\\n\\n    class Solution:\\n        def combinationSum3(self, k, n):\\n            combs = [[]]\\n            for _ in range(k):\\n                combs = [[first] + comb\\n                         for comb in combs\\n                         for first in range(1, comb[0] if comb else 10)]\\n            return [c for c in combs if sum(c) == n]\\n\\n---\\n\\n**Reduce**  \\nAC in 44 ms\\n\\nAnd here's a \"one-liner\" version of the iterative solution using `reduce` instead of the loop:\\n\\n    class Solution:\\n        def combinationSum3(self, k, n):\\n            return [c for c in\\n                    reduce(lambda combs, _: [[first] + comb\\n                                             for comb in combs\\n                                             for first in range(1, comb[0] if comb else 10)],\\n                           range(k), [[]])\\n                    if sum(c) == n]\\n\\n---\\n\\nI note that all these solutions also correctly solve the cases with k=0 and/or n=0 (but leetcode sadly doesn't test those).",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Batteries Included**  \\nAC in 44ms\\n\\nFirst the obligatory *\"use the darn library\"* solution. Create all k-combinations of digits and keep those with sum n:\\n\\n    from itertools import combinations\\n\\n    class Solution:\\n        def combinationSum3(self, k, n):\\n            return [c for c in combinations(range(1, 10), k) if sum(c) == n]\\n\\n---\\n\\n**Recursive**  \\nAC in 48 ms\\n\\nBut it's more interesting to do it on your own. Here I use a recursive helper function getting the same k and n as the main function, and an additional cap under which all the numbers have to be:\\n\\n    class Solution:\\n        def combinationSum3(self, k, n):\\n            def combs(k, n, cap):\\n                if not k:\\n                    return [[]] * (not n)\\n                return [comb + [last]\\n                        for last in range(1, cap)\\n                        for comb in combs(k-1, n-last, last)]\\n            return combs(k, n, 10)\\n\\n---\\n\\n**Iterative**  \\nAC in 56 ms\\n\\nAnd an iterative version doing pretty much the same thing, except this time I prepend elements on the left, and use the first element of a partial combination as the cap.\\n\\n    class Solution:\\n        def combinationSum3(self, k, n):\\n            combs = [[]]\\n            for _ in range(k):\\n                combs = [[first] + comb\\n                         for comb in combs\\n                         for first in range(1, comb[0] if comb else 10)]\\n            return [c for c in combs if sum(c) == n]\\n\\n---\\n\\n**Reduce**  \\nAC in 44 ms\\n\\nAnd here's a \"one-liner\" version of the iterative solution using `reduce` instead of the loop:\\n\\n    class Solution:\\n        def combinationSum3(self, k, n):\\n            return [c for c in\\n                    reduce(lambda combs, _: [[first] + comb\\n                                             for comb in combs\\n                                             for first in range(1, comb[0] if comb else 10)],\\n                           range(k), [[]])\\n                    if sum(c) == n]\\n\\n---\\n\\nI note that all these solutions also correctly solve the cases with k=0 and/or n=0 (but leetcode sadly doesn't test those).",
                "codeTag": "Java"
            },
            {
                "id": 2024061,
                "title": "c-faster-than-100-implementation-explained",
                "content": "* This is a simple backtracking problem.\\n* Try every k length combination for having sum equal to n.\\n* For this try including each number from 1 to 9 to be or not be in a combination. If at any point length of combination equal to k, check for its sum.\\n* If sum == n, include this combination in your answer otherwise backtrack.\\n* To check sum either you can pass a variable in your arguments or decrement n or check sum of elements in the combination vector at the end (like I have done).\\n```\\nclass Solution {\\n    \\n    vector<vector<int>> ansArr;\\n    \\npublic:\\n    \\n    int sum(vector<int>& combination){\\n        int ans = 0;\\n        for(auto x: combination){\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n    \\n    void combinationSumHelper(int k, int n, vector<int>& combination, int num){\\n        \\n        if(k == 0){\\n            if(sum(combination) == n ){\\n                ansArr.push_back(combination);\\n            }\\n            return;\\n        }\\n        \\n        if(num > 9) return;\\n        \\n        combination.push_back(num);  // Including num in combination\\n        combinationSumHelper(k - 1, n, combination, num + 1);\\n        combination.pop_back(); // Not including num in combination\\n        combinationSumHelper(k, n, combination, num + 1);    \\n        \\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int> combination;\\n        combinationSumHelper(k, n, combination, 1);\\n        return ansArr;\\n        \\n    }\\n};\\n```\\n\\nOther Similiar Problems : \\n1. https://leetcode.com/problems/combinations/\\n2. https://leetcode.com/problems/combination-sum/\\n3. https://leetcode.com/problems/combination-sum-ii/\\n4. https://leetcode.com/problems/combination-sum-iv/",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    \\n    vector<vector<int>> ansArr;\\n    \\npublic:\\n    \\n    int sum(vector<int>& combination){\\n        int ans = 0;\\n        for(auto x: combination){\\n            ans += x;\\n        }\\n        return ans;\\n    }\\n    \\n    void combinationSumHelper(int k, int n, vector<int>& combination, int num){\\n        \\n        if(k == 0){\\n            if(sum(combination) == n ){\\n                ansArr.push_back(combination);\\n            }\\n            return;\\n        }\\n        \\n        if(num > 9) return;\\n        \\n        combination.push_back(num);  // Including num in combination\\n        combinationSumHelper(k - 1, n, combination, num + 1);\\n        combination.pop_back(); // Not including num in combination\\n        combinationSumHelper(k, n, combination, num + 1);    \\n        \\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int> combination;\\n        combinationSumHelper(k, n, combination, 1);\\n        return ansArr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60631,
                "title": "fast-easy-java-code-with-explanation",
                "content": "Used backtracking to solve this.\\nBuild an array to apply to \"subset\" template. Each time we add an element to the \"list\", for the next step, target= target - num[i]. Since we have already added one element, for the next step, we can only add k-1 elements. Since no duplicated elements accept, for the next loop, the \"start\" should point to the next index of current index. The `list.remove(list.size() - 1)` here means, we need to change the element here. I know it is hard to understand it, let me give you an example.\\nWhen `k=3, n=9`, my answer works like this:\\n[1]->[1,2]->[1,2,3]. Since now sum is not 9, no more backtracking, so after  `list.remove(list.size() - 1)`, it is [1,2]. Then next follows [1,2,4], sum is not 9, repeat process above untill [1,2,6]. When go to next backtracking, the list will be added to `result`, and for this list, no more backtracking.\\nNow we can go back to a previous backtracking, which is [1,3]->[1,3,4], fail. [1,4,]->[1,4,5], fail. And so one.\\nSo the point of  `list.remove(list.size() - 1)` is, after each \"fail\" or \"success\", since we don't need to do further attempts given such a condition, we delete the last element, and then end current backtracking. Next step is, add the next element to the deleted index, go on attempting. \\n\\nIf you have other questions, just reply me. \\n\\n\\n\\n\\n  \\n\\n    public class Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        int[] num = {1,2,3,4,5,6,7,8,9};\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n        helper(result, new ArrayList<Integer>(), num, k, n,0);\\n        return result;\\n        }\\n    \\n    public void helper(List<List<Integer>> result, List<Integer> list, int[] num, int k, int target, int start){\\n        if (k == 0 && target == 0){\\n            result.add(new ArrayList<Integer>(list));\\n        } else {\\n            for (int i = start; i < num.length && target > 0 && k >0; i++){\\n                list.add(num[i]);\\n                helper(result, list, num, k-1,target-num[i],i+1);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        int[] num = {1,2,3,4,5,6,7,8,9}",
                "codeTag": "Java"
            },
            {
                "id": 60719,
                "title": "combination-sum-i-ii-and-iii-java-solution-see-the-similarities-yourself",
                "content": "Combination Sum I\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n        return list;\\n    }\\n\\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n        if (remain < 0) return; /** no solution */\\n        else if (remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i < cand.length; i++) { \\n                tempList.add(cand[i]);\\n                backtrack(list, tempList, cand, remain-cand[i], i);\\n                tempList.remove(tempList.size()-1);\\n            } \\n        }\\n\\n    }\\n\\nCombination Sum II\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n       List<List<Integer>> list = new LinkedList<List<Integer>>();\\n       Arrays.sort(candidates);\\n       backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n       \\n       if(remain < 0) return; /** no solution */\\n       else if(remain == 0) list.add(new ArrayList<>(tempList));\\n       else{\\n          for (int i = start; i < cand.length; i++) {\\n             if(i > start && cand[i] == cand[i-1]) continue; /** skip duplicates */\\n             tempList.add(cand[i]);\\n             backtrack(list, tempList, cand, remain - cand[i], i+1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n\\nCombination Sum III\\n\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<Integer>(), k, n, 1);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int start) {\\n        if(tempList.size() > k) return; /** no solution */\\n        else if(tempList.size() == k && remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i <= 9; i++) {\\n                tempList.add(i);\\n                backtrack(list, tempList, k, remain-i, i+1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Combination Sum I\\n\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(candidates);\\n        backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n        return list;\\n    }\\n\\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n        if (remain < 0) return; /** no solution */\\n        else if (remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i < cand.length; i++) { \\n                tempList.add(cand[i]);\\n                backtrack(list, tempList, cand, remain-cand[i], i);\\n                tempList.remove(tempList.size()-1);\\n            } \\n        }\\n\\n    }\\n\\nCombination Sum II\\n\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n       List<List<Integer>> list = new LinkedList<List<Integer>>();\\n       Arrays.sort(candidates);\\n       backtrack(list, new ArrayList<Integer>(), candidates, target, 0);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int[] cand, int remain, int start) {\\n       \\n       if(remain < 0) return; /** no solution */\\n       else if(remain == 0) list.add(new ArrayList<>(tempList));\\n       else{\\n          for (int i = start; i < cand.length; i++) {\\n             if(i > start && cand[i] == cand[i-1]) continue; /** skip duplicates */\\n             tempList.add(cand[i]);\\n             backtrack(list, tempList, cand, remain - cand[i], i+1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n\\nCombination Sum III\\n\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        backtrack(list, new ArrayList<Integer>(), k, n, 1);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int start) {\\n        if(tempList.size() > k) return; /** no solution */\\n        else if(tempList.size() == k && remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for (int i = start; i <= 9; i++) {\\n                tempList.add(i);\\n                backtrack(list, tempList, k, remain-i, i+1);\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2024085,
                "title": "combinations-all-types-solution-meme",
                "content": "The code is almost similar, for all combinations problem pattern. \\nNow you may think about the in-order of problem. I have arranged in a perfect order, practice in this way all these problems because they relates to each other.\\n\\n[**77. Combinations**](https://leetcode.com/problems/combinations/)\\n```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        solve(1, k, n, new ArrayList<>(), res);\\n        return res;\\n    }\\n    public void solve(int start, int k, int n, List<Integer> temp, List<List<Integer>> res){\\n        if(temp.size() == k){\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        for(int i = start; i <= n; i++){\\n            temp.add(i);\\n            solve(i + 1, k, n, temp, res);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\\nANALYSIS :-\\nTime/Space complexity:\\n\\nFirst if in combine will be called exactly **c(n, k)** times, which is a binomial coefficient - number of ways you can pick **k** elements from set of sizen. Then it has to perform k size job, of creating new result entry. Time complexity - `O(k * c(n, k)).`\\nFor loop fragment, will be called exactly **c(n, k - 1)** times and (in improved solution which only iterates on **i <= n - k + 1)** there will ben/k iterations on average. Time complexity - `O(n/k * c(n, k - 1))` .\\n\\n* **Final time complexity :-** **`O(k * c(n, k)) + O(n/k * c(n, k - 1))) = O(k * c(n, k))`**\\n\\n\\n* **Space complexity :-** **`O(k * c(n, k))`** - if we exclude the result collection it will be **`O(k)`**.\\n\\n[**216. Combination Sum III**](https://leetcode.com/problems/combination-sum-iii/)\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        solve(1, k, n, new ArrayList<>(), res);\\n        return res;\\n    }\\n    public void solve(int start, int k, int n, List<Integer> temp, List<List<Integer>> res){\\n        if(n == 0 && temp.size() == k){\\n            res.add(new ArrayList<>(temp));\\n        }\\n        for(int i = start; i <= 9; i++){\\n            temp.add(i);\\n            solve(i + 1, k, n - i, temp, res);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** **`O(K * 9^K)`**\\n\\n\\n* **Space Complexity :-** **`O(K)`**\\n\\n\\n[**39. Combination Sum**](https://leetcode.com/problems/combination-sum/)\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        solve(0, candidates, target, new ArrayList<>(), res);\\n        return res;\\n    }\\n    public void solve(int start, int nums[], int target, List<Integer> temp, List<List<Integer>> res){\\n        if(target == 0){\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        if(target > 0){\\n            for(int i = start; i < nums.length; i++){\\n                temp.add(nums[i]);\\n                solve(i, nums, target - nums[i], temp, res);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time complexity :-**  **`O(len(nums)^target)`** or **`O(N^M)`**\\n\\n* **Space Complexity :-** **`O(length of longest combination)`**\\n\\n\\n[**40. Combination Sum II**](https://leetcode.com/problems/combination-sum-ii/)\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> res = new ArrayList<>();\\n        solve(0, candidates, target, new ArrayList<>(), res);\\n        return res;\\n    }\\n    public void solve(int start, int nums[], int target, List<Integer> temp, List<List<Integer>> res){\\n        if(target == 0){\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        if(target > 0){\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i - 1]) continue;\\n                temp.add(nums[i]);\\n                solve(i + 1, nums, target - nums[i], temp, res);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time complexity :-**  **`O(N x 2^N)`**\\n\\n* **Space Complexity :-** **`O(N x 2^N)`**\\n\\n```\\nMEME Time :-\\n```\\n\\n![image](https://assets.leetcode.com/users/images/82a169c2-7cef-4871-b8a0-4f2aba9ee45e_1652153023.149258.gif)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        solve(1, k, n, new ArrayList<>(), res);\\n        return res;\\n    }\\n    public void solve(int start, int k, int n, List<Integer> temp, List<List<Integer>> res){\\n        if(temp.size() == k){\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        for(int i = start; i <= n; i++){\\n            temp.add(i);\\n            solve(i + 1, k, n, temp, res);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        solve(1, k, n, new ArrayList<>(), res);\\n        return res;\\n    }\\n    public void solve(int start, int k, int n, List<Integer> temp, List<List<Integer>> res){\\n        if(n == 0 && temp.size() == k){\\n            res.add(new ArrayList<>(temp));\\n        }\\n        for(int i = start; i <= 9; i++){\\n            temp.add(i);\\n            solve(i + 1, k, n - i, temp, res);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        solve(0, candidates, target, new ArrayList<>(), res);\\n        return res;\\n    }\\n    public void solve(int start, int nums[], int target, List<Integer> temp, List<List<Integer>> res){\\n        if(target == 0){\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        if(target > 0){\\n            for(int i = start; i < nums.length; i++){\\n                temp.add(nums[i]);\\n                solve(i, nums, target - nums[i], temp, res);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\\n        Arrays.sort(candidates);\\n        List<List<Integer>> res = new ArrayList<>();\\n        solve(0, candidates, target, new ArrayList<>(), res);\\n        return res;\\n    }\\n    public void solve(int start, int nums[], int target, List<Integer> temp, List<List<Integer>> res){\\n        if(target == 0){\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        if(target > 0){\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i - 1]) continue;\\n                temp.add(nums[i]);\\n                solve(i + 1, nums, target - nums[i], temp, res);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\n```\\nMEME Time :-\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60629,
                "title": "use-backtrack-c-solution-easy-to-understand",
                "content": "    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> result;\\n        vector<int> path;\\n        backtrack(result, path, 1, k, n);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<vector<int>> &result, vector<int> &path, int start, int k, int target){\\n        if(target==0&&k==0){\\n            result.push_back(path);\\n            return;\\n        }\\n        for(int i=start;i<=10-k&&i<=target;i++){\\n            path.push_back(i);\\n            backtrack(result,path,i+1,k-1,target-i);\\n            path.pop_back();\\n        }\\n    }",
                "solutionTags": [],
                "code": "    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> result;\\n        vector<int> path;\\n        backtrack(result, path, 1, k, n);\\n        return result;\\n    }\\n    \\n    void backtrack(vector<vector<int>> &result, vector<int> &path, int start, int k, int target){\\n        if(target==0&&k==0){\\n            result.push_back(path);\\n            return;\\n        }\\n        for(int i=start;i<=10-k&&i<=target;i++){\\n            path.push_back(i);\\n            backtrack(result,path,i+1,k-1,target-i);\\n            path.pop_back();\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 842733,
                "title": "c-clean-backtracking-0-ms-beats-100-easy-to-understand",
                "content": "**Explanation**\\nThe key to this question is backtracking, that is, generate possible combinations and see which one fulfills the conditions.\\nWe choose a number for 1,2..kth position in ascending order, and for each position, we only iterate through [current_number, 9].\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    void f(vector<int>& cur, int cnum, int k, int n) {\\n        if(n < 0 || cur.size() > k) return;\\n        if(n == 0 && cur.size() == k) {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        \\n        for(int i=cnum; i<=9; ++i) {\\n            cur.push_back(i);\\n            f(cur, i+1, k, n-i);\\n            cur.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> cur;\\n        f(cur, 1, k, n);\\n        return ans;\\n    }\\n};\\n```\\n\\nIf you have any doubts, feel free to comment. If you like the solution and the explanation, please **Upvote** to help others!\\nHave a great day!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    void f(vector<int>& cur, int cnum, int k, int n) {\\n        if(n < 0 || cur.size() > k) return;\\n        if(n == 0 && cur.size() == k) {\\n            ans.push_back(cur);\\n            return;\\n        }\\n        \\n        for(int i=cnum; i<=9; ++i) {\\n            cur.push_back(i);\\n            f(cur, i+1, k, n-i);\\n            cur.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> cur;\\n        f(cur, 1, k, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024574,
                "title": "python-solution-backtracking",
                "content": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        self.result =[]\\n        self.helper([],1,k,n)\\n        return self.result\\n    \\n    def helper(self,path,start,k,target):\\n        \\n        if k ==0 and target==0:\\n            self.result.append(path)\\n            return \\n        \\n        if k == 0 or target <= 0:\\n            return\\n        \\n        for i in range(start,10):\\n            self.helper(path+[i],i+1,k-1,target-i)\\n```\\n**Runtime: 34 ms**, faster than 82.38% of Python3 online submissions for Combination Sum III.\\n**Memory Usage: 13.9 MB**, less than 79.39% of Python3 online submissions for Combination Sum III.\\n\\nIf you have any doubts, feel free to comment. If you like the solution and the explanation, please **Upvote** to help others!\\nHave a great day!",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        self.result =[]\\n        self.helper([],1,k,n)\\n        return self.result\\n    \\n    def helper(self,path,start,k,target):\\n        \\n        if k ==0 and target==0:\\n            self.result.append(path)\\n            return \\n        \\n        if k == 0 or target <= 0:\\n            return\\n        \\n        for i in range(start,10):\\n            self.helper(path+[i],i+1,k-1,target-i)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842764,
                "title": "python-backtrack-solution-explained",
                "content": "If in problem we need to return all possible options with some property, usually it means that we need to do backtracking. Let us use `BackTr` function with parameters:\\n\\n1. `k` is number of numbers we need to take to build our number.\\n2. `n` is number we need to build\\n3. `curr_sol` built solution so far.\\n\\nThen if `n<0` of `k<0` we need to go back; if `n==0` and `k==0` means that we found solution, so we add it to our `self.sol`. Then we just run our `BackTr` with parameters: `k-1`: we need to take one less number, `n-i`, where `i` is the last digit we added: it is either starts with `1` or with `curr_sol[-1] + 1` and `curr_sol + [i]` will be our built solution so far.\\n\\nFinally, we run ` self.BackTr(k, n, [])` and return `self.sol`.\\n\\n**Comlexity**: For first digit we have not more than `9` options, for second one no more than `8` and so on, so there will be `9*8*...*(9-k+1)` possible options, for each of which we need `O(k)`. We can improve this bound if we take into account that there is 2^9 possible combinations at all, so complexity is `O(2^9*k)`, because of all dead-ends we can have. Space complexity is `O(k)`, if we do not take into account output solution.\\n\\n```\\nclass Solution:\\n    def combinationSum3(self, k, n):\\n        self.sol = []\\n        self.BackTr(k, n, [])\\n        return self.sol\\n        \\n    def BackTr(self, k, n, curr_sol):\\n        if n < 0 or k < 0: return\\n        if n == 0 and k == 0:\\n            self.sol.append(curr_sol)\\n            \\n        start = curr_sol[-1] + 1 if curr_sol else 1\\n            \\n        for i in range(start, 10):\\n            self.BackTr(k - 1, n - i, curr_sol + [i])\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k, n):\\n        self.sol = []\\n        self.BackTr(k, n, [])\\n        return self.sol\\n        \\n    def BackTr(self, k, n, curr_sol):\\n        if n < 0 or k < 0: return\\n        if n == 0 and k == 0:\\n            self.sol.append(curr_sol)\\n            \\n        start = curr_sol[-1] + 1 if curr_sol else 1\\n            \\n        for i in range(start, 10):\\n            self.BackTr(k - 1, n - i, curr_sol + [i])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024145,
                "title": "simple-easy-c-solution",
                "content": "```\\n void solve(int st,int k,int n,vector<int> &ds,vector<vector<int>> &ans)\\n    {\\n        if(k<=0)\\n        {\\n            if(n==0) ans.push_back(ds);\\n            return;\\n        }\\n        \\n        for(int i=st;i<=9;i++)    \\n        {\\n            ds.push_back(i);\\n            solve(i+1,k-1,n-i,ds,ans);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        solve(1,k,n,ds,ans);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n void solve(int st,int k,int n,vector<int> &ds,vector<vector<int>> &ans)\\n    {\\n        if(k<=0)\\n        {\\n            if(n==0) ans.push_back(ds);\\n            return;\\n        }\\n        \\n        for(int i=st;i<=9;i++)    \\n        {\\n            ds.push_back(i);\\n            solve(i+1,k-1,n-i,ds,ans);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        solve(1,k,n,ds,ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 843394,
                "title": "python-simple-solution-explained-video-code-backtracking",
                "content": "[](https://www.youtube.com/watch?v=J2hcPZRpbMk)\\nhttps://www.youtube.com/watch?v=J2hcPZRpbMk\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        res = []\\n        \\n        def backtrack(num, stack, target):\\n            if len(stack) == k:\\n                if target == 0:\\n                    res.append(stack)\\n                return\\n            \\n            for x in range(num + 1, 10):\\n                if x <= target:\\n                    backtrack(x, stack + [x], target - x)\\n                else:\\n                    return\\n        \\n        backtrack(0, [], n)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        res = []\\n        \\n        def backtrack(num, stack, target):\\n            if len(stack) == k:\\n                if target == 0:\\n                    res.append(stack)\\n                return\\n            \\n            for x in range(num + 1, 10):\\n                if x <= target:\\n                    backtrack(x, stack + [x], target - x)\\n                else:\\n                    return\\n        \\n        backtrack(0, [], n)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 844197,
                "title": "javascript-clean-code-72-ms",
                "content": "```javascript\\nvar combinationSum3 = function(k, n) {\\n    const res = []\\n    \\n    function permute(arr, sum, start) {\\n        if(sum > n) return;\\n        \\n        if(arr.length === k) {\\n            if(sum === n) res.push(arr);\\n            return;\\n        }\\n        \\n        for(let i = start; i < 10; i++) {\\n            permute([...arr, i], sum+i, i+1);\\n        }\\n    }\\n    permute([], 0, 1);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar combinationSum3 = function(k, n) {\\n    const res = []\\n    \\n    function permute(arr, sum, start) {\\n        if(sum > n) return;\\n        \\n        if(arr.length === k) {\\n            if(sum === n) res.push(arr);\\n            return;\\n        }\\n        \\n        for(let i = start; i < 10; i++) {\\n            permute([...arr, i], sum+i, i+1);\\n        }\\n    }\\n    permute([], 0, 1);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1546449,
                "title": "java-optimized-backtracking-w-detailed-time-complexity-explanation",
                "content": "```java\\n/**\\n * Backtracking\\n *\\n * Time complexity = InternalNodes in the RecursionTree   +   K * LeafNodes in RecursionTree\\n *                 = (C(9,0) + C(9,1) + ... + C(9,K-1))   +   K * C(9,K)\\n * In our solution, the worst case will happen when k = 8. Then Total Time Complexity = O(574) which is O(1)\\n *\\n * Space Complexity = O(k) -> Depth of Recursion tree + Size of TempList\\n *\\n * K = Input size of each combination.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        if (k <= 0 || k > 9 || n <= 0 || n > 45 || (k == 1 && n > 9) || (k == 9 && n != 45) || (n < k * (k + 1) / 2)) {\\n            return result;\\n        }\\n        if (k == 1) {\\n            result.add(List.of(n));\\n            return result;\\n        }\\n        if (k == 9) {\\n            result.add(List.of(1, 2, 3, 4, 5, 6, 7, 8, 9));\\n            return result;\\n        }\\n\\n        combinationSum3(1, k, n, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum3(int start, int k, int n, List<Integer> tempList, List<List<Integer>> result) {\\n        if (k == 0) {\\n            if (n == 0) {\\n                result.add(new ArrayList<>(tempList));\\n            }\\n            return;\\n        }\\n\\n        for (int i = start; i <= 9; i++) {\\n            if (i > n) {\\n                break;\\n            }\\n            tempList.add(i);\\n            combinationSum3(i + 1, k - 1, n - i, tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Combination Sum questions on LeetCode:\\n- [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/1546400/Java-or-Backtracking-w-Early-Exit-(Detailed-Time-Complexity-explanation-added))\\n- [40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/1546439/Java-or-Backtracking-optimized-for-duplicate-candidates-(Detailed-TC-explanation-added))\\n- [377. Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/discuss/1546467/Java-or-TC:-O(N*T)-or-SC:-O(T)-or-DP-(BottomUp-and-TopDown)-w-FollowUp)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```java\\n/**\\n * Backtracking\\n *\\n * Time complexity = InternalNodes in the RecursionTree   +   K * LeafNodes in RecursionTree\\n *                 = (C(9,0) + C(9,1) + ... + C(9,K-1))   +   K * C(9,K)\\n * In our solution, the worst case will happen when k = 8. Then Total Time Complexity = O(574) which is O(1)\\n *\\n * Space Complexity = O(k) -> Depth of Recursion tree + Size of TempList\\n *\\n * K = Input size of each combination.\\n */\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        if (k <= 0 || k > 9 || n <= 0 || n > 45 || (k == 1 && n > 9) || (k == 9 && n != 45) || (n < k * (k + 1) / 2)) {\\n            return result;\\n        }\\n        if (k == 1) {\\n            result.add(List.of(n));\\n            return result;\\n        }\\n        if (k == 9) {\\n            result.add(List.of(1, 2, 3, 4, 5, 6, 7, 8, 9));\\n            return result;\\n        }\\n\\n        combinationSum3(1, k, n, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void combinationSum3(int start, int k, int n, List<Integer> tempList, List<List<Integer>> result) {\\n        if (k == 0) {\\n            if (n == 0) {\\n                result.add(new ArrayList<>(tempList));\\n            }\\n            return;\\n        }\\n\\n        for (int i = start; i <= 9; i++) {\\n            if (i > n) {\\n                break;\\n            }\\n            tempList.add(i);\\n            combinationSum3(i + 1, k - 1, n - i, tempList, result);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60636,
                "title": "concise-python-solution-using-dfs",
                "content": "    class Solution:\\n        # @param {integer} k\\n        # @param {integer} n\\n        # @return {integer[][]}\\n        def combinationSum3(self, k, n):\\n            if n > sum([i for i in range(1, 11)]):\\n                return []\\n    \\n            res = []\\n            self.sum_help(k, n, 1, [], res)\\n            return res\\n    \\n    \\n        def sum_help(self, k, n, curr, arr, res):\\n            if len(arr) == k:\\n                if sum(arr) == n:\\n                    res.append(list(arr))\\n                return\\n    \\n            if len(arr) > k or curr > 9:\\n                return\\n            \\n            for i in range(curr, 10):\\n                arr.append(i)\\n                self.sum_help(k, n, i + 1, arr, res)\\n                arr.pop()",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 2024072,
                "title": "c-backtrack-take-it-or-leave-it",
                "content": "**Solved live on stream.  Come join us 6pm PT.  Link in profile**\\n\\n```\\nclass Solution {\\n    void dfs(int num, int sum, int count, vector<int>& path, vector<vector<int>>& ans) {\\n        if(sum == 0 && count == 0) {\\n            ans.push_back(path);\\n            return;\\n        }\\n        if(sum == 0 || count == 0) {\\n            return;\\n        }\\n        if(num > 9) return;\\n        \\n        //take it\\n        if(sum >= num && count > 0) {\\n            path.push_back(num);\\n            dfs(num+1, sum-num, count-1, path, ans);\\n            path.pop_back();\\n        }\\n        \\n        //leave it\\n        dfs(num+1, sum, count, path, ans);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) { \\n        vector<vector<int>> ans;\\n        vector<int> path;\\n        dfs(1, n, k, path, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void dfs(int num, int sum, int count, vector<int>& path, vector<vector<int>>& ans) {\\n        if(sum == 0 && count == 0) {\\n            ans.push_back(path);\\n            return;\\n        }\\n        if(sum == 0 || count == 0) {\\n            return;\\n        }\\n        if(num > 9) return;\\n        \\n        //take it\\n        if(sum >= num && count > 0) {\\n            path.push_back(num);\\n            dfs(num+1, sum-num, count-1, path, ans);\\n            path.pop_back();\\n        }\\n        \\n        //leave it\\n        dfs(num+1, sum, count, path, ans);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) { \\n        vector<vector<int>> ans;\\n        vector<int> path;\\n        dfs(1, n, k, path, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450921,
                "title": "simple-backtracking-solution-in-c",
                "content": "Here is my solution this problem.\\nIf you **LIKE** the solution then **Upvote** it!!\\nThank you !!\\n\\n### **Solution:**\\n```\\nclass Solution {\\npublic:\\n    void  combinations(int k,int idx, int n,vector<int>temp,vector<vector<int>>&ans)\\n    {\\n        if(n<0 || temp.size()>k)\\n            return;\\n        if(n==0 && temp.size()==k)\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        for(int i=idx;i<=9;i++)\\n        {\\n            temp.push_back(i);\\n            combinations(k,i+1,n-i,temp,ans);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        combinations(k,1,n,temp,ans);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void  combinations(int k,int idx, int n,vector<int>temp,vector<vector<int>>&ans)\\n    {\\n        if(n<0 || temp.size()>k)\\n            return;\\n        if(n==0 && temp.size()==k)\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        for(int i=idx;i<=9;i++)\\n        {\\n            temp.push_back(i);\\n            combinations(k,i+1,n-i,temp,ans);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        combinations(k,1,n,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026135,
                "title": "python-diagrammatically-explained-for-beginners-backtracking-tree-solution",
                "content": "![image](https://assets.leetcode.com/users/images/8ed8590d-5f69-4bab-9d1a-e0d128e0c3ba_1652194276.2071493.png)\\n\\n**Algorithm for the recursive backtracking function**:\\n***BASE CONDITION:*** \\n1. Check if sum(arr) exceeds the value of n, the simply return.\\n2. Check if k == 0, if sum(arr) == n then one of our answer is found, append it to the final answer list, else simply return as we have no more elements left to place in array as k == 0.\\n\\n***RECURSIVE STEP:***\\n1. Run a loop through the max element in array (as we dont want duplicates, and elements less that the max element would have been already considered in the previous recursive calls) to minimum of (n, 10) as we want only single digit as each of the array elements, so go upto n (as anyways we cannot exceed n) or less than 10 which ever is minimum as we just want a single digit.\\n2. for each iteration of the loop, append the iterator value to the existing array and call the recursive function reducing the value of k (saying we have added another element to the array, hence we used up one more space).\\nNow, when this recursive function is called again same base conditions will be checked and ans will be added if found.\\n\\nHope this explanation helps to the people who are just beginning with backtracking problems.\\n\\nAlso see this, if you are new to backtracking problems: https://leetcode.com/problems/generate-parentheses/discuss/1276417/python-explained-easy-backtracking-with-time-and-space-complexity\\n\\n\\n\\n\\n\\n**Time Complexity = O(9^k)** owing to Height/depth of the tree in worst case O(k) and for each height there are 9 possible splits.\\n**Space Complexity = O(k^2)** as at any instance of time the max height of the tree is O(k) and for each level we store an array of size k.\\n\\nKindly, correct me if I am wrong! (I too have some doubts here, yet this seems logical).\\n\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        \\n        def recur(k, n, arr):\\n            s = sum(arr)\\n            if k == 0 or s > n:\\n                if s == n:\\n                    self.ans.append(arr.copy())\\n                return\\n            \\n            max_e = max(arr) if arr else 0\\n            for i in range(max_e + 1, min(n + 1, 10)):\\n                temp = arr.copy()\\n                temp.append(i)\\n                recur(k-1, n, temp)\\n            return\\n        \\n        \\n        self.ans = []\\n        recur(k, n, [])\\n        return self.ans\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        \\n        def recur(k, n, arr):\\n            s = sum(arr)\\n            if k == 0 or s > n:\\n                if s == n:\\n                    self.ans.append(arr.copy())\\n                return\\n            \\n            max_e = max(arr) if arr else 0\\n            for i in range(max_e + 1, min(n + 1, 10)):\\n                temp = arr.copy()\\n                temp.append(i)\\n                recur(k-1, n, temp)\\n            return\\n        \\n        \\n        self.ans = []\\n        recur(k, n, [])\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60787,
                "title": "non-recursive-c-0ms-solution",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> combinationSum3(int k, int n) {\\n            vector<vector<int>> ret;\\n            vector<int> path(k);\\n            int i = 0;\\n            int curSum = 0;\\n            \\n            while(i!=-1){\\n                path[i]++;\\n                curSum++;\\n                if(path[i]>9 || curSum > n || (i!=k-1 && curSum+path[i] >= n) ){\\n                    curSum -= path[i];\\n                    i--;\\n                }else if(i == k-1){\\n                    if(curSum == n) ret.push_back(path);\\n                }else if(curSum+path[i] < n){\\n                    path[i+1] = path[i];\\n                    curSum += path[i];\\n                    i++;\\n                }\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> combinationSum3(int k, int n) {\\n            vector<vector<int>> ret;\\n            vector<int> path(k);\\n            int i = 0;\\n            int curSum = 0;\\n            \\n            while(i!=-1){\\n                path[i]++;\\n                curSum++;\\n                if(path[i]>9 || curSum > n || (i!=k-1 && curSum+path[i] >= n) ){\\n                    curSum -= path[i];\\n                    i--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2024468,
                "title": "easy-c-solution-2-approaches-bit-manipulation-backtracking",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> ans;\\npublic:\\n    /*\\n        BACKTRACKING BASED SOLUTION:\\n        ===========================        \\n    */\\n    \\n    \\n    int sum(const vector<int>& combo) {\\n        int temp = 0;\\n        for (int x : combo)\\n            temp += x;\\n        return temp;\\n    }\\n    \\n    void helper(vector<int>& combo, int k, int n, int num) {\\n        if (!k) {\\n            if (sum(combo) == n)\\n                ans.push_back(combo);\\n            return;\\n        }\\n        \\n        if (num > 9) return;\\n        \\n        combo.push_back(num);\\n        helper(combo, k - 1, n, num + 1);\\n        combo.pop_back();\\n        helper(combo, k, n, num + 1);\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> combo;\\n        helper(combo, k, n, 1);\\n        return ans;\\n    }\\n};\\n```\\n```    \\n/*\\n    BRUTE FORCE | BIT MANIPULATION\\n    ==============================\\n\\n\\tThis solution involves checking all possible combinations possible :\\n\\t- \"int bits = __builtin_popcount(i);\" here we check if their are K numbers or not\\n\\t- if there are K numbers present, then we just check the sum of all \\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < (1 << 9); i++) {\\n            vector<int> combo;\\n            int bits = __builtin_popcount(i);\\n            if (bits != k) continue;\\n            \\n            int temp = 0;\\n            for (int j = 0; j < 9; j++) {\\n                if (i & (1 << j)) {\\n                    temp += (j + 1);\\n                    combo.push_back(j + 1);\\n                }\\n            }\\n            \\n            if (temp == n)\\n                ans.push_back(combo);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<vector<int>> ans;\\npublic:\\n    /*\\n        BACKTRACKING BASED SOLUTION:\\n        ===========================        \\n    */\\n    \\n    \\n    int sum(const vector<int>& combo) {\\n        int temp = 0;\\n        for (int x : combo)\\n            temp += x;\\n        return temp;\\n    }\\n    \\n    void helper(vector<int>& combo, int k, int n, int num) {\\n        if (!k) {\\n            if (sum(combo) == n)\\n                ans.push_back(combo);\\n            return;\\n        }\\n        \\n        if (num > 9) return;\\n        \\n        combo.push_back(num);\\n        helper(combo, k - 1, n, num + 1);\\n        combo.pop_back();\\n        helper(combo, k, n, num + 1);\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> combo;\\n        helper(combo, k, n, 1);\\n        return ans;\\n    }\\n};\\n```\n```    \\n/*\\n    BRUTE FORCE | BIT MANIPULATION\\n    ==============================\\n\\n\\tThis solution involves checking all possible combinations possible :\\n\\t- \"int bits = __builtin_popcount(i);\" here we check if their are K numbers or not\\n\\t- if there are K numbers present, then we just check the sum of all \\n*/\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        for (int i = 0; i < (1 << 9); i++) {\\n            vector<int> combo;\\n            int bits = __builtin_popcount(i);\\n            if (bits != k) continue;\\n            \\n            int temp = 0;\\n            for (int j = 0; j < 9; j++) {\\n                if (i & (1 << j)) {\\n                    temp += (j + 1);\\n                    combo.push_back(j + 1);\\n                }\\n            }\\n            \\n            if (temp == n)\\n                ans.push_back(combo);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025415,
                "title": "easy-java-recursive-backtracking-clean-code-fast-simple",
                "content": "**Runtime: 0 ms, faster than 100.00% of Java online submissions for Combination Sum III.\\nMemory Usage: 39.7 MB, less than 89.81% of Java online submissions for Combination Sum III.**\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> res=new ArrayList<>();\\n        combi(res,new ArrayList<>(),1,0,k,n);\\n        return res;\\n    }\\n    public void combi(List<List<Integer>> res,List<Integer> ds,int num,int sum,int k,int n){\\n        if(k==0 && n==sum){\\n            res.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        for(int i=num;i<=9;i++){\\n            sum+=i;\\n            ds.add(i);\\n            combi(res,ds,i+1,sum,k-1,n);\\n            sum-=i;\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n}\\n```\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> res=new ArrayList<>();\\n        combi(res,new ArrayList<>(),1,0,k,n);\\n        return res;\\n    }\\n    public void combi(List<List<Integer>> res,List<Integer> ds,int num,int sum,int k,int n){\\n        if(k==0 && n==sum){\\n            res.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        for(int i=num;i<=9;i++){\\n            sum+=i;\\n            ds.add(i);\\n            combi(res,ds,i+1,sum,k-1,n);\\n            sum-=i;\\n            ds.remove(ds.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023978,
                "title": "java-backtracking",
                "content": "\\n\\n\\n```\\n\\nclass Solution {\\n    List<List<Integer>> allComb = new ArrayList<>();                     \\n    List<Integer> comb = new ArrayList<>();                              \\n    \\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        findComb(k, n, 1);                                              \\n        return allComb;\\n    }\\n    \\n    private void findComb(int k, int n, int start) {                      \\n        if(k == 0 && n == 0){                                             \\n            allComb.add(new ArrayList<>(comb));\\n            return;\\n        }\\n        for(int i = start; i < 10; i++){\\n            comb.add(i);\\n            findComb(k - 1, n - i, i + 1);\\n            comb.remove(comb.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\n\\nclass Solution {\\n    List<List<Integer>> allComb = new ArrayList<>();                     \\n    List<Integer> comb = new ArrayList<>();                              \\n    \\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        findComb(k, n, 1);                                              \\n        return allComb;\\n    }\\n    \\n    private void findComb(int k, int n, int start) {                      \\n        if(k == 0 && n == 0){                                             \\n            allComb.add(new ArrayList<>(comb));\\n            return;\\n        }\\n        for(int i = start; i < 10; i++){\\n            comb.add(i);\\n            findComb(k - 1, n - i, i + 1);\\n            comb.remove(comb.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099458,
                "title": "java-0ms-backtracking-extremely-easy",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        int[] nums = {1,2,3,4,5,6,7,8,9};\\n        Set<List<Integer>> set = new HashSet<>();\\n        combinationSum3Helper(nums,set,new ArrayList<>(),k,n,0);\\n\\n        return new ArrayList<>(set);\\n    }\\n\\n    static private void combinationSum3Helper(int[] nums,Set<List<Integer>> set,List<Integer> list,\\n                                              int k,int target,int start){\\n        if(target < 0)\\n            return;\\n        else if(target == 0 && list.size() == k)\\n            set.add(new ArrayList<>(list));\\n        else{\\n            for(int i =start;i<nums.length;i++){\\n                if(target - nums[i] < 0) //  Optimisation\\n                    break;;\\n                list.add(nums[i]);\\n                combinationSum3Helper(nums,set,list,k,target - nums[i],i+1);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        int[] nums = {1,2,3,4,5,6,7,8,9}",
                "codeTag": "Java"
            },
            {
                "id": 772273,
                "title": "general-approach-to-backtracking-questions-in-java",
                "content": "## [Subsets](https://leetcode.com/problems/subsets/)\\n\\nGiven a set of **distinct** integers, return all possible subsets.\\n\\n``` java\\nclass Solution {    \\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        backtrack(ans, new ArrayList<Integer>(), nums, 0);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int[] nums, int start) {\\n        ans.add(new ArrayList<Integer>(temp));\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            temp.add(nums[i]);\\n            backtrack(ans, temp, nums, i + 1);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n## [SubSets II](https://leetcode.com/problems/subsets-ii/)\\n\\nGiven a set of **some duplicate** integers, return all possible subsets.\\n\\n``` java\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums); // easy to compare \\n        backtrack(ans, new ArrayList<Integer>(), nums, 0);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int[] nums, int start) {\\n        ans.add(new ArrayList<Integer>(temp));\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            if (i > start && nums[i] == nums[i - 1]) { continue; } // skip duplicates\\n            temp.add(nums[i]);\\n            backtrack(ans, temp, nums, i + 1);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n## [Permutation](https://leetcode.com/problems/permutations/)\\n\\nGiven a collection of **distinct** integers, return all possible permutations.\\n\\n``` java\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        backtrack(ans, new ArrayList<Integer>(), nums);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int[] nums) {\\n        if (temp.size() == nums.length) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else {\\n            for (int i = 0; i < nums.length; i++) {\\n                if (temp.contains(nums[i])) { continue; } // skip duplicates\\n                temp.add(nums[i]);\\n                backtrack(ans, temp, nums);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n## [Permutation II](https://leetcode.com/problems/permutations-ii/)\\n\\nGiven a collection of **some duplicate** integers, return all possible permutations.\\n\\n``` java\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums); // easy to compare \\n        backtrack(ans, new ArrayList<Integer>(), nums, new boolean[nums.length]);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int[] nums, boolean[] used) {\\n        if (temp.size() == nums.length) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else {\\n            for (int i = 0; i < nums.length; i++) {\\n                if (used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])) { continue; } // skip duplicates\\n                used[i] = true;\\n                temp.add(nums[i]);\\n                backtrack(ans, temp, nums, used);\\n                used[i] = false;\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n## [Combination Sum](https://leetcode.com/problems/combination-sum/)\\n\\nGiven a set of candidate numbers (candidates) **(without duplicates)** and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. The **same** repeated number may be chosen from candidates **unlimited** number of times.\\n\\n``` java\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(ans, new ArrayList<>(), nums, target, 0);\\n        return ans;\\n    }\\n\\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int [] nums, int remain, int start){\\n        if (remain < 0) { \\n            return; \\n        } else if (remain == 0) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else{ \\n            for(int i = start; i < nums.length; i++){\\n                temp.add(nums[i]);\\n                backtrack(ans, temp, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n## [Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)\\n\\nGiven a set of candidate numbers (candidates) **(with some duplicates)** and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target. Each number may be chosen from candidates **once**. \\n\\n``` java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(nums); // easy to compare\\n        backtrack(ans, new ArrayList<>(), nums, target, 0);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int [] nums, int remain, int start){\\n        if (remain < 0) { \\n            return; \\n        } else if (remain == 0) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else{ \\n            for(int i = start; i < nums.length; i++){\\n                if (i > start && nums[i] == nums[i - 1]) { continue; } // skip duplicates\\n                temp.add(nums[i]);\\n                backtrack(ans, temp, nums, remain - nums[i], i + 1); \\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n## [Combination Sum III](https://leetcode.com/problems/combination-sum-iii/)\\n\\nFind all possible combinations of ***k*** numbers that add up to a number ***n***, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.\\n\\n``` java\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        backtrack(ans, new ArrayList<Integer>(), k, n, 1);\\n        return ans;\\n    }\\n\\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int k, int remain, int start) {\\n        if (temp.size() > k) { \\n            return; \\n        } else if (temp.size() == k && remain == 0) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else{\\n            for (int i = start; i <= 9; i++) {\\n                temp.add(i);\\n                backtrack(ans, temp, k, remain - i, i + 1);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "``` java\\nclass Solution {    \\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        backtrack(ans, new ArrayList<Integer>(), nums, 0);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int[] nums, int start) {\\n        ans.add(new ArrayList<Integer>(temp));\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            temp.add(nums[i]);\\n            backtrack(ans, temp, nums, i + 1);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums); // easy to compare \\n        backtrack(ans, new ArrayList<Integer>(), nums, 0);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int[] nums, int start) {\\n        ans.add(new ArrayList<Integer>(temp));\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            if (i > start && nums[i] == nums[i - 1]) { continue; } // skip duplicates\\n            temp.add(nums[i]);\\n            backtrack(ans, temp, nums, i + 1);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public List<List<Integer>> permute(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        backtrack(ans, new ArrayList<Integer>(), nums);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int[] nums) {\\n        if (temp.size() == nums.length) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else {\\n            for (int i = 0; i < nums.length; i++) {\\n                if (temp.contains(nums[i])) { continue; } // skip duplicates\\n                temp.add(nums[i]);\\n                backtrack(ans, temp, nums);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        Arrays.sort(nums); // easy to compare \\n        backtrack(ans, new ArrayList<Integer>(), nums, new boolean[nums.length]);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int[] nums, boolean[] used) {\\n        if (temp.size() == nums.length) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else {\\n            for (int i = 0; i < nums.length; i++) {\\n                if (used[i] || (i > 0 && nums[i] == nums[i - 1] && !used[i - 1])) { continue; } // skip duplicates\\n                used[i] = true;\\n                temp.add(nums[i]);\\n                backtrack(ans, temp, nums, used);\\n                used[i] = false;\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(ans, new ArrayList<>(), nums, target, 0);\\n        return ans;\\n    }\\n\\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int [] nums, int remain, int start){\\n        if (remain < 0) { \\n            return; \\n        } else if (remain == 0) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else{ \\n            for(int i = start; i < nums.length; i++){\\n                temp.add(nums[i]);\\n                backtrack(ans, temp, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        Arrays.sort(nums); // easy to compare\\n        backtrack(ans, new ArrayList<>(), nums, target, 0);\\n        return ans;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int [] nums, int remain, int start){\\n        if (remain < 0) { \\n            return; \\n        } else if (remain == 0) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else{ \\n            for(int i = start; i < nums.length; i++){\\n                if (i > start && nums[i] == nums[i - 1]) { continue; } // skip duplicates\\n                temp.add(nums[i]);\\n                backtrack(ans, temp, nums, remain - nums[i], i + 1); \\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        backtrack(ans, new ArrayList<Integer>(), k, n, 1);\\n        return ans;\\n    }\\n\\n    private void backtrack(List<List<Integer>> ans, List<Integer> temp, int k, int remain, int start) {\\n        if (temp.size() > k) { \\n            return; \\n        } else if (temp.size() == k && remain == 0) {\\n            ans.add(new ArrayList<Integer>(temp));\\n        } else{\\n            for (int i = start; i <= 9; i++) {\\n                temp.add(i);\\n                backtrack(ans, temp, k, remain - i, i + 1);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388941,
                "title": "0ms-c-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDefault backtracking solution, but here we have ```bool``` return type. It here for decrease amount of iterations. If target become less than zero it means that in other iterations has no sense, because of ```std::iota``` nums contains numbers from 1 to 9 and next itarations will make target smalle and smaller. So if target less then zero we return false that means that we shoudl return from previous call of backtrack method and try another ```nums[i]```.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int>> combinationSum3(int k, int n) {\\n        std::vector<std::vector<int>> output;\\n        std::vector<int> currentSeq;\\n        std::vector<int> nums(9);\\n        std::iota(nums.begin(), nums.end(), 1);\\n\\n        combination(nums, 0, n, k, currentSeq, output);\\n\\n\\n        return output;\\n    }\\n\\nprivate:\\n    bool combination(std::vector<int>& nums, int pos, int target, int length, std::vector<int>& currentSeq, std::vector<std::vector<int>>& output) {\\n        if(currentSeq.size() > length) {\\n            return false;\\n        }\\n        if(target == 0 && currentSeq.size() == length) {\\n            output.push_back(currentSeq);\\n            return true;\\n        }\\n        else if(target < 0) {\\n            return false;\\n        }\\n\\n        for(int i = pos; i < nums.size(); ++i) {\\n            currentSeq.push_back(nums[i]);\\n\\n            auto result = combination(nums, i+1, target-nums[i], length, currentSeq, output);\\n\\n            currentSeq.pop_back();\\n\\n            if(!result) {\\n                return true;\\n            }\\n        }\\n        return true;\\n    }\\n\\n};\\n```\\n\\n![fotor_2023-4-7_9_8_42.jpg](https://assets.leetcode.com/users/images/59e934fa-ccde-424c-a884-d4397fe3df0c_1680847781.015317.jpeg)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```bool```\n```std::iota```\n```nums[i]```\n```\\nclass Solution {\\npublic:\\n    std::vector<std::vector<int>> combinationSum3(int k, int n) {\\n        std::vector<std::vector<int>> output;\\n        std::vector<int> currentSeq;\\n        std::vector<int> nums(9);\\n        std::iota(nums.begin(), nums.end(), 1);\\n\\n        combination(nums, 0, n, k, currentSeq, output);\\n\\n\\n        return output;\\n    }\\n\\nprivate:\\n    bool combination(std::vector<int>& nums, int pos, int target, int length, std::vector<int>& currentSeq, std::vector<std::vector<int>>& output) {\\n        if(currentSeq.size() > length) {\\n            return false;\\n        }\\n        if(target == 0 && currentSeq.size() == length) {\\n            output.push_back(currentSeq);\\n            return true;\\n        }\\n        else if(target < 0) {\\n            return false;\\n        }\\n\\n        for(int i = pos; i < nums.size(); ++i) {\\n            currentSeq.push_back(nums[i]);\\n\\n            auto result = combination(nums, i+1, target-nums[i], length, currentSeq, output);\\n\\n            currentSeq.pop_back();\\n\\n            if(!result) {\\n                return true;\\n            }\\n        }\\n        return true;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997421,
                "title": "easy-backtracking-code-beats-100-amazon-sde-1-interview",
                "content": "![Screenshot (11).png](https://assets.leetcode.com/users/images/59178fb1-7b74-4b5c-8e7c-fdf7238dd0f5_1672830655.1942635.png)\\n\\n### **It is one of the Pick only type of Backtracking problems.**\\n\\n### **Doing Combination Sum 1 and 2 is mandatory before solving this problem.**\\n\\n### **Also this problem has been asked for FAANG interview multiple times.**\\n### **My friend recently gave Microsoft SDE-1 Interview and faced this question!** \\n\\n#### **Code is self explainatory ! If you don\\'t understand this code then plz do check out the following solutions to make it more clear.**\\n# Combination Sum 1 :-\\nhttps://leetcode.com/problems/combination-sum/solutions/2974627/easiest-faang-method-ever/\\n\\n# Combination Sum 2 :-\\nhttps://leetcode.com/problems/combination-sum-ii/solutions/2980945/easiest-faang-method-ever/\\n\\n\\n# ***Please Upvote if it helps \\uD83D\\uDE4F\\u2764\\uFE0F***\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void CombinationSum(int ind, vector<int> &ds, vector<vector<int>> &ans, int target, int k, int n){\\n        if(ds.size()==k){\\n            if(target==0){\\n                ans.emplace_back(ds);\\n                return;\\n            }\\n        }\\n        for(int i=ind;i<=9;i++){\\n            if(ds.size()>=k && target!=0) break;\\n            if(i>target) break;\\n            ds.emplace_back(i);\\n            CombinationSum(i+1, ds, ans, target-i, k, n);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        if(n<k){\\n            return ans;\\n        }\\n        CombinationSum(1, ds, ans, n, k, n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void CombinationSum(int ind, vector<int> &ds, vector<vector<int>> &ans, int target, int k, int n){\\n        if(ds.size()==k){\\n            if(target==0){\\n                ans.emplace_back(ds);\\n                return;\\n            }\\n        }\\n        for(int i=ind;i<=9;i++){\\n            if(ds.size()>=k && target!=0) break;\\n            if(i>target) break;\\n            ds.emplace_back(i);\\n            CombinationSum(i+1, ds, ans, target-i, k, n);\\n            ds.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> ds;\\n        if(n<k){\\n            return ans;\\n        }\\n        CombinationSum(1, ds, ans, n, k, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774445,
                "title": "combinations-sum-iii-java-solution-simple-approach-as-combination-sum-i",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        helper(1,9,k,n,sum,ans,subset);\\n        return ans;\\n    }\\n     void helper(int start, int end, int k, int n, int sum, List<List<Integer>> ans, List<Integer> subset)\\n    {\\n    \\n         if(k==0){\\n                if(sum==n){\\n                 ans.add(new ArrayList(subset));\\n                return;\\n                }\\n                return;\\n           }\\n\\t\\t   \\n         if(start>end)\\n             return;\\n\\t\\t\\t \\n         if(sum>n)\\n             return;\\n        \\n        //include\\n        sum+=start;\\n        subset.add(start);\\n        helper(start+1,end,k-1,n,sum,ans,subset);\\n        \\n        //exclude\\n         sum-=start;\\n        subset.remove(subset.size()-1);\\n        helper(start+1,end,k,n,sum,ans,subset);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        List<Integer> subset = new ArrayList<>();\\n        helper(1,9,k,n,sum,ans,subset);\\n        return ans;\\n    }\\n     void helper(int start, int end, int k, int n, int sum, List<List<Integer>> ans, List<Integer> subset)\\n    {\\n    \\n         if(k==0){\\n                if(sum==n){\\n                 ans.add(new ArrayList(subset));\\n                return;\\n                }\\n                return;\\n           }\\n\\t\\t   \\n         if(start>end)\\n             return;\\n\\t\\t\\t \\n         if(sum>n)\\n             return;\\n        \\n        //include\\n        sum+=start;\\n        subset.add(start);\\n        helper(start+1,end,k-1,n,sum,ans,subset);\\n        \\n        //exclude\\n         sum-=start;\\n        subset.remove(subset.size()-1);\\n        helper(start+1,end,k,n,sum,ans,subset);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029286,
                "title": "c-solution-recursion-and-backtracking-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res, vector<int> &ds, int count, int sum, int start)\\n    {\\n        // base condition to reached the answer\\n        if(sum==0 && count==0)\\n        {\\n            res.push_back(ds);\\n            return;\\n        }\\n\\n        // if any one of them (k,n) gets 0 it means no valid combination found then we return\\n        if(sum==0 || count==0)\\n            return;\\n\\n        // if value cross 9 then we also return as given in the condition\\n        if(start>9)\\n            return;\\n        \\n        //if current value lies in boundary then take it\\n        if(sum>=start && count>0)\\n        {\\n            ds.push_back(start);                               // taking the current value\\n            helper(res, ds, count-1, sum-start, start+1);      // now calling the same function for next\\n            ds.pop_back();                                     // backtracking\\n        }\\n\\n        //skipping the current value if it is not is the bound and check for\\n        helper(res, ds, count, sum, start+1);\\n    }\\n\\n    vector<vector<int>> combinationSum3(int k, int n) \\n    {\\n        // craeting the 2d bector for storing the list of list (final answer)\\n        vector<vector<int>> res;\\n\\n        // creating the vector that will store the combinations one by one \\n        vector<int> ds;\\n        \\n        // we are going to use recursion here because we need to check all possible combinations for n by using int between 1 to 9\\n        helper(res, ds, k, n, 1);\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res, vector<int> &ds, int count, int sum, int start)\\n    {\\n        // base condition to reached the answer\\n        if(sum==0 && count==0)\\n        {\\n            res.push_back(ds);\\n            return;\\n        }\\n\\n        // if any one of them (k,n) gets 0 it means no valid combination found then we return\\n        if(sum==0 || count==0)\\n            return;\\n\\n        // if value cross 9 then we also return as given in the condition\\n        if(start>9)\\n            return;\\n        \\n        //if current value lies in boundary then take it\\n        if(sum>=start && count>0)\\n        {\\n            ds.push_back(start);                               // taking the current value\\n            helper(res, ds, count-1, sum-start, start+1);      // now calling the same function for next\\n            ds.pop_back();                                     // backtracking\\n        }\\n\\n        //skipping the current value if it is not is the bound and check for\\n        helper(res, ds, count, sum, start+1);\\n    }\\n\\n    vector<vector<int>> combinationSum3(int k, int n) \\n    {\\n        // craeting the 2d bector for storing the list of list (final answer)\\n        vector<vector<int>> res;\\n\\n        // creating the vector that will store the combinations one by one \\n        vector<int> ds;\\n        \\n        // we are going to use recursion here because we need to check all possible combinations for n by using int between 1 to 9\\n        helper(res, ds, k, n, 1);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025355,
                "title": "c-easy-understanding-comments-explanation-daily-leetcoding-challenge-may-day-10",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res, vector<int> &ds, int count, int sum, int start)\\n    {\\n        // if we reached to our answer\\n        if(sum==0 && count==0)\\n        {\\n            res.push_back(ds);\\n            return;\\n        }\\n        \\n        // if any one of them (k,n) gets 0 then return\\n        if(sum==0 or count==0)\\n            return;\\n        \\n        // if value cross 9 then also return\\n        if(start>9)\\n            return;\\n        \\n        // if currentvalue lies in boundary then take it\\n        if(sum>=start && count>0)\\n        {\\n            ds.push_back(start);                               // taking the current value\\n            helper(res, ds, count-1, sum-start, start+1);      // now calling the same function for next\\n            ds.pop_back();                                     // backtracking\\n        }\\n        \\n        // else skipping the current value if it is not is the bound\\n        helper(res, ds, count, sum, start+1);\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) \\n    {\\n        // craeting the 2d bector for storing the list of list (final answer)\\n        vector<vector<int>> res;\\n        \\n        // creating the vector that will store the combinations one by one \\n        vector<int> ds;\\n        \\n        // we are going to use recursion here because we need to check all possible combinations for n by using int between 1 to 9\\n        helper(res, ds, k, n, 1);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &res, vector<int> &ds, int count, int sum, int start)\\n    {\\n        // if we reached to our answer\\n        if(sum==0 && count==0)\\n        {\\n            res.push_back(ds);\\n            return;\\n        }\\n        \\n        // if any one of them (k,n) gets 0 then return\\n        if(sum==0 or count==0)\\n            return;\\n        \\n        // if value cross 9 then also return\\n        if(start>9)\\n            return;\\n        \\n        // if currentvalue lies in boundary then take it\\n        if(sum>=start && count>0)\\n        {\\n            ds.push_back(start);                               // taking the current value\\n            helper(res, ds, count-1, sum-start, start+1);      // now calling the same function for next\\n            ds.pop_back();                                     // backtracking\\n        }\\n        \\n        // else skipping the current value if it is not is the bound\\n        helper(res, ds, count, sum, start+1);\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) \\n    {\\n        // craeting the 2d bector for storing the list of list (final answer)\\n        vector<vector<int>> res;\\n        \\n        // creating the vector that will store the combinations one by one \\n        vector<int> ds;\\n        \\n        // we are going to use recursion here because we need to check all possible combinations for n by using int between 1 to 9\\n        helper(res, ds, k, n, 1);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024527,
                "title": "c-clean-backtracking",
                "content": "```\\nusing System.Collections.Generic;\\n\\npublic class Solution\\n{\\n    public IList<IList<int>> CombinationSum3(int k, int n)\\n    {\\n        List<IList<int>> results = new();\\n        Stack<int> stack = new();\\n        FindSum(1, k, n);\\n        return results;\\n\\n        void FindSum(int startingValue, int numberOfNumbers, int targetSum)\\n        {\\n            if (targetSum is 0 && numberOfNumbers is 0) results.Add(stack.ToArray());\\n            if (targetSum is 0 || numberOfNumbers is 0) return;\\n\\n            for (int value = startingValue; value < 10; value++)\\n            {\\n                stack.Push(value);\\n                FindSum(value + 1, numberOfNumbers - 1, targetSum - value);\\n                stack.Pop();\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Backtracking"
                ],
                "code": "```\\nusing System.Collections.Generic;\\n\\npublic class Solution\\n{\\n    public IList<IList<int>> CombinationSum3(int k, int n)\\n    {\\n        List<IList<int>> results = new();\\n        Stack<int> stack = new();\\n        FindSum(1, k, n);\\n        return results;\\n\\n        void FindSum(int startingValue, int numberOfNumbers, int targetSum)\\n        {\\n            if (targetSum is 0 && numberOfNumbers is 0) results.Add(stack.ToArray());\\n            if (targetSum is 0 || numberOfNumbers is 0) return;\\n\\n            for (int value = startingValue; value < 10; value++)\\n            {\\n                stack.Push(value);\\n                FindSum(value + 1, numberOfNumbers - 1, targetSum - value);\\n                stack.Pop();\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024203,
                "title": "backtracking",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        backtrack(target, k, result, 1, new ArrayList<>(), 0);\\n        return result;\\n    }\\n    \\n    private void backtrack(int target, int k, List<List<Integer>> result, int index, List<Integer> currList,\\n                           int currSum) {\\n        if (currSum > target) return;\\n        if (currSum == target && currList.size() == k) result.add(new ArrayList<>(currList));\\n        for (int i = index; i < 10 && currList.size() <= k; ++i) {\\n            currList.add(i);\\n            backtrack(target, k, result, i + 1, currList, currSum + i);\\n            currList.remove(currList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int target) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        backtrack(target, k, result, 1, new ArrayList<>(), 0);\\n        return result;\\n    }\\n    \\n    private void backtrack(int target, int k, List<List<Integer>> result, int index, List<Integer> currList,\\n                           int currSum) {\\n        if (currSum > target) return;\\n        if (currSum == target && currList.size() == k) result.add(new ArrayList<>(currList));\\n        for (int i = index; i < 10 && currList.size() <= k; ++i) {\\n            currList.add(i);\\n            backtrack(target, k, result, i + 1, currList, currSum + i);\\n            currList.remove(currList.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60652,
                "title": "combinations-v-s-combination-sum-iii-java",
                "content": "These two questions are very similar, so here I am going to put these two questions into comparisons.\\n\\nIn ***Combinations***, given `k` is the length of the sub-list, `n` is the last number of combination, return all possible combinations of k numbers out of 1 ... n.\\n\\nIn ***Combination Sum III***,  `k` is the length of the sub-list, `n` is the target sum, return all possible combinations of k numbers  that add up to `n`. Here, we limit the number used from 1 to 9. \\n\\nWhat's the similarities? \\n\\n 1. Both start at `1`\\n 2. ***Combinations*** ends ranges from `n - k + 1` to `n` , ***Combination Sum III*** from `1` to `9`  \\n 3. ***Combinations*** adds sub-list when sub-list size is equal to `k`, ***Combination Sum III*** adds sub-list when sub-list size is equal to `k` and remaining equals `0` (subtract `i` from `n` in loop)\\n \\n----------\\n\\n\\nCombinations :\\n\\n    public List<List<Integer>> combine(int n, int k) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<Integer>(), k, 1, n - k + 1);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int start, int end) {\\n       if (tempList.size() == k) list.add(new ArrayList<>(tempList)); \\n       else{\\n          for (int i = start; i <= end; i++) {\\n             tempList.add(i);\\n             backtrack(list, tempList, k, i + 1, end + 1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n\\nCombination Sum III :\\n\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<Integer>(), k, n, 1);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int start) {\\n       if(tempList.size() == k && remain == 0) list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i <= 9; i++) {\\n             tempList.add(i);\\n             backtrack(list, tempList, k, remain - i, i + 1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       } \\n    }",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "These two questions are very similar, so here I am going to put these two questions into comparisons.\\n\\nIn ***Combinations***, given `k` is the length of the sub-list, `n` is the last number of combination, return all possible combinations of k numbers out of 1 ... n.\\n\\nIn ***Combination Sum III***,  `k` is the length of the sub-list, `n` is the target sum, return all possible combinations of k numbers  that add up to `n`. Here, we limit the number used from 1 to 9. \\n\\nWhat's the similarities? \\n\\n 1. Both start at `1`\\n 2. ***Combinations*** ends ranges from `n - k + 1` to `n` , ***Combination Sum III*** from `1` to `9`  \\n 3. ***Combinations*** adds sub-list when sub-list size is equal to `k`, ***Combination Sum III*** adds sub-list when sub-list size is equal to `k` and remaining equals `0` (subtract `i` from `n` in loop)\\n \\n----------\\n\\n\\nCombinations :\\n\\n    public List<List<Integer>> combine(int n, int k) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<Integer>(), k, 1, n - k + 1);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int start, int end) {\\n       if (tempList.size() == k) list.add(new ArrayList<>(tempList)); \\n       else{\\n          for (int i = start; i <= end; i++) {\\n             tempList.add(i);\\n             backtrack(list, tempList, k, i + 1, end + 1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    }\\n\\nCombination Sum III :\\n\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<Integer>(), k, n, 1);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int k, int remain, int start) {\\n       if(tempList.size() == k && remain == 0) list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i <= 9; i++) {\\n             tempList.add(i);\\n             backtrack(list, tempList, k, remain - i, i + 1);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       } \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 60746,
                "title": "accepted-recursive-java-solution-easy-to-understand",
                "content": "The idea is to choose proper number for 1,2..kth position in ascending order, and for each position, we only iterate through (prev_num, n/k]. Time comlexity O(k)\\n\\n    public class Solution {\\n        private List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        public List<List<Integer>> combinationSum3(int k, int n) {\\n            findCombo( k, n, 1, new LinkedList<Integer>() );\\n            return res;\\n        }\\n        public void findCombo(int k, int n, int start, List<Integer> list){\\n            if( k == 1 ){\\n                if( n < start || n > 9 ) return;\\n                list.add( n );\\n                res.add( list );\\n                return;\\n            }\\n            for( int i = start; i <= n / k && i < 10; i++ ){\\n                List<Integer> subList = new LinkedList<Integer>( list );\\n                sub.add( i );\\n                findCombo( k - 1, n - i, i + 1, subList );\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        private List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        public List<List<Integer>> combinationSum3(int k, int n) {\\n            findCombo( k, n, 1, new LinkedList<Integer>() );\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3535660,
                "title": "backtracking-c-tc-o-k-9-k-sc-o-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every combination we try out, we get an option of either selecting a digit from 1 to 9, or rejecting it and moving to the next one. Once we\\'ve made that choice, we have to continue making that decision for digits succeeding the current one.\\n\\nThis process is repeated till we either run out of the number of digits we can select, or the current sum becomes equal to the required sum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDeclare a function `generateCombos` with the parameters `idx` that indicates the number current number whose selection/rejection is to be decided, `k` that represents the number of digits we can select, `n` that represents the required sum, `temp` that stores the possible combination generated and `sol` that contains all possible solutions.\\n\\nIterate from `idx` to 9, selecting/rejecting values to be added to the possible solution. If the value to be selected is greater than the required sum `n`, return to the function call.\\n\\nIn all other cases, select the current value and recursively call the function with the next digit and the new, reduced values of `k` and `n`. Finally, reject the current value and move on the the subsequent values to generate all possible subcases.\\n\\nIf at any point in the function calls the number of moves become zero and the required sum is obtained, push it into the `sol` solution vector.\\n\\n# Complexity\\n- Time complexity: $$O(k*9^k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void generateCombos(int idx, int k, int n, vector<int>& temp, vector<vector<int>>& sol){\\n        if(!k||!n){\\n            if(!k&&!n) sol.push_back(temp);\\n            return;\\n        }\\n\\n        for(int i=idx;i<=9;i++){\\n            if(n<i) return;\\n            \\n            temp.push_back(i);\\n            generateCombos(i+1, k-1, n-i, temp, sol);\\n            temp.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> temp;\\n        vector<vector<int>> sol;\\n\\n        generateCombos(1, k, n, temp, sol);\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void generateCombos(int idx, int k, int n, vector<int>& temp, vector<vector<int>>& sol){\\n        if(!k||!n){\\n            if(!k&&!n) sol.push_back(temp);\\n            return;\\n        }\\n\\n        for(int i=idx;i<=9;i++){\\n            if(n<i) return;\\n            \\n            temp.push_back(i);\\n            generateCombos(i+1, k-1, n-i, temp, sol);\\n            temp.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> temp;\\n        vector<vector<int>> sol;\\n\\n        generateCombos(1, k, n, temp, sol);\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460726,
                "title": "bet-me-no-one-can-beat-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(9^k)\\nbecause we\\'re generating all possible combinations of numbers from 1 to 9 with length k\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> O(k)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/a66e19ac-9823-407c-b176-b5f22dbbd7e5_1682601634.5993307.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        // create a list to store all subsets that satisfy the conditions\\n        List<List<Integer>> subset = new ArrayList<>();\\n\\n        // create an array list to store the current subset\\n        ArrayList<Integer> current = new ArrayList<>();\\n\\n        // generate the subsets\\n        generateSubset(1,9,current,subset,k,n);\\n\\n        // return the list of subsets\\n        return subset;\\n    }\\n\\n    // helper method to generate the subsets\\n    public void generateSubset(int start,int end,ArrayList<Integer> current, List<List<Integer>> subset,int k, int target){\\n\\n        // if target is reached and the size of current subset is k, add current subset to the list of subsets\\n        if(target == 0 && current.size() == k){\\n            subset.add(new ArrayList(current));\\n        }\\n\\n        // recursively generate subsets by trying all possible numbers from start to end\\n        for(int i = start; i <= end; i++){\\n            current.add(i);\\n\\n            // recursively call generateSubset with updated current subset and target\\n            generateSubset(i+1, end, current,subset,k,target-i);\\n\\n            // remove the last element from current subset before trying the next number\\n            current.remove(current.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        // create a list to store all subsets that satisfy the conditions\\n        List<List<Integer>> subset = new ArrayList<>();\\n\\n        // create an array list to store the current subset\\n        ArrayList<Integer> current = new ArrayList<>();\\n\\n        // generate the subsets\\n        generateSubset(1,9,current,subset,k,n);\\n\\n        // return the list of subsets\\n        return subset;\\n    }\\n\\n    // helper method to generate the subsets\\n    public void generateSubset(int start,int end,ArrayList<Integer> current, List<List<Integer>> subset,int k, int target){\\n\\n        // if target is reached and the size of current subset is k, add current subset to the list of subsets\\n        if(target == 0 && current.size() == k){\\n            subset.add(new ArrayList(current));\\n        }\\n\\n        // recursively generate subsets by trying all possible numbers from start to end\\n        for(int i = start; i <= end; i++){\\n            current.add(i);\\n\\n            // recursively call generateSubset with updated current subset and target\\n            generateSubset(i+1, end, current,subset,k,target-i);\\n\\n            // remove the last element from current subset before trying the next number\\n            current.remove(current.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387485,
                "title": "runtime-0-sec-faster-than-100-very-simple-beginner-friendly-approach",
                "content": "**Intution:** We need to create distinct subsequences, hence we can make use of recursion. We can start by pushing 1 in the ds(data structure used to store the vectors) , i.e if i am presently at 1, i have options for 2,3,4 uptill 9. \\n    After the recursive call, we  increase the i by 1 (for the next stage) and add i to the sum(s).\\nBase case is easy when the size of ds == k and s == n ,we push the ds in ans, else we simply return. \\t\\n\\n**Time Complexity** - 2^n * k  (where k is the avg size of the ds)\\n**Space  Complexity** - k*x (auxillary space is ignored)\\n\\n```\\nvoid generate_combinations(int i, int s, int k, int n, vector<vector<int>> &ans, vector<int>&ds){\\n        \\n        if(ds.size() == k){\\n            \\n            if(s == n){\\n            ans.push_back(ds);\\n            }\\n           return;\\n        } \\n        \\n        for(i; i<=9; i++){\\n            \\n            ds.push_back(i);\\n            generate_combinations(i+1, s+i, k, n, ans, ds);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<vector<int>> ans; \\n        vector<int> ds;\\n        \\n        generate_combinations(1,0, k, n, ans, ds);\\n        return ans;\\n        \\n    }\\n};\\n\\n```\\nIf you liked my Solution, do upvote. Happy Leetcoding !",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nvoid generate_combinations(int i, int s, int k, int n, vector<vector<int>> &ans, vector<int>&ds){\\n        \\n        if(ds.size() == k){\\n            \\n            if(s == n){\\n            ans.push_back(ds);\\n            }\\n           return;\\n        } \\n        \\n        for(i; i<=9; i++){\\n            \\n            ds.push_back(i);\\n            generate_combinations(i+1, s+i, k, n, ans, ds);\\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<vector<int>> ans; \\n        vector<int> ds;\\n        \\n        generate_combinations(1,0, k, n, ans, ds);\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3215401,
                "title": "best-c-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(k*nCk), here nCk means the binomial coefficient of picking k elements out of n elements. where nCk = C(n,k) = n!/(n\\u2212k)!\\xD7k!.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(nCk), In worst case as stated above the nCk here refers to the binomial coefficient.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(k*nCk), here nCk means the binomial coefficient of picking k elements out of n elements.\\n    where nCk = C(n,k) = n!/(n\\u2212k)!\\xD7k!.\\n\\n    Space Complexity : O(nCk), In worst case as stated above the nCk here refers to the binomial coefficient.\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\nclass Solution {\\nprivate:\\n    void combinationSum3(int n, int k, vector<vector<int>> &output, vector<int> &temp, int start, int sum){\\n        if(temp.size() == k){\\n            if(n == sum){\\n                output.push_back(temp);\\n            }\\n            return;\\n        }\\n        for(int i=start; i<=9; i++){\\n            temp.push_back(i); \\n            combinationSum3(n, k, output, temp, i+1, sum+i);\\n            temp.pop_back(); \\n        }\\n    }     \\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum3(n, k, output, temp, 1, 0);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n**IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.**\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(k*nCk), here nCk means the binomial coefficient of picking k elements out of n elements.\\n    where nCk = C(n,k) = n!/(n\\u2212k)!\\xD7k!.\\n\\n    Space Complexity : O(nCk), In worst case as stated above the nCk here refers to the binomial coefficient.\\n\\n    Solved using Array + Backtracking.\\n\\n*/\\n\\nclass Solution {\\nprivate:\\n    void combinationSum3(int n, int k, vector<vector<int>> &output, vector<int> &temp, int start, int sum){\\n        if(temp.size() == k){\\n            if(n == sum){\\n                output.push_back(temp);\\n            }\\n            return;\\n        }\\n        for(int i=start; i<=9; i++){\\n            temp.push_back(i); \\n            combinationSum3(n, k, output, temp, i+1, sum+i);\\n            temp.pop_back(); \\n        }\\n    }     \\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        combinationSum3(n, k, output, temp, 1, 0);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211811,
                "title": "100-submission-time-taken-0ms-c-solution-using-simple-recursion-with-backtracing",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst of all we have to check for all the number from 1-9 and no number should repeat itself so we will have a loop from 1 to 9.\\n\\nWhenever we choose a number we use recursion and see for the value ahead of that number by replacing value of s by i+1.this will remove the possibility of any repetition of a number.\\n\\neg : if the number choose is 2 then the recursion will see for the other number ahead of it i.e 3,4... so on and the code will not see for 1 as it would be checked first and if the recursion is going for 2 that means that 1 was not suitable for the give condition. \\n\\n# Complexity\\n- Time complexity:O(k*9^k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define vii vector<vector<int>>\\n#define vi vector<int>\\n#define pb push_back\\nclass Solution {\\npublic:\\nvii ans;\\nvoid solve(vi &x,int k,int t,int s){\\n\\n    //base case\\n    if(t==0){ // here we have to push value when the target is zero\\n        if(k==0){   // but the condition is that the size should be k \\n        ans.pb(x); //so we will only push the vector when k is zero i.e the size of the give answer is k\\n        }\\n        return;\\n    }\\n    //recursive case\\n    for(int i=s;i<=9;++i){\\n        if(t>=i and k>0){   // here we will perform only when the target is greater than the value we are taking as well as the k should be +ve which means that the condition of having k element is not yet completed\\n            x.pb(i);\\n            k--; // whenever a value is inserted k is reduced \\n            solve(x,k,t-i,i+1);\\n            x.pop_back();\\n            k++;    // whenever a value is removed k is incremented again\\n        }\\n    }\\n\\n}\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vi x;\\n        solve(x,k,n,1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n#define vii vector<vector<int>>\\n#define vi vector<int>\\n#define pb push_back\\nclass Solution {\\npublic:\\nvii ans;\\nvoid solve(vi &x,int k,int t,int s){\\n\\n    //base case\\n    if(t==0){ // here we have to push value when the target is zero\\n        if(k==0){   // but the condition is that the size should be k \\n        ans.pb(x); //so we will only push the vector when k is zero i.e the size of the give answer is k\\n        }\\n        return;\\n    }\\n    //recursive case\\n    for(int i=s;i<=9;++i){\\n        if(t>=i and k>0){   // here we will perform only when the target is greater than the value we are taking as well as the k should be +ve which means that the condition of having k element is not yet completed\\n            x.pb(i);\\n            k--; // whenever a value is inserted k is reduced \\n            solve(x,k,t-i,i+1);\\n            x.pop_back();\\n            k++;    // whenever a value is removed k is incremented again\\n        }\\n    }\\n\\n}\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vi x;\\n        solve(x,k,n,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025671,
                "title": "2-solution-using-backtracking-dp-c",
                "content": "**1) BACKTRACKING SOLUTION**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(int k , int n,int sum , vector<int> v , int start)\\n    {\\n        if(k == 0)\\n        {\\n            if(sum == n)\\n                ans.push_back(v);\\n            return;\\n        }\\n        for(int i=start;i<=9;i++)\\n        {\\n            v.push_back(i);\\n            solve(k - 1 , n , sum+i , v , i + 1);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> v;\\n        solve(k , n , 0, v , 1);\\n        return ans;\\n    }\\n};\\n```\\n\\n**2) DP SOLUTION**\\nSimilar to 0-1 knapsack o(n) optimizattion\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<vector<int>>> dp(n+1);\\n        dp[0] = {{}};\\n        for(int i=1;i<=9;i++)\\n        {\\n            for(int j = n ; j >=i ; j--)\\n            {\\n                for(auto v : dp[j - i])\\n                {\\n                    v.push_back(i);\\n                    dp[j].push_back(v);\\n                }\\n            }\\n        }\\n        vector<vector<int>>res;\\n        for(auto t: dp[n])\\n        {\\n            if(t.size()==k)res.push_back(t);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void solve(int k , int n,int sum , vector<int> v , int start)\\n    {\\n        if(k == 0)\\n        {\\n            if(sum == n)\\n                ans.push_back(v);\\n            return;\\n        }\\n        for(int i=start;i<=9;i++)\\n        {\\n            v.push_back(i);\\n            solve(k - 1 , n , sum+i , v , i + 1);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> v;\\n        solve(k , n , 0, v , 1);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<vector<int>>> dp(n+1);\\n        dp[0] = {{}};\\n        for(int i=1;i<=9;i++)\\n        {\\n            for(int j = n ; j >=i ; j--)\\n            {\\n                for(auto v : dp[j - i])\\n                {\\n                    v.push_back(i);\\n                    dp[j].push_back(v);\\n                }\\n            }\\n        }\\n        vector<vector<int>>res;\\n        for(auto t: dp[n])\\n        {\\n            if(t.size()==k)res.push_back(t);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024233,
                "title": "c-easy-solution-with-explaination-backtracking",
                "content": "This problem is very simmilar to it\\'s previous versions ([Combination Sum I](https://leetcode.com/problems/combination-sum/) and [Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)).\\nWe will apply backtracking approach to solve this problem.\\n**Following are the steps to follow:**\\n1. Maintain two vectors (vector<vector<int>> and vector<int>),\\n2. Start with \\'1\\' and move to \\'9\\'.\\n3. Put every number in temp vector and include that number into sum property.\\n4. If number of elements in temp vector are more than k i.e k==0, check for sum and take action accordingly.\\n5. Then backtrack everytime for another solution.\\n6. Finally, return the solution.\\n\\n**Simple c++ code:**\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(int prev,int k,int sum,int n,vector<int> temp,vector<vector<int>>&ans){\\n        if(k==0){\\n            if(sum==n){\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n        for(int i=prev;i<=9;i++){\\n            temp.push_back(i);\\n            solve(i+1,k-1,sum+i,n,temp,ans);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        solve(1,k,0,n,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int prev,int k,int sum,int n,vector<int> temp,vector<vector<int>>&ans){\\n        if(k==0){\\n            if(sum==n){\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n        for(int i=prev;i<=9;i++){\\n            temp.push_back(i);\\n            solve(i+1,k-1,sum+i,n,temp,ans);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        solve(1,k,0,n,temp,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843430,
                "title": "python-crazy-simple-solution-faster-than-95",
                "content": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        all_combinations = list(combinations(range(1,10), k))\\n        sum_n = [c for c in all_combinations if sum(c)==n]\\n        return sum_n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        all_combinations = list(combinations(range(1,10), k))\\n        sum_n = [c for c in all_combinations if sum(c)==n]\\n        return sum_n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671391,
                "title": "javascript-solution",
                "content": "```js\\n/**\\n * @param {number} k\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar combinationSum3 = function(k, n) {\\n    const solArr = [];\\n    \\n    const recurse = (currArr, target, index) => {\\n        if (target < 0 || currArr.length > k) return;\\n        if (currArr.length === k) return target === 0 && solArr.push(currArr.slice())\\n        \\n        for (let i = index; i <= 9; i++) {\\n            currArr.push(i);\\n            recurse(currArr, target - i, i + 1);\\n            currArr.pop();\\n        }\\n    };\\n\\n    recurse([], n, 1);\\n    \\n    return solArr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```js\\n/**\\n * @param {number} k\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar combinationSum3 = function(k, n) {\\n    const solArr = [];\\n    \\n    const recurse = (currArr, target, index) => {\\n        if (target < 0 || currArr.length > k) return;\\n        if (currArr.length === k) return target === 0 && solArr.push(currArr.slice())\\n        \\n        for (let i = index; i <= 9; i++) {\\n            currArr.push(i);\\n            recurse(currArr, target - i, i + 1);\\n            currArr.pop();\\n        }\\n    };\\n\\n    recurse([], n, 1);\\n    \\n    return solArr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60717,
                "title": "java-easy-to-understand-recursive-solution",
                "content": "        \\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<Integer> nums = new ArrayList<>();\\n        for (int i = 1; i <= 9; i++) {\\n            nums.add(i);\\n        }\\n        List<List<Integer>> ret = new ArrayList<>();\\n        dfs(nums, k, n, 0, new ArrayList<>(), ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(List<Integer> nums, int k, int n, int idx, List<Integer> path, List<List<Integer>> ret) {\\n        if (k <= 0 && n <= 0) {\\n            if (k == 0 && n == 0) {\\n                ret.add(path);\\n            }\\n            return; // backtracking\\n        }\\n        for (int i = idx; i < nums.size(); i++) {\\n            List<Integer> p = new ArrayList<>(path);\\n            p.add(nums.get(i));\\n            dfs(nums, k-1, n-nums.get(i), i+1, p, ret);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "        \\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<Integer> nums = new ArrayList<>();\\n        for (int i = 1; i <= 9; i++) {\\n            nums.add(i);\\n        }\\n        List<List<Integer>> ret = new ArrayList<>();\\n        dfs(nums, k, n, 0, new ArrayList<>(), ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(List<Integer> nums, int k, int n, int idx, List<Integer> path, List<List<Integer>> ret) {\\n        if (k <= 0 && n <= 0) {\\n            if (k == 0 && n == 0) {\\n                ret.add(path);\\n            }\\n            return; // backtracking\\n        }\\n        for (int i = idx; i < nums.size(); i++) {\\n            List<Integer> p = new ArrayList<>(path);\\n            p.add(nums.get(i));\\n            dfs(nums, k-1, n-nums.get(i), i+1, p, ret);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 60732,
                "title": "simple-dfs-solution",
                "content": "    def combinationSum3(self, k, n):\\n        res = []\\n        self.dfs(range(1,10), 0, [], k, n, res)\\n        return res\\n    \\n    def dfs(self, nums, idx, path, k, n, res):\\n        if n < 0:\\n            return\\n        if len(path) == k and n == 0:\\n            res.append(path)\\n            return\\n        for i in range(idx, len(nums)):\\n            self.dfs(nums, i+1, path+[nums[i]], k, n-nums[i], res)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "    def combinationSum3(self, k, n):\\n        res = []\\n        self.dfs(range(1,10), 0, [], k, n, res)\\n        return res\\n    \\n    def dfs(self, nums, idx, path, k, n, res):\\n        if n < 0:\\n            return\\n        if len(path) == k and n == 0:\\n            res.append(path)\\n            return\\n        for i in range(idx, len(nums)):\\n            self.dfs(nums, i+1, path+[nums[i]], k, n-nums[i], res)",
                "codeTag": "Python3"
            },
            {
                "id": 3224641,
                "title": "216-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe backtrack() function returns a list of lists, where each inner list is a valid combination of numbers that sum up to n. The start parameter represents the smallest number that can be added to the combination, and it starts at 1 initially. The target parameter is the remaining sum that we need to reach. The k parameter is the number of values we still need to add to the combination. The res parameter is not used anymore, so we can remove it.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def backtrack(start, target, k, res):\\n            if k == 0 and target == 0:\\n                return [[]]\\n            if k == 0 or target < 0:\\n                return []\\n            ans = []\\n            for i in range(start, 10):\\n                for combo in backtrack(i+1, target-i, k-1, res):\\n                    ans.append([i] + combo)\\n            return ans\\n        \\n        return backtrack(1, n, k, [])\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def backtrack(start, target, k, res):\\n            if k == 0 and target == 0:\\n                return [[]]\\n            if k == 0 or target < 0:\\n                return []\\n            ans = []\\n            for i in range(start, 10):\\n                for combo in backtrack(i+1, target-i, k-1, res):\\n                    ans.append([i] + combo)\\n            return ans\\n        \\n        return backtrack(1, n, k, [])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140812,
                "title": "easy-c-backtracking-code-beats-100",
                "content": "# Intuition\\nIntuition is same as that of Combination Sum 1 and 2 but the only difference is we are given with a range of numbers(1-9) instead of an array to iterate through.\\n\\n# Approach\\n- Write the Base Case which is if size of ds gets > than k and target is achieved then store that ds in ans vector.\\n- Run loop from 1 to 9 as it is the range given.\\n- Add the sum and do recursion and after completing recursion subract the i from that sum to its original state.\\n\\n# To Avoid getting duplicates if we use stack then it will increase space and time complexity that is why we use for loop to avoid using duplicates.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>> &ans, vector<int> &ds, int sum,int ind,int k,int n)\\n    {\\n        if(ds.size() == k)\\n        {\\n            if(sum == n)\\n            {\\n                ans.push_back(ds);\\n            }\\n            return;               \\n        }\\n           for(int i =ind ;i<=9;i++)\\n           {\\n               if(i>n) \\n               {\\n                   break;\\n               }\\n               sum = sum + i;\\n               ds.push_back(i);\\n               solve(ans,ds,sum,i+1,k,n);\\n               ds.pop_back();\\n               sum = sum - i;\\n           }\\n    }\\n\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int sum = 0;\\n        solve(ans,v,sum,1,k,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<int>> &ans, vector<int> &ds, int sum,int ind,int k,int n)\\n    {\\n        if(ds.size() == k)\\n        {\\n            if(sum == n)\\n            {\\n                ans.push_back(ds);\\n            }\\n            return;               \\n        }\\n           for(int i =ind ;i<=9;i++)\\n           {\\n               if(i>n) \\n               {\\n                   break;\\n               }\\n               sum = sum + i;\\n               ds.push_back(i);\\n               solve(ans,ds,sum,i+1,k,n);\\n               ds.pop_back();\\n               sum = sum - i;\\n           }\\n    }\\n\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int sum = 0;\\n        solve(ans,v,sum,1,k,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437048,
                "title": "c-simple-recursion-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int k ;\\n    vector<vector<int>> ans ;\\n    void solve(int num , int target , vector<int>&temp){\\n        if(target < 0 || temp.size() > k) return ;\\n        if(num > 9){\\n            if(temp.size() == k and !target) ans.push_back(temp) ;\\n            return ;\\n        }\\n        \\n        //take this element \\n        temp.push_back(num) ;\\n        solve(num + 1 , target - num , temp) ;\\n        temp.pop_back() ;\\n        \\n\\t\\t//dont take this element\\n        solve(num + 1 , target , temp) ;\\n        \\n        return ;\\n    }\\n    vector<vector<int>> combinationSum3(int k, int target) {\\n        this->k = k ;\\n        vector<int> temp ;\\n        solve(1,target,temp) ;\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int k ;\\n    vector<vector<int>> ans ;\\n    void solve(int num , int target , vector<int>&temp){\\n        if(target < 0 || temp.size() > k) return ;\\n        if(num > 9){\\n            if(temp.size() == k and !target) ans.push_back(temp) ;\\n            return ;\\n        }\\n        \\n        //take this element \\n        temp.push_back(num) ;\\n        solve(num + 1 , target - num , temp) ;\\n        temp.pop_back() ;\\n        \\n\\t\\t//dont take this element\\n        solve(num + 1 , target , temp) ;\\n        \\n        return ;\\n    }\\n    vector<vector<int>> combinationSum3(int k, int target) {\\n        this->k = k ;\\n        vector<int> temp ;\\n        solve(1,target,temp) ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027170,
                "title": "python3-3-lines-of-code",
                "content": "\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        nums = [i for i in range(1,10)]\\n        \\n        comb = itertools.combinations(nums,k)\\n        \\n        return [c for c in comb if sum(c) == n]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        nums = [i for i in range(1,10)]\\n        \\n        comb = itertools.combinations(nums,k)\\n        \\n        return [c for c in comb if sum(c) == n]",
                "codeTag": "Python3"
            },
            {
                "id": 2024735,
                "title": "short-c-100-fastest-explaination-o-n-o-1",
                "content": "**100% faster Easy Backtracking Solution** \\nThis problem is very simmilar to it\\'s previous versions (Combination Sum I and Combination Sum II).\\nWe will apply backtracking approach to solve this problem.\\n**Following are the steps to follow:**\\n\\n* Maintain two vectors (vector<vector> and vector),\\n* Start with \\'1\\' and move to \\'9\\'.\\n* Put every number in temp vector and include that number into sum property.\\n* If number of elements in temp vector are more than k i.e k==0, check for sum and take action accordingly.\\n* Then backtrack everytime for another solution.\\n* Finally, return the solution.\\n\\n**Simple c++ code:**\\n\\n```\\nclass Solution {\\npublic:\\n    void combinationSumHelper( int start, int k, int n, vector<int> &ds, vector<vector<int>> &ans ){\\n        \\n        if( k<= 0 ){\\n            // We have got our combination \\n            if( n == 0 ) ans.push_back( ds );\\n            return ;\\n        }\\n        \\n        for( int i=start ; i<=9 ; i++ ){\\n            \\n\\t\\t\\t// Push the element \\n            ds.push_back( i );\\n\\t\\t\\t// Find out the combinations possible with this number \\n            combinationSumHelper( i+1, k-1, n-i, ds, ans );\\n\\t\\t\\t// Backtracking \\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<vector<int>> ans ;\\n        vector<int> ds ;\\n        \\n        combinationSumHelper( 1, k , n, ds, ans );\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void combinationSumHelper( int start, int k, int n, vector<int> &ds, vector<vector<int>> &ans ){\\n        \\n        if( k<= 0 ){\\n            // We have got our combination \\n            if( n == 0 ) ans.push_back( ds );\\n            return ;\\n        }\\n        \\n        for( int i=start ; i<=9 ; i++ ){\\n            \\n\\t\\t\\t// Push the element \\n            ds.push_back( i );\\n\\t\\t\\t// Find out the combinations possible with this number \\n            combinationSumHelper( i+1, k-1, n-i, ds, ans );\\n\\t\\t\\t// Backtracking \\n            ds.pop_back();\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<vector<int>> ans ;\\n        vector<int> ds ;\\n        \\n        combinationSumHelper( 1, k , n, ds, ans );\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1686893,
                "title": "golang-0ms",
                "content": "```\\nfunc combinationSum3(k int, n int) [][]int {\\n\\tans := make([][]int, 0)\\n\\tcurrent := make([]int, k)\\n\\n\\tdfs216(&ans, current, n, k-1, 1)\\n\\n\\treturn ans\\n}\\n```\\n\\n```\\nfunc dfs216(ans *[][]int, current []int, target, index, start int) {\\n\\tif index < 0 {\\n\\t\\tif target == 0 {\\n\\t\\t\\t*ans = append(*ans, append([]int{}, current...))\\n\\t\\t}\\n\\t\\treturn\\n\\t}\\n\\n\\tfor i := start; i <= 9 && target >= i; i++ {\\n\\t\\tcurrent[index] = i\\n\\t\\tdfs216(ans, current, target-i, index-1, i+1)\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc combinationSum3(k int, n int) [][]int {\\n\\tans := make([][]int, 0)\\n\\tcurrent := make([]int, k)\\n\\n\\tdfs216(&ans, current, n, k-1, 1)\\n\\n\\treturn ans\\n}\\n```\n```\\nfunc dfs216(ans *[][]int, current []int, target, index, start int) {\\n\\tif index < 0 {\\n\\t\\tif target == 0 {\\n\\t\\t\\t*ans = append(*ans, append([]int{}, current...))\\n\\t\\t}\\n\\t\\treturn\\n\\t}\\n\\n\\tfor i := start; i <= 9 && target >= i; i++ {\\n\\t\\tcurrent[index] = i\\n\\t\\tdfs216(ans, current, target-i, index-1, i+1)\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1312061,
                "title": "c-easy-solution-backtracking-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void makesum(vector<int>& v,int tar,int ssf,vector<int> &temp,int idx,int cnt){\\n        if(ssf>tar){\\n            return;\\n        }\\n        if(ssf==tar){\\n            if(cnt==0){\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=idx;i<v.size();i++){\\n            temp.push_back(v[i]);\\n            makesum(v,tar,ssf+v[i],temp,i+1,cnt-1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> temp;\\n        vector<int> candidates;\\n        for(int i=0;i<9;i++){\\n            candidates.push_back(i+1);\\n        }\\n        makesum(candidates,n,0,temp,0,k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    void makesum(vector<int>& v,int tar,int ssf,vector<int> &temp,int idx,int cnt){\\n        if(ssf>tar){\\n            return;\\n        }\\n        if(ssf==tar){\\n            if(cnt==0){\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=idx;i<v.size();i++){\\n            temp.push_back(v[i]);\\n            makesum(v,tar,ssf+v[i],temp,i+1,cnt-1);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> temp;\\n        vector<int> candidates;\\n        for(int i=0;i<9;i++){\\n            candidates.push_back(i+1);\\n        }\\n        makesum(candidates,n,0,temp,0,k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312030,
                "title": "elegant-python-iterative-recursive",
                "content": "#### Iterative\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        \\n        current_combination, combinations = [], []\\n        integer, combination_sum = 1, 0\\n        queue = [(integer, current_combination, combination_sum)]\\n        while queue:\\n            integer, current_combination, combination_sum = queue.pop()\\n            if combination_sum == n and len(current_combination) == k: combinations.append(current_combination)\\n            else:\\n                for i in range(integer, 10):\\n                    if combination_sum + i > n: break\\n                    queue.append((i+1, current_combination + [i], combination_sum + i))\\n        \\n        return combinations\\n```\\n#### Recursive\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        \\n        combinations = []\\n        counter = [(integer, 1) for integer in range(1, 10)]\\n        \\n        def recursion(integer = 0, current_combination = [], combination_sum = 0):\\n            if combination_sum > n or len(current_combination) > k or integer not in range(9): return\\n            elif combination_sum == n and len(current_combination) == k: combinations.append(current_combination.copy())\\n            else:\\n                candidate, frequency = counter[integer]\\n                if frequency == 1:\\n                    counter[integer] = (candidate, 0)\\n                    recursion(integer, current_combination + [candidate], combination_sum + candidate)\\n                counter[integer] = (candidate, frequency)\\n                recursion(integer+1, current_combination, combination_sum)\\n                \\n        recursion()\\n        return combinations\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        \\n        current_combination, combinations = [], []\\n        integer, combination_sum = 1, 0\\n        queue = [(integer, current_combination, combination_sum)]\\n        while queue:\\n            integer, current_combination, combination_sum = queue.pop()\\n            if combination_sum == n and len(current_combination) == k: combinations.append(current_combination)\\n            else:\\n                for i in range(integer, 10):\\n                    if combination_sum + i > n: break\\n                    queue.append((i+1, current_combination + [i], combination_sum + i))\\n        \\n        return combinations\\n```\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        \\n        combinations = []\\n        counter = [(integer, 1) for integer in range(1, 10)]\\n        \\n        def recursion(integer = 0, current_combination = [], combination_sum = 0):\\n            if combination_sum > n or len(current_combination) > k or integer not in range(9): return\\n            elif combination_sum == n and len(current_combination) == k: combinations.append(current_combination.copy())\\n            else:\\n                candidate, frequency = counter[integer]\\n                if frequency == 1:\\n                    counter[integer] = (candidate, 0)\\n                    recursion(integer, current_combination + [candidate], combination_sum + candidate)\\n                counter[integer] = (candidate, frequency)\\n                recursion(integer+1, current_combination, combination_sum)\\n                \\n        recursion()\\n        return combinations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872958,
                "title": "c-dp-solution-o-m-9-n-combinatorics-solution",
                "content": "**DP Solution**\\n\\nRuntime: 4 ms, faster than 43.49% of C++ online submissions for Combination Sum III.\\nMemory Usage: 7.3 MB, less than 11.17% of C++ online submissions for Combination Sum III.\\n\\nSolution similar to [Coin Change 2](https://leetcode.com/problems/coin-change-2/), [Combination Sum](https://leetcode.com/problems/combination-sum/) \\nand 0-1 KnapSack problem (Candidates are considered once only), just need to track the combination sums in different vector.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        // If k>=n then no combination sum is possible Ex: k = 2, n = 1 => not possible, k = 2, n = 2 => not possible\\n        // Also largest possible combination sum = [1+2+3+4+5+6+7+8+9] = 45 and so if n>45 then no combination sum possible\\n        if(k>=n || n>45)return vector<vector<int>>{};\\n        \\n        // combination track 3D vector holds the combination sum vectors of nums from 1 to target\\n        vector<vector<vector<int>>>result(n+1,vector<vector<int>>(1,vector<int>(0)));     \\n        \\n        // dp vector holds all possible combination sum count for range 1 to target\\n        vector<int>dp(n+1,0);\\n        dp[0] = 1;\\n        \\n        // combination candidate limit 1 to 9 and so we take min(9,n)\\n        int lim = min(9,n);\\n        \\n        // Loop through candidates 1 to limit\\n        for(int i=1;i<=lim;i++)\\n        {\\n            // calculate the contribution of candidates in the range target to candidates\\n            // as we can only take each candidate once in each combination sum\\n            for(int j=n;j>=i;j--)\\n            {\\n                // combination sum count for number j\\n                dp[j]+= dp[j-i];\\n                \\n                // If combination sum possible for number j and i; and j is not the target  \\n                if(dp[j-i]>=1 && j<n)\\n                {\\n                    // get all combination sum vectors from number j-i  and add to number j\\'s combination sum vector \\n                    result[j].insert(result[j].end(),result[j-i].end()-dp[j-i],result[j-i].end());\\n\\n                    // add current candidate in to newly added combination sum vectors\\n                    for(int p=0;p<dp[j-i];p++)\\n                        result[j][result[j].size()-1-p].push_back(i);\\n                }\\n                \\n                // If combination sum possible for number j and i; and j is the target\\n                else if(dp[j-i]>=1 && j==n)\\n                {\\n                    // get all combination sum vectors from number j-i whose vector size k-1 and add to number j\\'s combination sum vector  \\n                    // add current candidate in to newly added combination sum vectors\\n                    for(int p=result[j-i].size()-dp[j-i];p<result[j-i].size();p++)\\n                        if(result[j-i][p].size()==k-1)\\n                            result[j].push_back(result[j-i][p]),result[j].back().push_back(i);\\n                }\\n            }\\n        }\\n        \\n        // remove blank vector at front\\n        result[n].erase(result[n].begin());\\n        return result[n];\\n    }\\n};\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        // base case k>=n then no possible solution and also for n>45\\n        if(k>=n || n>45) return vector<vector<int>>();\\n        \\n        // limit = n if n < 9\\n        int limit = min(9,n);\\n        \\n        // dp vector to hold all the combinations of target from 1 to target\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>());\\n        \\n        // loop through 1 to limit and check the contribution of candidates from 1 to n\\n        for(int i=1;i<=limit;i++)\\n        {\\n            // loop from n to i to check contribution of candidate i cause we consider each item once only\\n            for(int j=n;j>=i;j--)\\n            {\\n                // add candidate if compliment is 0\\n                if(j-i==0)dp[j].push_back({i});\\n                \\n                // otherwise add ith candidate to all compliment combinations and add those to dp[i]\\n                else if(dp[j-i].size()>0)\\n                {\\n                    for(auto t : dp[j-i])\\n                    {\\n                        t.push_back(i);\\n                        dp[j].push_back(t);\\n                    }\\n                }\\n            }    \\n        }\\n        \\n        // add only the k size combinations in to result\\n        vector<vector<int>>res;\\n        for(auto t: dp[n])\\n        {\\n            if(t.size()==k)res.push_back(t);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n\\n**Combination Solution**\\n\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Combination Sum III.\\nMemory Usage: 6.4 MB, less than 83.25% of C++ online submissions for Combination Sum III.\\n\\n```\\nGenerate all mCk combinations where m = min (9,n) and check the sum of the\\ncombination. Take only those combinations where sum == n.\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void combination(int start, int limit, int n, int k, int sum, int &target, vector<vector<int>>&res, vector<int>&vals)\\n    {\\n        // check sum == target\\n        if(k==0)\\n        {\\n            if(sum==target)\\n            {\\n                res.push_back(vals);\\n            }\\n            \\n            return;\\n        }\\n        \\n        if(n==0) return;\\n        \\n        // take and ignore value from start to limit-k+1\\n        for(int i=start;i<=limit-k+1;i++)\\n        {\\n            vals.push_back(i);\\n            combination(i+1,limit,n-1,k-1,sum+i,target,res,vals);\\n            vals.pop_back();\\n        }\\n        \\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        // base case k>=n then no possible solution and also for n>45\\n        if(k>=n || n>45) return {};\\n        \\n        // limit = n if n < 9\\n        int limit = min(9,n);\\n        \\n        vector<int>vals;\\n        vector<vector<int>>res;\\n        \\n        // generate all mCk combinations\\n        combination(1,limit,limit,k,0,n,res,vals);\\n        \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        // If k>=n then no combination sum is possible Ex: k = 2, n = 1 => not possible, k = 2, n = 2 => not possible\\n        // Also largest possible combination sum = [1+2+3+4+5+6+7+8+9] = 45 and so if n>45 then no combination sum possible\\n        if(k>=n || n>45)return vector<vector<int>>{};\\n        \\n        // combination track 3D vector holds the combination sum vectors of nums from 1 to target\\n        vector<vector<vector<int>>>result(n+1,vector<vector<int>>(1,vector<int>(0)));     \\n        \\n        // dp vector holds all possible combination sum count for range 1 to target\\n        vector<int>dp(n+1,0);\\n        dp[0] = 1;\\n        \\n        // combination candidate limit 1 to 9 and so we take min(9,n)\\n        int lim = min(9,n);\\n        \\n        // Loop through candidates 1 to limit\\n        for(int i=1;i<=lim;i++)\\n        {\\n            // calculate the contribution of candidates in the range target to candidates\\n            // as we can only take each candidate once in each combination sum\\n            for(int j=n;j>=i;j--)\\n            {\\n                // combination sum count for number j\\n                dp[j]+= dp[j-i];\\n                \\n                // If combination sum possible for number j and i; and j is not the target  \\n                if(dp[j-i]>=1 && j<n)\\n                {\\n                    // get all combination sum vectors from number j-i  and add to number j\\'s combination sum vector \\n                    result[j].insert(result[j].end(),result[j-i].end()-dp[j-i],result[j-i].end());\\n\\n                    // add current candidate in to newly added combination sum vectors\\n                    for(int p=0;p<dp[j-i];p++)\\n                        result[j][result[j].size()-1-p].push_back(i);\\n                }\\n                \\n                // If combination sum possible for number j and i; and j is the target\\n                else if(dp[j-i]>=1 && j==n)\\n                {\\n                    // get all combination sum vectors from number j-i whose vector size k-1 and add to number j\\'s combination sum vector  \\n                    // add current candidate in to newly added combination sum vectors\\n                    for(int p=result[j-i].size()-dp[j-i];p<result[j-i].size();p++)\\n                        if(result[j-i][p].size()==k-1)\\n                            result[j].push_back(result[j-i][p]),result[j].back().push_back(i);\\n                }\\n            }\\n        }\\n        \\n        // remove blank vector at front\\n        result[n].erase(result[n].begin());\\n        return result[n];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        // base case k>=n then no possible solution and also for n>45\\n        if(k>=n || n>45) return vector<vector<int>>();\\n        \\n        // limit = n if n < 9\\n        int limit = min(9,n);\\n        \\n        // dp vector to hold all the combinations of target from 1 to target\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>());\\n        \\n        // loop through 1 to limit and check the contribution of candidates from 1 to n\\n        for(int i=1;i<=limit;i++)\\n        {\\n            // loop from n to i to check contribution of candidate i cause we consider each item once only\\n            for(int j=n;j>=i;j--)\\n            {\\n                // add candidate if compliment is 0\\n                if(j-i==0)dp[j].push_back({i});\\n                \\n                // otherwise add ith candidate to all compliment combinations and add those to dp[i]\\n                else if(dp[j-i].size()>0)\\n                {\\n                    for(auto t : dp[j-i])\\n                    {\\n                        t.push_back(i);\\n                        dp[j].push_back(t);\\n                    }\\n                }\\n            }    \\n        }\\n        \\n        // add only the k size combinations in to result\\n        vector<vector<int>>res;\\n        for(auto t: dp[n])\\n        {\\n            if(t.size()==k)res.push_back(t);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nGenerate all mCk combinations where m = min (9,n) and check the sum of the\\ncombination. Take only those combinations where sum == n.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void combination(int start, int limit, int n, int k, int sum, int &target, vector<vector<int>>&res, vector<int>&vals)\\n    {\\n        // check sum == target\\n        if(k==0)\\n        {\\n            if(sum==target)\\n            {\\n                res.push_back(vals);\\n            }\\n            \\n            return;\\n        }\\n        \\n        if(n==0) return;\\n        \\n        // take and ignore value from start to limit-k+1\\n        for(int i=start;i<=limit-k+1;i++)\\n        {\\n            vals.push_back(i);\\n            combination(i+1,limit,n-1,k-1,sum+i,target,res,vals);\\n            vals.pop_back();\\n        }\\n        \\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        // base case k>=n then no possible solution and also for n>45\\n        if(k>=n || n>45) return {};\\n        \\n        // limit = n if n < 9\\n        int limit = min(9,n);\\n        \\n        vector<int>vals;\\n        vector<vector<int>>res;\\n        \\n        // generate all mCk combinations\\n        combination(1,limit,limit,k,0,n,res,vals);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842861,
                "title": "java-solution-simplified-with-video-explanation",
                "content": "<iframe width=\"650\" height=\"450\" src=\"https://www.youtube.com/embed/BPeyMvNc_b4\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\\n\\n```\\n\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n           Set<List<Integer>>  set = new HashSet<>();\\n        combinationSum3Helper(set, k, n, new HashSet<>());\\n        return new ArrayList<>(set);\\n    }\\n    \\n    private void combinationSum3Helper(Set<List<Integer>> ans, int noOfElements, int remainingSum, Set<Integer> runningSet) {\\n        if(noOfElements ==0){\\n            if(remainingSum==0){\\n                ans.add(new ArrayList<>(runningSet));  \\n                return ;\\n            } else {\\n                return ;\\n            }\\n        }\\n        \\n        if(remainingSum<0){\\n            return ;\\n        }\\n        \\n        for(int i=1;i<=9;i++) {\\n            if(!runningSet.contains(i)){\\n                runningSet.add(i);\\n                combinationSum3Helper(ans,noOfElements-1, remainingSum- i, runningSet);\\n                runningSet.remove(i);\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n           Set<List<Integer>>  set = new HashSet<>();\\n        combinationSum3Helper(set, k, n, new HashSet<>());\\n        return new ArrayList<>(set);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 842726,
                "title": "combination-sum-iii-python-99-13",
                "content": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        output=[]\\n        def dfs(depth,cur,start):\\n            nonlocal output\\n            if n-sum(cur)<sum([i for i in range(start,start+depth)]):\\n                return\\n            if depth==1 and start<=n-sum(cur)<10:\\n                output.append(cur+[n-sum(cur)])\\n                return\\n            for i in range(start,10):\\n                dfs(depth-1,cur+[i],i+1)\\n        \\n        dfs(k,[],1)\\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        output=[]\\n        def dfs(depth,cur,start):\\n            nonlocal output\\n            if n-sum(cur)<sum([i for i in range(start,start+depth)]):\\n                return\\n            if depth==1 and start<=n-sum(cur)<10:\\n                output.append(cur+[n-sum(cur)])\\n                return\\n            for i in range(start,10):\\n                dfs(depth-1,cur+[i],i+1)\\n        \\n        dfs(k,[],1)\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842694,
                "title": "c-ugly-bruteforce-solution-faster-than-100",
                "content": "```\\nclass Solution {\\nprivate:\\n   \\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        if (1+2+3+4+5+6+7+8+9 < n || k > 9)\\n            return {};\\n        \\n        vector<vector<int>> result;\\n        \\n        for(int i_1 = 0; i_1 < 2; i_1++) {\\n            for(int i_2 = 0; i_2 < 2; i_2++) {\\n                for(int i_3 = 0; i_3 < 2; i_3++) {\\n                    for(int i_4 = 0; i_4 < 2; i_4++) {\\n                        for(int i_5 = 0; i_5 < 2; i_5++) {\\n                            for(int i_6 = 0; i_6 < 2; i_6++) {\\n                                for(int i_7 = 0; i_7 < 2; i_7++) {\\n                                    for(int i_8 = 0; i_8 < 2; i_8++) {\\n                                        for(int i_9 = 0; i_9 < 2; i_9++) {\\n                                            if (i_1+i_2+i_3+i_4+i_5+i_6+i_7+i_8+i_9 != k) continue;\\n                                            if (i_1+2*i_2+3*i_3+4*i_4+5*i_5+6*i_6+7*i_7+8*i_8+9*i_9 != n) continue;\\n                                            vector<int> res;\\n                                            if(i_1 > 0) res.push_back(1);\\n                                            if(i_2 > 0) res.push_back(2);\\n                                            if(i_3 > 0) res.push_back(3);\\n                                            if(i_4 > 0) res.push_back(4);\\n                                            if(i_5 > 0) res.push_back(5);\\n                                            if(i_6 > 0) res.push_back(6);\\n                                            if(i_7 > 0) res.push_back(7);\\n                                            if(i_8 > 0) res.push_back(8);\\n                                            if(i_9 > 0) res.push_back(9);\\n                                            result.push_back(res);\\n                                        }\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }   \\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n   \\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        if (1+2+3+4+5+6+7+8+9 < n || k > 9)\\n            return {};\\n        \\n        vector<vector<int>> result;\\n        \\n        for(int i_1 = 0; i_1 < 2; i_1++) {\\n            for(int i_2 = 0; i_2 < 2; i_2++) {\\n                for(int i_3 = 0; i_3 < 2; i_3++) {\\n                    for(int i_4 = 0; i_4 < 2; i_4++) {\\n                        for(int i_5 = 0; i_5 < 2; i_5++) {\\n                            for(int i_6 = 0; i_6 < 2; i_6++) {\\n                                for(int i_7 = 0; i_7 < 2; i_7++) {\\n                                    for(int i_8 = 0; i_8 < 2; i_8++) {\\n                                        for(int i_9 = 0; i_9 < 2; i_9++) {\\n                                            if (i_1+i_2+i_3+i_4+i_5+i_6+i_7+i_8+i_9 != k) continue;\\n                                            if (i_1+2*i_2+3*i_3+4*i_4+5*i_5+6*i_6+7*i_7+8*i_8+9*i_9 != n) continue;\\n                                            vector<int> res;\\n                                            if(i_1 > 0) res.push_back(1);\\n                                            if(i_2 > 0) res.push_back(2);\\n                                            if(i_3 > 0) res.push_back(3);\\n                                            if(i_4 > 0) res.push_back(4);\\n                                            if(i_5 > 0) res.push_back(5);\\n                                            if(i_6 > 0) res.push_back(6);\\n                                            if(i_7 > 0) res.push_back(7);\\n                                            if(i_8 > 0) res.push_back(8);\\n                                            if(i_9 > 0) res.push_back(9);\\n                                            result.push_back(res);\\n                                        }\\n                                    }\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }   \\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 310040,
                "title": "simple-python-dfs-solutions-for-similar-backtrack-problems",
                "content": "Please see and vote for my simple solutions for\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 306068,
                "title": "combination-sum-i-ii-and-iii-iterative-dp-solutions",
                "content": "Basically we are using bottom-up DP, and notice that the outer loop is looping through the elements, not the DP table. Use `reversed(range())` to ensure that we do not reuse elements. (Reason is given in the code for Combination Sum II).\\n\\n---\\n### Combination Sum\\n```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [set() for _ in range(target + 1)]\\n        dp[0].add(())\\n        for c in candidates:\\n            for subtarget in range(target - c + 1):\\n                # this ascending loop from 0 to target - c (inclusive) allows reuse of elements\\n                dp[subtarget + c] |= {prev_list + (c,) for prev_list in dp[subtarget]}\\n        return list(dp[-1])\\n```\\n\\n---\\n### Combination Sum II\\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [set() for _ in range(target + 1)]   # set to ensure unique result\\n        dp[0].add(())\\n        for c in candidates:\\n            for subtarget in reversed(range(target - c + 1)):\\n                # If we do not use `reversed()`, when we are building dp[subtarget2] and \\n                # have already built dp[subtarget1] (where subtarget2 > subtarget1),\\n                # then we will use the new results we enter into dp[subtarget1] (i.e., use the same element more than once)\\n                dp[c + subtarget] |= {prev_list + (c,) for prev_list in dp[subtarget]}\\n        return list( dp[-1])\\n```\\n---\\n### Combination Sum III\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        dp = [set() for _ in range(n + 1)]\\n        dp[0].add(())\\n        for cand in range(1, 10):\\n            for subtarget in reversed(range(n - cand + 1)):\\n                dp[subtarget + cand] |= {prev_list + (cand,) for prev_list in dp[subtarget]}\\n        \\n        return [L for L in map(list, dp[-1]) if len(L) == k]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```python\\nclass Solution:\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [set() for _ in range(target + 1)]\\n        dp[0].add(())\\n        for c in candidates:\\n            for subtarget in range(target - c + 1):\\n                # this ascending loop from 0 to target - c (inclusive) allows reuse of elements\\n                dp[subtarget + c] |= {prev_list + (c,) for prev_list in dp[subtarget]}\\n        return list(dp[-1])\\n```\n```python\\nclass Solution:\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        candidates.sort()\\n        dp = [set() for _ in range(target + 1)]   # set to ensure unique result\\n        dp[0].add(())\\n        for c in candidates:\\n            for subtarget in reversed(range(target - c + 1)):\\n                # If we do not use `reversed()`, when we are building dp[subtarget2] and \\n                # have already built dp[subtarget1] (where subtarget2 > subtarget1),\\n                # then we will use the new results we enter into dp[subtarget1] (i.e., use the same element more than once)\\n                dp[c + subtarget] |= {prev_list + (c,) for prev_list in dp[subtarget]}\\n        return list( dp[-1])\\n```\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        dp = [set() for _ in range(n + 1)]\\n        dp[0].add(())\\n        for cand in range(1, 10):\\n            for subtarget in reversed(range(n - cand + 1)):\\n                dp[subtarget + cand] |= {prev_list + (cand,) for prev_list in dp[subtarget]}\\n        \\n        return [L for L in map(list, dp[-1]) if len(L) == k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 60789,
                "title": "simple-python-code-using-generator",
                "content": "    def combination(self, k, n, left):\\n        if k == 1 and n in left:\\n            yield [n]\\n        for i in range(len(left)):\\n            for rest in self.combination(k-1, n-left[i], left[i+1:]):\\n                rest.insert(0, left[i])\\n                yield rest\\n    \\n    def combinationSum3(self, k, n):\\n        return list(self.combination(k, n, range(1, 10)))",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def combination(self, k, n, left):\\n        if k == 1 and n in left:\\n            yield [n]\\n        for i in range(len(left)):\\n            for rest in self.combination(k-1, n-left[i], left[i+1:]):\\n                rest.insert(0, left[i])\\n                yield rest\\n    \\n    def combinationSum3(self, k, n):\\n        return list(self.combination(k, n, range(1, 10)))",
                "codeTag": "Python3"
            },
            {
                "id": 60838,
                "title": "share-my-128-ms-javascript-solution",
                "content": "    var combinationSum3 = function(k, n) {\\n      var result = [];\\n      search(1, [], k, n);\\n      return result;\\n    \\n      function search(from, prefix, k, n) {\\n        if (k === 0 && n === 0) return result.push(prefix);\\n        if (from > 9) return;\\n        prefix.push(from);\\n        search(from + 1, prefix.slice(0), k - 1, n - from);\\n        prefix.pop();\\n        search(from + 1, prefix.slice(0), k, n);\\n      }\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var combinationSum3 = function(k, n) {\\n      var result = [];\\n      search(1, [], k, n);\\n      return result;\\n    \\n      function search(from, prefix, k, n) {\\n        if (k === 0 && n === 0) return result.push(prefix);\\n        if (from > 9) return;\\n        prefix.push(from);\\n        search(from + 1, prefix.slice(0), k - 1, n - from);\\n        prefix.pop();\\n        search(from + 1, prefix.slice(0), k, n);\\n      }\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3467536,
                "title": "python-simple-clean-solution-using-combinations",
                "content": "\\n# Code\\n\\n## Using Recursion / DFS:\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(nums, k, n, path, ans):\\n            if k < 0 or n < 0:    return\\n            if k == 0 and n == 0: ans.append(path)\\n\\n            for i in range(len(nums)):\\n                dfs(nums[i + 1:], k - 1, n - nums[i], path + [nums[i]], ans)\\n        \\n        ans = []\\n        dfs(list(range(1,10)), k, n, [], ans)\\n        return ans\\n```\\n\\n## Using Functool Library\\'s combinations:\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        ans = []\\n        for c in combinations(range(1,10),k):\\n            if sum(c)==n:\\n                ans.append(c)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(nums, k, n, path, ans):\\n            if k < 0 or n < 0:    return\\n            if k == 0 and n == 0: ans.append(path)\\n\\n            for i in range(len(nums)):\\n                dfs(nums[i + 1:], k - 1, n - nums[i], path + [nums[i]], ans)\\n        \\n        ans = []\\n        dfs(list(range(1,10)), k, n, [], ans)\\n        return ans\\n```\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        ans = []\\n        for c in combinations(range(1,10),k):\\n            if sum(c)==n:\\n                ans.append(c)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346965,
                "title": "efficient-solution-c-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCombination is needed so \"Pick\" and \"Not Pick\" method is going to be used.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Base Case Explanation\\n```\\nif(k==vec.size()){\\n            if(n==0){\\n            ans.push_back(vec);\\n            return;\\n            }\\n            if(n<0){\\n                return;\\n            }\\n        }\\n        if(i==nums.size()){\\n            return;\\n        }\\n```\\nAs per the problem statement \\nSize of each combination must be equal to k (given in the problem)\\nand sum of the elements of the combination must be \\'n\\'(given in the problem) \\nIf both the condition are full-filled then the combination will be inserted in the ans (vector of vector).\\n\\nIf combination\\'s sum becomes more than n\\n ```\\nif(n<0) // Elements of combination are being subtracted from the required sum\\n```\\nthen, it will return.\\n\\nand if index which are being \"Pick\" or \"Not pick\" are equal to the size of nums \\n```\\nif(i==nums.size()){\\n            return;\\n        }\\n```\\n\\nthen it means there are no more elements left in the nums to take decision of picking it or not picking it, so it will return.\\n\\n# Recursive call Explanation\\n\\nIt is same as Combination Sum -->\\n\\nMy Combination sum solution link\\uD83D\\uDC47\\nhttps://leetcode.com/problems/combination-sum/solutions/3344753/100-beats-easy-to-understand-c-code/\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n*O(2^n)*\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n*O(n^2)*\\n\\nPlease upvote if you find it helpful\\u2B06\\uFE0F\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void help(int i,int k,int n,vector<int>&vec,vector<vector<int>>&ans,vector<int>&nums){\\n        if(k==vec.size()){\\n            if(n==0){\\n            ans.push_back(vec);\\n            return;\\n            }\\n            if(n<0){\\n                return;\\n            }\\n        }\\n        if(i==nums.size()){\\n            return;\\n        }\\n        \\n        vec.push_back(nums[i]);\\n        help(i+1,k,n-nums[i],vec,ans,nums);\\n        vec.pop_back();\\n        help(i+1,k,n,vec,ans,nums);\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int>nums{1,2,3,4,5,6,7,8,9};\\n        vector<int>vec;\\n        vector<vector<int>> ans;\\n        help(0,k,n,vec,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif(k==vec.size()){\\n            if(n==0){\\n            ans.push_back(vec);\\n            return;\\n            }\\n            if(n<0){\\n                return;\\n            }\\n        }\\n        if(i==nums.size()){\\n            return;\\n        }\\n```\n```\\nif(n<0) // Elements of combination are being subtracted from the required sum\\n```\n```\\nif(i==nums.size()){\\n            return;\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n    void help(int i,int k,int n,vector<int>&vec,vector<vector<int>>&ans,vector<int>&nums){\\n        if(k==vec.size()){\\n            if(n==0){\\n            ans.push_back(vec);\\n            return;\\n            }\\n            if(n<0){\\n                return;\\n            }\\n        }\\n        if(i==nums.size()){\\n            return;\\n        }\\n        \\n        vec.push_back(nums[i]);\\n        help(i+1,k,n-nums[i],vec,ans,nums);\\n        vec.pop_back();\\n        help(i+1,k,n,vec,ans,nums);\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int>nums{1,2,3,4,5,6,7,8,9};\\n        vector<int>vec;\\n        vector<vector<int>> ans;\\n        help(0,k,n,vec,ans,nums);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222235,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int k ;\\n    vector<vector<int>> ans ;\\n    void solve(int num , int target , vector<int>&temp){\\n        if(target < 0 || temp.size() > k) return ;\\n        if(num > 9){\\n            if(temp.size() == k and !target) ans.push_back(temp) ;\\n            return ;\\n        }\\n        temp.push_back(num) ;\\n        solve(num + 1 , target - num , temp) ;\\n        temp.pop_back() ;\\n        solve(num + 1 , target , temp) ;\\n        return ;\\n    }\\n    vector<vector<int>> combinationSum3(int k, int target) {\\n        this->k = k ;\\n        vector<int> temp ;\\n        solve(1,target,temp) ;\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int k ;\\n    vector<vector<int>> ans ;\\n    void solve(int num , int target , vector<int>&temp){\\n        if(target < 0 || temp.size() > k) return ;\\n        if(num > 9){\\n            if(temp.size() == k and !target) ans.push_back(temp) ;\\n            return ;\\n        }\\n        temp.push_back(num) ;\\n        solve(num + 1 , target - num , temp) ;\\n        temp.pop_back() ;\\n        solve(num + 1 , target , temp) ;\\n        return ;\\n    }\\n    vector<vector<int>> combinationSum3(int k, int target) {\\n        this->k = k ;\\n        vector<int> temp ;\\n        solve(1,target,temp) ;\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084198,
                "title": "beats-100-conventional-backtrackting-approach-c",
                "content": "# Code\\n```\\nclass Solution {\\n    vector<vector<int>> ans; \\n    void solve(vector<int>& v,int i, int n, int k, int s){\\n        if(s==0){\\n           if(k==0) ans.push_back(v);\\n            return;\\n        }\\n        if(i==n){\\n            return;\\n        }\\n        if(i<=s){\\n            v.push_back(i);\\n            solve(v,i+1, n, k-1, s-i );\\n            v.pop_back();\\n        }\\n        solve(v,i+1, n, k, s);\\n\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> v;\\n        solve(v, 1, 10, k ,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> ans; \\n    void solve(vector<int>& v,int i, int n, int k, int s){\\n        if(s==0){\\n           if(k==0) ans.push_back(v);\\n            return;\\n        }\\n        if(i==n){\\n            return;\\n        }\\n        if(i<=s){\\n            v.push_back(i);\\n            solve(v,i+1, n, k-1, s-i );\\n            v.pop_back();\\n        }\\n        solve(v,i+1, n, k, s);\\n\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> v;\\n        solve(v, 1, 10, k ,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3071688,
                "title": "easy-c-solution-recursion",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nvoid f(int i,int tar,vector<int>&can,vector<vector<int>>&res,vector<int>&temp,int k){\\n     if(tar==0){\\n         if(temp.size()==k)\\n                res.push_back(temp);\\n                return;\\n            } \\n        for(int j=i;j<can.size();j++){\\n            if(j>i && (can[j]==can[j-1])) continue;\\n            if(can[j]>tar) break;\\n            temp.push_back(can[j]);\\n            f(j+1,tar-can[j],can,res,temp,k);\\n            temp.pop_back();\\n        }\\n}\\n    vector<vector<int>> combinationSum3(int k, int tar) {\\n        vector<int>can;\\n        for(int i=0;i<9;i++){\\n            can.push_back(i+1);\\n        }\\n        vector<vector<int>>res;\\n        vector<int>temp;\\n        f(0,tar,can,res,temp,k);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid f(int i,int tar,vector<int>&can,vector<vector<int>>&res,vector<int>&temp,int k){\\n     if(tar==0){\\n         if(temp.size()==k)\\n                res.push_back(temp);\\n                return;\\n            } \\n        for(int j=i;j<can.size();j++){\\n            if(j>i && (can[j]==can[j-1])) continue;\\n            if(can[j]>tar) break;\\n            temp.push_back(can[j]);\\n            f(j+1,tar-can[j],can,res,temp,k);\\n            temp.pop_back();\\n        }\\n}\\n    vector<vector<int>> combinationSum3(int k, int tar) {\\n        vector<int>can;\\n        for(int i=0;i<9;i++){\\n            can.push_back(i+1);\\n        }\\n        vector<vector<int>>res;\\n        vector<int>temp;\\n        f(0,tar,can,res,temp,k);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025761,
                "title": "java-c-100-solution-using-backtracking-combination-sum-iii",
                "content": "# Complexity\\n- Time complexity: $$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Java Code\\n```\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    List<Integer> currCombination = new ArrayList<>();\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        makeCombination(k,n,1);\\n        return ans;\\n    }\\n    public void makeCombination(int k,int n,int start)\\n    {\\n        if(k==0 && n==0)\\n        {\\n            ans.add(new ArrayList<>(currCombination));\\n            return;\\n        }\\n        for(int i=start;i<10;++i)\\n        {\\n            currCombination.add(i);\\n            makeCombination(k-1,n-i,i+1);\\n            currCombination.remove(currCombination.size()-1);\\n        }\\n    }\\n}\\n```\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> currCombination;\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        makeCombination(k,n,1);\\n        return ans;\\n    }\\n    void makeCombination(int k,int n,int start){\\n        if(k==0 && n==0)\\n        {\\n            ans.push_back(currCombination);\\n            return;\\n        }\\n        for(int i = start;i<10;++i)\\n        {\\n            currCombination.push_back(i);\\n            makeCombination(k-1,n-i,i+1);\\n            currCombination.pop_back();\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    List<Integer> currCombination = new ArrayList<>();\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        makeCombination(k,n,1);\\n        return ans;\\n    }\\n    public void makeCombination(int k,int n,int start)\\n    {\\n        if(k==0 && n==0)\\n        {\\n            ans.add(new ArrayList<>(currCombination));\\n            return;\\n        }\\n        for(int i=start;i<10;++i)\\n        {\\n            currCombination.add(i);\\n            makeCombination(k-1,n-i,i+1);\\n            currCombination.remove(currCombination.size()-1);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> currCombination;\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        makeCombination(k,n,1);\\n        return ans;\\n    }\\n    void makeCombination(int k,int n,int start){\\n        if(k==0 && n==0)\\n        {\\n            ans.push_back(currCombination);\\n            return;\\n        }\\n        for(int i = start;i<10;++i)\\n        {\\n            currCombination.push_back(i);\\n            makeCombination(k-1,n-i,i+1);\\n            currCombination.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994199,
                "title": "easy-solution-well-explained-understandable",
                "content": "**Please give an upvote if you like the solution**\\n\\n*#6Companies30days #ReviseWithArsh Challenge 2023\\n*Day1*\\nQ2. Combination Sum with a twist.*\\n\\n# Approach\\nBacktracking Recursive \\n\\n![2.combination-sum-iii.jpg](https://assets.leetcode.com/users/images/bdf748fd-7f97-4f81-a9a1-a538278db186_1672774338.4305134.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void help(vector<vector<int>> &ans, vector<int>cur, int n, int k, int start){\\n        if(n==0 and k==0){ //base condition\\n        ans.push_back(cur); //append this combination in final ans\\n        return; //we can\\'t go further, bcuz if we go further k & n becomes negative\\n    }\\n    if(k==0){// when we reached the limit of takingelement into account\\n    return;// some amount left in n\\n    }\\n    for(int i=start;i<=9;i++){\\n        cur.push_back(i); //append i into current vector | push 1\\n        help(ans, cur, n-i, k-1, i+1); // as start=1, so n=n-i i.e., 4, as we have consider an element so k=k-1 i.e., 1, and i=i+1 cuz we had taken i=1 into our account , so for finding combinations for 1 we have to take 2, 3, 4...9 into consideration, we cannot take 1 again into consideration\\n        cur.pop_back(); // we have to find all combinations which are starting i i.e., intial i which was 1, now we have to find all combinations from next i i.e., i+1 i.e.,2, so we have  to pop 1\\n        //Now current vector is empty\\n        //now this process continuous further for 2, 3....9\\n    }\\n    return; //return the value\\n}\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector <vector<int>> ans; //return 2D array\\n        vector<int>cur; //store a current combination: we will see that current combination follows a given condition or not\\n        help(ans, cur, n, k, 1); //call a recursive function\\n        return ans;\\n    }\\n};\\n    \\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void help(vector<vector<int>> &ans, vector<int>cur, int n, int k, int start){\\n        if(n==0 and k==0){ //base condition\\n        ans.push_back(cur); //append this combination in final ans\\n        return; //we can\\'t go further, bcuz if we go further k & n becomes negative\\n    }\\n    if(k==0){// when we reached the limit of takingelement into account\\n    return;// some amount left in n\\n    }\\n    for(int i=start;i<=9;i++){\\n        cur.push_back(i); //append i into current vector | push 1\\n        help(ans, cur, n-i, k-1, i+1); // as start=1, so n=n-i i.e., 4, as we have consider an element so k=k-1 i.e., 1, and i=i+1 cuz we had taken i=1 into our account , so for finding combinations for 1 we have to take 2, 3, 4...9 into consideration, we cannot take 1 again into consideration\\n        cur.pop_back(); // we have to find all combinations which are starting i i.e., intial i which was 1, now we have to find all combinations from next i i.e., i+1 i.e.,2, so we have  to pop 1\\n        //Now current vector is empty\\n        //now this process continuous further for 2, 3....9\\n    }\\n    return; //return the value\\n}\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector <vector<int>> ans; //return 2D array\\n        vector<int>cur; //store a current combination: we will see that current combination follows a given condition or not\\n        help(ans, cur, n, k, 1); //call a recursive function\\n        return ans;\\n    }\\n};\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795587,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n  void combination(vector<vector<int>>& result, vector<int> sol, int k, int n) {\\n    if (sol.size() == k && n == 0) { result.push_back(sol); return ; }\\n    if (sol.size() < k) {\\n      for (int i = sol.empty() ? 1 : sol.back() + 1; i <= 9; ++i) {\\n        if (n - i < 0) break;\\n        sol.push_back(i);\\n        combination(result, sol, k, n - i);\\n        sol.pop_back();\\n      }\\n    }\\n  }\\n\\n  vector<vector<int>> combinationSum3(int k, int n) {\\n    vector<vector<int>> result;\\n    vector<int> sol;\\n    combination(result, sol, k, n);\\n    return result;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  void combination(vector<vector<int>>& result, vector<int> sol, int k, int n) {\\n    if (sol.size() == k && n == 0) { result.push_back(sol); return ; }\\n    if (sol.size() < k) {\\n      for (int i = sol.empty() ? 1 : sol.back() + 1; i <= 9; ++i) {\\n        if (n - i < 0) break;\\n        sol.push_back(i);\\n        combination(result, sol, k, n - i);\\n        sol.pop_back();\\n      }\\n    }\\n  }\\n\\n  vector<vector<int>> combinationSum3(int k, int n) {\\n    vector<vector<int>> result;\\n    vector<int> sol;\\n    combination(result, sol, k, n);\\n    return result;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783759,
                "title": "100-faster-c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(int k,int n,vector<int> tmp,vector<vector<int>> &ans,int s){\\n        if(n==0&&k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        if(n==0)return;\\n        if(k==0)return;\\n        for(int i = s; i <= 9; i++){\\n            tmp.push_back(i);\\n            solve(k-1,n-i,tmp,ans,i+1);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        if(k>=n || n==1){\\n            return ans;\\n        }\\n        vector<int> tmp;\\n        solve(k,n,tmp,ans,1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int k,int n,vector<int> tmp,vector<vector<int>> &ans,int s){\\n        if(n==0&&k==0){\\n            ans.push_back(tmp);\\n            return;\\n        }\\n        if(n==0)return;\\n        if(k==0)return;\\n        for(int i = s; i <= 9; i++){\\n            tmp.push_back(i);\\n            solve(k-1,n-i,tmp,ans,i+1);\\n            tmp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        if(k>=n || n==1){\\n            return ans;\\n        }\\n        vector<int> tmp;\\n        solve(k,n,tmp,ans,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774421,
                "title": "java-c-easy-to-understand-backtracking",
                "content": "# // \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<Integer> ans=new ArrayList();\\n        List<List<Integer>> res=new ArrayList();\\n        combin(k, n, 1, ans, res);\\n        return res;\\n        \\n    }\\n    public static void combin(int k, int n, int index, List<Integer> ans, List<List<Integer>> res)\\n    {\\n        if(k==0 && n==0)\\n        {\\n            res.add(new ArrayList(ans));\\n            return;\\n        }\\n        for(int i=index;i<10;i++)\\n        {\\n            ans.add(i);\\n            combin(k-1, n-i, i+1, ans, res);\\n            ans.remove(ans.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<Integer> ans=new ArrayList();\\n        List<List<Integer>> res=new ArrayList();\\n        combin(k, n, 1, ans, res);\\n        return res;\\n        \\n    }\\n    public static void combin(int k, int n, int index, List<Integer> ans, List<List<Integer>> res)\\n    {\\n        if(k==0 && n==0)\\n        {\\n            res.add(new ArrayList(ans));\\n            return;\\n        }\\n        for(int i=index;i<10;i++)\\n        {\\n            ans.add(i);\\n            combin(k-1, n-i, i+1, ans, res);\\n            ans.remove(ans.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637057,
                "title": "c-100-fast-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(vector<int> &ans,int j,int k,int n)\\n    {\\n        if(n==0 && k==0)\\n        {\\n            res.push_back(ans);\\n            return;         \\n        }\\n        if(k==0)return;\\n        for(int i=j;i<10;i++)\\n        {\\n            if(n>=i && k>0 )\\n            {\\n                ans.push_back(i);\\n                solve(ans,i+1,k-1,n-i);\\n                ans.pop_back();\\n                \\n            }\\n        \\n            \\n        }\\n        if(n!=0)\\n            return;\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n       \\n      \\n        vector<int> ans;\\n        solve(ans,1,k,n);\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> res;\\n    void solve(vector<int> &ans,int j,int k,int n)\\n    {\\n        if(n==0 && k==0)\\n        {\\n            res.push_back(ans);\\n            return;         \\n        }\\n        if(k==0)return;\\n        for(int i=j;i<10;i++)\\n        {\\n            if(n>=i && k>0 )\\n            {\\n                ans.push_back(i);\\n                solve(ans,i+1,k-1,n-i);\\n                ans.pop_back();\\n                \\n            }\\n        \\n            \\n        }\\n        if(n!=0)\\n            return;\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n       \\n      \\n        vector<int> ans;\\n        solve(ans,1,k,n);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2586629,
                "title": "javascript-backtracking-solution-59-ms",
                "content": "### Solution\\n```js\\n/**\\n * @param {number} k\\n * @param {number} n\\n * @return {number[][]}\\n */\\nconst backtrack = (remain, k,arr, next_start, results) => {\\n  if (remain === 0 && arr.length === k) {\\n        results.push(new Array(...arr));\\n        return;\\n  } else if (remain < 0 || arr.length === k) {\\n        return;\\n  }\\n\\n  // Iterate through the reduced list of candidates.\\n  for (let i = next_start; i < 9; ++i) {\\n        arr.push(i + 1);\\n        backtrack(remain - i - 1, k, arr, i + 1, results);\\n        arr.pop();\\n  }\\n}\\n\\nvar combinationSum3 = function(k, n) {\\n    let results = [];\\n    \\n    if (k > n) {\\n        return [];\\n    }\\n    \\n    backtrack(n, k, [], 0, results);\\n    return results;\\n};\\n```\\n\\n\\n### LeetCode Output\\nRuntime: **59 ms**, faster than **97.46%** of JavaScript online submissions for Combination Sum III.\\nMemory Usage: 41.9 MB, less than **82.79%** of JavaScript online submissions for Combination Sum III.\\n\\n[Link to Submission](https://leetcode.com/submissions/detail/801878999/)",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```js\\n/**\\n * @param {number} k\\n * @param {number} n\\n * @return {number[][]}\\n */\\nconst backtrack = (remain, k,arr, next_start, results) => {\\n  if (remain === 0 && arr.length === k) {\\n        results.push(new Array(...arr));\\n        return;\\n  } else if (remain < 0 || arr.length === k) {\\n        return;\\n  }\\n\\n  // Iterate through the reduced list of candidates.\\n  for (let i = next_start; i < 9; ++i) {\\n        arr.push(i + 1);\\n        backtrack(remain - i - 1, k, arr, i + 1, results);\\n        arr.pop();\\n  }\\n}\\n\\nvar combinationSum3 = function(k, n) {\\n    let results = [];\\n    \\n    if (k > n) {\\n        return [];\\n    }\\n    \\n    backtrack(n, k, [], 0, results);\\n    return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2523560,
                "title": "go-backtracking",
                "content": "```\\nfunc combinationSum3(k int, n int) [][]int {\\n    var result [][]int\\n    \\n    combination , visit:= make([]int, k), make([]bool, 10)\\n    \\n    var backtrack func(int, int)\\n    backtrack = func(index int, target int) {\\n        if target < 0 {\\n            return\\n        }\\n        \\n        if index == k {\\n            if target == 0 {\\n                copiedCombination := make([]int, k)\\n                copy(copiedCombination, combination)\\n                result = append(result, copiedCombination)\\n            } \\n            \\n            return\\n        }\\n        \\n        begin := 1\\n        \\n        if index > 0 {\\n            begin = combination[index-1] + 1\\n        }\\n        \\n        for num := begin; num <= 9; num++ {\\n            if visit[num] == false {\\n                visit[num] = true\\n                combination[index] = num\\n                backtrack(index + 1, target - num)\\n                visit[num] = false\\n            }\\n        }\\n    }\\n    \\n    backtrack(0, n)\\n    \\n    return result\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nfunc combinationSum3(k int, n int) [][]int {\\n    var result [][]int\\n    \\n    combination , visit:= make([]int, k), make([]bool, 10)\\n    \\n    var backtrack func(int, int)\\n    backtrack = func(index int, target int) {\\n        if target < 0 {\\n            return\\n        }\\n        \\n        if index == k {\\n            if target == 0 {\\n                copiedCombination := make([]int, k)\\n                copy(copiedCombination, combination)\\n                result = append(result, copiedCombination)\\n            } \\n            \\n            return\\n        }\\n        \\n        begin := 1\\n        \\n        if index > 0 {\\n            begin = combination[index-1] + 1\\n        }\\n        \\n        for num := begin; num <= 9; num++ {\\n            if visit[num] == false {\\n                visit[num] = true\\n                combination[index] = num\\n                backtrack(index + 1, target - num)\\n                visit[num] = false\\n            }\\n        }\\n    }\\n    \\n    backtrack(0, n)\\n    \\n    return result\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2026763,
                "title": "c-pick-not-pick-backtracking-dlc-may11",
                "content": "```\\nclass Solution {\\npublic:\\n    //PICK- NOT PICK (backtracking)\\n    \\n    vector<vector<int>> ans;\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> combination;\\n        helper(combination, 0, k, n, 0);\\n        return ans;\\n    }\\n    \\n    void helper(vector<int>& combi, int sum, int k, int n, int num){\\n        if(combi.size() >k || sum > n) return;\\n        \\n        if(combi.size()==k && sum==n)\\n            ans.push_back(combi);\\n        \\n        for(int i= num+1; i<=9; i++){\\n            combi.push_back(i);\\n            helper(combi, sum+i, k, n, ++num);\\n            combi.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //PICK- NOT PICK (backtracking)\\n    \\n    vector<vector<int>> ans;\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> combination;\\n        helper(combination, 0, k, n, 0);\\n        return ans;\\n    }\\n    \\n    void helper(vector<int>& combi, int sum, int k, int n, int num){\\n        if(combi.size() >k || sum > n) return;\\n        \\n        if(combi.size()==k && sum==n)\\n            ans.push_back(combi);\\n        \\n        for(int i= num+1; i<=9; i++){\\n            combi.push_back(i);\\n            helper(combi, sum+i, k, n, ++num);\\n            combi.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026270,
                "title": "short-clean-code-with-explanation-recursion",
                "content": "**If (n > 45)** : Suppose, we take k (*i.e. no of numbers*)  = 9 (*k\\'s max value*) and we are allowed to take one occurence of each number, then the maximum sum will 45. So, in any case, if n is given greater than 45, then it is not possible to give any answer.\\n\\n-----------------------------\\n\\n**Variables used :**\\n```vector<vector<int>> res;```            : to store the result whose sum will be equal to n\\n```vector<int> temp;```                       : to store every value on which we are iterating and comparing the sum with n\\n```int index = 0;```                               : to keep a check on the index of array arr[ ]\\n```int arr[9] = {1,2,3,4,5,6,7,8,9};```  : To iterate on the values\\n\\n-----------------------------\\n\\n**picknotpick( ) function :** \\nExample : k = 3 , n = 7 || Answer : [ [ 1, 2, 4 ] ]\\n\\nThere are two aspects. To choose that element or not to choose that element. And we are taking considering both the situations. \\nThis code is choosing / picking up the element.\\n```\\ntemp.push_back(arr[index]);\\nsum += arr[index];\\npicknotpick(arr, res, temp, k, n, index + 1, sum);\\n```\\nBelow, three lines of code are not choosing the element and skipping it.\\n```\\ntemp.pop_back();\\nsum -= arr[index];\\npicknotpick(arr, res, temp, k, n, index + 1, sum);\\n```\\n-----------------------\\n```if(index == 9) return;``` : is used to stop *index + 1* called in the functions throwing exception index out of bound.\\n\\n---------------------------\\n\\n**Complete code :**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        if(n > 45) return {};\\n        \\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        int index = 0;\\n        int arr[9] = {1,2,3,4,5,6,7,8,9};\\n        picknotpick(arr, res, temp, k, n, index, 0);\\n        return res;\\n    }\\n    void picknotpick(int arr[], vector<vector<int>> &res, vector<int> temp, int k, int n, int index, int sum)\\n    {\\n        if(temp.size() == k)\\n        {\\n            if(sum == n) res.push_back(temp);\\n            return;\\n        }\\n        if(index == 9) return;\\n        temp.push_back(arr[index]);\\n        sum += arr[index];\\n        picknotpick(arr, res, temp, k, n, index + 1, sum);\\n        \\n        temp.pop_back();\\n        sum -= arr[index];\\n        picknotpick(arr, res, temp, k, n, index + 1, sum);\\n    }\\n};\\n```\\n\\n*Dry run the code manually in a notebook for better understanding :)*",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```vector<vector<int>> res;```\n```vector<int> temp;```\n```int index = 0;```\n```int arr[9] = {1,2,3,4,5,6,7,8,9};```\n```\\ntemp.push_back(arr[index]);\\nsum += arr[index];\\npicknotpick(arr, res, temp, k, n, index + 1, sum);\\n```\n```\\ntemp.pop_back();\\nsum -= arr[index];\\npicknotpick(arr, res, temp, k, n, index + 1, sum);\\n```\n```if(index == 9) return;```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        if(n > 45) return {};\\n        \\n        vector<vector<int>> res;\\n        vector<int> temp;\\n        int index = 0;\\n        int arr[9] = {1,2,3,4,5,6,7,8,9};\\n        picknotpick(arr, res, temp, k, n, index, 0);\\n        return res;\\n    }\\n    void picknotpick(int arr[], vector<vector<int>> &res, vector<int> temp, int k, int n, int index, int sum)\\n    {\\n        if(temp.size() == k)\\n        {\\n            if(sum == n) res.push_back(temp);\\n            return;\\n        }\\n        if(index == 9) return;\\n        temp.push_back(arr[index]);\\n        sum += arr[index];\\n        picknotpick(arr, res, temp, k, n, index + 1, sum);\\n        \\n        temp.pop_back();\\n        sum -= arr[index];\\n        picknotpick(arr, res, temp, k, n, index + 1, sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025297,
                "title": "js-backtracking-i-m-so-awesome-i-learned-backtracking-how-cool-am-i-p",
                "content": "Faster than 94%\\n\\nSome backtracking points:\\n\\n- We need to step over all remaining numbers in a loop otherwise we will not try them (and we need to).\\n- We can end a branch early if length > k or sum > n\\n- We make an array from current to add it to results `[...cur]` so that this result snapshot does not get changed by subsequent push and pop calls.\\n- The backtracking steps are `return` and `cur.pop()`. Also the sum is implicitly correct because it is a recursion local variable at each recursive call (rather than a global which we would need to keep a stack of and calculate through addition). \\n\\nAll in all backtracking recursion is an elegant and fast solution for what is essentially a simple problem (if viewed correctly as a backtracking recursion), but what can be a subtle and complex problem if you think about it in general. \\n\\n**What is the time complexity?**\\n\\nIf you run the data for `k = 3, n = 24` (which will enumerate maximum possibilities as 24 is the max that can be created from 3 disctinct chosen from 1 - 9), you see there are 130 recursive calls.\\n\\nFrom this, and from the general structure of them (it seems it will check all possibilities of 0, 1, 2, and 3 length), we have the number of variations of a given length, `l`,  is `9 choose l`.\\n\\nSo we have the number of recursive calls is:\\n\\n`9 choose 0` + `9 choose 1` + `9 choose 2` + `9 choose 3` = 1 + 9 + 36 + 84. \\n\\nIn general if we assume that k can go up to 9, then we have sum(9 choose i) with i from 0 to 9, and m = 9. That is equal to 2^m. So the worst case is O(2^m). \\n\\nIn the specific case we created, the number of recursive calls exactly equals the sum of the (9 choose i) that we ranged over:  130. \\n\\n\\n\\n\\n\\n```\\n/**\\n * @param {number} k\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar combinationSum3 = function(k, n) {\\n  const s = [1,2,3,4,5,6,7,8,9];\\n  const results = [];\\n  \\n  recurse([], 0, 0);  \\n  \\n  return results;\\n  \\n  function recurse(cur, i, sum) {\\n    //console.log({cur, sum, k, n, i});\\n    if ( cur.length === k && sum === n ) {\\n      results.push([...cur]);\\n    } else {\\n      if ( sum > n || cur.length >= k ) {\\n        return;  \\n      } else {\\n        for( let j = i; j < s.length; j++ ) {\\n          cur.push(s[j]);\\n          recurse(cur, j+1, sum+s[j]);\\n          cur.pop();\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Combinatorics"
                ],
                "code": "```\\n/**\\n * @param {number} k\\n * @param {number} n\\n * @return {number[][]}\\n */\\nvar combinationSum3 = function(k, n) {\\n  const s = [1,2,3,4,5,6,7,8,9];\\n  const results = [];\\n  \\n  recurse([], 0, 0);  \\n  \\n  return results;\\n  \\n  function recurse(cur, i, sum) {\\n    //console.log({cur, sum, k, n, i});\\n    if ( cur.length === k && sum === n ) {\\n      results.push([...cur]);\\n    } else {\\n      if ( sum > n || cur.length >= k ) {\\n        return;  \\n      } else {\\n        for( let j = i; j < s.length; j++ ) {\\n          cur.push(s[j]);\\n          recurse(cur, j+1, sum+s[j]);\\n          cur.pop();\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2024994,
                "title": "java-simple-recursive-soln-0ms",
                "content": "Checking for all appropriate digits to be included in the ans, if it\\'s not the last digit of the ans list, then merging this digit with the list returned by the fututre calls for this particular digit and return the final list for this particular call.\\n\\nIf it\\'s the last digit (i.e. k == 1) and the digit is appropriate acc to the PS then just add this in a list of list of Integer and return else return empty list.\\n\\n\\'last fn var\\' is just keeping the value of last used digit for this particular fn call.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        return helper(n, k, 0);\\n    }\\n    \\n    public List<List<Integer>> helper(int n, int k, int last){\\n        List<List<Integer>> temp2 = new ArrayList<>();\\n        \\n        if(last >= n || (k == 1 && n >= 10)) return temp2;\\n        if(k == 1 && n > last){\\n            List<Integer> temp = new ArrayList<>();\\n            temp.add(n);\\n            temp2.add(temp);\\n            return temp2;\\n        }\\n        \\n        for(int i = last + 1; i < n && i < 10; i++){\\n            List<List<Integer>> curr = helper(n - i, k - 1, i);\\n            if(!curr.isEmpty()){\\n                for(List<Integer> ins : curr){\\n                    List<Integer> temp3 = new ArrayList<>();\\n                    temp3.add(i);\\n                    temp3.addAll(ins);\\n                    temp2.add(temp3);\\n                }\\n            }\\n        }\\n        \\n        return temp2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        return helper(n, k, 0);\\n    }\\n    \\n    public List<List<Integer>> helper(int n, int k, int last){\\n        List<List<Integer>> temp2 = new ArrayList<>();\\n        \\n        if(last >= n || (k == 1 && n >= 10)) return temp2;\\n        if(k == 1 && n > last){\\n            List<Integer> temp = new ArrayList<>();\\n            temp.add(n);\\n            temp2.add(temp);\\n            return temp2;\\n        }\\n        \\n        for(int i = last + 1; i < n && i < 10; i++){\\n            List<List<Integer>> curr = helper(n - i, k - 1, i);\\n            if(!curr.isEmpty()){\\n                for(List<Integer> ins : curr){\\n                    List<Integer> temp3 = new ArrayList<>();\\n                    temp3.add(i);\\n                    temp3.addAll(ins);\\n                    temp2.add(temp3);\\n                }\\n            }\\n        }\\n        \\n        return temp2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024991,
                "title": "easy-to-understand-backtracking-for-only-possible-cases-python",
                "content": "* Since the allowed numbers are 1 - 9 only and we can use a number atmost one time in a combination.\\n*  follwing the above condition, Max value of n can which can be obtained is 9*(9+1)/2 = 45, if n >45 we\\'ll return empty list.\\n * #####  For given value of k it possible to have combination if and only if  value of n is in between (k*(k+1))/2 ( i.e sum of first k elemets (1,2,...9) ) and (9 * (9+1))/2  -  ((9-k)* (9-k+1))/2 ( i.e sum of  last k elements in (1,2,3...9)  ), for such value of n and k we\\'ll use backtracking and all the possible combination.\\n * Other than above cases we\\'ll just return empty list.\\n \\n Python Code:\\n```\\nclass Solution:\\n    def solve(self,a,pos,k,n):\\n        if pos==k:\\n            if sum(a)==n:\\n                self.ans.append(a[:])\\n            return \\n        for i in range(a[-1]+1 if a else 1,10):\\n            a.append(i)\\n            self.solve(a,pos+1,k,n)\\n            a.pop()\\n            \\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        if n>45:\\n            return []\\n        if (k*(k+1))//2>n and (9*10)//2-((9-k)*(9-k+1))//2<n :\\n            return []\\n        self.ans=[]\\n        a=[]\\n        self.solve(a,0,k,n)\\n        return self.ans\\n```\\n\\n**Please Upvote, if you find it helpful :)**",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def solve(self,a,pos,k,n):\\n        if pos==k:\\n            if sum(a)==n:\\n                self.ans.append(a[:])\\n            return \\n        for i in range(a[-1]+1 if a else 1,10):\\n            a.append(i)\\n            self.solve(a,pos+1,k,n)\\n            a.pop()\\n            \\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        if n>45:\\n            return []\\n        if (k*(k+1))//2>n and (9*10)//2-((9-k)*(9-k+1))//2<n :\\n            return []\\n        self.ans=[]\\n        a=[]\\n        self.solve(a,0,k,n)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024775,
                "title": "java-classic-backtracking",
                "content": "```java\\npublic List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> combinations = new ArrayList<>();\\n        backtracking(combinations, new ArrayList<>(), k, n, 1);\\n        return combinations;\\n    }\\n\\n    private void backtracking(List<List<Integer>> result, List<Integer> current, int k, int n, int start) {\\n        if (current.size() == k && n == 0) {\\n            result.add(new ArrayList<>(current));\\n            return;\\n        }\\n\\n        for (int i = start; i <= 9; i++) {\\n            current.add(i);\\n            backtracking(result, current, k, n - i , i + 1);\\n            current.remove(current.size() - 1);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```java\\npublic List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> combinations = new ArrayList<>();\\n        backtracking(combinations, new ArrayList<>(), k, n, 1);\\n        return combinations;\\n    }\\n\\n    private void backtracking(List<List<Integer>> result, List<Integer> current, int k, int n, int start) {\\n        if (current.size() == k && n == 0) {\\n            result.add(new ArrayList<>(current));\\n            return;\\n        }\\n\\n        for (int i = start; i <= 9; i++) {\\n            current.add(i);\\n            backtracking(result, current, k, n - i , i + 1);\\n            current.remove(current.size() - 1);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2024223,
                "title": "c-iterative-and-recursive-approach-fastest-solution",
                "content": "To get all combinations, we can either write a recursive solution or iterative solution.\\n**Recursive Idea:** In the solution, there are three states - n, k and num.\\n* n : represents number which we have to make using the remaining k numbers from range num - 9. \\n* k : represents how many numbers currently we have to make n.\\n* num :  represents which numbers are available from this state and the available numbers from each state are **num to 9**.\\n\\n**Time Complexity:** 2^9\\n\\n**Recursive Approach:** \\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> temp;\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        if(k * 9 < n) return ans;\\n        solve(n, k, 1);\\n        return ans;\\n    }\\n    \\n    void solve(int n, int k, int num){\\n        if(n==0){\\n            if(k==0){\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n        \\n        if(k==0){\\n            return;\\n        }\\n        \\n        if(num == 10){\\n            return;\\n        }\\n        \\n        if(n - num >= 0){\\n            temp.push_back(num);\\n            solve(n - num, k - 1, num + 1);\\n            temp.pop_back();\\n        }\\n        solve(n, k, num + 1);\\n    }\\n};\\n```\\n\\n**Iterative Approach Using Bfs:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> temp;\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        if(k * 9 < n) return ans;\\n                \\n        queue<int> myq;\\n        myq.push(0);\\n        \\n        while(myq.size()){\\n            int u = myq.front();\\n            myq.pop();\\n            \\n            int val = 0, cur = 0, cnt  = 0;\\n            temp.clear();\\n            for(int i = 1; i <= 9; i++){\\n                if(u & (1<<(i-1))){\\n                    val = i;\\n                    temp.push_back(i);\\n                    cur += i;\\n                    cnt++;\\n                }\\n            }\\n            \\n            if(cnt == k){\\n                if(cur == n){\\n                    ans.push_back(temp);\\n                }\\n                continue;\\n            }\\n            \\n            for(int i=val + 1;i<10;i++){\\n                if(cur + i <= n){\\n                    myq.push( (u | (1 << (i-1))) );\\n                } \\n                else{\\n                    break;\\n                }\\n            }           \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> temp;\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        if(k * 9 < n) return ans;\\n        solve(n, k, 1);\\n        return ans;\\n    }\\n    \\n    void solve(int n, int k, int num){\\n        if(n==0){\\n            if(k==0){\\n                ans.push_back(temp);\\n            }\\n            return;\\n        }\\n        \\n        if(k==0){\\n            return;\\n        }\\n        \\n        if(num == 10){\\n            return;\\n        }\\n        \\n        if(n - num >= 0){\\n            temp.push_back(num);\\n            solve(n - num, k - 1, num + 1);\\n            temp.pop_back();\\n        }\\n        solve(n, k, num + 1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> temp;\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        if(k * 9 < n) return ans;\\n                \\n        queue<int> myq;\\n        myq.push(0);\\n        \\n        while(myq.size()){\\n            int u = myq.front();\\n            myq.pop();\\n            \\n            int val = 0, cur = 0, cnt  = 0;\\n            temp.clear();\\n            for(int i = 1; i <= 9; i++){\\n                if(u & (1<<(i-1))){\\n                    val = i;\\n                    temp.push_back(i);\\n                    cur += i;\\n                    cnt++;\\n                }\\n            }\\n            \\n            if(cnt == k){\\n                if(cur == n){\\n                    ans.push_back(temp);\\n                }\\n                continue;\\n            }\\n            \\n            for(int i=val + 1;i<10;i++){\\n                if(cur + i <= n){\\n                    myq.push( (u | (1 << (i-1))) );\\n                } \\n                else{\\n                    break;\\n                }\\n            }           \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024165,
                "title": "easy-runtime-0-ms-faster-than-100-00-eexplnation",
                "content": "this queston is similar to combination question\\nin this question we use backtracking to solve all the possible value\\n then we 1st check combination  for example\\n--> k=3,n=7\\n-->ist combination 1 less the value from k-1 and n-i\\n--> 2nd 2 then 1,2  k-1 and n-i;\\n-->3rd chosse 3 but not  sum 1+2+3==n so pop the last value \\n-->4 choose 1,2,4 then sum 1+2+4==n and value of k==0 \\nhence return the 1,2,4 \\n\\n```\\nclass Solution {\\npublic:\\n  void solve(int s,int k,int n,vector<int> &v,vector<vector<int>> &ans)\\n    {\\n        if(k<=0)\\n        {\\n            if(n==0) ans.push_back(v);\\n            return;\\n        }\\n        \\n        for(int i=s;i<=9;i++)    \\n        {\\n            v.push_back(i);\\n            solve(i+1,k-1,n-i,v,ans);\\n            v.pop_back();\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) \\n    {\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        solve(1,k,n,v,ans);\\n        return ans;\\n    \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n  void solve(int s,int k,int n,vector<int> &v,vector<vector<int>> &ans)\\n    {\\n        if(k<=0)\\n        {\\n            if(n==0) ans.push_back(v);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2024116,
                "title": "python-backtracking",
                "content": "```\\nclass Solution(object):\\n    def combinationSum3(self, k, n):\\n        ans = []\\n\\t\\t\\n\\t\\t# s = start of iteration - to avoid repetitions\\n\\t\\t# tmp - temp list holding possible combination\\n\\t\\t# l - keep track of length of tmp\\n        def rec(k, n, s, tmp, l):\\n            if l == k:\\n                # return True to break out of loop\\n\\t\\t\\t\\t# we can\\'t get another answer from combination from here\\n\\t\\t\\t\\t# only combinations with sum greater than n\\n                if sum(tmp) == n:\\n                    ans.append(tmp)\\n                    return True\\n                return False\\n           \\n            for i in range(s, 10):\\n                if rec(k, n, i+1, tmp+[i], l+1):\\n                    break\\n\\t\\t\\t\\t\\t\\n        rec(k, n, 1, [], 0)\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def combinationSum3(self, k, n):\\n        ans = []\\n\\t\\t\\n\\t\\t# s = start of iteration - to avoid repetitions\\n\\t\\t# tmp - temp list holding possible combination\\n\\t\\t# l - keep track of length of tmp\\n        def rec(k, n, s, tmp, l):\\n            if l == k:\\n                # return True to break out of loop\\n\\t\\t\\t\\t# we can\\'t get another answer from combination from here\\n\\t\\t\\t\\t# only combinations with sum greater than n\\n                if sum(tmp) == n:\\n                    ans.append(tmp)\\n                    return True\\n                return False\\n           \\n            for i in range(s, 10):\\n                if rec(k, n, i+1, tmp+[i], l+1):\\n                    break\\n\\t\\t\\t\\t\\t\\n        rec(k, n, 1, [], 0)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1557855,
                "title": "c-0ms-faster-than-100-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> res;\\n    \\n    void helper(vector<int> a ,int beg ,int t, int k)\\n    {\\n         if(t<=0)\\n        {\\n            if(t == 0 && k == 0)\\n        {\\n            res.push_back(a);\\n        }\\n            return;\\n    }\\n        \\n            \\n        for(int index = beg ; index <= 9 ; index++ )\\n        {\\n            if(index <= t)\\n            { \\n                a.push_back(index);\\n                helper(a , index + 1 , t - index , k - 1);\\n                a.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> a;\\n        helper(a,1,n,k);\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> res;\\n    \\n    void helper(vector<int> a ,int beg ,int t, int k)\\n    {\\n         if(t<=0)\\n        {\\n            if(t == 0 && k == 0)\\n        {\\n            res.push_back(a);\\n        }\\n            return;\\n    }\\n        \\n            \\n        for(int index = beg ; index <= 9 ; index++ )\\n        {\\n            if(index <= t)\\n            { \\n                a.push_back(index);\\n                helper(a , index + 1 , t - index , k - 1);\\n                a.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> a;\\n        helper(a,1,n,k);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843765,
                "title": "c-dfs-based-solution-100-time-75-space",
                "content": "I decided I wanted to build this as a DFS since I read the description and the first results I got from the template solution when I ran the first version of my code confirmed my mind in that direction.\\n\\nFirst of all I declared 4 class variables, in order not to have to pass them down to the recursive calls to my `dfs` helper:\\n* `res`, the accumulator storing the final result;\\n* `tmp`, the vector storing the possible solution as I go along to build them;\\n* `k` and `n` to keep track of what we have done so far with the recursive calls.\\n\\nIn my `dfs` helper I then set the need for only one variable (I know, I might have made a class variable out of it, but that is how I felt), `start`, that decides from which number we should start computing the remaining combinations.\\n\\nSay for example I need to find all the solutions summing up to `7` (`n`) using `3` (`k`) digits: I will start with `1` and progress on, with the problem now being getting up to `6` using `2` (more) digits, starting from `2` (in order to avoid duplicate solution, I will always consider numbers higher than the last one I pushed). And so on.\\n\\nIn order to achieve that, my `dfs` helper has first of all a base case: when `k` is down to `1`, it means we only have one digit left to push: if `n` (or rather: what is left of the original number we were provided, minus all the other numbers already added to `tmp`) is a single digit (`n < 10`) number, then we add it to `tmp`, add `tmp` to `res` and finally clean up, backtracking on `tmp` (ie: removing that last element we just added).\\n\\nOtherwise, and this is the core of the logic, we proceed to decrease `k`, create a `for` loop starting at `start + 1` (for the reason I mentioned above, so to have all the digits only once, in increasing order) and looping up to `lmt`, the minimum value we can still get, aptly set so that it will only equal the maximum amount you can still create with the digits left. I will not go too deep with the math, but it is basically just Gauss\\' formula with the previous value of `k`, considered from the starting point `start` we are at this loop.\\n\\nSay for example we begin the function with `k == 3` (initial value, that we decrease right before the loop, that is why the formula has increased values) and `start == 0`, then `lmt` is going to be `6` (`1 + 2 + 3` is the minimum value we can still get summing those numbers); if we entered the function with `k == 5` and `start == 2`, then we would have `20` (`2 + 3 + 4 + 5 + 6`).\\n\\nIf it still does not make sense, try with some pen and paper, but it works and we want to loop until `n >= lmt` (it would not make much sense otherwise: it would mean we cannot achieve `n` summing up all the digits left).\\n\\nNow, inside our loop we do a few things:\\n* update `n` and `tmp` before recursively calling `dfs` to it (remember we decrease `k` only once, before the loop);\\n* recursively calling `dfs` passing `i` (which will become our next `start`);\\n* backtracking `n` and `tmp`, restoring them to their previous values when the recursive calls are done;\\n* increasing `lmt`, since greater values of `i` also reduce how much we can still milk out of our remaining digits, by an amount `== k + 1`.\\n\\nFinally, before leaving `dfs`, we just backtrack on `k`.\\n\\nThe main function is going to be much more streamlined, since we just:\\n* update the class variables `n` and `k` with the provided initial values;\\n* call `dfs`, but only if it make sense - we are requested no more than `9` digits and it is a number that can actually be reached with all of them (the sum of all the first `9` positive digits is `45`;\\n* once we are done, we just have to return our lovely filled `res`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // support variables\\n    vector<vector<int>> res;\\n    vector<int> tmp;\\n    int k, n;\\n    // dfs generator\\n    void dfs(int start = 0) {\\n        // base case, only the last element potentially missing\\n        if (k == 1) {\\n            // allowing only for single digit insertions\\n            if (n < 10) {\\n                tmp.push_back(n);\\n                res.push_back(tmp);\\n                tmp.pop_back();\\n            }\\n            return;\\n        }\\n        // updating k\\n        k--;\\n        for (int i = start + 1, lmt = (k + 2) * (k + 1) / 2 + start * (k + 1); n >= lmt; i++) {\\n            // updating n and tmp\\n            n -= i;\\n            tmp.push_back(i);\\n            dfs(i);\\n            // backtracking n and tmp\\n            n += i;\\n            tmp.pop_back();\\n            lmt += k + 1;\\n        }\\n        // backtracking k\\n        k++;\\n    }\\n    vector<vector<int>> combinationSum3(int _k, int _n) {\\n        k = _k;\\n        n = _n;\\n        // we proceed only if k < 10 and n is achievable with just 9 digits\\n        if (k < 10 && n < 46) dfs();\\n        return res;\\n    }\\n};\\n```\\n\\n[More informative discussion down below about optimisation opportunities by @cleydyr](https://leetcode.com/problems/combination-sum-iii/discuss/843765/c-dfs-based-solution-100-time-75-space/696363).",
                "solutionTags": [
                    "C++",
                    "C",
                    "Combinatorics"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // support variables\\n    vector<vector<int>> res;\\n    vector<int> tmp;\\n    int k, n;\\n    // dfs generator\\n    void dfs(int start = 0) {\\n        // base case, only the last element potentially missing\\n        if (k == 1) {\\n            // allowing only for single digit insertions\\n            if (n < 10) {\\n                tmp.push_back(n);\\n                res.push_back(tmp);\\n                tmp.pop_back();\\n            }\\n            return;\\n        }\\n        // updating k\\n        k--;\\n        for (int i = start + 1, lmt = (k + 2) * (k + 1) / 2 + start * (k + 1); n >= lmt; i++) {\\n            // updating n and tmp\\n            n -= i;\\n            tmp.push_back(i);\\n            dfs(i);\\n            // backtracking n and tmp\\n            n += i;\\n            tmp.pop_back();\\n            lmt += k + 1;\\n        }\\n        // backtracking k\\n        k++;\\n    }\\n    vector<vector<int>> combinationSum3(int _k, int _n) {\\n        k = _k;\\n        n = _n;\\n        // we proceed only if k < 10 and n is achievable with just 9 digits\\n        if (k < 10 && n < 46) dfs();\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843373,
                "title": "python-super-simple-solution",
                "content": "the idea is to choose from all combinations of length k only the combinations which their sum is n\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n         return [list for list in itertools.combinations(range(1, 10), k) if sum(list) == n]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n         return [list for list in itertools.combinations(range(1, 10), k) if sum(list) == n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842908,
                "title": "512-iterations-bit-manipulation-non-backtracking",
                "content": "Let iterate all possible combinations from set {1, 2, 3, 4, 5, 6, 7, 8, 9} using bitmask.\\nFor example:\\n```\\nall digits: 1, 2, 3, 4, 5, 6, 7, 8, 9\\nmask:       0  0  1  0  0  1  0  0  0 -> this mask gives us subset {3, 6}\\n```\\nDuring each iteration we should count \"1\" bits in mask (should be **k**, skip mask if not) and should ckeck sum of subset values (should be **n**).\\nThis solution has exactly 2^9 iterations and generally speaking it has O(1) time complexity ;)\\n\\nJava\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        var result = new ArrayList<List<Integer>>();\\n\\n        int bits = 0x0200;\\n        var a = new Integer[k];\\n        while (--bits > 0) {\\n            if (countBits(bits) != k) continue;\\n\\n            int sum = 0;\\n            int w = 0;\\n            for (int i = 9; i >= 1 && sum <= n; i--) {\\n                if ((bits & (1 << i-1)) != 0) {\\n                    sum += i;\\n                    a[w++] = i;\\n                }\\n            }\\n\\n            if (sum == n) {\\n                result.add(Arrays.asList(a));\\n                a = new Integer[k];\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private int countBits(int x) {\\n        int count = 0;\\n        while (x > 0) {\\n            x &= x - 1;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nC#\\n```\\npublic class Solution\\n{\\n    public IList<IList<int>> CombinationSum3(int k, int n)\\n    {\\n        var result = new List<IList<int>>();\\n        \\n        int bits = 0x0200;\\n        var a = new int[k];\\n        while(--bits > 0)\\n        {\\n            if(CountBits(bits) != k) continue;\\n\\n            int sum = 0;\\n            int w = 0;\\n            for(int i=9; i>=1 && sum<=n; i--)\\n            {\\n                if((bits & (1<<(i-1))) != 0)\\n                {\\n                    sum += i;\\n                    a[w++] = i;\\n                }\\n            }\\n            \\n            if(sum == n)\\n            {\\n                result.Add(a);\\n                a = new int[k];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int CountBits(int x)\\n    {\\n        int count = 0;\\n        while(x > 0)\\n        {\\n            x &= x - 1;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nall digits: 1, 2, 3, 4, 5, 6, 7, 8, 9\\nmask:       0  0  1  0  0  1  0  0  0 -> this mask gives us subset {3, 6}\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        var result = new ArrayList<List<Integer>>();\\n\\n        int bits = 0x0200;\\n        var a = new Integer[k];\\n        while (--bits > 0) {\\n            if (countBits(bits) != k) continue;\\n\\n            int sum = 0;\\n            int w = 0;\\n            for (int i = 9; i >= 1 && sum <= n; i--) {\\n                if ((bits & (1 << i-1)) != 0) {\\n                    sum += i;\\n                    a[w++] = i;\\n                }\\n            }\\n\\n            if (sum == n) {\\n                result.add(Arrays.asList(a));\\n                a = new Integer[k];\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private int countBits(int x) {\\n        int count = 0;\\n        while (x > 0) {\\n            x &= x - 1;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\npublic class Solution\\n{\\n    public IList<IList<int>> CombinationSum3(int k, int n)\\n    {\\n        var result = new List<IList<int>>();\\n        \\n        int bits = 0x0200;\\n        var a = new int[k];\\n        while(--bits > 0)\\n        {\\n            if(CountBits(bits) != k) continue;\\n\\n            int sum = 0;\\n            int w = 0;\\n            for(int i=9; i>=1 && sum<=n; i--)\\n            {\\n                if((bits & (1<<(i-1))) != 0)\\n                {\\n                    sum += i;\\n                    a[w++] = i;\\n                }\\n            }\\n            \\n            if(sum == n)\\n            {\\n                result.Add(a);\\n                a = new int[k];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int CountBits(int x)\\n    {\\n        int count = 0;\\n        while(x > 0)\\n        {\\n            x &= x - 1;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777779,
                "title": "c-easy-solution-using-backtracking-template-for-all-combination-sum-problems",
                "content": "**Combination Sum**\\nNotice in this question that repetition is allowed . That is the reason we pass j as it is in this call combination(ans,sub,target-candidates[j],j,candidates).\\n```\\nclass Solution {\\npublic:\\n    void combination(vector<vector<int>>&ans,vector<int>&sub,int target,int i,vector<int>&candidates){\\n        if(target==0){\\n            ans.push_back(sub);\\n            return;\\n        }\\n        for(int j=i;j<candidates.size();j++){\\n            if(target-candidates[j]>=0){\\n                sub.push_back(candidates[j]);\\n                combination(ans,sub,target-candidates[j],j,candidates);\\n                sub.pop_back();\\n            }\\n                \\n            \\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        \\n        vector<int> sub;\\n        combination(ans,sub,target,0,candidates);\\n        return ans;\\n    }\\n};\\n```\\n**Combination Sum II**\\nSimilar to the previous one we just we have to prevent the recursion calls from the duplicate ones.To prevent duplicates we use condition if(j>i && candidates[j]==candidates[j-1]) And also one element can be used only once that is why i have used j+1 in this call combination(ans,sub,target-candidates[j],j+1,candidates).\\n```\\nclass Solution {\\npublic:\\n    void combination(vector<vector<int>>&ans,vector<int>&sub,int target,int i,vector<int>&candidates){\\n        if(target==0){\\n            ans.push_back(sub);\\n            return;\\n        }\\n        for(int j=i;j<candidates.size();j++){\\n            if(j>i && candidates[j]==candidates[j-1])continue;\\n            if(target-candidates[j]>=0){\\n                sub.push_back(candidates[j]);\\n                combination(ans,sub,target-candidates[j],j+1,candidates);\\n                sub.pop_back();\\n            }\\n                \\n            \\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        sort(candidates.begin(),candidates.end());\\n        vector<int> sub;\\n        combination(ans,sub,target,0,candidates);\\n        return ans;\\n    }\\n};\\n```\\n**Combination Sum |||**\\nSame as combination II only difference being here there are no duplicates.So we don\\'t need to keep a check for it.\\n```\\nclass Solution {\\npublic:\\n    void combination(vector<vector<int>>&ans,vector<int>&sub,int target,int i,vector<int>&candidates,int k){\\n        if(target==0 && sub.size()==k){\\n            ans.push_back(sub);\\n            return;\\n        }\\n        for(int j=i;j<candidates.size();j++){\\n            if(target-candidates[j]>=0){\\n                sub.push_back(candidates[j]);\\n                combination(ans,sub,target-candidates[j],j+1,candidates,k);\\n                sub.pop_back();\\n            }\\n                \\n            \\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> candidates;\\n        for(int i=1;i<=9;i++){\\n            candidates.push_back(i);\\n        }\\n        vector<vector<int>> ans;\\n        \\n        vector<int> sub;\\n        combination(ans,sub,n,0,candidates,k);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void combination(vector<vector<int>>&ans,vector<int>&sub,int target,int i,vector<int>&candidates){\\n        if(target==0){\\n            ans.push_back(sub);\\n            return;\\n        }\\n        for(int j=i;j<candidates.size();j++){\\n            if(target-candidates[j]>=0){\\n                sub.push_back(candidates[j]);\\n                combination(ans,sub,target-candidates[j],j,candidates);\\n                sub.pop_back();\\n            }\\n                \\n            \\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        \\n        vector<int> sub;\\n        combination(ans,sub,target,0,candidates);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void combination(vector<vector<int>>&ans,vector<int>&sub,int target,int i,vector<int>&candidates){\\n        if(target==0){\\n            ans.push_back(sub);\\n            return;\\n        }\\n        for(int j=i;j<candidates.size();j++){\\n            if(j>i && candidates[j]==candidates[j-1])continue;\\n            if(target-candidates[j]>=0){\\n                sub.push_back(candidates[j]);\\n                combination(ans,sub,target-candidates[j],j+1,candidates);\\n                sub.pop_back();\\n            }\\n                \\n            \\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\\n        vector<vector<int>> ans;\\n        sort(candidates.begin(),candidates.end());\\n        vector<int> sub;\\n        combination(ans,sub,target,0,candidates);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void combination(vector<vector<int>>&ans,vector<int>&sub,int target,int i,vector<int>&candidates,int k){\\n        if(target==0 && sub.size()==k){\\n            ans.push_back(sub);\\n            return;\\n        }\\n        for(int j=i;j<candidates.size();j++){\\n            if(target-candidates[j]>=0){\\n                sub.push_back(candidates[j]);\\n                combination(ans,sub,target-candidates[j],j+1,candidates,k);\\n                sub.pop_back();\\n            }\\n                \\n            \\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> candidates;\\n        for(int i=1;i<=9;i++){\\n            candidates.push_back(i);\\n        }\\n        vector<vector<int>> ans;\\n        \\n        vector<int> sub;\\n        combination(ans,sub,n,0,candidates,k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519489,
                "title": "0ms-java-code-using-backtracking",
                "content": "public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        backTracking(res, new ArrayList<>(), k, n, 1);\\n        return res;\\n    }\\n    \\n    private void backTracking(List<List<Integer>> res, List<Integer> temp, int k, int target, int start) {\\n        if (target < 0 || temp.size() > k) return;\\n        if (target == 0 && temp.size() == k) {\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        for (int i = start; i < 10; i++) {\\n            temp.add(i);\\n            backTracking(res, temp, k, target - i, i + 1);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        backTracking(res, new ArrayList<>(), k, n, 1);\\n        return res;\\n    }\\n    \\n    private void backTracking(List<List<Integer>> res, List<Integer> temp, int k, int target, int start) {\\n        if (target < 0 || temp.size() > k) return;\\n        if (target == 0 && temp.size() == k) {\\n            res.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        for (int i = start; i < 10; i++) {\\n            temp.add(i);\\n            backTracking(res, temp, k, target - i, i + 1);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 381306,
                "title": "ruby-1-liner",
                "content": "```\\ndef combination_sum3(k, n)\\n  (1..9).to_a.combination(k).select { |nums| nums.sum == n }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef combination_sum3(k, n)\\n  (1..9).to_a.combination(k).select { |nums| nums.sum == n }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 60698,
                "title": "4-problems-1-solution-java-solutions-for-combinations-combination-sum1-combination-sum2-combination-sum3",
                "content": "**Combinations**\\n\\n```\\npublic List<List<Integer>> combine(int n, int k) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, \\nList<List<Integer>> result) {\\n\\t\\tif(k == curPath.size()) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= n; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\\n\\n**CombinationSum1**\\n\\n\\n```\\n    public static List<List<Integer>> combinationSum(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\\n\\n**CombinationSum2**\\n\\n```\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t    if (i > start && nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```\\n\\n**CombinationSum3**\\n\\n```\\n\\n    public static List<List<Integer>> combinationSum3(int k, int n) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(k == curPath.size() && n == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= 9; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n - i, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic List<List<Integer>> combine(int n, int k) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, \\nList<List<Integer>> result) {\\n\\t\\tif(k == curPath.size()) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= n; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\n```\\n    public static List<List<Integer>> combinationSum(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n```\n```\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(nums == null || nums.length == 0) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tArrays.sort(nums);\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(nums, target, curPath, 0, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int[] nums, int target, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(target == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(target < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i < nums.length; ++i) {\\n\\t\\t    if (i > start && nums[i] == nums[i-1]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\tcurPath.add(nums[i]);\\n\\t\\t\\tdfs(nums, target - nums[i], curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```\n```\\n\\n    public static List<List<Integer>> combinationSum3(int k, int n) {\\n\\t\\tList<List<Integer>> result = new ArrayList<>();\\n\\t\\tif(n < 1 || k < 1 || k > n) {\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\tList<Integer> curPath = new ArrayList<>();\\n\\t\\tdfs(n, k, curPath, 1, result);\\n\\t\\treturn result;\\n\\t}\\n\\n\\tpublic static void dfs(int n, int k, List<Integer> curPath, int start, List<List<Integer>> result) {\\n\\t\\tif(k == curPath.size() && n == 0) {\\n\\t\\t\\tresult.add(new ArrayList<Integer>(curPath));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif(n < 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tfor(int i = start; i <= 9; ++i) {\\n\\t\\t\\tcurPath.add(i);\\n\\t\\t\\tdfs(n - i, k, curPath, i+1, result);\\n\\t\\t\\tcurPath.remove(curPath.size() - 1);\\n\\t\\t}\\n\\t}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 60792,
                "title": "share-my-python-solution-with-iterative-backtracking",
                "content": "    class Solution:\\n    # @param {integer} k\\n    # @param {integer} n\\n    # @return {integer[][]}\\n    def combinationSum3(self, k, n):\\n        # Iterative backtracking: AC in 60 ms\\n        # -----------------------------------\\n        #\\n        ans = []\\n        stack = [(0, 1, [])]  # (total, start, combination)\\n        while stack:\\n            total, start, comb = stack.pop()\\n            if total == n and len(comb) == k:\\n                ans.append(comb)\\n                continue\\n\\n            for i in range(start, 10):\\n                tmp_total = total + i\\n                if tmp_total > n:\\n                    break\\n                stack.append((tmp_total, i + 1, comb + [i]))\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    # @param {integer}",
                "codeTag": "Java"
            },
            {
                "id": 60825,
                "title": "accepted-c-solution-standard-backtracking",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int>> combinationSum3(int k, int n) {\\n        \\tvector<vector<int>> ret;\\n        \\tvector<int> partial;\\n        \\n        \\tbackTrackingFun(n,k,1,partial,ret);\\n        \\treturn ret;\\n        }\\n        \\n        void backTrackingFun(int n,int k,int idx,vector<int> partial,vector<vector<int>> &ret){\\n        \\tif(1==k){\\n        \\t\\tif(idx<=n && n<10){\\n        \\t\\t\\tpartial.push_back(n);\\n        \\t\\t\\tret.push_back(partial);\\n        \\t\\t}\\n        \\t\\treturn;\\n        \\t}\\n        \\n        \\tfor(auto i=idx;i<10;++i){\\n        \\t\\tif(i<n){\\n        \\t\\t\\tpartial.push_back(i);\\n        \\t\\t\\tbackTrackingFun(n-i,k-1,i+1,partial,ret);\\n        \\t\\t\\tpartial.pop_back();\\n        \\t\\t}else{\\n        \\t\\t\\tbreak;\\n        \\t\\t}\\n        \\t}\\n        }\\n    };\\n\\nwell, there is not too much to say.it's not tricky at all.\\n\\n----------\\ncombinationSum2 and combinationSum below.\\ncontent of the caller function is the same only backTrackingFun is different.\\n\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\\n    \\tvector<vector<int>> ret;\\n    \\tvector<int> partial;\\n    \\tsort(candidates.begin(),candidates.end());\\n    \\tbackTrackingFun(candidates,target,0,partial,ret);\\n    \\n    \\treturn ret;\\n    }\\n\\n\\n----------\\n\\ncombinationSum2\\n\\n    void backTrackingFun(const vector<int>& candidates, int target,int idx,vector<int> partial,vector<vector<int>> &ret){\\n    \\tif(0==target){\\n    \\t\\tret.push_back(partial);\\n    \\t\\treturn;\\n    \\t}\\n    \\n    \\tint size=candidates.size();\\n    \\tfor(auto i=idx;i<size;++i){\\n    \\t\\tint v=candidates[i];\\n    \\t\\t// remove dups\\n    \\t\\tif(i>idx && v==candidates[i-1]) continue;\\n    \\n    \\t\\tif(v<=target){\\n    \\t\\t\\tpartial.push_back(v);\\n    \\t\\t\\tbackTrackingFun(candidates,target-v,i+1,partial,ret);\\n    \\t\\t\\tpartial.pop_back();\\n    \\t\\t}else{\\n    \\t\\t\\tbreak;\\n    \\t\\t}\\n    \\t}\\n    }\\n\\ncombinationSum\\n\\n    void backTrackingFun(const vector<int>& candidates, int target,int idx,vector<int> partial,vector<vector<int>> &ret){\\n    \\tif(0==target){\\n    \\t\\tret.push_back(partial);\\n    \\t\\treturn;\\n    \\t}\\n    \\n    \\tint size=candidates.size();\\n    \\tfor(auto i=idx;i<size;++i){\\n    \\t\\tint v=candidates.at(i);\\n    \\t\\tif(v<=target){\\n    \\t\\t\\tpartial.push_back(v);\\n    \\t\\t\\tbackTrackingFun(candidates,target-v,i,partial,ret);\\n    \\t\\t\\tpartial.pop_back();\\n    \\t\\t}else{\\n    \\t\\t\\tbreak;\\n    \\t\\t}\\n    \\t}\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> combinationSum3(int k, int n) {\\n        \\tvector<vector<int>> ret;\\n        \\tvector<int> partial;\\n        \\n        \\tbackTrackingFun(n,k,1,partial,ret);\\n        \\treturn ret;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3876134,
                "title": "simple-code-backtracking-beats-100",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nTo solve this problem, we can use a recursive backtracking approach. Here\\'s a step-by-step explanation of the approach:\\n\\nInitialize necessary variables and arrays.\\nCall the main recursive function to find all valid combinations.\\nThe recursive function does the following:\\nBase Case: If the current index is equal to the array length, it means we have considered all numbers. At this point, we check if the size of the current combination is equal to k and if the target sum is 0 (indicating that we have found a valid combination that sums up to n). If both conditions are met, we add the current combination to the final answer.\\nPick: Add the current number to the current combination, decrease the target sum by the value of the current number, and recursively call the function with the updated values and move to the next index.\\nNot Pick: Remove the last element from the current combination (backtrack) to try the next number and call the function with the same index value but without including the current number. This helps explore other possible combinations.\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        int [] arr=new int[]{1,2,3,4,5,6,7,8,9};\\n        List<List<Integer>> ans=new ArrayList<>();\\n        List<Integer> ds=new ArrayList<>();\\n        func(0,k,n,ds,arr,ans);\\n        return ans;\\n    }\\n\\n    public void func(int idx,int len,int target,List<Integer> ds,\\n                     int [] arr,List<List<Integer>> ans)\\n    {\\n        if(idx==arr.length){\\n            if(ds.size()==len && target==0) ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        ds.add(arr[idx]);\\n        func(idx+1,len,target-arr[idx],ds,arr,ans);\\n        ds.remove(ds.size()-1);\\n        func(idx+1,len,target,ds,arr,ans);\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        int [] arr=new int[]{1,2,3,4,5,6,7,8,9};\\n        List<List<Integer>> ans=new ArrayList<>();\\n        List<Integer> ds=new ArrayList<>();\\n        func(0,k,n,ds,arr,ans);\\n        return ans;\\n    }\\n\\n    public void func(int idx,int len,int target,List<Integer> ds,\\n                     int [] arr,List<List<Integer>> ans)\\n    {\\n        if(idx==arr.length){\\n            if(ds.size()==len && target==0) ans.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        ds.add(arr[idx]);\\n        func(idx+1,len,target-arr[idx],ds,arr,ans);\\n        ds.remove(ds.size()-1);\\n        func(idx+1,len,target,ds,arr,ans);\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875751,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> val;\\n    int nl, kl;\\n\\n    void solve(vector<int> &arr, int id, int target) {\\n        if(target < 0) return;\\n        if(target == 0) {\\n            if(arr.size() == kl) ans.push_back(arr);\\n            return;\\n        }\\n        for(int i = id; i < nl; i++) {\\n            arr.push_back(val[i]);\\n            solve(arr, i + 1, target - val[i]);\\n            arr.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        nl = 9, kl = k;\\n        for (int i = 1; i <= 9; i++) val.push_back(i);\\n        vector<int> arr;\\n        solve(arr, 0, n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    vector<int> val;\\n    int nl, kl;\\n\\n    void solve(vector<int> &arr, int id, int target) {\\n        if(target < 0) return;\\n        if(target == 0) {\\n            if(arr.size() == kl) ans.push_back(arr);\\n            return;\\n        }\\n        for(int i = id; i < nl; i++) {\\n            arr.push_back(val[i]);\\n            solve(arr, i + 1, target - val[i]);\\n            arr.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        nl = 9, kl = k;\\n        for (int i = 1; i <= 9; i++) val.push_back(i);\\n        vector<int> arr;\\n        solve(arr, 0, n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764696,
                "title": "beats-100-time-and-99-space-fast-solution-easiest-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic Backtracking\\n![image.png](https://assets.leetcode.com/users/images/13231a36-2935-4efc-88b6-0d7b5b1c2d8c_1689346156.2213929.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create 2 lists, one for the result and another for tracking current.\\n2. Create generate function for generating the list, accepting result list, current list, no of elements more required, required sum using current no of elements, and start element.\\n3. Generate checks if required element is 1 and required sum lies between start and n, if so add that to the current list and insert the list into result and remove the added element from the current list;\\n4. If the condition fails, generate starts a loop i = start till 9, and checks if the i is within n and n - i (new sum required) is greater than i (not taking the smaller elements under consideration).\\n5. If so, it add the element to the list and calls generate function again with k - 1 no of elements required to form n - i sum.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIn the worst case, the code will generate all possible valid combinations of \\'k\\' numbers from 1 to 9. The number of valid combinations is given by the binomial coefficient formula: C(9, k), which is n! / (k! * (n-k)!).\\n\\nTherefore, the time complexity of the code is **O(C(9, k))**.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe maximum depth of recursion is \\'k\\'. Hence, the space complexity for recursion is **O(k)**.\\n\\n# Code\\n```\\nclass Solution {\\n    public static void generate(List<List<Integer>> result, List<Integer> list, int k, int n, int start) {\\n        if(k == 1 && start <= n && n <= 9) {\\n            list.add(n);\\n            result.add(new ArrayList<>(list));\\n            list.remove(Integer.valueOf(n));\\n            return;\\n        }\\n        for(int i = start; i <= 9; i++) {\\n            if(i <= n && n - i > i) {\\n                list.add(i);\\n                generate(result, list, k - 1, n - i, i + 1);\\n                list.remove(Integer.valueOf(i));\\n            }\\n            else break;\\n        }\\n    }\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n        generate(result, list, k, n, 1);\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public static void generate(List<List<Integer>> result, List<Integer> list, int k, int n, int start) {\\n        if(k == 1 && start <= n && n <= 9) {\\n            list.add(n);\\n            result.add(new ArrayList<>(list));\\n            list.remove(Integer.valueOf(n));\\n            return;\\n        }\\n        for(int i = start; i <= 9; i++) {\\n            if(i <= n && n - i > i) {\\n                list.add(i);\\n                generate(result, list, k - 1, n - i, i + 1);\\n                list.remove(Integer.valueOf(i));\\n            }\\n            else break;\\n        }\\n    }\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n        generate(result, list, k, n, 1);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342988,
                "title": "c-using-recursion-backtracking-beats-100-t-c-o-2-n-s-c-o-n",
                "content": "```\\nclass Solution {\\n\\n/*\\n\\tTime Complexity : O(2^N)\\n\\tSpace Complexity : O(N)\\n*/\\n\\nprivate:\\n    vector<vector<int>> res;\\n    \\n    void helper(int idx, int target, int k, vector<int> &temp, vector<int> &nums){\\n        if(target == 0 && temp.size() == k){\\n            res.push_back(temp);\\n            return;\\n        }\\n        \\n        if(idx >= nums.size()) return;\\n        if(temp.size()>k) return;\\n        \\n        for(int i=idx; i<nums.size(); i++){\\n            if(nums[i] <= target){\\n                temp.push_back(nums[i]);\\n                helper(i+1, target-nums[i], k, temp, nums);\\n                \\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> nums;\\n        for(int i=1; i<=9; i++) nums.push_back(i);\\n        vector<int> temp;\\n        \\n        // idx, currSum, target, k, temp \\n        helper(0, n, k, temp, nums);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n/*\\n\\tTime Complexity : O(2^N)\\n\\tSpace Complexity : O(N)\\n*/\\n\\nprivate:\\n    vector<vector<int>> res;\\n    \\n    void helper(int idx, int target, int k, vector<int> &temp, vector<int> &nums){\\n        if(target == 0 && temp.size() == k){\\n            res.push_back(temp);\\n            return;\\n        }\\n        \\n        if(idx >= nums.size()) return;\\n        if(temp.size()>k) return;\\n        \\n        for(int i=idx; i<nums.size(); i++){\\n            if(nums[i] <= target){\\n                temp.push_back(nums[i]);\\n                helper(i+1, target-nums[i], k, temp, nums);\\n                \\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> nums;\\n        for(int i=1; i<=9; i++) nums.push_back(i);\\n        vector<int> temp;\\n        \\n        // idx, currSum, target, k, temp \\n        helper(0, n, k, temp, nums);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3120584,
                "title": "just-a-trick-100-faster-same-as-combination-sum-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nit is same problem as combination sum II problem , here is just a modification is that our candidate array will be of 1 to 9.and this problem will be solved.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>>ans;\\n    void f(int i, vector<int>&candidates , vector<int>&v , int t , int k){\\n        int n = candidates.size();\\n        if(t == 0 && k==0){\\n            ans.push_back(v);\\n        }\\n\\n        for(int j=i;j<n;j++){\\n\\n            if(j > i && candidates[j] == candidates[j-1]){\\n                continue;\\n            }\\n            if(candidates[j] <= t){\\n            v.push_back(candidates[j]);\\n            f(j+1 , candidates , v , t-candidates[j] , k-1);\\n            v.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int>candidates;\\n        int target = n;\\n        for(int i=1;i<=9;i++){\\n            candidates.push_back(i);\\n        }\\n\\n        vector<int>v;\\n        f(0 , candidates , v , target , k);\\n        return (ans);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>>ans;\\n    void f(int i, vector<int>&candidates , vector<int>&v , int t , int k){\\n        int n = candidates.size();\\n        if(t == 0 && k==0){\\n            ans.push_back(v);\\n        }\\n\\n        for(int j=i;j<n;j++){\\n\\n            if(j > i && candidates[j] == candidates[j-1]){\\n                continue;\\n            }\\n            if(candidates[j] <= t){\\n            v.push_back(candidates[j]);\\n            f(j+1 , candidates , v , t-candidates[j] , k-1);\\n            v.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int>candidates;\\n        int target = n;\\n        for(int i=1;i<=9;i++){\\n            candidates.push_back(i);\\n        }\\n\\n        vector<int>v;\\n        f(0 , candidates , v , target , k);\\n        return (ans);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2978482,
                "title": "very-easy-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n!!PLZZ UPVOTE IF YOU LIKE MY SOLUTION !!\\n\\n vector<vector<int>> ans; //Globally declared ans vector so that we don\\'t have to pass this in each function call this will contain multiple temp vectors\\n   void solve(int k,int n,vector<int> num,int i,vector<int>& temp){\\n\\n    //Base Conditions\\n       if(n<0) return; //Base condition 1:As we are subtracting the value of n in our function call so if it becomes less than 0 or negative it means our temp array have sum more than n so we simply have to return because return typr of function is void.\\n        if(n==0){  //Base Condition 2:if temp elemets sum becomes exactly equal to n then n becomes 0 so now we have to check the sixe of array if size is equal to k then only we can push our temp vector into ans vector;\\n           if(temp.size()==k) ans.push_back(temp); //checking the condition of equallity i.e. temp size is euqal to k or not\\n           return; \\n        }\\n        if(i==num.size()) return; //Base Condition3: if index of num vector becomes equal to or greater its size then return in that case;\\n\\n\\n        //function Calling\\n        if(num[i]<=n){  //if element at index i in num vector is less or equal to n then either we can pick that element of i or not pick\\n            temp.push_back(num[i]); //pick that\\'s why pushing it into temp array\\n            solve(k,n-num[i],num,i+1,temp); //picking that\\'s why subtracting the value of that elememt from n i.e. n-nums[i] and increasing index by 1.\\n            temp.pop_back();//poping the picked element so that in further function call we doesnot want to pick that element\\n            solve(k,n,num,i+1,temp); //not pick that\\'s why not subtracting anything from n and then increasing the index by 1.\\n        }else{ //if element at index i in num vector is greater than  n then not pick\\n            solve(k,n,num,i+1,temp); //not pick\\n        }\\n    }\\n\\n\\n\\n\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> num; //creating a temprory vector to store 1 to 9\\n        for(int i=1;i<10;i++){ // pushing 1 to 9 in vector num\\n            num.push_back(i);\\n        }\\n        vector<int> temp; // creating another vector temp which gets pushed inside ans vector if it satisfy the base condition\\n        solve(k,n,num,0,temp); //calling solve function which is declared above.\\n        return ans; // finally returning the answer;\\n    }\\n};\\n\\n!!PLZZ UPVOTE IF YOU LIKE MY SOLUTION !!\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n!!PLZZ UPVOTE IF YOU LIKE MY SOLUTION !!\\n\\n vector<vector<int>> ans; //Globally declared ans vector so that we don\\'t have to pass this in each function call this will contain multiple temp vectors\\n   void solve(int k,int n,vector<int> num,int i,vector<int>& temp){\\n\\n    //Base Conditions\\n       if(n<0) return; //Base condition 1:As we are subtracting the value of n in our function call so if it becomes less than 0 or negative it means our temp array have sum more than n so we simply have to return because return typr of function is void.\\n        if(n==0){  //Base Condition 2:if temp elemets sum becomes exactly equal to n then n becomes 0 so now we have to check the sixe of array if size is equal to k then only we can push our temp vector into ans vector;\\n           if(temp.size()==k) ans.push_back(temp); //checking the condition of equallity i.e. temp size is euqal to k or not\\n           return; \\n        }\\n        if(i==num.size()) return; //Base Condition3: if index of num vector becomes equal to or greater its size then return in that case;\\n\\n\\n        //function Calling\\n        if(num[i]<=n){  //if element at index i in num vector is less or equal to n then either we can pick that element of i or not pick\\n            temp.push_back(num[i]); //pick that\\'s why pushing it into temp array\\n            solve(k,n-num[i],num,i+1,temp); //picking that\\'s why subtracting the value of that elememt from n i.e. n-nums[i] and increasing index by 1.\\n            temp.pop_back();//poping the picked element so that in further function call we doesnot want to pick that element\\n            solve(k,n,num,i+1,temp); //not pick that\\'s why not subtracting anything from n and then increasing the index by 1.\\n        }else{ //if element at index i in num vector is greater than  n then not pick\\n            solve(k,n,num,i+1,temp); //not pick\\n        }\\n    }\\n\\n\\n\\n\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> num; //creating a temprory vector to store 1 to 9\\n        for(int i=1;i<10;i++){ // pushing 1 to 9 in vector num\\n            num.push_back(i);\\n        }\\n        vector<int> temp; // creating another vector temp which gets pushed inside ans vector if it satisfy the base condition\\n        solve(k,n,num,0,temp); //calling solve function which is declared above.\\n        return ans; // finally returning the answer;\\n    }\\n};\\n\\n!!PLZZ UPVOTE IF YOU LIKE MY SOLUTION !!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868817,
                "title": "go-backtracking-map-solution",
                "content": "```\\nfunc backtrack(res *[][]int, k, n, sum int, curSequence []int, used map[int]struct{}) {\\n    if sum == n && len(curSequence) == k{\\n        cs := make([]int, len(curSequence))\\n        copy(cs, curSequence)\\n        *res = append(*res, cs)\\n        return\\n    }\\n\\n    for i := 1; i <= 9; i++ {\\n        if _, ok := used[i]; ok {\\n            continue\\n        }\\n\\n        switch {\\n        case len(curSequence) > k:\\n            continue\\n        case len(curSequence) > 0 && i <= curSequence[len(curSequence)-1]:\\n            continue\\n        case sum > n:\\n            continue\\n        }\\n\\n        used[i] = struct{}{}\\n        curSequence = append(curSequence, i)\\n        backtrack(res, k, n, sum+i, curSequence, used)\\n        delete(used, i)\\n        curSequence = curSequence[:len(curSequence)-1]\\n    }\\n}\\n\\nfunc combinationSum3(k int, n int) [][]int {\\n    var res [][]int\\n    used := make(map[int]struct{})\\n    backtrack(&res, k, n, 0/*sum*/, []int{} /*curSequence*/, used)\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nfunc backtrack(res *[][]int, k, n, sum int, curSequence []int, used map[int]struct{}) {\\n    if sum == n && len(curSequence) == k{\\n        cs := make([]int, len(curSequence))\\n        copy(cs, curSequence)\\n        *res = append(*res, cs)\\n        return\\n    }\\n\\n    for i := 1; i <= 9; i++ {\\n        if _, ok := used[i]; ok {\\n            continue\\n        }\\n\\n        switch {\\n        case len(curSequence) > k:\\n            continue\\n        case len(curSequence) > 0 && i <= curSequence[len(curSequence)-1]:\\n            continue\\n        case sum > n:\\n            continue\\n        }\\n\\n        used[i] = struct{}{}\\n        curSequence = append(curSequence, i)\\n        backtrack(res, k, n, sum+i, curSequence, used)\\n        delete(used, i)\\n        curSequence = curSequence[:len(curSequence)-1]\\n    }\\n}\\n\\nfunc combinationSum3(k int, n int) [][]int {\\n    var res [][]int\\n    used := make(map[int]struct{})\\n    backtrack(&res, k, n, 0/*sum*/, []int{} /*curSequence*/, used)\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2774827,
                "title": "simple-clean-c-backtracking-3ms",
                "content": "```\\nclass Solution {\\npublic:\\n    void combination(vector<int> &v,vector<vector<int>> &ans,vector<int> &ds,int k,int n,int i){\\n        if(ds.size()==k){\\n            if(n==0){\\n                ans.push_back(ds);\\n                return;\\n            }\\n        }\\n        if(i==v.size()){\\n            return;\\n        }  \\n        if(ds.size()<k){\\n        if(v[i]<=n){\\n        ds.push_back(v[i]);\\n        combination(v,ans,ds,k,n-v[i],i+1);\\n        ds.pop_back();\\n        combination(v,ans,ds,k,n,i+1);\\n            }\\n    }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> v = {1,2,3,4,5,6,7,8,9};\\n        vector<vector<int>>ans;\\n        vector<int> ds;\\n        combination(v,ans,ds,k,n,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void combination(vector<int> &v,vector<vector<int>> &ans,vector<int> &ds,int k,int n,int i){\\n        if(ds.size()==k){\\n            if(n==0){\\n                ans.push_back(ds);\\n                return;\\n            }\\n        }\\n        if(i==v.size()){\\n            return;\\n        }  \\n        if(ds.size()<k){\\n        if(v[i]<=n){\\n        ds.push_back(v[i]);\\n        combination(v,ans,ds,k,n-v[i],i+1);\\n        ds.pop_back();\\n        combination(v,ans,ds,k,n,i+1);\\n            }\\n    }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> v = {1,2,3,4,5,6,7,8,9};\\n        vector<vector<int>>ans;\\n        vector<int> ds;\\n        combination(v,ans,ds,k,n,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2715490,
                "title": "easy-to-understand",
                "content": "```\\ndef fun(k,n,p):\\n    if(n<=0 or k==1 and n>=p):\\n        return []\\n    elif(k==1):\\n        return([[n]])\\n    ans=[]\\n    for i in range(p-1,0,-1):\\n        a=fun(k-1,n-i,i)\\n        for x in a:\\n            ans.append(x+[i])\\n    return ans\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        return(fun(k,n,10))\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ndef fun(k,n,p):\\n    if(n<=0 or k==1 and n>=p):\\n        return []\\n    elif(k==1):\\n        return([[n]])\\n    ans=[]\\n    for i in range(p-1,0,-1):\\n        a=fun(k-1,n-i,i)\\n        for x in a:\\n            ans.append(x+[i])\\n    return ans\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        return(fun(k,n,10))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677557,
                "title": "python-backtracking-with-comments",
                "content": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        if k > n:    # if number of elements greater than sum no point in checking\\n            return []\\n        if n > 45:   # we can have max sum 45 for [1,2....,9]\\n            return []\\n     \\n        lst = range(1,10)\\n\\n        ans=[]\\n\\n        def solve(ind, ds, target):\\n            if target == 0 and len(ds) == k: \\n                ans.append(ds[:])     # have to append a copy to our final answer (i.e. we cannot do ans.append(ds))\\n                return \\n\\n            for i in range(ind,len(lst)):\\n                if target < lst[i]:\\n                    break\\n                ds.append(lst[i])      # add the element to our data structure\\n                solve(i+1, ds, target-lst[i])   # remove that element from target\\n                ds.pop()        # now during backtracking we have to remove that element from our data structure\\n        solve(0,[],n)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        if k > n:    # if number of elements greater than sum no point in checking\\n            return []\\n        if n > 45:   # we can have max sum 45 for [1,2....,9]\\n            return []\\n     \\n        lst = range(1,10)\\n\\n        ans=[]\\n\\n        def solve(ind, ds, target):\\n            if target == 0 and len(ds) == k: \\n                ans.append(ds[:])     # have to append a copy to our final answer (i.e. we cannot do ans.append(ds))\\n                return \\n\\n            for i in range(ind,len(lst)):\\n                if target < lst[i]:\\n                    break\\n                ds.append(lst[i])      # add the element to our data structure\\n                solve(i+1, ds, target-lst[i])   # remove that element from target\\n                ds.pop()        # now during backtracking we have to remove that element from our data structure\\n        solve(0,[],n)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242425,
                "title": "100-faster-simple-backtracking-explaination-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void rec(int i,int k, int n, vector<vector<int>> &ans, vector<int>&temp){\\n        /*If target i.e n is discovered and the size of temp is also k so added it to ans */\\n        if(n==0 and temp.size()==k){ans.push_back(temp); return;}\\n        \\n        /*checking for the numbers from i to 9*/\\n        for(int j=i; j<=9; j++){\\n            /*Calling for j<=n only */\\n            if(j<=n){\\n                temp.push_back(j);\\n                /*j+1 check from next number and should not repeat the number again*/\\n                /*reducing value of target*/\\n                \\n                rec(j+1,k,n-j,ans,temp);\\n                \\n                /*backtracking*/\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        if(n>55) return ans; /* if  required sum > 55 (sum 1 to 10) */\\n        vector<int> temp;\\n        /*Backtracking*/\\n        rec(1,k,n,ans,temp);\\n        \\n        return ans;\\n    }\\n};```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void rec(int i,int k, int n, vector<vector<int>> &ans, vector<int>&temp){\\n        /*If target i.e n is discovered and the size of temp is also k so added it to ans */\\n        if(n==0 and temp.size()==k){ans.push_back(temp); return;}\\n        \\n        /*checking for the numbers from i to 9*/\\n        for(int j=i; j<=9; j++){\\n            /*Calling for j<=n only */\\n            if(j<=n){\\n                temp.push_back(j);\\n                /*j+1 check from next number and should not repeat the number again*/\\n                /*reducing value of target*/\\n                \\n                rec(j+1,k,n-j,ans,temp);\\n                \\n                /*backtracking*/\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        if(n>55) return ans; /* if  required sum > 55 (sum 1 to 10) */\\n        vector<int> temp;\\n        /*Backtracking*/\\n        rec(1,k,n,ans,temp);\\n        \\n        return ans;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2026238,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> nm=new ArrayList<List<Integer>>();\\n        if(n<k*(k+1)/2)\\n            return nm;\\n        task(1,k,n,new LinkedList<>(),nm);\\n            return nm;\\n    }\\n    static void task(int s, int k, int n, LinkedList<Integer> kk, List<List<Integer>> nm)\\n    {\\n        if(k<0||n<0)\\n            return;\\n        if(n==0&&k==0)\\n        {\\n            nm.add(new ArrayList<>(kk));\\n            return;\\n        }\\n        for(int i=s;i<=9;i++)\\n        {\\n            kk.add(i);\\n            task(i+1,k-1,n-i,kk,nm);\\n            kk.removeLast();\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> nm=new ArrayList<List<Integer>>();\\n        if(n<k*(k+1)/2)\\n            return nm;\\n        task(1,k,n,new LinkedList<>(),nm);\\n            return nm;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2026171,
                "title": "c-backtracking-solution",
                "content": "```\\n   void helper(vector<vector<int>>& output, int k, int n, int num,  vector<int> currentGroup)     {\\n        if(n ==0 && k ==0){\\n            output.push_back(currentGroup);\\n            return;\\n        }\\n        \\n        if(num <= 0) return;\\n        \\n        if(num <= n){\\n            currentGroup.push_back(num);\\n            helper(output, k-1, n-num, num-1, currentGroup);\\n            currentGroup.pop_back();      \\n        }\\n\\t\\t\\n        helper(output, k, n, num-1, currentGroup);\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> output;\\n        vector<int> currGroup;\\n        int num = 9;\\n        helper(output, k , n, num,  currGroup);\\n        return output;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n   void helper(vector<vector<int>>& output, int k, int n, int num,  vector<int> currentGroup)     {\\n        if(n ==0 && k ==0){\\n            output.push_back(currentGroup);\\n            return;\\n        }\\n        \\n        if(num <= 0) return;\\n        \\n        if(num <= n){\\n            currentGroup.push_back(num);\\n            helper(output, k-1, n-num, num-1, currentGroup);\\n            currentGroup.pop_back();      \\n        }\\n\\t\\t\\n        helper(output, k, n, num-1, currentGroup);\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> output;\\n        vector<int> currGroup;\\n        int num = 9;\\n        helper(output, k , n, num,  currGroup);\\n        return output;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2026134,
                "title": "c-next-permutation-100-time",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<bool> bits;\\n        static vector<int> vals;\\n        if(vals.empty())for(int i=0;i<9;i++)vals.push_back(i+1);\\n        int i;\\n        bits.resize(9);\\n        for(i=0;i<k;i++)\\n            bits[8-i]=1;\\n        do{\\n            int now=inner_product(bits.begin(),bits.end(),vals.begin(),0);\\n            if(now==n){\\n                ans.push_back({});\\n                for(i=0;i<9;i++)\\n                    if(bits[i])ans.back().push_back(i+1);\\n            }\\n        }while(next_permutation(bits.begin(),bits.end()));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<bool> bits;\\n        static vector<int> vals;\\n        if(vals.empty())for(int i=0;i<9;i++)vals.push_back(i+1);\\n        int i;\\n        bits.resize(9);\\n        for(i=0;i<k;i++)\\n            bits[8-i]=1;\\n        do{\\n            int now=inner_product(bits.begin(),bits.end(),vals.begin(),0);\\n            if(now==n){\\n                ans.push_back({});\\n                for(i=0;i<9;i++)\\n                    if(bits[i])ans.back().push_back(i+1);\\n            }\\n        }while(next_permutation(bits.begin(),bits.end()));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026081,
                "title": "java-backtracking-100-faster-recursive-solution-easy-solution",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> ans;\\n    private void backtrack(int k, int n, int i, List<Integer> val){\\n        \\n        if(k == 0 && n == 0){\\n            ans.add(val);\\n            return;\\n        }\\n        if(k < 0 || n < 0)\\n            return;\\n        \\n        for(; i <= 9; i++){\\n            val.add(i);\\n            backtrack(k-1, n-i, i+1, new ArrayList<>(val));\\n            val.remove(val.size()-1); //Backtrack\\n        }\\n    }\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        ans = new ArrayList<>();\\n        \\n        if(k >= n)\\n            return ans;\\n        \\n        backtrack(k, n, 1, new ArrayList<>());\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> ans;\\n    private void backtrack(int k, int n, int i, List<Integer> val){\\n        \\n        if(k == 0 && n == 0){\\n            ans.add(val);\\n            return;\\n        }\\n        if(k < 0 || n < 0)\\n            return;\\n        \\n        for(; i <= 9; i++){\\n            val.add(i);\\n            backtrack(k-1, n-i, i+1, new ArrayList<>(val));\\n            val.remove(val.size()-1); //Backtrack\\n        }\\n    }\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        ans = new ArrayList<>();\\n        \\n        if(k >= n)\\n            return ans;\\n        \\n        backtrack(k, n, 1, new ArrayList<>());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025936,
                "title": "python-39ms-solution",
                "content": "\\'\\'\\'\\n       \\n\\t   res=[]\\n        def backtrack(i=0,c=1,r=[],s=0):\\n            if i==k:\\n                if s==n:\\n                    res.append(r[:])\\n            if i>=k or c>9:\\n                return\\n            r.append(c)\\n            backtrack(i+1,c+1,r,s+c)\\n            r.pop()\\n            backtrack(i,c+1,r,s)\\n            \\n        backtrack()\\n        return res\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "\\'\\'\\'\\n       \\n\\t   res=[]\\n        def backtrack(i=0,c=1,r=[],s=0):\\n            if i==k:\\n                if s==n:\\n                    res.append(r[:])\\n            if i>=k or c>9:\\n                return\\n            r.append(c)\\n            backtrack(i+1,c+1,r,s+c)\\n            r.pop()\\n            backtrack(i,c+1,r,s)\\n            \\n        backtrack()\\n        return res\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 2025397,
                "title": "one-liner-solution",
                "content": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        return [list(x) for x in combinations(range(1,10), k) if sum(x) == n]\\n```\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        return [list(x) for x in combinations(range(1,10), k) if sum(x) == n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025273,
                "title": "c-solution-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    vector<int>temp;\\n    int sum=0;\\n    void f(int index,vector<int>&v,int k,int n){\\n      if(index>=v.size()){\\n        if(sum==n and temp.size()==k){\\n          ans.push_back(temp);\\n        }\\n        return;\\n      } \\n      if(sum>n) return;\\n      \\n      temp.push_back(v[index]);\\n      sum+=v[index];\\n      f(index+1,v,k,n);\\n      temp.pop_back();\\n      sum-=v[index];\\n      f(index+1,v,k,n);\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n      vector<int>v;\\n      for(int i=1;i<=9;i++){\\n        v.push_back(i);\\n      }\\n      f(0,v,k,n);\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    vector<int>temp;\\n    int sum=0;\\n    void f(int index,vector<int>&v,int k,int n){\\n      if(index>=v.size()){\\n        if(sum==n and temp.size()==k){\\n          ans.push_back(temp);\\n        }\\n        return;\\n      } \\n      if(sum>n) return;\\n      \\n      temp.push_back(v[index]);\\n      sum+=v[index];\\n      f(index+1,v,k,n);\\n      temp.pop_back();\\n      sum-=v[index];\\n      f(index+1,v,k,n);\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n      vector<int>v;\\n      for(int i=1;i<=9;i++){\\n        v.push_back(i);\\n      }\\n      f(0,v,k,n);\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024540,
                "title": "100-0-ms-simple-concise-code-meme",
                "content": "```\\npublic List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/a0a687d6-aa68-4d8e-8edc-595ebaf2e719_1652158837.0654278.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\npublic List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2024421,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void helper(int k,int n,vector<int> &c,vector<vector<int>> &ans,vector<int> &v)\\n    {\\n        if(k==0 && n==0)\\n        {\\n            ans.push_back(c);\\n            return;\\n        }\\n        if(k<0 || n<0)\\n            return;\\n        for(int i=1;i<=9;i++)\\n        {\\n            if(v[i]==0 && n>=i && (c.size()>0?i>c[c.size()-1]:true))\\n            {\\n                v[i]=1;\\n                c.push_back(i);\\n                helper(k-1,n-i,c,ans,v);\\n                c.pop_back();\\n                v[i]=0;\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> visited(10,0);\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        helper(k,n,curr,ans,visited);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(int k,int n,vector<int> &c,vector<vector<int>> &ans,vector<int> &v)\\n    {\\n        if(k==0 && n==0)\\n        {\\n            ans.push_back(c);\\n            return;\\n        }\\n        if(k<0 || n<0)\\n            return;\\n        for(int i=1;i<=9;i++)\\n        {\\n            if(v[i]==0 && n>=i && (c.size()>0?i>c[c.size()-1]:true))\\n            {\\n                v[i]=1;\\n                c.push_back(i);\\n                helper(k-1,n-i,c,ans,v);\\n                c.pop_back();\\n                v[i]=0;\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> visited(10,0);\\n        vector<vector<int>> ans;\\n        vector<int> curr;\\n        helper(k,n,curr,ans,visited);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024378,
                "title": "c-simple-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> res;\\n       \\n        vector<int> ans;\\n        \\n        solve(k,n, 1 ,res,ans);\\n        return res;\\n    }\\n    void solve(int k , int n, int i,vector<vector<int>>&res, vector<int>&ans )\\n    {\\n        if(k==0)\\n        {\\n                int sum=0;\\n                for(int x=0;x<ans.size();x++)\\n                {\\n                    sum += ans[x];\\n                }\\n                if(sum == n)\\n                    res.push_back(ans);\\n            return;\\n        }\\n        if(i>9)\\n        {\\n            return;\\n        }\\n       \\n        ans.push_back(i);\\n        solve(k-1 , n,i+1,res,ans);\\n        ans.pop_back();\\n        solve(k , n ,i+1,res,ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> res;\\n       \\n        vector<int> ans;\\n        \\n        solve(k,n, 1 ,res,ans);\\n        return res;\\n    }\\n    void solve(int k , int n, int i,vector<vector<int>>&res, vector<int>&ans )\\n    {\\n        if(k==0)\\n        {\\n                int sum=0;\\n                for(int x=0;x<ans.size();x++)\\n                {\\n                    sum += ans[x];\\n                }\\n                if(sum == n)\\n                    res.push_back(ans);\\n            return;\\n        }\\n        if(i>9)\\n        {\\n            return;\\n        }\\n       \\n        ans.push_back(i);\\n        solve(k-1 , n,i+1,res,ans);\\n        ans.pop_back();\\n        solve(k , n ,i+1,res,ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024126,
                "title": "2-approaches-backtracking-and-bit-mask-code-commented",
                "content": "[Leetcode](https://leetcode.com/) [216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/).\\n\\nHere shows **2** Approaches to slove this problem: **Backtracking** and **Bit Mask**.\\n\\n# Backtracking\\n\\nA very easy backtracking solution. Just refer to [4 Approaches: BF 4 Loops, Backtracking, BFS, Queue with Image Explaination](https://leetcode.com/problems/letter-combinations-of-a-phone-number/solutions/2021106/4-approaches-bf-4-loops-backtracking-bfs-queue-with-image-explanation/).\\n\\n```java\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        // corner cases\\n        if (k <= 0 || n <= 0 || k > n) {\\n            return ans;\\n        }\\n\\n        // The upper bound of n: [9, 8, ... , (9 - k + 1)], sum is (19 - k) * k / 2\\n        if (n > (19 - k) * k / 2) {\\n            return ans;\\n        }\\n\\n        backtrack(ans, new ArrayList<>(), 1, k, n);\\n        return ans;\\n    }\\n\\n    public void backtrack(List<List<Integer>> res, List<Integer> path, int start, int k, int target) {\\n        if (k < 0 || target < 0) {\\n            return;\\n        }\\n\\n        if (k == 0 && target == 0) {\\n            res.add(new ArrayList<>(path));\\n            return;\\n        }\\n\\n        for (int i = start; i <= 9; i++) {\\n            // trim \\n            if (i > target) {\\n                break;\\n            }\\n\\t\\t\\t\\n            // trim\\n            if (target - i == 0 && k > 1) {\\n                break;\\n            }\\n\\n            path.add(i);\\n            backtrack(res, path, i + 1, k - 1, target - i);\\n            path.remove(path.size() - 1);\\n        }\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O({M \\\\choose k} \\\\times k)$, $M$ is the size of combinations, $M = 9$, the total combinations is $M \\\\choose k$.\\n- **Space Complexity**: $O(M + k)$, size of $path$ is $k$, the recursion stack is $O(M)$.\\n\\n\\n# Bit Mask\\n\\nSince the numbers are just from $1$ to $9$, the total sum of combinations is $2^9=512$.\\n\\nWe can map $1$ - $9$ with a number with a length of 9-bits number, bits $0$ means selecting $1$, bits $8$ means selecting $9$.\\n\\nEg:\\n\\n$000000001b$, means [1]\\n$000000011b$, means [1,2]\\n$100000011b$, means [1,2,9]\\n\\nWe can search from $1$ to $512$, take the number corresponding to the bit value of $1$ in $i$, and sum it up to see if it is satisfied.\\n\\n```java\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        // corner cases\\n        if (k <= 0 || n <= 0 || k > n) {\\n            return ans;\\n        }\\n\\n        // The upper bound of n: [9, 8, ... , (9 - k + 1)], sum is (19 - k) * k / 2\\n        if (n > (19 - k) * k / 2) {\\n            return ans;\\n        }\\n\\n        for (int mask = 0; mask < (1 << 9); mask++) {\\n            List<Integer> path = new ArrayList<>();\\n            if (check(path, mask, k, n)) {\\n                ans.add(path);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public boolean check(List<Integer> path, int mask, int k, int target) {\\n        path.clear();\\n        \\n        for (int i = 0; i < 9; i++) {\\n            if (((1 << i) & mask) != 0) {\\n                path.add(i + 1);\\n            }\\n        }\\n\\n        if (path.size() != k) {\\n            return false;\\n        }\\n\\n        int sum = 0;\\n        for (int x : path) {\\n            sum += x;\\n        }\\n\\n        return sum == target;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(M \\\\times 2^M)$, $M = 9$, every state needs $O(M + k) = O(M)$ to check.\\n- **Space Complexity**: $O(M)$, $M$ is size of $\\\\textit{path}$.\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Bit Manipulation"
                ],
                "code": "```java\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        // corner cases\\n        if (k <= 0 || n <= 0 || k > n) {\\n            return ans;\\n        }\\n\\n        // The upper bound of n: [9, 8, ... , (9 - k + 1)], sum is (19 - k) * k / 2\\n        if (n > (19 - k) * k / 2) {\\n            return ans;\\n        }\\n\\n        backtrack(ans, new ArrayList<>(), 1, k, n);\\n        return ans;\\n    }\\n\\n    public void backtrack(List<List<Integer>> res, List<Integer> path, int start, int k, int target) {\\n        if (k < 0 || target < 0) {\\n            return;\\n        }\\n\\n        if (k == 0 && target == 0) {\\n            res.add(new ArrayList<>(path));\\n            return;\\n        }\\n\\n        for (int i = start; i <= 9; i++) {\\n            // trim \\n            if (i > target) {\\n                break;\\n            }\\n\\t\\t\\t\\n            // trim\\n            if (target - i == 0 && k > 1) {\\n                break;\\n            }\\n\\n            path.add(i);\\n            backtrack(res, path, i + 1, k - 1, target - i);\\n            path.remove(path.size() - 1);\\n        }\\n    }\\n```\n```java\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n\\n        // corner cases\\n        if (k <= 0 || n <= 0 || k > n) {\\n            return ans;\\n        }\\n\\n        // The upper bound of n: [9, 8, ... , (9 - k + 1)], sum is (19 - k) * k / 2\\n        if (n > (19 - k) * k / 2) {\\n            return ans;\\n        }\\n\\n        for (int mask = 0; mask < (1 << 9); mask++) {\\n            List<Integer> path = new ArrayList<>();\\n            if (check(path, mask, k, n)) {\\n                ans.add(path);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    public boolean check(List<Integer> path, int mask, int k, int target) {\\n        path.clear();\\n        \\n        for (int i = 0; i < 9; i++) {\\n            if (((1 << i) & mask) != 0) {\\n                path.add(i + 1);\\n            }\\n        }\\n\\n        if (path.size() != k) {\\n            return false;\\n        }\\n\\n        int sum = 0;\\n        for (int x : path) {\\n            sum += x;\\n        }\\n\\n        return sum == target;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2024122,
                "title": "golang",
                "content": "```\\nfunc combinationSum3(k int, n int) [][]int {\\n    result := make([][]int, 0)\\n    \\n    backtrack(k, n, 1, []int{}, &result)\\n    \\n    return result\\n}\\n\\nfunc backtrack(k, target, start int, visited []int, result *[][]int) {\\n    if k == 0 && target == 0 {\\n        nums := make([]int, 0)\\n        nums = append(nums, visited...)\\n        *result = append(*result, nums)\\n        return\\n    }\\n    \\n    for i := start; i <= 9; i++ {\\n        visited = append(visited, i)\\n        backtrack(k-1, target-i, i+1, visited, result)\\n        visited = visited[:len(visited)-1]\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc combinationSum3(k int, n int) [][]int {\\n    result := make([][]int, 0)\\n    \\n    backtrack(k, n, 1, []int{}, &result)\\n    \\n    return result\\n}\\n\\nfunc backtrack(k, target, start int, visited []int, result *[][]int) {\\n    if k == 0 && target == 0 {\\n        nums := make([]int, 0)\\n        nums = append(nums, visited...)\\n        *result = append(*result, nums)\\n        return\\n    }\\n    \\n    for i := start; i <= 9; i++ {\\n        visited = append(visited, i)\\n        backtrack(k-1, target-i, i+1, visited, result)\\n        visited = visited[:len(visited)-1]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2005679,
                "title": "simple-clean-code-easy-to-understand",
                "content": "```\\nclass Solution {\\nprivate:\\n    void solve(vector<vector<int>>& ans,vector<int>& temp,int ind,int num,int k,int target){\\n        if(num==k){\\n            \\n            if(target==0){\\n                ans.push_back(temp);\\n                return ;\\n            }\\n        }\\n        \\n        \\n        for(int i=ind;i<=9;i++){\\n            if(i>target) return;\\n            temp.push_back(i);\\n            solve(ans,temp,i+1,num+1,k,target-i);\\n            temp.pop_back();\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        solve(ans,temp,1,0,k,n);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solve(vector<vector<int>>& ans,vector<int>& temp,int ind,int num,int k,int target){\\n        if(num==k){\\n            \\n            if(target==0){\\n                ans.push_back(temp);\\n                return ;\\n            }\\n        }\\n        \\n        \\n        for(int i=ind;i<=9;i++){\\n            if(i>target) return;\\n            temp.push_back(i);\\n            solve(ans,temp,i+1,num+1,k,target-i);\\n            temp.pop_back();\\n        }\\n        \\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        solve(ans,temp,1,0,k,n);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983443,
                "title": "faster-than-96-89-solution-python",
                "content": "![image](https://assets.leetcode.com/users/images/37c371af-a0dd-4e4a-a5c9-6e2e7a924b63_1650963389.4401085.png)\\n\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        nums=[i for i in range(1,10)]\\n        res=[]\\n        self.helper(res,nums,k,[],n)\\n        return res\\n    def helper(self,res,nums,k,path,t):\\n        if len(path)==k:\\n            if t==0:\\n                res.append(path)\\n        for i in range(len(nums)):\\n            if nums[i]>t:\\n                continue\\n            self.helper(res,nums[i+1:],k,path+[nums[i]],t-nums[i])\\n```\\nFeel free to ask about any line .\\nUpvote plz...\\n",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        nums=[i for i in range(1,10)]\\n        res=[]\\n        self.helper(res,nums,k,[],n)\\n        return res\\n    def helper(self,res,nums,k,path,t):\\n        if len(path)==k:\\n            if t==0:\\n                res.append(path)\\n        for i in range(len(nums)):\\n            if nums[i]>t:\\n                continue\\n            self.helper(res,nums[i+1:],k,path+[nums[i]],t-nums[i])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808782,
                "title": "simplest-solution-easy-to-understand-c",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPERICIATED**\\n```\\nclass Solution {\\nprivate:\\n    void f(int ind,int sum,int n,vector<vector<int>>& ans,vector<int>& ans2,int k){\\n        if(sum==n && k==0){\\n            ans.push_back(ans2);\\n            return;\\n        }\\n        if(sum>n){\\n            return;\\n        }\\n        for(int i=ind;i<=9;i++){\\n            if(i>n){\\n                break;\\n            }\\n            ans2.push_back(i);\\n            f(i+1,sum+i,n,ans,ans2,k-1);\\n            ans2.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> ans2;\\n        vector<vector<int>> ans;\\n        f(1,0,n,ans,ans2,k);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void f(int ind,int sum,int n,vector<vector<int>>& ans,vector<int>& ans2,int k){\\n        if(sum==n && k==0){\\n            ans.push_back(ans2);\\n            return;\\n        }\\n        if(sum>n){\\n            return;\\n        }\\n        for(int i=ind;i<=9;i++){\\n            if(i>n){\\n                break;\\n            }\\n            ans2.push_back(i);\\n            f(i+1,sum+i,n,ans,ans2,k-1);\\n            ans2.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> ans2;\\n        vector<vector<int>> ans;\\n        f(1,0,n,ans,ans2,k);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808291,
                "title": "c-recursion-simple-picking-and-non-picking-problem",
                "content": "Credits : Aditya Verma OP\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void findit(int i,int k,int n,vector<int>V){\\n        // we can also write base conditions in a more decent way\\n        if(n==0&&k==0){\\n            ans.push_back(V);              //true base condition\\n            return ;\\n        }\\n        if(i==10){\\n            return;                  // false base condition \\n        }\\n        vector<int>V1=V;                \\n        V1.push_back(i); \\n        // if we are picking in the answer k=k-1 & n=n-i \\n        findit(i+1,k-1,n-i,V1);       // picking in the answer\\n        findit(i+1,k,n,V);            // not picking\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int>V;\\n        findit(1,k,n,V);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void findit(int i,int k,int n,vector<int>V){\\n        // we can also write base conditions in a more decent way\\n        if(n==0&&k==0){\\n            ans.push_back(V);              //true base condition\\n            return ;\\n        }\\n        if(i==10){\\n            return;                  // false base condition \\n        }\\n        vector<int>V1=V;                \\n        V1.push_back(i); \\n        // if we are picking in the answer k=k-1 & n=n-i \\n        findit(i+1,k-1,n-i,V1);       // picking in the answer\\n        findit(i+1,k,n,V);            // not picking\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int>V;\\n        findit(1,k,n,V);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803227,
                "title": "c-100-faster-backtracking-solution",
                "content": "\\tclass Solution {\\n\\t\\tvector<vector<int>> ans; //to store our answer\\n\\tpublic:\\n\\t\\tvoid helper(vector<int> &num,int idx,vector<int> &v,int sum,int k){\\n\\t\\t\\tif(sum==0 && k==0){  //base condition\\n\\t\\t\\t\\tans.push_back(v);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(idx==9) return; //what if we exceed our limit of taking number\\n\\t\\t\\tif(num[idx]<=sum)  //we can only take number less than or equal to sum\\n\\t\\t\\t{\\n\\t\\t\\t\\tv.push_back(num[idx]),k-=1,sum-=num[idx];\\n\\t\\t\\t\\thelper(num,idx+1,v,sum,k);\\n\\t\\t\\t\\tv.pop_back(),k+=1,sum+=num[idx];\\n\\t\\t\\t\\thelper(num,idx+1,v,sum,k);\\n\\t\\t\\t}\\n\\t\\t\\telse   //if number is greater than sum then all further number will be too so return\\n\\t\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tvector<vector<int>> combinationSum3(int k, int n) {\\n\\t\\t\\t  vector<int> v,num;\\n\\t\\t\\t  for(int i=1;i<=9;i++) num.push_back(i); //all number we need\\n\\t\\t\\t helper(num,0,v,n,k); \\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\t\\tvector<vector<int>> ans; //to store our answer\\n\\tpublic:\\n\\t\\tvoid helper(vector<int> &num,int idx,vector<int> &v,int sum,int k){\\n\\t\\t\\tif(sum==0 && k==0){  //base condition\\n\\t\\t\\t\\tans.push_back(v);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1798886,
                "title": "simple-and-clean-c-backtracking-solution-with-explanation",
                "content": "We need to pick numbers from 1 to 9, and not pick same number twice. It means if in the first place we fill 1, we can only fill 2 - 9 on 2nd place, 3 - 9 and onwards on 3rd place and so on.\\nFor filling each place, we are in a different recursion call, so in a different call stack space. \\n\\nWe will subtract the number taken for a particular place from `target`, and subtract 1 from `k` each time a number is added in our combination before calling the next recursive function, so that when both `target` and `k` are equal to 0, we know we\\'ve found the combination. We\\'ll add it to our answer and return.\\nIf any of `target` or `k` is equal to 0, it means we cannot fill that place, so we just return.\\n\\nIf the 1st place is filled with a number, the 2nd place needs to fill from the next number (so elements are not duplicated), so we passed `i + 1` to `index`, and in the next call stack, the `for` loop will start from the next number.\\n\\nIn the `for` loop, we push a number in our `combination`, and call the function recursively to fill the next place. Once it returns (either the `combination` was added to our answer, or it was not added), we remove the number from our `combination`, and try for the next number.\\n\\nAdditionally, if at any point for filling a particular place, `i >= target`, it means now any other number will also be greater than target for filling that particular place. We just break from the loop, so that we can recursively go to the previous place, increase the number on the previous place, then try again filling this particular place.\\n\\n**Lets take an example**\\nIf `target` = 4, `k` = 2 :\\n\\nFor the first place, we start by filling 1. We go to the next call stack and fill 2 for the next place. `combination: [1,2]`\\nThen we go to the next call stack. At this point, `k` = 0, `target` = 1, so we\\'ll just return. Now we\\'re back at filling the 2nd place, which was originally filled with 2. We remove 2, go one iteration further in the `for` loop, and now fill 3. `combination: [1, 3]`\\nIn the next call stack, `k` = 0, `target` = 0, therefore we add [1,3] to our answer. \\n\\nWe remove the element, but before going forward, we can see that `i >= target` (3 >= 3 in this call stack). There can be no greater element in this place than 3, given 1 is in the 1st place. So we `break` out of finding an element for this place, and go to the previous call stack. There too we remove 1 from 1st place, add 2 and search for an element on the next place. \\nThis goes on till all combinations are added to the answer.\\n\\n**Code:**\\n\\n```c++\\nclass Solution {\\npublic:\\n    void recursion(int k, int target, vector<vector<int>>& ans, vector<int>& combination, int index) {\\n        if(target == 0 && k == 0) {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        if(target == 0 || k == 0)\\n            return;\\n        \\n        for(int i = index; i < 10; i++) {\\n            \\n            combination.push_back(i);\\n            recursion(k - 1, target - i, ans, combination, i + 1);\\n            combination.pop_back();\\n            \\n            if(i >= target)\\n                break;\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> combination;\\n        recursion(k, n, ans, combination, 1);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    void recursion(int k, int target, vector<vector<int>>& ans, vector<int>& combination, int index) {\\n        if(target == 0 && k == 0) {\\n            ans.push_back(combination);\\n            return;\\n        }\\n        if(target == 0 || k == 0)\\n            return;\\n        \\n        for(int i = index; i < 10; i++) {\\n            \\n            combination.push_back(i);\\n            recursion(k - 1, target - i, ans, combination, i + 1);\\n            combination.pop_back();\\n            \\n            if(i >= target)\\n                break;\\n        }\\n    }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int> combination;\\n        recursion(k, n, ans, combination, 1);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721465,
                "title": "simple-c-recursion-code",
                "content": "class Solution {\\n    public:\\n    void rec(int ind,vector<int>&arr,int k,vector<int>&ds,vector<vector<int>>&ans,int n,int v)\\n    {\\n        if(ind==arr.size())\\n        {\\n            if(ds.size()==k and v==n)\\n            {\\n                ans.push_back(ds);\\n            }\\n            return;\\n        }\\n        ds.push_back(arr[ind]);\\n        rec(ind+1,arr,k,ds,ans,n,v+arr[ind]);\\n        ds.pop_back();\\n        rec(ind+1,arr,k,ds,ans,n,v);\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>>ans;\\n        vector<int>ds;\\n        vector<int>arr;\\n        for(int i=1;i<=9;i++)\\n        {\\n            arr.push_back(i);\\n        }\\n        rec(0,arr,k,ds,ans,n,0);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n    void rec(int ind,vector<int>&arr,int k,vector<int>&ds,vector<vector<int>>&ans,int n,int v)\\n    {\\n        if(ind==arr.size())\\n        {\\n            if(ds.size()==k and v==n)\\n            {\\n                ans.push_back(ds);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1535789,
                "title": "python-simple-efficient-code",
                "content": "```class Solution:\\n    def combinationSum3(self, k: int, n: int) -> list[list[int]]:\\n        res = []\\n        \\n        if k > n:\\n            return res\\n        \\n        def dfs(i, total, cur):\\n            if len(cur) == k and total == n:\\n                res.append(cur[:])\\n                return\\n            \\n            if len(cur) == k:\\n                return\\n            \\n            for j in range(i, 10):\\n                dfs(j + 1, total + j, cur + [j])\\n        \\n        dfs(1, 0, [])\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```class Solution:\\n    def combinationSum3(self, k: int, n: int) -> list[list[int]]:\\n        res = []\\n        \\n        if k > n:\\n            return res\\n        \\n        def dfs(i, total, cur):\\n            if len(cur) == k and total == n:\\n                res.append(cur[:])\\n                return\\n            \\n            if len(cur) == k:\\n                return\\n            \\n            for j in range(i, 10):\\n                dfs(j + 1, total + j, cur + [j])\\n        \\n        dfs(1, 0, [])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1336846,
                "title": "recursion-backtracking-faster-than-100-cpp-solutions",
                "content": "This is same as combination sum-1. We just need to add some conditions to keep a check on given constraints(like the combination should contain k elements).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> arr{1,2,3,4,5,6,7,8,9};\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int start = 0;\\n         backtrack(arr,ans,v,start,k,n);\\n        return ans;\\n        \\n        \\n    }\\n    \\n    void backtrack(vector<int> &arr,vector<vector<int>> & ans, vector<int> &v,int start,int k,int sum){\\n        if(v.size()==k){\\n            if(sum==0){\\n                ans.push_back(v);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=start;i<arr.size();i++){\\n            if(arr[i]<=sum){\\n                v.push_back(arr[i]);\\n                backtrack(arr,ans,v,i+1,k,sum-arr[i]);\\n                v.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> arr{1,2,3,4,5,6,7,8,9};\\n        vector<vector<int>> ans;\\n        vector<int> v;\\n        int start = 0;\\n         backtrack(arr,ans,v,start,k,n);\\n        return ans;\\n        \\n        \\n    }\\n    \\n    void backtrack(vector<int> &arr,vector<vector<int>> & ans, vector<int> &v,int start,int k,int sum){\\n        if(v.size()==k){\\n            if(sum==0){\\n                ans.push_back(v);\\n            }\\n            return;\\n        }\\n        \\n        for(int i=start;i<arr.size();i++){\\n            if(arr[i]<=sum){\\n                v.push_back(arr[i]);\\n                backtrack(arr,ans,v,i+1,k,sum-arr[i]);\\n                v.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300888,
                "title": "c-100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    int os;\\n    void solve(int n,int k,int index,vector<int>& cur,vector<int>& nums)\\n    {\\n        if(k == 0 || cur.size() == os || n == 0)\\n        {\\n            if(cur.size() == os && n == 0)\\n                result.push_back(cur);\\n            return;\\n        }\\n        \\n        for(int i=index;i < nums.size();i++)\\n        {\\n            if(nums[i] <= n)\\n            {\\n                cur.push_back(nums[i]);\\n                solve(n-nums[i],k-1,i+1,cur,nums);   \\n                cur.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        os = k;\\n        vector<int> array(9,0);\\n        for(int i=1;i<10;i++)\\n        {\\n            array[i-1] = i;\\n        }\\n        vector<int> temp;\\n        solve(n,k,0,temp,array);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> result;\\n    int os;\\n    void solve(int n,int k,int index,vector<int>& cur,vector<int>& nums)\\n    {\\n        if(k == 0 || cur.size() == os || n == 0)\\n        {\\n            if(cur.size() == os && n == 0)\\n                result.push_back(cur);\\n            return;\\n        }\\n        \\n        for(int i=index;i < nums.size();i++)\\n        {\\n            if(nums[i] <= n)\\n            {\\n                cur.push_back(nums[i]);\\n                solve(n-nums[i],k-1,i+1,cur,nums);   \\n                cur.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        os = k;\\n        vector<int> array(9,0);\\n        for(int i=1;i<10;i++)\\n        {\\n            array[i-1] = i;\\n        }\\n        vector<int> temp;\\n        solve(n,k,0,temp,array);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294029,
                "title": "c-backtracking-with-complete-explanation",
                "content": "**Explanation:**\\n* We use a vector for storing the possible numbers, a 2D vector for our result and a temp vector for storing each possible array.\\n* This problem is similar to Combination Sum II ,except there is a limit in length of the array \\'k\\', and there are no candidate vectors given.\\n* we use recursive function helper, for finding all the possibilities.\\n```\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> v= {1,2,3,4,5,6,7,8,9};\\n        vector<vector<int>>res;\\n        vector<int> path;\\n        if(k==0) return res;\\n        helper(v,res,path,k,0,n);\\n        return res;\\n    }\\n```\\n* \\tThe Helper function consists of the candidates vector(v) , result (res) ,temp vector(path) , length limit (k), iterative index(start) and target sum (target). Notice that we have passed parameters by reference which gives significant advantage in time and space complexities.\\n* \\twe start with 0 as the index in the first iteration. Let\\'s use the given example k=3, target(n) = 7;\\n* \\twe go throught 1 to 9 in an array. we pick the first element and push it in the vector. We decrement our target to target- the picked number and check if the remaining can be achieved by recursion. the start index is incremented because we can only have a max of 1 repetitions of a number. length limit(k) is decremented as we have picked an element;\\n* \\tif the target is less than zero, then no element in the candidate array can add up to make target as zero. hence we return if target <0;\\n* \\tif the length of path is k and target is achieved, we simply push the vector into the result. and return for other possibilites.\\n* \\tfor checking other possibilities, we need to remove our last element and iterate from the next number. since the length of the path vector is reduced, we increment k.\\n```\\n    void helper(vector<int> &v,vector<vector<int>>&res,vector<int>& path,int &k,int start,int target)\\n    {\\n        if(target <0)\\n        {\\n            return;\\n        }\\n        if(k==0 && target==0)\\n        {\\n            res.push_back(path);\\n            return;\\n        }\\n        for(int i=start;i<9;i++)\\n        {\\n            path.push_back(v[i]);\\n            helper(v,res,path,--k,i+1,target-v[i]);\\n            path.pop_back();\\n            k++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> v= {1,2,3,4,5,6,7,8,9};\\n        vector<vector<int>>res;\\n        vector<int> path;\\n        if(k==0) return res;\\n        helper(v,res,path,k,0,n);\\n        return res;\\n    }\\n```\n```\\n    void helper(vector<int> &v,vector<vector<int>>&res,vector<int>& path,int &k,int start,int target)\\n    {\\n        if(target <0)\\n        {\\n            return;\\n        }\\n        if(k==0 && target==0)\\n        {\\n            res.push_back(path);\\n            return;\\n        }\\n        for(int i=start;i<9;i++)\\n        {\\n            path.push_back(v[i]);\\n            helper(v,res,path,--k,i+1,target-v[i]);\\n            path.pop_back();\\n            k++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1283367,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n     List<List<Integer>> result=new ArrayList<>();\\n        recur(1,k,n,new ArrayList(),result);\\n        return result;\\n    }\\n    public void recur(int start,int k,int n,List<Integer> list,List<List<Integer>> result)\\n    {\\n        if(k<0 || n<0)\\n            return;\\n        if(k==0 && n==0)\\n        {\\n            result.add(new ArrayList(list));\\n        }\\n        for(int i=start;i<=9;i++)\\n        {\\n            list.add(i);\\n            recur(i+1,k-1,n-i,list,result);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n     List<List<Integer>> result=new ArrayList<>();\\n        recur(1,k,n,new ArrayList(),result);\\n        return result;\\n    }\\n    public void recur(int start,int k,int n,List<Integer> list,List<List<Integer>> result)\\n    {\\n        if(k<0 || n<0)\\n            return;\\n        if(k==0 && n==0)\\n        {\\n            result.add(new ArrayList(list));\\n        }\\n        for(int i=start;i<=9;i++)\\n        {\\n            list.add(i);\\n            recur(i+1,k-1,n-i,list,result);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1229801,
                "title": "c-super-short-dp",
                "content": "Solve Coin Change II first. The approach is the same.\\n\\n```\\nvector<vector<int>> combinationSum3(int k, int n) \\n{\\n\\tvector<vector<vector<int>>> dp(n + 1);\\n\\tdp[0].push_back(vector<int>());\\n\\n\\tfor (int i = 1; i <= 9; ++i)\\n\\t\\tfor (int j = i; j <= n; ++j)\\n\\t\\t\\tfor (auto arr : dp[j - i])\\n\\t\\t\\t\\tif (arr.size() < k && (j < n || arr.size() == k - 1) && (arr.empty() || arr.back() != i))\\n\\t\\t\\t\\t\\tdp[j].push_back(arr),\\n\\t\\t\\t\\t\\tdp[j].back().push_back(i);\\n\\n\\treturn dp[n];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> combinationSum3(int k, int n) \\n{\\n\\tvector<vector<vector<int>>> dp(n + 1);\\n\\tdp[0].push_back(vector<int>());\\n\\n\\tfor (int i = 1; i <= 9; ++i)\\n\\t\\tfor (int j = i; j <= n; ++j)\\n\\t\\t\\tfor (auto arr : dp[j - i])\\n\\t\\t\\t\\tif (arr.size() < k && (j < n || arr.size() == k - 1) && (arr.empty() || arr.back() != i))\\n\\t\\t\\t\\t\\tdp[j].push_back(arr),\\n\\t\\t\\t\\t\\tdp[j].back().push_back(i);\\n\\n\\treturn dp[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1197346,
                "title": "java-backtracking-beats-100-0ms-t-c-o-1-s-c-o-1",
                "content": "\\t// Backtracking\\n\\t// O(9^k)/O(1) O(k)/O(1)\\n\\tpublic List<List<Integer>> combinationSum3(int k, int n) {\\n\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\tList<Integer> temp = new ArrayList<>();\\n\\t\\tboolean[] map = new boolean[10];\\n\\t\\tcombinationSum3Helper(k, n, map, 0, ans, temp, 0);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// Backtracking\\n\\t// O(9^k)/O(1) O(k)/O(1)\\n\\tpublic void combinationSum3Helper(int k, int n, boolean[] map, int curr, List<List<Integer>> ans,\\n\\t\\t\\tList<Integer> temp, int last) {\\n\\n\\t\\tif (k == 0 && curr == n) {\\n\\t\\t\\tans.add(new ArrayList<>(temp));\\n\\t\\t\\treturn;\\n\\t\\t} else if (k == 0 && curr != n)\\n\\t\\t\\treturn;\\n\\n\\t\\tfor (int i = last + 1; i <= 9; i++) {\\n\\t\\t\\tif (!map[i]) {\\n\\t\\t\\t\\tmap[i] = true;\\n\\t\\t\\t\\ttemp.add(i);\\n\\t\\t\\t\\tcombinationSum3Helper(k - 1, n, map, curr + i, ans, temp, i);\\n\\t\\t\\t\\tmap[i] = false;\\n\\t\\t\\t\\ttemp.remove(temp.size() - 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "\\t// Backtracking\\n\\t// O(9^k)/O(1) O(k)/O(1)\\n\\tpublic List<List<Integer>> combinationSum3(int k, int n) {\\n\\n\\t\\tList<List<Integer>> ans = new ArrayList<>();\\n\\t\\tList<Integer> temp = new ArrayList<>();\\n\\t\\tboolean[] map = new boolean[10];\\n\\t\\tcombinationSum3Helper(k, n, map, 0, ans, temp, 0);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// Backtracking\\n\\t// O(9^k)/O(1) O(k)/O(1)\\n\\tpublic void combinationSum3Helper(int k, int n, boolean[] map, int curr, List<List<Integer>> ans,\\n\\t\\t\\tList<Integer> temp, int last) {\\n\\n\\t\\tif (k == 0 && curr == n) {\\n\\t\\t\\tans.add(new ArrayList<>(temp));\\n\\t\\t\\treturn;\\n\\t\\t} else if (k == 0 && curr != n)\\n\\t\\t\\treturn;\\n\\n\\t\\tfor (int i = last + 1; i <= 9; i++) {\\n\\t\\t\\tif (!map[i]) {\\n\\t\\t\\t\\tmap[i] = true;\\n\\t\\t\\t\\ttemp.add(i);\\n\\t\\t\\t\\tcombinationSum3Helper(k - 1, n, map, curr + i, ans, temp, i);\\n\\t\\t\\t\\tmap[i] = false;\\n\\t\\t\\t\\ttemp.remove(temp.size() - 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1197081,
                "title": "c-simple-solution-using-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    void help(vector<int>&number, int strt, int &k, int &target, vector<int>&V, int sum)\\n    {\\n        if(sum == target and k == V.size())\\n        {\\n            ans.push_back(V);\\n            return;\\n        }\\n        \\n        if(strt == number.size())\\n            return;\\n        \\n        if(V.size() >= k)\\n            return;\\n        \\n        for(int i=strt; i<number.size(); i++)\\n        {\\n            if(sum + number[i] <= target)\\n            {\\n                V.push_back(number[i]);\\n                help(number, i+1, k, target, V, sum + number[i]);\\n                V.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int> number={1,2,3,4,5,6,7,8,9};\\n        \\n        vector<int>V;\\n        \\n        help(number, 0, k, n, V, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    void help(vector<int>&number, int strt, int &k, int &target, vector<int>&V, int sum)\\n    {\\n        if(sum == target and k == V.size())\\n        {\\n            ans.push_back(V);\\n            return;\\n        }\\n        \\n        if(strt == number.size())\\n            return;\\n        \\n        if(V.size() >= k)\\n            return;\\n        \\n        for(int i=strt; i<number.size(); i++)\\n        {\\n            if(sum + number[i] <= target)\\n            {\\n                V.push_back(number[i]);\\n                help(number, i+1, k, target, V, sum + number[i]);\\n                V.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int> number={1,2,3,4,5,6,7,8,9};\\n        \\n        vector<int>V;\\n        \\n        help(number, 0, k, n, V, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012810,
                "title": "easy-to-understand-100-faster-backtracking",
                "content": "class Solution {\\npublic:\\n    \\n    void check(vector<vector<int>>& ans,vector<int>& vec,int target,int k,int st){\\n        \\n        if(target<0 || vec.size()>k)           //base condition\\n\\t\\t\\treturn;                                    \\n        \\n        if(target==0 && vec.size()==k)    //base condition for successful combination\\n            ans.push_back(vec);\\n        \\n        for(int i=st;i<10;i++){\\n            vec.push_back(i);\\n            check(ans,vec,target-i,k,i+1);     \\n            vec.pop_back();                       //Backtrack\\n        }\\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<vector<int>> ans;\\n        vector<int>vec;\\n        \\n        check(ans,vec,n,k,1);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void check(vector<vector<int>>& ans,vector<int>& vec,int target,int k,int st){\\n        \\n        if(target<0 || vec.size()>k)           //base condition\\n\\t\\t\\treturn;                                    \\n        \\n        if(target==0 && vec.size()==k)    //base condition for successful combination\\n            ans.push_back(vec);\\n        \\n        for(int i=st;i<10;i++){\\n            vec.push_back(i);\\n            check(ans,vec,target-i,k,i+1);     \\n            vec.pop_back();                       //Backtrack\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 993838,
                "title": "clean-code-using-backtracking",
                "content": "class Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        \\n     int[] arr=new int[9];\\n        arr[0]=1;\\n        arr[1]=2;\\n        arr[2]=3;\\n        arr[3]=4;\\n        arr[4]=5;\\n        arr[5]=6;\\n        arr[6]=7;\\n        arr[7]=8;\\n        arr[8]=9;\\n     List<List<Integer>> ans=new ArrayList<>();\\n        rec(arr,k,0,n,0,new ArrayList<Integer>(),ans);\\n        return ans;\\n    }\\n    \\n    public void rec(int[] cd, int k,int idx, int tgt,int depth,List<Integer> temp,List<List<Integer>> ans){\\n        \\n        if(tgt<0 || depth>k)\\n            return;\\n        \\n        if(tgt==0){\\n            if(depth==k)\\n            ans.add(new ArrayList<Integer>(temp));\\n            return;\\n        }\\n        \\n        for(int i=idx;i<cd.length;i++){\\n                  \\n             temp.add(cd[i]);\\n             rec(cd,k,i+1,tgt-cd[i],depth+1,temp,ans);\\n             temp.remove(temp.size()-1);\\n               \\n        }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        \\n     int[] arr=new int[9];\\n        arr[0]=1;\\n        arr[1]=2;\\n        arr[2]=3;\\n        arr[3]=4;\\n        arr[4]=5;\\n        arr[5]=6;\\n        arr[6]=7;\\n        arr[7]=8;\\n        arr[8]=9;\\n     List<List<Integer>> ans=new ArrayList<>();\\n        rec(arr,k,0,n,0,new ArrayList<Integer>(),ans);\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 843873,
                "title": "java-combination-sum-iii-recursion-include-exclude",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        \\n        List<List<Integer>> result=new ArrayList<>();\\n        \\n        findCombinations(1, k, n, new ArrayList<Integer>(), result);\\n        \\n        return result;\\n    }\\n    \\n    private void findCombinations(int currNum, int listSize, int target, List<Integer> currList,  List<List<Integer>> result){\\n        \\n        if(target==0 && currList.size() == listSize){\\n            \\n            List<Integer> list= new ArrayList<>();\\n            list.addAll(currList);\\n            \\n            result.add(list);\\n            return;\\n        }\\n        \\n        if(currList.size() == listSize || target<0 || currNum==10) return;\\n        \\n        currList.add(currNum);\\n        findCombinations(currNum+1, listSize, target-currNum, currList, result);\\n        currList.remove(currList.size()-1);\\n        \\n        findCombinations(currNum+1, listSize, target, currList, result);\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        \\n        List<List<Integer>> result=new ArrayList<>();\\n        \\n        findCombinations(1, k, n, new ArrayList<Integer>(), result);\\n        \\n        return result;\\n    }\\n    \\n    private void findCombinations(int currNum, int listSize, int target, List<Integer> currList,  List<List<Integer>> result){\\n        \\n        if(target==0 && currList.size() == listSize){\\n            \\n            List<Integer> list= new ArrayList<>();\\n            list.addAll(currList);\\n            \\n            result.add(list);\\n            return;\\n        }\\n        \\n        if(currList.size() == listSize || target<0 || currNum==10) return;\\n        \\n        currList.add(currNum);\\n        findCombinations(currNum+1, listSize, target-currNum, currList, result);\\n        currList.remove(currList.size()-1);\\n        \\n        findCombinations(currNum+1, listSize, target, currList, result);\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843460,
                "title": "simplest-backtracking-solution-with-comments-c",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void solve(int k , int n , vector<int> current , int index , int sum){\\n        \\n        if(k==0 and n==0){  //base case 1 : if k==0 and sum is exhausted than we have our required solution\\n            result.push_back(current); \\n            return ;                \\n        }\\n        \\n        if(k==0){        //base case 2: if k is exhausted but the sum is less or more , return from here\\n            return ;\\n        }\\n        \\n        for(int i=index ;i<=9 ; i++){  //choose numbers from 1 to 9\\n            \\n            if(n<=sum){  //if the current sum is less than the required sum than only include the element\\n                current.push_back(i);\\n                solve(k-1,n-i,current,i+1,sum); //subtract k by 1 , subtract current sum by included element , check for next element\\n            }\\n                \\n            current.pop_back(); //backtrack from here as either our current sum has exceeded the sum required or we have reached our solution and we want to explore more possibilites so remove last element  from the current vector\\n        }\\n        \\n        \\n    }\\n    \\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        if(k==0 || n==0) return {};  //if k==0 or n==0 return 0\\n        int sum = n;\\n        solve(k,n,{},1,sum);\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> result;\\n    \\n    void solve(int k , int n , vector<int> current , int index , int sum){\\n        \\n        if(k==0 and n==0){  //base case 1 : if k==0 and sum is exhausted than we have our required solution\\n            result.push_back(current); \\n            return ;                \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 843371,
                "title": "combination-sum-iii-java-solution-beats-100-in-runtime-backtracking",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> ans;\\n    public void findAns(int curNo, int curSum, int targetSum, int targetSize,\\n                       ArrayList<Integer> curSet){\\n        if((curNo >= 10) || \\n           (targetSum <= curSum) || (curSet.size() >= targetSize)){\\n            if((curSet.size() == targetSize) && (targetSum == curSum)){\\n                ans.add(new ArrayList<Integer>(curSet));\\n            }\\n        }else{\\n            //do not include current element in set\\n            findAns(curNo+1, curSum, targetSum, targetSize, curSet);\\n            //include current element in set\\n            curSet.add(curNo);\\n            findAns(curNo+1, curSum + curNo , targetSum, targetSize, curSet);\\n            //backtrack\\n            curSet.remove(curSet.size()-1);\\n        }\\n    }\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        ans = new ArrayList<List<Integer>>();\\n        findAns(1, 0, n, k, new ArrayList<Integer>());\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> ans;\\n    public void findAns(int curNo, int curSum, int targetSum, int targetSize,\\n                       ArrayList<Integer> curSet){\\n        if((curNo >= 10) || \\n           (targetSum <= curSum) || (curSet.size() >= targetSize)){\\n            if((curSet.size() == targetSize) && (targetSum == curSum)){\\n                ans.add(new ArrayList<Integer>(curSet));\\n            }\\n        }else{\\n            //do not include current element in set\\n            findAns(curNo+1, curSum, targetSum, targetSize, curSet);\\n            //include current element in set\\n            curSet.add(curNo);\\n            findAns(curNo+1, curSum + curNo , targetSum, targetSize, curSet);\\n            //backtrack\\n            curSet.remove(curSet.size()-1);\\n        }\\n    }\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        ans = new ArrayList<List<Integer>>();\\n        findAns(1, 0, n, k, new ArrayList<Integer>());\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843290,
                "title": "c-combination-sum-iii-share-my-backtracking-solution",
                "content": "Generally, my solution is not fastest but easy to understand.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> sub(0);\\n        \\n        solve(sub, 0, k, n);\\n        return res;\\n    }\\n    void solve(vector<int> &sub, int be, int k, int n){\\n        if( n == 0 && k == 0 ){\\n            res.push_back(sub);\\n            return;\\n        }\\n        if( n < 0 || k < 0){\\n            return; \\n        }\\n        for(int i = be + 1; i <= 9; ++i){\\n            vector<int> ne = sub;\\n            ne.push_back(i);\\n            solve(ne, i, k-1, n-i);\\n        }\\n    }\\n    \\nprivate:\\n    vector< vector<int> > res;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        vector<int> sub(0);\\n        \\n        solve(sub, 0, k, n);\\n        return res;\\n    }\\n    void solve(vector<int> &sub, int be, int k, int n){\\n        if( n == 0 && k == 0 ){\\n            res.push_back(sub);\\n            return;\\n        }\\n        if( n < 0 || k < 0){\\n            return; \\n        }\\n        for(int i = be + 1; i <= 9; ++i){\\n            vector<int> ne = sub;\\n            ne.push_back(i);\\n            solve(ne, i, k-1, n-i);\\n        }\\n    }\\n    \\nprivate:\\n    vector< vector<int> > res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843173,
                "title": "a-few-solutions",
                "content": "DFS + BT to find all and return candidate `paths` of cardinality `K` and total `T`.\\n\\n---\\n\\n**Similiar Problems:**\\n\\n* [39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/506331/a-few-solutions)\\n* [40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/506360/a-few-solutions)\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun combinationSum3(K: Int, T: Int): List<List<Int>> {\\n        var paths = mutableListOf<List<Int>>()\\n        fun go(start: Int = 1, t: Int = 0, path: MutableList<Int> = mutableListOf<Int>()) {\\n            if (path.size == K) {\\n                if (t == T)\\n                    paths.add(path.toList())\\n                return\\n            }\\n            for (x in start..9) {\\n                path.add(x)\\n                go(x + 1, t + x, path)\\n                path.removeAt(path.lastIndex)\\n            }\\n        }\\n        go()\\n        return paths\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet combinationSum3 = (K, T, paths = []) => {\\n    let go = (start = 1, t = 0, path = []) => {\\n        if (path.length == K) {\\n            if (t == T)\\n                paths.push([...path]);\\n            return;\\n        }\\n        for (let x = start; x <= 9; ++x)\\n            go(x + 1, t + x, path.concat(x));\\n    };\\n    go();\\n    return paths;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def combinationSum3(self, K: int, T: int) -> List[List[int]]:\\n        paths = []\\n        def go(start = 1, t = 0, path = []):\\n            if len(path) == K:\\n                if t == T:\\n                    paths.append(path[:])\\n            for x in range(start, 9 + 1):\\n                go(x + 1, t + x, path + [x])\\n        go()\\n        return paths\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nimpl Solution {\\n    pub fn combination_sum3(K: i32, T: i32) -> VVI {\\n        let mut paths = vec![];\\n        fn go(start: i32, k: i32, t: i32, path: &mut VI, paths: &mut VVI) {\\n            if k == 0 {\\n                if t == 0 {\\n                    paths.push(path.clone());\\n                }\\n                return;\\n            }\\n            for x in start..=9 {\\n                path.push(x);\\n                go(x + 1, k - 1, t - x, path, paths);\\n                path.pop();\\n            }\\n        }\\n        go(1, K, T, &mut vec![], &mut paths);\\n        return paths;\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<void(int, int, VI&&)>;\\n    VVI combinationSum3(int K, int T, VVI paths = {}) {\\n        fun go = [&](auto start, auto t, auto&& path) {\\n            if (path.size() == K) {\\n                if (t == T)\\n                    paths.emplace_back(path);\\n                return;\\n            }\\n            for (auto x{ start }; x <= 9; ++x) {\\n                path.push_back(x);\\n                go(x + 1, t + x, move(path));\\n                path.pop_back();\\n            }\\n        };\\n        go(1, 0, {});\\n        return paths;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun combinationSum3(K: Int, T: Int): List<List<Int>> {\\n        var paths = mutableListOf<List<Int>>()\\n        fun go(start: Int = 1, t: Int = 0, path: MutableList<Int> = mutableListOf<Int>()) {\\n            if (path.size == K) {\\n                if (t == T)\\n                    paths.add(path.toList())\\n                return\\n            }\\n            for (x in start..9) {\\n                path.add(x)\\n                go(x + 1, t + x, path)\\n                path.removeAt(path.lastIndex)\\n            }\\n        }\\n        go()\\n        return paths\\n    }\\n}\\n```\n```\\nlet combinationSum3 = (K, T, paths = []) => {\\n    let go = (start = 1, t = 0, path = []) => {\\n        if (path.length == K) {\\n            if (t == T)\\n                paths.push([...path]);\\n            return;\\n        }\\n        for (let x = start; x <= 9; ++x)\\n            go(x + 1, t + x, path.concat(x));\\n    };\\n    go();\\n    return paths;\\n};\\n```\n```\\nclass Solution:\\n    def combinationSum3(self, K: int, T: int) -> List[List[int]]:\\n        paths = []\\n        def go(start = 1, t = 0, path = []):\\n            if len(path) == K:\\n                if t == T:\\n                    paths.append(path[:])\\n            for x in range(start, 9 + 1):\\n                go(x + 1, t + x, path + [x])\\n        go()\\n        return paths\\n```\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nimpl Solution {\\n    pub fn combination_sum3(K: i32, T: i32) -> VVI {\\n        let mut paths = vec![];\\n        fn go(start: i32, k: i32, t: i32, path: &mut VI, paths: &mut VVI) {\\n            if k == 0 {\\n                if t == 0 {\\n                    paths.push(path.clone());\\n                }\\n                return;\\n            }\\n            for x in start..=9 {\\n                path.push(x);\\n                go(x + 1, k - 1, t - x, path, paths);\\n                path.pop();\\n            }\\n        }\\n        go(1, K, T, &mut vec![], &mut paths);\\n        return paths;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using fun = function<void(int, int, VI&&)>;\\n    VVI combinationSum3(int K, int T, VVI paths = {}) {\\n        fun go = [&](auto start, auto t, auto&& path) {\\n            if (path.size() == K) {\\n                if (t == T)\\n                    paths.emplace_back(path);\\n                return;\\n            }\\n            for (auto x{ start }; x <= 9; ++x) {\\n                path.push_back(x);\\n                go(x + 1, t + x, move(path));\\n                path.pop_back();\\n            }\\n        };\\n        go(1, 0, {});\\n        return paths;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843007,
                "title": "python-1-line-itertools-easy-to-understand",
                "content": "Function *combinations(iterable, k)*  from *itertools* returns all k-lenth combinations from s.\\n\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        return [num for num in itertools.combinations(range(1,10), k) if sum(num)==n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        return [num for num in itertools.combinations(range(1,10), k) if sum(num)==n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842624,
                "title": "python-3-backtracking-dfs-explanations",
                "content": "### Explanation\\n- Intuitively, backtracking should work with this question, since the final result depends on previous step, and there is a recursive relation between current value and next possible value\\n- Numbers in each possible combination are unique, so we can use a variable to indicate the start number to avoid repeat (`start_num`)\\n- We need to count how many numbers (`digit`) we used, combo with numbers over `k` will be disqualified \\n- `cur`: is current combo\\n- `cur_sum`: is current sum of current combo, if `cum_sum > n`, this combo will be disqualified\\n### Implementation\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(digit, start_num, cur, cur_sum):\\n            if cur_sum == n and digit == k: ans.append(cur[:])\\n            elif digit >= k or cur_sum > n: return    \\n            else:\\n                for i in range(start_num+1, 10):\\n                    cur.append(i)\\n                    dfs(digit+1, i, cur, cur_sum+i)\\n                    cur.pop()\\n        ans = list()\\n        dfs(0, 0, [], 0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(digit, start_num, cur, cur_sum):\\n            if cur_sum == n and digit == k: ans.append(cur[:])\\n            elif digit >= k or cur_sum > n: return    \\n            else:\\n                for i in range(start_num+1, 10):\\n                    cur.append(i)\\n                    dfs(digit+1, i, cur, cur_sum+i)\\n                    cur.pop()\\n        ans = list()\\n        dfs(0, 0, [], 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842615,
                "title": "combination-sum-iii-python-1-line-solution",
                "content": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        return filter(lambda x: sum(x) == n, combinations(range(1, 10), r=k))\\n```",
                "solutionTags": [],
                "code": "```\\nfrom itertools import combinations\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        return filter(lambda x: sum(x) == n, combinations(range(1, 10), r=k))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842613,
                "title": "very-simple-python-solution-using-itertools",
                "content": "```\\nimport itertools\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        \\n        allNumbers=[i for i in range(1,10)]\\n        res=[]\\n        for item in itertools.combinations(allNumbers,k):\\n            if sum(item)==n:\\n                res.append(item)\\n                \\n        return res        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport itertools\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        \\n        allNumbers=[i for i in range(1,10)]\\n        res=[]\\n        for item in itertools.combinations(allNumbers,k):\\n            if sum(item)==n:\\n                res.append(item)\\n                \\n        return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 802224,
                "title": "c-dp-coin-change-ii-analog",
                "content": "First of all, try to solve **coin change ii** problem. Here, technique is the same.\\n\\n```\\nvector<vector<int>> combinationSum3(int k, int n) \\n{\\n\\tvector<vector<unordered_set<int>>> dp(n + 1, \\n\\t\\tvector<unordered_set<int>>());\\n\\n\\tdp[0] = { unordered_set<int>() };\\n\\n\\tfor (int i = 1; i <= 9; ++i)\\n\\t\\tfor (int j = i; j <= n; ++j)\\n\\t\\t\\tfor (auto set : dp[j - i])\\n\\t\\t\\t\\tif (set.size() < k && !set.count(i))\\n\\t\\t\\t\\t\\tset.insert(i), dp[j].push_back(set);\\n\\n\\tvector<vector<int>> result;\\n\\n\\tfor (auto set : dp[n])\\n\\t\\tif (set.size() == k)\\n\\t\\t\\tresult.push_back(vector<int>(set.begin(), set.end()));\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<vector<int>> combinationSum3(int k, int n) \\n{\\n\\tvector<vector<unordered_set<int>>> dp(n + 1, \\n\\t\\tvector<unordered_set<int>>());\\n\\n\\tdp[0] = { unordered_set<int>() };\\n\\n\\tfor (int i = 1; i <= 9; ++i)\\n\\t\\tfor (int j = i; j <= n; ++j)\\n\\t\\t\\tfor (auto set : dp[j - i])\\n\\t\\t\\t\\tif (set.size() < k && !set.count(i))\\n\\t\\t\\t\\t\\tset.insert(i), dp[j].push_back(set);\\n\\n\\tvector<vector<int>> result;\\n\\n\\tfor (auto set : dp[n])\\n\\t\\tif (set.size() == k)\\n\\t\\t\\tresult.push_back(vector<int>(set.begin(), set.end()));\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 702351,
                "title": "details-in-pruning-an-optimization-for-lower-time-complexity",
                "content": "Wisely select the starting number and ending number can significantly reduece the time cost of this problem. The algorithm can be considered as growing a **tree** and find all nodes on the k-th level with a sum of n, then what we gonna do to optimize is **pruning** so that the tree would not grow too large.\\n\\nRegardless of the algorithm, dfs or bfs, it is necessary to find the next number si that it can be appended to the current unfinished combination, Let\\'s say the range is from *starting number* to *ending numbe*r.\\n\\n>**Starting number**\\nMost solutions start from the next available number, which is the currently largest number + 1. It is good enough to avoid duplicates in a combination, but not strong enough condition.  One  thing worth thinking here is: is it possible to reach the target sum pick this number?\\nIf not, it would be better to prune the combinations, whose largest possible sum does not covers current target sum.\\ne.g.\\na candidate combination is currently [1,2,x,x,x]. x\\'s are vacacies to fill, which should sum up to, say, 22\\nThe first x is the number to fill in this iteration, which is ok to start with 3 (= 2 + 1), but consider the following:\\nThe largest sum of the last two vacancies are 17 (= 9 + 8)\\nso the min start would be 5 (= 22 - 17), instead of 3 (= 2 + 1).\\nHow to calculate the start.\\nIt is quite straightforward to figure out the starting number. Simply fill the rest vacancies with the largest possible number and get the sum (arithmetic sequence). The starting number can be calculated by substracting the sum from current target.\\n\\n>**Ending number**\\n>Again it is ok to pick 9 as an end, but there are still somthing to prune.\\n>Firstly, is there enough number to finish the combination?\\n>e.g.\\n>A candidate combination is currently [3,4,x,x,x], three numbers to go. If  9 is picked here, then we have [3,4,9,x,x], there are no numbers to fill in the rest two vacancies. Instead, the max number to pick in this iteration is 7, so that the rest two can be 8 and 9.\\n>Secondly, is the current picked number too large for the current target sum?\\n>e.g.\\n>A candidate combination is currently [1,2,x,x,x], current target sum to go is 16, which means the rest three vacanies sum up to 16. If we pick 5 as the next nmber, then the sequence with the least sum with be [1,2,5,6,7], the sum of vacancies is 18 (= 5 + 6 + 7) > 16, so the ending number here is 4, so that the lesat-sum sequenc would be [1,2,4,5,6], with 4 + 5 + 6 = 15 < 16.\\n>Whichever of the two upper limits is smaller, we take it.\\n\\nAn snippet in python implementing BFS is below.\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        # bfs optimzied by pruning, \\n\\t\\t\\n        MIN_NUM = 1\\n        MAX_NUM = 9\\n        q = [([], n)]\\n        level = 0\\n        \\n        while level < k:\\n            next_level = []\\n            for path, target in q:\\n                # avoid duplicate numbers in a combination\\n                lower_limit_1 = path[-1] + 1 if path else MIN_NUM\\n                # guarantee the largest sum covers target (larger than target)\\n                lower_limit_2 = target - (2 * MAX_NUM - k + level + 2) * (k - level - 1) // 2\\n                # guarantee enough numbers to finish the sequence\\n                upper_limit_1 = MAX_NUM + 1 - k + level\\n                # guarantee the least sum does not overflow (no larger than target)\\n                upper_limit_2 = int(target / (k - level) - (k - level - 1) / 2)\\n                \\n                lower_limit = max(lower_limit_1, lower_limit_2)\\n                upper_limit = min(upper_limit_1, upper_limit_2)\\n                \\n                for num in range(lower_limit, upper_limit + 1): # upper_limit + 1 for right exlusive\\n                    next_level.append((path + [num], target - num))\\n            \\n            level += 1\\n            q = next_level\\n            \\n        return [path for path, target in q if target == 0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        # bfs optimzied by pruning, \\n\\t\\t\\n        MIN_NUM = 1\\n        MAX_NUM = 9\\n        q = [([], n)]\\n        level = 0\\n        \\n        while level < k:\\n            next_level = []\\n            for path, target in q:\\n                # avoid duplicate numbers in a combination\\n                lower_limit_1 = path[-1] + 1 if path else MIN_NUM\\n                # guarantee the largest sum covers target (larger than target)\\n                lower_limit_2 = target - (2 * MAX_NUM - k + level + 2) * (k - level - 1) // 2\\n                # guarantee enough numbers to finish the sequence\\n                upper_limit_1 = MAX_NUM + 1 - k + level\\n                # guarantee the least sum does not overflow (no larger than target)\\n                upper_limit_2 = int(target / (k - level) - (k - level - 1) / 2)\\n                \\n                lower_limit = max(lower_limit_1, lower_limit_2)\\n                upper_limit = min(upper_limit_1, upper_limit_2)\\n                \\n                for num in range(lower_limit, upper_limit + 1): # upper_limit + 1 for right exlusive\\n                    next_level.append((path + [num], target - num))\\n            \\n            level += 1\\n            q = next_level\\n            \\n        return [path for path, target in q if target == 0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 689915,
                "title": "python-backtracking-easy-solution",
                "content": "Runtime: 32 ms, faster than 65.87% of Python3 online submissions for Combination Sum III.\\nMemory Usage: 13.6 MB, less than 94.07% of Python3 online submissions for Combination Sum III.\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        self.k, self.n, self.res = k, n, []\\n        self.backtrack([i+1 for i in range(9)], [], 0)\\n        return self.res\\n    \\n    def backtrack(self, nums, current, start):\\n        if len(current) == self.k and sum(current) == self.n:\\n            self.res.append(current)\\n            return\\n        if len(current) == self.k or sum(current) == self.n:\\n            return\\n        for i in range(start, len(nums)):\\n            self.backtrack(nums, current + [nums[i]], i + 1)",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "Runtime: 32 ms, faster than 65.87% of Python3 online submissions for Combination Sum III.\\nMemory Usage: 13.6 MB, less than 94.07% of Python3 online submissions for Combination Sum III.\\n```\\nclass Solution:\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        self.k, self.n, self.res = k, n, []\\n        self.backtrack([i+1 for i in range(9)], [], 0)\\n        return self.res\\n    \\n    def backtrack(self, nums, current, start):\\n        if len(current) == self.k and sum(current) == self.n:\\n            self.res.append(current)\\n            return\\n        if len(current) == self.k or sum(current) == self.n:\\n            return\\n        for i in range(start, len(nums)):\\n            self.backtrack(nums, current + [nums[i]], i + 1)",
                "codeTag": "Java"
            },
            {
                "id": 645100,
                "title": "java-simple-solution-beats-100-of-java-submissions-with-explanation",
                "content": "Time complexity is O (9^k) since that\\'s the number of solutions one can have but actual runtime should be less as there is actually only (n-k) possible numbers to place.\\n\\nThe main idea is to build these combinations through the recursive calls. We start with an empty list as combination. We will try adding the next possible unique number (by keeping track of `currNum`) and `remain` will keep track of how much more we need to add to reach the sum n. Once `remain` is 0 and we have reached the required number of `k` integers to form the sum, we will add it to the `results` list.\\nWe will only continue building the combination if the `remain` can be satisfied by the next possible number `currNum`. If not, we will stop building this specific combination since if it won\\'t be satisified by the `currNum`, it sure won\\'t be satisfied for the next possible numbers that are greater than `currNum`.\\n\\nNote: We can save further space by not making new list `copy` of the combination to pass into the recursive calls and instead, add it to a single list and backtrack by removing it after the recursive call returns. However, to make this solution simpler and easier to to understand, I used copied lists.\\n\\nThanks for reading and would appreciate any feedback!\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> results = new ArrayList<>();\\n        makeComb(1, n, new ArrayList<Integer>(), k, results);\\n        return results;\\n    }\\n    \\n    private void makeComb(int currNum, int remain, List<Integer> comb, int k, List<List<Integer>> results) {\\n        if (remain == 0 && comb.size() == k) {\\n            results.add(comb);\\n        } else if (remain >= currNum) {\\n            for (int i = currNum; i <= 9;i++) {\\n                List<Integer> copy = new ArrayList<>(comb);\\n                copy.add(i);\\n                makeComb(i + 1, remain - i, copy, k, results);\\n            }\\n        }\\n    }\\n}\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> results = new ArrayList<>();\\n        makeComb(1, n, new ArrayList<Integer>(), k, results);\\n        return results;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 619055,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\n    void combinationSum3Util(vector<int>nums, int l, int k, int n, vector<int>& v,\\n                            vector<vector<int>>& ans) {\\n        \\n        if (v.size() == k && n == 0) {\\n            ans.push_back(v);\\n            return;\\n        }\\n        \\n        for (int i = l; i < nums.size(); i++) {\\n            v.push_back(nums[i]);\\n            combinationSum3Util(nums, i+1, k, n-nums[i], v, ans);\\n            v.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>nums;\\n        for (int i = 1; i <= 9; i++)\\n            nums.push_back(i);\\n        \\n        vector<int>v;\\n        vector<vector<int>>ans;\\n        \\n        combinationSum3Util(nums, 0, k, n, v, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void combinationSum3Util(vector<int>nums, int l, int k, int n, vector<int>& v,\\n                            vector<vector<int>>& ans) {\\n        \\n        if (v.size() == k && n == 0) {\\n            ans.push_back(v);\\n            return;\\n        }\\n        \\n        for (int i = l; i < nums.size(); i++) {\\n            v.push_back(nums[i]);\\n            combinationSum3Util(nums, i+1, k, n-nums[i], v, ans);\\n            v.pop_back();\\n        }\\n    }\\npublic:\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>nums;\\n        for (int i = 1; i <= 9; i++)\\n            nums.push_back(i);\\n        \\n        vector<int>v;\\n        vector<vector<int>>ans;\\n        \\n        combinationSum3Util(nums, 0, k, n, v, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547111,
                "title": "go-golang-0ms-solution",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Combination Sum III.\\nMemory Usage: 2 MB, less than 100.00% of Go online submissions for Combination Sum III.\\n\\n```go\\nfunc combinationSum3(k int, n int) [][]int {\\n    ans := [][]int{}\\n    helper(k, n, 1, []int{}, &ans)\\n    return ans\\n}\\n\\nfunc helper(k, n, i int, cur []int, ans *[][]int) {\\n    if k < 0 || n < 0 { return }\\n    if k == 0 && n == 0 { *ans = append(*ans, append([]int{}, cur...)); return }\\n    for j := i; j <= 9; j++ { helper(k - 1, n - j, j + 1, append(cur, j), ans) }\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc combinationSum3(k int, n int) [][]int {\\n    ans := [][]int{}\\n    helper(k, n, 1, []int{}, &ans)\\n    return ans\\n}\\n\\nfunc helper(k, n, i int, cur []int, ans *[][]int) {\\n    if k < 0 || n < 0 { return }\\n    if k == 0 && n == 0 { *ans = append(*ans, append([]int{}, cur...)); return }\\n    for j := i; j <= 9; j++ { helper(k - 1, n - j, j + 1, append(cur, j), ans) }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 391725,
                "title": "java-backtracking-solution-beats-100-with-explains",
                "content": "```\\npublic List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if(n>45) return ans;  //we can use only onece for element 1->9 so maximun n must be 45\\n        helper(ans,new ArrayList<>(),n,1,k,n);\\n        return ans;\\n    }\\n    public void helper(List<List<Integer>> ans,List<Integer> one,int target,int start,int k,int n){\\n        if(target==0 && one.size()==k){\\n            ans.add(new ArrayList<>(one));\\n            return;\\n        }\\n        for(int i=start;i<=9;i++){\\n            if(target<i) return; // if target less than i , we do not need to go on anymore \\n            one.add(i);\\n            helper(ans,one,target-i,i+1,k,n);\\n            one.remove(one.size()-1);\\n        }\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> combinationSum3(int k, int n) {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if(n>45) return ans;  //we can use only onece for element 1->9 so maximun n must be 45\\n        helper(ans,new ArrayList<>(),n,1,k,n);\\n        return ans;\\n    }\\n    public void helper(List<List<Integer>> ans,List<Integer> one,int target,int start,int k,int n){\\n        if(target==0 && one.size()==k){\\n            ans.add(new ArrayList<>(one));\\n            return;\\n        }\\n        for(int i=start;i<=9;i++){\\n            if(target<i) return; // if target less than i , we do not need to go on anymore \\n            one.add(i);\\n            helper(ans,one,target-i,i+1,k,n);\\n            one.remove(one.size()-1);\\n        }\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565816,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1565528,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1566487,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1929270,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1570873,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1745508,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1576291,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1567920,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 2029637,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1742692,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1565816,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1565528,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1566487,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1929270,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1570873,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1745508,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1576291,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1567920,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 2029637,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1742692,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/combination-sum-iii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "zhou.jiang",
                        "content": "when I provide the input k = 1, n = 100, the oj gives me the answer [[100]]. I think it is not correct, cause we can only use number 1-9. Any comment?"
                    },
                    {
                        "username": "sid_1164",
                        "content": "in problem constrain is given as : 1 <= n <= 60"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705Easy Backtracking Code || Beats 100%\\uD83D\\uDD25 || AMAZON SDE-1 Interview\\u26A0\\uFE0F\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/2997421/easy-backtracking-code-beats-100-amazon-sde-1-interview/?orderBy=hot"
                    },
                    {
                        "username": "momo_92",
                        "content": "The expected answer is [[10]]. Should it be []?"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "\\nGiven number lies between 1-9 inclusively.\\nStep1: make an array which store number from 1 to 9.\\nStep2: declare vector of vector int for answer.\\ndeclare vector of int for storing the intermediate subsequence.\\nStep3: Call the recursion. having array,currentIndex,SizeOfArray,ansVector,tempVector,k,n.\\nStep4: base condition if index reached the end of sizeOfArray.\\ncheck given n==0 and size of temp is equal given size.\\nStep5: if yes store the temp in ans. return.\\nStep6:Take the current element. Check the condition n is greater or equal to current array element.\\nStep7: if yes add the current element in temp array. \\nstep8: call recursion on next index. decrease k by current value of array element.\\nStep9: pop the last element added in temp array.Step(7 & 9 ) is backtracking. If step 6 satisfy then do step(7to9).\\nStep10: call the recursion without adding the current index to temp. just increase the current index.\\n\\n# Complexity\\n- Time complexity:\\nO(2^n)\\n\\n- Space complexity:\\nS.c=O(9). temp of k is used again and again. Answer vector is not considered in space complexity.\\n\\nPlease Upvote. If Understand the Concept....\\nSolution link:\\nhttps://leetcode.com/problems/combination-sum-iii/solutions/3637571/c-recursion-backtracking-understand-concept/"
                    },
                    {
                        "username": "psionl0",
                        "content": "\"Step5: if yes store the temp in ans. return.\"\\nI think you mean store a COPY of temp in ans. The backtracking process will continue to modify temp."
                    },
                    {
                        "username": "AnEmos82",
                        "content": "yes you are correct but it can be further optimized"
                    },
                    {
                        "username": "Tobias47",
                        "content": "The method must return IList<IList\\\\<int>> but I can\\'t return List<List\\\\<int>> even though List implements IList. What is wrong with this language?"
                    },
                    {
                        "username": "AvineshPandey",
                        "content": "can we solve this using graph by making k edges for each node and then perform from each node something like that ?"
                    },
                    {
                        "username": "subhasishhalder107",
                        "content": "![image](https://assets.leetcode.com/users/images/5936204a-8c85-47b4-9ec7-e94b08930ad5_1643182096.588056.jpeg)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "david120",
                        "content": "\\tdef combinationSum3(self, k, n, start=1):\\n\\t\\treturn [[i]+c for i in xrange(start,10)\\tfor c in self.combinationSum3(k-1,n-i,i+1)]\\n                   if k > 1 else [[], [[n]]][start<=n<=9]\\n\\nNot very readable, but it was fun to collapse my code down to \"one line\"."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sapna002153",
                        "content": "can anyone explain when k=2,n=18 expected output is empty\\nbut it should be [[1,17],[2,16],[3,15],[4,14],[5,13],[6,12],[7,11],[8,10]]"
                    },
                    {
                        "username": "sapna002153",
                        "content": "[@tbarry98](/tbarry98) thnks"
                    },
                    {
                        "username": "tbarry98",
                        "content": "Yes, the answer should be empty because the problem description states that \"Only numbers 1 through 9 are used\", so in this case you cannot have a number bigger than 9 like you have 17 there, that\\'s wrong.  You could have [9,9] (which is a number between 1-9) but you can\\'t also get a duplicated answer like that. So the correct answer is empty array[]. "
                    },
                    {
                        "username": "kayastmayank",
                        "content": "class Solution {\\n     public List<List<Integer>> combinationSum3(int k, int n) {\\n    List<List<Integer>> ans = new ArrayList<>();\\n    combination(ans, new ArrayList<Integer>(), k, 1, n);\\n    return ans;\\n}\\n\\nprivate void combination(List<List<Integer>> ans, List<Integer> comb, int k,  int start, int n) {\\n\\tif (comb.size() == k && n == 0) {\\n\\t\\tList<Integer> li = new ArrayList<Integer>(comb);\\n\\t\\tans.add(li);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int i = start; i <= 9; i++) {\\n\\t\\tcomb.add(i);\\n\\t\\tcombination(ans, comb, k, i+1, n-i);\\n\\t\\tcomb.remove(comb.size() - 1);\\n\\t}\\n}\\n} \\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    }
                ]
            },
            {
                "id": 1572630,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1572584,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1572349,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1571444,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2054065,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1995843,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1988755,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1839590,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1823663,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1757524,
                "content": [
                    {
                        "username": "jjiang28",
                        "content": "I don\\'t know what algorithm the system use for this question. But when I try n=1 k=20, it give me the output [[20]], which is not correct. Please fixed it. Thank you."
                    },
                    {
                        "username": "user4550C",
                        "content": "since the number are from 1-9,  k and n are limited. can i say the time complexity is O(1)"
                    },
                    {
                        "username": "ejxqy",
                        "content": "the expected output should be [], not [[100]]\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655078.png)\\nthis case is right...\\n![image](https://assets.leetcode.com/users/ejxqy/image_1545655088.png)\\n"
                    },
                    {
                        "username": "deadEternally",
                        "content": "Question says combination sets are unique, not that numbers in each set are also unique. It is not apparent that sets like {1, 1, 2} are not to be used."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Can be done using brute force recursion, checking to see if every possible combination of k numbers between 1 to 9 is equal to n."
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "If someone could tell me what\\'s wrong with my code, it would be greatly appreciated!! \\uD83D\\uDE4F\\n(Only passed 6 test cases \\uD83E\\uDD72)\\n\\n```\\ndef combinationSum3(self, k, n):\\n        result = []\\n\\n        def backtrack(start, comb, total):\\n            if total == n and len(comb) == k:\\n                result.append(comb)\\n                return\\n            \\n            if start > 9 or total > n or len(comb) > k:\\n                return\\n            \\n            for i in range(start, 10):\\n                comb.append(i)\\n                backtrack(i+1, comb, total + i)\\n                comb.pop()\\n        \\n        backtrack(1, [], 0)\\n        return result\\n```"
                    },
                    {
                        "username": "sunruiheng",
                        "content": "You're passing around references to objects which are intended to remain at a certain state, but later on you change the state and don't realise your previous answers have been changed. I'm talking about the comb list. When you do result.append(comb), you are passing a reference to the list to the result, but later on in the program you still do more things to the same list such as comb.append(...).\nYou need to change \"result.append(comb)\" to \"result.append(list(comb))\".\nlist(comb) is basically making a copy of comb, with the same elements but they are now separate objects. The next time you do something to comb, the list(comb) you created won't be affected.\nNow it passes everything."
                    },
                    {
                        "username": "sunruiheng",
                        "content": "If you\\'re stuck, perhaps consider a DP-style approach: \\nIn every combination sum, either the first item (let\\'s call it t) is included, or it isn\\'t. \\nIf it is included, we can k-- and n-=t, and recurse. \\nIf it\\'s excluded, we can remove t from our potential list of numbers and recurse. \\nFinally, the full list is the sum of combinations where t is included and combinations where t is excluded.\\n\\nFor a further hint, here\\'s a snippet:\\nq = whatsleft.pop()\\nreturn [comb + [q] for comb in func(k - 1, n - q, whatsleft.copy())] + func(k, n, whatsleft.copy())"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fast code:-\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\npick and choose different suitable combination form all combination\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbacktracing \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(N)\\n# Code\\n```\\n//find useful upvote it vro :)\\nclass Solution {\\npublic: \\nvector<vector<int>>answer;\\n void help( vector<int>&curr ,int index ,int count, int k , int n)\\n {\\n      if( count==k && n==0)\\n      {\\n           answer.push_back( curr);\\n           return ;\\n      }\\n\\n    if( count>k)\\n    {\\n         return;\\n    }\\n\\n    for( int i = index ; i< 10 ; i++)\\n    {\\n        if( n <i)\\n        {\\n            break;\\n        }\\n\\n        curr.push_back(i);\\n         help(curr , i+1 , count+1 , k ,n-i);\\n         curr.pop_back();\\n         \\n    }\\n    return ;\\n }\\n    vector<vector<int>> combinationSum3(int k, int n) {\\n        \\n        vector<int>curr;\\n    help(curr , 1,0 ,k ,n);\\n        return answer;\\n    }\\n};\\n\\n\\n\\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great... but what exactly do you want to discuss here in discussion section where people wait for tips?"
                    },
                    {
                        "username": "sharpsailor",
                        "content": "FIgured out how to solve the sum of elements problem but still not able to figure out how to remove duplicacy..\nAfter adding elements in the list I am not able to think how I can move to next unique element in iteration and add it to the list.\nMy output for the testcase 1\n[[1,2,4],1,3,3],[2,2,3]]\nDrop your suggestions"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            }
        ]
    },
    {
        "title": "Remove Duplicate Letters",
        "question_content": "<p>Given a string <code>s</code>, remove duplicate letters so that every letter appears once and only once. You must make sure your result is <span data-keyword=\"lexicographically-smaller-string\"><strong>the smallest in lexicographical order</strong></span> among all possible results.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bcabc&quot;\n<strong>Output:</strong> &quot;abc&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;cbacdcbc&quot;\n<strong>Output:</strong> &quot;acdb&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Note:</strong> This question is the same as 1081: <a href=\"https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/\" target=\"_blank\">https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/</a></p>\n",
        "solutions": [
            {
                "id": 1859410,
                "title": "java-c-detailed-visually-explained",
                "content": "How\\'s going Ladies - n - Gentlemen, today we are going to solve another coolest problem i.e. **Remove Duplicate Letters**\\n\\n```\\nWhat the problem statement is saying,\\n\\nGiven a string s, remove duplicate letters so that every letter appears once and only once. \\nYou must make sure your result is the smallest in lexicographical order among all possible results.\\n```\\n\\n`Let\\'s take one example in order to understand it:-`\\n**Input** :- \"cbacdcbc\"\\n**Output** :- \"acdb\"\\n\\n<hr>\\n\\nNow, your first Question is which **Data Structure do we use in order to solve this problem??** `Well, let\\'s have a look at the input firstOfAll`\\n\\nFirst Of all, we have to pick the character\\'s if it is not already visited. If, that\\'s the case we\\'ll try to pick these character\\'s. We\\'ll also make sure, the previously picked character is smaller then the current character in order to maintain **lexicographically order**. But, how we can check the previously picked character is best for!! **And the answer is Stack!!**\\n\\n<hr>\\n\\nWhat we\\'ll do, use the **stack** to keep track of selected character\\'s. We try to put the character\\'s only once & maintain the `lexicographicall smallest one`. **So, how we do that :-**\\n* If the stack is empty, we\\'ll put the **current character into our stack**\\n* We\\'ll also keep here **`boolean array`** which will mark, whether we have seen this character or not. So, that if we are getting again the same character and we have already seen that. We\\'ll ignore that character.\\n* So, the length of **boolean array** will be **26**\\n\\n***Let\\'s Undertsand it\\'s working***\\n\\n* First we put character `c` into our stack and mark it as true\\n\\n\\n* Then we come to next character i.e. `b` we check is **`b < c`** to maintain lexicographically order. Yes `b` is samller then `c` we\\'ll remove it from the stack.\\n* But before removing we have to check that, is `c` more present in our string. So, how will we quickly check that for that we\\'ll keep one more Array which will keep track of last index of all the character\\'s present in our string\\n* So, we see that `c` exists on 7th index.\\n* We\\'ll remove `c` from the stack & don\\'t forgot to mark `c` in boolean array from **true to false** \\n* Now add `b` into our stack. ANd mark `b` in boolean array as true\\n* Now next character is `a` which is smaller then `b` & do the same process of checking if it exists somewhere in array & if so, remove it from stack update boolean to false. And put `a` into the stack. And in boolean array mark it as true.\\n* Let\\'s add `c` in the stack mark it as true & `c > a` so carry on....\\n* Let\\'s add `d` in the stack mark it as true & `d > c` so carry on....\\n* Now we encounter `c` which is already visited so, carry on....\\n* Let\\'s add `b` in the stack mark it as true & `b < d` so carry on....\\n```\\nThis, line explanation : BY @nirala_414\\n\\n\"now try to add \"b\" in the stack and mark it as true, for this since the current_element(\"b\") is less than\\nthe peek(top) element of stack(\"d\")so we should pop the \"d\" for now and push \"b\" in stack but before \\npoping \"d\" check is there \"d\" is again persent in given string after this \"b\" , since \"d\" is not more \\npersent after this \"b\" so we can\\'t do that pop and push operation for \"d\" and \"b\" respectively , simply \\nadd \"b\" into the stack and mark is as true that\\'s set, but in some case if \"d\" is available again after \\nthat \"b\" then we will definitely be poping \"d\" from the stack and adding \"b\" into the stack( we can take \\nexample for this case as \"cbadcbcd\" and try to dry run it )\\n```\\n* Now we encounter `c` which is already visited so, carry on....\\n* End of the string.\\n\\nNow whatever character we have present in our stack, take them out. i.e. **`bdca`** now reverse it **`acdb`** and this is our smallest lexicographically string\\n\\n`Let\\'s understand it visually :-` You can download all the images from here [**G-Drive**](https://drive.google.com/drive/folders/1ZmVXpG5uFqFHm_f6GXC78_3pmwkcaxNP?usp=sharing)\\n\\n![image](https://assets.leetcode.com/users/images/20260c29-2873-4002-b1a1-5479f5d3eca3_1647569488.8472958.gif)\\n\\n*I hope you got it* **Let\\'s code it up:-**\\n\\n**Java**\\n```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        int[] lastIndex = new int[26];\\n        for (int i = 0; i < s.length(); i++){\\n            lastIndex[s.charAt(i) - \\'a\\'] = i; // track the lastIndex of character presence\\n        }\\n        \\n        boolean[] seen = new boolean[26]; // keep track seen\\n        Stack<Integer> st = new Stack();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            int curr = s.charAt(i) - \\'a\\';\\n            if (seen[curr]) continue; // if seen continue as we need to pick one char only\\n            while (!st.isEmpty() && st.peek() > curr && i < lastIndex[st.peek()]){\\n                seen[st.pop()] = false; // pop out and mark unseen\\n            }\\n            st.push(curr); // add into stack\\n            seen[curr] = true; // mark seen\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        while (!st.isEmpty())\\n            sb.append((char) (st.pop() + \\'a\\'));\\n        return sb.reverse().toString();\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> lastIndex(26, 0);\\n        for (int i = 0; i < s.length(); i++){\\n            lastIndex[s[i] - \\'a\\'] = i; // track the lastIndex of character presence\\n        }\\n        \\n        vector<bool> seen(26, false); // keep track seen\\n        stack<char> st;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            int curr = s[i] - \\'a\\';\\n            if (seen[curr]) continue; // if seen continue as we need to pick one char only\\n            while(st.size() > 0 && st.top() > s[i] && i < lastIndex[st.top() - \\'a\\']){\\n                seen[st.top() - \\'a\\'] = false; // pop out and mark unseen\\n                st.pop();\\n            }\\n            st.push(s[i]); // add into stack\\n            seen[curr] = true; // mark seen\\n        }\\n        \\n        string ans = \"\";\\n        while (st.size() > 0){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(N)\\n\\n```\\nIn the End, Wishing you A Happy Holi !!\\n\\n**Bura Na Mano Holi Hn**\\n```\\n\\n![image](https://assets.leetcode.com/users/images/630ef5b1-6579-401d-b500-49215c7057b4_1647570317.032519.gif)![image](https://assets.leetcode.com/users/images/1bfdf3c9-24b2-40ef-8375-ba4aa7ff8b7f_1647572249.395173.gif)\\n\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nWhat the problem statement is saying,\\n\\nGiven a string s, remove duplicate letters so that every letter appears once and only once. \\nYou must make sure your result is the smallest in lexicographical order among all possible results.\\n```\n```\\nThis, line explanation : BY @nirala_414\\n\\n\"now try to add \"b\" in the stack and mark it as true, for this since the current_element(\"b\") is less than\\nthe peek(top) element of stack(\"d\")so we should pop the \"d\" for now and push \"b\" in stack but before \\npoping \"d\" check is there \"d\" is again persent in given string after this \"b\" , since \"d\" is not more \\npersent after this \"b\" so we can\\'t do that pop and push operation for \"d\" and \"b\" respectively , simply \\nadd \"b\" into the stack and mark is as true that\\'s set, but in some case if \"d\" is available again after \\nthat \"b\" then we will definitely be poping \"d\" from the stack and adding \"b\" into the stack( we can take \\nexample for this case as \"cbadcbcd\" and try to dry run it )\\n```\n```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        int[] lastIndex = new int[26];\\n        for (int i = 0; i < s.length(); i++){\\n            lastIndex[s.charAt(i) - \\'a\\'] = i; // track the lastIndex of character presence\\n        }\\n        \\n        boolean[] seen = new boolean[26]; // keep track seen\\n        Stack<Integer> st = new Stack();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            int curr = s.charAt(i) - \\'a\\';\\n            if (seen[curr]) continue; // if seen continue as we need to pick one char only\\n            while (!st.isEmpty() && st.peek() > curr && i < lastIndex[st.peek()]){\\n                seen[st.pop()] = false; // pop out and mark unseen\\n            }\\n            st.push(curr); // add into stack\\n            seen[curr] = true; // mark seen\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        while (!st.isEmpty())\\n            sb.append((char) (st.pop() + \\'a\\'));\\n        return sb.reverse().toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> lastIndex(26, 0);\\n        for (int i = 0; i < s.length(); i++){\\n            lastIndex[s[i] - \\'a\\'] = i; // track the lastIndex of character presence\\n        }\\n        \\n        vector<bool> seen(26, false); // keep track seen\\n        stack<char> st;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            int curr = s[i] - \\'a\\';\\n            if (seen[curr]) continue; // if seen continue as we need to pick one char only\\n            while(st.size() > 0 && st.top() > s[i] && i < lastIndex[st.top() - \\'a\\']){\\n                seen[st.top() - \\'a\\'] = false; // pop out and mark unseen\\n                st.pop();\\n            }\\n            st.push(s[i]); // add into stack\\n            seen[curr] = true; // mark seen\\n        }\\n        \\n        string ans = \"\";\\n        while (st.size() > 0){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\n```\\nIn the End, Wishing you A Happy Holi !!\\n\\n**Bura Na Mano Holi Hn**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859515,
                "title": "python-o-n-beats-98-stack-detailed-explanation-simple",
                "content": "We will be using a stack question. Approach is shown below\\n\\nlast_occ = used to capture last occurence of any character in string\\n\\n1. We traverse sequentially on the string\\n2. For each s[i], we check whether it\\'s already in stack or not \\n3. if its not in the stack, we need to push it to the stack. But we need to check another condition before pushing.\\n4. If s[i] is not in the stack (we can check using this in O(1) using a set), and it is smaller than previous elements in stack (lexicographically), and those elements are repeating in future (can check with last_occ), we need to pop these elements\\n5. Now we can push s[i] in stack\\n6. Finally just join the characters in stack to form the result\\n\\nWe are using visited set to check whether s[i] is in stack or not in O(1) time, to improve time complexity\\n\\nExample:\\ns = \\'bcabc\\'\\nlast_occ = { a : 2, b : 3, c : 4 }\\nstack trace:\\n[]\\n[ \\'b\\' ]\\n[ \\'b\\', \\'c\\' ]\\n[ \\'a\\' ]                   (b & c got popped because a < c, a < b and b and c both were gonna repeat in future)\\n[ \\'a\\' , \\'b\\' ]\\n[ \\'a\\' , \\'b\\', \\'c\\' ]\\n\\n```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        \\n\\t\\tlast_occ = {}\\n\\t\\tstack = []\\n\\t\\tvisited = set()\\n\\n\\t\\tfor i in range(len(s)):\\n\\t\\t\\tlast_occ[s[i]] = i\\n\\n\\t\\tfor i in range(len(s)):\\n\\n\\t\\t\\tif s[i] not in visited:\\n\\t\\t\\t\\twhile (stack and stack[-1] > s[i] and last_occ[stack[-1]] > i):\\n\\t\\t\\t\\t\\tvisited.remove(stack.pop())\\n\\n\\t\\t\\t\\tstack.append(s[i])\\n\\t\\t\\t\\tvisited.add(s[i])\\n\\n\\t\\treturn \\'\\'.join(stack)\\n```\\n\\n\\nThanks to [@christ7622](https://leetcode.com/christ7622/) for pointing out the correct time complexity!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        \\n\\t\\tlast_occ = {}\\n\\t\\tstack = []\\n\\t\\tvisited = set()\\n\\n\\t\\tfor i in range(len(s)):\\n\\t\\t\\tlast_occ[s[i]] = i\\n\\n\\t\\tfor i in range(len(s)):\\n\\n\\t\\t\\tif s[i] not in visited:\\n\\t\\t\\t\\twhile (stack and stack[-1] > s[i] and last_occ[stack[-1]] > i):\\n\\t\\t\\t\\t\\tvisited.remove(stack.pop())\\n\\n\\t\\t\\t\\tstack.append(s[i])\\n\\t\\t\\t\\tvisited.add(s[i])\\n\\n\\t\\treturn \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859469,
                "title": "c-easy-to-understand-explanation",
                "content": "**Appproach**\\n\\n\\nWe can use the stack to solve. When traversing the string s from left to right, we decide which characters can be deleted. Use a dictionary to record the number of occurrences of each character.\\nWhen traversing to the i-th character, we can look at the previous character of i, **assuming it is the j-th character, if s[i]<s[j], and there is s[j] after i, then s[j] can be deleted**\\n\\nIt should be noted here that if the string is bcab, the best answer is bca, and the last b should be deleted, which seems to contradict the above discussion. Therefore, we need to use a stack to record the characters we saved. \\nAfter each character is deleted, a new s will be generated, and then in this new string s, j=i-1. i.e. i and j are adjacent, the only way to ensure that s[j] deletes without throwing an error. For example, bcabc, when traversing to a, the adjacent c can be deleted. At this time, babc is formed. \\nAt this time, it is a new string a, and b can be deleted. When the string is bcab, when traversing to a, the previous b is not adjacent to a, so it cannot be deleted.\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int len = s.size();\\n        string res = \"\";\\n        unordered_map<char, int> M;\\n        unordered_map<char, bool> V;\\n        stack<int> S;\\n        \\n        for (auto c : s) {\\n            if (M.find(c) == M.end()) M[c] = 1;\\n            else M[c]++; \\n        }\\n        for (unordered_map<char, int>::iterator iter=M.begin(); iter!=M.end(); iter++) V[iter->first] = false;\\n        \\n        cout<<M.size()<<V.size()<<endl;\\n        for (int i=0; i<len; i++) {\\n            M[s[i]]--;\\n            if (V[s[i]] == true) continue;\\n            \\n            while (!S.empty() and s[i] < s[S.top()] and M[s[S.top()]] > 0) {\\n                V[s[S.top()]] = false;\\n                S.pop();\\n            }\\n            S.push(i);\\n            V[s[i]] = true;\\n        }\\n        while (!S.empty()) {\\n            res = s[S.top()] + res;\\n            S.pop();\\n        }\\n        return res;\\n    }\\n};\\n\\n\\nAnalysis\\nTime complexity O(n)\\nspace complexity O(n)",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int len = s.size();\\n        string res = \"\";\\n        unordered_map<char, int> M;\\n        unordered_map<char, bool> V;\\n        stack<int> S;\\n        \\n        for (auto c : s) {\\n            if (M.find(c) == M.end()) M[c] = 1;\\n            else M[c]++; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 76769,
                "title": "java-solution-using-stack-with-comments",
                "content": "    public String removeDuplicateLetters(String sr) {\\n    \\n        int[] res = new int[26]; //will contain number of occurences of character (i+'a')\\n        boolean[] visited = new boolean[26]; //will contain if character (i+'a') is present in current result Stack\\n        char[] ch = sr.toCharArray();\\n        for(char c: ch){  //count number of occurences of character \\n            res[c-'a']++;\\n        }\\n        Stack<Character> st = new Stack<>(); // answer stack\\n        int index;\\n        for(char s:ch){ \\n            index= s-'a';\\n            res[index]--;   //decrement number of characters remaining in the string to be analysed\\n            if(visited[index]) //if character is already present in stack, dont bother\\n                continue;\\n            //if current character is smaller than last character in stack which occurs later in the string again\\n            //it can be removed and  added later e.g stack = bc remaining string abc then a can pop b and then c\\n            while(!st.isEmpty() && s<st.peek() && res[st.peek()-'a']!=0){ \\n                visited[st.pop()-'a']=false;\\n            }\\n            st.push(s); //add current character and mark it as visited\\n            visited[index]=true;\\n        }\\n    \\n        StringBuilder sb = new StringBuilder();\\n        //pop character from stack and build answer string from back\\n        while(!st.isEmpty()){\\n            sb.insert(0,st.pop());\\n        }\\n        return sb.toString();\\n    }",
                "solutionTags": [],
                "code": "    public String removeDuplicateLetters(String sr) {\\n    \\n        int[] res = new int[26]; //will contain number of occurences of character (i+'a')\\n        boolean[] visited = new boolean[26]; //will contain if character (i+'a') is present in current result Stack\\n        char[] ch = sr.toCharArray();\\n        for(char c: ch){  //count number of occurences of character \\n            res[c-'a']++;\\n        }\\n        Stack<Character> st = new Stack<>(); // answer stack\\n        int index;\\n        for(char s:ch){ \\n            index= s-'a';\\n            res[index]--;   //decrement number of characters remaining in the string to be analysed\\n            if(visited[index]) //if character is already present in stack, dont bother\\n                continue;\\n            //if current character is smaller than last character in stack which occurs later in the string again\\n            //it can be removed and  added later e.g stack = bc remaining string abc then a can pop b and then c\\n            while(!st.isEmpty() && s<st.peek() && res[st.peek()-'a']!=0){ \\n                visited[st.pop()-'a']=false;\\n            }\\n            st.push(s); //add current character and mark it as visited\\n            visited[index]=true;\\n        }\\n    \\n        StringBuilder sb = new StringBuilder();\\n        //pop character from stack and build answer string from back\\n        while(!st.isEmpty()){\\n            sb.insert(0,st.pop());\\n        }\\n        return sb.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 76768,
                "title": "a-short-o-n-recursive-greedy-solution",
                "content": "Given the string s, the greedy choice (i.e., the leftmost letter in the answer) is the smallest s[i], s.t.\\nthe suffix s[i .. ] contains all the unique letters. (Note that, when there are more than one smallest s[i]'s, we choose the leftmost one. Why? Simply consider the example: \"abcacb\".)\\n\\nAfter determining the greedy choice s[i], we get a new string s' from s by \\n\\n 1. removing all letters to the left of s[i],\\n 2. removing all s[i]'s from s.\\n\\nWe then recursively solve the problem w.r.t. s'. \\n\\nThe runtime is O(26 * n) = O(n).\\n\\n    public class Solution {\\n        public String removeDuplicateLetters(String s) {\\n            int[] cnt = new int[26];\\n            int pos = 0; // the position for the smallest s[i]\\n            for (int i = 0; i < s.length(); i++) cnt[s.charAt(i) - 'a']++;\\n            for (int i = 0; i < s.length(); i++) {\\n                if (s.charAt(i) < s.charAt(pos)) pos = i;\\n                if (--cnt[s.charAt(i) - 'a'] == 0) break;\\n            }\\n            return s.length() == 0 ? \"\" : s.charAt(pos) + removeDuplicateLetters(s.substring(pos + 1).replaceAll(\"\" + s.charAt(pos), \"\"));\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n        public String removeDuplicateLetters(String s) {\\n            int[] cnt = new int[26];\\n            int pos = 0; // the position for the smallest s[i]\\n            for (int i = 0; i < s.length(); i++) cnt[s.charAt(i) - 'a']++;\\n            for (int i = 0; i < s.length(); i++) {\\n                if (s.charAt(i) < s.charAt(pos)) pos = i;\\n                if (--cnt[s.charAt(i) - 'a'] == 0) break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 76767,
                "title": "c-simple-solution-easy-understanding",
                "content": "    string removeDuplicateLetters(string s) {\\n        vector<int> cand(256, 0);\\n        vector<bool> visited(256, false);\\n        for (char c : s)\\n            cand[c]++;\\n        string result = \"0\";\\n        for (char c : s) {\\n            cand[c]--;\\n            if (visited[c]) continue;\\n            while (c < result.back() && cand[result.back()]) {\\n                visited[result.back()] = false;\\n                result.pop_back();\\n            }\\n            result += c;\\n            visited[c] = true;\\n        }\\n        return result.substr(1);\\n    }",
                "solutionTags": [],
                "code": "    string removeDuplicateLetters(string s) {\\n        vector<int> cand(256, 0);\\n        vector<bool> visited(256, false);\\n        for (char c : s)\\n            cand[c]++;\\n        string result = \"0\";\\n        for (char c : s) {\\n            cand[c]--;\\n            if (visited[c]) continue;\\n            while (c < result.back() && cand[result.back()]) {\\n                visited[result.back()] = false;\\n                result.pop_back();\\n            }\\n            result += c;\\n            visited[c] = true;\\n        }\\n        return result.substr(1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 76762,
                "title": "java-o-n-solution-using-stack-with-detail-explanation",
                "content": "First, given `\"bcabc\"`, the solution should be `\"abc\"`.  If we think about this problem intuitively, you would sort of go from the beginning of the string and start removing one if there is still the same character left and a smaller character is after it.  Given `\"bcabc\"`, when you see a `'b'`, keep it and continue with the search, then keep the following `'c'`, then we see an `'a'`.  Now we get a chance to get a smaller lexi order, you can check if after `'a'`, there is still `'b'` and `'c'` or not.  We indeed have them and `\"abc\"` will be our result.  \\n\\nCome to the implementation, we need some data structure to store the previous characters `'b'` and `'c'`, and we need to compare the current character with previous saved ones, and if there are multiple same characters, we prefer left ones.  This calls for a stack.  \\n\\nAfter we decided to use stack, the implementation becomes clearer.  From the intuition, we know that we need to know if there are still remaining characters left or not.  So we need to iterate the array and save how many each characters are there.  A visited array is also required since we want unique character in the solution.  The line `while(!stack.isEmpty() && stack.peek() > c && count[stack.peek()-'a'] > 0)` checks that the queued character should be removed or not, like the `'b'` and `'c'` in the previous example.  After removing the previous characters, push in the new char and mark the visited array. \\n\\nTime complexity:  O(n), n is the number of chars in string.\\n\\nSpace complexity:  O(n) worst case.\\n\\n\\n    public String removeDuplicateLetters(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int[] count = new int[26];\\n        char[] arr = s.toCharArray();\\n        for(char c : arr) {\\n            count[c-'a']++;\\n        }\\n        boolean[] visited = new boolean[26];\\n        for(char c : arr) {\\n            count[c-'a']--;\\n            if(visited[c-'a']) {\\n                continue;\\n            }\\n            while(!stack.isEmpty() && stack.peek() > c && count[stack.peek()-'a'] > 0) {\\n                visited[stack.peek()-'a'] = false;\\n                stack.pop();\\n            }\\n            stack.push(c);\\n            visited[c-'a'] = true;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(char c : stack) {\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "First, given `\"bcabc\"`, the solution should be `\"abc\"`.  If we think about this problem intuitively, you would sort of go from the beginning of the string and start removing one if there is still the same character left and a smaller character is after it.  Given `\"bcabc\"`, when you see a `'b'`, keep it and continue with the search, then keep the following `'c'`, then we see an `'a'`.  Now we get a chance to get a smaller lexi order, you can check if after `'a'`, there is still `'b'` and `'c'` or not.  We indeed have them and `\"abc\"` will be our result.  \\n\\nCome to the implementation, we need some data structure to store the previous characters `'b'` and `'c'`, and we need to compare the current character with previous saved ones, and if there are multiple same characters, we prefer left ones.  This calls for a stack.  \\n\\nAfter we decided to use stack, the implementation becomes clearer.  From the intuition, we know that we need to know if there are still remaining characters left or not.  So we need to iterate the array and save how many each characters are there.  A visited array is also required since we want unique character in the solution.  The line `while(!stack.isEmpty() && stack.peek() > c && count[stack.peek()-'a'] > 0)` checks that the queued character should be removed or not, like the `'b'` and `'c'` in the previous example.  After removing the previous characters, push in the new char and mark the visited array. \\n\\nTime complexity:  O(n), n is the number of chars in string.\\n\\nSpace complexity:  O(n) worst case.\\n\\n\\n    public String removeDuplicateLetters(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int[] count = new int[26];\\n        char[] arr = s.toCharArray();\\n        for(char c : arr) {\\n            count[c-'a']++;\\n        }\\n        boolean[] visited = new boolean[26];\\n        for(char c : arr) {\\n            count[c-'a']--;\\n            if(visited[c-'a']) {\\n                continue;\\n            }\\n            while(!stack.isEmpty() && stack.peek() > c && count[stack.peek()-'a'] > 0) {\\n                visited[stack.peek()-'a'] = false;\\n                stack.pop();\\n            }\\n            stack.push(c);\\n            visited[c-'a'] = true;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(char c : stack) {\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 76766,
                "title": "easy-to-understand-iterative-java-solution",
                "content": "The basic idea is to find out the smallest result letter by letter (one letter at a time). Here is the thinking process for input \"cbacdcbc\":\\n\\n1. find out the last appeared position for each letter;\\n    c - 7\\n    b - 6\\n    a - 2\\n    d - 4\\n2. find out the smallest index from the map in step 1 (a - 2);\\n3. the first letter in the final result must be the smallest letter from index 0 to index 2;\\n4. repeat step 2 to 3 to find out remaining letters.\\n\\n- the smallest letter from index 0 to index 2: a\\n- the smallest letter from index 3 to index 4: c\\n- the smallest letter from index 4 to index 4: d\\n- the smallest letter from index 5 to index 6: b\\n\\nso the result is \"acdb\"\\n\\nNotes:\\n\\n- after one letter is determined in step 3, it need to be removed from the \"last appeared position map\", and the same letter should be ignored in the following steps\\n- in step 3, the beginning index of the search range should be the index of previous determined letter plus one\\n\\n----\\n\\n    public class Solution {\\n    \\n        public String removeDuplicateLetters(String s) {\\n            if (s == null || s.length() <= 1) return s;\\n    \\n            Map<Character, Integer> lastPosMap = new HashMap<>();\\n            for (int i = 0; i < s.length(); i++) {\\n                lastPosMap.put(s.charAt(i), i);\\n            }\\n    \\n            char[] result = new char[lastPosMap.size()];\\n            int begin = 0, end = findMinLastPos(lastPosMap);\\n    \\n            for (int i = 0; i < result.length; i++) {\\n                char minChar = 'z' + 1;\\n                for (int k = begin; k <= end; k++) {\\n                    if (lastPosMap.containsKey(s.charAt(k)) && s.charAt(k) < minChar) {\\n                        minChar = s.charAt(k);\\n                        begin = k+1;\\n                    }\\n                }\\n    \\n                result[i] = minChar;\\n                if (i == result.length-1) break;\\n    \\n                lastPosMap.remove(minChar);\\n                if (s.charAt(end) == minChar) end = findMinLastPos(lastPosMap);\\n            }\\n    \\n            return new String(result);\\n        }\\n    \\n        private int findMinLastPos(Map<Character, Integer> lastPosMap) {\\n            if (lastPosMap == null || lastPosMap.isEmpty()) return -1;\\n            int minLastPos = Integer.MAX_VALUE;\\n            for (int lastPos : lastPosMap.values()) {\\n                 minLastPos = Math.min(minLastPos, lastPos);\\n            }\\n            return minLastPos;\\n        }\\n    \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n        public String removeDuplicateLetters(String s) {\\n            if (s == null || s.length() <= 1) return s;\\n    \\n            Map<Character, Integer> lastPosMap = new HashMap<>();\\n            for (int i = 0; i < s.length(); i++) {\\n                lastPosMap.put(s.charAt(i), i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1859332,
                "title": "c-monotonic-stack-easy-simple-o-n",
                "content": "\\n# 316. Remove Duplicate Letters\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. cnt & visited array/vector approach with initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n``` ```\\n[LeetCode](http://github.com/knockcat/Leetcode) **LINK TO LEETCODE REPOSITORY**\\n``` ```\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**Intution**\\n\\n1. The task is to return the **lexically smallest string of unique characters**.\\n1. Or the smallest string which **do not contain any repetition of characters and it is the smallest** in terms of lexical order.\\n1. **eg adbcabcd**  , here we have 2 a\\'s , b\\'s and c\\'s and d\\'s ( **all have 2 frequency**)\\n1. We have to return a **string which contain all the characters and is the smallest one** above eg have two possible strings.\\n1. adbc and abcd and abcd is the smallest in lexical order. Again this is the simpler eg but you can imagine complex eg .\\n1. The only point is to return the smallest unique lexical characters string.\\n\\n1. Now, this is what the problems want us to do, Hope this is clear now.\\n\\n Now **how we can come up with the lexical smallest unique characters string ?**\\n\\n\\tTHere are 2 observations\\n1. to maintain the smallest lexical order **if the current character is smaller than your last added** character than obviously **you will try to bring it at its correct position** but  **we have to maintain the order too** ( we have to return lexically smallest among all possible result).\\n\\n1. now since the current character is smaller you will pop the character you have added so far till you bring current it into its correct position but now **you will only pop the character if you have occurences of the character that you want to pop in future** because **if there are no occurences of your last added characters you cannot pop** as all unique chaaracters should be there. so in this case you have to keep this character you cannot pop because it has no upcoming occurences.\\n\\n1. so we will use the concept of **monotonic stack** it **helps in maintaing an increasing or decreasing sequence** in this problem we are maintain increasing sequence but apart from this we cannot say we will maintain an complete increasing sequence since there is one more condition that all characters has to be there.\\n\\n**for eg for the case        [d a b c]**\\n* we have to keep d since it has no future occurences so here we will not be able to maintain a complete increasing sequence. That can be possible if we have occurences of elements in future.\\n\\n* So **we will scan the string and if at some instance we find the current character is smaller we will pop** the characters **until there occurences are available or curr character comes at it right place** and with that we will able to keep the string lexically smaller.\\n\\n*  and we can also thing this problem not in terms of occrences but the **only about the last occurence of some character** like **if you want to pop an character you will see that have you crossed it last occurence or not**, if you have not you will definitely able to add it in future otherwise you cannot make string more lexically smallest.\\n\\nNow if the idea is clear to you, you can do in any way, either keeping only the last occurence track or frequency I have done the frequency way.\\n\\n* now what i have done, i **store all the frequency of character.**\\n* Then i have kept **a visited array to keep track that i am not adding the same character again.**\\n* now, I am first **decrementing the frequency** because **i will be adding that character if it is not already added.**\\n* if the **curr character is not visited** that **means i had to add** that character to its current position so if my **ans string is not empty** and the current character is greater than last added charater there is no problem.\\n* but, **if the curr character is smaller** than i will **check if the occurences of last characters is available** if that the case, i will **pop those  last characters until my current comes to correct position and mark them unvisited because i have to add them in future.**\\n* if **frequency is not available that mean I have to keep that**, because **that is the only lexical  smaller string which will be containing all the characters.**\\n* after I finish this steps whatever the case, I will **add the character and also marks is visited..**\\n\\n**Now don\\'t think that the stack data structure is not used since we did the same this using ans string.**\\n\\nANALYSIS :-\\n\\n* TIME COMPLEXITY :-  **O(N)**\\n* SPACE COMPLEXITY :- **O(N)**\\n\\n\\n\\n**CODE WITH EXPLANATION**\\n\\t\\t\\t\\n```\\n\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        // cnt for storing frequency of characters\\n        // vis for marking visited characters\\n        vector<int> cnt(26,0)  , vis(26,0);\\n        \\n        string res = \"\";\\n        int n = s.size();\\n        \\n        for(int i = 0; i<n; ++i)\\n            cnt[s[i] - \\'a\\']++;\\n        \\n        for(int i = 0; i<n; ++i)\\n        {\\n            // decrease cnt of current character\\n            cnt[s[i] - \\'a\\']--;\\n            \\n            // If character is not already\\n            // in answer\\n            if(!vis[s[i]- \\'a\\'])\\n            {\\n                // Last character > s[i]\\n                // and its count > 0\\n                while(res.size() > 0 && res.back() > s[i] && cnt[res.back() - \\'a\\'] > 0)\\n                {\\n                    // marking letter visited\\n                    vis[res.back() - \\'a\\'] = 0;\\n                    res.pop_back();\\n                }\\n                \\n                // Add s[i] in res and\\n                // mark it visited\\n                res += s[i];\\n                vis[s[i] - \\'a\\'] = 1;\\n            }\\n        }\\n        // return resultant string\\n        return res;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. cnt & visited array/vector approach with initution.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n``` ```\n``` ```\n```\\n\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        // cnt for storing frequency of characters\\n        // vis for marking visited characters\\n        vector<int> cnt(26,0)  , vis(26,0);\\n        \\n        string res = \"\";\\n        int n = s.size();\\n        \\n        for(int i = 0; i<n; ++i)\\n            cnt[s[i] - \\'a\\']++;\\n        \\n        for(int i = 0; i<n; ++i)\\n        {\\n            // decrease cnt of current character\\n            cnt[s[i] - \\'a\\']--;\\n            \\n            // If character is not already\\n            // in answer\\n            if(!vis[s[i]- \\'a\\'])\\n            {\\n                // Last character > s[i]\\n                // and its count > 0\\n                while(res.size() > 0 && res.back() > s[i] && cnt[res.back() - \\'a\\'] > 0)\\n                {\\n                    // marking letter visited\\n                    vis[res.back() - \\'a\\'] = 0;\\n                    res.pop_back();\\n                }\\n                \\n                // Add s[i] in res and\\n                // mark it visited\\n                res += s[i];\\n                vis[s[i] - \\'a\\'] = 1;\\n            }\\n        }\\n        // return resultant string\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889477,
                "title": "python-o-n-greedy-with-stack-explained",
                "content": "Let us try to build our answer in greedy way: we take letter by letter and put them into stack: if we have next letter which decreased lexicographical order of string, we remove it from stack and put new letter. However we need to be careful: if we remove some letter from stack and it was the last occurence, then we failed: we can not finish this process. So, we need to do the following:\\n\\n1. Find `last_occ`: last occurences for each letter in our string\\n2. Initialize our `stack` either as empty or with symbol, which is less than any letter (\\'!\\' in my case), so we do not need to deal with the case of empty stack. Also initialize `Visited` as empty set.\\n3. Iterate over our string and if we already have symbol in `Visited`, we just continue.\\n4. Then, we try to remove elements from the top of our stack: we do it, if new symbol is less than previous and also if last occurence of last symbol is more than `i`: it means that we have removed symbol later in our string, so if we remove it we will not fail to constract full string.\\n5. Append new symbol to our stack and mark it as visited.\\n6. Finally, return string built from our stack.\\n\\n**Complexity**: Time complexity is `O(n)`, because we iterate our string once. Space complexity is `O(26)`, because it will be the longest size of our stack and answer.\\n\\n```\\nclass Solution:\\n    def removeDuplicateLetters(self, s):\\n        last_occ = {c: i for i, c in enumerate(s)}\\n        stack = [\"!\"]\\n        Visited = set()\\n        \\n        for i, symbol in enumerate(s):\\n            if symbol in Visited: continue\\n            \\n            while (symbol < stack[-1] and last_occ[stack[-1]] > i):\\n                Visited.remove(stack.pop())\\n           \\n            stack.append(symbol)\\n            Visited.add(symbol)        \\n        return \"\".join(stack)[1:]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicateLetters(self, s):\\n        last_occ = {c: i for i, c in enumerate(s)}\\n        stack = [\"!\"]\\n        Visited = set()\\n        \\n        for i, symbol in enumerate(s):\\n            if symbol in Visited: continue\\n            \\n            while (symbol < stack[-1] and last_occ[stack[-1]] > i):\\n                Visited.remove(stack.pop())\\n           \\n            stack.append(symbol)\\n            Visited.add(symbol)        \\n        return \"\".join(stack)[1:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76787,
                "title": "some-python-solutions",
                "content": "Solutions inspired by those of others. Simpler but less efficient (all still get accepted, of course, in about 50 to 100 ms, normal for Python).\\n\\n---\\n\\n**Solution 1**\\n\\nInspired by [lixx2100's explanation](https://leetcode.com/discuss/73761/a-short-o-n-recursive-greedy-solution).\\n\\n    def removeDuplicateLetters(self, s):\\n        for c in sorted(set(s)):\\n            suffix = s[s.index(c):]\\n            if set(suffix) == set(s):\\n                return c + self.removeDuplicateLetters(suffix.replace(c, ''))\\n        return ''\\n\\n---\\n\\n**Solution 2**\\n\\nInspired by [WHJ425's explanation](https://leetcode.com/discuss/73777/easy-to-understand-iterative-java-solution).\\n\\n    def removeDuplicateLetters(self, s):\\n        result = ''\\n        while s:\\n            i = min(map(s.rindex, set(s)))\\n            c = min(s[:i+1])\\n            result += c\\n            s = s[s.index(c):].replace(c, '')\\n        return result\\n\\n---\\n\\n**Solution 3**\\n\\nInspired by [halibut735's solution](https://leetcode.com/discuss/73824/short-16ms-solution-using-stack-which-can-optimized-down-4ms).\\n\\n    def removeDuplicateLetters(self, s):\\n        rindex = {c: i for i, c in enumerate(s)}\\n        result = ''\\n        for i, c in enumerate(s):\\n            if c not in result:\\n                while c < result[-1:] and i < rindex[result[-1]]:\\n                    result = result[:-1]\\n                result += c\\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "Solutions inspired by those of others. Simpler but less efficient (all still get accepted, of course, in about 50 to 100 ms, normal for Python).\\n\\n---\\n\\n**Solution 1**\\n\\nInspired by [lixx2100's explanation](https://leetcode.com/discuss/73761/a-short-o-n-recursive-greedy-solution).\\n\\n    def removeDuplicateLetters(self, s):\\n        for c in sorted(set(s)):\\n            suffix = s[s.index(c):]\\n            if set(suffix) == set(s):\\n                return c + self.removeDuplicateLetters(suffix.replace(c, ''))\\n        return ''\\n\\n---\\n\\n**Solution 2**\\n\\nInspired by [WHJ425's explanation](https://leetcode.com/discuss/73777/easy-to-understand-iterative-java-solution).\\n\\n    def removeDuplicateLetters(self, s):\\n        result = ''\\n        while s:\\n            i = min(map(s.rindex, set(s)))\\n            c = min(s[:i+1])\\n            result += c\\n            s = s[s.index(c):].replace(c, '')\\n        return result\\n\\n---\\n\\n**Solution 3**\\n\\nInspired by [halibut735's solution](https://leetcode.com/discuss/73824/short-16ms-solution-using-stack-which-can-optimized-down-4ms).\\n\\n    def removeDuplicateLetters(self, s):\\n        rindex = {c: i for i, c in enumerate(s)}\\n        result = ''\\n        for i, c in enumerate(s):\\n            if c not in result:\\n                while c < result[-1:] and i < rindex[result[-1]]:\\n                    result = result[:-1]\\n                result += c\\n        return result",
                "codeTag": "Python3"
            },
            {
                "id": 340721,
                "title": "python-readable-code-with-comments",
                "content": "**Explanation**\\n``last_index``  is a mapping from character to its last appearing index\\n``cur_result``  stores current result\\n\\nWhen ``cur_result`` is not empty, ``cur_result[-1]`` represents the last element of current result,\\nif the current character ``ch`` is smaller than ``cur_result[-1]``  and we have another ``cur_result[-1]`` in the subsequent string i.e. `i < last_index[cur_result[-1]]`, we need to pop the last element from the current result.\\n**Example**\\nSay our  input s is `\\'bcabc\\'`.\\n`last_index` would be\\n```\\nlast_index = {\\n\\t\\'b\\': 3,\\n\\t\\'c\\': 4,\\n\\t\\'a\\':2\\n}\\n```\\nWhen `i` = 2, `cur_result` is ` [\\'bc\\']`, current character `ch` is `\\'a\\'`. \\nAs `\\'a\\'` is smaller than `\\'c\\'` and `i` is smaller than `last_index[\\'c\\']`, we pop `\\'c\\'` from `cur_result`, then `cur_result` becomes ` [\\'b\\']`. Similarly,  we pop `\\'b\\'` as well. At the end of this iteration, we add current character `a` into the `cur_result`  resulting in `[\\'a\\']`.\\n```\\ndef removeDuplicateLetters(self, s):\\n\\t\"\"\"\\n\\t:type s: str\\n\\t:rtype: str\\n\\t\"\"\"\\n\\tlast_index = {}\\n\\tfor index, ch in enumerate(s):\\n\\t\\tlast_index[ch] = index \\n\\tcur_result = []\\n\\tfor i, ch in enumerate(s):\\n\\t\\tif ch not in cur_result:\\n\\t\\t\\twhile cur_result and ch < cur_result[-1] and i < last_index[cur_result[-1]]:\\n\\t\\t\\t\\tcur_result.pop()\\n\\t\\t\\tcur_result.append(ch)\\n\\treturn \\'\\'.join(cur_result)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nlast_index = {\\n\\t\\'b\\': 3,\\n\\t\\'c\\': 4,\\n\\t\\'a\\':2\\n}\\n```\n```\\ndef removeDuplicateLetters(self, s):\\n\\t\"\"\"\\n\\t:type s: str\\n\\t:rtype: str\\n\\t\"\"\"\\n\\tlast_index = {}\\n\\tfor index, ch in enumerate(s):\\n\\t\\tlast_index[ch] = index \\n\\tcur_result = []\\n\\tfor i, ch in enumerate(s):\\n\\t\\tif ch not in cur_result:\\n\\t\\t\\twhile cur_result and ch < cur_result[-1] and i < last_index[cur_result[-1]]:\\n\\t\\t\\t\\tcur_result.pop()\\n\\t\\t\\tcur_result.append(ch)\\n\\treturn \\'\\'.join(cur_result)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 890511,
                "title": "remove-duplicate-letters-java-c-o-n",
                "content": "In order to make the result \"the smallest in lexicographical order\", a character should appear before others character bigger than it if possilbe.  \\n\\n* If a char A is already added, let\\'s check the next one in string s.  \\n* If the char is not added, we need to do the following steps and add it. \\n\\t* If the last char B in the currently result is bigger than A and there are still B in string s after A,  we can remove B. \\n\\t* Let\\'s keep doing this until the current reult is empty or the last char is smaller than A.  \\n\\t* We can add A now.\\n* Let\\'s keep doing this till the end of the string\\n\\n\\nFor this example \"bcacb\"\\n\\n1. Step 1: the stack is empty, add \\'b\\'. current string: \"b\"\\n2. Step 2: \\'c\\' is bigger than \\'b\\', add it to stack.  current string: \"bc\"\\n3. Step 3: \\'a\\' is smaller than \\'c\\', there is still \\'c\\' after this \\'a\\'. so pop it.  The same for \\'b\\' as well.  So pop it. current string: \"a\"\\n4. Step 4: \\'c\\' is bigger than \\'a\\', add it to stack.  current string: \"ac\"\\n5. Step 5: \\'b\\' is smaller than \\'c\", howerver, there is no \\'c\\' after \\'b\\'.  We can\\'t pop \\'c\\', add \\'b\\'. current string: \"acb\"\\n\\nSo the result is \\'acb\\'\\n\\nIf you like it, please upvote it.  Thanks. \\n\\n![image](https://assets.leetcode.com/users/images/5113bd9b-c3b3-4629-b68b-7f173d7e5c68_1602460985.9961107.png)\\n\\njava\\n\\n```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        Deque<Character> stack = new ArrayDeque<>();\\n        int [] lastPos = new int [26]; // the last position of the char\\n        boolean [] added = new boolean [26]; // if the char is added to the result\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            lastPos[s.charAt(i) - \\'a\\'] = i; \\n        }\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            char c = s.charAt(i);\\n            if (added[c - \\'a\\']) continue;\\n            while (!stack.isEmpty() && stack.peek() > c && lastPos[stack.peek() - \\'a\\'] > i)\\n            {\\n                added[stack.peek() - \\'a\\'] = false;\\n                stack.pop();\\n            }\\n            added[c-\\'a\\'] = true;\\n            stack.push(c);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while (!stack.isEmpty())\\n        {\\n            sb.append(stack.pollLast());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n\\nc++\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        string res=\"\";\\n        int lastPos[26] = {}; // the last position of the char\\n        bool added[26] = {};  // if the char is added to the result\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            lastPos[s[i] - \\'a\\'] = i;\\n        }\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (added[s[i] - \\'a\\']) continue;\\n            while ( !res.empty() && res.back() > s[i] && lastPos[res.back() - \\'a\\'] > i)\\n            {\\n                added[res.back() - \\'a\\'] = false;\\n                res.pop_back();\\n            }\\n            res.push_back(s[i]);\\n            added[s[i] - \\'a\\'] = true;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        Deque<Character> stack = new ArrayDeque<>();\\n        int [] lastPos = new int [26]; // the last position of the char\\n        boolean [] added = new boolean [26]; // if the char is added to the result\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            lastPos[s.charAt(i) - \\'a\\'] = i; \\n        }\\n        for (int i = 0; i < s.length(); i++)\\n        {\\n            char c = s.charAt(i);\\n            if (added[c - \\'a\\']) continue;\\n            while (!stack.isEmpty() && stack.peek() > c && lastPos[stack.peek() - \\'a\\'] > i)\\n            {\\n                added[stack.peek() - \\'a\\'] = false;\\n                stack.pop();\\n            }\\n            added[c-\\'a\\'] = true;\\n            stack.push(c);\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while (!stack.isEmpty())\\n        {\\n            sb.append(stack.pollLast());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        string res=\"\";\\n        int lastPos[26] = {}; // the last position of the char\\n        bool added[26] = {};  // if the char is added to the result\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            lastPos[s[i] - \\'a\\'] = i;\\n        }\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (added[s[i] - \\'a\\']) continue;\\n            while ( !res.empty() && res.back() > s[i] && lastPos[res.back() - \\'a\\'] > i)\\n            {\\n                added[res.back() - \\'a\\'] = false;\\n                res.pop_back();\\n            }\\n            res.push_back(s[i]);\\n            added[s[i] - \\'a\\'] = true;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755001,
                "title": "solution-learn-one-solve-all-similar-one-s-monotonically-increasing-stack-approach-questions",
                "content": "[316. Remove Duplicate Letters](https://leetcode.com/problems/remove-duplicate-letters/)\\n[1081. Smallest Subsequence of Distinct Characters](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/)\\n * When we see these kind of problems which asks for lexigraphical order by removing few or by using k number of elements the first approach that should come into our mind is using Monotonically Increasing or Decreasing Stack approach\\n* we use same kind of approach in finding previous/next largest , previous/next smallest using stack etc..\\n\\n* lets take this example\\n    Input: s = \"cbacdcbc\"\\n    Output: \"acdb\"\\n\\t\\n1. \\tfirst we will count no of occurances using map;\\n2. \\tthen while traversion from beginning to ending we will reduce the freq of current element in map;\\n3. \\twe will maintain a vis array to check if the current char is visited or not\\n4. \\tif(vis[currentchar]) continue;\\n5. \\telse we will check if there is any char before this in result that is greater than current char and also has another occurance after the present index (ex:- bab first b need not be considered as we also have b after a and this lets us get a before b in lexigraphical order ) and we will mark vis of removed as false;\\n6. \\tthough there is a previous char greater than present and if its not occuring after the current index then we wont remove that (as we need atleast one occurance )\\n7. \\twe mark visited of current as true and add current to result \\n\\n```\\nstring removeDuplicateLetters(string s) {\\n        vector<int> dict(256,0);\\n        vector<bool> vis(256,false);\\n        \\n        for(auto &c:s)dict[c]++;\\n        string res = \"\";\\n        for(auto &c:s){\\n            dict[c]--;\\n            if(vis[c])continue;\\n            \\n            while(!res.empty() && res.back()>c && dict[res.back()]!=0){\\n                vis[res.back()]=false;\\n                res.pop_back();\\n            }\\n            vis[c] = true;\\n            res += c;\\n        }\\n        return res;\\n    }\\n```\\n\\nPlease Upvote \\u2764 if you like this Solution \\n\\n[1673. Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/)\\n\\n* here in this question we need k elements\\n* then while processing current element we need to check two main conditions i.e is there any index before , which contains value greater than present and another condition is can we satisfy k elements conditon if we remove last element from result\\n* we need minimum number at minimum-index-possible to make it more competetive\\n\\n```\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n        while(!ans.empty() && (ans.back()>nums[i]) && (n+ans.size()-i>k))\\n          ans.pop_back();\\n          if(k>ans.size()) ans.push_back(nums[i]);\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n```\\n\\nPlease Upvote \\u2764 if you like this Solution \\n\\n[402. Remove K Digits](https://leetcode.com/problems/remove-k-digits/)\\n\\n* This is also a similar question to previous one\\n* In previous question we checked k numbers condtion can be satisfied or not , but here in this question we need to remove k elements so n-k elements will be left so we will check n-k elements can be satisfied or not\\n* remaining is same as previous question\\n\\n```\\n    string removeKdigits(string A, int k) {\\n     string stack;\\n        for (int i = 0; i < A.size(); ++i) {\\n                while (!stack.empty() && stack.back() > A[i] && (stack.size()+A.size()-i > A.size()-k))\\n                stack.pop_back();\\n            if (stack.size() < A.size()-k)\\n                stack.push_back(A[i]);\\n        }\\n        stack.erase(0,stack.find_first_not_of(\\'0\\'));\\n        return stack==\"\"?\"0\":stack;\\n    }\\n```\\n\\nPlease Upvote \\u2764 if you like this Solution \\n\\n[321. Create Maximum Number](https://leetcode.com/problems/create-maximum-number/)\\n\\n* This is a Hard question \\n* Here we need to take K elements from 2 arrays so , if we take i elements from array 1 , we need to take k-i elements from array 2 \\n* we dont know whats the value of i which gives biggest lexigraphical vector\\n* so we check for all possible value of i starting from max(0,k-m) to min(k,n) where n,m are sizes of vector 1 and vector 2 respectively;\\n* we start from max(0,k-m) because if n is 4 and m is 4 and k is 6 , we need at to take atleast 2 elements from 1st vector as 2nd only contains 4\\n* we end at min(k,n) because atmost we can take k elements from one vector\\n* maxelement function returns maximum monotonically decreasing vector for vector1 and vector2 and we merge both of them using maxcombo function\\n* max lexigraphical vector is stored in ans which will be returned \\n\\n\\n\\n```\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        for(int i=max(0,k-m);i<=min(k,n);i++){\\n            ans = max(ans,maxCombo(maxelement(nums1,i,n),maxelement(nums2,k-i,m)));\\n        }\\n        return ans;\\n    }\\n    vector<int> maxelement(vector<int> vec,int k,int size){\\n        vector<int> res;\\n        \\n        for(int i=0;i<size;i++){\\n            while(!res.empty() && res.back()<vec[i] && size+res.size()-i>k){\\n                res.pop_back();\\n            }\\n            if(res.size()<k)res.push_back(vec[i]);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    vector<int> maxCombo(vector<int> vec1,vector<int> vec2){\\n        vector<int> ans;\\n        while(vec1.size()+vec2.size()){\\n            vector<int>& now = vec1>vec2?vec1:vec2;\\n            ans.push_back(now[0]);\\n            now.erase(now.begin());\\n        }\\n        return ans;\\n    }\\n```\\n\\n\\n\\uD83D\\uDE0A I am new to writing posts , please give ur valuable suggestions in comments section , if leetcoders are liking these kind of posts i will create much more of this kind \\uD83D\\uDE0A\\n\\t",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nstring removeDuplicateLetters(string s) {\\n        vector<int> dict(256,0);\\n        vector<bool> vis(256,false);\\n        \\n        for(auto &c:s)dict[c]++;\\n        string res = \"\";\\n        for(auto &c:s){\\n            dict[c]--;\\n            if(vis[c])continue;\\n            \\n            while(!res.empty() && res.back()>c && dict[res.back()]!=0){\\n                vis[res.back()]=false;\\n                res.pop_back();\\n            }\\n            vis[c] = true;\\n            res += c;\\n        }\\n        return res;\\n    }\\n```\n```\\n    vector<int> mostCompetitive(vector<int>& nums, int k) {\\n        vector<int> ans;\\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n        while(!ans.empty() && (ans.back()>nums[i]) && (n+ans.size()-i>k))\\n          ans.pop_back();\\n          if(k>ans.size()) ans.push_back(nums[i]);\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n```\n```\\n    string removeKdigits(string A, int k) {\\n     string stack;\\n        for (int i = 0; i < A.size(); ++i) {\\n                while (!stack.empty() && stack.back() > A[i] && (stack.size()+A.size()-i > A.size()-k))\\n                stack.pop_back();\\n            if (stack.size() < A.size()-k)\\n                stack.push_back(A[i]);\\n        }\\n        stack.erase(0,stack.find_first_not_of(\\'0\\'));\\n        return stack==\"\"?\"0\":stack;\\n    }\\n```\n```\\n    vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\\n        vector<int> ans;\\n        int n = nums1.size();\\n        int m = nums2.size();\\n        for(int i=max(0,k-m);i<=min(k,n);i++){\\n            ans = max(ans,maxCombo(maxelement(nums1,i,n),maxelement(nums2,k-i,m)));\\n        }\\n        return ans;\\n    }\\n    vector<int> maxelement(vector<int> vec,int k,int size){\\n        vector<int> res;\\n        \\n        for(int i=0;i<size;i++){\\n            while(!res.empty() && res.back()<vec[i] && size+res.size()-i>k){\\n                res.pop_back();\\n            }\\n            if(res.size()<k)res.push_back(vec[i]);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    vector<int> maxCombo(vector<int> vec1,vector<int> vec2){\\n        vector<int> ans;\\n        while(vec1.size()+vec2.size()){\\n            vector<int>& now = vec1>vec2?vec1:vec2;\\n            ans.push_back(now[0]);\\n            now.erase(now.begin());\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090711,
                "title": "98-53-stack-and-greedy",
                "content": "# Interview Guide: \"Remove Duplicate Letters\" Problem\\n\\n## Problem Understanding\\n\\nThe \"Remove Duplicate Letters\" problem tasks you with removing duplicate letters from a string such that every letter appears only once. The challenge is to make sure the result is the smallest in lexicographical order among all possible outcomes.\\n\\n## Key Points to Consider\\n\\n### 1. Understand the Constraints\\n\\nBefore diving deep into the solution, it\\'s crucial to understand the constraints. The length of string `s` is between 1 and 10,000, and `s` consists only of lowercase English letters. This provides insight into the feasible solutions in terms of time and space complexity.\\n\\n### 2. Multiple Approaches\\n\\nThere are different ways to solve this problem:\\n\\n  - Using a Stack and Greedy algorithm\\n  - Using a Count and Visited array\\n\\nBoth approaches have their advantages and trade-offs, so it\\'s essential to understand both and choose the one that aligns with the problem\\'s constraints.\\n\\n### 3. Stack\\'s Utility\\n\\nWhen using the Stack approach, the stack serves as a dynamic data structure to hold the characters in the desired order. It plays a crucial role in ensuring lexicographical ordering of characters.\\n\\n### 4. Explain Your Thought Process\\n\\nAlways articulate your thought process and the rationale behind choosing a specific approach. Highlight the trade-offs you\\'re considering in terms of time and space complexity.\\n\\n## Conclusion\\n\\nThe \"Remove Duplicate Letters\" problem is an excellent example of how different data structures and algorithms can be used to achieve the desired outcome. By understanding the problem, deciding on the best data structures, and choosing the right algorithm, you demonstrate a comprehensive grasp of algorithmic challenges.\\n\\n---\\n\\n## Live Coding & Explain\\nhttps://youtu.be/Z0rg6rAWMik?si=vAkmw5iSwa_gFX3h\\n\\n# Approach: Stack and Greedy\\n\\nTo address the \"Remove Duplicate Letters\" problem using a stack and greedy algorithm, we lean on the properties of the stack to maintain lexicographical order:\\n\\n## Key Data Structures:\\n\\n- **stack**: A dynamic data structure to hold characters in the desired order.\\n- **seen**: A set to track characters already in the stack.\\n- **last_occurrence**: A dictionary to track the last occurrence of each character in the string.\\n\\n## Enhanced Breakdown:\\n\\n1. **Initialization**:\\n   - Initialize the stack, seen set, and last_occurrence dictionary.\\n  \\n2. **Iterate through the string**:\\n   - For each character, if it\\'s in the seen set, skip it.\\n   - If it\\'s not in the seen set, add it to the stack. While adding, compare it with the top character of the stack. If the current character is smaller and the top character appears later in the string, pop the top character.\\n\\n3. **Output**:\\n   - Convert the stack to a string and return.\\n\\n# Complexity:\\n\\n**Time Complexity:** \\n- The solution iterates over each character in the string once, leading to a time complexity of $$ O(n) $$, where `n` is the length of the string `s`.\\n\\n**Space Complexity:** \\n- The space complexity is $$ O(n) $$ due to the stack, seen set, and last_occurrence dictionary.\\n\\n# Code Stack and Greedy\\n``` Python []\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        stack = []\\n        seen = set() \\n        last_occ = {c: i for i, c in enumerate(s)}\\n        \\n        for i, c in enumerate(s):\\n            if c not in seen:\\n                \\n                while stack and c < stack[-1] and i < last_occ[stack[-1]]:\\n                    seen.discard(stack.pop())\\n                seen.add(c)\\n                stack.append(c)\\n        \\n        return \\'\\'.join(stack)\\n```\\n``` Go []\\nfunc removeDuplicateLetters(s string) string {\\n\\tstack := []rune{}\\n\\tseen := make(map[rune]bool)\\n\\tlastOcc := make(map[rune]int)\\n\\n\\tfor i, c := range s {\\n\\t\\tlastOcc[c] = i\\n\\t}\\n\\n\\tfor i, c := range s {\\n\\t\\tif !seen[c] {\\n\\t\\t\\tfor len(stack) > 0 && c < stack[len(stack)-1] && i < lastOcc[stack[len(stack)-1]] {\\n\\t\\t\\t\\tdelete(seen, stack[len(stack)-1])\\n\\t\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t\\t}\\n\\t\\t\\tseen[c] = true\\n\\t\\t\\tstack = append(stack, c)\\n\\t\\t}\\n\\t}\\n\\n\\treturn string(stack)\\n}\\n```\\n``` Rust []\\nuse std::collections::{HashSet, HashMap};\\n\\nimpl Solution {\\n    pub fn remove_duplicate_letters(s: String) -> String {\\n        let mut stack: Vec<char> = Vec::new();\\n        let mut seen: HashSet<char> = HashSet::new();\\n        let mut last_occ: HashMap<char, usize> = HashMap::new();\\n        for (i, c) in s.chars().enumerate() {\\n            last_occ.insert(c, i);\\n        }\\n        \\n        for (i, c) in s.chars().enumerate() {\\n            if !seen.contains(&c) {\\n                while let Some(&top) = stack.last() {\\n                    if c < top && i < *last_occ.get(&top).unwrap() {\\n                        seen.remove(&stack.pop().unwrap());\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                seen.insert(c);\\n                stack.push(c);\\n            }\\n        }\\n        \\n        stack.into_iter().collect()\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    std::string removeDuplicateLetters(std::string s) {\\n        std::stack<char> stack;\\n        std::unordered_set<char> seen;\\n        std::unordered_map<char, int> last_occ;\\n        for (int i = 0; i < s.size(); i++) {\\n            last_occ[s[i]] = i;\\n        }\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            char c = s[i];\\n            if (seen.find(c) == seen.end()) {\\n                while (!stack.empty() && c < stack.top() && i < last_occ[stack.top()]) {\\n                    seen.erase(stack.top());\\n                    stack.pop();\\n                }\\n                seen.insert(c);\\n                stack.push(c);\\n            }\\n        }\\n        \\n        std::string result = \"\";\\n        while (!stack.empty()) {\\n            result = stack.top() + result;\\n            stack.pop();\\n        }\\n        return result;\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public String removeDuplicateLetters(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        Set<Character> seen = new HashSet<>();\\n        Map<Character, Integer> lastOcc = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            lastOcc.put(s.charAt(i), i);\\n        }\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (!seen.contains(c)) {\\n                while (!stack.isEmpty() && c < stack.peek() && i < lastOcc.get(stack.peek())) {\\n                    seen.remove(stack.pop());\\n                }\\n                seen.add(c);\\n                stack.push(c);\\n            }\\n        }\\n        \\n        StringBuilder result = new StringBuilder();\\n        for (char c : stack) {\\n            result.append(c);\\n        }\\n        return result.toString();\\n    }\\n}\\n```\\n``` C# []\\npublic class Solution {\\n    public string RemoveDuplicateLetters(string s) {\\n        Stack<char> stack = new Stack<char>();\\n        HashSet<char> seen = new HashSet<char>();\\n        Dictionary<char, int> lastOcc = new Dictionary<char, int>();\\n        for (int i = 0; i < s.Length; i++) {\\n            lastOcc[s[i]] = i;\\n        }\\n        \\n        for (int i = 0; i < s.Length; i++) {\\n            char c = s[i];\\n            if (!seen.Contains(c)) {\\n                while (stack.Count > 0 && c < stack.Peek() && i < lastOcc[stack.Peek()]) {\\n                    seen.Remove(stack.Pop());\\n                }\\n                seen.Add(c);\\n                stack.Push(c);\\n            }\\n        }\\n        \\n        char[] result = stack.ToArray();\\n        Array.Reverse(result);\\n        return new string(result);\\n    }\\n}\\n```\\n``` JavaScript []\\nvar removeDuplicateLetters = function(s) {\\n        let stack = [];\\n        let seen = new Set();\\n        let lastOcc = {};\\n        for (let i = 0; i < s.length; i++) {\\n            lastOcc[s[i]] = i;\\n        }\\n        \\n        for (let i = 0; i < s.length; i++) {\\n            let c = s[i];\\n            if (!seen.has(c)) {\\n                while (stack.length && c < stack[stack.length - 1] && i < lastOcc[stack[stack.length - 1]]) {\\n                    seen.delete(stack.pop());\\n                }\\n                seen.add(c);\\n                stack.push(c);\\n            }\\n        }\\n        \\n        return stack.join(\\'\\');\\n    }\\n```\\n``` PHP []\\nclass Solution {\\n    function removeDuplicateLetters($s) {\\n        $stack = [];\\n        $seen = [];\\n        $lastOcc = [];\\n        for ($i = 0; $i < strlen($s); $i++) {\\n            $lastOcc[$s[$i]] = $i;\\n        }\\n        \\n        for ($i = 0; $i < strlen($s); $i++) {\\n            $c = $s[$i];\\n            if (!isset($seen[$c])) {\\n                while (!empty($stack) && $c < end($stack) && $i < $lastOcc[end($stack)]) {\\n                    unset($seen[array_pop($stack)]);\\n                }\\n                $seen[$c] = true;\\n                array_push($stack, $c);\\n            }\\n        }\\n        \\n        return implode(\\'\\', $stack);\\n    }\\n}\\n```\\n\\n---\\n\\n# Approach: Count and Visited Array\\n\\nTo address the \"Remove Duplicate Letters\" problem using a count and visited array, we leverage the frequency of each character:\\n\\n## Key Data Structures:\\n\\n- **count**: A dictionary to hold the frequency of each character.\\n- **result**: A list to hold the final characters in the desired order.\\n- **visited**: A set to track characters already in the result.\\n\\n## Enhanced Breakdown:\\n\\n1. **Calculate Frequencies**:\\n   - Compute the frequency of each character in the string.\\n  \\n2. **Iterate through the string**:\\n   - For each character, decrease its count. If it\\'s in the visited set, skip it.\\n   - If it\\'s not in the visited set, add it to the result. While adding, compare it with the last character in the result. If the current character is smaller and the last character appears later in the string, remove the last character.\\n\\n3. **Output**:\\n   - Convert the result list to a string and return.\\n\\n# Complexity:\\n\\n**Time Complexity:** \\n- The solution iterates over each character in the string once, leading to a time complexity of $$ O(n) $$, where  `n`  is the length of the string `s`.\\n\\n**Space Complexity:** \\n- The space complexity is $$ O(n) $$ due to the count dictionary, result list, and visited set.\\n\\n# Code Count and Visited Array\\n``` Python []\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        count = collections.Counter(s)\\n        result = []\\n        visited = set()\\n        \\n        for c in s:\\n            count[c] -= 1\\n            if c in visited:\\n                continue\\n            while result and c < result[-1] and count[result[-1]] > 0:\\n                visited.remove(result.pop())\\n            visited.add(c)\\n            result.append(c)\\n            \\n        return \\'\\'.join(result)\\n\\n```\\n\\n## Performance\\n\\n| Language    | Execution Time (ms) | Memory Usage |\\n|-------------|---------------------|--------------|\\n| C++         | 0 ms                | 7.4 MB       |\\n| Rust        | 2 ms                | 2.2 MB       |\\n| Go          | 3 ms                | 2.1 MB       |\\n| Java        | 3 ms                | 41.2 MB      |\\n| PHP         | 10 ms               | 19 MB        |\\n| Python3 (Stack)     | 32 ms               | 16.4 MB      |\\n| Python3 (Count)    | 38 ms               | 16.3 MB      |\\n| JavaScript  | 56 ms               | 42.2 MB      |\\n| C#          | 82 ms               | 37.9 MB      |\\n\\n![plot5.png](https://assets.leetcode.com/users/images/c85e2f72-e37e-48a8-a03c-2282e0f3be44_1695687878.709512.png)\\n\\n\\n## Bonuse: Live Coding in Rust\\nhttps://youtu.be/mMJ4LtwDRnc?si=AyuKt3HQIHqkS2DT\\n\\nBoth approaches showcase different techniques to solve the problem: one uses the properties of a stack and the greedy algorithm, while the other leverages the frequency of characters. Deciding between them depends on the specific constraints and requirements of the given scenario. \\uD83D\\uDE80\\uD83D\\uDC69\\u200D\\uD83D\\uDCBB\\uD83D\\uDC68\\u200D\\uD83D\\uDCBB\\uD83C\\uDF0C.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Rust",
                    "PHP",
                    "Stack",
                    "Greedy"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        stack = []\\n        seen = set() \\n        last_occ = {c: i for i, c in enumerate(s)}\\n        \\n        for i, c in enumerate(s):\\n            if c not in seen:\\n                \\n                while stack and c < stack[-1] and i < last_occ[stack[-1]]:\\n                    seen.discard(stack.pop())\\n                seen.add(c)\\n                stack.append(c)\\n        \\n        return \\'\\'.join(stack)\\n```\n``` Go []\\nfunc removeDuplicateLetters(s string) string {\\n\\tstack := []rune{}\\n\\tseen := make(map[rune]bool)\\n\\tlastOcc := make(map[rune]int)\\n\\n\\tfor i, c := range s {\\n\\t\\tlastOcc[c] = i\\n\\t}\\n\\n\\tfor i, c := range s {\\n\\t\\tif !seen[c] {\\n\\t\\t\\tfor len(stack) > 0 && c < stack[len(stack)-1] && i < lastOcc[stack[len(stack)-1]] {\\n\\t\\t\\t\\tdelete(seen, stack[len(stack)-1])\\n\\t\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t\\t}\\n\\t\\t\\tseen[c] = true\\n\\t\\t\\tstack = append(stack, c)\\n\\t\\t}\\n\\t}\\n\\n\\treturn string(stack)\\n}\\n```\n``` Rust []\\nuse std::collections::{HashSet, HashMap};\\n\\nimpl Solution {\\n    pub fn remove_duplicate_letters(s: String) -> String {\\n        let mut stack: Vec<char> = Vec::new();\\n        let mut seen: HashSet<char> = HashSet::new();\\n        let mut last_occ: HashMap<char, usize> = HashMap::new();\\n        for (i, c) in s.chars().enumerate() {\\n            last_occ.insert(c, i);\\n        }\\n        \\n        for (i, c) in s.chars().enumerate() {\\n            if !seen.contains(&c) {\\n                while let Some(&top) = stack.last() {\\n                    if c < top && i < *last_occ.get(&top).unwrap() {\\n                        seen.remove(&stack.pop().unwrap());\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                seen.insert(c);\\n                stack.push(c);\\n            }\\n        }\\n        \\n        stack.into_iter().collect()\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    std::string removeDuplicateLetters(std::string s) {\\n        std::stack<char> stack;\\n        std::unordered_set<char> seen;\\n        std::unordered_map<char, int> last_occ;\\n        for (int i = 0; i < s.size(); i++) {\\n            last_occ[s[i]] = i;\\n        }\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            char c = s[i];\\n            if (seen.find(c) == seen.end()) {\\n                while (!stack.empty() && c < stack.top() && i < last_occ[stack.top()]) {\\n                    seen.erase(stack.top());\\n                    stack.pop();\\n                }\\n                seen.insert(c);\\n                stack.push(c);\\n            }\\n        }\\n        \\n        std::string result = \"\";\\n        while (!stack.empty()) {\\n            result = stack.top() + result;\\n            stack.pop();\\n        }\\n        return result;\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public String removeDuplicateLetters(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        Set<Character> seen = new HashSet<>();\\n        Map<Character, Integer> lastOcc = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            lastOcc.put(s.charAt(i), i);\\n        }\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (!seen.contains(c)) {\\n                while (!stack.isEmpty() && c < stack.peek() && i < lastOcc.get(stack.peek())) {\\n                    seen.remove(stack.pop());\\n                }\\n                seen.add(c);\\n                stack.push(c);\\n            }\\n        }\\n        \\n        StringBuilder result = new StringBuilder();\\n        for (char c : stack) {\\n            result.append(c);\\n        }\\n        return result.toString();\\n    }\\n}\\n```\n``` C# []\\npublic class Solution {\\n    public string RemoveDuplicateLetters(string s) {\\n        Stack<char> stack = new Stack<char>();\\n        HashSet<char> seen = new HashSet<char>();\\n        Dictionary<char, int> lastOcc = new Dictionary<char, int>();\\n        for (int i = 0; i < s.Length; i++) {\\n            lastOcc[s[i]] = i;\\n        }\\n        \\n        for (int i = 0; i < s.Length; i++) {\\n            char c = s[i];\\n            if (!seen.Contains(c)) {\\n                while (stack.Count > 0 && c < stack.Peek() && i < lastOcc[stack.Peek()]) {\\n                    seen.Remove(stack.Pop());\\n                }\\n                seen.Add(c);\\n                stack.Push(c);\\n            }\\n        }\\n        \\n        char[] result = stack.ToArray();\\n        Array.Reverse(result);\\n        return new string(result);\\n    }\\n}\\n```\n``` JavaScript []\\nvar removeDuplicateLetters = function(s) {\\n        let stack = [];\\n        let seen = new Set();\\n        let lastOcc = {};\\n        for (let i = 0; i < s.length; i++) {\\n            lastOcc[s[i]] = i;\\n        }\\n        \\n        for (let i = 0; i < s.length; i++) {\\n            let c = s[i];\\n            if (!seen.has(c)) {\\n                while (stack.length && c < stack[stack.length - 1] && i < lastOcc[stack[stack.length - 1]]) {\\n                    seen.delete(stack.pop());\\n                }\\n                seen.add(c);\\n                stack.push(c);\\n            }\\n        }\\n        \\n        return stack.join(\\'\\');\\n    }\\n```\n``` PHP []\\nclass Solution {\\n    function removeDuplicateLetters($s) {\\n        $stack = [];\\n        $seen = [];\\n        $lastOcc = [];\\n        for ($i = 0; $i < strlen($s); $i++) {\\n            $lastOcc[$s[$i]] = $i;\\n        }\\n        \\n        for ($i = 0; $i < strlen($s); $i++) {\\n            $c = $s[$i];\\n            if (!isset($seen[$c])) {\\n                while (!empty($stack) && $c < end($stack) && $i < $lastOcc[end($stack)]) {\\n                    unset($seen[array_pop($stack)]);\\n                }\\n                $seen[$c] = true;\\n                array_push($stack, $c);\\n            }\\n        }\\n        \\n        return implode(\\'\\', $stack);\\n    }\\n}\\n```\n``` Python []\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        count = collections.Counter(s)\\n        result = []\\n        visited = set()\\n        \\n        for c in s:\\n            count[c] -= 1\\n            if c in visited:\\n                continue\\n            while result and c < result[-1] and count[result[-1]] > 0:\\n                visited.remove(result.pop())\\n            visited.add(c)\\n            result.append(c)\\n            \\n        return \\'\\'.join(result)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76860,
                "title": "15-ms-java-solution",
                "content": "for \"cbacdcbc\", we counts each letter's index:\\n\\n    a----2\\n    b----1,6\\n    c----0,3,5,7\\n    d----4\\n\\nwe go from a to d, to find the first letter who has a index smaller than the largest index of the rest. Here, index 2 of letter a is smaller than 6, 7, 4, so we first pick a; then we remove all index smaller than 2, and we have:\\n\\n    b----6\\n    c----3,5,7\\n    d----4\\n\\nthe next round we pick c not b, why ? cuz  6 of b is larger than 4, but 3 of c is smaller than 4 and 6.\\n\\n    b---6\\n    d---4\\n\\nthen we pick d and b to form \"acdb\"\\n\\nO(n) time to count index, and as we only have 26 letters, it's about O(26 * 26) to find a candidate letter and O(n) time to remove all index. So I think the running time is O(n).\\n\\n    public class Solution {\\n        public String removeDuplicateLetters(String s) {\\n            HashMap<Character, ArrayList<Integer>> counts = new HashMap<Character, ArrayList<Integer>>();\\n            ArrayList<Character> keys = new ArrayList<Character>();\\n            for (int i = 0; i < s.length(); i++) {\\n                char c = s.charAt(i);\\n                if (!counts.containsKey(c)) {\\n                    counts.put(c, new ArrayList<Integer>());\\n                    keys.add(c);\\n                }\\n                counts.get(c).add(i);\\n            }\\n            Collections.sort(keys);\\n            StringBuilder sb = new StringBuilder();\\n            while (!counts.isEmpty()) {\\n                boolean found = true;\\n                for (int i = 0; i < keys.size(); i++) {\\n                    int index = counts.get(keys.get(i)).get(0);\\n                    for (int j = 0; j < keys.size(); j++) {\\n                        ArrayList<Integer> count = counts.get(keys.get(j));\\n                        if (count.get(count.size() - 1) < index) {\\n                            found = false;\\n                            break;\\n                        }\\n                    }\\n                    if (found) {\\n                        sb.append(keys.get(i));\\n                        counts.remove(keys.get(i));\\n                        keys.remove(i);\\n                        for (int j = 0; j < keys.size(); j++) {\\n                            ArrayList<Integer> count = counts.get(keys.get(j));\\n                            while (count.get(0) < index) {\\n                                count.remove(0);\\n                            }\\n                        }\\n                        break;\\n                    }\\n                    found = true;\\n                }\\n            }\\n            return sb.toString();\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String removeDuplicateLetters(String s) {\\n            HashMap<Character, ArrayList<Integer>> counts = new HashMap<Character, ArrayList<Integer>>();\\n            ArrayList<Character> keys = new ArrayList<Character>();\\n            for (int i = 0; i < s.length(); i++) {\\n                char c = s.charAt(i);\\n                if (!counts.containsKey(c)) {\\n                    counts.put(c, new ArrayList<Integer>());\\n                    keys.add(c);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 76853,
                "title": "4ms-c-solution-use-return-string-as-a-stack",
                "content": "\\n    string removeDuplicateLetters(string s) {\\n        vector<unsigned int> cnt(26,0); //only consider lowercase letters\\n        vector<bool> inRes(26, false); //true if the letter has been added to res \\n        for(char ch:s) cnt[ ch-'a' ]++;\\n        string res = \"\"; //use res as a stack\\n        for(char ch:s){\\n           cnt[ ch-'a' ]--;\\n           if(res.empty()){ \\n               res.push_back(ch);\\n               inRes[ ch-'a' ] = true;\\n               continue;\\n           }\\n           if(inRes[ch-'a']) continue;\\n           while(ch<res.back() && !res.empty() && cnt[ res.back()-'a' ]>0){\\n               inRes[ res.back()-'a' ] = false;\\n               res.pop_back();\\n               \\n           }\\n           res.push_back(ch);\\n           inRes[ ch-'a' ] = true;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "\\n    string removeDuplicateLetters(string s) {\\n        vector<unsigned int> cnt(26,0); //only consider lowercase letters\\n        vector<bool> inRes(26, false); //true if the letter has been added to res \\n        for(char ch:s) cnt[ ch-'a' ]++;\\n        string res = \"\"; //use res as a stack\\n        for(char ch:s){\\n           cnt[ ch-'a' ]--;\\n           if(res.empty()){ \\n               res.push_back(ch);\\n               inRes[ ch-'a' ] = true;\\n               continue;\\n           }\\n           if(inRes[ch-'a']) continue;\\n           while(ch<res.back() && !res.empty() && cnt[ res.back()-'a' ]>0){\\n               inRes[ res.back()-'a' ] = false;\\n               res.pop_back();\\n               \\n           }\\n           res.push_back(ch);\\n           inRes[ ch-'a' ] = true;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4091060,
                "title": "video-how-we-think-about-a-solution-with-stack-python-javascript-java-c",
                "content": "Welcome to my article! This artcle starts with \"How we think about a solution\". In other words, that is my thought process to solve the question. This article explains how I get to my solution instead of just posting solution codes or out of blue algorithms. I hope this aricle is helpful for someone.\\n\\n# Intuition\\n\\nUse stack to keep order of charcters in string with the smallest in lexicographical order.\\n\\n---\\n\\n# Solution Video\\n\\nhttps://youtu.be/aU0MiLWAm4o\\n\\n\\u25A0 Timeline of the video\\n`0:00` Read the question of Remove Duplicate Letters\\n`0:16` How we think about a solution - What is the smallest in lexicographical order for this question?\\n`2:28` Demonstrate solution with an example.\\n`7:43` Coding\\n`10:00` Time Complexity and Space Complexity\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nSubscribers: 2,493\\nMy initial goal is 10,000\\nThank you for your support!\\n\\n---\\n\\n\\n# Approach\\n\\n## How we think about a solution\\n\\n### What is the smallest in lexicographical order for this quesiton?\\nTo solve this question, we need to understand what smallest in lexicographical order is.\\n\\n```\\nInput: \"bcabc\"\\n```\\n\\nIn this case, we have duplicte characters `b` and `c`, so we need to remove one of `b` and one of `c`.\\n\\n```\\n_ _ a b c \\u2192 abc\\n_ c a b _ \\u2192 cab\\nb _ a _ c \\u2192 bac\\nb c a _ _ \\u2192 bca\\n```\\nWe can create 4 strings and need to keep order of appearance of each character. And then, sort the 4 strings lexicographically(alphabetically).\\n```\\nabc\\nbac\\nbca\\ncab\\n```\\n\\n`abc` is the smallest string, that\\'s why we should return `abc`.\\n\\nThat is the smallest in lexicographical order we must understand for this question.\\n\\nNow, let\\'s focus on \\n```\\n_(b) _(c) a b c \\u2192 abc\\n```\\n From the idea above, we can say two important things.\\n\\n---\\nWe want to put the smaller character in early position but we have to use big character(For example \"z\") if it is unique in the string.\\n\\n\\nThe two important thing are as follows;\\n1. Previous characters are lexicographically greater than current character\\n2. The previous big characters show up again after position of current character\\n\\nIf both cases are true, we can remove the previous big charcters because we try to put smaller characters in early position and bigger characters in late position if possible. It leads to creating smaller string lexicographically and can remove duplicate characters.\\n\\n---\\n\\n\\nIn this case, what data structure do you use? \\n\\nMy answer is to use `stack`. We want to compare current character with the last previous character one by one. We can use `pop` and `append` with `O(1)`. Seems like `stack` make the problem easy and efficient.\\n\\nLet\\'s see one by one. First of all, `stack` is empty\\n\\n```\\nstack = []\\n```\\nThe first character is `b` and `stack` is now empty, so just add `b` to `stack`\\n```\\nstack = [\"b\"]\\n```\\nThe next character is `c`, in this case, compare `c` with the last character in `stack` which is `b` with the main idea above.\\n\\n`c` is greater than `b`, so it\\'s false case. Just add `c` in `stack`\\n\\n```\\n\"c\" < \"b\" \\u2192 false\\nstack = [\"b\", \"c\"]\\n```\\n\\nThe next character is `a`. Here is an interesting point. Compare `a` with the last character in `stack` which is `c`\\n\\n```\\n\"a\" < \"c\" \\u2192 true\\nprevious character(c) will show up again after current position(a)? \\u2192 true\\n```\\nIn that case, remove `c` from `stack`\\n```\\nstack = [\"b\"]\\n```\\nWe still have `b` in stack. Let\\'s compare `a` vs `b`.\\n```\\n\"a\" < \"b\" \\u2192 true\\nprevious character(b) will show up again after current position(a)? \\u2192 true\\n```\\nIn that case, remove `b` from `stack`. Now `stack` is empty. we stop comparing and add `a` to `stack`\\n```\\nstack = [\"a\"]\\n```\\nWe will repeat the same process. I\\'ll speed up. The next character is `b`.\\n```\\n\"b\" < \"a\" \\u2192 false\\nstack = [\"a\", \"b\"]\\n```\\nThe next character is `c`.\\n```\\n\"c\" < \"b\" \\u2192 false\\nstack = [\"a\", \"b\", \"c\"]\\n```\\n\\nAll we have to do is just to concatenate the characters remaining in the stack.\\n\\nThat is main point of how we think about a solution. Exepct the main idea, I use `Set` and `HashMap` to support the idea in the solution codes below. `Set` is used to prevent duplicate characters and `HashMap` is used to keep the last position of each character. I believe now you can understand them easily.\\n\\nLet\\'s see a real algorithm!\\n\\n### Algorithm Overview\\n1. Build a dictionary `last_occur` to store the last occurrence index of each character in the input string `s`.\\n2. Iterate through the input string `s` to build the `last_occur` dictionary and initialize an empty stack and a visited set.\\n3. Iterate through the characters in the input string `s` again. If a character is already visited, skip it. If not, process it based on certain conditions and update the stack and visited set accordingly.\\n4. Finally, concatenate the characters remaining in the stack to get the final result.\\n\\n### Detailed Explanation\\n1. Create a dictionary `last_occur` to store the last occurrence index of each character in the input string `s`.\\n2. Iterate through each character and its index in the input string `s`:\\n   1. Update the `last_occur` dictionary with the last occurrence index of the current character.\\n3. Initialize an empty stack to hold the characters in the desired order and a visited set to keep track of visited characters.\\n4. Iterate through each index `i` in the range of the length of the input string `s`:\\n   1. Check if the current character `s[i]` is already visited. If visited, skip to the next iteration.\\n   2. If the current character `s[i]` is not visited:\\n      1. While the stack is not empty, the top of the stack is greater than `s[i]`, and the last occurrence of the top of the stack is after the current index `i`, remove the top of the stack and mark it as not visited.\\n      2. Mark the current character `s[i]` as visited and push it onto the stack.\\n5. Concatenate the characters remaining in the stack to obtain the final result.\\n6. Return the concatenated string, which represents the characters in the desired order without duplicate letters.\\n\\n\\n---\\n\\n\\n\\n# Complexity\\nLet\\'s analyze the time and space complexity of the given code.\\n\\n### Time Complexity:\\nThe time complexity can be broken down as follows:\\n\\n1. **First Loop (iteration over string `s`):** This involves iterating over each character in string `s` to build the `last_occur` dictionary. This takes O(len(s)), where len(s) is the length of string `s`.\\n\\n2. **Second Loop (iteration over string `s`):** In the worst case, this loop iterates over each character in string `s` and performs operations such as stack manipulations and dictionary lookups, which are O(1) operations.\\n\\nHence, the overall time complexity is O(len(s)), where len(s) is the length of string `s`.\\n\\n### Space Complexity:\\nThe space complexity is determined by the space used by the `last_occur` dictionary, the `stack`, and the `visited` set.\\n\\n1. **Dictionary (`last_occur`):** The space used by the `last_occur` dictionary is O(26) at most, considering only lowercase English letters, which is a constant.\\n\\n2. **Stack (`stack`):** In the worst case, the stack can contain all characters of string `s`. Therefore, the space used by the stack is O(len(s)), where len(s) is the length of string `s`.\\n\\n3. **Set (`visited`):** In the worst case, the visited set can contain all characters of string `s`. Therefore, the space used by the set is O(len(s)), where len(s) is the length of string `s`.\\n\\nHence, the overall space complexity of the code is O(max(len(s), 26)), which simplifies to O(len(s)) since 26 is a constant.\\n\\nBut regarding O(len(s)), we have also O(26) at most because we are not allowed to have duplicate characters, so we can say O(1) instead of O(len(s)).\\n\\n\\n```python []\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        # Dictionary to store the last occurrence of each character\\n        last_occur = {}\\n\\n        # Record the last occurrence of each character\\n        for i, char in enumerate(s):\\n            last_occur[char] = i        \\n\\n        stack = []  # Stack to store characters in the desired order\\n        visited = set()  # Set to keep track of visited characters\\n\\n        for i in range(len(s)):\\n            if s[i] in visited:\\n                continue  # Skip if the character is already visited\\n\\n            # If the top of the stack is greater than s[i] and will occur later again, remove from stack\\n            while stack and s[i] < stack[-1] and i < last_occur.get(stack[-1], -1):\\n                visited.remove(stack.pop())\\n\\n            visited.add(s[i])  # Mark as visited\\n            stack.append(s[i])  # Add to the stack\\n        \\n        return \\'\\'.join(stack)  # Concatenate the characters remaining in the stack\\n\\n```\\n```javascript []\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeDuplicateLetters = function(s) {\\n    const lastOccurrence = {};\\n    for (let i = 0; i < s.length; i++) {\\n        lastOccurrence[s[i]] = i;\\n    }\\n\\n    const stack = [];\\n    const visited = new Set();\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (visited.has(s[i])) {\\n            continue;\\n        }\\n\\n        while (\\n            stack.length > 0 &&\\n            s[i] < stack[stack.length - 1] &&\\n            i < lastOccurrence[stack[stack.length - 1]]\\n        ) {\\n            visited.delete(stack.pop());\\n        }\\n\\n        visited.add(s[i]);\\n        stack.push(s[i]);\\n    }\\n\\n    return stack.join(\\'\\');    \\n};\\n```\\n```java []\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        Map<Character, Integer> lastOccurrence = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            lastOccurrence.put(s.charAt(i), i);\\n        }\\n\\n        Stack<Character> stack = new Stack<>();\\n        Set<Character> visited = new HashSet<>();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (visited.contains(s.charAt(i))) {\\n                continue;\\n            }\\n\\n            while (!stack.isEmpty() && s.charAt(i) < stack.peek() && i < lastOccurrence.getOrDefault(stack.peek(), -1)) {\\n                visited.remove(stack.pop());\\n            }\\n\\n            visited.add(s.charAt(i));\\n            stack.push(s.charAt(i));\\n        }\\n\\n        StringBuilder result = new StringBuilder();\\n        for (char ch : stack) {\\n            result.append(ch);\\n        }\\n        return result.toString();        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        std::unordered_map<char, int> lastOccurrence;\\n        for (int i = 0; i < s.length(); i++) {\\n            lastOccurrence[s[i]] = i;\\n        }\\n\\n        std::stack<char> stack;\\n        std::unordered_set<char> visited;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (visited.find(s[i]) != visited.end()) {\\n                continue;\\n            }\\n\\n            while (!stack.empty() && s[i] < stack.top() && i < lastOccurrence[stack.top()]) {\\n                visited.erase(stack.top());\\n                stack.pop();\\n            }\\n\\n            visited.insert(s[i]);\\n            stack.push(s[i]);\\n        }\\n\\n        std::string result;\\n        while (!stack.empty()) {\\n            result = stack.top() + result;\\n            stack.pop();\\n        }\\n        return result;        \\n    }\\n};\\n```\\n\\n\\n---\\n\\n\\nThank you for reading my post.\\n\\u2B50\\uFE0F Please upvote it and don\\'t forget to subscribe to my channel!\\n\\nMy next post for daily coding challenge on Sep 27th, 2023\\nhttps://leetcode.com/problems/decoded-string-at-index/solutions/4096860/how-i-think-about-a-solution-python-java-c/",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nInput: \"bcabc\"\\n```\n```\\n_ _ a b c \\u2192 abc\\n_ c a b _ \\u2192 cab\\nb _ a _ c \\u2192 bac\\nb c a _ _ \\u2192 bca\\n```\n```\\nabc\\nbac\\nbca\\ncab\\n```\n```\\n_(b) _(c) a b c \\u2192 abc\\n```\n```\\nstack = []\\n```\n```\\nstack = [\"b\"]\\n```\n```\\n\"c\" < \"b\" \\u2192 false\\nstack = [\"b\", \"c\"]\\n```\n```\\n\"a\" < \"c\" \\u2192 true\\nprevious character(c) will show up again after current position(a)? \\u2192 true\\n```\n```\\nstack = [\"b\"]\\n```\n```\\n\"a\" < \"b\" \\u2192 true\\nprevious character(b) will show up again after current position(a)? \\u2192 true\\n```\n```\\nstack = [\"a\"]\\n```\n```\\n\"b\" < \"a\" \\u2192 false\\nstack = [\"a\", \"b\"]\\n```\n```\\n\"c\" < \"b\" \\u2192 false\\nstack = [\"a\", \"b\", \"c\"]\\n```\n```python []\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        # Dictionary to store the last occurrence of each character\\n        last_occur = {}\\n\\n        # Record the last occurrence of each character\\n        for i, char in enumerate(s):\\n            last_occur[char] = i        \\n\\n        stack = []  # Stack to store characters in the desired order\\n        visited = set()  # Set to keep track of visited characters\\n\\n        for i in range(len(s)):\\n            if s[i] in visited:\\n                continue  # Skip if the character is already visited\\n\\n            # If the top of the stack is greater than s[i] and will occur later again, remove from stack\\n            while stack and s[i] < stack[-1] and i < last_occur.get(stack[-1], -1):\\n                visited.remove(stack.pop())\\n\\n            visited.add(s[i])  # Mark as visited\\n            stack.append(s[i])  # Add to the stack\\n        \\n        return \\'\\'.join(stack)  # Concatenate the characters remaining in the stack\\n\\n```\n```javascript []\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeDuplicateLetters = function(s) {\\n    const lastOccurrence = {};\\n    for (let i = 0; i < s.length; i++) {\\n        lastOccurrence[s[i]] = i;\\n    }\\n\\n    const stack = [];\\n    const visited = new Set();\\n\\n    for (let i = 0; i < s.length; i++) {\\n        if (visited.has(s[i])) {\\n            continue;\\n        }\\n\\n        while (\\n            stack.length > 0 &&\\n            s[i] < stack[stack.length - 1] &&\\n            i < lastOccurrence[stack[stack.length - 1]]\\n        ) {\\n            visited.delete(stack.pop());\\n        }\\n\\n        visited.add(s[i]);\\n        stack.push(s[i]);\\n    }\\n\\n    return stack.join(\\'\\');    \\n};\\n```\n```java []\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        Map<Character, Integer> lastOccurrence = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            lastOccurrence.put(s.charAt(i), i);\\n        }\\n\\n        Stack<Character> stack = new Stack<>();\\n        Set<Character> visited = new HashSet<>();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (visited.contains(s.charAt(i))) {\\n                continue;\\n            }\\n\\n            while (!stack.isEmpty() && s.charAt(i) < stack.peek() && i < lastOccurrence.getOrDefault(stack.peek(), -1)) {\\n                visited.remove(stack.pop());\\n            }\\n\\n            visited.add(s.charAt(i));\\n            stack.push(s.charAt(i));\\n        }\\n\\n        StringBuilder result = new StringBuilder();\\n        for (char ch : stack) {\\n            result.append(ch);\\n        }\\n        return result.toString();        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        std::unordered_map<char, int> lastOccurrence;\\n        for (int i = 0; i < s.length(); i++) {\\n            lastOccurrence[s[i]] = i;\\n        }\\n\\n        std::stack<char> stack;\\n        std::unordered_set<char> visited;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (visited.find(s[i]) != visited.end()) {\\n                continue;\\n            }\\n\\n            while (!stack.empty() && s[i] < stack.top() && i < lastOccurrence[stack.top()]) {\\n                visited.erase(stack.top());\\n                stack.pop();\\n            }\\n\\n            visited.insert(s[i]);\\n            stack.push(s[i]);\\n        }\\n\\n        std::string result;\\n        while (!stack.empty()) {\\n            result = stack.top() + result;\\n            stack.pop();\\n        }\\n        return result;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152230,
                "title": "o-n-python-solution-with-stack-implementation-and-explanation",
                "content": "#### Thought Process:\\nIf we take the example \\'bcabc\\'; and we try to manually solve this one. \\n1. encountered b, [good] --store it [we have nothing, let\\'s start with this character]\\n2. encountered c, -- store it too [this is bigger than last one --> good! (lexicographically)]\\n3. encountered a, [this is smaller than the ones we have come across in the past, right? If we skip all the past ones because they were bigger than current and also presume that they appear in the future than this is a good candidate to start with.]\\n-->>Its very clear now, that a stack would be a good DS to use here or perhaps one of the better choices if not the best.\\n4. encountered b, [good] -- store it [lexicographically preffered candidate when compared to last item in the stack -- \\'a\\']\\n...... and keep going on till the string ends; we now have the required string in the stack.\\n\\n```py3\\nclass Solution(object):\\n    def removeDuplicateLetters(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        \\'\\'\\'Let\\'s start with having three DS - counter for all the character frequecies in the string\\n                                            - a boolean list for the characters which we encounter so that we can skip them once they are encountered\\n                                            - a stack to store the lexicographically appropriate order of the string without the duplicates\\n        \\'\\'\\'\\n        countList = [0]*26\\n        boolList = [False]*26\\n        stack = []\\n        \\'\\'\\'Initializer the counter array\\'\\'\\'\\n        for character in s:\\n            countList[ord(character) - ord(\\'a\\')] += 1\\n\\n        \\'\\'\\'Traverse the given string\\'\\'\\'\\n        for character in s:\\n            \\'\\'\\'Decrease the count in the counter array as we came across this letter in a respective iteration\\'\\'\\'\\n            countList[ord(character)- ord(\\'a\\')] -= 1\\n            \\'\\'\\'skip the character altogether if we have encountered it already\\'\\'\\'\\n            if boolList[ord(character) - ord(\\'a\\')]:\\n                continue\\n\\n            \\'\\'\\'if the stack is not empty and the iterator points to a character which is smaller than the last element in the stack --> we need to skip all the characters in the stack which are bigger than the current item. And we can only skip the items if there is a chance of encountering them in the future so we also should check for this in this while loop threshold statment\\'\\'\\'\\n            while stack and character<stack[-1] and countList[ord(stack[-1]) - ord(\\'a\\')] >0:\\n                \\'\\'\\'the control comes here only if the logic found candidates to be removed from the stack. Hence lets just reverse the boolean values for these items as we should consider them fresh new items when we encounter them in the future so that we don\\'t skip them\\'\\'\\'\\n                boolList[ord(stack[-1]) - ord(\\'a\\')] = False\\n                \\'\\'\\'pop the item\\'\\'\\'\\n                stack.pop()\\n\\n            \\'\\'\\'just add the item to the stack\\'\\'\\'\\n            stack.append(character)\\n\\n            \\'\\'\\'Don\\'t forget to switch the boolean key ON for this item, so we can skip it, if possible\\'\\'\\'\\n            boolList[ord(character) - ord(\\'a\\')] = True \\n\\n        return \\'\\'.join(stack)\\n```\\n\\n```\\n```\\nyou can also checkout -> https://github.com/adaggarwal/leetcode1992\\n```\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```py3\\nclass Solution(object):\\n    def removeDuplicateLetters(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        \\'\\'\\'Let\\'s start with having three DS - counter for all the character frequecies in the string\\n                                            - a boolean list for the characters which we encounter so that we can skip them once they are encountered\\n                                            - a stack to store the lexicographically appropriate order of the string without the duplicates\\n        \\'\\'\\'\\n        countList = [0]*26\\n        boolList = [False]*26\\n        stack = []\\n        \\'\\'\\'Initializer the counter array\\'\\'\\'\\n        for character in s:\\n            countList[ord(character) - ord(\\'a\\')] += 1\\n\\n        \\'\\'\\'Traverse the given string\\'\\'\\'\\n        for character in s:\\n            \\'\\'\\'Decrease the count in the counter array as we came across this letter in a respective iteration\\'\\'\\'\\n            countList[ord(character)- ord(\\'a\\')] -= 1\\n            \\'\\'\\'skip the character altogether if we have encountered it already\\'\\'\\'\\n            if boolList[ord(character) - ord(\\'a\\')]:\\n                continue\\n\\n            \\'\\'\\'if the stack is not empty and the iterator points to a character which is smaller than the last element in the stack --> we need to skip all the characters in the stack which are bigger than the current item. And we can only skip the items if there is a chance of encountering them in the future so we also should check for this in this while loop threshold statment\\'\\'\\'\\n            while stack and character<stack[-1] and countList[ord(stack[-1]) - ord(\\'a\\')] >0:\\n                \\'\\'\\'the control comes here only if the logic found candidates to be removed from the stack. Hence lets just reverse the boolean values for these items as we should consider them fresh new items when we encounter them in the future so that we don\\'t skip them\\'\\'\\'\\n                boolList[ord(stack[-1]) - ord(\\'a\\')] = False\\n                \\'\\'\\'pop the item\\'\\'\\'\\n                stack.pop()\\n\\n            \\'\\'\\'just add the item to the stack\\'\\'\\'\\n            stack.append(character)\\n\\n            \\'\\'\\'Don\\'t forget to switch the boolean key ON for this item, so we can skip it, if possible\\'\\'\\'\\n            boolList[ord(character) - ord(\\'a\\')] = True \\n\\n        return \\'\\'.join(stack)\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76841,
                "title": "clean-and-easy-understand-java-stack-solution-with-explanation",
                "content": "The basic idea is to go through the given string char by char. If the current char has been used in the solution string, continue our loop to next char; If not, keep replacing the last char of current solution string with our current char being considered if the current character is smaller, then add current char to solution string.\\n\\nThe process requires an int array and a Boolean array to store the appearances and status(used or not) of each letter. And a stack is used to conveniently push and pop chars.\\n\\n    public String removeDuplicateLetters(String s) {\\n\\n\\t\\tStack<Character> stack = new Stack<Character>();\\n\\n         // appearance count\\n\\t\\tint[] count = new int[26];\\n        // used or not;\\n\\t\\tboolean[] added = new boolean[26];\\n\\n        // count appearances\\n\\t\\tfor (char ch : s.toCharArray())\\n\\t\\t\\tcount[ch - 'a']++;\\n\\n        // go through each char\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\t\\n\\t\\t\\tcount[ch - 'a']--;\\n\\t\\t\\t\\n\\t\\t\\tif (added[ch - 'a'])\\n\\t\\t\\t\\tcontinue;\\n\\n            // poping out the char which is bigger and still has some left in behind\\n\\t\\t\\twhile (!stack.isEmpty() && stack.peek() > ch\\n\\t\\t\\t\\t\\t&& count[stack.peek() - 'a'] > 0)\\n\\t\\t\\t\\tadded[stack.pop() - 'a'] = false;\\n\\n           // add current one\\n\\t\\t\\tstack.push(ch);\\n\\t\\t\\tadded[ch - 'a'] = true;\\n\\t\\t}\\n\\n           // move from stack to string\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\tsb.append(stack.pop());\\n\\t\\t}\\n\\n\\t\\treturn sb.reverse().toString();\\n\\n\\t}",
                "solutionTags": [],
                "code": "The basic idea is to go through the given string char by char. If the current char has been used in the solution string, continue our loop to next char; If not, keep replacing the last char of current solution string with our current char being considered if the current character is smaller, then add current char to solution string.\\n\\nThe process requires an int array and a Boolean array to store the appearances and status(used or not) of each letter. And a stack is used to conveniently push and pop chars.\\n\\n    public String removeDuplicateLetters(String s) {\\n\\n\\t\\tStack<Character> stack = new Stack<Character>();\\n\\n         // appearance count\\n\\t\\tint[] count = new int[26];\\n        // used or not;\\n\\t\\tboolean[] added = new boolean[26];\\n\\n        // count appearances\\n\\t\\tfor (char ch : s.toCharArray())\\n\\t\\t\\tcount[ch - 'a']++;\\n\\n        // go through each char\\n\\t\\tfor (char ch : s.toCharArray()) {\\n\\t\\t\\t\\n\\t\\t\\tcount[ch - 'a']--;\\n\\t\\t\\t\\n\\t\\t\\tif (added[ch - 'a'])\\n\\t\\t\\t\\tcontinue;\\n\\n            // poping out the char which is bigger and still has some left in behind\\n\\t\\t\\twhile (!stack.isEmpty() && stack.peek() > ch\\n\\t\\t\\t\\t\\t&& count[stack.peek() - 'a'] > 0)\\n\\t\\t\\t\\tadded[stack.pop() - 'a'] = false;\\n\\n           // add current one\\n\\t\\t\\tstack.push(ch);\\n\\t\\t\\tadded[ch - 'a'] = true;\\n\\t\\t}\\n\\n           // move from stack to string\\n\\t\\tStringBuilder sb = new StringBuilder();\\n\\t\\twhile (!stack.isEmpty()) {\\n\\t\\t\\tsb.append(stack.pop());\\n\\t\\t}\\n\\n\\t\\treturn sb.reverse().toString();\\n\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 76813,
                "title": "short-16ms-o-n-c-solution-using-stack-which-can-be-optimized-down-to-4ms",
                "content": "    class Solution {\\n    public:\\n        string removeDuplicateLetters(string s) {\\n            unordered_map<char, int> cnts;\\n            string ret;\\n            stack<char> stk;\\n            vector<bool> isVisited(26, false);\\n            for (char each : s) cnts[each] ++;\\n            for (int i = 0; i < s.size(); cnts[s[i]] --, ++ i) {\\n                if (isVisited[s[i] - 'a'] || (!stk.empty() && stk.top() == s[i])) continue;\\n                while (!stk.empty() && stk.top() > s[i] && cnts[stk.top()] > 0) {\\n                    isVisited[stk.top() - 'a'] = false;\\n                    stk.pop();\\n                }\\n                stk.push(s[i]);\\n                isVisited[s[i] - 'a'] = true;\\n            }\\n            while (!stk.empty()) {\\n                ret.push_back(stk.top());\\n                stk.pop();\\n            }\\n            reverse(ret.begin(), ret.end());\\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\n    public:\\n        string removeDuplicateLetters(string s) {\\n            unordered_map<char, int> cnts;\\n            string ret;\\n            stack<char> stk;\\n            vector<bool> isVisited(26, false);\\n            for (char each : s) cnts[each] ++;\\n            for (int i = 0; i < s.size(); cnts[s[i]] --, ++ i) {\\n                if (isVisited[s[i] - 'a'] || (!stk.empty() && stk.top() == s[i])) continue;\\n                while (!stk.empty() && stk.top() > s[i] && cnts[stk.top()] > 0) {\\n                    isVisited[stk.top() - 'a'] = false;\\n                    stk.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 977608,
                "title": "use-stack-to-solve-by-js-94-89-fast-100-less-memory-with-explaination",
                "content": "Source: https://leetcode-cn.com/problems/remove-duplicate-letters/solution/jsshi-xian-nei-cun-chao-guo-100su-du-chao-guo-82-b/\\n\\nThis was solved by another great person [careteenl](https://leetcode-cn.com/u/careteenl/) in leetcode China, I share this since I found this very easy to understand and clean\\n\\nFirst, we need to know that JavaScript compare string by dictionary order, which means\\n```\\n\"zoo\" > \"apple\"\\n```\\nwill return true since in dictionary if you turn page by page apple will always appear earlier than zoo.\\nWe can use array but as stack and compare letter to solve this. First we define array called stack:\\n```\\nvar stack = [];\\n```\\nand we can start to iterate input s\\n```\\nfor (var i = 0; i < s.length; i++) {\\n  // ...\\n}\\n```\\nand we need to check:\\n* Is top of stack\\'s dictionary order bigger than s[i] ?\\n* If yes, does top of stack appear in characters later than s[i] ?\\n\\nIf both of the situations are achieved, we need to remove top of the stack, and do it again until stack is empty. Finally We put the s[i] at top of stack. We remove the letters because the dictionary order of the letter is greater than s[i], and it will appears again, so we can still put it after next loop.\\n\\nAnd if s[i] is already existed in stack, we won\\'t need to run the check loop again since stack is already sorted in dictionary order. Full code:\\n```\\nvar removeDuplicateLetters = function (s) {\\n  var stack = [];\\n  for (var i = 0; i < s.length; i++) {\\n    var char = s[i];\\n    // if s[i] already appears in stack, jump to next loop\\n    if (stack.indexOf(char) > -1) continue;\\n   while (\\n      // when stack is not empty\\n      stack.length > 0 &&\\n      // when top of stack letter dictionary order is greater than s[i](z > a)\\n      stack[stack.length - 1] > char &&\\n      // when top of stack letter still appears in s not iterated yet letters\\n      s.indexOf(stack[stack.length - 1], i) > i\\n    ) {\\n      // remove top of stack\\n      stack.pop();\\n    }\\n    // put s[i] into top of stack\\n    stack.push(char);\\n  }\\n  return stack.join(\"\");\\n};\\n```\\n\\nSorry my English is horrible since I\\'m not a naive English speaker, I hope at least the solve helps if the explanation does not.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\"zoo\" > \"apple\"\\n```\n```\\nvar stack = [];\\n```\n```\\nfor (var i = 0; i < s.length; i++) {\\n  // ...\\n}\\n```\n```\\nvar removeDuplicateLetters = function (s) {\\n  var stack = [];\\n  for (var i = 0; i < s.length; i++) {\\n    var char = s[i];\\n    // if s[i] already appears in stack, jump to next loop\\n    if (stack.indexOf(char) > -1) continue;\\n   while (\\n      // when stack is not empty\\n      stack.length > 0 &&\\n      // when top of stack letter dictionary order is greater than s[i](z > a)\\n      stack[stack.length - 1] > char &&\\n      // when top of stack letter still appears in s not iterated yet letters\\n      s.indexOf(stack[stack.length - 1], i) > i\\n    ) {\\n      // remove top of stack\\n      stack.pop();\\n    }\\n    // put s[i] into top of stack\\n    stack.push(char);\\n  }\\n  return stack.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 234240,
                "title": "c",
                "content": "From the input string, we are trying to build a monotonically increasing result string.\\n\\nIf the input character is smaller than the back of the result string, we remove larger characters from the back **providing** there are more occurrences of that character in the input string.\\n```\\nstring removeDuplicateLetters(string s, string res = \"\") {\\n  int cnt[26] = {}, used[26] = {};\\n  for (auto ch : s) ++cnt[ch - \\'a\\'];\\n  for (auto ch : s) {\\n    --cnt[ch - \\'a\\'];\\n    if (used[ch - \\'a\\']++ > 0) continue;\\n    while (!res.empty() && res.back() > ch && cnt[res.back() - \\'a\\'] > 0) {\\n      used[res.back() - \\'a\\'] = 0;\\n      res.pop_back();\\n    }\\n    res.push_back(ch);\\n  }\\n  return res;\\n}\\n```\\n## Complexity Analysis\\nRuntime: O(n). We process each input character no more than 2 times.\\nMemory: O(1). We need the constant memory to track up to 26 unique letters.",
                "solutionTags": [],
                "code": "```\\nstring removeDuplicateLetters(string s, string res = \"\") {\\n  int cnt[26] = {}, used[26] = {};\\n  for (auto ch : s) ++cnt[ch - \\'a\\'];\\n  for (auto ch : s) {\\n    --cnt[ch - \\'a\\'];\\n    if (used[ch - \\'a\\']++ > 0) continue;\\n    while (!res.empty() && res.back() > ch && cnt[res.back() - \\'a\\'] > 0) {\\n      used[res.back() - \\'a\\'] = 0;\\n      res.pop_back();\\n    }\\n    res.push_back(ch);\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 696815,
                "title": "python-simple-solution-with-stack",
                "content": "```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        ## RC ##\\n\\t\\t## APPROACH : STACK ##\\n\\t\\t## 100% Same Problem Leetcode 1081. Smallest Subsequence of Distinct Characters ##\\n\\t\\t## LOGIC ##\\n\\t\\t#\\t1. We add element to the stack\\n\\t\\t#\\t2. IF we get bigger element, we just push on top\\n\\t\\t#\\t3. ELSE we pop if and only if there are other occurances of same letter again in the string, otherwise we donot pop\\n\\t\\t#\\t4. If an element is already in the stack, we donot push.\\n\\t\\t## TIME COMPLEXICITY : O(N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(N) ##\\n\\t\\n\\t\\t## EXAMPLE : \"cdadabcc\"\\t##\\n\\t\\t## STACK TRACE ##\\n        # {\\'c\\': 7, \\'d\\': 3, \\'a\\': 4, \\'b\\': 5}\\n        # [\\'c\\']\\n        # [\\'c\\', \\'d\\']\\n        # [\\'a\\']\\n        # [\\'a\\', \\'d\\']\\n        # [\\'a\\', \\'d\\', \\'b\\']\\n        # [\\'a\\', \\'d\\', \\'b\\', \\'c\\']\\n        \\n        stack = []\\n        seen = set()\\n        last_occurance = {}\\n        for i in range(len(s)):\\n            last_occurance[ s[i] ] = i\\n        \\n        # print(last_occurance)\\n        \\n        for i, ch in enumerate(s):\\n            if( ch in seen ):\\n                continue\\n            else:\\n                # 3\\n                while( stack and stack[-1] > ch and last_occurance[stack[-1]] > i ):\\n                    removed_char = stack.pop()\\n                    seen.remove(removed_char)\\n                seen.add(ch)\\n                stack.append(ch)\\n            # print(stack)\\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        ## RC ##\\n\\t\\t## APPROACH : STACK ##\\n\\t\\t## 100% Same Problem Leetcode 1081. Smallest Subsequence of Distinct Characters ##\\n\\t\\t## LOGIC ##\\n\\t\\t#\\t1. We add element to the stack\\n\\t\\t#\\t2. IF we get bigger element, we just push on top\\n\\t\\t#\\t3. ELSE we pop if and only if there are other occurances of same letter again in the string, otherwise we donot pop\\n\\t\\t#\\t4. If an element is already in the stack, we donot push.\\n\\t\\t## TIME COMPLEXICITY : O(N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(N) ##\\n\\t\\n\\t\\t## EXAMPLE : \"cdadabcc\"\\t##\\n\\t\\t## STACK TRACE ##\\n        # {\\'c\\': 7, \\'d\\': 3, \\'a\\': 4, \\'b\\': 5}\\n        # [\\'c\\']\\n        # [\\'c\\', \\'d\\']\\n        # [\\'a\\']\\n        # [\\'a\\', \\'d\\']\\n        # [\\'a\\', \\'d\\', \\'b\\']\\n        # [\\'a\\', \\'d\\', \\'b\\', \\'c\\']\\n        \\n        stack = []\\n        seen = set()\\n        last_occurance = {}\\n        for i in range(len(s)):\\n            last_occurance[ s[i] ] = i\\n        \\n        # print(last_occurance)\\n        \\n        for i, ch in enumerate(s):\\n            if( ch in seen ):\\n                continue\\n            else:\\n                # 3\\n                while( stack and stack[-1] > ch and last_occurance[stack[-1]] > i ):\\n                    removed_char = stack.pop()\\n                    seen.remove(removed_char)\\n                seen.add(ch)\\n                stack.append(ch)\\n            # print(stack)\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859356,
                "title": "this-problem-is-hard",
                "content": "It took me such a long time to solve even with reading several hints from the discussion. It contains several key methods:\\n1. Gready algorithm: the difficulty part is how to prove the correctness. I did not try that yet.\\n2.  Monotonic stack\\n3.  Bit mask. Of course, you can use an alternative approach by not using the bit mask if you don\\'t want to.\\n\\n\\nThe highlevel logic is:\\n1. Put the res in a stack, each time, check whether the back of the res is larger than the current one.\\n2. If the back is larger, then we have possibility to generate a smaller one by pop the last one and push the current one. \\n3. The step 2 can be repeated if the back is always larger than current one. Such as   YZaYZ case, when meet a, you can keep on pop the Y and then Z as you have Y and Z later. The res update process for this exmaple is :\\n```bash\\nFor easy demo, the Y, Z should be lower case.\\nY : res = \"Y\"\\nZ:  res = \"YZ\"\\na:  res \"YZ\", Z > a, we have  Z in the future, pop Z, got \"Y\". Similar, pop Y and push a we update res = \"a\"\\nY: res = \"aY\"\\nZ: res = \"aYZ\".\\n\\n```\\n4. The step 2 should be stopped if the back is the only letter left. If you pop the only letter, you will fail.\\n5. Pls check whether the current letter is already visited or not. If already visited, do not need do anything.\\n\\nI am using a bit mask from back to front to indicate whether a specified letter still exist in the future. The mask building process took O(n) and the one pass took O(n), the overrall time complexity is O(n)\\n\\n\\n```cpp\\nclass Solution {\\n    public:\\n    bool seen(int visited, char c){\\n        return visited &(1 << (c - \\'a\\'));\\n    }\\n    string removeDuplicateLetters(string s) {\\n        const int n = s.size();\\n\\t\\t// build bitmask from back. If you are not familar with bitmask, you will feel this is hard to understand.\\n        vector<int> masks(n+1, 0);\\n        for (int i = n -1; i >=0 ; --i){\\n            masks[i] = masks[i+1] | (1 << (s[i] - \\'a\\'));\\n        }\\n        string ret;\\n        int visited = 0;\\n        for (int i = 0; i < n; ++i){\\n            while (!ret.empty() && (!seen(visited, s[i]))&& ret.back() > s[i]){\\n                // if the back is not the last element\\n                if (masks[i+1] & (1 << (ret.back() - \\'a\\'))){\\n                    visited ^= (1 << (ret.back() - \\'a\\'));\\n                    ret.pop_back();\\n                } else {\\n                    break;\\n                }  \\n            }\\n            if (!(seen(visited, s[i]))){\\n                visited |= (1 << (s[i] - \\'a\\'));\\n                ret.push_back(s[i]);\\n            }\\n\\n        }\\n        return ret;\\n\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```bash\\nFor easy demo, the Y, Z should be lower case.\\nY : res = \"Y\"\\nZ:  res = \"YZ\"\\na:  res \"YZ\", Z > a, we have  Z in the future, pop Z, got \"Y\". Similar, pop Y and push a we update res = \"a\"\\nY: res = \"aY\"\\nZ: res = \"aYZ\".\\n\\n```\n```cpp\\nclass Solution {\\n    public:\\n    bool seen(int visited, char c){\\n        return visited &(1 << (c - \\'a\\'));\\n    }\\n    string removeDuplicateLetters(string s) {\\n        const int n = s.size();\\n\\t\\t// build bitmask from back. If you are not familar with bitmask, you will feel this is hard to understand.\\n        vector<int> masks(n+1, 0);\\n        for (int i = n -1; i >=0 ; --i){\\n            masks[i] = masks[i+1] | (1 << (s[i] - \\'a\\'));\\n        }\\n        string ret;\\n        int visited = 0;\\n        for (int i = 0; i < n; ++i){\\n            while (!ret.empty() && (!seen(visited, s[i]))&& ret.back() > s[i]){\\n                // if the back is not the last element\\n                if (masks[i+1] & (1 << (ret.back() - \\'a\\'))){\\n                    visited ^= (1 << (ret.back() - \\'a\\'));\\n                    ret.pop_back();\\n                } else {\\n                    break;\\n                }  \\n            }\\n            if (!(seen(visited, s[i]))){\\n                visited |= (1 << (s[i] - \\'a\\'));\\n                ret.push_back(s[i]);\\n            }\\n\\n        }\\n        return ret;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890696,
                "title": "step-by-step-monotonic-stack-o-n-python-solution",
                "content": "*Ideally* we want the letters in our subsequence to be strictly increasing. For example, **abcd** is lexicographically smaller than **abdc**. Thus, a monotonically increasing stack will be useful here. The code below shows the maintenance of the monotonic stack:\\n\\n```python\\nst = []\\nfor char in s:\\n\\twhile st and st[-1] > char:\\n\\t\\tst.pop()\\n\\tst.append(char)\\n```\\n\\nObviously this isn\\'t enough to solve the problem. For starters, we would like our stack to contain unique characters. Let\\'s use a `set` to keep track of which characters are currently in the stack. \\n```python\\nst = []\\ntaken = set() # initialize set\\nfor char in s:\\n\\tif char not in taken: # check if character already in stack\\n\\t\\twhile st and st[-1] > char:\\n\\t\\t\\ttaken.remove(st.pop()) # remove from both stack and set\\n\\t\\tst.append(char)\\n\\t\\ttaken.add(char)  # add character to set\\nreturn \\'\\'.join(st)\\n```\\nWe\\'re getting close, this code will actually work for simple test cases. To see why the code isn\\'t complete, let\\'s look at **Example 2** from the problem statement\\n```\\nInput: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n```\\nThe desired output is a subsequence that is **NOT** strictly increasing. This is because there is only one **d** in the string. If we were to evict it while maintaining the monotonic stack, we would have no more instances of **d** to grab. Thus, in our `while` loop we need to check if there are any more instances of the character we are about to evict. If there aren\\'t, we have no choice but to keep it in our stack. We use a frequency hashmap to keep track of which characters are left.\\n```python\\ncount = Counter(s) # initialize frequency hashmap\\nst = []\\ntaken = set()\\nfor char in s:\\n\\tif char not in taken:\\n\\t\\t# check if there are any more instances of the evicting character\\n\\t\\twhile st and st[-1] > char and count[st[-1]] > 0:\\n\\t\\t\\ttaken.remove(st.pop())\\n\\t\\tst.append(char)\\n\\t\\ttaken.add(char)\\n\\tcount[char] -= 1 # finish processing this character\\nreturn \\'\\'.join(st)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```python\\nst = []\\nfor char in s:\\n\\twhile st and st[-1] > char:\\n\\t\\tst.pop()\\n\\tst.append(char)\\n```\n```python\\nst = []\\ntaken = set() # initialize set\\nfor char in s:\\n\\tif char not in taken: # check if character already in stack\\n\\t\\twhile st and st[-1] > char:\\n\\t\\t\\ttaken.remove(st.pop()) # remove from both stack and set\\n\\t\\tst.append(char)\\n\\t\\ttaken.add(char)  # add character to set\\nreturn \\'\\'.join(st)\\n```\n```\\nInput: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n```\n```python\\ncount = Counter(s) # initialize frequency hashmap\\nst = []\\ntaken = set()\\nfor char in s:\\n\\tif char not in taken:\\n\\t\\t# check if there are any more instances of the evicting character\\n\\t\\twhile st and st[-1] > char and count[st[-1]] > 0:\\n\\t\\t\\ttaken.remove(st.pop())\\n\\t\\tst.append(char)\\n\\t\\ttaken.add(char)\\n\\tcount[char] -= 1 # finish processing this character\\nreturn \\'\\'.join(st)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 76777,
                "title": "java-o-n-iterative-greedy-solution",
                "content": "I used StringBuilder to build the solution.  First we count all the characters in the string, and then when we iterate the string, when we see a smaller char than the previous one, we greedily remove the previous ones as long as there are still same chars later.  A visited array is used to make sure than we only take same character to the left because we want the lexi smallest sequence.\\n\\n    public class Solution {\\n        public String removeDuplicateLetters(String s) {\\n            int[] count = new int[26];\\n            char[] chars = s.toCharArray();\\n            for(char c : chars) {\\n                count[c-'a']++;\\n            }\\n            StringBuilder sb = new StringBuilder();\\n            boolean[] visited = new boolean[26];\\n            for(char c : chars) {\\n                count[c-'a']--;\\n                if(visited[c-'a']) {\\n                    continue;\\n                }\\n                while(sb.length() > 0 && c <= sb.charAt(sb.length() - 1) && count[sb.charAt(sb.length() - 1)-'a'] > 0) {\\n                    visited[sb.charAt(sb.length() - 1)-'a'] = false;\\n                    sb.deleteCharAt(sb.length() - 1);\\n                }\\n                sb.append(c);\\n                visited[c-'a'] = true;\\n            }\\n            return sb.toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n        public String removeDuplicateLetters(String s) {\\n            int[] count = new int[26];\\n            char[] chars = s.toCharArray();\\n            for(char c : chars) {\\n                count[c-'a']++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 76833,
                "title": "java-2ms-two-pointers-solution-or-stack-simulation-beats-99-72",
                "content": "    public String removeDuplicateLetters(String s) {\\n\\t\\t\\t/**\\n\\t\\t\\t * First loop: use an array cnt[] to count the number of times\\n\\t\\t\\t * appeared for each letter in s.\\n\\t\\t\\t * \\n\\t\\t\\t * Second loop (Greedy): use a stack, pop() while (!stack.isEmpty()\\n\\t\\t\\t * && (sc = stack.peek()) >= c && cnt[sc] > 0)\\n\\t\\t\\t */\\n\\n\\t\\t\\tint i, n = s.length();\\n\\t\\t\\tint[] cnt = new int[128];\\n\\t\\t\\tboolean[] inRes = new boolean[128]; // whether a char is in res[]\\n\\t\\t\\tchar[] res = s.toCharArray(); // simulate a stack\\n\\n\\t\\t\\tfor (i = 0; i < n; i++)\\n\\t\\t\\t\\tcnt[res[i]]++;\\n\\n\\t\\t\\tchar c, sc;\\n\\t\\t\\tint end = -1;\\n\\t\\t\\t// now cnt[c] means the remaining count of the char c\\n\\t\\t\\tfor (i = 0; i < n; i++) {\\n\\t\\t\\t\\tc = res[i];\\n\\t\\t\\t\\tif (inRes[c]) {\\n\\t\\t\\t\\t\\tcnt[c]--;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\twhile (end >= 0 && (sc = res[end]) >= c && cnt[sc] > 0) {\\n\\t\\t\\t\\t\\tend--;\\n\\t\\t\\t\\t\\tinRes[sc] = false;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tres[++end] = c;\\n\\t\\t\\t\\tcnt[c]--;\\n\\t\\t\\t\\tinRes[c] = true;\\n\\t\\t\\t}\\n\\t\\t\\treturn String.valueOf(res).substring(0, end + 1);\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "    public String removeDuplicateLetters(String s) {\\n\\t\\t\\t/**\\n\\t\\t\\t * First loop: use an array cnt[] to count the number of times\\n\\t\\t\\t * appeared for each letter in s.\\n\\t\\t\\t * \\n\\t\\t\\t * Second loop (Greedy): use a stack, pop() while (!stack.isEmpty()\\n\\t\\t\\t * && (sc = stack.peek()) >= c && cnt[sc] > 0)\\n\\t\\t\\t */\\n\\n\\t\\t\\tint i, n = s.length();\\n\\t\\t\\tint[] cnt = new int[128];\\n\\t\\t\\tboolean[] inRes = new boolean[128]; // whether a char is in res[]\\n\\t\\t\\tchar[] res = s.toCharArray(); // simulate a stack\\n\\n\\t\\t\\tfor (i = 0; i < n; i++)\\n\\t\\t\\t\\tcnt[res[i]]++;\\n\\n\\t\\t\\tchar c, sc;\\n\\t\\t\\tint end = -1;\\n\\t\\t\\t// now cnt[c] means the remaining count of the char c\\n\\t\\t\\tfor (i = 0; i < n; i++) {\\n\\t\\t\\t\\tc = res[i];\\n\\t\\t\\t\\tif (inRes[c]) {\\n\\t\\t\\t\\t\\tcnt[c]--;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\twhile (end >= 0 && (sc = res[end]) >= c && cnt[sc] > 0) {\\n\\t\\t\\t\\t\\tend--;\\n\\t\\t\\t\\t\\tinRes[sc] = false;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tres[++end] = c;\\n\\t\\t\\t\\tcnt[c]--;\\n\\t\\t\\t\\tinRes[c] = true;\\n\\t\\t\\t}\\n\\t\\t\\treturn String.valueOf(res).substring(0, end + 1);\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1229567,
                "title": "c-stack-detailed-explanation-0ms",
                "content": "Lets deep dive into the solution:\\nHere in the solution ``` visited ``` is the map which helps to track of each character whether i have visited or not\\n\\nHere ```  lastIdx ``` is where we keep track of the last Index of every char eg **abddcabbe**   if we make this array of last index then it will look something like this *[a => 5 , b => 7 , c => 4 , e => 8 ]*\\n\\nApart from this we have taken stack ``` stc ``` in which we will store our final variable\\n\\nLets take a example to understand :\\n\\nstring ``` s ```= **\"bcabc\"**\\n\\nIn the first loop it will mark all the numbers from 1-26 as ```false``` as in starting all the characters are not visited the next loop ``` lastIdx ``` will keep the track of the last visited number of individual character.\\n\\nHere comes the main logic \\n* If the value in ```  visited ``` is already visited we just continue with our solution.\\n* Now we check of the. stack is empty or not and also followed by a condition where the stack top value > the current val.\\neg 1st iteration  -->``` b ```  will enter in the loop and will not go in any condition so its pushed into the stack\\n2nd value will be ``` c ``` now the stack is not empty (1st condition satisfied) we check with ```stc.top()``` that is ```b``` will check if ```b``` >``` c ``` this condition doesnt satisfied so the value will be pushed into the stack.\\n\\nThis way doing the dry run we can reach to our solution below is the code \\n\\nIf you liked it do click on **UPVOTE** button \\n\\n\\n```\\n  stack<int> stc;\\n        unordered_map<int,bool> visited;\\n        int lastIdx[26] ;\\n        string ans = \"\";\\n        for(int i=1 ; i<=26;i++)\\n            visited[i] = false;\\n        \\n        for(int i=0 ; i<s.size();i++)\\n            lastIdx[s[i] - \\'a\\'] = i;\\n        \\n        for(int i=0 ; i<s.size();i++){\\n             int val = s[i] - \\'a\\';\\n            if(visited[val]) continue;\\n            while(!stc.empty()  && stc.top() > val && lastIdx[stc.top()] > i){\\n                visited[stc.top()] = false;\\n                 stc.pop();\\n            }\\n            stc.push(val);\\n            visited[val] = true;\\n        }\\n        while(!stc.empty()){\\n            ans+= stc.top() + \\'a\\';\\n            stc.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "``` visited ```\n```  lastIdx ```\n``` stc ```\n``` s ```\n```false```\n``` lastIdx ```\n```  visited ```\n``` b ```\n``` c ```\n```stc.top()```\n```b```\n```b```\n``` c ```\n```\\n  stack<int> stc;\\n        unordered_map<int,bool> visited;\\n        int lastIdx[26] ;\\n        string ans = \"\";\\n        for(int i=1 ; i<=26;i++)\\n            visited[i] = false;\\n        \\n        for(int i=0 ; i<s.size();i++)\\n            lastIdx[s[i] - \\'a\\'] = i;\\n        \\n        for(int i=0 ; i<s.size();i++){\\n             int val = s[i] - \\'a\\';\\n            if(visited[val]) continue;\\n            while(!stc.empty()  && stc.top() > val && lastIdx[stc.top()] > i){\\n                visited[stc.top()] = false;\\n                 stc.pop();\\n            }\\n            stc.push(val);\\n            visited[val] = true;\\n        }\\n        while(!stc.empty()){\\n            ans+= stc.top() + \\'a\\';\\n            stc.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 906973,
                "title": "c-simple-with-comments-0-ms-faster-than-100-00-easy-buzzy",
                "content": "```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Remove Duplicate Letters.\\nMemory Usage: 7 MB, less than 7.67% of C++ online submissions for Remove Duplicate Letters.\\n```\\n#### TC -- O(String length)\\n#### SC -- O(1)                 //26 is constant\\n\\n### Approach:- Just think in the way, we need least ascii characters at first in result string, and if they are repeating we don\\'t care anymore. If in string last character having greater ascii value and can be placed anywhere further because of it\\'s repetitive nature (count in counting array) that\\'s why we are saying taken = false\\n\\n## {1,2,3} in lexicographic order are 123, 132, 213, 231, 312, and 321. Observe this pattern as 1<2<3 for smallest lexicographic\\n\\n#### *I have chosen naming of variable in very simple way. I hope you\\'ll understand very easily, if not, please comment down*\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int *count = new int[26];\\n        bool *taken = new bool[26];\\n\\n        for (int i = 0; i < 26; i++){\\n            count[i] = 0;\\n            taken[i] = 0;      //false\\n        }\\n\\n        for (auto it : s) {\\n            int ch = it - 97;\\n            count[ch]++;\\n        }\\n         string result = \"\";\\n        for (auto it : s) {\\n            int ch = it - 97;                 //97 is the ascii value of \\'a\\'\\n\\t\\t                          \\t          //whenever you do any operation on characters, you are mainly doing operations on their ascii value \\n\\t\\t\\t                                 //if you subtract two characters, you\\'ll get result as ascii value. And then it\\'s upto on you if you want to convert that ascii into character or want it into \"int\" only.\\n            count[ch]--;\\n\\n            if (taken[ch])       // already present in result\\n                continue;\\n\\n            while (!result.empty() && it < result.back() && count[result.back()-97]) {\\n                taken[result.back()-97] = false;    //we don\\'t want this bigger in front side in resultant string and due to it\\'s reptition in upcoming stream, can be placed further according to requirement. so,now not in result\\n                result.pop_back();\\n            }\\n            result += it;\\n            taken[ch] = true;    // mark that we have taken smallest ascii value character, here taking into result\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Remove Duplicate Letters.\\nMemory Usage: 7 MB, less than 7.67% of C++ online submissions for Remove Duplicate Letters.\\n```\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int *count = new int[26];\\n        bool *taken = new bool[26];\\n\\n        for (int i = 0; i < 26; i++){\\n            count[i] = 0;\\n            taken[i] = 0;      //false\\n        }\\n\\n        for (auto it : s) {\\n            int ch = it - 97;\\n            count[ch]++;\\n        }\\n         string result = \"\";\\n        for (auto it : s) {\\n            int ch = it - 97;                 //97 is the ascii value of \\'a\\'\\n\\t\\t                          \\t          //whenever you do any operation on characters, you are mainly doing operations on their ascii value \\n\\t\\t\\t                                 //if you subtract two characters, you\\'ll get result as ascii value. And then it\\'s upto on you if you want to convert that ascii into character or want it into \"int\" only.\\n            count[ch]--;\\n\\n            if (taken[ch])       // already present in result\\n                continue;\\n\\n            while (!result.empty() && it < result.back() && count[result.back()-97]) {\\n                taken[result.back()-97] = false;    //we don\\'t want this bigger in front side in resultant string and due to it\\'s reptition in upcoming stream, can be placed further according to requirement. so,now not in result\\n                result.pop_back();\\n            }\\n            result += it;\\n            taken[ch] = true;    // mark that we have taken smallest ascii value character, here taking into result\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859346,
                "title": "c-2-approaches-greedy-o-n-easy-expalantion",
                "content": "\\n**Approach 1**\\n\\n**Digramatic Explanation**\\n![image](https://assets.leetcode.com/users/images/834f7347-a9f9-422e-a4c8-1f55a63ceca5_1647567645.4863443.jpeg)\\n\\n**Code**\\n\\n**Time complexity: O(N)**\\n**Space complexity: O(N)**\\n\\n```\\n//Will use greddy approach\\n//While iterating i will check if element at i greater than i+1\\n//and i is duplicated then we can remove element i\\n\\n//Time complexity: O(N)\\n//Space complexity: O(N)\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        //Frequency of each character\\n        vector<int> count(26,0);\\n        for(int i=0;i<s.length();i++){\\n            count[s[i]-\\'a\\']++;\\n        }\\n        //Is the current char is visited\\n        vector<int> visited(26,0);\\n        //Result\\n        string ans=\"\";\\n        //Iterating\\n        for(int i=0;i<s.length();i++){\\n            //Decrement the count\\n            count[s[i]-\\'a\\']--;\\n            if(!visited[s[i]-\\'a\\']){\\n                while(ans.length()>0 && ans.back()>s[i] && count[ans.back()-\\'a\\']>0){\\n                    visited[ans.back()-\\'a\\']=0;\\n                    ans.pop_back();\\n                }\\n                ans+=s[i];\\n                visited[s[i]-\\'a\\']=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach 2:**\\n\\n**Using stack**\\n\\n**Time complexity: O(N)**\\n**Space complexity: O(N)**\\n\\n```\\n//Will use greddy approach\\n//While iterating i will check if element at i greater than i+1\\n//and i is duplicated then we can remove element i\\n\\n//Time complexity: O(N)\\n//Space complexity: O(N)\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        //Will use stack to store output string\\n        stack<char> st;\\n        //to check is the element is seen earlier\\n        vector<int> seen(26,0);\\n        //Map to store the last occurence index\\n        unordered_map<char,int> last_index;\\n        for(int i=0;i<s.length();i++){\\n            last_index[s[i]]=i;\\n        }\\n        \\n        //Iterating \\n        for(int i=0;i<s.length();i++){\\n            char cur=s[i];\\n            //if char is not seen before\\n            if(!seen[cur-\\'a\\']){\\n                //We will check if current element is \\n                //less than element at top of stack\\n                //and repeating then remove that element\\n                while(!st.empty() and cur<st.top() and last_index[st.top()]>i){\\n                    seen[st.top()-\\'a\\']=0;\\n                    st.pop();\\n                }\\n                st.push(cur);\\n                seen[cur-\\'a\\']++;\\n            }\\n        }\\n        string ans;\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n//Will use greddy approach\\n//While iterating i will check if element at i greater than i+1\\n//and i is duplicated then we can remove element i\\n\\n//Time complexity: O(N)\\n//Space complexity: O(N)\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        //Frequency of each character\\n        vector<int> count(26,0);\\n        for(int i=0;i<s.length();i++){\\n            count[s[i]-\\'a\\']++;\\n        }\\n        //Is the current char is visited\\n        vector<int> visited(26,0);\\n        //Result\\n        string ans=\"\";\\n        //Iterating\\n        for(int i=0;i<s.length();i++){\\n            //Decrement the count\\n            count[s[i]-\\'a\\']--;\\n            if(!visited[s[i]-\\'a\\']){\\n                while(ans.length()>0 && ans.back()>s[i] && count[ans.back()-\\'a\\']>0){\\n                    visited[ans.back()-\\'a\\']=0;\\n                    ans.pop_back();\\n                }\\n                ans+=s[i];\\n                visited[s[i]-\\'a\\']=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n//Will use greddy approach\\n//While iterating i will check if element at i greater than i+1\\n//and i is duplicated then we can remove element i\\n\\n//Time complexity: O(N)\\n//Space complexity: O(N)\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        //Will use stack to store output string\\n        stack<char> st;\\n        //to check is the element is seen earlier\\n        vector<int> seen(26,0);\\n        //Map to store the last occurence index\\n        unordered_map<char,int> last_index;\\n        for(int i=0;i<s.length();i++){\\n            last_index[s[i]]=i;\\n        }\\n        \\n        //Iterating \\n        for(int i=0;i<s.length();i++){\\n            char cur=s[i];\\n            //if char is not seen before\\n            if(!seen[cur-\\'a\\']){\\n                //We will check if current element is \\n                //less than element at top of stack\\n                //and repeating then remove that element\\n                while(!st.empty() and cur<st.top() and last_index[st.top()]>i){\\n                    seen[st.top()-\\'a\\']=0;\\n                    st.pop();\\n                }\\n                st.push(cur);\\n                seen[cur-\\'a\\']++;\\n            }\\n        }\\n        string ans;\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890479,
                "title": "python-solution-explained-beats-100-video-code",
                "content": "[](https://www.youtube.com/watch?v=2ayws5Y-WM4)\\nhttps://www.youtube.com/watch?v=2ayws5Y-WM4\\n```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        d = {char: indx for indx, char in enumerate(s)}\\n        \\n        res = []\\n        \\n        for indx, char in enumerate(s):\\n            if char not in res:\\n                \\n                while res and indx < d[res[-1]] and char < res[-1]:\\n                    res.pop()\\n                    \\n                res.append(char)\\n        \\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        d = {char: indx for indx, char in enumerate(s)}\\n        \\n        res = []\\n        \\n        for indx, char in enumerate(s):\\n            if char not in res:\\n                \\n                while res and indx < d[res[-1]] and char < res[-1]:\\n                    res.pop()\\n                    \\n                res.append(char)\\n        \\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859791,
                "title": "java-easy-stack-hashmap-monotonic-stack",
                "content": "```\\n* LOGIC HERE IS WE STORE THE LAST INDEXES OF THE CHARACTERS.\\n* SO THAT AT ANY INDEX, IF CURRENT CHARACTER IS LESS THAN THE PEEK OF STACK AND\\n  ASSUMING IN FUTURE TRAVERSAL WE CAN ADD THAT PEEK CHARACTER BY USING IT\\'S LAST INDEX.\\n* ELSE WE SIMPLY PUSH THE CHARACTER INTO STACK IF IT IS NOT ADDED ATLEAST \\n  ONCE[WE USE ALPHA ARRAY FOR THIS PURPOSE]\\n```\\n```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        int[] alpha = new int[26];\\n        HashMap<Character, Integer> map =  new HashMap<>();\\n        Stack<Character> stack = new Stack<>();\\n        \\n        //Store the last Index of the character.\\n        for(int i = 0; i < s.length(); i++) map.put(s.charAt(i), i);\\n        \\n\\t\\t//TRAVERSE EACH CHARACTER\\n        for(int i = 0; i < s.length(); i++){\\n            char curr = s.charAt(i);\\n\\t\\t\\t\\n\\t\\t\\t//IF ALREADY ADDED, CONTINUE\\n            if(alpha[curr - \\'a\\'] == 1) continue;\\n\\t\\t\\t\\n\\t\\t\\t//IF WE CAN POP THE PEEK BECAUSE IN NEXT TRAVERSAL I CAN ADD THIS CHARACTER \\n\\t\\t\\t//BY USING IT\\'S LAST INDEX.\\n            while(!stack.isEmpty() && curr < stack.peek() && i < map.get(stack.peek())){\\n\\t\\t\\t// ONCE I POP I HAVE TO CHANGE THE ALPHA ARRAY TOO.\\n                alpha[stack.pop() - \\'a\\'] = 0;\\n            }\\n            stack.push(curr);\\n            alpha[curr - \\'a\\'] = 1;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();   \\n        while(!stack.isEmpty()) sb.append(stack.pop());\\n        return sb.reverse().toString();\\n    }\\n}\\n```\\n**UPVOTE IF HELPFUL**",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n* LOGIC HERE IS WE STORE THE LAST INDEXES OF THE CHARACTERS.\\n* SO THAT AT ANY INDEX, IF CURRENT CHARACTER IS LESS THAN THE PEEK OF STACK AND\\n  ASSUMING IN FUTURE TRAVERSAL WE CAN ADD THAT PEEK CHARACTER BY USING IT\\'S LAST INDEX.\\n* ELSE WE SIMPLY PUSH THE CHARACTER INTO STACK IF IT IS NOT ADDED ATLEAST \\n  ONCE[WE USE ALPHA ARRAY FOR THIS PURPOSE]\\n```\n```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        int[] alpha = new int[26];\\n        HashMap<Character, Integer> map =  new HashMap<>();\\n        Stack<Character> stack = new Stack<>();\\n        \\n        //Store the last Index of the character.\\n        for(int i = 0; i < s.length(); i++) map.put(s.charAt(i), i);\\n        \\n\\t\\t//TRAVERSE EACH CHARACTER\\n        for(int i = 0; i < s.length(); i++){\\n            char curr = s.charAt(i);\\n\\t\\t\\t\\n\\t\\t\\t//IF ALREADY ADDED, CONTINUE\\n            if(alpha[curr - \\'a\\'] == 1) continue;\\n\\t\\t\\t\\n\\t\\t\\t//IF WE CAN POP THE PEEK BECAUSE IN NEXT TRAVERSAL I CAN ADD THIS CHARACTER \\n\\t\\t\\t//BY USING IT\\'S LAST INDEX.\\n            while(!stack.isEmpty() && curr < stack.peek() && i < map.get(stack.peek())){\\n\\t\\t\\t// ONCE I POP I HAVE TO CHANGE THE ALPHA ARRAY TOO.\\n                alpha[stack.pop() - \\'a\\'] = 0;\\n            }\\n            stack.push(curr);\\n            alpha[curr - \\'a\\'] = 1;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();   \\n        while(!stack.isEmpty()) sb.append(stack.pop());\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859616,
                "title": "the-detailed-explanation-with-3-steps-to-understand-the-stack-approach",
                "content": "[Leetcode](https://leetcode.com/) [316. Remove Duplicate Letters](https://leetcode.com/problems/remove-duplicate-letters).\\n\\n***By Frank Luo***\\n\\n# Intuition\\n\\nFirst, let\\'s look at the problem description:\\n\\nGiven a string $\\\\textit{s}$, remove duplicate letters so that every letter appears once and only **once**. You must make sure your result is the smallest in **lexicographical** order among all possible results.\\n\\nThe requirements of the problems can be listed in **3** rules:\\n\\n1. Remove duplicate letters;\\n2. The order of characters in the deduplicated string cannot disrupt the relative order of the characters in s;\\n3. Among all deduplicated strings that meet the previous requirement, the one with the **smallest lexicographical** order is the final result.\\n\\n\\n# Step 1\\n\\nLet\\'s just ignore **rule 3** for now, and use **Stack** to follow **rule 1** and **rule 2**:\\n\\n```java\\n    public static String removeDuplicateLetters_stk_1(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        boolean[] inStack = new boolean[26];\\n        int len = s.length();\\n        for (int i = 0; i < len; i++) {\\n            char ch = s.charAt(i);\\n            if (inStack[ch - \\'a\\']) {\\n                continue;\\n            }\\n\\n            stack.push(ch);\\n            inStack[ch - \\'a\\'] = true;\\n        }\\n\\n        StringBuilder sb = new StringBuilder(stack.size());\\n        while (!stack.empty()) {\\n            sb.append(stack.pop());\\n        }\\n\\n        return sb.reverse().toString();\\n    }\\n```\\n\\nUse the boolean array **inStack** to record the chars in the stack to deduplication, so the chars in the stack are not duplicated.\\n\\nIf you enter s = \"bcabc\", the result is \"bca\", which already meets **rule 1** and **2**. However, the right answer is \"abc\". \\n\\nSo if we want to meet the **rule 3** and follow the lexicographic order, what should we do?\\n\\n\\n# Step 2\\n\\nWhile inserting the character \\'a\\' into the stack, we needs to know, which is greater in the lexicographical order of the character \\'a\\' and the previous two characters \\'b\\' and \\'c\\'?\\n\\nIf the current char \\'a\\' is lexicographically smaller than the previous character, it may be necessary to pop the previous character from the stack to put \\'a\\' first.\\n\\n```java\\n    public static String removeDuplicateLetters_stk_2(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        boolean[] inStack = new boolean[26];\\n        int len = s.length();\\n        for (int i = 0; i < len; i++) {\\n            char ch = s.charAt(i);\\n            if (inStack[ch - \\'a\\']) {\\n                continue;\\n            }\\n            while (!stack.empty() && stack.peek() > ch) {\\n                inStack[stack.pop() - \\'a\\'] = false;\\n            }\\n\\n            stack.push(ch);\\n            inStack[ch - \\'a\\'] = true;\\n        }\\n\\n        StringBuilder sb = new StringBuilder(stack.size());\\n        while (!stack.empty()) {\\n            sb.append(stack.pop());\\n        }\\n\\n        return sb.reverse().toString();\\n    }\\n```\\n\\nIf s = \"bcac\", the result is \"ac\", but the right answer should be \"bac\".\\n\\nSince there is only one \\'b\\' in s, the character \\'b\\' should not be popped even if its lexicographical order is smaller than the character \\'b\\'.\\n\\nHow to fix it?\\n\\n\\n# Step 3\\n\\nWe will only pop the element when $\\\\texttt{stack.peek()} \\\\gt ch$. At this time, we can divide it to.\\n\\n1. If the char $\\\\texttt{stack.peek()}$ will appear later, pop it out;\\n2. If the $\\\\texttt{stack.peek()}$ char will not appear afterward, and it was said earlier that there will be no duplicate elements in the stack, then you cannot pop it out, otherwise you will lose this character forever.\\n\\nThe key is to count the freqency of diffent chars in the string and we get the final answer.\\n\\n```java\\n    public static String removeDuplicateLetters(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int[] cnt = new int[26];\\n        boolean[] inStack = new boolean[26];\\n        int len = s.length();\\n        for (int i = 0; i < len; i++) {\\n            cnt[s.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < len; i++) {\\n            char ch = s.charAt(i);\\n            cnt[ch - \\'a\\']--;\\n            if (inStack[ch - \\'a\\']) {\\n                continue;\\n            }\\n            while (!stack.empty() && stack.peek() > ch) {\\n                if (cnt[stack.peek() - \\'a\\'] <= 0) {\\n                    break;\\n                }\\n\\n                inStack[stack.pop() - \\'a\\'] = false;\\n            }\\n\\n            stack.push(ch);\\n            inStack[ch - \\'a\\'] = true;\\n        }\\n\\n        StringBuilder sb = new StringBuilder(stack.size());\\n        while (!stack.empty()) {\\n            sb.append(stack.pop());\\n        }\\n\\n        return sb.reverse().toString();\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(N)$.\\n- **Space Complexity**: $O(N)$.\\n\\n\\n--------------------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```java\\n    public static String removeDuplicateLetters_stk_1(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        boolean[] inStack = new boolean[26];\\n        int len = s.length();\\n        for (int i = 0; i < len; i++) {\\n            char ch = s.charAt(i);\\n            if (inStack[ch - \\'a\\']) {\\n                continue;\\n            }\\n\\n            stack.push(ch);\\n            inStack[ch - \\'a\\'] = true;\\n        }\\n\\n        StringBuilder sb = new StringBuilder(stack.size());\\n        while (!stack.empty()) {\\n            sb.append(stack.pop());\\n        }\\n\\n        return sb.reverse().toString();\\n    }\\n```\n```java\\n    public static String removeDuplicateLetters_stk_2(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        boolean[] inStack = new boolean[26];\\n        int len = s.length();\\n        for (int i = 0; i < len; i++) {\\n            char ch = s.charAt(i);\\n            if (inStack[ch - \\'a\\']) {\\n                continue;\\n            }\\n            while (!stack.empty() && stack.peek() > ch) {\\n                inStack[stack.pop() - \\'a\\'] = false;\\n            }\\n\\n            stack.push(ch);\\n            inStack[ch - \\'a\\'] = true;\\n        }\\n\\n        StringBuilder sb = new StringBuilder(stack.size());\\n        while (!stack.empty()) {\\n            sb.append(stack.pop());\\n        }\\n\\n        return sb.reverse().toString();\\n    }\\n```\n```java\\n    public static String removeDuplicateLetters(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        int[] cnt = new int[26];\\n        boolean[] inStack = new boolean[26];\\n        int len = s.length();\\n        for (int i = 0; i < len; i++) {\\n            cnt[s.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < len; i++) {\\n            char ch = s.charAt(i);\\n            cnt[ch - \\'a\\']--;\\n            if (inStack[ch - \\'a\\']) {\\n                continue;\\n            }\\n            while (!stack.empty() && stack.peek() > ch) {\\n                if (cnt[stack.peek() - \\'a\\'] <= 0) {\\n                    break;\\n                }\\n\\n                inStack[stack.pop() - \\'a\\'] = false;\\n            }\\n\\n            stack.push(ch);\\n            inStack[ch - \\'a\\'] = true;\\n        }\\n\\n        StringBuilder sb = new StringBuilder(stack.size());\\n        while (!stack.empty()) {\\n            sb.append(stack.pop());\\n        }\\n\\n        return sb.reverse().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 889781,
                "title": "c-logic-explained",
                "content": "class Solution {\\npublic:\\n     \\n    string removeDuplicateLetters(string s) {\\n     \\n        string str=\"\";\\n        \\n        unordered_map<char,int> mp;\\n        vector<bool> visited(26,false);\\n        \\n        //count frequency of each character\\n        for(auto ch:s)\\n            mp[ch]++;\\n        \\n        for(auto c:s)\\n        {\\n            mp[c]--;\\n            \\n            //means we have not visited the current character before\\n            if(visited[c-\\'a\\']==false)\\n            {\\n                //if the last character at string is lexographically greater and \\n                //its count is still there so that it can be adjusted later on in iteration\\n                //we remove it\\n                while(str.length()>0 and c<str.back() and mp[str.back()]>0)\\n                {\\n                    visited[str.back()-\\'a\\']=false;\\n                    str.pop_back();\\n                }\\n                //after we are done with removing elements from last\\n                 //push the current element and set visited to true\\n            str.push_back(c);\\n            visited[c-\\'a\\']=true;\\n            }\\n           \\n        }\\n        \\n        return str;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n     \\n    string removeDuplicateLetters(string s) {\\n     \\n        string str=\"\";\\n        \\n        unordered_map<char,int> mp;\\n        vector<bool> visited(26,false);\\n        \\n        //count frequency of each character\\n        for(auto ch:s)\\n            mp[ch]++;\\n        \\n        for(auto c:s)\\n        {\\n            mp[c]--;\\n            \\n            //means we have not visited the current character before\\n            if(visited[c-\\'a\\']==false)\\n            {\\n                //if the last character at string is lexographically greater and \\n                //its count is still there so that it can be adjusted later on in iteration\\n                //we remove it\\n                while(str.length()>0 and c<str.back() and mp[str.back()]>0)\\n                {\\n                    visited[str.back()-\\'a\\']=false;\\n                    str.pop_back();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 76844,
                "title": "from-an-intuitive-recursive-solution-4ms-to-an-optimized-backtracking-solution-0ms-in-c-both-are-well-explained",
                "content": "Because we are required to remove the duplicates and still search for the lexicographical smallest, we can then follow the following steps to solve it: \\n\\n - first use a counter array to count the frequency for each letter that appears in the string; \\n - in this recursive method, we will search for the smallest valid letter in each recursion - validity here means that selecting this letter will not exclude others which can be ensured by the counter we initialized before;\\n - after selecting the current valid smallest letter, we then need to prepare a substring for the recursion - removing all the letters before this selected letter and remove all the same letter after this selected letter; why? since we have already get the valid smallest letter without excluding any other letter, the letters before this is useless and invalid now and since we have store this selected letter, the selected letter should also not be allowed to appear in the next recursion, right? Solved simply and directly! \\n\\nTo save space cost, I used an assistant method to store the result string using a int pointer to record its size.\\n \\n - Space cost O(1)\\n - Time cost O(n) - since there are at most 26 different letters, the recursions will be limited to O(1).\\n\\n----------\\n\\n    //selecting the valid smallest, remove the invalid\\n    //and then select the next smallest valid;\\n    void helper(char* s, char* t, int* returnSize)\\n    {\\n        int len = strlen(s);\\n        if(!len) return ;\\n        int count[26] = {0};\\n        int index = 0;\\n        for(int i = 0; i < len; i++) count[s[i]-'a']++;\\n        for(int i = 0; i < len; i++)\\n        {\\n            if(s[i] < s[index]) //search for the smallest;\\n                index = i;\\n            if(!(--count[s[i]-'a'])) //ensure every letter appears at least once, do not exclude any letter;\\n                break;\\n        }\\n        char c = s[index];\\n        *returnSize += 1;\\n        t[*returnSize-1] = c;\\n        int newIndex = 0;\\n        for(int i = index+1; i < len; i++) //reconstructing the left substring by removing the collected character and the letters before the selected since they are invalid after selecting the letter in 'index' position;\\n            if(s[i] != c)\\n                s[newIndex++] = s[i];\\n        s[newIndex] = '\\\\0';\\n        helper(s, t, returnSize);\\n    }\\n    \\n    //AC - 4ms - quite intuitive solution selecting the smallest one by one;\\n    char* removeDuplicateLetters(char* s)\\n    {\\n        char* t = (char*)malloc(sizeof(char)*27);\\n        int size = 0;\\n        helper(s, t, &size);\\n        t[size] = '\\\\0';\\n        return t;\\n    }\\n    \\nApart from the above recursion solution, there is also a backtracking one which comparably more efficient eliminating redundant traversal for counter or something like that. Also there is a counter for avoiding removing essential letters, an array used to record the status (stored or not - in stack or not) and a char stack to store the valid letter which will be returned as the result. The steps are as follows:\\n\\n - initialize the array counter;\\n - decrease the count for each corresponding letter while traversing the string ensure the unknowingly exclusion will not happen;\\n - if the current letter is already stored in the stack, we just continue the loop letting the follow-up letters to handle it if there is something wrong with the position;\\n - if the current letter is not stored then we have to where it should be placed in the stack - checking the value of the letter and counter at the same time - we have to ensure the lexicographical order, remember? but at the same time we have to ensure every unique letter is included that's why we need to check the counter - if the counter is bigger than zero, then there will others of the letter in the un-traversed part, right?\\n - store the letter and update its status (stored now).\\n\\nCompared with the above recursive solution, this one is so economic - almost waste nothing in space and time! Though pitifully they share the same representation of cost ##\\n\\n - Space cost O(n)\\n - Time cost O(n)\\n\\n----------\\n    \\n    //AC - 0ms - using counter to ensure including each letter\\n    //using visited to accelerate the checking process;\\n    char* removeDuplicateLetters0(char* s)\\n    {\\n        int count[26] = {0};\\n        bool visited[26] = {0};\\n        int len = strlen(s);\\n        for(int i = 0; i < len ;i++) count[s[i]-'a']++; //count the frequency of each character;\\n        char *t = (char*)malloc(sizeof(char)*27); //used to store the result string;\\n        int size = 0; //used to indicate the length of the result string;\\n        for(int i = 0; i < len; i++)\\n        {\\n            int index = s[i]-'a';\\n            count[index]--;\\n            if(visited[index]) continue; //stored already, needless to check the result string;\\n            int j = size-1; //not visited before, check it in the result string;\\n            for(; j > -1; j--)\\n            {\\n                int index = t[j]-'a';\\n                if(s[i] < t[j] && count[index]) visited[index] = false; //if the character t[j] is bigger and there is still such character in the remaining substring, to keep lexicographical order, we have to remove it from the result string and meantime reset visited records;\\n                else break;\\n            }\\n            size = j+1; //update the size of the result string;\\n            t[size++] = s[i];\\n            visited[index] = true;\\n        }\\n        t[size] = '\\\\0';\\n        return t;\\n    }",
                "solutionTags": [],
                "code": "Because we are required to remove the duplicates and still search for the lexicographical smallest, we can then follow the following steps to solve it: \\n\\n - first use a counter array to count the frequency for each letter that appears in the string; \\n - in this recursive method, we will search for the smallest valid letter in each recursion - validity here means that selecting this letter will not exclude others which can be ensured by the counter we initialized before;\\n - after selecting the current valid smallest letter, we then need to prepare a substring for the recursion - removing all the letters before this selected letter and remove all the same letter after this selected letter; why? since we have already get the valid smallest letter without excluding any other letter, the letters before this is useless and invalid now and since we have store this selected letter, the selected letter should also not be allowed to appear in the next recursion, right? Solved simply and directly! \\n\\nTo save space cost, I used an assistant method to store the result string using a int pointer to record its size.\\n \\n - Space cost O(1)\\n - Time cost O(n) - since there are at most 26 different letters, the recursions will be limited to O(1).\\n\\n----------\\n\\n    //selecting the valid smallest, remove the invalid\\n    //and then select the next smallest valid;\\n    void helper(char* s, char* t, int* returnSize)\\n    {\\n        int len = strlen(s);\\n        if(!len) return ;\\n        int count[26] = {0};\\n        int index = 0;\\n        for(int i = 0; i < len; i++) count[s[i]-'a']++;\\n        for(int i = 0; i < len; i++)\\n        {\\n            if(s[i] < s[index]) //search for the smallest;\\n                index = i;\\n            if(!(--count[s[i]-'a'])) //ensure every letter appears at least once, do not exclude any letter;\\n                break;\\n        }\\n        char c = s[index];\\n        *returnSize += 1;\\n        t[*returnSize-1] = c;\\n        int newIndex = 0;\\n        for(int i = index+1; i < len; i++) //reconstructing the left substring by removing the collected character and the letters before the selected since they are invalid after selecting the letter in 'index' position;\\n            if(s[i] != c)\\n                s[newIndex++] = s[i];\\n        s[newIndex] = '\\\\0';\\n        helper(s, t, returnSize);\\n    }\\n    \\n    //AC - 4ms - quite intuitive solution selecting the smallest one by one;\\n    char* removeDuplicateLetters(char* s)\\n    {\\n        char* t = (char*)malloc(sizeof(char)*27);\\n        int size = 0;\\n        helper(s, t, &size);\\n        t[size] = '\\\\0';\\n        return t;\\n    }\\n    \\nApart from the above recursion solution, there is also a backtracking one which comparably more efficient eliminating redundant traversal for counter or something like that. Also there is a counter for avoiding removing essential letters, an array used to record the status (stored or not - in stack or not) and a char stack to store the valid letter which will be returned as the result. The steps are as follows:\\n\\n - initialize the array counter;\\n - decrease the count for each corresponding letter while traversing the string ensure the unknowingly exclusion will not happen;\\n - if the current letter is already stored in the stack, we just continue the loop letting the follow-up letters to handle it if there is something wrong with the position;\\n - if the current letter is not stored then we have to where it should be placed in the stack - checking the value of the letter and counter at the same time - we have to ensure the lexicographical order, remember? but at the same time we have to ensure every unique letter is included that's why we need to check the counter - if the counter is bigger than zero, then there will others of the letter in the un-traversed part, right?\\n - store the letter and update its status (stored now).\\n\\nCompared with the above recursive solution, this one is so economic - almost waste nothing in space and time! Though pitifully they share the same representation of cost ##\\n\\n - Space cost O(n)\\n - Time cost O(n)\\n\\n----------\\n    \\n    //AC - 0ms - using counter to ensure including each letter\\n    //using visited to accelerate the checking process;\\n    char* removeDuplicateLetters0(char* s)\\n    {\\n        int count[26] = {0};\\n        bool visited[26] = {0};\\n        int len = strlen(s);\\n        for(int i = 0; i < len ;i++) count[s[i]-'a']++; //count the frequency of each character;\\n        char *t = (char*)malloc(sizeof(char)*27); //used to store the result string;\\n        int size = 0; //used to indicate the length of the result string;\\n        for(int i = 0; i < len; i++)\\n        {\\n            int index = s[i]-'a';\\n            count[index]--;\\n            if(visited[index]) continue; //stored already, needless to check the result string;\\n            int j = size-1; //not visited before, check it in the result string;\\n            for(; j > -1; j--)\\n            {\\n                int index = t[j]-'a';\\n                if(s[i] < t[j] && count[index]) visited[index] = false; //if the character t[j] is bigger and there is still such character in the remaining substring, to keep lexicographical order, we have to remove it from the result string and meantime reset visited records;\\n                else break;\\n            }\\n            size = j+1; //update the size of the result string;\\n            t[size++] = s[i];\\n            visited[index] = true;\\n        }\\n        t[size] = '\\\\0';\\n        return t;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3240694,
                "title": "316-space-98-37-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We create a stack to keep track of the characters that we are going to keep in the result.\\n- We also create a dictionary last_occurrence to keep track of the last occurrence of each character in the string.\\n- We iterate through the string s and check if the current character is already in the stack. If it is, we skip it.\\n- If the current character is not in the stack, we compare it to the top of the stack and pop characters from the stack until we reach a character that is not greater than the current character and that has a last occurrence index that is greater than the current index i. We do this to make sure that we keep the characters in lexicographical order and that we don\\'t remove characters that we need to keep.\\n- We then add the current character to the stack.\\n- Finally, we return the characters in the stack as a string.\\n\\n# Complexity\\n- Time complexity:\\n81.68%\\n\\n- Space complexity:\\n98.37%\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        stack = []\\n        last_occurrence = {char: i for i, char in enumerate(s)}\\n        \\n        for i, char in enumerate(s):\\n            if char in stack:\\n                continue\\n                \\n            while stack and char < stack[-1] and i < last_occurrence[stack[-1]]:\\n                stack.pop()\\n                \\n            stack.append(char)\\n            \\n        return \\'\\'.join(stack)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        stack = []\\n        last_occurrence = {char: i for i, char in enumerate(s)}\\n        \\n        for i, char in enumerate(s):\\n            if char in stack:\\n                continue\\n                \\n            while stack and char < stack[-1] and i < last_occurrence[stack[-1]]:\\n                stack.pop()\\n                \\n            stack.append(char)\\n            \\n        return \\'\\'.join(stack)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889793,
                "title": "python3-greedy-short-code-intuition-and-stack-based-greedy-logic-explained",
                "content": "If you don\\'t get it in your first try don\\'t worry. These greedy algorithms are not that easy to grasp at first. However there are always a few techniques that are surely gonna work out. Let\\'s look at this problem for instance .\\n## Intuition:\\nWe want to maintain an order here, ascending order of characters in this case. Hence it makes a lot of sense to go with something like a monotone stack where we maintain a order invariant. \\n\\n## Algorithm:\\nWe need there things:\\n1. `left`: A hash-map to keep count of occurences of a character in a string\\n2. `stack`: A monotone stack where we always have characters in non-decreasing order.\\n3. `in_stack`: A set to see if a character is in the stack currently or not.    \\n\\nWe then iterate over the given strinfg `s`.\\nThen we check if that character is currently in our stack or not. \\n* If it is on stack:\\n\\t* We dont need this particular instance of this character because we already have it and adding it now to our stack will just make final string bigger\\n* If it is not on stack:\\n\\t* Loop till stack is not empty AND topmost element of stack is greater than current one AND if this topmost character of stack will appear again in the string. ( This maintains order/monotonicity of the stack.\\n\\t* Pop the topmost element\\n\\t* Remove it from `in_stack` set.\\n* Append current character to stack\\n* Decrese its count from `left` hash-map.\\n* Add this character to `in_stack` set.\\n* Finally join the stack contents and retrun.\\n\\n## Code:\\n\\n```python\\nfrom collections import Counter\\n\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        if not s:\\n            return \"\"\\n        \\n        left = Counter(s)\\n        stack = []\\n        in_stack = set()\\n        \\n        for c in s:\\n            if c in in_stack:\\n                left[c]-=1\\n                continue\\n            else:\\n                while stack and stack[-1]>c and left[stack[-1]]>=1:\\n                    popped = stack.pop()\\n                    in_stack.remove(popped)\\n                    \\n                stack.append(c)\\n                left[c] -=1\\n                in_stack.add(c)\\n                \\n        ret = \\'\\'.join(stack)\\n        return ret\\n\\n```\\n\\n## Example:\\n\\nFine, Now we have seen algorithm and the code, lets look at an example for a better understanding.\\n\\n```\\n# Initially before running the loop over string s, we have:\\n\\ns = |bcabc\\nleft = {a:1, b:2, c:2}\\nstack = []\\nin_stack = {}\\n\\n# We dive in to the loop over s, and incomes b:\\n\\ns = b|cabc\\nleft = {a:1, b:1, c:2}\\nstack = [b]\\nin_stack = {b}\\n\\n# Now comes, c:\\n\\ns = bc|abc\\nleft = {a:1, b:1, c:1}\\nstack = [b,c]\\nin_stack = {b,c}\\n\\n# Now comes, a. This time loop runs and we pop-off previous elements:\\n\\ns = bca|bc\\nleft = {a:0, b:1, c:1}\\nstack = [a]\\nin_stack = {a}\\n\\n# Now b arrives:\\n\\ns = bcab|c\\nleft = {a:0, b:0, c:1}\\nstack = [a,b]\\nin_stack = {a,b}\\n\\n# And finally last c arives:\\n\\ns = bcab|c\\nleft = {a:0, b:0, c:0}\\nstack = [a,b,c]\\nin_stack = {a,b,c}\\n\\nThen we stick all stack contents togeather and return.\\n```\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```python\\nfrom collections import Counter\\n\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        if not s:\\n            return \"\"\\n        \\n        left = Counter(s)\\n        stack = []\\n        in_stack = set()\\n        \\n        for c in s:\\n            if c in in_stack:\\n                left[c]-=1\\n                continue\\n            else:\\n                while stack and stack[-1]>c and left[stack[-1]]>=1:\\n                    popped = stack.pop()\\n                    in_stack.remove(popped)\\n                    \\n                stack.append(c)\\n                left[c] -=1\\n                in_stack.add(c)\\n                \\n        ret = \\'\\'.join(stack)\\n        return ret\\n\\n```\n```\\n# Initially before running the loop over string s, we have:\\n\\ns = |bcabc\\nleft = {a:1, b:2, c:2}\\nstack = []\\nin_stack = {}\\n\\n# We dive in to the loop over s, and incomes b:\\n\\ns = b|cabc\\nleft = {a:1, b:1, c:2}\\nstack = [b]\\nin_stack = {b}\\n\\n# Now comes, c:\\n\\ns = bc|abc\\nleft = {a:1, b:1, c:1}\\nstack = [b,c]\\nin_stack = {b,c}\\n\\n# Now comes, a. This time loop runs and we pop-off previous elements:\\n\\ns = bca|bc\\nleft = {a:0, b:1, c:1}\\nstack = [a]\\nin_stack = {a}\\n\\n# Now b arrives:\\n\\ns = bcab|c\\nleft = {a:0, b:0, c:1}\\nstack = [a,b]\\nin_stack = {a,b}\\n\\n# And finally last c arives:\\n\\ns = bcab|c\\nleft = {a:0, b:0, c:0}\\nstack = [a,b,c]\\nin_stack = {a,b,c}\\n\\nThen we stick all stack contents togeather and return.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822854,
                "title": "python-easy-simple-solution-using-stack-time-o-n",
                "content": "```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        countMap = collections.defaultdict(int)\\n        stack = []\\n        selected = set()\\n\\n        for c in s:\\n            countMap[c] += 1\\n\\n        for c in s:\\n            countMap[c] -= 1\\n            if c not in selected:\\n                while stack and countMap[stack[-1]] > 0 and stack[-1] > c:\\n                    selected.remove(stack.pop())\\n                    \\n                stack.append(c)\\n                selected.add(c)\\n                \\n        return \"\".join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        countMap = collections.defaultdict(int)\\n        stack = []\\n        selected = set()\\n\\n        for c in s:\\n            countMap[c] += 1\\n\\n        for c in s:\\n            countMap[c] -= 1\\n            if c not in selected:\\n                while stack and countMap[stack[-1]] > 0 and stack[-1] > c:\\n                    selected.remove(stack.pop())\\n                    \\n                stack.append(c)\\n                selected.add(c)\\n                \\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302668,
                "title": "c-o-n-solution-beats-100",
                "content": "Idea is to have 2 arrays :\\n1. One to maintain the count of numbers of chars from a-z\\n2. Another to check whether a char is already \"visited\"\\n\\nWhen parsing the given string, if we encounter a character that is already visited we simply continue.\\nIf we visit a character that is not visited and if it is lesser than last character of the result string, and the count of the last character of the result string is > 0, we pop the last char of result and mark it as unvisited and repeat this step until the condition fails. Then we push the new character and continue;\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        \\n        if(s.length()==0 || s.length()==1)\\n            return s;\\n        \\n        int st[26] = {0};\\n        for(int i=0;i<s.size();i++)\\n        {\\n            st[s[i]-\\'a\\']++;\\n        }\\n        \\n        bool visited[26] = {false};\\n        \\n        string result = \"*\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            char c = s[i];\\n             --st[c-\\'a\\'];\\n            if(visited[c-\\'a\\']==true)\\n                continue;\\n            \\n            while(c < result.back() && st[result.back()-\\'a\\'])\\n            {\\n                visited[result.back()-\\'a\\'] = false;\\n                result.pop_back();\\n            }\\n            \\n            result+=c;\\n            visited[c-\\'a\\'] = true;\\n        }\\n        \\n        return result.substr(1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        \\n        if(s.length()==0 || s.length()==1)\\n            return s;\\n        \\n        int st[26] = {0};\\n        for(int i=0;i<s.size();i++)\\n        {\\n            st[s[i]-\\'a\\']++;\\n        }\\n        \\n        bool visited[26] = {false};\\n        \\n        string result = \"*\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            char c = s[i];\\n             --st[c-\\'a\\'];\\n            if(visited[c-\\'a\\']==true)\\n                continue;\\n            \\n            while(c < result.back() && st[result.back()-\\'a\\'])\\n            {\\n                visited[result.back()-\\'a\\'] = false;\\n                result.pop_back();\\n            }\\n            \\n            result+=c;\\n            visited[c-\\'a\\'] = true;\\n        }\\n        \\n        return result.substr(1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76837,
                "title": "o-n-c-solution",
                "content": "    class Solution {\\n    public:\\n        string removeDuplicateLetters(string s) {\\n            int counts[26] = {};\\n            bool inresult[26] = {};\\n            for(char c: s) counts[c-'a']++;\\n            string result = \"\";\\n            for(char c: s) {\\n                counts[c-'a']--;\\n                if(inresult[c-'a']) continue;\\n                while(!result.empty() && counts[result.back()-'a']>0 && result.back()>c){\\n                    inresult[result.back()-'a'] = false;\\n                    result.pop_back();\\n                }\\n                inresult[c-'a'] =true;\\n                result.push_back(c);\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string removeDuplicateLetters(string s) {\\n            int counts[26] = {}",
                "codeTag": "Java"
            },
            {
                "id": 1614533,
                "title": "detailed-explanation-of-logic-with-code",
                "content": "The lexicographic part is the trouble maker in an otherwise simple problem.\\nWe don\\'t just want to remove the duplicates, but we want to remove duplicates in a manner that the resultant string is lexicographically smallest.\\n\\nLet\\'s try to get to the solution using an example.\\n\\ns = \"bcabc\"\\nHere we have 4 possible solutions: abc, bca, bac, cab. Out of these abc is smallest lexicographically.\\n\\n**Observations**:\\n* We need a mechanism to know whether a certain character is going to appear later in the string. In our above example, At index 0, we have b. But we need to know whether b  will appear again or not. If it appears again, then we can think of removing it. But if it does not appear again, then we have no choice but to keep this letter in our answer.\\n* If current letter is lexicographically smaller than previous letters, AND the previous letters appear again later in array, we need to remove these previous letters from our answer, and add the current letter. Which data structure is best for keeping track of previous consecutive data? Stack!\\n\\n**Approach**:\\n* To keep track of the highest index of each letter, we will use a Hashmap. So once we will go through the string and update our map. key will be the character, and value will be its index. Once the traversal is done, all characters will have highest indices updated in the map. (See first 5 lines code for clarity.)\\n* We will use a stack to keep track of the letters, but we will also need a mechanism for checking whether a letter has already been added to the stack. (This point will become clear in a while)\\n* We now go through the string, and do the following for each letter:\\n1. Check if this letter is lexicographically smaller/bigger than the character at the top of the stack. If it is smaller, then we will **pop the stack only if the character at the top appears again later in the string**. Other wise just add it to the stack and the set iff this letter is not already added earlier (This is where the set comes in handy).\\n2. Repeat the above step as long as current character is smaller than stack\\'s top character.\\n3. If the current character is bigger, then simply add this character to the stack and set if not already added before.\\n\\nGo through the code for better clarity.\\n\\nCode:\\n```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        HashMap<Character, Integer> countMap = new HashMap();\\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            countMap.put(c,i);\\n        }\\n        \\n        Stack<Character> stack = new Stack();\\n        Set<Character> set = new HashSet();\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if(!set.contains(c)) {\\n                while(!stack.isEmpty() \\n                      && c < stack.peek() \\n                      && countMap.get(stack.peek()) >= i){\\n                    set.remove(stack.pop());\\n                }\\n                stack.push(c);\\n                set.add(c);\\n            }\\n        }\\n        \\n        String ans = \"\";\\n        while(!stack.isEmpty()) {\\n            ans = stack.pop() + ans;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nHope this helps.\\nPlease drop comments for any queries/suggestions.\\nPeace!",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        HashMap<Character, Integer> countMap = new HashMap();\\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            countMap.put(c,i);\\n        }\\n        \\n        Stack<Character> stack = new Stack();\\n        Set<Character> set = new HashSet();\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if(!set.contains(c)) {\\n                while(!stack.isEmpty() \\n                      && c < stack.peek() \\n                      && countMap.get(stack.peek()) >= i){\\n                    set.remove(stack.pop());\\n                }\\n                stack.push(c);\\n                set.add(c);\\n            }\\n        }\\n        \\n        String ans = \"\";\\n        while(!stack.isEmpty()) {\\n            ans = stack.pop() + ans;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 374413,
                "title": "javascript-using-stack-84-81-100",
                "content": "```\\nvar removeDuplicateLetters = function(s) {\\n    var countObject = {};//contains each letters count in string\\n    var isInStack = {};//tells whether a letter is already in the stack or not\\n    var stack = [];//the final stack which will contain the string\\n    \\n    //build countObject and initialize isInStack\\n    for(var i=0; i<s.length; i++){\\n        if(!countObject[s[i]]){\\n            countObject[s[i]] = 0;\\n        }\\n        countObject[s[i]]++;\\n        isInStack[s[i]] = false;\\n    }\\n    \\n    //iterate through string\\n    for(var i=0; i<s.length; i++){\\n        var currentLetter = s[i];\\n        var stackTop = stack[stack.length - 1];\\n        \\n        //decrement counter for every letter each time we see it\\n        countObject[currentLetter]--;\\n        \\n        if(isInStack[currentLetter]){\\n            //currentLetter is already in stack. Skip it.\\n            continue;\\n        }\\n        \\n        if(currentLetter < stackTop){\\n            //currentLetter comes first lexicographically\\n            //do more of the stacktop element exist further in the string?\\n            //(we can find this out from countObject)\\n            //keep popping while currentLetter < stackTop\\n            //or if stackTop does not exist further in the string\\n            while(currentLetter < stackTop && countObject[stackTop] > 0){\\n                isInStack[stack.pop()] = false;\\n                stackTop = stack[stack.length - 1];\\n            }\\n            \\n            //the stack top should now have a letter which is either lexicographically\\n            //smaller than currentLetter or \\n            //a letter which does not have any more occurrences in the string\\n            //for example in bbacd, when currentLetter is a, stack top would be b\\n        }\\n        \\n        //push the currentLetter to stack\\n        isInStack[currentLetter] = true;\\n        stack.push(currentLetter);\\n    }\\n    \\n    //convert stack arrray to string and return\\n    return stack.join(\\'\\');\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeDuplicateLetters = function(s) {\\n    var countObject = {};//contains each letters count in string\\n    var isInStack = {};//tells whether a letter is already in the stack or not\\n    var stack = [];//the final stack which will contain the string\\n    \\n    //build countObject and initialize isInStack\\n    for(var i=0; i<s.length; i++){\\n        if(!countObject[s[i]]){\\n            countObject[s[i]] = 0;\\n        }\\n        countObject[s[i]]++;\\n        isInStack[s[i]] = false;\\n    }\\n    \\n    //iterate through string\\n    for(var i=0; i<s.length; i++){\\n        var currentLetter = s[i];\\n        var stackTop = stack[stack.length - 1];\\n        \\n        //decrement counter for every letter each time we see it\\n        countObject[currentLetter]--;\\n        \\n        if(isInStack[currentLetter]){\\n            //currentLetter is already in stack. Skip it.\\n            continue;\\n        }\\n        \\n        if(currentLetter < stackTop){\\n            //currentLetter comes first lexicographically\\n            //do more of the stacktop element exist further in the string?\\n            //(we can find this out from countObject)\\n            //keep popping while currentLetter < stackTop\\n            //or if stackTop does not exist further in the string\\n            while(currentLetter < stackTop && countObject[stackTop] > 0){\\n                isInStack[stack.pop()] = false;\\n                stackTop = stack[stack.length - 1];\\n            }\\n            \\n            //the stack top should now have a letter which is either lexicographically\\n            //smaller than currentLetter or \\n            //a letter which does not have any more occurrences in the string\\n            //for example in bbacd, when currentLetter is a, stack top would be b\\n        }\\n        \\n        //push the currentLetter to stack\\n        isInStack[currentLetter] = true;\\n        stack.push(currentLetter);\\n    }\\n    \\n    //convert stack arrray to string and return\\n    return stack.join(\\'\\');\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 4090821,
                "title": "easy-to-understand-and-begginer-friendly-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n   stack<char> charStack;\\n\\n    // Frequency array\\n    vector<int> count(26, 0); \\n\\n    // Boolean array to track whether a character is in the stack\\n     vector<bool> inStack(26, false);\\n    \\n    // Count the occurrences of each character in the string\\n    for (char c : s) {\\n        count[c - \\'a\\']++;  }\\n\\n     // Decrement the count of the current character\\n    for (char c : s) {\\n        count[c - \\'a\\']--;\\n        \\n        // If the character is already in the stack, skip it    \\n        if (inStack[c - \\'a\\']) {\\n                continue; \\n                          }\\n            \\n        // Pop characters from the stack as long as the current character is smaller\\n        // and there are more occurrences of the character at the top of the stack\\n        while (!charStack.empty() && c < charStack.top() && count[charStack.top() - \\'a\\'] > 0) {\\n                inStack[charStack.top() - \\'a\\'] = false;\\n                charStack.pop();\\n            }\\n            \\n        // Push the current character onto the stack\\n            charStack.push(c);\\n            inStack[c - \\'a\\'] = true;\\n                      }\\n    \\n    // Construct the result string by popping characters from the stack\\n    string result = \"\";\\n    while (!charStack.empty()) {\\n        result = charStack.top() + result;\\n        charStack.pop();\\n    }\\n    \\n    return result;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n   stack<char> charStack;\\n\\n    // Frequency array\\n    vector<int> count(26, 0); \\n\\n    // Boolean array to track whether a character is in the stack\\n     vector<bool> inStack(26, false);\\n    \\n    // Count the occurrences of each character in the string\\n    for (char c : s) {\\n        count[c - \\'a\\']++;  }\\n\\n     // Decrement the count of the current character\\n    for (char c : s) {\\n        count[c - \\'a\\']--;\\n        \\n        // If the character is already in the stack, skip it    \\n        if (inStack[c - \\'a\\']) {\\n                continue; \\n                          }\\n            \\n        // Pop characters from the stack as long as the current character is smaller\\n        // and there are more occurrences of the character at the top of the stack\\n        while (!charStack.empty() && c < charStack.top() && count[charStack.top() - \\'a\\'] > 0) {\\n                inStack[charStack.top() - \\'a\\'] = false;\\n                charStack.pop();\\n            }\\n            \\n        // Push the current character onto the stack\\n            charStack.push(c);\\n            inStack[c - \\'a\\'] = true;\\n                      }\\n    \\n    // Construct the result string by popping characters from the stack\\n    string result = \"\";\\n    while (!charStack.empty()) {\\n        result = charStack.top() + result;\\n        charStack.pop();\\n    }\\n    \\n    return result;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135130,
                "title": "java-1ms-solution-beating-100-with-monotonic-stack-and-hash-table",
                "content": "Apparently, if we want to get the subsequence with minimum dictionary order, we can use a monotonic stack, i.e., traverse the input string and put the minimum character in the bottom of stack.\\nThis problem add a constraint that there can\\'t be any duplicate character in the subsequence. We can use a hash table to count the frequency of each character and determine whether the element in the stack can be removed by checking the freq of it.\\n\\n```\\npublic String removeDuplicateLetters(String s) {\\n\\t// 1. The monotonic stack that saves the result\\n\\tchar result[] = new char[s.length()];\\n\\tint top = 0;\\n\\t\\n\\tchar array[] = s.toCharArray();\\n\\t// 2. The hash table that records the freq of character\\n\\tint freq[] = new int[26];\\n\\tfor (int i = 0; i < array.length; i++) {\\n\\t\\tfreq[array[i] - \\'a\\']++;\\n\\t}\\n\\t\\n\\t// 3. There can\\'t be duplicate element in the subsequence\\n\\tboolean used[] = new boolean[26];\\n\\t\\n\\tfor (int i = 0; i < array.length; i++) {\\n\\t\\tfreq[array[i] - \\'a\\']--;\\n\\t\\tif (used[array[i] - \\'a\\']) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\twhile (top > 0 && array[i] < result[top - 1] && freq[result[top - 1] - \\'a\\'] > 0) {\\n\\t\\t\\tused[result[--top] - \\'a\\'] = false;\\n\\t\\t}\\n\\t\\tresult[top++] = array[i];\\n\\t\\tused[array[i] - \\'a\\'] = true;\\n\\t}\\n\\treturn String.copyValueOf(result, 0, top);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Monotonic Stack"
                ],
                "code": "```\\npublic String removeDuplicateLetters(String s) {\\n\\t// 1. The monotonic stack that saves the result\\n\\tchar result[] = new char[s.length()];\\n\\tint top = 0;\\n\\t\\n\\tchar array[] = s.toCharArray();\\n\\t// 2. The hash table that records the freq of character\\n\\tint freq[] = new int[26];\\n\\tfor (int i = 0; i < array.length; i++) {\\n\\t\\tfreq[array[i] - \\'a\\']++;\\n\\t}\\n\\t\\n\\t// 3. There can\\'t be duplicate element in the subsequence\\n\\tboolean used[] = new boolean[26];\\n\\t\\n\\tfor (int i = 0; i < array.length; i++) {\\n\\t\\tfreq[array[i] - \\'a\\']--;\\n\\t\\tif (used[array[i] - \\'a\\']) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\twhile (top > 0 && array[i] < result[top - 1] && freq[result[top - 1] - \\'a\\'] > 0) {\\n\\t\\t\\tused[result[--top] - \\'a\\'] = false;\\n\\t\\t}\\n\\t\\tresult[top++] = array[i];\\n\\t\\tused[array[i] - \\'a\\'] = true;\\n\\t}\\n\\treturn String.copyValueOf(result, 0, top);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 889547,
                "title": "python-monotonic-stack-with-explanation",
                "content": "To get the string with the smallest in lexicographical order, we\\'d want it to be as strictly increasing as possible - it may not be perfectly strictly increasing, since we are limited by the order of occurrence in the input string.\\nWe need to keep track the number of occurrence of each character in the string and a stack of characters that would be our result. When we push a new character into the stack, we first pop out each greater character if there\\'s remaining occurrence of it. \\n\\n```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        res = []\\n        remaining = Counter(s)\\n        \\n        for c in s:\\n            if c not in res:\\n                while res and res[-1] >= c and remaining[res[-1]] > 0:\\n                    res.pop()\\n                res.append(c)\\n            remaining[c]-=1\\n        \\n        return \"\".join(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        res = []\\n        remaining = Counter(s)\\n        \\n        for c in s:\\n            if c not in res:\\n                while res and res[-1] >= c and remaining[res[-1]] > 0:\\n                    res.pop()\\n                res.append(c)\\n            remaining[c]-=1\\n        \\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296438,
                "title": "java-simple-code-greedy-and-thinking-process-for-dummy-people-like-me",
                "content": "**The 1st thougth** would be from a given string `s`, we can know what distinct `letters` are in `s`. It\\'s easy by 1 iterate going through `s` with `Set`.\\n\\nFor example: `s = \"cbacdcbc\"`, then `set = {\\'a\\', \\'b\\', \\'c\\', \\'d\\'}`\\nThe result might be `\"abcd\"`, or `\"dbca\"`, or `\"cbda\"`, etc ... Any permutation of the set can be a result. However, if a specific permutation is the result, so the order of letters in permutation should be found in `s`.\\n\\nFor example: if `cbda` is the result, so we must found a patter like this in `s`:\\n`s = \"....c....b....d....a....\"`\\n\\nIn anothe word there must exist : `pos(c) < pos(b) < pos(d) < pos(a)`\\n\\n**The 2nd thougth** would be the positions of each letter in `s` are important. So, we should collect all positions of `each letter` in `s`. Again, it\\'s easy by 1 iterate going through `s` with `Map`:\\n\\n`a` --> `{a1, a2, a3, ..., am}`\\n`b` --> `{b1, b2, b3, ...., bn}`\\n`c` --> `{c1, c2, c3, ...., cl}`\\n`d` --> `{d1, d2, d3, ...., dk}`\\n\\nif `cbda` is the result, there must exist: `cx < by < dz < at`\\nWe can go for **Brute-Force** to check all permutations (of cource in the order):\\n* check `abcd`first --> then check `abdc` --> then check `acbd`, ...\\n* check `bacd` --> then check `badc` --> ...\\n* finally check `dcba`\\n\\n**The 3rd thought** would be instead of checking each permutation, can we check each position of the result?\\nFor example: if `cdba` is the result, so `c` must be the `1st` position, `d` must be the `2nd` position, ... How come can we know these facts?\\n\\n* if `c` is the `1st` position, there must be a group `{a,b,d}` or `{d,b,a}`, ... standing after a position of `c` in `s` (The order of group, we don\\'t care). Once we know `c` is the `1st` position, we add `c` to the result: `res.append(\\'c\\')` and move `c` out of our game.\\n\\n* Once we have chosen the position `ci` of letter `c` in `s` for the `1st` position of `result`, we know that all positions < `ci`, we don\\'t care. So remove all positions < `ci` from `{b1, b2, ...}`, `{c1, c2, ...}`, `{d1, d2, ...}`\\n\\n* We do the same, if `d` is the `2snd` position, there must be a group `{a,b}` or `{b,a}` standing after a position of `d` in `s`...\\n\\n**The 4th thought** would be we go for **Greedy** to choose the best possible for each step.\\n\\nFor example, which letter do we expect to put for the `1st` position of the result? **Of course, it\\'s `a`**. \\n\\nNext, if `a` is correct, which position of `a` from `{a1, a2, ..., am}` we will choose? **Of course, it\\'s `a1`**. If the minimum position of `a` doesn\\'t satisfy, so who can?\\n\\nNext, there must be a group `{b, c, d}` (the order is not important) standing after `a1`. So, which positions of `b`, `c`, `d`, we should choose to compare with `a1`? **Of course, go for the largest ones**. If the maximum positions of `b`, `c`, `d` cannot stand after `a1`, so who can?\\n\\nIn the case, `a` can\\'t be put in the `1st` position, so which next letter should be chosen? **Of course, we choose the 2nd best possibility `b`**.\\n\\nNow, if `b` can be put in the `1st` position, so which letter we should choose for the `2nd` position? **Of course, again we choose the best possibility `a`**, because `a` is still free to choose.\\n\\n````\\n\\n\\tpublic String removeDuplicateLetters(String s) {\\n\\n        Letter[] letters = new Letter[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            int j = s.charAt(i)-\\'a\\';\\n            if (letters[j] == null) letters[j] = new Letter();\\n            letters[j].addPos(i);\\n        }\\n\\n        int size = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (letters[i] != null) size++;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        while (sb.length() < size) {\\n            for (int i = 0; i < letters.length; i++) {\\n                char c = (char)(i+\\'a\\');\\n                if (tryLetter(letters, i)) {\\n                    sb.append(c);\\n                    letters[i] = null;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public boolean tryLetter(Letter[] letters, int index) {\\n        Letter letter = letters[index];\\n        if (letter == null) return false;\\n\\n        // check\\n        for (int i = index+1; i < letters.length; i++) {\\n            if (letters[i] == null) continue;\\n            if (letter.minPos() > letters[i].maxPos()) return false;\\n        }\\n\\n        // clean\\n        for (int i = index+1; i < letters.length; i++) {\\n            if (letters[i] != null) letters[i].clean(letter.minPos());\\n        }\\n        return true;\\n    }\\n\\n    class Letter {\\n        List<Integer> pos;\\n        int iMin;\\n\\n        public Letter() {\\n            this.pos = new ArrayList<>();\\n            this.iMin = 0;\\n        }\\n\\n        public void addPos(int p) { pos.add(p);}\\n\\n        public int minPos() { return pos.get(iMin); }\\n\\n        public int maxPos() { return pos.get(pos.size()-1); }\\n\\n        public void clean(int fromPos) {\\n            for (int i = iMin; i < pos.size(); i++) {\\n                if (pos.get(i) > fromPos) break;\\n                iMin++;\\n            }\\n        }\\n    }\\n\\n````\\n\\n\\n",
                "solutionTags": [],
                "code": "````\\n\\n\\tpublic String removeDuplicateLetters(String s) {\\n\\n        Letter[] letters = new Letter[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            int j = s.charAt(i)-\\'a\\';\\n            if (letters[j] == null) letters[j] = new Letter();\\n            letters[j].addPos(i);\\n        }\\n\\n        int size = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (letters[i] != null) size++;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        while (sb.length() < size) {\\n            for (int i = 0; i < letters.length; i++) {\\n                char c = (char)(i+\\'a\\');\\n                if (tryLetter(letters, i)) {\\n                    sb.append(c);\\n                    letters[i] = null;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n\\n    public boolean tryLetter(Letter[] letters, int index) {\\n        Letter letter = letters[index];\\n        if (letter == null) return false;\\n\\n        // check\\n        for (int i = index+1; i < letters.length; i++) {\\n            if (letters[i] == null) continue;\\n            if (letter.minPos() > letters[i].maxPos()) return false;\\n        }\\n\\n        // clean\\n        for (int i = index+1; i < letters.length; i++) {\\n            if (letters[i] != null) letters[i].clean(letter.minPos());\\n        }\\n        return true;\\n    }\\n\\n    class Letter {\\n        List<Integer> pos;\\n        int iMin;\\n\\n        public Letter() {\\n            this.pos = new ArrayList<>();\\n            this.iMin = 0;\\n        }\\n\\n        public void addPos(int p) { pos.add(p);}\\n\\n        public int minPos() { return pos.get(iMin); }\\n\\n        public int maxPos() { return pos.get(pos.size()-1); }\\n\\n        public void clean(int fromPos) {\\n            for (int i = iMin; i < pos.size(); i++) {\\n                if (pos.get(i) > fromPos) break;\\n                iMin++;\\n            }\\n        }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247012,
                "title": "java-code-with-explanation-faster-than-100-in-execution-time",
                "content": "```\\npublic String removeDuplicateLetters(String s) {        \\n        // We want to keep the characters sorted in ascending order whenever possible.\\n        // When we come across a char \"g\" first, and \"d\" second, if we know that there is\\n        // another \"g\" to the right of \"d\", we can always skip first \"g\" in favor of the one in the right\\n\\n        // sBuff acts as a stack kind of data structure where we append to end of it,\\n        // or remove from end of it based on above condition\\n        StringBuffer sBuff = new StringBuffer();\\n\\n        int[] charCount = new int[26]; // To keep track of how many chars are remaining to the right of current char        \\n        for (char ch: s.toCharArray()) {\\n            charCount[ch-\\'a\\']++;\\n        }        \\n        \\n        boolean[] presentInStack = new boolean[26];\\n        \\n        for (int i=0; i<s.length(); i++) {\\n            char ch = s.charAt(i);\\n            charCount[ch - \\'a\\']--;\\n\\n            if (presentInStack[ch-\\'a\\']) {\\n                continue;\\n            }\\n\\n            char lastChar;\\n            int index = sBuff.length()-1;\\n            while (index >= 0 && (lastChar = sBuff.charAt(index)) > ch && charCount[lastChar-\\'a\\'] > 0) {\\n                presentInStack[lastChar-\\'a\\'] = false; // Not present in stack anymore\\n                index--;\\n            }\\n            if (index != sBuff.length()-1) {\\n                // We can remove some elements from end of the string which are greater than current char\\n                sBuff.setLength(index+1);            \\n            }\\n\\n            presentInStack[ch-\\'a\\'] = true;\\n            sBuff.append(ch);            \\n        }\\n        \\n        return sBuff.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String removeDuplicateLetters(String s) {        \\n        // We want to keep the characters sorted in ascending order whenever possible.\\n        // When we come across a char \"g\" first, and \"d\" second, if we know that there is\\n        // another \"g\" to the right of \"d\", we can always skip first \"g\" in favor of the one in the right\\n\\n        // sBuff acts as a stack kind of data structure where we append to end of it,\\n        // or remove from end of it based on above condition\\n        StringBuffer sBuff = new StringBuffer();\\n\\n        int[] charCount = new int[26]; // To keep track of how many chars are remaining to the right of current char        \\n        for (char ch: s.toCharArray()) {\\n            charCount[ch-\\'a\\']++;\\n        }        \\n        \\n        boolean[] presentInStack = new boolean[26];\\n        \\n        for (int i=0; i<s.length(); i++) {\\n            char ch = s.charAt(i);\\n            charCount[ch - \\'a\\']--;\\n\\n            if (presentInStack[ch-\\'a\\']) {\\n                continue;\\n            }\\n\\n            char lastChar;\\n            int index = sBuff.length()-1;\\n            while (index >= 0 && (lastChar = sBuff.charAt(index)) > ch && charCount[lastChar-\\'a\\'] > 0) {\\n                presentInStack[lastChar-\\'a\\'] = false; // Not present in stack anymore\\n                index--;\\n            }\\n            if (index != sBuff.length()-1) {\\n                // We can remove some elements from end of the string which are greater than current char\\n                sBuff.setLength(index+1);            \\n            }\\n\\n            presentInStack[ch-\\'a\\'] = true;\\n            sBuff.append(ch);            \\n        }\\n        \\n        return sBuff.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 76828,
                "title": "clear-c-solution",
                "content": "    class Solution {\\n    public:\\n        string removeDuplicateLetters(string s) {\\n            vector<int> mp(26);\\n            for (int i = 0; i < s.size(); i++)\\n                mp[s[i] - 'a']++;\\n            stack<char> S;\\n            vector<bool> visited(26, false);\\n            for (int i = 0; i < s.size(); i++) {\\n                if (visited[s[i] - 'a']) {\\n                    mp[s[i] - 'a']--;\\n                    continue;\\n                }\\n                while (!S.empty() && S.top() >= s[i] && mp[S.top() - 'a'] > 1) {\\n                    mp[S.top() - 'a']--;\\n                    visited[S.top() - 'a'] = false;\\n                    S.pop();\\n                }\\n                S.push(s[i]);\\n                visited[s[i] - 'a'] = true;\\n            }\\n            string result = \"\";\\n            while (!S.empty()) {\\n                result = S.top() + result;\\n                S.pop();\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string removeDuplicateLetters(string s) {\\n            vector<int> mp(26);\\n            for (int i = 0; i < s.size(); i++)\\n                mp[s[i] - 'a']++;\\n            stack<char> S;\\n            vector<bool> visited(26, false);\\n            for (int i = 0; i < s.size(); i++) {\\n                if (visited[s[i] - 'a']) {\\n                    mp[s[i] - 'a']--;\\n                    continue;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4090799,
                "title": "simple-c-o-n-solution-using-visited-frequency-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem asks us to find the smallest lexicographical string that can be obtained by removing duplicate letters from the given string while maintaining the relative order of the characters. To achieve this, we need to make sure that the characters appear in their smallest lexicographical order. We can use a greedy approach to build the answer string.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nIntuition\\nThe problem asks us to find the smallest lexicographical string that can be obtained by removing duplicate letters from the given string while maintaining the relative order of the characters. To achieve this, we need to make sure that the characters appear in their smallest lexicographical order. We can use a greedy approach to build the answer string.\\n\\nApproach\\n1. Initialize:\\n    - Create a frequency array `freq` to store the frequency of each character in the input string s.\\n    - Create a boolean array `visited` to keep track of whether a character has been visited or not.\\n2. Iterate through each character in the input string `s`.\\n    - Decrement the frequency of the current character.\\n    - Check if the current character is not visited:\\n        - While the answer string `ans` is not empty, the last character in ans is greater than the current character, and there are more occurrences of the last character later in the input string:\\n            - Pop the last character from ans.\\n            - Mark the last character as not visited.\\n            - Repeat this until the above condition is met.\\n        - Append the current character to ans.\\n        - Mark the current character as visited.\\n3. Return the final `ans` string\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n      vector<int>freq(26,0), visited(26,0);\\n        for(auto ch:s)freq[ch-\\'a\\']++;\\n\\n        string ans;\\n        int n = s.length();\\n        for(int i=0;i<n;i++){\\n               freq[s[i]-\\'a\\']--;\\n               if(!visited[s[i]-\\'a\\']){ \\n                while(ans.size() and ans.back()>s[i] and freq[ans.back()-\\'a\\']>0) {\\n                    visited[ans.back()-\\'a\\'] = 0;\\n                    ans.pop_back();\\n                }\\n                ans.push_back(s[i]);\\n                visited[s[i]-\\'a\\'] = 1;\\n                }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n      vector<int>freq(26,0), visited(26,0);\\n        for(auto ch:s)freq[ch-\\'a\\']++;\\n\\n        string ans;\\n        int n = s.length();\\n        for(int i=0;i<n;i++){\\n               freq[s[i]-\\'a\\']--;\\n               if(!visited[s[i]-\\'a\\']){ \\n                while(ans.size() and ans.back()>s[i] and freq[ans.back()-\\'a\\']>0) {\\n                    visited[ans.back()-\\'a\\'] = 0;\\n                    ans.pop_back();\\n                }\\n                ans.push_back(s[i]);\\n                visited[s[i]-\\'a\\'] = 1;\\n                }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687144,
                "title": "python-3-simple-solution-using-a-stack-and-greedy-approach-32ms-14-4mb",
                "content": "The main constraint of this problem is that we have to return the substring containing unique characters, but:\\n\\t1) we must maintain the inherent order of the characters and\\n\\t2) we must return the lexicographically smallest substring among the candidates.\\n\\nIn order to do this, we\\'ll use the stack data structure. The essence of the algorithm is that we\\'re checking whether or not our current character is lexicographically smaller than each element in the stack, and if it is and the stack character happens to appear later on in the string (i.e., it\\'s a duplicate) then we pop it.\\n\\nIt\\'s hard to explain in words so I drew a flowchart:\\n![image](https://assets.leetcode.com/users/images/b13875f4-a38b-4a23-bd61-e21dc6e3af9e_1642069125.8223226.png)\\n\\nHere\\'s the code:\\n\\n```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        stack = []\\n        \\n        for idx, character in enumerate(s):\\n            if not stack:\\n                stack.append(character)\\n            elif character in stack:\\n                continue\\n            else:\\n                while stack and (character < stack[-1]):\\n                    if stack[-1] in s[idx + 1:]:\\n                        _ = stack.pop()\\n                    else:\\n                        break\\n                        \\n                stack.append(character)\\n                \\n        return \\'\\'.join(stack)\\n```\\n\\nTime complexity is O(n) since we\\'re looping once through the input string, and space complexity is O(n) as well since our stack also linearly depends on our input string and the worst case is when the size of the stack is the same as the input (i.e., all characters are unique).",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        stack = []\\n        \\n        for idx, character in enumerate(s):\\n            if not stack:\\n                stack.append(character)\\n            elif character in stack:\\n                continue\\n            else:\\n                while stack and (character < stack[-1]):\\n                    if stack[-1] in s[idx + 1:]:\\n                        _ = stack.pop()\\n                    else:\\n                        break\\n                        \\n                stack.append(character)\\n                \\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630516,
                "title": "my-simple-c-solution-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s){\\n        \\n        unordered_map<char, int>last; //Map to store last index of every char\\n        vector<bool>vis(26);          //Vector to check if the character is visited\\n        string ans = \"\";\\n        \\n        for(int i = 0; i < s.size(); i++)\\n            last[s[i]] = i;         //Storing the last index of each character\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            if(vis[s[i] - \\'a\\']) continue;   //If index is visited, pass\\n            \\n            \\n            //If s[i] is smaller than last character of ans and last index of the \\n            //character is greater than i, we can delete the last character of\\n            //ans as it will come after i later\\n            while(!ans.empty() && ans.back() > s[i] && last[ans.back()] > i){\\n                vis[ans.back() - \\'a\\'] = false;      \\n                ans.pop_back();\\n            }\\n            ans.push_back(s[i]);            //Adding the current character to ans\\n            vis[s[i] - \\'a\\'] = true;         //Marking the current node visited\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**If you find it helpful, kindly upvote...** \\uD83D\\uDE00",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s){\\n        \\n        unordered_map<char, int>last; //Map to store last index of every char\\n        vector<bool>vis(26);          //Vector to check if the character is visited\\n        string ans = \"\";\\n        \\n        for(int i = 0; i < s.size(); i++)\\n            last[s[i]] = i;         //Storing the last index of each character\\n        \\n        for(int i = 0; i < s.size(); i++){\\n            if(vis[s[i] - \\'a\\']) continue;   //If index is visited, pass\\n            \\n            \\n            //If s[i] is smaller than last character of ans and last index of the \\n            //character is greater than i, we can delete the last character of\\n            //ans as it will come after i later\\n            while(!ans.empty() && ans.back() > s[i] && last[ans.back()] > i){\\n                vis[ans.back() - \\'a\\'] = false;      \\n                ans.pop_back();\\n            }\\n            ans.push_back(s[i]);            //Adding the current character to ans\\n            vis[s[i] - \\'a\\'] = true;         //Marking the current node visited\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1534850,
                "title": "simple-and-concise-map-c",
                "content": "Implementation\\n\\n**Time Complexity = O(N), Space Complexity = O(N)**\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        unordered_map<char, int> frequency;\\n        unordered_map<char, bool> visited;\\n        string res;\\n        for(auto ch : s) frequency[ch]++;\\n        for(auto ch : s){\\n            frequency[ch]--;\\n            if(visited[ch]) continue;\\n            while(!res.empty() && res.back() > ch && frequency[res.back()] > 0){\\n                visited[res.back()] = false;\\n                res.pop_back();\\n            }\\n            visited[ch] = true;\\n            res += ch;\\n        }\\n        return res;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding **:)**",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        unordered_map<char, int> frequency;\\n        unordered_map<char, bool> visited;\\n        string res;\\n        for(auto ch : s) frequency[ch]++;\\n        for(auto ch : s){\\n            frequency[ch]--;\\n            if(visited[ch]) continue;\\n            while(!res.empty() && res.back() > ch && frequency[res.back()] > 0){\\n                visited[res.back()] = false;\\n                res.pop_back();\\n            }\\n            visited[ch] = true;\\n            res += ch;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 215167,
                "title": "python-stack-o-n",
                "content": "```\\nclass Solution:\\n    def removeDuplicateLetters(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        last_idx = {c:i for i, c in enumerate(s)}\\n        ans = []\\n        seen = set()\\n        for i, c in enumerate(s):\\n            if c not in seen:\\n                while ans and c < ans[-1] and i < last_idx[ans[-1]]:\\n                    tail = ans.pop()\\n                    seen.remove(tail)\\n                ans.append(c)\\n                seen.add(c)\\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicateLetters(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        last_idx = {c:i for i, c in enumerate(s)}\\n        ans = []\\n        seen = set()\\n        for i, c in enumerate(s):\\n            if c not in seen:\\n                while ans and c < ans[-1] and i < last_idx[ans[-1]]:\\n                    tail = ans.pop()\\n                    seen.remove(tail)\\n                ans.append(c)\\n                seen.add(c)\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 76859,
                "title": "my-simple-c-o-n-solution-4ms",
                "content": "The key is to get an auxiliary array to save the index of the last occurence of each letter in S. Then we do greedy algorithm: scan the string from left to right, for the current letter s[i], if it is already included then move on, if not, check if the previously included letter in res (from back to begin) if larger than s[i], if yes and such res.back() letter has occurence after the current position i, then drop it from res and reset the included flag (since it can reduce res and res.back() can still be added back later on), and repeat to check the new res.back(). If s[i]> res.back() or res.back() has no occurence after i, then, just add s[i] to res.\\nTwo key arrays are used in the following code\\nlastIdx[i]: the last occurence index of letter 'a'+i in s \\nincluded[i]: if 'a'+i is already included in res\\n\\n     \\n       class Solution {\\n        public:\\n            string removeDuplicateLetters(string s) {\\n                int sLen = s.size(), i, lastIdx[26]={0},resLen=0, included[26]={0};\\n                string res;\\n                for(i=sLen-1; i>=0 && resLen<26;--i) //generate lastIdx array\\n                       if(!lastIdx[s[i]-'a']) {\\n                        lastIdx[s[i]-'a'] = i; \\n                        ++resLen;\\n                      }  \\n                for(i=0; i<sLen;++i) \\n                { //scan s from left to right\\n                    if(!included[s[i]-'a'])\\n                    { // if s[i] is not included in s[i]\\n                        while(!res.empty() && s[i]<res.back() && lastIdx[res.back()-'a']>i)\\n                        { // pop res as much as possible to reduce res\\n                            included[res.back()-'a'] = 0;\\n                            res.pop_back();\\n                        }\\n                        included[s[i]-'a'] = 1; // add s[i] to res\\n                        res.push_back(s[i]);\\n                    }\\n                }\\n                return res;\\n            }\\n    };\\n\\nMy first ugly version, 8ms, a little bit different auxilliary info used, less efficient and concise, 8ms\\n\\n    class Solution {\\n    public:\\n        string removeDuplicateLetters(string s) {\\n            if(s.size() <= 1) return s;\\n            string res;\\n            int sLen =s.size(), i, resL, inS[26]={0}, start=0, count[sLen+1] = {0};\\n            char curC = 'z'+1;\\n            for(i=sLen-1; i>=0; --i)\\n            {\\n                count[i] = count[i+1];\\n                if(inS[s[i]-'a']==0) \\n                {\\n                    inS[s[i]-'a'] = 1;\\n                    ++count[i];\\n                }\\n            }\\n            resL = count[0];\\n            while(resL)\\n            {\\n                for(i=start, curC='z'+1;i==0 || count[i]==count[i-1] || inS[s[i-1]-'a']== 0;++i)\\n                    if(inS[s[i]-'a'] && s[i]<curC) {\\n                        curC=s[i]; \\n                        start=i;\\n                    }\\n    \\n                inS[s[start]-'a']= 0;\\n                res.push_back(s[start++]);\\n                --resL;\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            string removeDuplicateLetters(string s) {\\n                int sLen = s.size(), i, lastIdx[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 4091755,
                "title": "c-stack-deque-vs-just-string-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt uses a stack and two vectors to keep track of character frequencies and whether a character has been seen before. The algorithm iterates through the input string, considering each character, and decides whether to include it in the result.\\n\\n2nd approach just uses string ans. No need for stack and deque. Why?\\nstring operations pop_back() & push_back() play the same roles for stack operations pop() & push(). The string ans is sufficient for the solution.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStack (st):\\nThe stack (st) is used to keep track of the indices of characters from the input string s.\\nIt ensures that the characters in the resulting string maintain their relative order while removing duplicates.\\nCharacters are pushed onto the stack if they meet certain conditions.\\nDeque (ans):\\n\\nThe deque (ans) is used to store the resulting characters.\\nCharacters are popped from the stack and added to the front of the deque to maintain their original order.\\nThe deque is used to build the final result string with duplicates removed.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(26)=O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> freq(26, 0);\\n        vector<bool> seen(26, 0);\\n        stack<int> st;\\n\\n        for (char c : s)\\n            freq[c-\\'a\\']++;\\n\\n        deque<char> ans;\\n        int n = s.size();\\n        for (int i = 0; i < n; i++) {\\n            char c = s[i];\\n            freq[c-\\'a\\']--;\\n            if (seen[c - \\'a\\']) continue;\\n            while (!st.empty()&& c< s[st.top()] && freq[s[st.top()]-\\'a\\'] > 0) {\\n                seen[s[st.top()]-\\'a\\'] = 0;\\n                st.pop();\\n            }\\n            st.push(i);\\n            seen[c-\\'a\\'] = 1;\\n        }\\n        while (!st.empty()) {\\n            ans.push_front(s[st.top()]);\\n            st.pop();\\n        }\\n        \\n        return string(ans.begin(), ans.end());\\n    }\\n};\\n```\\n# Code with Explanation in comments\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        // Initialize two vectors to track character frequencies and whether characters are seen\\n        vector<int> freq(26, 0);     // freq: to count the frequency of each lowercase letter\\n        vector<bool> seen(26, 0); // seen: to track if a letter is already in the result\\n        stack<int> st;               // Create a stack to store the indices of characters\\n        \\n        // Count the frequency of each character in the input string \\'s\\'\\n        for (char c : s)\\n            freq[c - \\'a\\']++;\\n\\n        // Initialize a deque to store the resulting characters\\n        deque<char> ans;\\n        int n = s.size(); // Get the length of the input string \\'s\\'\\n\\n        for (int i = 0; i < n; i++) {\\n            char c = s[i]; // Current character\\n\\n            freq[c - \\'a\\']--; // Decrease the frequency of this character since we are considering it\\n\\n            if (seen[c - \\'a\\']) continue; // If we\\'ve already seen this character, skip it\\n\\n            // Check for characters in the stack that are greater than the current character\\n            while (!st.empty() && c < s[st.top()] && freq[s[st.top()] - \\'a\\'] > 0) {\\n                // Pop characters from the stack and mark them as unseen\\n                seen[s[st.top()] - \\'a\\'] = 0;\\n                st.pop();\\n            }\\n\\n            // Push the current character onto the stack and mark it as seen\\n            st.push(i);\\n            seen[c - \\'a\\'] = 1;\\n        }\\n\\n        // Pop characters from the stack and add them to the front of the result deque\\n        while (!st.empty()) {\\n            ans.push_front(s[st.top()]);\\n            st.pop();\\n        }\\n        \\n        // Convert the deque to a string and return the result\\n        return string(ans.begin(), ans.end());\\n    }\\n};\\n\\n```\\n# 2nd Approach\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> freq(26, 0);\\n        vector<bool> seen(26, 0);\\n\\n        for (char c : s)\\n            freq[c-\\'a\\']++;\\n\\n        string ans=\"\";\\n        for (char c : s) {\\n            freq[c-\\'a\\']--;\\n            if (seen[c - \\'a\\']) continue;\\n            while (ans!=\"\" && c< ans.back() && freq[ans.back()-\\'a\\'] > 0) {\\n                seen[ans.back()-\\'a\\'] = 0;\\n                ans.pop_back();\\n            }\\n            ans.push_back(c);\\n            seen[c-\\'a\\'] = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> freq(26, 0);\\n        vector<bool> seen(26, 0);\\n        stack<int> st;\\n\\n        for (char c : s)\\n            freq[c-\\'a\\']++;\\n\\n        deque<char> ans;\\n        int n = s.size();\\n        for (int i = 0; i < n; i++) {\\n            char c = s[i];\\n            freq[c-\\'a\\']--;\\n            if (seen[c - \\'a\\']) continue;\\n            while (!st.empty()&& c< s[st.top()] && freq[s[st.top()]-\\'a\\'] > 0) {\\n                seen[s[st.top()]-\\'a\\'] = 0;\\n                st.pop();\\n            }\\n            st.push(i);\\n            seen[c-\\'a\\'] = 1;\\n        }\\n        while (!st.empty()) {\\n            ans.push_front(s[st.top()]);\\n            st.pop();\\n        }\\n        \\n        return string(ans.begin(), ans.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        // Initialize two vectors to track character frequencies and whether characters are seen\\n        vector<int> freq(26, 0);     // freq: to count the frequency of each lowercase letter\\n        vector<bool> seen(26, 0); // seen: to track if a letter is already in the result\\n        stack<int> st;               // Create a stack to store the indices of characters\\n        \\n        // Count the frequency of each character in the input string \\'s\\'\\n        for (char c : s)\\n            freq[c - \\'a\\']++;\\n\\n        // Initialize a deque to store the resulting characters\\n        deque<char> ans;\\n        int n = s.size(); // Get the length of the input string \\'s\\'\\n\\n        for (int i = 0; i < n; i++) {\\n            char c = s[i]; // Current character\\n\\n            freq[c - \\'a\\']--; // Decrease the frequency of this character since we are considering it\\n\\n            if (seen[c - \\'a\\']) continue; // If we\\'ve already seen this character, skip it\\n\\n            // Check for characters in the stack that are greater than the current character\\n            while (!st.empty() && c < s[st.top()] && freq[s[st.top()] - \\'a\\'] > 0) {\\n                // Pop characters from the stack and mark them as unseen\\n                seen[s[st.top()] - \\'a\\'] = 0;\\n                st.pop();\\n            }\\n\\n            // Push the current character onto the stack and mark it as seen\\n            st.push(i);\\n            seen[c - \\'a\\'] = 1;\\n        }\\n\\n        // Pop characters from the stack and add them to the front of the result deque\\n        while (!st.empty()) {\\n            ans.push_front(s[st.top()]);\\n            st.pop();\\n        }\\n        \\n        // Convert the deque to a string and return the result\\n        return string(ans.begin(), ans.end());\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> freq(26, 0);\\n        vector<bool> seen(26, 0);\\n\\n        for (char c : s)\\n            freq[c-\\'a\\']++;\\n\\n        string ans=\"\";\\n        for (char c : s) {\\n            freq[c-\\'a\\']--;\\n            if (seen[c - \\'a\\']) continue;\\n            while (ans!=\"\" && c< ans.back() && freq[ans.back()-\\'a\\'] > 0) {\\n                seen[ans.back()-\\'a\\'] = 0;\\n                ans.pop_back();\\n            }\\n            ans.push_back(c);\\n            seen[c-\\'a\\'] = 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091249,
                "title": "beats-100-with-explanation-and-visualization",
                "content": "\\n# Approach\\nWe have to find a lexicographically smallest subsequence formed by deleting repeating characters in the original string such that every character stays only once. This means that the relative order of the characters need to be preserved.\\n\\nWe do this by - \\n- First Create an array `lastIndex` which stores the last index of any character in the string `s`.\\n- Create a boolean array `seen` to keep track of whether we\\'ve seen a certain character or not.\\n- In our result string we have to pick characters which aren\\'t already picked, also the current character picked should be `lexicographically greater` than the previous character. This can be achieved with the help of a stack . So create a stack `st`.\\n- Now, traverse over our string `s` and find our `curr`. `curr` repressents the index of the character in `alphabets`.\\n- If the character `curr` is already seen continue move on to next character.\\n- Else while the stack is not empty and our current character is smaller than the top of stack , pop the top of stack and mark it unseen , i.e `false`. This way our stack\\'s any element is always greater than its previous.\\n- After this popping operation is done, the stack\\'s top is less than our current character `s[i]` hence push `s[i]` in the stack and mark it `seen , i.e true`.\\n- At last, pop the stack elements and store it in a string `ans` and return `ans` in reverse order.\\n\\n# I\\'ve explained the second test case below for better understanding.\\n![image.png](https://assets.leetcode.com/users/images/668c7bd1-fcb1-4c1e-b584-6fb723b072b8_1695705396.801895.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> lastIndex(26, 0);\\n        for (int i = 0; i < s.length(); i++){\\n            lastIndex[s[i] - \\'a\\'] = i; \\n        }\\n        \\n        vector<bool> seen(26, false); \\n        stack<char> st;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            int curr = s[i] - \\'a\\';\\n            if (seen[curr]) continue; \\n            while(st.size() > 0 && st.top() > s[i] && i < lastIndex[st.top() - \\'a\\']){\\n                seen[st.top() - \\'a\\'] = false; // pop out and mark unseen\\n                st.pop();\\n            }\\n            st.push(s[i]); \\n            seen[curr] = true; \\n        }\\n        \\n        string ans = \"\";\\n        while (st.size() > 0){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\n# JAva Code\\n```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        int[] lastIndex = new int[26];\\n        for (int i = 0; i < s.length(); i++){\\n            lastIndex[s.charAt(i) - \\'a\\'] = i; // track the lastIndex of character presence\\n        }\\n        \\n        boolean[] seen = new boolean[26]; // keep track seen\\n        Stack<Integer> st = new Stack();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            int curr = s.charAt(i) - \\'a\\';\\n            if (seen[curr]) continue; // if seen continue as we need to pick one char only\\n            while (!st.isEmpty() && st.peek() > curr && i < lastIndex[st.peek()]){\\n                seen[st.pop()] = false; // pop out and mark unseen\\n            }\\n            st.push(curr); // add into stack\\n            seen[curr] = true; // mark seen\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        while (!st.isEmpty())\\n            sb.append((char) (st.pop() + \\'a\\'));\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> lastIndex(26, 0);\\n        for (int i = 0; i < s.length(); i++){\\n            lastIndex[s[i] - \\'a\\'] = i; \\n        }\\n        \\n        vector<bool> seen(26, false); \\n        stack<char> st;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            int curr = s[i] - \\'a\\';\\n            if (seen[curr]) continue; \\n            while(st.size() > 0 && st.top() > s[i] && i < lastIndex[st.top() - \\'a\\']){\\n                seen[st.top() - \\'a\\'] = false; // pop out and mark unseen\\n                st.pop();\\n            }\\n            st.push(s[i]); \\n            seen[curr] = true; \\n        }\\n        \\n        string ans = \"\";\\n        while (st.size() > 0){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        int[] lastIndex = new int[26];\\n        for (int i = 0; i < s.length(); i++){\\n            lastIndex[s.charAt(i) - \\'a\\'] = i; // track the lastIndex of character presence\\n        }\\n        \\n        boolean[] seen = new boolean[26]; // keep track seen\\n        Stack<Integer> st = new Stack();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            int curr = s.charAt(i) - \\'a\\';\\n            if (seen[curr]) continue; // if seen continue as we need to pick one char only\\n            while (!st.isEmpty() && st.peek() > curr && i < lastIndex[st.peek()]){\\n                seen[st.pop()] = false; // pop out and mark unseen\\n            }\\n            st.push(curr); // add into stack\\n            seen[curr] = true; // mark seen\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        while (!st.isEmpty())\\n            sb.append((char) (st.pop() + \\'a\\'));\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816297,
                "title": "remove-duplicate-letters",
                "content": "same as - [smallest subsequence of distinct characters](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/)\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        \\n        int count[26]={0};//stores the frequency of characters\\n        int visited[26]={0};//visited characters\\n        int n=s.length();\\n        \\n        //stores count of each character\\n        for(int i=0;i<n;i++){\\n            count[s[i]-\\'a\\']++;\\n        }\\n        string res=\"\";//stores the resultant string\\n        for(int i=0;i<n;i++){\\n            //decrease the count of current character\\n            count[s[i]-\\'a\\']--;\\n            //if character is not already in answer\\n            if(!visited[s[i]-\\'a\\']){\\n                //last chracter>s[i] and its count >0\\n                while(res.length()>0 && res.back()>s[i] && count[res.back()-\\'a\\']>0){\\n                    //mark letter unvisited\\n                    visited[res.back()-\\'a\\']=0;\\n                    res.pop_back();\\n                }\\n                //add s[i] in res and mark it visited\\n                res+=s[i];\\n                visited[s[i]-\\'a\\']=1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n*Please give an upvote!\\nIt will boost me to solve more questions.\\nHappy Leetcoding!\\nThank you!*",
                "solutionTags": [
                    "C",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        \\n        int count[26]={0};//stores the frequency of characters\\n        int visited[26]={0};//visited characters\\n        int n=s.length();\\n        \\n        //stores count of each character\\n        for(int i=0;i<n;i++){\\n            count[s[i]-\\'a\\']++;\\n        }\\n        string res=\"\";//stores the resultant string\\n        for(int i=0;i<n;i++){\\n            //decrease the count of current character\\n            count[s[i]-\\'a\\']--;\\n            //if character is not already in answer\\n            if(!visited[s[i]-\\'a\\']){\\n                //last chracter>s[i] and its count >0\\n                while(res.length()>0 && res.back()>s[i] && count[res.back()-\\'a\\']>0){\\n                    //mark letter unvisited\\n                    visited[res.back()-\\'a\\']=0;\\n                    res.pop_back();\\n                }\\n                //add s[i] in res and mark it visited\\n                res+=s[i];\\n                visited[s[i]-\\'a\\']=1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393353,
                "title": "most-lucrative-c-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        //algo-push when the char is bigger than the top of the stack.\\n        //pop,when the top of the stack is bigger than the current char and the top of the stack has more iterations of it still to come. continue this until we find place in the result stack where the current char is bigger than the then top of the stack or the stack gets empty.\\n        //stack functionality can be usd by string too. so we have 2 string ,one is the originall string, other one is the result string.\\n        //we have two maps ,one is used as count array of diff char nd other as boolean array,,,this boolean map is used to show which char is already pushed in the stack, when u push a char,u mark bool map for that char 1 and vice versa.\\n        map<char,int> m;\\n        map<char,bool> v;\\n        for(auto i:s)\\n        {\\n            m[i]++;\\n            v[i]=0;\\n        }\\n       \\n        string ans ={0};\\n        \\n        for(auto i:s)\\n        {\\n            m[i]--;\\n            if(!v[i])\\n            {\\n                while(i<ans.back() && m[ans.back()])\\n                {\\n                    v[ans.back()]=0;\\n                    ans.pop_back();\\n                }\\n                ans+=i;\\n                v[i]=1;\\n            }\\n        }\\n        return ans.substr(1);\\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        //algo-push when the char is bigger than the top of the stack.\\n        //pop,when the top of the stack is bigger than the current char and the top of the stack has more iterations of it still to come. continue this until we find place in the result stack where the current char is bigger than the then top of the stack or the stack gets empty.\\n        //stack functionality can be usd by string too. so we have 2 string ,one is the originall string, other one is the result string.\\n        //we have two maps ,one is used as count array of diff char nd other as boolean array,,,this boolean map is used to show which char is already pushed in the stack, when u push a char,u mark bool map for that char 1 and vice versa.\\n        map<char,int> m;\\n        map<char,bool> v;\\n        for(auto i:s)\\n        {\\n            m[i]++;\\n            v[i]=0;\\n        }\\n       \\n        string ans ={0};\\n        \\n        for(auto i:s)\\n        {\\n            m[i]--;\\n            if(!v[i])\\n            {\\n                while(i<ans.back() && m[ans.back()])\\n                {\\n                    v[ans.back()]=0;\\n                    ans.pop_back();\\n                }\\n                ans+=i;\\n                v[i]=1;\\n            }\\n        }\\n        return ans.substr(1);\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272211,
                "title": "c-explained-easy-stack-0-ms-faster-than-100-00",
                "content": "Code has been commented below:\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        \\n        stack<char> st; \\n        vector<int> freq(27,0), vis(27,0);\\n//loop and get the frequency of all charcters\\n        for(auto x:s){\\n            freq[x-\\'a\\']++;\\n        }\\n//now we traverse the given string to find the lexographically smallest meeting the required condition\\n        for(int i=0;i<s.size();i++){\\n             freq[s[i]-\\'a\\']--;  //for the ith char decrease its frequency\\n             \\n            if(vis[s[i]-\\'a\\']) //if char s[i] has been alreaddy visited then process next\\n            continue; \\n//to find lexographically smallest  we pop the satck till we find the topmost element in\\n// stack is> s[i] and its frequency is >0 i.e if frequency is greater than zero we can use\\n//that element somewhere right afterwards\\n            while(!st.empty()&& st.top()>s[i] && freq[st.top()-\\'a\\']>0){\\n                   \\n                vis[st.top()-\\'a\\']=0;\\n                 st.pop();\\n            }\\n// push the current element and mark it visited\\n            vis[s[i]-\\'a\\']=1;\\n            st.push(s[i]);\\n           \\n        }\\n//string ans will store the final result     \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n//reverse it bcoz during poping from stack we get original string charcter in reverse form\\n        reverse(ans.begin(), ans.end());\\n //return the final resulting string     \\n        return ans;\\n    }\\n};\\n``` \\n**Do upvote if explanation was useful and you liked the code:)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        \\n        stack<char> st; \\n        vector<int> freq(27,0), vis(27,0);\\n//loop and get the frequency of all charcters\\n        for(auto x:s){\\n            freq[x-\\'a\\']++;\\n        }\\n//now we traverse the given string to find the lexographically smallest meeting the required condition\\n        for(int i=0;i<s.size();i++){\\n             freq[s[i]-\\'a\\']--;  //for the ith char decrease its frequency\\n             \\n            if(vis[s[i]-\\'a\\']) //if char s[i] has been alreaddy visited then process next\\n            continue; \\n//to find lexographically smallest  we pop the satck till we find the topmost element in\\n// stack is> s[i] and its frequency is >0 i.e if frequency is greater than zero we can use\\n//that element somewhere right afterwards\\n            while(!st.empty()&& st.top()>s[i] && freq[st.top()-\\'a\\']>0){\\n                   \\n                vis[st.top()-\\'a\\']=0;\\n                 st.pop();\\n            }\\n// push the current element and mark it visited\\n            vis[s[i]-\\'a\\']=1;\\n            st.push(s[i]);\\n           \\n        }\\n//string ans will store the final result     \\n        string ans=\"\";\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n//reverse it bcoz during poping from stack we get original string charcter in reverse form\\n        reverse(ans.begin(), ans.end());\\n //return the final resulting string     \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244434,
                "title": "python-solution-o-n-using-stack-with-visualization-and-diagrams",
                "content": "\\nUse 2 dictionaries-->\\n1. LastSeenAtIndex --> To keep track of lastIndex of character in string. This helps in deciding wether char can be ignored while moving from start to end and gives surity that we will see this char again in later part of string. If the char at current index is the last occurance of that char, even though it doesnt follow sorted order, we have to keep that.\\n2. Visited --> to keep the track of visited char.\\n3. Stack - to compare characters sorting order\\n\\n![image](https://assets.leetcode.com/users/images/6560e25e-c9e8-4669-ad97-34fdd801683c_1622529730.4051428.png)\\n```\\nimport string\\nclass Solution:\\n    def smallestSubsequence(self, s: str) -> str:\\n        lastSeenAtIndex, visited =dict.fromkeys(string.ascii_lowercase,0), dict.fromkeys(string.ascii_lowercase,False)\\n        stack, res =[], \"\"\\n        for i in range(len(s)):\\n            lastSeenAtIndex[s[i]]=i\\n        for i in range(len(s)):\\n            if visited[s[i]]:\\n                continue\\n            while len(stack) and stack[-1] > s[i] and  i < lastSeenAtIndex[stack[-1]]:\\n                visited[stack.pop()]=False\\n            stack.append(s[i])\\n            visited[s[i]]=True\\n        while len(stack):\\n            res = \"\".join(stack.pop()) + res\\n        return res\\n            \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nimport string\\nclass Solution:\\n    def smallestSubsequence(self, s: str) -> str:\\n        lastSeenAtIndex, visited =dict.fromkeys(string.ascii_lowercase,0), dict.fromkeys(string.ascii_lowercase,False)\\n        stack, res =[], \"\"\\n        for i in range(len(s)):\\n            lastSeenAtIndex[s[i]]=i\\n        for i in range(len(s)):\\n            if visited[s[i]]:\\n                continue\\n            while len(stack) and stack[-1] > s[i] and  i < lastSeenAtIndex[stack[-1]]:\\n                visited[stack.pop()]=False\\n            stack.append(s[i])\\n            visited[s[i]]=True\\n        while len(stack):\\n            res = \"\".join(stack.pop()) + res\\n        return res\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1034489,
                "title": "java-stack-map-with-comments",
                "content": "```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        \\n        Map<Character, Integer> map = new HashMap<>(); // keep track of the last index of everyone\\n        Stack<Character> stack = new Stack<>(); // best for keeping track of previous characters\\n        Map<Character, Boolean> visited = new HashMap<>(); //checks if that character is finally visited\\n        \\n        //purpose of this was to keep track of the last available index of any character\\n        for(int i = 0; i < s.length(); i++) {\\n            map.put(s.charAt(i) , i);   \\n            visited.put(s.charAt(i), false);\\n        }\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            \\n            char current = s.charAt(i);\\n            //if the character is already visited then move on\\n            if(visited.get(current)) {\\n                continue;\\n            }\\n            /*main part :-\\n                If the stack is not empty and the previous character is greater and also the \\n                prvious charater is available afterwards the current :\\n                    remove the higher char and also mark it as unvisited (as afterwards we will visit it)\\n            */\\n            while(!stack.isEmpty() && stack.peek() > current && i < map.get(stack.peek())) {\\n                char temp = stack.pop();\\n                visited.put(temp, false);\\n            }\\n            //add the currect to our stack \\n            stack.push(current);\\n            //mark it visited\\n            visited.put(current, true);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder(\"\");\\n        while(!stack.isEmpty()) {\\n            sb.append(stack.pop());\\n        }\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        \\n        Map<Character, Integer> map = new HashMap<>(); // keep track of the last index of everyone\\n        Stack<Character> stack = new Stack<>(); // best for keeping track of previous characters\\n        Map<Character, Boolean> visited = new HashMap<>(); //checks if that character is finally visited\\n        \\n        //purpose of this was to keep track of the last available index of any character\\n        for(int i = 0; i < s.length(); i++) {\\n            map.put(s.charAt(i) , i);   \\n            visited.put(s.charAt(i), false);\\n        }\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            \\n            char current = s.charAt(i);\\n            //if the character is already visited then move on\\n            if(visited.get(current)) {\\n                continue;\\n            }\\n            /*main part :-\\n                If the stack is not empty and the previous character is greater and also the \\n                prvious charater is available afterwards the current :\\n                    remove the higher char and also mark it as unvisited (as afterwards we will visit it)\\n            */\\n            while(!stack.isEmpty() && stack.peek() > current && i < map.get(stack.peek())) {\\n                char temp = stack.pop();\\n                visited.put(temp, false);\\n            }\\n            //add the currect to our stack \\n            stack.push(current);\\n            //mark it visited\\n            visited.put(current, true);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder(\"\");\\n        while(!stack.isEmpty()) {\\n            sb.append(stack.pop());\\n        }\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890096,
                "title": "javascript-solution-explained-97-speed",
                "content": "Build the new string res iterating through string s one letter at a time. At each letter in s, pop letters from the end of the being-built string res if the following conditions are true:\\n\\n1.  The letter at the end of res is lexicographically after the current s letter\\n2.  A letter count record which indicates the quantities of letters remaining in the unprocessed s (which is updated at each iteration in s), indicates the out-of-order letter at the end of res will be encountered again later in s\\n\\nThis allows for unique letters to stay in minimum lexiographical order as the string is being built.\\n\\n```\\nconst removeDuplicateLetters = s => {\\n    const n = s.length;\\n    if (n < 2) return s;                       //Blank or single letter-string\\n    const count = Array(26).fill(0);           //Counting all letters in s by index 0-25 -- tracks how many of each are remaining when building new string\\n    const used = Array(26);                    //Record which letters have been used when building the new string\\n\\n    for (let i = 0; i < n; i++)                //Count all letters in s by ASCII code offset from a\\'s code = 97\\n        count[s.charCodeAt(i) - 97]++;\\n\\n    const res = [];                            //Array of letters representing the new string\\n    for (let i = 0; i < n; i++) {\\n        const letter = s.charCodeAt(i) - 97;   //Iterating over all letters in string, reduce count\\n        count[letter]--;\\n        if (!used[letter]) {    //If letter is currently used in res, while the letter at the end of res is lexicographically after the current letter and the count record indicates that last character will be encountered later in the string, toggle the last letter to being unused and pop it from the string\\n            while ( res.length > 0 && res[res.length - 1].charCodeAt(0) - 97 > letter && count[res[res.length - 1].charCodeAt(0) - 97] > 0 ) {\\n                used[res[res.length - 1].charCodeAt(0) - 97] = false;\\n                res.pop();\\n            }\\n            res.push(s[i]);     //Add the current letter now that the lexicographically succeeding letters (which are present later in the string s) have been removed\\n        }\\n        used[letter] = true;    //Set the current letter\\'s used value to true\\n    }\\n    return res.join(\\'\\');        //Return the built new string\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst removeDuplicateLetters = s => {\\n    const n = s.length;\\n    if (n < 2) return s;                       //Blank or single letter-string\\n    const count = Array(26).fill(0);           //Counting all letters in s by index 0-25 -- tracks how many of each are remaining when building new string\\n    const used = Array(26);                    //Record which letters have been used when building the new string\\n\\n    for (let i = 0; i < n; i++)                //Count all letters in s by ASCII code offset from a\\'s code = 97\\n        count[s.charCodeAt(i) - 97]++;\\n\\n    const res = [];                            //Array of letters representing the new string\\n    for (let i = 0; i < n; i++) {\\n        const letter = s.charCodeAt(i) - 97;   //Iterating over all letters in string, reduce count\\n        count[letter]--;\\n        if (!used[letter]) {    //If letter is currently used in res, while the letter at the end of res is lexicographically after the current letter and the count record indicates that last character will be encountered later in the string, toggle the last letter to being unused and pop it from the string\\n            while ( res.length > 0 && res[res.length - 1].charCodeAt(0) - 97 > letter && count[res[res.length - 1].charCodeAt(0) - 97] > 0 ) {\\n                used[res[res.length - 1].charCodeAt(0) - 97] = false;\\n                res.pop();\\n            }\\n            res.push(s[i]);     //Add the current letter now that the lexicographically succeeding letters (which are present later in the string s) have been removed\\n        }\\n        used[letter] = true;    //Set the current letter\\'s used value to true\\n    }\\n    return res.join(\\'\\');        //Return the built new string\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 889982,
                "title": "greedy-but-for-a-reason-o-n-solution-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def removeDuplicateLetters(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        #purpose: to have as less characters as possible to return the characters subset lexicographically\\n        stack = []\\n        \\n        #purpose: to record if the character is seen earlier or not\\n        seen = set()\\n        \\n        #purpose: to record last index of each character\\n        last_occurrence = {}\\n        \\n        for i in range(len(s)):\\n            last_occurrence[s[i]] = i\\n            \\n        for index, character in enumerate(s):\\n            \\n            if character not in seen:\\n                \\n                #   if current character is not seen earleir:\\n                #   while the stack is not empty:\\n                #       a)compare current character with previous character on stack.\\n                #       b) if lexicographically less and the previous character has future occurences, pop the previous character from stack.\\n                #       c) delete the previous character from seen dict\\n                #\\n                #   add current character to seen\\n                #   append current character to stack\\n                #   return contents of stack as result\\n                while stack and character < stack[-1] and index < last_occurrence[stack[-1]]:\\n                    seen.discard(stack.pop())\\n                seen.add(character)\\n                stack.append(character)\\n        \\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeDuplicateLetters(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        #purpose: to have as less characters as possible to return the characters subset lexicographically\\n        stack = []\\n        \\n        #purpose: to record if the character is seen earlier or not\\n        seen = set()\\n        \\n        #purpose: to record last index of each character\\n        last_occurrence = {}\\n        \\n        for i in range(len(s)):\\n            last_occurrence[s[i]] = i\\n            \\n        for index, character in enumerate(s):\\n            \\n            if character not in seen:\\n                \\n                #   if current character is not seen earleir:\\n                #   while the stack is not empty:\\n                #       a)compare current character with previous character on stack.\\n                #       b) if lexicographically less and the previous character has future occurences, pop the previous character from stack.\\n                #       c) delete the previous character from seen dict\\n                #\\n                #   add current character to seen\\n                #   append current character to stack\\n                #   return contents of stack as result\\n                while stack and character < stack[-1] and index < last_occurrence[stack[-1]]:\\n                    seen.discard(stack.pop())\\n                seen.add(character)\\n                stack.append(character)\\n        \\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889521,
                "title": "c-remove-duplicate-letters-two-approaches",
                "content": "## O(nlogn) \\n#### Constructing result string by choosing suitable element\\n\\n```\\nstring removeDuplicateLetters(string s) {\\n        unordered_map<char, vector<int> > umap;\\n        vector<bool> valid(26, false);\\n        string res = \"\";\\n\\n        for(int i=0; i<s.length(); i++){\\n            umap[s[i]].push_back(i);\\n            valid[s[i]-\\'a\\'] = true;\\n        }\\n\\n        int distinctCount = umap.size();\\n        int curIndex = 0;\\n\\n        while(distinctCount--){\\n            for(char ch=\\'a\\'; ch<=\\'z\\'; ch++) {\\n\\t\\t\\t    // check character validity smaller -> bigger\\n                if(valid[ch-\\'a\\']) {\\n                    bool flag = true;\\n                    int index = lower_bound(umap[ch].begin(), umap[ch].end(), \\\\\\n                                            curIndex) - umap[ch].begin();\\n\\t\\t\\t\\t\\t// check if all remaining characters appear atleast once if current character is choosen\\n                    for(char ch2=\\'a\\'; ch2<=\\'z\\'; ch2++) { \\n                        if(not valid[ch2-\\'a\\'] or ch == ch2)   continue;\\n                        if(upper_bound(umap[ch2].begin(), umap[ch2].end(), \\\\\\n                                       umap[ch][index]) - umap[ch2].begin() == umap[ch2].size()) {\\n                            flag = false;\\n                            break;\\n                        }\\n                    }\\n\\n                    if(flag) {\\n                        valid[ch-\\'a\\'] = false;\\n                        res += ch;\\n                        curIndex = umap[ch][index];\\n                        umap.erase(ch);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n## O(n)\\n#### Greedy Approach\\n```\\nstring removeDuplicateLetters(string s) {\\n        string res = \"\";\\n        vector<bool> visited(26, false);\\n        vector<int> dict(26, 0);\\n\\n        for(auto it: s)     dict[it-\\'a\\'] ++;\\n\\n        for(int i=0; i<s.length(); i++) {\\n            dict[s[i]-\\'a\\'] --;\\n            if(visited[s[i]-\\'a\\']) continue;\\n            while ( res.size() and res.back() > s[i] and dict[res.back() -\\'a\\'] ) {\\n                visited[res.back()-\\'a\\'] = false;\\n                res.pop_back();\\n            }\\n            res += s[i];\\n            visited[s[i]-\\'a\\'] = true;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstring removeDuplicateLetters(string s) {\\n        unordered_map<char, vector<int> > umap;\\n        vector<bool> valid(26, false);\\n        string res = \"\";\\n\\n        for(int i=0; i<s.length(); i++){\\n            umap[s[i]].push_back(i);\\n            valid[s[i]-\\'a\\'] = true;\\n        }\\n\\n        int distinctCount = umap.size();\\n        int curIndex = 0;\\n\\n        while(distinctCount--){\\n            for(char ch=\\'a\\'; ch<=\\'z\\'; ch++) {\\n\\t\\t\\t    // check character validity smaller -> bigger\\n                if(valid[ch-\\'a\\']) {\\n                    bool flag = true;\\n                    int index = lower_bound(umap[ch].begin(), umap[ch].end(), \\\\\\n                                            curIndex) - umap[ch].begin();\\n\\t\\t\\t\\t\\t// check if all remaining characters appear atleast once if current character is choosen\\n                    for(char ch2=\\'a\\'; ch2<=\\'z\\'; ch2++) { \\n                        if(not valid[ch2-\\'a\\'] or ch == ch2)   continue;\\n                        if(upper_bound(umap[ch2].begin(), umap[ch2].end(), \\\\\\n                                       umap[ch][index]) - umap[ch2].begin() == umap[ch2].size()) {\\n                            flag = false;\\n                            break;\\n                        }\\n                    }\\n\\n                    if(flag) {\\n                        valid[ch-\\'a\\'] = false;\\n                        res += ch;\\n                        curIndex = umap[ch][index];\\n                        umap.erase(ch);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\nstring removeDuplicateLetters(string s) {\\n        string res = \"\";\\n        vector<bool> visited(26, false);\\n        vector<int> dict(26, 0);\\n\\n        for(auto it: s)     dict[it-\\'a\\'] ++;\\n\\n        for(int i=0; i<s.length(); i++) {\\n            dict[s[i]-\\'a\\'] --;\\n            if(visited[s[i]-\\'a\\']) continue;\\n            while ( res.size() and res.back() > s[i] and dict[res.back() -\\'a\\'] ) {\\n                visited[res.back()-\\'a\\'] = false;\\n                res.pop_back();\\n            }\\n            res += s[i];\\n            visited[s[i]-\\'a\\'] = true;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308977,
                "title": "python-stack-solution-with-explanation",
                "content": "The solution is exactly the same as for [1081. Smallest Subsequence of Distinct Characters ](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/discuss/308923/Python-stack-solution)\\n\\nSave the temporary result into a stack.\\nThe stack properties:\\n(1) stack can be splitted to several segments\\n(2) for each segment, the characters are lexicographically increasing\\n(3) except the last segment, the last character doesn\\'t appear in the future\\n\\n```\\n    def smallestSubsequence(self, text: str) -> str:\\n        rindex = {c: i for i, c in enumerate(text)}\\n        stack = []\\n        for i, c in enumerate(text):\\n            if c not in stack:\\n                while stack and c < stack[-1] and i < rindex[stack[-1]]:\\n                    stack.pop()\\n                stack.append(c)\\n\\t\\t\\t# else: c exists in stack\\n\\t\\t\\t# if stack[-1] == c: don\\'t need to need to delete stack[-1] and append c\\n\\t\\t\\t# if stack[j] == c and j < len(stack) - 1: because of the stack properties, \\n\\t\\t\\t# the stack is lexicographically smaller than the new one after deleting stack[j] and appending c\\n        return \\'\\'.join(stack)\\n```\\n\\n```\\n    def smallestSubsequence(self, text: str) -> str:\\n        count, used = 26 * [0], 26 * [0]\\n        for c in text:\\n            count[ord(c) - ord(\\'a\\')] += 1\\n        stack = []\\n        for c in text:\\n            count[ord(c) - ord(\\'a\\')] -= 1\\n            if used[ord(c) - ord(\\'a\\')] == 0:\\n                while stack and c < stack[-1] and count[ord(stack[-1]) - ord(\\'a\\')]:\\n                    used[ord(stack[-1]) - ord(\\'a\\')] = 0\\n                    stack.pop()\\n                stack.append(c)\\n                used[ord(c) - ord(\\'a\\')] = 1\\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [],
                "code": "```\\n    def smallestSubsequence(self, text: str) -> str:\\n        rindex = {c: i for i, c in enumerate(text)}\\n        stack = []\\n        for i, c in enumerate(text):\\n            if c not in stack:\\n                while stack and c < stack[-1] and i < rindex[stack[-1]]:\\n                    stack.pop()\\n                stack.append(c)\\n\\t\\t\\t# else: c exists in stack\\n\\t\\t\\t# if stack[-1] == c: don\\'t need to need to delete stack[-1] and append c\\n\\t\\t\\t# if stack[j] == c and j < len(stack) - 1: because of the stack properties, \\n\\t\\t\\t# the stack is lexicographically smaller than the new one after deleting stack[j] and appending c\\n        return \\'\\'.join(stack)\\n```\n```\\n    def smallestSubsequence(self, text: str) -> str:\\n        count, used = 26 * [0], 26 * [0]\\n        for c in text:\\n            count[ord(c) - ord(\\'a\\')] += 1\\n        stack = []\\n        for c in text:\\n            count[ord(c) - ord(\\'a\\')] -= 1\\n            if used[ord(c) - ord(\\'a\\')] == 0:\\n                while stack and c < stack[-1] and count[ord(stack[-1]) - ord(\\'a\\')]:\\n                    used[ord(stack[-1]) - ord(\\'a\\')] = 0\\n                    stack.pop()\\n                stack.append(c)\\n                used[ord(c) - ord(\\'a\\')] = 1\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 76849,
                "title": "java-easy-understanding-solution-9ms-greedy-with-deque",
                "content": "Greedy algorithm with deque. \\n\\nWe always want the smaller character appears before the bigger character. \\n\\nFor example, \"cbacdcbc\", when we traverse through the string, the first one is c, we store it, because we don't know whether the latter character is bigger than c or not.  [result = \"c\"]\\n\\nWhen go to b, we know c will appear in latter part, so we discard the first c. [result = \"b\"]\\n\\nNow a, cause a is less than b, b will appear in latter part, so we discard b, and then store a. [result =\"a\"]\\n\\nNow c, c is bigger than a, we store it. Now d, same reason, c is bigger than c store it.[result = \"acd\"]\\n\\nNow c again, we already has c, so ignore it. Now b, we compare b with d, because d won't appear latter, so we store b. [result = \"acdb\"]\\n\\nUse a stack or deque to imitate the process until finish traversing the string.\\n\\nTraverse the string to get the appearance times of each character. And then traverse through the string to decide whether to store current character or not.\\n\\n 1.If the deque is empty, add current character\\n\\n 2.Otherwise, check the last element t of the deque with current character c, if c is less than t and\\nt will appear in latter string, poll out t. Continue this process until there is no t meet the requirement, then add c into the deque.\\n\\n    public String removeDuplicateLetters(String s) {\\n\\t\\tif(s.length() == 0)return \"\";\\n\\t\\tint[] count = new int[26];\\n\\t\\tfor(int i =0;i<s.length();i++)\\n\\t\\t{\\n\\t\\t\\tcount[s.charAt(i)-'a']++;\\n\\t\\t}\\n\\t\\tString res = \"\";\\n\\t\\tDeque<Character> deque = new ArrayDeque<Character>();\\n\\n\\t\\tfor(int i = 0; i<s.length();i++)\\n\\t\\t{\\n\\t\\t\\tif(deque.isEmpty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tdeque.addLast(s.charAt(i));\\n\\t\\t\\t}\\n\\t\\t\\telse if(!deque.contains(s.charAt(i)))\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar t = deque.peekLast();\\n\\t\\t\\t\\twhile(s.charAt(i)<t && count[t-'a']>0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tt = deque.pollLast();\\n\\t\\t\\t\\t\\tif(deque.isEmpty())break;\\n\\t\\t\\t\\t\\tt = deque.peekLast();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdeque.addLast(s.charAt(i));\\n\\t\\t\\t}\\n\\t\\t\\tcount[s.charAt(i)-'a']--;\\t\\t\\t\\n\\t\\t}\\n\\t\\tint size = deque.size();\\n\\t\\tfor(int i = 0; i<size;i++)\\n\\t\\t{\\n\\t\\t\\tres += String.valueOf(deque.pollFirst());\\n\\t\\t}\\n\\t\\treturn res;\\n  }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Greedy algorithm with deque. \\n\\nWe always want the smaller character appears before the bigger character. \\n\\nFor example, \"cbacdcbc\", when we traverse through the string, the first one is c, we store it, because we don't know whether the latter character is bigger than c or not.  [result = \"c\"]\\n\\nWhen go to b, we know c will appear in latter part, so we discard the first c. [result = \"b\"]\\n\\nNow a, cause a is less than b, b will appear in latter part, so we discard b, and then store a. [result =\"a\"]\\n\\nNow c, c is bigger than a, we store it. Now d, same reason, c is bigger than c store it.[result = \"acd\"]\\n\\nNow c again, we already has c, so ignore it. Now b, we compare b with d, because d won't appear latter, so we store b. [result = \"acdb\"]\\n\\nUse a stack or deque to imitate the process until finish traversing the string.\\n\\nTraverse the string to get the appearance times of each character. And then traverse through the string to decide whether to store current character or not.\\n\\n 1.If the deque is empty, add current character\\n\\n 2.Otherwise, check the last element t of the deque with current character c, if c is less than t and\\nt will appear in latter string, poll out t. Continue this process until there is no t meet the requirement, then add c into the deque.\\n\\n    public String removeDuplicateLetters(String s) {\\n\\t\\tif(s.length() == 0)return \"\";\\n\\t\\tint[] count = new int[26];\\n\\t\\tfor(int i =0;i<s.length();i++)\\n\\t\\t{\\n\\t\\t\\tcount[s.charAt(i)-'a']++;\\n\\t\\t}\\n\\t\\tString res = \"\";\\n\\t\\tDeque<Character> deque = new ArrayDeque<Character>();\\n\\n\\t\\tfor(int i = 0; i<s.length();i++)\\n\\t\\t{\\n\\t\\t\\tif(deque.isEmpty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tdeque.addLast(s.charAt(i));\\n\\t\\t\\t}\\n\\t\\t\\telse if(!deque.contains(s.charAt(i)))\\n\\t\\t\\t{\\n\\t\\t\\t\\tchar t = deque.peekLast();\\n\\t\\t\\t\\twhile(s.charAt(i)<t && count[t-'a']>0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tt = deque.pollLast();\\n\\t\\t\\t\\t\\tif(deque.isEmpty())break;\\n\\t\\t\\t\\t\\tt = deque.peekLast();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdeque.addLast(s.charAt(i));\\n\\t\\t\\t}\\n\\t\\t\\tcount[s.charAt(i)-'a']--;\\t\\t\\t\\n\\t\\t}\\n\\t\\tint size = deque.size();\\n\\t\\tfor(int i = 0; i<size;i++)\\n\\t\\t{\\n\\t\\t\\tres += String.valueOf(deque.pollFirst());\\n\\t\\t}\\n\\t\\treturn res;\\n  }",
                "codeTag": "Unknown"
            },
            {
                "id": 76820,
                "title": "easy-understanding-10m-stack-java-solution",
                "content": "    public class Solution {\\n       \\n        public static String removeDuplicateLetters(String s) {\\n            if (s == null || s.length() == 0){\\n                return \"\";\\n            }\\n            int[] dict = new int[26];\\n            // initialize\\n            for(int i = 0; i < s.length(); i ++){\\n                dict[s.charAt(i)-'a'] += 1;\\n            }\\n            Stack<Character> stack = new Stack<Character>();\\n            int i = 0;\\n            \\n            // maintain the sequence, if the next character is better, push it into stack\\n            while(i < s.length()){\\n                char current = s.charAt(i);\\n                int index = current - 'a';\\n                // only take care of new characters that are not in the stack\\n                if(!stack.contains(current)) {\\n                    while (!stack.isEmpty() && current <= stack.peek() && dict[stack.peek()-'a'] >= 1){\\n                        stack.pop();\\n                    }\\n                    if(!stack.contains(current)) {\\n                        stack.push(current);\\n                    }\\n                }\\n                dict[index]--;\\n                i++;\\n            }\\n            \\n            // convert stack to result\\n            StringBuilder result = new StringBuilder();\\n            while(!stack.isEmpty()){\\n                result.append(stack.pop());\\n            }\\n            return result.reverse().toString();\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n       \\n        public static String removeDuplicateLetters(String s) {\\n            if (s == null || s.length() == 0){\\n                return \"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4091800,
                "title": "easy-c-solution-using-stack",
                "content": "# **PLEASE UPVOTE MY SOLUTION IF YOU LIKE IT**\\n# **CONNECT WITH ME**\\n### **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n#### **[https://www.instagram.com/pratay_nandy/]()**\\n\\n# Approach\\nThe provided C++ code is an implementation of the \"Remove Duplicate Letters\" problem. The goal of this problem is to remove duplicate letters from a given string while maintaining the lexicographical order of the remaining letters.\\n\\nHere\\'s an explanation of the approach:\\n\\n- Create a stack st to store characters as you iterate through the input string s.\\n\\n- Create two vectors:\\n\\n1. `lastindex`: It stores the last index where each character appears in the string s. This information helps in deciding when to remove characters from the stack.\\n2. `seen`: It tracks whether a character has been added to the stack or not to avoid duplicates.\\n- Iterate through the string s to populate the lastindex vector. For each character, update its corresponding index in the lastindex vector.\\n\\nIterate through the string s again:\\n\\n- For each character `s[i]`, check if it has already been seen (i.e., if `seen[curr]` is true). If it has been seen, skip it.\\nIf it hasn\\'t been seen:\\n- While the stack is not empty, the character at the top of the stack `(st.top())` is greater than the current character `s[i]`, and there\\'s still a remaining occurrence of the character after the current index (i.e., `i < lastindex[st.top()-\\'a\\'])`, pop characters from the stack and mark them as unseen `(seen[st.top() - \\'a\\'] = false)` to ensure that the smaller characters appear later.\\n- Push the current character`s[i]` onto the stack and mark it as seen (`seen[curr] = true`).\\n- After processing all characters in the input string, the stack `st` contains the characters to keep in the lexicographical order.\\n\\n- Build the result string `res` by popping characters from the stack and reversing it (since the characters were pushed onto the stack in reverse order).\\n\\n- Return the result string as the final answer.\\n\\nThis approach ensures that the characters in the result string are in lexicographical order, and duplicates are removed. The order is preserved by considering the last index of each character and removing characters from the stack when necessary.\\n![upvote.png](https://assets.leetcode.com/users/images/36c703a7-d938-475c-9b56-ea082c1c81d7_1695715236.309361.png)\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: --> \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        stack<char>st;\\n        vector<int>lastindex(26,0);\\n        vector<bool>seen(26,false);\\n        for(int i = 0 ;i<s.size();i++)\\n        {\\n            lastindex[s[i] - \\'a\\'] = i; \\n        }\\n        for(int i = 0 ;i<s.size();i++)\\n        {\\n            int curr = s[i] - \\'a\\'; \\n            if(seen[curr])\\n            {\\n                continue;\\n            }\\n            while(st.size() > 0 && st.top() > s[i] && i < lastindex[st.top()-\\'a\\'])\\n            {\\n                seen[st.top() - \\'a\\'] = false;\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n            seen[curr] = true;  \\n        }\\n        string res= \"\";\\n        while(st.size() > 0)\\n        {\\n            res += st.top();\\n            st.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        stack<char>st;\\n        vector<int>lastindex(26,0);\\n        vector<bool>seen(26,false);\\n        for(int i = 0 ;i<s.size();i++)\\n        {\\n            lastindex[s[i] - \\'a\\'] = i; \\n        }\\n        for(int i = 0 ;i<s.size();i++)\\n        {\\n            int curr = s[i] - \\'a\\'; \\n            if(seen[curr])\\n            {\\n                continue;\\n            }\\n            while(st.size() > 0 && st.top() > s[i] && i < lastindex[st.top()-\\'a\\'])\\n            {\\n                seen[st.top() - \\'a\\'] = false;\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n            seen[curr] = true;  \\n        }\\n        string res= \"\";\\n        while(st.size() > 0)\\n        {\\n            res += st.top();\\n            st.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091517,
                "title": "potd-with-100-optimisation-with-100-runtime-and-memory-acceptance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to remove duplicate letters from the input string while ensuring that the result is in lexicographically smallest order. To achieve this, we can use a stack to maintain characters and their order. We need to keep track of the last occurrence of each character to make sure we are removing characters correctly.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a stack (st) to store characters, two vectors (last_occurrence and used) to keep track of the last occurrence of each character and whether a character is already in the result, respectively.\\n\\n2. Iterate through the input string s:\\n   - For each character currChar, check if it has not been used (used[currChar - \\'a\\'] is false).\\n   - If it has not been used:\\n   - While the stack is not empty, the current character currChar is smaller than the character at the top of the stack (st.top()), and there are more occurrences of the character at the top of the stack later in the string, pop characters from the stack and mark them as unused.\\n    - Push the current character onto the stack and mark it as used.\\n3. After processing the entire input string, create a result string of the same size as the stack (st.size()) and construct it in reverse order by popping characters from the stack.\\n\\n4. Return the result string, which contains the lexicographically smallest string without duplicate letters.\\n# Complexity\\n1. Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    - The code iterates through the input string s twice, once for calculating the last occurrence of each character and once for processing the string with the stack.\\n    - Both iterations have a time complexity of O(N), where N is the length of the input string s.\\n    - The final construction of the result string from the stack also takes O(N) time.\\n    - Thus, the overall time complexity is O(N).\\n2. Space complexity:\\n    - The additional space used is mainly for the stack, which can have at most N characters, where N is the length of the input string s.\\n    - The last_occurrence and used vectors each have a constant size of 26 (for the English alphabet).\\n    - The result string also takes O(N) space.\\n    - Therefore, the overall space complexity is O(N).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> last_occurrence(26, -1);\\n        vector<bool> used(26, false);\\n        stack<char> st;\\n\\n        // Calculate the last occurrence of each character in the string\\n        for (int i = 0; i < s.size(); ++i) {\\n            last_occurrence[s[i] - \\'a\\'] = i;\\n        }\\n\\n        for (int i = 0; i < s.size(); ++i) {\\n            char currChar = s[i];\\n\\n            if (!used[currChar - \\'a\\']) {\\n                while (!st.empty() && currChar < st.top() && last_occurrence[st.top() - \\'a\\'] > i) {\\n                    used[st.top() - \\'a\\'] = false;\\n                    st.pop();\\n                }\\n\\n                st.push(currChar);\\n                used[currChar - \\'a\\'] = true;\\n            }\\n        }\\n\\n        string result(st.size(), \\' \\');\\n\\n        // Construct the result string in reverse order from the stack\\n        for (int i = st.size() - 1; i >= 0; --i) {\\n            result[i] = st.top();\\n            st.pop();\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "TypeScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> last_occurrence(26, -1);\\n        vector<bool> used(26, false);\\n        stack<char> st;\\n\\n        // Calculate the last occurrence of each character in the string\\n        for (int i = 0; i < s.size(); ++i) {\\n            last_occurrence[s[i] - \\'a\\'] = i;\\n        }\\n\\n        for (int i = 0; i < s.size(); ++i) {\\n            char currChar = s[i];\\n\\n            if (!used[currChar - \\'a\\']) {\\n                while (!st.empty() && currChar < st.top() && last_occurrence[st.top() - \\'a\\'] > i) {\\n                    used[st.top() - \\'a\\'] = false;\\n                    st.pop();\\n                }\\n\\n                st.push(currChar);\\n                used[currChar - \\'a\\'] = true;\\n            }\\n        }\\n\\n        string result(st.size(), \\' \\');\\n\\n        // Construct the result string in reverse order from the stack\\n        for (int i = st.size() - 1; i >= 0; --i) {\\n            result[i] = st.top();\\n            st.pop();\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091325,
                "title": "c-solution-by-using-set",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<char> st;\\n        int n = s.size();\\n        unordered_set<char> seen; // To keep track of characters already added to \\'st\\'.\\n\\n        for (int i = 0; i < n; i++) {\\n            if (seen.find(s[i]) == seen.end()) {\\n                // If the character is not in \\'st\\', and it hasn\\'t been seen before,\\n                // add it to \\'st\\'.\\n                while (!st.empty() && s[i] < st.back() && s.find(st.back(), i) != string::npos) {\\n                    // Pop characters from \\'st\\' if they are greater than the current character\\n                    // and still occur later in the string.\\n                    seen.erase(st.back());\\n                    st.pop_back();\\n                }\\n                st.push_back(s[i]);\\n                seen.insert(s[i]);\\n            }\\n        }\\n\\n        return string(st.begin(), st.end());\\n    }\\n};\\n",
                "solutionTags": [
                    "String",
                    "Ordered Set"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090908,
                "title": "java-stack-o-n-time-o-1-space-explanation-easy-to-understand",
                "content": "# Remove Duplicate Letters\\n\\n![Screenshot 2023-09-26 081620.jpg](https://assets.leetcode.com/users/images/934736aa-7b0b-4cfd-973b-c6fdf6f20e24_1695696421.460025.jpeg)\\n\\n## Intuition\\nThe problem requires removing duplicate letters from a string while ensuring that the result is the smallest in lexicographical order. To solve this, we can use a stack to keep track of characters. We iterate through the string, and for each character, we check if it\\'s already seen. If it is, we skip it as we can choose each character only once. If it\\'s not seen, we compare it with the characters in the stack. We pop characters from the stack that are greater than the current character and still have remaining occurrences in the string. Finally, we add the current character to the stack.\\n\\n## Approach\\n1. Initialize an array `lastIndex` to track the last index of character presence in the string.\\n2. Initialize a boolean array `seen` to keep track of seen characters.\\n3. Initialize a stack `stack` to store characters.\\n4. Iterate through the string `s`:\\n   - Get the current character\\'s index.\\n   - If the character is already seen, continue to the next character.\\n   - While the stack is not empty, the current character is smaller than the top of the stack, and the top character still occurs later in the string, pop characters from the stack, mark them as unseen, and remove them from the stack.\\n   - Push the current character onto the stack and mark it as seen.\\n5. Build the result string by popping characters from the stack.\\n6. Reverse the result string to get the lexicographically smallest result.\\n\\n## Complexity Analysis\\n- Time Complexity: O(N), where N is the length of the input string `s`.\\n- Space Complexity: O(1) since the maximum size of the stack and arrays is constant (26 characters).\\n\\nWatch the step-by-step explanation and implementation on YouTube:\\n\\n[https://youtu.be/AAVBre45pF0]()\\n\\nFeel free to like, share, and subscribe!\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        int[] lastIndex = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            lastIndex[s.charAt(i) - \\'a\\'] = i; \\n        }\\n\\n        boolean[] seen = new boolean[26]; \\n        Stack<Integer> stack = new Stack<>();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            int currentChar = s.charAt(i) - \\'a\\';\\n            if (seen[currentChar]) continue; \\n                while (!stack.isEmpty() && stack.peek() > currentChar && i < lastIndex[stack.peek()]) {\\n                seen[stack.pop()] = false;\\n            }\\n            \\n            stack.push(currentChar); \\n            seen[currentChar] = true;\\n        }\\n        StringBuilder result = new StringBuilder();\\n        while (!stack.isEmpty()) {\\n            result.append((char) (stack.pop() + \\'a\\'));\\n        }\\n        return result.reverse().toString();\\n    }\\n}\\n\\n```\\n\\n\\nHappy Coding!",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        int[] lastIndex = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            lastIndex[s.charAt(i) - \\'a\\'] = i; \\n        }\\n\\n        boolean[] seen = new boolean[26]; \\n        Stack<Integer> stack = new Stack<>();\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            int currentChar = s.charAt(i) - \\'a\\';\\n            if (seen[currentChar]) continue; \\n                while (!stack.isEmpty() && stack.peek() > currentChar && i < lastIndex[stack.peek()]) {\\n                seen[stack.pop()] = false;\\n            }\\n            \\n            stack.push(currentChar); \\n            seen[currentChar] = true;\\n        }\\n        StringBuilder result = new StringBuilder();\\n        while (!stack.isEmpty()) {\\n            result.append((char) (stack.pop() + \\'a\\'));\\n        }\\n        return result.reverse().toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437254,
                "title": "best-handwritten-explanation-you-will-come-across-fully-commented",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/57b0a8cf-e3b3-4fdf-8943-356c302c4410_1681974812.0590713.png)\\n![image.png](https://assets.leetcode.com/users/images/825c2331-a215-4f9b-8f6b-c7c5fe944d25_1681974825.945163.png)\\n![image.png](https://assets.leetcode.com/users/images/e7d295c3-d44f-4b2e-9ceb-b6bba4ba3a15_1681974877.362605.png)\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) \\n    {\\n        string ans=\"\";\\n        unordered_map<char,int>map;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            map[s[i]]=max(i,map[s[i]]);\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch=s[i];\\n            if(ans.find(ch)!=string::npos)\\n                continue;\\n            while(ans.length()>0 && ans[ans.length()-1]>ch && map[ans[ans.length()-1]]>i)\\n            {\\n                // cout<<ans[ans.length()-1]<<\" \"<<ch<<endl;\\n                ans.pop_back();\\n            }\\n            ans+=ch;   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) \\n    {\\n        string ans=\"\";\\n        unordered_map<char,int>map;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            map[s[i]]=max(i,map[s[i]]);\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch=s[i];\\n            if(ans.find(ch)!=string::npos)\\n                continue;\\n            while(ans.length()>0 && ans[ans.length()-1]>ch && map[ans[ans.length()-1]]>i)\\n            {\\n                // cout<<ans[ans.length()-1]<<\" \"<<ch<<endl;\\n                ans.pop_back();\\n            }\\n            ans+=ch;   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2323865,
                "title": "c-intuition-explained",
                "content": "```\\n\\n\\n\\nFirst we put character c into our stack and mark it as true\\n\\nThen we come to next character i.e. b we check is b < c to maintain lexicographically order. Yes b is samller then c we\\'ll remove it from the stack.\\n\\nBut before removing we have to check that, is c more present in our string. So, how will we quickly check that for that we\\'ll keep one more Array which will keep track of last index of all the character\\'s present in our string\\n\\nSo, we see that c exists on 7th index.\\n\\nWe\\'ll remove c from the stack & don\\'t forgot to mark c in boolean array from true to false\\n\\nNow add b into our stack. ANd mark b in boolean array as true\\n\\nNow next character is a which is smaller then b & do the same process of checking if it exists somewhere in array & if so, remove it from stack update boolean to false. And put a into the stack. And in boolean array mark it as true.\\n\\nLet\\'s add c in the stack mark it as true & c > a so carry on.\\n\\n```\\n\\n```\\n\\nWhat we\\'ll do, use the stack to keep track of selected character\\'s. We try to put the character\\'s only once & maintain the lexicographicall smallest one. So, how we do that :-\\n\\nIf the stack is empty, we\\'ll put the current character into our stack\\nWe\\'ll also keep here boolean array which will mark, whether we have seen this character or not. So, that if we are getting again the same character and we have already seen that. We\\'ll ignore that character.\\nSo, the length of boolean array will be 26\\n\\n\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n    vector<int> lastindex(26,0);;\\n        for(int i=0;i<s.size();i++){\\n            lastindex[s[i]-\\'a\\']=i;\\n        }\\n        \\n        \\n        \\n        \\n        vector<bool> seen(26,false);\\n        stack<char> st;\\n        \\n        \\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            int curr=s[i]-\\'a\\';\\n        if(seen[curr])continue;\\n            while(st.size()>0&&st.top()>s[i]&&i<lastindex[st.top()-\\'a\\']){\\n                seen[st.top()-\\'a\\']=false;\\n                st.pop();\\n                \\n            }\\n            st.push(s[i]);\\n            seen[curr]=true;\\n        } \\n          string ans=\"\";\\n          while(st.size()!=0){\\n              ans+=st.top();\\n              st.pop();\\n          }  \\n        reverse(ans.begin(),ans.end());\\n            return ans;\\n        }\\n        \\n    \\n    \\n    \\n};\\n\\n```\\n\\n\\n        \\n       \\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n\\n\\nFirst we put character c into our stack and mark it as true\\n\\nThen we come to next character i.e. b we check is b < c to maintain lexicographically order. Yes b is samller then c we\\'ll remove it from the stack.\\n\\nBut before removing we have to check that, is c more present in our string. So, how will we quickly check that for that we\\'ll keep one more Array which will keep track of last index of all the character\\'s present in our string\\n\\nSo, we see that c exists on 7th index.\\n\\nWe\\'ll remove c from the stack & don\\'t forgot to mark c in boolean array from true to false\\n\\nNow add b into our stack. ANd mark b in boolean array as true\\n\\nNow next character is a which is smaller then b & do the same process of checking if it exists somewhere in array & if so, remove it from stack update boolean to false. And put a into the stack. And in boolean array mark it as true.\\n\\nLet\\'s add c in the stack mark it as true & c > a so carry on.\\n\\n```\n```\\n\\nWhat we\\'ll do, use the stack to keep track of selected character\\'s. We try to put the character\\'s only once & maintain the lexicographicall smallest one. So, how we do that :-\\n\\nIf the stack is empty, we\\'ll put the current character into our stack\\nWe\\'ll also keep here boolean array which will mark, whether we have seen this character or not. So, that if we are getting again the same character and we have already seen that. We\\'ll ignore that character.\\nSo, the length of boolean array will be 26\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n    vector<int> lastindex(26,0);;\\n        for(int i=0;i<s.size();i++){\\n            lastindex[s[i]-\\'a\\']=i;\\n        }\\n        \\n        \\n        \\n        \\n        vector<bool> seen(26,false);\\n        stack<char> st;\\n        \\n        \\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            int curr=s[i]-\\'a\\';\\n        if(seen[curr])continue;\\n            while(st.size()>0&&st.top()>s[i]&&i<lastindex[st.top()-\\'a\\']){\\n                seen[st.top()-\\'a\\']=false;\\n                st.pop();\\n                \\n            }\\n            st.push(s[i]);\\n            seen[curr]=true;\\n        } \\n          string ans=\"\";\\n          while(st.size()!=0){\\n              ans+=st.top();\\n              st.pop();\\n          }  \\n        reverse(ans.begin(),ans.end());\\n            return ans;\\n        }\\n        \\n    \\n    \\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861409,
                "title": "c-easy-to-understand-solution-100-faster-than-other-c-solutions",
                "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int c[26]={0};\\n        int vis[26]={0};\\n        stack<char>st;\\n        for(int i=0;i<s.size();i++){\\n            c[s[i]-97]++;\\n        }\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(vis[s[i]-97]==0){\\n                vis[s[i]-97]=1;\\n                c[s[i]-97]--;\\n                if(st.empty())\\n                    st.push(s[i]); \\n                else{\\n                    while(st.empty()==false && st.top()>s[i] && c[st.top()-97]>0 )\\n                    {   vis[st.top()-97]=0; st.pop(); }\\n                        \\n                        st.push(s[i]);\\n                } \\n            }\\n            else \\n                c[s[i]-97]--;\\n        }\\n        string ans; \\n        while(st.empty()==false){\\n            ans.push_back(st.top()); \\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end()); \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int c[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 1861011,
                "title": "c-code-with-explanation-why-use-stack",
                "content": "**Brief Overview:**\\nThe aim is to find the lexicographically shortest subsequence having distinct letters.\\nThere would exist various permutations of subsequences that would have distinct letters. For instance if the String is \"bcabc\" , following are the subsequences possible:  { \"bca\" , \"cab\" , \"bac\" ,\"abc\" }, out of which lexicographically smallest is \"abc\" which is the answer.\\n\\n**How to Approach:**\\n\\n**Brute Force:**\\nIn a Brute force Approach, we can use a Hashmap/Dictionary to map all the characters to all the indices and then generate all the possible subsequence permutations. Although this would give the correct answer, Computation would be very costly as generating and checking for every subsequence will take up factorial time complexity.\\n\\n**How to Optimize:**\\nThe challenge is to think of a data structure or algorithm which can reduce the time complexity.\\nFirst, we have to pick the characters if they are not already visited(to main distinctiveness). If that\\'s the case, we\\'ll try to pick these characters. We\\'ll also make sure the previously picked character is smaller then the current character to maintain lexicographical order. To implement this we will use a **Stack!!**\\nAs a general rule of thumb, a Stack data structure should be used to keep track of comparison among previously chosen/ next chosen elements.\\n\\n**How to Implement:**\\nWe use the visited to keep track of selected characters.\\nWe will loop through all characters of the string and take the following actions: \\n* If the stack is empty, we\\'ll put the current character into our stack.\\n* We\\'ll also keep here boolean array which will mark whether we have seen this character or not. So, if we are getting the same character again and we have already seen that. We\\'ll ignore that character.\\n* For every character, we will see if some greater characters are present in the stack, which can also be used later. As far as possible, we will make use of greater characters that are present farthest in the string. (How to do this is explained in the comments of the code).\\n\\n**Code (with comments) :**\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int n=s.size();\\n        vector<bool> vis(26,0); // keeping track of visited letters\\n        vector<int> lastInd(26,-1); // The last occurence of letter in the string\\n        for(int i=0;i<n;i++){\\n            lastInd[s[i]-\\'a\\']=i;\\n        }\\n        stack<char> st;     \\n        for(int i=0;i<n;i++){\\n            if(!vis[s[i]-\\'a\\']){\\n                vis[s[i]-\\'a\\']=1;\\n                // Checking only if letter not visited previously\\n                // Once we meet this condition we are sure to push \\n                // this character into the stack, before that \\n                // we will check stack\\'s surrent status and check for   \\n                // any elements that can be removed. \\n                while(!st.empty() && lastInd[st.top()-\\'a\\']>i && st.top()>s[i]){\\n                    // If a greater letter is present again in the string \\n                    //at  a a later index,lets use that index to use this character\\n                    // , so for now we keep it out of stack and make it unvisited \\n                    // to be able to be used later.\\n                    vis[st.top()-\\'a\\']=0;\\n                    st.pop();\\n                }\\n                st.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        // Pour out all the stack contents into a string and reverse it.\\n        while(!st.empty()){\\n            char c=st.top();\\n            st.pop();\\n            ans+=c;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\n**Complexity Analysis :**\\nTime: **O(N)** (one pass through the string every time, no nested loops)\\nSpace: **O(N)** (lastInd array of size n, visited boolean array of size n, stack size)\\n\\nComment down below, If you have any queries or suggestions :)\\nBest Wishes, \\nAnurag",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int n=s.size();\\n        vector<bool> vis(26,0); // keeping track of visited letters\\n        vector<int> lastInd(26,-1); // The last occurence of letter in the string\\n        for(int i=0;i<n;i++){\\n            lastInd[s[i]-\\'a\\']=i;\\n        }\\n        stack<char> st;     \\n        for(int i=0;i<n;i++){\\n            if(!vis[s[i]-\\'a\\']){\\n                vis[s[i]-\\'a\\']=1;\\n                // Checking only if letter not visited previously\\n                // Once we meet this condition we are sure to push \\n                // this character into the stack, before that \\n                // we will check stack\\'s surrent status and check for   \\n                // any elements that can be removed. \\n                while(!st.empty() && lastInd[st.top()-\\'a\\']>i && st.top()>s[i]){\\n                    // If a greater letter is present again in the string \\n                    //at  a a later index,lets use that index to use this character\\n                    // , so for now we keep it out of stack and make it unvisited \\n                    // to be able to be used later.\\n                    vis[st.top()-\\'a\\']=0;\\n                    st.pop();\\n                }\\n                st.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        // Pour out all the stack contents into a string and reverse it.\\n        while(!st.empty()){\\n            char c=st.top();\\n            st.pop();\\n            ans+=c;\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860594,
                "title": "javascript-effective-solution-easy-to-understand-with-explanation-beginner-friendly",
                "content": "```\\nvar removeDuplicateLetters = function(s) {\\n    let stk = []; // Create a stack ie, an array\\n    for(let i = 0; i < s.length; i++){ //loop through the string\\n        let letter = s[i]; \\n        if(stk.includes(letter))  //if the stk already contains the letter skip \\n            continue;\\n        while(stk[stk.length-1] > letter && s.substring(i).includes(stk[stk.length-1]))  \\n\\t\\t{\\n\\t\\t/*peek stack and check if the top letter has higher order than incoming letter and\\n\\t\\tthe top letter must be present in the remaining sub-sting. */\\n            stk.pop(); //pop all such elements\\n\\t\\t}\\n        stk.push(letter); //push the letter\\n    }\\n    return stk.join(\\'\\'); //convert the stk into a string and return it.\\n};\\n```\\n\\nIts okay if you did not get the solution in the first try, don\\'t give up!\\nPlease do UPVOTE if you find it helpfull.... I know this is not the best solution to this problem but this is what I came up with.\\nHave fun Coding!! Cheers!",
                "solutionTags": [
                    "JavaScript",
                    "Monotonic Stack"
                ],
                "code": "```\\nvar removeDuplicateLetters = function(s) {\\n    let stk = []; // Create a stack ie, an array\\n    for(let i = 0; i < s.length; i++){ //loop through the string\\n        let letter = s[i]; \\n        if(stk.includes(letter))  //if the stk already contains the letter skip \\n            continue;\\n        while(stk[stk.length-1] > letter && s.substring(i).includes(stk[stk.length-1]))  \\n\\t\\t{\\n\\t\\t/*peek stack and check if the top letter has higher order than incoming letter and\\n\\t\\tthe top letter must be present in the remaining sub-sting. */\\n            stk.pop(); //pop all such elements\\n\\t\\t}\\n        stk.push(letter); //push the letter\\n    }\\n    return stk.join(\\'\\'); //convert the stk into a string and return it.\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1860303,
                "title": "c-using-stack-easy-explanation-0ms-time",
                "content": "Traverse in the string and then count the frequency of each letter\\nNow make a present array to check that it is present in answer\\nNow we have to return the smallest lexicographical order so we use stack and if the current letter is smaller than top of the stack and freqency of top of stack is greater than 0 (i ,e, frequency(stack.top())>0 then pop it and continue this ultil stack goes empty or stack.top()<current char \\nAt the end we have our final string in stack in reverse order, So we use another stack to get original answer\\n\\n| PLEASE UPVOTE IF YOU LIKE THE SOLTUION |\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n         int n=s.length();\\n        stack<char> st;\\n        vector<int> present(26,0);\\n        vector<int> freq(26,0);\\n        for(int i=0;i<n;i++) freq[s[i]-97]++;\\n        st.push(s[0]);\\n        present[s[0]-97]=1;\\n        freq[s[0]-97]--;\\n        for(int i=1;i<n;i++){\\n            freq[s[i]-97]--;\\n            if(present[s[i]-97]) continue;\\n            while(!st.empty() && s[i]<st.top() && freq[(st.top())-97]>0){\\n                present[st.top()-97]=0;\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n            present[s[i]-97]=1;\\n        }\\n        \\n        stack<char> temp;\\n        while(!st.empty()) {\\n            temp.push(st.top());\\n            st.pop();\\n        }\\n        \\n        string ans=\"\";\\n        while(!temp.empty()){\\n            ans+=temp.top();\\n            temp.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n         int n=s.length();\\n        stack<char> st;\\n        vector<int> present(26,0);\\n        vector<int> freq(26,0);\\n        for(int i=0;i<n;i++) freq[s[i]-97]++;\\n        st.push(s[0]);\\n        present[s[0]-97]=1;\\n        freq[s[0]-97]--;\\n        for(int i=1;i<n;i++){\\n            freq[s[i]-97]--;\\n            if(present[s[i]-97]) continue;\\n            while(!st.empty() && s[i]<st.top() && freq[(st.top())-97]>0){\\n                present[st.top()-97]=0;\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n            present[s[i]-97]=1;\\n        }\\n        \\n        stack<char> temp;\\n        while(!st.empty()) {\\n            temp.push(st.top());\\n            st.pop();\\n        }\\n        \\n        string ans=\"\";\\n        while(!temp.empty()){\\n            ans+=temp.top();\\n            temp.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859383,
                "title": "c-2-easy-approaches-no-stack-commented",
                "content": "**Unordered MAP**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        \\n        unordered_map<char,int> freq;\\n        unordered_map<char,bool> visit;\\n        string result;\\n        \\n        //calculating frequency \\n        for(auto &it:s)\\n            freq[it]++;\\n        \\n        \\n        //now traversing  on a condition\\n        for(auto &it:s)\\n        {\\n            freq[it]--;\\n            \\n            if(visit[it]) continue;\\n            \\n            //now removing duplicates on some conditions\\n            \\n            while(result.empty()==false  and result.back()>it and freq[result.back()]>0)\\n            {\\n                visit[result.back()]=false;\\n                result.pop_back();\\n            }\\n            \\n            visit[it]=true;\\n            result+=it;\\n        }\\n        \\n        \\n        return result;\\n    }\\n};\\n```\\n\\n<br>\\n\\n**APPROACH 2**\\n\\n**Alphabet Indexed Array**\\n***TC -> O(n)\\nSC -> O(26)***\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int>freq(26);\\n        vector<int>visit(26);\\n        \\n        //frequency \\n        for(auto &it:s)\\n        {\\n            freq[it-\\'a\\']++;\\n            \\n        }\\n        \\n        string res;\\n        //now processing string\\n        for(auto &it:s)\\n        {\\n            freq[it-\\'a\\']--;\\n            \\n            if(visit[it-\\'a\\']) continue;\\n            \\n            while(res.empty()==false  and res.back()>it and freq[res.back()-\\'a\\']>0)\\n            {\\n                visit[res.back()-\\'a\\']=false;\\n                res.pop_back();\\n            }\\n            \\n            visit[it-\\'a\\']=true;\\n            res+=it;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```\\n\\n<br>\\n\\n**KINDLY UPVOTE FOR SUPPORTING THIS ARTICLE**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        \\n        unordered_map<char,int> freq;\\n        unordered_map<char,bool> visit;\\n        string result;\\n        \\n        //calculating frequency \\n        for(auto &it:s)\\n            freq[it]++;\\n        \\n        \\n        //now traversing  on a condition\\n        for(auto &it:s)\\n        {\\n            freq[it]--;\\n            \\n            if(visit[it]) continue;\\n            \\n            //now removing duplicates on some conditions\\n            \\n            while(result.empty()==false  and result.back()>it and freq[result.back()]>0)\\n            {\\n                visit[result.back()]=false;\\n                result.pop_back();\\n            }\\n            \\n            visit[it]=true;\\n            result+=it;\\n        }\\n        \\n        \\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int>freq(26);\\n        vector<int>visit(26);\\n        \\n        //frequency \\n        for(auto &it:s)\\n        {\\n            freq[it-\\'a\\']++;\\n            \\n        }\\n        \\n        string res;\\n        //now processing string\\n        for(auto &it:s)\\n        {\\n            freq[it-\\'a\\']--;\\n            \\n            if(visit[it-\\'a\\']) continue;\\n            \\n            while(res.empty()==false  and res.back()>it and freq[res.back()-\\'a\\']>0)\\n            {\\n                visit[res.back()-\\'a\\']=false;\\n                res.pop_back();\\n            }\\n            \\n            visit[it-\\'a\\']=true;\\n            res+=it;\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825195,
                "title": "lexicographical-order-explained",
                "content": "The immediate error you might have faced is : how acdb is correct and abcd not!\\nInitially you all might have tried this solution:\\n```\\npublic String removeDuplicateLetters(String s) {\\n        char[]arr=new char[s.length()];\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch=s.charAt(i);\\n            arr[i]=ch;\\n        }\\n//        System.out.println(Arrays.toString(arr));\\n        Arrays.sort(arr);\\n//        System.out.println(Arrays.toString(arr));\\n        Stack<Character>st=new Stack<>();\\n        for (int i = arr.length-1; i >= 0 ; i--) {\\n            char ch=arr[i];\\n            while(!st.empty() && arr[i]==st.peek()){\\n                st.pop();\\n            }\\n\\n            st.push(arr[i]);\\n        }\\n        String res = \"\";\\n        while(!st.empty()){\\n            char ch=st.peek();\\n            res+=ch;\\n            st.pop();\\n        }\\n        return res;\\n    }\\n\\t\\n```\\n\\nBut the above solution is wrong !\\n___________________________________________________________________________________\\nLet\\'s 1st learn what is the smallest lexicographical order ?\\n\\nThe smallest lexicographical order is an order relation where string s is smaller than t, given the first character of s (s1) is smaller than the first character of t (t1), or in case they are equivalent, the second character, etc.\\n\\nSo aaabbb is smaller than aaac because although the first three characters are equal, the fourth character b is smaller than the fourth character c.\\n\\nFor cbacdcbc, there are several options, since b and c are duplicates, you can decided which duplicates to remove. This results in:\\n\\ncbacdcbc = adbc\\ncbacdcbc = adcb\\ncbacdcbc = badc\\ncbacdcbc = badc\\n...\\nsince adbc < adcb, you cannot thus simply answer with the first answer that pops into your mind.\\n\\n-------------------------------------------------------------------------------------------------\\n\\nWell now looking at the correct solution:\\n\\n```\\npublic String removeDuplicateLetters(String s) {\\n        int[] res = new int[26];\\n        boolean[] visited = new boolean[26];\\n        char[] ch = s.toCharArray();\\n        Stack<Character>st=new Stack<>();\\n        for(char c : ch) {\\n            res[c - \\'a\\']++;\\n        }\\n        int index=0;\\n        for(char c : ch) {\\n            index = c-\\'a\\';\\n            res[index]--;\\n            if(visited[index])\\n                continue;\\n            while(!st.isEmpty() && c<st.peek() && res[st.peek()-\\'a\\']>0) {\\n                visited[st.pop() - \\'a\\'] = false;\\n            }\\n            st.push(c);\\n            visited[c-\\'a\\'] = true;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!st.isEmpty()) {\\n            sb.insert(0,st.pop());\\n        }\\n        return sb.toString();\\n    }",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\npublic String removeDuplicateLetters(String s) {\\n        char[]arr=new char[s.length()];\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch=s.charAt(i);\\n            arr[i]=ch;\\n        }\\n//        System.out.println(Arrays.toString(arr));\\n        Arrays.sort(arr);\\n//        System.out.println(Arrays.toString(arr));\\n        Stack<Character>st=new Stack<>();\\n        for (int i = arr.length-1; i >= 0 ; i--) {\\n            char ch=arr[i];\\n            while(!st.empty() && arr[i]==st.peek()){\\n                st.pop();\\n            }\\n\\n            st.push(arr[i]);\\n        }\\n        String res = \"\";\\n        while(!st.empty()){\\n            char ch=st.peek();\\n            res+=ch;\\n            st.pop();\\n        }\\n        return res;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1565484,
                "title": "python-stack-counter",
                "content": "The idea is to remove duplicates as while as get the smallest alphabeticlally order while not changing the original order.\\nThink about this example:\\n s = \"bcabc\"\\n we can simply remove all duplicates and get a string \"bca\" yet we can remove s[0] and s[1] to get \"abc\" which is the desired answer.\\n What we want to do here is to count each char in the string and see which of them appeared more than once.\\n fisrt we add \"b\", then we are at \"c\" and we realize that \"c\" > \"b\", this satisfy the alphabetically order so we add \"c\", now we have [\"b\", \"c\"]\\n Then we move to \"a\", now we check stack[-1] which is \"c\" and \"a\" is alphabetically smaller than \"c\", so we check if c appears more than once.\\n Since we haven\\'t running to other \"c\" when we reach \"a\" except for the first one. we will simply pop stack[-1] (\"c\") because we know that later we will add it back in alphabetically order since the count of \"c\" is more than 1 and another \"c\" will appear after \"a\". We will also need to decrease the count of \"c\" in the counter since we no longer need that \"c\" anymore. Then we compare \"a\" with \"b\" which is the same situation as above. After popping stack[-1] (\"b\") and add \"a\" to the stack since \"a\" is not in the stack and the count of \"a\" is 1. now the count of  \"b\" and \"c\" in the counter decreased to 1 and they are not in current stack, we simply add them to the stack. And we will get[\"a\", \"b\",\"c\"].\\n```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        ct = Counter(s)\\n        stack =[]\\n        for i in s:\\n            while stack and i < stack[-1] and ct[stack[-1]] > 1 and i not in stack:\\n                char = stack.pop()\\n                ct[char] -= 1\\n            \\n            if i not in stack:\\n                stack.append(i)\\n            else:\\n                ct[i] -= 1\\n                \\n        return \"\".join(stack)",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "The idea is to remove duplicates as while as get the smallest alphabeticlally order while not changing the original order.\\nThink about this example:\\n s = \"bcabc\"\\n we can simply remove all duplicates and get a string \"bca\" yet we can remove s[0] and s[1] to get \"abc\" which is the desired answer.\\n What we want to do here is to count each char in the string and see which of them appeared more than once.\\n fisrt we add \"b\", then we are at \"c\" and we realize that \"c\" > \"b\", this satisfy the alphabetically order so we add \"c\", now we have [\"b\", \"c\"]\\n Then we move to \"a\", now we check stack[-1] which is \"c\" and \"a\" is alphabetically smaller than \"c\", so we check if c appears more than once.\\n Since we haven\\'t running to other \"c\" when we reach \"a\" except for the first one. we will simply pop stack[-1] (\"c\") because we know that later we will add it back in alphabetically order since the count of \"c\" is more than 1 and another \"c\" will appear after \"a\". We will also need to decrease the count of \"c\" in the counter since we no longer need that \"c\" anymore. Then we compare \"a\" with \"b\" which is the same situation as above. After popping stack[-1] (\"b\") and add \"a\" to the stack since \"a\" is not in the stack and the count of \"a\" is 1. now the count of  \"b\" and \"c\" in the counter decreased to 1 and they are not in current stack, we simply add them to the stack. And we will get[\"a\", \"b\",\"c\"].\\n```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        ct = Counter(s)\\n        stack =[]\\n        for i in s:\\n            while stack and i < stack[-1] and ct[stack[-1]] > 1 and i not in stack:\\n                char = stack.pop()\\n                ct[char] -= 1\\n            \\n            if i not in stack:\\n                stack.append(i)\\n            else:\\n                ct[i] -= 1\\n                \\n        return \"\".join(stack)",
                "codeTag": "Java"
            },
            {
                "id": 1444897,
                "title": "c-stack-100-runtime-inline-comments-for-explaination-o-n-clean-code",
                "content": "```\\n    string removeDuplicateLetters(string s) {\\n        \\n        unordered_map<char, int> mp;     // --> will store running freq of each char\\n        stack<char> stk;\\n        vector<bool> vis (26, false);\\n        \\n        string ans = \"\";\\n        \\n        for(char ch : s)\\n            mp[ch]++;\\n        \\n        \\n        /* one by one iterate for all chars */\\n        \\n        for(char ch : s){\\n            \\n            /* If some char is all vis (i.e already present is stk), decrement the freq and continue */\\n            \\n            if(vis[ch-\\'a\\']){\\n                mp[ch]--;       // --> don\\'t forget to decrement freq before continue\\n                continue;\\n            } \\n            \\n            /* pop till stk.top() is lexically greater then curr char and its freq >=1 and also mark it unvisited */\\n            \\n            while(!stk.empty() and stk.top()>ch and mp[stk.top()]>=1){\\n                vis[stk.top()-\\'a\\'] = false;\\n                stk.pop();\\n            }\\n            \\n            /* push curr char to stk, decrement freq and mark it vis */\\n            \\n            stk.push(ch);\\n            mp[ch]--;\\n            vis[ch-\\'a\\'] = true;\\n        }\\n        \\n        while(!stk.empty()){\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n    string removeDuplicateLetters(string s) {\\n        \\n        unordered_map<char, int> mp;     // --> will store running freq of each char\\n        stack<char> stk;\\n        vector<bool> vis (26, false);\\n        \\n        string ans = \"\";\\n        \\n        for(char ch : s)\\n            mp[ch]++;\\n        \\n        \\n        /* one by one iterate for all chars */\\n        \\n        for(char ch : s){\\n            \\n            /* If some char is all vis (i.e already present is stk), decrement the freq and continue */\\n            \\n            if(vis[ch-\\'a\\']){\\n                mp[ch]--;       // --> don\\'t forget to decrement freq before continue\\n                continue;\\n            } \\n            \\n            /* pop till stk.top() is lexically greater then curr char and its freq >=1 and also mark it unvisited */\\n            \\n            while(!stk.empty() and stk.top()>ch and mp[stk.top()]>=1){\\n                vis[stk.top()-\\'a\\'] = false;\\n                stk.pop();\\n            }\\n            \\n            /* push curr char to stk, decrement freq and mark it vis */\\n            \\n            stk.push(ch);\\n            mp[ch]--;\\n            vis[ch-\\'a\\'] = true;\\n        }\\n        \\n        while(!stk.empty()){\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1404695,
                "title": "java-solution-well-explained-1ms",
                "content": "\\n```\\nclass Solution {\\n    public String removeDuplicateLetters(String text) {\\n        int[] cnt = new int[26];\\n        boolean[] added = new boolean[26];\\n        \\n        for(char c: text.toCharArray()) //count the frequency of all character\\n            cnt[c - \\'a\\']++;\\n        \\n        StringBuilder res = new StringBuilder();\\n        res.append(\\'0\\');  // we add dummy character into the final string\\n        \\n        for(char c: text.toCharArray()) { // traverse whole array\\n            cnt[c-\\'a\\']--; // decrement the current character count\\n            if(!added[c - \\'a\\']) { // if not added into the final string there add this\\n                char x = res.charAt(res.length() - 1);  // find the last character of the final string\\n                while(x > c && cnt[x - \\'a\\'] > 0) { // check whether the current character is greater or not, incase not remove the character\\n                    res.deleteCharAt(res.length() - 1);\\n                    added[x - \\'a\\'] = false; // mark it as false\\n                    x = res.charAt(res.length() - 1); // find the next last character of the final string\\n                }\\n                res.append(c); // finally add the current character\\n                added[c-\\'a\\'] = true; // mark it as true\\n            }\\n        }\\n        \\n        return res.substring(1).toString(); // return the final string after removing the dummy character.\\n        \\n    }\\n}\\n```\\n**Upvotes are encouraging! Do it if you find it helpful!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicateLetters(String text) {\\n        int[] cnt = new int[26];\\n        boolean[] added = new boolean[26];\\n        \\n        for(char c: text.toCharArray()) //count the frequency of all character\\n            cnt[c - \\'a\\']++;\\n        \\n        StringBuilder res = new StringBuilder();\\n        res.append(\\'0\\');  // we add dummy character into the final string\\n        \\n        for(char c: text.toCharArray()) { // traverse whole array\\n            cnt[c-\\'a\\']--; // decrement the current character count\\n            if(!added[c - \\'a\\']) { // if not added into the final string there add this\\n                char x = res.charAt(res.length() - 1);  // find the last character of the final string\\n                while(x > c && cnt[x - \\'a\\'] > 0) { // check whether the current character is greater or not, incase not remove the character\\n                    res.deleteCharAt(res.length() - 1);\\n                    added[x - \\'a\\'] = false; // mark it as false\\n                    x = res.charAt(res.length() - 1); // find the next last character of the final string\\n                }\\n                res.append(c); // finally add the current character\\n                added[c-\\'a\\'] = true; // mark it as true\\n            }\\n        }\\n        \\n        return res.substring(1).toString(); // return the final string after removing the dummy character.\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384567,
                "title": "with-comments-stack-greedy-o-n",
                "content": "**HAVE YOU EVER SOLVED CONVERSION OF INFIX EXPRESSION TO POSTFIX OR PREFIX??**\\n```\\nclass Solution {\\npublic: \\n    \\n    string removeDuplicateLetters(string s) { \\n        \\n        //TRACK OF ELEMENTS WHICH ARE INSTACK\\n        unordered_map<char, bool> visited; \\n        \\n        //TRACK FREQUENCY OF ELEMENTS\\n        unordered_map<char, int> frequency; \\n        \\n        //INITALLY STACK IS EMPTY MARK VISITED AS FALSE, SET FREQUENCY \\n        for (int i = 0; i < s.length(); i++) {  \\n            visited[s[i]] = false;\\n            frequency[s[i]]++;\\n        }\\n        \\n        //STACK - WE ARE GOING TO STORE ELEMENTS IN DESENDING ORDER IN STACK\\n        stack<char> st; \\n        \\n        //..INITALLY PUSH FIRST ELEMENT AS STACK\\n        st.push(s[0]);   \\n        \\n        //AS ELEMENT IS IN STACK MARK IT AS TRUE IN VISITED MAP\\n        visited[s[0]] = true;\\n\\n        //ITERATE 1...N-1\\n        for (int i = 1; i < s.length(); i++) { \\n            \\n            //IF INCOMING CHAR IS LEXICOGRAPHICALLY LESSER THAN TOP OF STACK\\n            if (s[i] <= st.top()) { \\n                \\n                //AND THAT ELEMENT ISN\\'T IN STACK(WE DON\\'T NEED DUPLICATES)\\n                if (!visited[s[i]]) { \\n                    \\n                    //POP ELEMENTS TILL WE DONT FIND ST.TOP > S[I] (MAINTAING DESENDING ORDER) \\n                    //ELEMENTS SHOULD ONLY BE POPED IF THERE FREQ > 1 - BECAUSE WE KNOW THAT THAT CHARECTER IS PRESENT                           //FURTHER IN THE STRING\\n                    while (!st.empty() and s[i] < st.top() and frequency[st.top()] > 1) { \\n                        \\n                        frequency[st.top()]--; // DECREMMENT ITS FREQ BY ONE (WE SKIPPED THAT CHAR)  \\n                        visited[st.top()] = false; // SET ELEMENT AS FALSE BEACUSE NOW THEY ARE NOT IN STACK\\n                        st.pop();  \\n                        \\n                    } \\n                    \\n                    st.push(s[i]); //PUSH THE CURRENT ELEMENT\\n                    visited[s[i]] = true; //SET IT AS TRUE\\n                }  \\n                \\n                else {  \\n                    //IF INCOMING ELEMENT IS ALREADY VISITED JUST SKIP IT BY DECREMMENTING ITS FREQUENCY\\n                    frequency[s[i]]--;\\n                }\\n            } \\n            \\n            //IF INCOMING CHAR > TOP THEN DIRECTLY PUSH IT(MAINTAIN DESCENDING ORDER)\\n            else { \\n                \\n                if (!visited[s[i]]) { \\n                    st.push(s[i]); \\n                    visited[s[i]] = true;\\n                }\\n            }\\n        }\\n        \\n        string answer = \"\"; \\n        \\n        //EMPTY THE STACK AND CONCATINATE TO STRING\\n        while (!st.empty()) {  \\n            cout << st.top();\\n            answer += st.top(); \\n            st.pop();\\n        } \\n        \\n        //REVERSE STRING BEACUSE WE HAVE MAINTAINED DESCENDING IRDER \\n        reverse(answer.begin(), answer.end()); \\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    \\n    string removeDuplicateLetters(string s) { \\n        \\n        //TRACK OF ELEMENTS WHICH ARE INSTACK\\n        unordered_map<char, bool> visited; \\n        \\n        //TRACK FREQUENCY OF ELEMENTS\\n        unordered_map<char, int> frequency; \\n        \\n        //INITALLY STACK IS EMPTY MARK VISITED AS FALSE, SET FREQUENCY \\n        for (int i = 0; i < s.length(); i++) {  \\n            visited[s[i]] = false;\\n            frequency[s[i]]++;\\n        }\\n        \\n        //STACK - WE ARE GOING TO STORE ELEMENTS IN DESENDING ORDER IN STACK\\n        stack<char> st; \\n        \\n        //..INITALLY PUSH FIRST ELEMENT AS STACK\\n        st.push(s[0]);   \\n        \\n        //AS ELEMENT IS IN STACK MARK IT AS TRUE IN VISITED MAP\\n        visited[s[0]] = true;\\n\\n        //ITERATE 1...N-1\\n        for (int i = 1; i < s.length(); i++) { \\n            \\n            //IF INCOMING CHAR IS LEXICOGRAPHICALLY LESSER THAN TOP OF STACK\\n            if (s[i] <= st.top()) { \\n                \\n                //AND THAT ELEMENT ISN\\'T IN STACK(WE DON\\'T NEED DUPLICATES)\\n                if (!visited[s[i]]) { \\n                    \\n                    //POP ELEMENTS TILL WE DONT FIND ST.TOP > S[I] (MAINTAING DESENDING ORDER) \\n                    //ELEMENTS SHOULD ONLY BE POPED IF THERE FREQ > 1 - BECAUSE WE KNOW THAT THAT CHARECTER IS PRESENT                           //FURTHER IN THE STRING\\n                    while (!st.empty() and s[i] < st.top() and frequency[st.top()] > 1) { \\n                        \\n                        frequency[st.top()]--; // DECREMMENT ITS FREQ BY ONE (WE SKIPPED THAT CHAR)  \\n                        visited[st.top()] = false; // SET ELEMENT AS FALSE BEACUSE NOW THEY ARE NOT IN STACK\\n                        st.pop();  \\n                        \\n                    } \\n                    \\n                    st.push(s[i]); //PUSH THE CURRENT ELEMENT\\n                    visited[s[i]] = true; //SET IT AS TRUE\\n                }  \\n                \\n                else {  \\n                    //IF INCOMING ELEMENT IS ALREADY VISITED JUST SKIP IT BY DECREMMENTING ITS FREQUENCY\\n                    frequency[s[i]]--;\\n                }\\n            } \\n            \\n            //IF INCOMING CHAR > TOP THEN DIRECTLY PUSH IT(MAINTAIN DESCENDING ORDER)\\n            else { \\n                \\n                if (!visited[s[i]]) { \\n                    st.push(s[i]); \\n                    visited[s[i]] = true;\\n                }\\n            }\\n        }\\n        \\n        string answer = \"\"; \\n        \\n        //EMPTY THE STACK AND CONCATINATE TO STRING\\n        while (!st.empty()) {  \\n            cout << st.top();\\n            answer += st.top(); \\n            st.pop();\\n        } \\n        \\n        //REVERSE STRING BEACUSE WE HAVE MAINTAINED DESCENDING IRDER \\n        reverse(answer.begin(), answer.end()); \\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1185261,
                "title": "lessons-learned",
                "content": "**Update**:\\nCoded it in 1 to 2 hours using different test cases. 2 edge cases bugged my solution though. A peaceful mind is required to solve these kinds of problems where we build our approach via test cases. \\n\\n**Update**:\\n* Feeling super hard to solve.\\n* Referenece from LC solution that helped this time: \\n```\\n\"As we iterate over our string, if character i is greater than character i+1 and another occurrence of character i \\nexists later in the string, deleting character i will always lead to the optimal solution. \\nCharacters that come later in the string i don\\'t matter in this calculation because i is in a more significant spot. \\nEven if character i+1 isn\\'t the best yet, we can always replace it for a smaller character down the line if possible.\\n\\nSince we try to remove characters as early as possible, and picking the best letter at each step leads to the best solution, \\n\"greedy\" should be going off like an alarm.\"\\n```\\n\\n**Original**:\\nSolved it mentally in 15 min. I never expected I could solve this. What helped me is taking different test cases: \\n- \\'duplicates\\' in alphabets signalled me to use char[26] or HashMap<Character, Integer>. Solving sliding window substring problems helped me to identify this faster.\\n- aba, cbc: this showed duplicates are not **always** removed from first or last, they could be removed from any position and varied across test cases.\\n- digged deeply to know why different test cases behaved differently. Realized this was connected to **lexographical ordering**. Deleting a duplicate char meant the next char would come in place of the deleted one. But to maintain the lexographical priority I needed the lowest of these two. So before deleting I compared/made sure if the next char is smaller than current char, else no deletion. Used stack for this FIFO comparison.\\n- When I thought I cracked it, I simply took a bigger test case and my approach failed: cbcbc. The second b entered into stack (we already have a \\'b\\' in stack) since it was smaller than the second c. To avoid this I wanted something that warned me when I added duplicates into stack: a HashSet for Stacked elements. \\n- Note: The space compexity for this Stack approach is O(1). LC has explained it well why it is not O(n).\\n\\n**Code**:\\n```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        \\n        int length = s.length();\\n        \\n        // Identify duplicates\\n        Map<Character, Integer> characterFrequencyMap = new HashMap<>();\\n        for (char c: s.toCharArray()) {\\n            characterFrequencyMap.put(c, characterFrequencyMap.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        // Remove duplicates while maintaining lexo order\\n        Stack<Character> stack = new Stack<>();\\n        Set<Character> stackCharacterSet = new HashSet<>();\\n        for (char c : s.toCharArray()) {\\n            while (!stack.isEmpty() && characterFrequencyMap.get(stack.peek()) > 1 && c < stack.peek() && !stackCharacterSet.contains(c)) { // Edge case 1a: !stackCharacterSet.contains(c) -> Input: \"cdadabcc\", Output:\"abc\", Expected:\"adbc\"\\n                char poppedCharacter = stack.pop();\\n                stackCharacterSet.remove(poppedCharacter);\\n                characterFrequencyMap.put(poppedCharacter, characterFrequencyMap.getOrDefault(poppedCharacter, 0) - 1); // Edge case 1b: Input: \"cdadabcc\", Output:\"abc\", Expected:\"adbc\"\\n            }\\n            if (!stackCharacterSet.contains(c)) {\\n                stack.push(c);\\n                stackCharacterSet.add(c);\\n            } else { // Edge case 2: Input:\"bbcaac\", Output:\"ac\", Expected:\"bac\"\\n                characterFrequencyMap.put(c, characterFrequencyMap.getOrDefault(c, 0) - 1);\\n            }\\n        }\\n        \\n        // Prepare output\\n        StringBuilder stringBuilder = new StringBuilder();\\n        for (char c : stack) {\\n            stringBuilder.append(c);\\n        }\\n        return stringBuilder.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\"As we iterate over our string, if character i is greater than character i+1 and another occurrence of character i \\nexists later in the string, deleting character i will always lead to the optimal solution. \\nCharacters that come later in the string i don\\'t matter in this calculation because i is in a more significant spot. \\nEven if character i+1 isn\\'t the best yet, we can always replace it for a smaller character down the line if possible.\\n\\nSince we try to remove characters as early as possible, and picking the best letter at each step leads to the best solution, \\n\"greedy\" should be going off like an alarm.\"\\n```\n```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        \\n        int length = s.length();\\n        \\n        // Identify duplicates\\n        Map<Character, Integer> characterFrequencyMap = new HashMap<>();\\n        for (char c: s.toCharArray()) {\\n            characterFrequencyMap.put(c, characterFrequencyMap.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        // Remove duplicates while maintaining lexo order\\n        Stack<Character> stack = new Stack<>();\\n        Set<Character> stackCharacterSet = new HashSet<>();\\n        for (char c : s.toCharArray()) {\\n            while (!stack.isEmpty() && characterFrequencyMap.get(stack.peek()) > 1 && c < stack.peek() && !stackCharacterSet.contains(c)) { // Edge case 1a: !stackCharacterSet.contains(c) -> Input: \"cdadabcc\", Output:\"abc\", Expected:\"adbc\"\\n                char poppedCharacter = stack.pop();\\n                stackCharacterSet.remove(poppedCharacter);\\n                characterFrequencyMap.put(poppedCharacter, characterFrequencyMap.getOrDefault(poppedCharacter, 0) - 1); // Edge case 1b: Input: \"cdadabcc\", Output:\"abc\", Expected:\"adbc\"\\n            }\\n            if (!stackCharacterSet.contains(c)) {\\n                stack.push(c);\\n                stackCharacterSet.add(c);\\n            } else { // Edge case 2: Input:\"bbcaac\", Output:\"ac\", Expected:\"bac\"\\n                characterFrequencyMap.put(c, characterFrequencyMap.getOrDefault(c, 0) - 1);\\n            }\\n        }\\n        \\n        // Prepare output\\n        StringBuilder stringBuilder = new StringBuilder();\\n        for (char c : stack) {\\n            stringBuilder.append(c);\\n        }\\n        return stringBuilder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050213,
                "title": "1st-time-my-code-beats-98-35",
                "content": "class Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n                \\n        ans = []\\n        \\n        for i in range(len(s)):\\n            if s[i] in ans:\\n                continue\\n                \\n            while ans  and s[i] < ans[-1] and ans[-1] in s[i+1:]:\\n                ans.pop()\\n                \\n            ans.append(s[i])\\n            \\n        return \"\".join(ans)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n                \\n        ans = []\\n        \\n        for i in range(len(s)):\\n            if s[i] in ans:\\n                continue\\n                \\n            while ans  and s[i] < ans[-1] and ans[-1] in s[i+1:]:\\n                ans.pop()\\n                \\n            ans.append(s[i])\\n            \\n        return \"\".join(ans)",
                "codeTag": "Java"
            },
            {
                "id": 894743,
                "title": "java-greedy-algorithm-to-find-the-smallest-beginning-character",
                "content": "In order to get the result that is the smallest in lexicographical order among all possible results, **we can greedily pick the smallest characters for each postion**. To do so, we can always keep track of the **last occurrence postion** of each character in *s*, since **we can feel free to remove the duplicate before the last occurence postion** of it. \\n\\nNow we can use a data structure as Stack, while\\n**1. Stack is non-empty and\\n2. the character at current postion i, is smaller than the top of Stack and \\n3. the character on the top of Stack can be seen in the future, which means we have not reached the last postion of it.**\\nThen we are free to do a Stack.pop() to update the beginning of the result. Same for the 2nd position, 3rd postion and so on.\\n\\nHere is the clean Java code:\\n```\\npublic String removeDuplicateLetters(String s) {\\n\\tint[] map = new int[26]; // To keep track of the last occurence of each character is the given string.\\n\\tchar[] ch = s.toCharArray();\\n\\tfor (int i=0; i<ch.length; i++) {\\n\\t\\tmap[ch[i] - \\'a\\'] = i;\\n\\t}\\n\\tint[] counter = new int[26]; // we do need a \"counter\" to counte if we have put the character to the stack.\\n\\tStack<Character> stack = new Stack<>();\\n\\tfor (int i=0; i<ch.length; i++) {\\n\\t\\tif (counter[ch[i] - \\'a\\'] != 0) continue;\\n\\t\\t\\t// When meet those 3 conditions to update the top of stack:\\n\\t\\t\\twhile (!stack.isEmpty() && ch[i] - stack.peek() < 0 && map[stack.peek() - \\'a\\'] > i) {\\n\\t\\t\\t\\tcounter[stack.peek() - \\'a\\'] = 0;\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t}\\n\\t\\t\\tstack.push(ch[i]);\\n\\t\\t\\tcounter[ch[i] - \\'a\\'] = 1;\\n\\t}\\n\\tStringBuilder sb = new StringBuilder();\\n\\twhile (!stack.isEmpty()) sb.append(stack.pop());\\n\\treturn sb.reverse().toString();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String removeDuplicateLetters(String s) {\\n\\tint[] map = new int[26]; // To keep track of the last occurence of each character is the given string.\\n\\tchar[] ch = s.toCharArray();\\n\\tfor (int i=0; i<ch.length; i++) {\\n\\t\\tmap[ch[i] - \\'a\\'] = i;\\n\\t}\\n\\tint[] counter = new int[26]; // we do need a \"counter\" to counte if we have put the character to the stack.\\n\\tStack<Character> stack = new Stack<>();\\n\\tfor (int i=0; i<ch.length; i++) {\\n\\t\\tif (counter[ch[i] - \\'a\\'] != 0) continue;\\n\\t\\t\\t// When meet those 3 conditions to update the top of stack:\\n\\t\\t\\twhile (!stack.isEmpty() && ch[i] - stack.peek() < 0 && map[stack.peek() - \\'a\\'] > i) {\\n\\t\\t\\t\\tcounter[stack.peek() - \\'a\\'] = 0;\\n\\t\\t\\t\\tstack.pop();\\n\\t\\t\\t}\\n\\t\\t\\tstack.push(ch[i]);\\n\\t\\t\\tcounter[ch[i] - \\'a\\'] = 1;\\n\\t}\\n\\tStringBuilder sb = new StringBuilder();\\n\\twhile (!stack.isEmpty()) sb.append(stack.pop());\\n\\treturn sb.reverse().toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 889958,
                "title": "remove-duplicate-letters-0-ms-short-c-code-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int dict[26]={0};\\n        bool visited[26] ={0};\\n        for(auto i: s)  dict[i-\\'a\\']++;\\n        string result;\\n        for(auto c : s) {\\n            dict[c-\\'a\\']--;\\n            if(visited[c-\\'a\\'])  continue;\\n            while(c < result.back() && dict[result.back()-\\'a\\']) {\\n                visited[result.back()-\\'a\\'] = false;\\n                result.pop_back();\\n            }\\n            result += c;\\n            visited[c-\\'a\\'] = 1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int dict[26]={0};\\n        bool visited[26] ={0};\\n        for(auto i: s)  dict[i-\\'a\\']++;\\n        string result;\\n        for(auto c : s) {\\n            dict[c-\\'a\\']--;\\n            if(visited[c-\\'a\\'])  continue;\\n            while(c < result.back() && dict[result.back()-\\'a\\']) {\\n                visited[result.back()-\\'a\\'] = false;\\n                result.pop_back();\\n            }\\n            result += c;\\n            visited[c-\\'a\\'] = 1;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642480,
                "title": "c-hashmap-string-same-as-1081",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        \\n        int n = s.length();\\n        \\n        unordered_map<char, int>hm;\\n        unordered_map<char, bool>seen;\\n        \\n        for (int i = 0; i < n; i++) \\n            hm[s[i]]++;\\n        \\n        string res;\\n        for (int i = 0; i < n; i++) {\\n            hm[s[i]]--;\\n            \\n            if (seen[s[i]]) continue;\\n            \\n            seen[s[i]] = true;\\n            \\n            while (!res.empty() && res.back() > s[i] && hm[res.back()] > 0) {\\n                seen[res.back()] = false;\\n                res.pop_back();\\n            }\\n            \\n            res.push_back(s[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        \\n        int n = s.length();\\n        \\n        unordered_map<char, int>hm;\\n        unordered_map<char, bool>seen;\\n        \\n        for (int i = 0; i < n; i++) \\n            hm[s[i]]++;\\n        \\n        string res;\\n        for (int i = 0; i < n; i++) {\\n            hm[s[i]]--;\\n            \\n            if (seen[s[i]]) continue;\\n            \\n            seen[s[i]] = true;\\n            \\n            while (!res.empty() && res.back() > s[i] && hm[res.back()] > 0) {\\n                seen[res.back()] = false;\\n                res.pop_back();\\n            }\\n            \\n            res.push_back(s[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439198,
                "title": "python-stack-solution",
                "content": "```py\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        if not s:\\n            return s\\n\\n        # keep track of occurances of each character in the original string\\n        counter = collections.Counter(s)\\n\\n        # keep track of which characters have already been used\\n        used = set()\\n\\n        stack = []\\n\\n        # iterate through the input string\\n        for ch in s:\\n            counter[ch] -= 1\\n            # skip current character\\n            # 1) if it is already in use\\n            if ch in used:\\n                continue\\n\\n            # pop off characters from stack if they are larger than the current character\\n            # and there are other appearances of them later in the string\\n            while stack and stack[-1] > ch and counter[stack[-1]]:\\n                used.remove(stack.pop())\\n\\n            # add this character onto the stack\\n            stack.append(ch)\\n            # mark this character as used\\n            used.add(ch)\\n\\n        return \\'\\'.join(stack)\\n```\\nHappy Coding~",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        if not s:\\n            return s\\n\\n        # keep track of occurances of each character in the original string\\n        counter = collections.Counter(s)\\n\\n        # keep track of which characters have already been used\\n        used = set()\\n\\n        stack = []\\n\\n        # iterate through the input string\\n        for ch in s:\\n            counter[ch] -= 1\\n            # skip current character\\n            # 1) if it is already in use\\n            if ch in used:\\n                continue\\n\\n            # pop off characters from stack if they are larger than the current character\\n            # and there are other appearances of them later in the string\\n            while stack and stack[-1] > ch and counter[stack[-1]]:\\n                used.remove(stack.pop())\\n\\n            # add this character onto the stack\\n            stack.append(ch)\\n            # mark this character as used\\n            used.add(ch)\\n\\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327687,
                "title": "very-simple-solution-written-in-c",
                "content": "we use a hash to save the frequency of each character, use a visited to judge whether character has appeared.\\nwe use a string res to save the result, and go through the string s. when s[i] < res.back() && hash[s[i]] > 0(it means it could appear in the right so we could pop it from res) && visited[s[i]]) == false(it means the s[i] didn\\'t appear in the left. I would explain it later), we will pop the res.back().\\nas for the condition that visited[s[i]] == false. if s[i] has appear in the left, suppose it is at position p, then res[p+1], res[p+2], ..., res[end] should be bigger than s[i]/res[p], and res[0], res[1], ..., res[p-1] woule be smaller than s[i]/res[p]. in this case, we couldn\\'t pop those characters in res smaller than s[i]. For example, \"abcafgbc\" if we pop \\'b\\' \\'c\\' from \"abc\" then the res would be \"afgbc\"\\nhere is my code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> hash(128, 0);\\n        for(int i = 0; i < s.size(); i++){\\n            hash[s[i]]++;\\n        }\\n        vector<bool> visited(128, false);\\n        string res = \"\";\\n        \\n        for(int i = 0; i < s.size(); i++){\\n\\n            while(!visited[s[i]] && s[i] < res.back() && hash[res.back()] > 0){\\n                visited[res.back()] = false;\\n                res.pop_back();\\n            }\\n            \\n            if(!visited[s[i]]){\\n                res += string(1, s[i]);\\n                visited[s[i]] = true;\\n            }\\n            \\n            hash[s[i]]--;\\n        }\\n        \\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> hash(128, 0);\\n        for(int i = 0; i < s.size(); i++){\\n            hash[s[i]]++;\\n        }\\n        vector<bool> visited(128, false);\\n        string res = \"\";\\n        \\n        for(int i = 0; i < s.size(); i++){\\n\\n            while(!visited[s[i]] && s[i] < res.back() && hash[res.back()] > 0){\\n                visited[res.back()] = false;\\n                res.pop_back();\\n            }\\n            \\n            if(!visited[s[i]]){\\n                res += string(1, s[i]);\\n                visited[s[i]] = true;\\n            }\\n            \\n            hash[s[i]]--;\\n        }\\n        \\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 313544,
                "title": "java-stack-solution",
                "content": "\\'\\'\\'\\n\\t\\t\\n\\t\\tStack<Character> T = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        // \\u8BBE\\u7F6E\\u8BA1\\u6570\\u4E0E\\u662F\\u5426\\u4F7F\\u7528\\u8FC7\\u8BE5\\u5B57\\u6BCD\\n        int[] cnt = new int[26];\\n        boolean[] used = new boolean[26];\\n        \\n        \\n        for (char c : s.toCharArray()) {\\n            //\\u7531\\u4E8E\\u662Fchar \\u6240\\u4EE5convert to int\\u8FDB\\u884C\\u8BA1\\u6570\\n            cnt[c - \\'a\\']++;\\n        }\\n        \\n        for (char c : s.toCharArray()) {\\n            cnt[c-\\'a\\']--;\\n            if (used[c-\\'a\\'] == true) continue; \\n            while (!T.isEmpty() && T.peek() > c && cnt[T.peek()-\\'a\\'] > 0) {\\n                used[T.peek() - \\'a\\'] = false;\\n                T.pop();\\n            }\\n            T.push(c);\\n            used[c-\\'a\\'] = true;\\n        }\\n        \\n        for (char c : T){\\n            sb.append(c);\\n        }\\n        \\n        return sb.toString();\\n    }",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\t\\t\\n\\t\\tStack<Character> T = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n        \\n        // \\u8BBE\\u7F6E\\u8BA1\\u6570\\u4E0E\\u662F\\u5426\\u4F7F\\u7528\\u8FC7\\u8BE5\\u5B57\\u6BCD\\n        int[] cnt = new int[26];\\n        boolean[] used = new boolean[26];\\n        \\n        \\n        for (char c : s.toCharArray()) {\\n            //\\u7531\\u4E8E\\u662Fchar \\u6240\\u4EE5convert to int\\u8FDB\\u884C\\u8BA1\\u6570\\n            cnt[c - \\'a\\']++;\\n        }\\n        \\n        for (char c : s.toCharArray()) {\\n            cnt[c-\\'a\\']--;\\n            if (used[c-\\'a\\'] == true) continue; \\n            while (!T.isEmpty() && T.peek() > c && cnt[T.peek()-\\'a\\'] > 0) {\\n                used[T.peek() - \\'a\\'] = false;\\n                T.pop();\\n            }\\n            T.push(c);\\n            used[c-\\'a\\'] = true;\\n        }\\n        \\n        for (char c : T){\\n            sb.append(c);\\n        }\\n        \\n        return sb.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 128235,
                "title": "java-stack",
                "content": "> It is intuitive to list all subsequences with unique chars and get the smallest one.\\n\\n>To optimize, let\\'s try building the final result from scratch.\\n\\n> The final result should satisfy:\\n\\n1. contains all unique characters\\n2. smallest\\n\\n> If we put s[i] as long as it is not in the current result. property 1 is satisfied\\n\\n> Before we add s[i] into result, if we abandon its preceding elements(`ch`) such that\\n```\\n`ch` > s[i] and `ch` will occur later\\n```\\n> property 2 will be satisfied. \\n\\n> To get preceding elements, we utilize **stack** to store result.\\n\\nSimilar usage of stack\\n[42. Trapping Rain Water](https://leetcode.com/problems/trapping-rain-water/discuss/178028/Stack-with-Explanation-(Java-Python-Scala))\\n\\n```\\n    public String removeDuplicateLetters(String s) {\\n        if (s.length() <= 1) {\\n            return s;\\n        }\\n        \\n        int[] freq = buildFreq(s); // tell whether ch in s will appear later or not\\n        \\n        Stack<Character> stack = new Stack<>();\\n        \\n        for (char ch : s.toCharArray()) {\\n            freq[ch - \\'a\\']--;\\n            if (stack.contains(ch)) {\\n                continue;\\n            }\\n\\n            while (!stack.isEmpty()\\n                    && stack.peek() > ch\\n                    && freq[stack.peek() - \\'a\\'] > 0) {\\n                stack.pop();\\n            }\\n            \\n            stack.push(ch);\\n        }\\n        \\n        // Build result\\n        StringBuilder result = new StringBuilder();\\n        while (!stack.isEmpty()) {\\n            result.append(stack.pop());\\n        }\\n        \\n        return result.reverse().toString();\\n    }\\n                         \\n    private int[] buildFreq(String s) {\\n        int[] freq = new int[26];\\n        for (char ch : s.toCharArray()) {\\n            freq[ch - \\'a\\']++;\\n        }\\n        return freq;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n`ch` > s[i] and `ch` will occur later\\n```\n```\\n    public String removeDuplicateLetters(String s) {\\n        if (s.length() <= 1) {\\n            return s;\\n        }\\n        \\n        int[] freq = buildFreq(s); // tell whether ch in s will appear later or not\\n        \\n        Stack<Character> stack = new Stack<>();\\n        \\n        for (char ch : s.toCharArray()) {\\n            freq[ch - \\'a\\']--;\\n            if (stack.contains(ch)) {\\n                continue;\\n            }\\n\\n            while (!stack.isEmpty()\\n                    && stack.peek() > ch\\n                    && freq[stack.peek() - \\'a\\'] > 0) {\\n                stack.pop();\\n            }\\n            \\n            stack.push(ch);\\n        }\\n        \\n        // Build result\\n        StringBuilder result = new StringBuilder();\\n        while (!stack.isEmpty()) {\\n            result.append(stack.pop());\\n        }\\n        \\n        return result.reverse().toString();\\n    }\\n                         \\n    private int[] buildFreq(String s) {\\n        int[] freq = new int[26];\\n        for (char ch : s.toCharArray()) {\\n            freq[ch - \\'a\\']++;\\n        }\\n        return freq;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 76773,
                "title": "life-is-short-why-not-python-o-1-space-o-n-time",
                "content": "    def removeDuplicateLetters(self, s):\\n        cnt = [0]*26 # Counters needed\\n        res = '' # And an answer container\\n        used = [False]*26 # Some used marks as well \\n        for c in s:\\n            cnt[ord(c) - ord('a')] += 1\\n        for c in s:\\n            ci = ord(c) - ord('a')\\n            cnt[ci] -= 1\\n            if used[ci]:    continue\\n            for j in xrange(len(res)-1, -1, -1): # Checking backward for some dulplicate leters\\n                cj = ord(res[j]) - ord('a')\\n                if cj > ci and cnt[cj] > 0:\\n                    used[cj] = False\\n                    res = res[:j] + res[j+1:]\\n                    j -= 1\\n                else:    break\\n            used[ci] = True\\n            res += c\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def removeDuplicateLetters(self, s):\\n        cnt = [0]*26 # Counters needed\\n        res = '' # And an answer container\\n        used = [False]*26 # Some used marks as well \\n        for c in s:\\n            cnt[ord(c) - ord('a')] += 1\\n        for c in s:\\n            ci = ord(c) - ord('a')\\n            cnt[ci] -= 1\\n            if used[ci]:    continue\\n            for j in xrange(len(res)-1, -1, -1): # Checking backward for some dulplicate leters\\n                cj = ord(res[j]) - ord('a')\\n                if cj > ci and cnt[cj] > 0:\\n                    used[cj] = False\\n                    res = res[:j] + res[j+1:]\\n                    j -= 1\\n                else:    break\\n            used[ci] = True\\n            res += c\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 76827,
                "title": "the-pattern-of-this-type-of-problem-in-leetcode",
                "content": "I think this solution is really concise!  But I want to add some detailed explainations to show why we do so to solve the problem, This problem is in fact similiar to the problem \"[Largest Rectangle under the histogram \"][1]\\n\\n**We need to keep the monotically decreasing substring that contains all the char in the s. So we just use a vector to mimic the stack! Just similiar to the previous many solutions that use the vector to simulate a stack.** \\n\\nIn fact this problem is also similiar to the problem that the [maximum in the sliding windows][2], I strongly recommend you to grasp the sliding windows solutions.\\n\\nHere is the AC C++ implementation \\n\\n    class Solution {\\n    public:\\n        string removeDuplicateLetters(string s) {\\n            vector<int> dict(256, 0);\\n            vector<bool> visited(256, false);\\n            for(auto ch : s)  dict[ch]++;\\n            string result = \"0\";\\n            /** the key idea is to keep a monotically increasing sequence **/\\n            for(auto c : s) {\\n                dict[c]--;\\n                /** to filter the previously visited elements **/\\n                if(visited[c])  continue;\\n                while(c < result.back() && dict[result.back()]) {\\n                    visited[result.back()] = false;\\n                    result.pop_back();\\n                }\\n                result += c;\\n                visited[c] = true;\\n            }\\n            return result.substr(1);\\n        }\\n    };\\n\\n\\n\\n  [1]: https://leetcode.com/discuss/84911/geeks-for-geeks-thought-on-how-to-solve-the-problem\\n  [2]: https://leetcode.com/discuss/87685/template-subarray-substring-substring-repeating-characters",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string removeDuplicateLetters(string s) {\\n            vector<int> dict(256, 0);\\n            vector<bool> visited(256, false);\\n            for(auto ch : s)  dict[ch]++;\\n            string result = \"0\";\\n            /** the key idea is to keep a monotically increasing sequence **/\\n            for(auto c : s) {\\n                dict[c]--;\\n                /** to filter the previously visited elements **/\\n                if(visited[c])  continue;\\n                while(c < result.back() && dict[result.back()]) {\\n                    visited[result.back()] = false;\\n                    result.pop_back();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4093499,
                "title": "c-without-stack-explained",
                "content": "# *PLEASE UPVOTE IF IT HELPED*\\n#### **Same Approach in this question too:** https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/solutions/4094062/c-without-stack-explained/\\n\\n---\\n\\n# Approach\\n\\n***(Also explained in the code)***\\n\\n#### **Step-by-Step Explanation:**\\n\\n1. Initialize two vectors, `count` and `used`, and an empty string `result`.\\n\\n   - `count`: Stores the frequency of each character in the input string.\\n   - `used`: Keeps track of whether a character has been used in the result.\\n   - `result`: Will store the final lexicographically smallest string without duplicate letters.\\n\\n2. Iterate through the characters of the input string `s`.\\n\\n   - For each character ch:\\n     - Decrement its frequency in the count vector.\\n\\n3. Check if the character `ch` is already used in the result.\\n\\n    - If it\\'s used, skip processing it.\\n\\n4. Enter a loop to remove characters from the result string if they are greater than the current character ch in lexicographical order.\\n\\n   - This loop continues until one of the following conditions is met:\\n     - The `result` string is empty.\\n     - The last character in the `result` string is smaller than `ch`.\\n      - The count of the last character in the `count` vector is greater than zero.\\n1. Inside the loop, mark the removed character as unused in the `used` vector and remove it from the `result` string.\\n\\n1. Add the current character `ch` to the `result` string and mark it as `used` in the used vector.\\n\\n1. After processing all characters, return the `result` string, which contains the lexicographically smallest string without duplicate letters.\\n\\n---\\n\\n\\n\\n# Complexity\\n- **Time complexity:**\\n$$O(n)$$\\n\\n- **Space complexity:**\\n$$O(1)$$\\n\\n---\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> count(26, 0); // Count the frequency of each character\\n        vector<bool> used(26, false); // Track if a character is already used\\n        string result = \"\"; // To store the final result\\n\\n        for (char ch : s) {\\n            count[ch - \\'a\\']++; // Increment the frequency of the current character\\n        }\\n\\n        for (char ch : s) {\\n            count[ch - \\'a\\']--; // Decrement the frequency of the current character\\n\\n            // Check if the character is already in the result or not\\n            if (used[ch - \\'a\\']) {\\n                continue; // Skip if it\\'s already used\\n            }\\n\\n            // Remove characters from the result string if they are greater than the current character\\n            while (!result.empty() && ch < result.back() && count[result.back() - \\'a\\'] > 0) {\\n                used[result.back() - \\'a\\'] = false;\\n                result.pop_back();\\n            }\\n\\n            result.push_back(ch); // Add the current character to the result\\n            used[ch - \\'a\\'] = true; // Mark it as used\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```\\n# *PLEASE UPVOTE IF IT HELPED*\\n\\n\\n---\\n---\\n\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> count(26, 0); // Count the frequency of each character\\n        vector<bool> used(26, false); // Track if a character is already used\\n        string result = \"\"; // To store the final result\\n\\n        for (char ch : s) {\\n            count[ch - \\'a\\']++; // Increment the frequency of the current character\\n        }\\n\\n        for (char ch : s) {\\n            count[ch - \\'a\\']--; // Decrement the frequency of the current character\\n\\n            // Check if the character is already in the result or not\\n            if (used[ch - \\'a\\']) {\\n                continue; // Skip if it\\'s already used\\n            }\\n\\n            // Remove characters from the result string if they are greater than the current character\\n            while (!result.empty() && ch < result.back() && count[result.back() - \\'a\\'] > 0) {\\n                used[result.back() - \\'a\\'] = false;\\n                result.pop_back();\\n            }\\n\\n            result.push_back(ch); // Add the current character to the result\\n            used[ch - \\'a\\'] = true; // Mark it as used\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092809,
                "title": "python-solution-beats-100-users-greedy-algorithm-easy-to-understand",
                "content": "# Intuition\\n The goal is to remove duplicate letters from the input string while preserving their lexicographical order. This can be achieved using a systematic approach that iterates through the string, ensuring that the characters are added to the result string in the correct order.\\n\\n# Approach\\n- Initialize an empty string res to store the final result.\\n\\n- Create a dictionary last_occurrence to keep track of the last occurrence index of each character in the input string s. This dictionary will help us decide whether to remove characters from the result or not.\\n\\n- Iterate through the characters in the input string s.\\n\\n- For each character in s:\\n\\n  - Check if the current character is not already in the result string res. This step ensures uniqueness in the result.\\n  - If the character is not in res, enter a loop:\\n    - While the result string res is not empty (res and) and the current character char is lexicographically smaller than the last character in res (char < res[-1]) and there are more occurrences of the last character ahead in the input string (i < last_occurrence[res[-1]]), remove the last character from res. This step ensures that we maintain lexicographical order.\\n    - After the loop, append the current character char to the result string res.\\n- Continue this process for all characters in the input string.\\n\\n- Finally, the res string will contain the desired result, with duplicates removed while preserving lexicographical order.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the length of the input string s. The algorithm iterates through the string once to build the result string.\\n- Space complexity: O(1) for the res string and O(k) for the last_occurrence dictionary, where k is the number of unique characters in the input string. In practice, this is O(26) as there are 26 lowercase letters in the English alphabet, making the space complexity constant.\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        # Initialize an empty result string\\n        res = \"\"\\n        # Initialize a dictionary to store the last occurrence index of each character\\n        last_occurrence = {}\\n\\n        # Populate the last_occurrence dictionary with the last index of each character\\n        for i, char in enumerate(s):\\n            last_occurrence[char] = i\\n\\n        # Iterate through the characters in the input string\\n        for i, char in enumerate(s):\\n            if char not in res:\\n                while res and char < res[-1] and i < last_occurrence[res[-1]]:\\n                    res = res[:-1]\\n                # Append the current character to res.\\n                res += char\\n\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        # Initialize an empty result string\\n        res = \"\"\\n        # Initialize a dictionary to store the last occurrence index of each character\\n        last_occurrence = {}\\n\\n        # Populate the last_occurrence dictionary with the last index of each character\\n        for i, char in enumerate(s):\\n            last_occurrence[char] = i\\n\\n        # Iterate through the characters in the input string\\n        for i, char in enumerate(s):\\n            if char not in res:\\n                while res and char < res[-1] and i < last_occurrence[res[-1]]:\\n                    res = res[:-1]\\n                # Append the current character to res.\\n                res += char\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092793,
                "title": "o-n-fastest-solution-beats-100",
                "content": "# Approach\\nFirst count the frequecy of each characters.\\nAlso use *isPresent* set to keep track of what characters are alrady included in answer.\\n\\nNow iterate over given string and start constructing answer.\\n- If current character is present in answer then ignore it and check string further. Also reduce its frequency as its traversed.\\n- Otherwise compare this with last character of answer string. If its greater then current character then , remove it from answer if there are more occurence of that characters are yet to be traversed further in string. \\n- Keep doing above step untill above condition is satisfied. \\n- At last put current character in answer string, and mark it in *isPresent* and *freq*\\n\\n**Note** : pop_back and push_back take O(1) time , because of this we can achive O(N) TC without using stack. Also use push_back insetad of \\'+\\' operator to append one character, cause \\'+\\' takses O(n) tiime.\\n    \\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        unordered_map<char,int> freq;\\n        for(char c : s) {\\n            freq[c]++;\\n        }\\n        unordered_set<char> isPresent;\\n        string ans;\\n        for(char c : s) {\\n            if(isPresent.find(c)!=isPresent.end()) {\\n                freq[c]--;\\n                continue;\\n            }\\n            while(ans.size() > 0 && ans[ans.size() - 1] > c && freq[ans[ans.size() - 1]] > 0) {\\n                isPresent.erase(ans[ans.size() - 1]);\\n                ans.pop_back();\\n\\n            }\\n            ans.push_back(c);\\n            freq[c]--;\\n            isPresent.insert(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        unordered_map<char,int> freq;\\n        for(char c : s) {\\n            freq[c]++;\\n        }\\n        unordered_set<char> isPresent;\\n        string ans;\\n        for(char c : s) {\\n            if(isPresent.find(c)!=isPresent.end()) {\\n                freq[c]--;\\n                continue;\\n            }\\n            while(ans.size() > 0 && ans[ans.size() - 1] > c && freq[ans[ans.size() - 1]] > 0) {\\n                isPresent.erase(ans[ans.size() - 1]);\\n                ans.pop_back();\\n\\n            }\\n            ans.push_back(c);\\n            freq[c]--;\\n            isPresent.insert(c);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091736,
                "title": "c-short-and-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s, string res = \"\") {\\n  int cnt[26] = {}, used[26] = {};\\n  for (auto ch : s) ++cnt[ch - \\'a\\'];\\n  for (auto ch : s) {\\n    --cnt[ch - \\'a\\'];\\n    if (used[ch - \\'a\\']++ > 0) continue;\\n    while (!res.empty() && res.back() > ch && cnt[res.back() - \\'a\\'] > 0) {\\n      used[res.back() - \\'a\\'] = 0;\\n      res.pop_back();\\n    }\\n    res.push_back(ch);\\n  }\\n  return res;\\n }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s, string res = \"\") {\\n  int cnt[26] = {}, used[26] = {};\\n  for (auto ch : s) ++cnt[ch - \\'a\\'];\\n  for (auto ch : s) {\\n    --cnt[ch - \\'a\\'];\\n    if (used[ch - \\'a\\']++ > 0) continue;\\n    while (!res.empty() && res.back() > ch && cnt[res.back() - \\'a\\'] > 0) {\\n      used[res.back() - \\'a\\'] = 0;\\n      res.pop_back();\\n    }\\n    res.push_back(ch);\\n  }\\n  return res;\\n }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091637,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\n\\nThe intuition behind the problem is to remove duplicate letters from a given string while maintaining the order of the remaining characters and selecting the smallest lexicographically possible result. To achieve this, we use a stack to keep track of characters and a set to keep track of characters that have been seen. We also maintain a map to store the last occurrence index of each character in the input string. We iterate through the input string, and for each character, we check whether it should be added to the result or not by comparing it with the characters in the stack. If the character is smaller and there are more occurrences of it later in the string, we remove characters from the stack until it can safely add the current character. Finally, we construct the result string by popping characters from the stack in reverse order. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) Iterate through the input string to populate the last_occ map.\\n3) Iterate through the input string again:\\n- For each character \\'c\\', check if it has been seen.\\n- If \\'c\\' is not in the seen set:\\n- - While the stack is not empty, \\'c\\' is smaller than the top of the stack, and there are more occurrences of the top character later in the string, pop characters from the stack and remove them from the seen set until \\'c\\' can be safely added.\\n- - Add \\'c\\' to the seen set and push it onto the stack.\\n3) Construct the result string by popping characters from the stack in reverse order.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        stack<char> stack;\\n        set<char> seen;\\n        map<char,int> last_occ;\\n        for(int i=0;i<s.size();i++) last_occ[s[i]]=i;\\n        for(int i=0;i<s.size();i++){\\n            char c=s[i];\\n            if(seen.find(c)==seen.end()){\\n                while (!stack.empty() and c<stack.top() and \\n                i<last_occ[stack.top()]){\\n                    seen.erase(stack.top());\\n                    stack.pop();\\n                }\\n                seen.insert(c);\\n                stack.push(c);\\n            }\\n        }\\n        string res=\"\";\\n        while(!stack.empty()){\\n            res=stack.top()+res;\\n            stack.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        stack<char> stack;\\n        set<char> seen;\\n        map<char,int> last_occ;\\n        for(int i=0;i<s.size();i++) last_occ[s[i]]=i;\\n        for(int i=0;i<s.size();i++){\\n            char c=s[i];\\n            if(seen.find(c)==seen.end()){\\n                while (!stack.empty() and c<stack.top() and \\n                i<last_occ[stack.top()]){\\n                    seen.erase(stack.top());\\n                    stack.pop();\\n                }\\n                seen.insert(c);\\n                stack.push(c);\\n            }\\n        }\\n        string res=\"\";\\n        while(!stack.empty()){\\n            res=stack.top()+res;\\n            stack.pop();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091592,
                "title": "cpp-solution-with-line-by-line-explanation",
                "content": "\\n# Approach\\n* First get the last index of all the elements so we can get smallest lexiographic order\\n* We intialise a stack and a visited vector\\n* if the element is already visted we skip it as it will be already in the stack\\n* Otherwise we check the top element of the stack and check if it is smaller than the current element \\n    *   if it is we check whether the top element can be found after the current element by using the index array and comparing indexes of current element and the last index of top element of stack\\n* We add the element to the stack and mark it as visited\\n* Then we assign answer as reverse order of the string\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> index(26, 0); // Initialize an index vector to store the last occurrence index of each character in the string.\\n        \\n        // Populate the index vector with the last occurrence index of each character.\\n        for (int i = 0; i < s.size(); i++) {\\n            index[s[i] - \\'a\\'] = i;\\n        }\\n        \\n        vector<bool> visited(26, false); // Initialize a visited vector to keep track of visited characters.\\n        stack<char> st; // Initialize a stack to store characters in the desired order.\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            if (visited[s[i] - \\'a\\']) continue; // Skip characters that have already been visited.\\n            \\n            // While the stack is not empty, the current character is smaller than the top character in the stack,\\n            // and there are more occurrences of the top character later in the string, pop characters from the stack.\\n            while (!st.empty() && st.top() > s[i] && index[st.top() - \\'a\\'] > i) {\\n                visited[st.top() - \\'a\\'] = false; // Mark the character as unvisited.\\n                st.pop(); // Pop the top character from the stack.\\n            }\\n            \\n            st.push(s[i]); // Push the current character onto the stack.\\n            visited[s[i] - \\'a\\'] = true; // Mark the current character as visited.\\n        }\\n        \\n        string ans = \"\";\\n        \\n        // Pop characters from the stack to construct the final answer string.\\n        while (!st.empty()) {\\n            ans = st.top() + ans;\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> index(26, 0); // Initialize an index vector to store the last occurrence index of each character in the string.\\n        \\n        // Populate the index vector with the last occurrence index of each character.\\n        for (int i = 0; i < s.size(); i++) {\\n            index[s[i] - \\'a\\'] = i;\\n        }\\n        \\n        vector<bool> visited(26, false); // Initialize a visited vector to keep track of visited characters.\\n        stack<char> st; // Initialize a stack to store characters in the desired order.\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            if (visited[s[i] - \\'a\\']) continue; // Skip characters that have already been visited.\\n            \\n            // While the stack is not empty, the current character is smaller than the top character in the stack,\\n            // and there are more occurrences of the top character later in the string, pop characters from the stack.\\n            while (!st.empty() && st.top() > s[i] && index[st.top() - \\'a\\'] > i) {\\n                visited[st.top() - \\'a\\'] = false; // Mark the character as unvisited.\\n                st.pop(); // Pop the top character from the stack.\\n            }\\n            \\n            st.push(s[i]); // Push the current character onto the stack.\\n            visited[s[i] - \\'a\\'] = true; // Mark the current character as visited.\\n        }\\n        \\n        string ans = \"\";\\n        \\n        // Pop characters from the stack to construct the final answer string.\\n        while (!st.empty()) {\\n            ans = st.top() + ans;\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091264,
                "title": "c-easy-solution",
                "content": "# Intuition\\nWe will use greedy approach.If after removing the element we are getting smaller element we will remove it else we will leave it.\\n\\n\\nApproach is mentioned below. Please go through it and then I will recommend to dry run the code for better understanding...\\nIn whichever line you have doubt please comment that and try to run.\\n# Approach\\n\\nFirst we will count the frequency for every element.Then we will declare a stack (which will be monotonic (increasing)).Now we will traverse through our given string and we will remove existing element of stack based on following two condition\\ni.) new element is lexiographically smaller then element present in stack.\\nii.) element present in stack shoulb be removeable (it\\'s frequency should be greater than 1).\\n\\nNow we need to update our freq table accordingly..If we are popping a element from stack we should decrease it\\'s freq because now we excluded it and  also when we are skipping element we should decrease the freq for future use.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n0(n), where n is size of given string\\n\\n- Space complexity:\\n0(1), as maximum no of element we can push in stack is 26.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int n = s.size();\\n        vector<int> freq(26,0);\\n        for(int i=0;i<n;i++){\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        stack<char> st;\\n        vector<bool> check(26,false); \\n        for(int i=0;i<n;i++){\\n            char temp = s[i];\\n            if(check[temp-\\'a\\']){\\n                freq[temp-\\'a\\']--;\\n                continue;\\n            }\\n            while(!st.empty() && temp<st.top() && freq[st.top()-\\'a\\']>1){\\n                freq[st.top()-\\'a\\']--;\\n                check[st.top()-\\'a\\'] = false;\\n                st.pop();            \\n            }\\n            st.push(temp);\\n            check[temp-\\'a\\'] = true;\\n        }\\n\\n        string ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int n = s.size();\\n        vector<int> freq(26,0);\\n        for(int i=0;i<n;i++){\\n            freq[s[i]-\\'a\\']++;\\n        }\\n        stack<char> st;\\n        vector<bool> check(26,false); \\n        for(int i=0;i<n;i++){\\n            char temp = s[i];\\n            if(check[temp-\\'a\\']){\\n                freq[temp-\\'a\\']--;\\n                continue;\\n            }\\n            while(!st.empty() && temp<st.top() && freq[st.top()-\\'a\\']>1){\\n                freq[st.top()-\\'a\\']--;\\n                check[st.top()-\\'a\\'] = false;\\n                st.pop();            \\n            }\\n            st.push(temp);\\n            check[temp-\\'a\\'] = true;\\n        }\\n\\n        string ans;\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090699,
                "title": "daily-leetcoding-challenge-september-day-26",
                "content": "This problem is the Daily LeetCoding Challenge for September, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicate-letters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Greedy - Solving Letter by Letter\n\n  \n**Approach 2:** Greedy - Solving with Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicate-letters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3538628,
                "title": "316-remove-duplicate-letters",
                "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int>val(26,0);\\n        map<char,int>m;\\n        string ans=\"\";\\n        for(auto i:s)\\n           m[i]++;\\n        \\n        for(int i=0;i<s.size();++i){\\n            m[s[i]]--;\\n            if(val[s[i]-\\'a\\']) continue;\\n            int j=ans.size()-1;\\n            while(j>=0 && m[ans[j]]>0 && s[i]<ans[j]){\\n                val[ans[j]-\\'a\\']=0;\\n                ans.pop_back();\\n                j--;\\n            }\\n            if(val[s[i]-\\'a\\']==0){\\n                val[s[i]-\\'a\\']=1;\\n                ans+=s[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int>val(26,0);\\n        map<char,int>m;\\n        string ans=\"\";\\n        for(auto i:s)\\n           m[i]++;\\n        \\n        for(int i=0;i<s.size();++i){\\n            m[s[i]]--;\\n            if(val[s[i]-\\'a\\']) continue;\\n            int j=ans.size()-1;\\n            while(j>=0 && m[ans[j]]>0 && s[i]<ans[j]){\\n                val[ans[j]-\\'a\\']=0;\\n                ans.pop_back();\\n                j--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3230230,
                "title": "brute-force-stack-solution-noob-explanation",
                "content": "# Brute Force Yucky solution\\n## Intuition\\n- Basically consider each letter from left to right, to be included or not in the result until you get to the last character of the input string. For each choice, you update your builder string\\n\\n## Approach\\n- Start at index `i=0` and perform a recursive call based on these conditions:\\n```\\n- if charAt(i) was chosen already in previous recursion, skip.\\n    just recurse to i+1 without modifying anything\\n- if charAt(i) has a duplicate\\nTwo choices:\\n    include the charAt(i) in the result, then recurse to i+1\\n    exclude the charAt(i) in the result, then recurse to i+1\\n- if charAt(i) has no duplicate\\n    no choice but to include it in result. then recurse to i+1\\n```\\n- Keep doing the above recursive calls until you get to a level of recursion where `i >= n`. When you reach this, update global result, with chosen characters in the string builder so far\\n\\n## Complexity\\n- Time complexity:\\nO(2^n) - two possibilities every recursion: Either we choose the duplicate character and include in result, or we dont include it\\n\\n- Space complexity:\\nO(n) recursion stack depth is at most O(n) I think.... and we need to store size n in a map\\n\\n## Code\\n```\\nclass Solution {\\n  String result = \"\";\\n  public String removeDuplicateLetters(String s) {\\n    result = s;\\n    int n = s.length();\\n    Map<Character, Integer> duplicates = new HashMap<>();\\n    Map<Character, Integer> count = new HashMap<>();\\n    for (int i = 0; i < n; i++) {\\n      char letter = s.charAt(i);\\n      count.put(letter, count.getOrDefault(letter, 0) + 1);\\n      if (count.get(letter) > 1)\\n        duplicates.put(letter, i);\\n    }\\n\\n    if (duplicates.size() == 0)\\n      return s;\\n\\n    Set<Character> chosen = new HashSet();\\n    recurse(s, new StringBuilder(), 0, chosen, duplicates);\\n    return result;\\n  }\\n\\n  private void recurse(\\n    String s, \\n    StringBuilder builder, \\n    int i, \\n    Set<Character> chosen, \\n    Map<Character, Integer> duplicates\\n  ) {\\n    int n = s.length();\\n    if (i >= n) {\\n      String tmp = builder.toString();\\n      if (tmp.length() < result.length() || tmp.compareTo(result) < 0)\\n        result = tmp;\\n      return;\\n    }\\n\\n    char letter = s.charAt(i);\\n    boolean isUnique = !duplicates.containsKey(letter);\\n    if (chosen.contains(letter)) {\\n      recurse(s, builder, i + 1, chosen, duplicates);\\n    } else if (isUnique) {\\n      builder.append(letter);\\n      chosen.add(letter);\\n      recurse(s, builder, i + 1, chosen, duplicates);\\n      pop(builder);\\n      chosen.remove(letter);\\n    } else { // duplicates.containsKey(letter)\\n      builder.append(letter);\\n      chosen.add(letter);\\n      recurse(s, builder, i + 1, chosen, duplicates);\\n      chosen.remove(letter);\\n      pop(builder);\\n\\n      // check last index appearance of duplicate letter\\n      // can only skip this letter if there are remaining duplicates left\\n      int lastIndex = duplicates.get(letter);\\n      if (i < lastIndex)\\n        recurse(s, builder, i + 1, chosen, duplicates);\\n    }\\n  }\\n\\n  private void pop(StringBuilder sb) {\\n    sb.deleteCharAt(sb.length() - 1);\\n  }\\n}\\n```\\n\\n# Bootiful/Beautiful stack solution\\n## Intuition\\n- First figure out how to remove all duplicates. And then figure out how to tweak the algorithm so that you always consider lexicographically smaller characters. Use a stack to maintain a \"smaller lexicographic ordering\" by checking last element pushed to the stack and current iteration.\\n\\n## Approach\\n- Create a mapping of letter to lastIndex\\n- Iterate input string from left to right. For every character `charAt(i)`, you have two possibilities\\n```\\n    Case 1: Character has no duplicates  - in which case you just need to add this to the result\\n    Case 2: Character has duplicates\\n```\\n- Case 2 is the tricky part\\n```\\n    For Case 2, either of the two things will happen:\\n      - result is empty/nothing is selected yet. Just add charAt(i) to result\\n                             previous\\n                                v\\n      - resultSoFar = [ . . . . .    ]\\n                                  ^\\n                                charAt(i)\\n\\n        if previous is \"smaller\" than charAt(i), we just add charAt(i) to resultSoFar\\n          because we maintain lexicographic order\\n        if previous is \"bigger\" than charAt(i), we keep popping previous \\n          (top of stack), until previous is \"smaller\" and insert charAt(i)\\n```\\nTheres a couple more checks for case 2 (making sure we dont run into empty stack exception, and its not the last occurrence of the previous - in other words, previous must be included and has no remaining duplicates on the right of i - this is what the \"lastOccurence map\" is used for).\\n\\n## Complexity\\n- Time complexity:\\nO(n) - iterate input string from left to right\\n\\n- Space complexity:\\nO(n) - stack space\\n\\n## Code\\n```\\nclass Solution {\\n  public String removeDuplicateLetters(String s) {\\n    int n = s.length();\\n    Map<Character, Integer> lastOccurence = new HashMap<>(); \\n    for (int i = 0; i < n; i++)\\n      lastOccurence.put(s.charAt(i), i);\\n    Stack<Character> stack = new Stack<>();  \\n    Set<Character> seen = new HashSet<>();\\n    for (int i = 0; i < n; i++) {  \\n      char letter = s.charAt(i); \\n      if (seen.contains(letter)) \\n        continue;\\n\\n      // previous character in stack is \"bigger\" than current letter\\n      // and its not the last occurrence\\n      while (!stack.isEmpty()  \\n        && stack.peek().compareTo(letter) > 0      \\n        && lastOccurence.get(stack.peek()) > i) {  \\n        char removed = stack.pop();  // there are more occurences of previous letter, pop stack \\n        seen.remove(removed);\\n      }\\n\\n      stack.push(letter); \\n      seen.add(letter); \\n    }\\n\\n    char[] result = new char[stack.size()];\\n    for (int i = stack.size() - 1; i >= 0; i--)\\n      result[i] = stack.pop();\\n    return new String(result);\\n  }\\n}\\n\\n```\\n\\nOr you can just watch this video:\\nhttps://www.youtube.com/watch?v=2ayws5Y-WM4&ab_channel=SaiAnishMalla",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\n- if charAt(i) was chosen already in previous recursion, skip.\\n    just recurse to i+1 without modifying anything\\n- if charAt(i) has a duplicate\\nTwo choices:\\n    include the charAt(i) in the result, then recurse to i+1\\n    exclude the charAt(i) in the result, then recurse to i+1\\n- if charAt(i) has no duplicate\\n    no choice but to include it in result. then recurse to i+1\\n```\n```\\nclass Solution {\\n  String result = \"\";\\n  public String removeDuplicateLetters(String s) {\\n    result = s;\\n    int n = s.length();\\n    Map<Character, Integer> duplicates = new HashMap<>();\\n    Map<Character, Integer> count = new HashMap<>();\\n    for (int i = 0; i < n; i++) {\\n      char letter = s.charAt(i);\\n      count.put(letter, count.getOrDefault(letter, 0) + 1);\\n      if (count.get(letter) > 1)\\n        duplicates.put(letter, i);\\n    }\\n\\n    if (duplicates.size() == 0)\\n      return s;\\n\\n    Set<Character> chosen = new HashSet();\\n    recurse(s, new StringBuilder(), 0, chosen, duplicates);\\n    return result;\\n  }\\n\\n  private void recurse(\\n    String s, \\n    StringBuilder builder, \\n    int i, \\n    Set<Character> chosen, \\n    Map<Character, Integer> duplicates\\n  ) {\\n    int n = s.length();\\n    if (i >= n) {\\n      String tmp = builder.toString();\\n      if (tmp.length() < result.length() || tmp.compareTo(result) < 0)\\n        result = tmp;\\n      return;\\n    }\\n\\n    char letter = s.charAt(i);\\n    boolean isUnique = !duplicates.containsKey(letter);\\n    if (chosen.contains(letter)) {\\n      recurse(s, builder, i + 1, chosen, duplicates);\\n    } else if (isUnique) {\\n      builder.append(letter);\\n      chosen.add(letter);\\n      recurse(s, builder, i + 1, chosen, duplicates);\\n      pop(builder);\\n      chosen.remove(letter);\\n    } else { // duplicates.containsKey(letter)\\n      builder.append(letter);\\n      chosen.add(letter);\\n      recurse(s, builder, i + 1, chosen, duplicates);\\n      chosen.remove(letter);\\n      pop(builder);\\n\\n      // check last index appearance of duplicate letter\\n      // can only skip this letter if there are remaining duplicates left\\n      int lastIndex = duplicates.get(letter);\\n      if (i < lastIndex)\\n        recurse(s, builder, i + 1, chosen, duplicates);\\n    }\\n  }\\n\\n  private void pop(StringBuilder sb) {\\n    sb.deleteCharAt(sb.length() - 1);\\n  }\\n}\\n```\n```\\n    Case 1: Character has no duplicates  - in which case you just need to add this to the result\\n    Case 2: Character has duplicates\\n```\n```\\n    For Case 2, either of the two things will happen:\\n      - result is empty/nothing is selected yet. Just add charAt(i) to result\\n                             previous\\n                                v\\n      - resultSoFar = [ . . . . .    ]\\n                                  ^\\n                                charAt(i)\\n\\n        if previous is \"smaller\" than charAt(i), we just add charAt(i) to resultSoFar\\n          because we maintain lexicographic order\\n        if previous is \"bigger\" than charAt(i), we keep popping previous \\n          (top of stack), until previous is \"smaller\" and insert charAt(i)\\n```\n```\\nclass Solution {\\n  public String removeDuplicateLetters(String s) {\\n    int n = s.length();\\n    Map<Character, Integer> lastOccurence = new HashMap<>(); \\n    for (int i = 0; i < n; i++)\\n      lastOccurence.put(s.charAt(i), i);\\n    Stack<Character> stack = new Stack<>();  \\n    Set<Character> seen = new HashSet<>();\\n    for (int i = 0; i < n; i++) {  \\n      char letter = s.charAt(i); \\n      if (seen.contains(letter)) \\n        continue;\\n\\n      // previous character in stack is \"bigger\" than current letter\\n      // and its not the last occurrence\\n      while (!stack.isEmpty()  \\n        && stack.peek().compareTo(letter) > 0      \\n        && lastOccurence.get(stack.peek()) > i) {  \\n        char removed = stack.pop();  // there are more occurences of previous letter, pop stack \\n        seen.remove(removed);\\n      }\\n\\n      stack.push(letter); \\n      seen.add(letter); \\n    }\\n\\n    char[] result = new char[stack.size()];\\n    for (int i = stack.size() - 1; i >= 0; i--)\\n      result[i] = stack.pop();\\n    return new String(result);\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2921683,
                "title": "using-stack-o-n-very-easy-to-understand-visually-explained-using-handwritten-diagram",
                "content": "\\n# heading\\n\\n **FAVOUR :: FOLLOW PICTURE SHARED ALONG WITH CODE **\\n\\n![WhatsApp Image 2022-12-17 at 18.16.46.jpg](https://assets.leetcode.com/users/images/846cd8d3-b169-45c7-8e17-7fecbb281d3e_1671281786.9477136.jpeg)\\n\\n# Intuition\\nUsing stack to maintain result in\\nthe smallest in lexicographical order.\\nUsing frequency vector for not storing repeated elements .\\nUsing boolean vector storing the data that we alreay taken character s[i] in  our stack or not .\\n\\n\\n\\n# Approach\\n\\n1. Freq vector is made to store different frequency of characters present in our array.\\n\\n2. bool vector to assign true if character is already pushed in array and false if not pushed or had been poped while maintaining lexicographical order .\\n\\n3. For loop is used for traversing the given string s. \\n\\n4. If we find that given element is alredy in seen vector(i.e. true value) then will reduce the frequency of that element in freq vector.\\n\\n5. Now follow the code and picture shared simultaneously.\\n  \\n\\n# Complexity\\n- Time complexity:\\n\\nO(1)-AS WE ARE TRAVERSING STRING ONLY ONCE . AS RANDOM ACCESS IN SEEN AND FREQ ARRAY TAKE O(1) TIME .ALSO FOR ACCESSING STACK st-O(1).\\n\\n- Space complexity:\\nO(1)-FREQ VECTOR\\nO(1)-SEEN VECTOR\\nO(N)-FOR ST STACK AND ANS STRING \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<char>freq(26,0);\\n        for(int i=0;i<s.size();i++)freq[s[i]-\\'a\\']++;\\n\\n        stack<char> st;\\n        vector<bool>seen(26,false);\\n\\n        for(int i =0;i<s.size();i++){\\n\\n            if(seen[s[i]-\\'a\\']){\\n                freq[s[i]-\\'a\\']--;\\n            }\\n\\n        else {\\n\\n        while(st.size() && st.top()>s[i] && freq[st.top()-\\'a\\']>0)\\n        {\\n            seen[st.top()-\\'a\\']=false;\\n            st.pop();\\n        }\\n\\n        st.push(s[i]);\\n        freq[s[i]-\\'a\\']--;\\n        seen[s[i]-\\'a\\']=true;\\n        \\n        }\\n\\n    }\\n        string ans =\"\";\\n\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<char>freq(26,0);\\n        for(int i=0;i<s.size();i++)freq[s[i]-\\'a\\']++;\\n\\n        stack<char> st;\\n        vector<bool>seen(26,false);\\n\\n        for(int i =0;i<s.size();i++){\\n\\n            if(seen[s[i]-\\'a\\']){\\n                freq[s[i]-\\'a\\']--;\\n            }\\n\\n        else {\\n\\n        while(st.size() && st.top()>s[i] && freq[st.top()-\\'a\\']>0)\\n        {\\n            seen[st.top()-\\'a\\']=false;\\n            st.pop();\\n        }\\n\\n        st.push(s[i]);\\n        freq[s[i]-\\'a\\']--;\\n        seen[s[i]-\\'a\\']=true;\\n        \\n        }\\n\\n    }\\n        string ans =\"\";\\n\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114250,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        unordered_map<char,int> freq;\\n        for(auto it :s){\\n            freq[it]++;\\n        }\\n        \\n        vector<bool> visited (26,false);\\n        stack<char> st;\\n        \\n        \\n        for(int i=0;i<s.length();i++){\\n            freq[s[i]]--;\\n            \\n            if(visited[s[i]-\\'a\\']){\\n                continue;\\n            }\\n            while(!st.empty()&& s[i]<st.top() && freq[st.top()]>0){\\n                visited[st.top()-\\'a\\']=false;\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n            visited [s[i]-\\'a\\']=true;\\n        }\\n        string res =\"\";\\n        while(!st.empty()){\\n            res.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        unordered_map<char,int> freq;\\n        for(auto it :s){\\n            freq[it]++;\\n        }\\n        \\n        vector<bool> visited (26,false);\\n        stack<char> st;\\n        \\n        \\n        for(int i=0;i<s.length();i++){\\n            freq[s[i]]--;\\n            \\n            if(visited[s[i]-\\'a\\']){\\n                continue;\\n            }\\n            while(!st.empty()&& s[i]<st.top() && freq[st.top()]>0){\\n                visited[st.top()-\\'a\\']=false;\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n            visited [s[i]-\\'a\\']=true;\\n        }\\n        string res =\"\";\\n        while(!st.empty()){\\n            res.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(res.begin(),res.end());\\n        return res;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2011186,
                "title": "javascript-o-n-beats-87-stack",
                "content": "![image](https://assets.leetcode.com/users/images/89957c76-c426-4a00-b1a8-3844129bb82a_1651768428.1228964.png)\\n\\nTime complexity: O(N)\\nSpace complexity: O(1)\\n\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeDuplicateLetters = function(s) {\\n    const stack = [];\\n    const seen = {};\\n    const occurrence = {};\\n    for(let j = 0; j < s.length; j++) {\\n        occurrence[s[j]] = j;\\n    }\\n    for(let i = 0; i < s.length; i++) {\\n        const char = s[i];\\n        if(seen[char]) {\\n            continue;\\n        }\\n        while(stack.length > 0 && stack[stack.length - 1] > char && occurrence[stack[stack.length - 1]] > i) {\\n            const temp = stack.pop();\\n            seen[temp] = false;\\n        }\\n        seen[char] = true;\\n        stack.push(char);\\n    }\\n   \\n    return stack.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Monotonic Stack"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeDuplicateLetters = function(s) {\\n    const stack = [];\\n    const seen = {};\\n    const occurrence = {};\\n    for(let j = 0; j < s.length; j++) {\\n        occurrence[s[j]] = j;\\n    }\\n    for(let i = 0; i < s.length; i++) {\\n        const char = s[i];\\n        if(seen[char]) {\\n            continue;\\n        }\\n        while(stack.length > 0 && stack[stack.length - 1] > char && occurrence[stack[stack.length - 1]] > i) {\\n            const temp = stack.pop();\\n            seen[temp] = false;\\n        }\\n        seen[char] = true;\\n        stack.push(char);\\n    }\\n   \\n    return stack.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1861190,
                "title": "c-deque-time-o-n-space-o-1",
                "content": "```C++\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        unordered_map<char,int> mp; //mapping char into its maximum index\\n        unordered_map<char,int> in_stack_mp; //in_stack_mp[i]==1 iff char i in deque\\n        deque<int> q;  //use deque as stack but return the made string by using deque as queue\\n        int n = s.length();\\n        for(int i = 0; i<n; i++) mp[s[i]] = i; //figure out maximum index of each character in s\\n        for(int i = 0; i<n; i++) { \\n            char c = s[i];\\n            if(in_deque_mp[c]==0) {\\n                while(!q.empty() && c<q.back() && mp[q.back()]>i) {\\n                    in_deque_mp[q.back()]=0;\\n                    q.pop_back();\\n                }\\n                in_deque_mp[c] = 1;\\n                q.push_back(c);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!q.empty()) {\\n            ans.push_back(q.front());\\n            q.pop_front();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n        \\n\\n**Time Complexity O(n)** \\nAs you can see, only one loop -> O(n)\\n**Space Complexity O(1)**\\nmp, in_stack_mp use O(1)\\nq also use O(1) because it can not put same element \\ninto same deque by this code logic.\\nThe return string ans is also O(1). \\n\\n",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        unordered_map<char,int> mp; //mapping char into its maximum index\\n        unordered_map<char,int> in_stack_mp; //in_stack_mp[i]==1 iff char i in deque\\n        deque<int> q;  //use deque as stack but return the made string by using deque as queue\\n        int n = s.length();\\n        for(int i = 0; i<n; i++) mp[s[i]] = i; //figure out maximum index of each character in s\\n        for(int i = 0; i<n; i++) { \\n            char c = s[i];\\n            if(in_deque_mp[c]==0) {\\n                while(!q.empty() && c<q.back() && mp[q.back()]>i) {\\n                    in_deque_mp[q.back()]=0;\\n                    q.pop_back();\\n                }\\n                in_deque_mp[c] = 1;\\n                q.push_back(c);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!q.empty()) {\\n            ans.push_back(q.front());\\n            q.pop_front();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860761,
                "title": "solution-swift-remove-duplicate-letters",
                "content": "```swift\\nclass Solution {\\n    func removeDuplicateLetters(_ s: String) -> String {\\n        var count: [Character:Int] = [:]\\n        s.forEach { count[$0] = count[$0, default: 0] + 1 }\\n        var stack: [Character] = []\\n        var visited: Set<Character> = []\\n        for c in s {\\n            count[c] = count[c, default: 0] - 1\\n            if visited.contains(c) { continue }\\n            while let last = stack.last, c < last, count[last, default: 0] > 0 {\\n                stack.removeLast()\\n                visited.remove(last)\\n            }\\n            stack.append(c)\\n            visited.insert(c)\\n        }\\n        return String(stack)\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.020 (0.022) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.removeDuplicateLetters(\"bcabc\")\\n        XCTAssertEqual(value, \"abc\")\\n    }\\n    \\n    func test1() {\\n        let value = solution.removeDuplicateLetters(\"cbacdcbc\")\\n        XCTAssertEqual(value, \"acdb\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func removeDuplicateLetters(_ s: String) -> String {\\n        var count: [Character:Int] = [:]\\n        s.forEach { count[$0] = count[$0, default: 0] + 1 }\\n        var stack: [Character] = []\\n        var visited: Set<Character> = []\\n        for c in s {\\n            count[c] = count[c, default: 0] - 1\\n            if visited.contains(c) { continue }\\n            while let last = stack.last, c < last, count[last, default: 0] > 0 {\\n                stack.removeLast()\\n                visited.remove(last)\\n            }\\n            stack.append(c)\\n            visited.insert(c)\\n        }\\n        return String(stack)\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.removeDuplicateLetters(\"bcabc\")\\n        XCTAssertEqual(value, \"abc\")\\n    }\\n    \\n    func test1() {\\n        let value = solution.removeDuplicateLetters(\"cbacdcbc\")\\n        XCTAssertEqual(value, \"acdb\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859922,
                "title": "java-c-solution",
                "content": "How\\'s going Ladies - n - Gentlemen, today we are going to solve another coolest problem i.e. Remove Duplicate Letters\\n\\nWhat the problem statement is saying,\\n\\nGiven a string s, remove duplicate letters so that every letter appears once and only once. \\nYou must make sure your result is the smallest in lexicographical order among all possible results.\\nLet\\'s take one example in order to understand it:-\\nInput :- \"cbacdcbc\"\\nOutput :- \"acdb\"\\n\\nNow, your first Question is which Data Structure do we use in order to solve this problem?? Well, let\\'s have a look at the input firstOfAll\\n\\nFirst Of all, we have to pick the character\\'s if it is not already visited. If, that\\'s the case we\\'ll try to pick these character\\'s. We\\'ll also make sure, the previously picked character is smaller then the current character in order to maintain lexicographically order. But, how we can check the previously picked character is best for!! And the answer is Stack!!\\n\\nWhat we\\'ll do, use the stack to keep track of selected character\\'s. We try to put the character\\'s only once & maintain the lexicographicall smallest one. So, how we do that :-\\n\\nIf the stack is empty, we\\'ll put the current character into our stack\\nWe\\'ll also keep here boolean array which will mark, whether we have seen this character or not. So, that if we are getting again the same character and we have already seen that. We\\'ll ignore that character.\\nSo, the length of boolean array will be 26\\nLet\\'s Undertsand it\\'s working\\n\\nFirst we put character c into our stack and mark it as true\\n\\nThen we come to next character i.e. b we check is b < c to maintain lexicographically order. Yes b is samller then c we\\'ll remove it from the stack.\\n\\nBut before removing we have to check that, is c more present in our string. So, how will we quickly check that for that we\\'ll keep one more Array which will keep track of last index of all the character\\'s present in our string\\n\\nSo, we see that c exists on 7th index.\\n\\nWe\\'ll remove c from the stack & don\\'t forgot to mark c in boolean array from true to false\\n\\nNow add b into our stack. ANd mark b in boolean array as true\\n\\nNow next character is a which is smaller then b & do the same process of checking if it exists somewhere in array & if so, remove it from stack update boolean to false. And put a into the stack. And in boolean array mark it as true.\\n\\nLet\\'s add c in the stack mark it as true & c > a so carry on....\\n\\nLet\\'s add d in the stack mark it as true & d > c so carry on....\\n\\nNow we encounter c which is already visited so, carry on....\\n\\nLet\\'s add b in the stack mark it as true & b < d so carry on....\\n\\nNow we encounter c which is already visited so, carry on....\\n\\nEnd of the string.\\n\\nNow whatever character we have present in our stack, take them out. i.e. bdca now reverse it acdb and this is our smallest lexicographically string\\n\\nLet\\'s understand it visually :- You can download all the images from here G-Drive\\n\\nimage\\n\\nI hope you got it Let\\'s code it up:-\\n\\nJava\\n\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        int[] lastIndex = new int[26];\\n        for (int i = 0; i < s.length(); i++){\\n            lastIndex[s.charAt(i) - \\'a\\'] = i; // track the lastIndex of character presence\\n        }\\n        \\n        boolean[] seen = new boolean[26]; // keep track seen\\n        Stack<Integer> st = new Stack();\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            int curr = s.charAt(i) - \\'a\\';\\n            if (seen[curr]) continue; // if seen continue as we need to pick one char only\\n            while (!st.isEmpty() && st.peek() > curr && i < lastIndex[st.peek()]){\\n                seen[st.pop()] = false; // pop out and mark unseen\\n            }\\n            st.push(curr); // add into stack\\n            seen[curr] = true; // mark seen\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n        while (!st.isEmpty())\\n            sb.append((char) (st.pop() + \\'a\\'));\\n        return sb.reverse().toString();\\n    }\\n}\\nC++\\n\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> lastIndex(26, 0);\\n        for (int i = 0; i < s.length(); i++){\\n            lastIndex[s[i] - \\'a\\'] = i; // track the lastIndex of character presence\\n        }\\n        \\n        vector<bool> seen(26, false); // keep track seen\\n        stack<char> st;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            int curr = s[i] - \\'a\\';\\n            if (seen[curr]) continue; // if seen continue as we need to pick one char only\\n            while(st.size() > 0 && st.top() > s[i] && i < lastIndex[st.top() - \\'a\\']){\\n                seen[st.top() - \\'a\\'] = false; // pop out and mark unseen\\n                st.pop();\\n            }\\n            st.push(s[i]); // add into stack\\n            seen[curr] = true; // mark seen\\n        }\\n        \\n        string ans = \"\";\\n        while (st.size() > 0){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\nANALYSIS :-\\n\\nTime Complexity :- BigO(N)\\n\\nSpace Complexity :- BigO(N)\\n\\nIn the End, Wishing you A Happy Holi !!\\n\\n**Bura Na Mano Holi Hn**\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "class Solution {\\n    public String removeDuplicateLetters(String s) {\\n        int[] lastIndex = new int[26];\\n        for (int i = 0; i < s.length(); i++){\\n            lastIndex[s.charAt(i) - \\'a\\'] = i; // track the lastIndex of character presence\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1859874,
                "title": "c-2-solutions-using-freq-last-index-w-o-stack-o-n-time-easy-clean-code",
                "content": "**1. Frequency**\\n```\\n\\tstring removeDuplicateLetters(string s) {\\n        \\n        int f[26]={0};\\n        unordered_set<char> vis;\\n        int i,n=s.length();\\n        \\n        string ans=\"\";\\n        \\n        for(char ch:s)\\n            f[ch-\\'a\\']++;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            char ch=s[i];\\n            f[ch-\\'a\\']--;\\n            \\n            if(vis.find(ch)!=vis.end())\\n                continue;\\n            \\n            if(ans.size()==0 || ch>ans.back())\\n            {\\n                ans+=ch;\\n                vis.insert(ch);\\n            }\\n            else\\n            {\\n                if(f[ans.back()-\\'a\\']>0)\\n                {\\n                    vis.erase(ans.back());\\n                    ans.pop_back();     \\n                    i--;\\n                    f[ch-\\'a\\']++;\\n                }\\n                else\\n                {\\n                    ans+=ch;\\n                    vis.insert(ch);   \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n**2. Last Index**\\n```\\n\\tstring removeDuplicateLetters(string s)\\n\\t{\\n        int i,n=s.length();\\n        string ans=\"\";\\n        unordered_map<char,int> lastin;\\n        unordered_set<char> vis;\\n        \\n        for(i=0;i<n;i++)\\n            lastin[s[i]]=i;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(vis.find(s[i])!=vis.end())\\n                continue;\\n            \\n            if(!ans.empty() && ans.back()>s[i] && lastin[ans.back()]>i)\\n            {\\n                vis.erase(ans.back());\\n                ans.pop_back();\\n                i--;\\n            }\\n            else\\n            {\\n                ans+=s[i];\\n                vis.insert(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n\\uD83D\\uDC9B\\uD83D\\uDDA4\\uD83D\\uDC9C\\uD83E\\uDDE1 **And a veryyy Happyyy Holiii to everyone !!!!!!** \\u2764\\uD83D\\uDC9A\\uD83D\\uDC99\\uD83E\\uDD0E\\uD83E\\uDD0D\\n\\n**Do share your views & upvote if you like !!** \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n\\tstring removeDuplicateLetters(string s) {\\n        \\n        int f[26]={0};\\n        unordered_set<char> vis;\\n        int i,n=s.length();\\n        \\n        string ans=\"\";\\n        \\n        for(char ch:s)\\n            f[ch-\\'a\\']++;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            char ch=s[i];\\n            f[ch-\\'a\\']--;\\n            \\n            if(vis.find(ch)!=vis.end())\\n                continue;\\n            \\n            if(ans.size()==0 || ch>ans.back())\\n            {\\n                ans+=ch;\\n                vis.insert(ch);\\n            }\\n            else\\n            {\\n                if(f[ans.back()-\\'a\\']>0)\\n                {\\n                    vis.erase(ans.back());\\n                    ans.pop_back();     \\n                    i--;\\n                    f[ch-\\'a\\']++;\\n                }\\n                else\\n                {\\n                    ans+=ch;\\n                    vis.insert(ch);   \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\n```\\n\\tstring removeDuplicateLetters(string s)\\n\\t{\\n        int i,n=s.length();\\n        string ans=\"\";\\n        unordered_map<char,int> lastin;\\n        unordered_set<char> vis;\\n        \\n        for(i=0;i<n;i++)\\n            lastin[s[i]]=i;\\n        \\n        for(i=0;i<n;i++)\\n        {\\n            if(vis.find(s[i])!=vis.end())\\n                continue;\\n            \\n            if(!ans.empty() && ans.back()>s[i] && lastin[ans.back()]>i)\\n            {\\n                vis.erase(ans.back());\\n                ans.pop_back();\\n                i--;\\n            }\\n            else\\n            {\\n                ans+=s[i];\\n                vis.insert(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1697913,
                "title": "easy-intuitive-python-solution",
                "content": "```\\nfrom collections import Counter, defaultdict\\n\\n\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        counts = Counter(s)  # Count number of occurrences of each char in s\\n        used = defaultdict(bool)  # Find if specific char is already pushed onto stack\\n        mono_stack = []  # Monotonically Increasing Stack (Top elements > Bottom elements)\\n\\n        for char in s:\\n            # Always decrement count of current char\\n            counts[char] -= 1\\n\\n            # If char is already used before, no need to append it again\\n            if used[char]:\\n                continue\\n\\t\\t\\t\\t\\n            # Check if char is less than top element of stack (if so, it cannot be appended on the top)\\n            # And pop top char only if there are more occurrences of it left in the string\\n            while mono_stack and char <= mono_stack[-1] and counts[mono_stack[-1]] != 0:\\n                this_char = mono_stack.pop(-1)\\n                used[this_char] = False\\n\\n            # Append current char onto the stack\\n            used[char] = True\\n            mono_stack.append(char)\\n\\n        # Elements of the stack is the final string\\n        return \"\".join(mono_stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Monotonic Stack"
                ],
                "code": "```\\nfrom collections import Counter, defaultdict\\n\\n\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        counts = Counter(s)  # Count number of occurrences of each char in s\\n        used = defaultdict(bool)  # Find if specific char is already pushed onto stack\\n        mono_stack = []  # Monotonically Increasing Stack (Top elements > Bottom elements)\\n\\n        for char in s:\\n            # Always decrement count of current char\\n            counts[char] -= 1\\n\\n            # If char is already used before, no need to append it again\\n            if used[char]:\\n                continue\\n\\t\\t\\t\\t\\n            # Check if char is less than top element of stack (if so, it cannot be appended on the top)\\n            # And pop top char only if there are more occurrences of it left in the string\\n            while mono_stack and char <= mono_stack[-1] and counts[mono_stack[-1]] != 0:\\n                this_char = mono_stack.pop(-1)\\n                used[this_char] = False\\n\\n            # Append current char onto the stack\\n            used[char] = True\\n            mono_stack.append(char)\\n\\n        # Elements of the stack is the final string\\n        return \"\".join(mono_stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1512052,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        char arr[]=s.toCharArray();\\n        \\n        int freq[]=new int[26];\\n        boolean flag[]=new boolean[26];\\n        \\n\\t\\t//counting frequency of chars in arr\\n        for(int i=0;i<arr.length;i++){\\n            freq[arr[i]-\\'a\\']++;\\n        }\\n        \\n        Stack<Character> stk=new Stack<Character>();\\n        \\n        for(int i=0;i<arr.length;i++){\\n            freq[arr[i]-\\'a\\']--;    //decreasing frequency of ith char\\n\\t\\t\\t\\n\\t\\t\\t//if ith char is not in stack already then we check if we should add it or not\\n            if(!flag[arr[i]-\\'a\\']){\\n\\t\\t\\t\\n\\t\\t\\t\\t//if stack top is greater than ith char and stack top has frequency remaining then we should remove it from here as it can be added further\\n                while(stk.size()>0 && stk.peek()>arr[i] && freq[stk.peek()-\\'a\\']>0){\\n                    flag[stk.pop()-\\'a\\']=false;//stk doesn\\'t have it the char now so making its flag false\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//adding ith char and flagging true\\n                stk.push(arr[i]);\\n                flag[arr[i]-\\'a\\']=true;\\n            }\\n\\t\\t\\t\\n\\t\\t//finally building string \\n        StringBuilder sb=new StringBuilder();\\n        while(!stk.isEmpty()){\\n            sb.insert(0,stk.pop());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        char arr[]=s.toCharArray();\\n        \\n        int freq[]=new int[26];\\n        boolean flag[]=new boolean[26];\\n        \\n\\t\\t//counting frequency of chars in arr\\n        for(int i=0;i<arr.length;i++){\\n            freq[arr[i]-\\'a\\']++;\\n        }\\n        \\n        Stack<Character> stk=new Stack<Character>();\\n        \\n        for(int i=0;i<arr.length;i++){\\n            freq[arr[i]-\\'a\\']--;    //decreasing frequency of ith char\\n\\t\\t\\t\\n\\t\\t\\t//if ith char is not in stack already then we check if we should add it or not\\n            if(!flag[arr[i]-\\'a\\']){\\n\\t\\t\\t\\n\\t\\t\\t\\t//if stack top is greater than ith char and stack top has frequency remaining then we should remove it from here as it can be added further\\n                while(stk.size()>0 && stk.peek()>arr[i] && freq[stk.peek()-\\'a\\']>0){\\n                    flag[stk.pop()-\\'a\\']=false;//stk doesn\\'t have it the char now so making its flag false\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//adding ith char and flagging true\\n                stk.push(arr[i]);\\n                flag[arr[i]-\\'a\\']=true;\\n            }\\n\\t\\t\\t\\n\\t\\t//finally building string \\n        StringBuilder sb=new StringBuilder();\\n        while(!stk.isEmpty()){\\n            sb.insert(0,stk.pop());\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479715,
                "title": "java-solution-o-n",
                "content": "Do a basic dry run u will understand it\\n\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n\\t\\n\\t\\n        int [] arr=new int[26];//for all characters we have made a string\\n        boolean [] visited=new boolean[26];//by default value of boolean is false\\n        char [] ch=s.toCharArray();\\n        for(char character:ch){\\n            arr[character -\\'a\\']++;//a character is uesd as a starts from 0\\n            //putting frequency of occurance a specific character in  array arr\\n        }\\n        Stack<Character> st=new Stack<>();\\n        for(char character :ch){\\n            int idx=character-\\'a\\';//for index\\n            arr[idx]--;//the times we are going to go in we will decrease the frequency of character\\n            if(visited[idx]==true){\\n                continue;\\n            }\\n            \\n            while(st.size()!=0 && character<st.peek() && arr[st.peek()-\\'a\\']!=0){\\n                visited[st.pop()-\\'a\\']=false;\\n            }\\n            st.push(character);\\n            visited[character-\\'a\\']=true;\\n        }\\n        StringBuilder str=new StringBuilder();\\n        while(st.size()!=0){\\n           str.insert(0,st.pop());\\n        }\\n        return str.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String removeDuplicateLetters(String s) {\\n\\t\\n\\t\\n        int [] arr=new int[26];//for all characters we have made a string\\n        boolean [] visited=new boolean[26];//by default value of boolean is false\\n        char [] ch=s.toCharArray();\\n        for(char character:ch){\\n            arr[character -\\'a\\']++;//a character is uesd as a starts from 0\\n            //putting frequency of occurance a specific character in  array arr\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1355644,
                "title": "using-stack-in-python",
                "content": "```\\nclass Solution:\\n  \"\"\"The idea is to have a stack and push each element one by one. \\n  But with some conditions. To be in lexicographic(dictionary) order, \\n  smaller elements must appear before larger ones (D>A). \\n  To do that, we pop any element that is already in the stack and is greater than our awaiting element \\n  (to be pushed into the stack) \\n  and which will be appearing again in our consideration of the characters of the given string s.\"\"\"\\n    def removeDuplicateLetters(self, s: str) -> str:\\n      res = []    #empty stack\\n      for i in range(len(s)):\\n        if s[i] in res: continue   #if element already in stack, don\\'t bother \\n        while res and s[i]<res[-1] and res[-1] in s[i+1:]:   #try to put the smallest element at the front \\n          res.pop()                 #by popping previously pushed larger elements, but only those that will be appearing again\\n        res.append(s[i])       #push the smallest in\\n      return \"\".join(res)\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n  \"\"\"The idea is to have a stack and push each element one by one. \\n  But with some conditions. To be in lexicographic(dictionary) order, \\n  smaller elements must appear before larger ones (D>A). \\n  To do that, we pop any element that is already in the stack and is greater than our awaiting element \\n  (to be pushed into the stack) \\n  and which will be appearing again in our consideration of the characters of the given string s.\"\"\"\\n    def removeDuplicateLetters(self, s: str) -> str:\\n      res = []    #empty stack\\n      for i in range(len(s)):\\n        if s[i] in res: continue   #if element already in stack, don\\'t bother \\n        while res and s[i]<res[-1] and res[-1] in s[i+1:]:   #try to put the smallest element at the front \\n          res.pop()                 #by popping previously pushed larger elements, but only those that will be appearing again\\n        res.append(s[i])       #push the smallest in\\n      return \"\".join(res)\\n",
                "codeTag": "Java"
            },
            {
                "id": 891215,
                "title": "locality-of-reference-why-is-this-solution-slower-than-the-other",
                "content": "I had solved this question using the stack approach. To keep track of alphabets already in the stack, I used a set. In the other solution I simply thought of using an array of size 26 instead of a set. But the latter seems to be slower than the former. Can anyone tell me why is it so? Is it due to locality of reference being violated? I mean cache miss while accessing the array?\\n\\n\\nSolution using SET \\n```\\n\\tdef removeDuplicateLetters(self, s: str) -> str:\\n        freq  = Counter(s)\\n        stk, added = [], set()\\n        for c in s:\\n            if(c not in added):\\n                while(stk and stk[-1] > c and freq[stk[-1]] > 0):\\n                    added.remove(stk[-1])\\n                    stk.pop()\\n                stk.append(c)\\n                added.add(c)\\n            freq[c]-=1\\n        return \"\".join(stk)\\n```\\nUsing an Array of size 26 to immitate a dictionary.\\n```\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        freq  = Counter(s)\\n        stk, added, ordA= [], [0]*26, ord(\\'a\\')\\n        for c in s:\\n            if(not added[ord(c)- ordA]):\\n                while(stk and stk[-1] > c and freq[stk[-1]] > 0):\\n                    added[ord(stk[-1]) - ordA] = 0\\n                    stk.pop()\\n                stk.append(c)\\n                added[ord(c) - ordA] = 1\\n            freq[c]-=1\\n        return \"\".join(stk)\\n```",
                "solutionTags": [],
                "code": "```\\n\\tdef removeDuplicateLetters(self, s: str) -> str:\\n        freq  = Counter(s)\\n        stk, added = [], set()\\n        for c in s:\\n            if(c not in added):\\n                while(stk and stk[-1] > c and freq[stk[-1]] > 0):\\n                    added.remove(stk[-1])\\n                    stk.pop()\\n                stk.append(c)\\n                added.add(c)\\n            freq[c]-=1\\n        return \"\".join(stk)\\n```\n```\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        freq  = Counter(s)\\n        stk, added, ordA= [], [0]*26, ord(\\'a\\')\\n        for c in s:\\n            if(not added[ord(c)- ordA]):\\n                while(stk and stk[-1] > c and freq[stk[-1]] > 0):\\n                    added[ord(stk[-1]) - ordA] = 0\\n                    stk.pop()\\n                stk.append(c)\\n                added[ord(c) - ordA] = 1\\n            freq[c]-=1\\n        return \"\".join(stk)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 890662,
                "title": "c-0ms-stack-solution",
                "content": "```\\n    static string removeDuplicateLetters(const string& s) {\\n        uint16_t last[26];\\n        for (int i = 0; i < s.length(); ++i) last[s[i] - \\'a\\'] = i;\\n        uint32_t seen = 0;\\n        \\n        string ans;\\n        for (int i = 0; i < s.length(); ++i)  {\\n            if (seen & (1 << s[i] - \\'a\\')) continue;\\n            while (!ans.empty() && s[i] < ans.back() && i < last[ans.back() - \\'a\\']) {\\n                seen &= ~(1 << ans.back() - \\'a\\');\\n                ans.pop_back();\\n            }\\n            seen |= 1 << s[i] - \\'a\\';\\n            ans.push_back(s[i]);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    static string removeDuplicateLetters(const string& s) {\\n        uint16_t last[26];\\n        for (int i = 0; i < s.length(); ++i) last[s[i] - \\'a\\'] = i;\\n        uint32_t seen = 0;\\n        \\n        string ans;\\n        for (int i = 0; i < s.length(); ++i)  {\\n            if (seen & (1 << s[i] - \\'a\\')) continue;\\n            while (!ans.empty() && s[i] < ans.back() && i < last[ans.back() - \\'a\\']) {\\n                seen &= ~(1 << ans.back() - \\'a\\');\\n                ans.pop_back();\\n            }\\n            seen |= 1 << s[i] - \\'a\\';\\n            ans.push_back(s[i]);\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 835097,
                "title": "c-o-n-easy-implementation-using-stack-with-step-wise-explanation",
                "content": "## STEPS FOR SOLVING\\n1. Take a vector for storing the frequencies of characters.\\n2. Take a monotonically increasing stack as we want the lexicographically smallest answer.\\n3. Take a set to check if the character is already present in the stack.\\n4. We will pop a character untill the next element is smallest and we have that character to the right,   that is the frequency should be greater than 0.\\n5. After that we push the current character into the stack.\\n6. The characters in the stack is the resulting lexicographically smallest possible sequence. \\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        \\n        vector<char>v(256,0);\\n        \\n        for(auto i:s)\\n            v[i]++;\\n        \\n        stack<char>st;\\n        set<int>cur;\\n        \\n        for(auto i:s)\\n        {\\n            v[i]--;\\n            \\n            if(cur.find(i)!=cur.end())continue;\\n            \\n            while(!st.empty() and st.top()>i and v[st.top()]>0)\\n            {\\n                cur.erase(st.top());\\n                st.pop();\\n            }\\n            \\n            cur.insert(i);\\n            st.push(i);\\n        }\\n        \\n        string ans=\"\";\\n        \\n        while(!st.empty())\\n        {\\n            ans=st.top()+ans;\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        \\n        vector<char>v(256,0);\\n        \\n        for(auto i:s)\\n            v[i]++;\\n        \\n        stack<char>st;\\n        set<int>cur;\\n        \\n        for(auto i:s)\\n        {\\n            v[i]--;\\n            \\n            if(cur.find(i)!=cur.end())continue;\\n            \\n            while(!st.empty() and st.top()>i and v[st.top()]>0)\\n            {\\n                cur.erase(st.top());\\n                st.pop();\\n            }\\n            \\n            cur.insert(i);\\n            st.push(i);\\n        }\\n        \\n        string ans=\"\";\\n        \\n        while(!st.empty())\\n        {\\n            ans=st.top()+ans;\\n            st.pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787390,
                "title": "c-stack-greedy-solution",
                "content": "Always make the element in the stack top as small as possible\\nEverytime you push the element, if the top element is larger than the current element and the top element can be found in the future, pop it.\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        \\n        int cnt[26] = {0};\\n        for(int i=0; i<s.size(); i++) cnt[s[i] - \\'a\\']++;\\n        \\n        unordered_set<char> uset;\\n        stack<char> stk;\\n        for(int i=0; i<s.size(); i++){\\n            char now = s[i];\\n            cnt[s[i]-\\'a\\']--;\\n            if(uset.count(now))continue;\\n            uset.insert(now);\\n            if(stk.size() == 0)stk.push(now);\\n            else{\\n                while(stk.size() && stk.top() > now && cnt[stk.top() - \\'a\\']){\\n                    uset.erase(uset.find(stk.top()));\\n                    stk.pop();\\n                }\\n                stk.push(now);\\n            }\\n        }\\n        string ret = \"\";\\n        while(stk.size()){\\n            ret = stk.top() + ret;\\n            stk.pop();\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        \\n        int cnt[26] = {0};\\n        for(int i=0; i<s.size(); i++) cnt[s[i] - \\'a\\']++;\\n        \\n        unordered_set<char> uset;\\n        stack<char> stk;\\n        for(int i=0; i<s.size(); i++){\\n            char now = s[i];\\n            cnt[s[i]-\\'a\\']--;\\n            if(uset.count(now))continue;\\n            uset.insert(now);\\n            if(stk.size() == 0)stk.push(now);\\n            else{\\n                while(stk.size() && stk.top() > now && cnt[stk.top() - \\'a\\']){\\n                    uset.erase(uset.find(stk.top()));\\n                    stk.pop();\\n                }\\n                stk.push(now);\\n            }\\n        }\\n        string ret = \"\";\\n        while(stk.size()){\\n            ret = stk.top() + ret;\\n            stk.pop();\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 449026,
                "title": "easy-to-understand-timeo-n-space-o-1-1ms-beat100-with-detailed-comments",
                "content": "Time complexity O(n), Space Complexity O(1)\\n```\\npublic String removeDuplicateLetters(String s) {\\n        int len = 0;\\n        int[] map = new int[128];\\n        char[] arr = s.toCharArray();\\n\\t\\t/*first, just scan the string to record every character\\'s number, and the total number of unique character which is also the output string\\'s length */\\n        for(char c : arr){\\n            if(map[c]++ == 0)len++;\\n        }\\n\\t\\t/*put result into this char array */\\n\\t\\tchar[] res = new char[len];\\n\\t\\t/*use an array to record, if a certain character is already put into the result*/\\n        boolean[] used = new boolean[128];\\n        int i = 0; \\n\\t\\t\\n\\t\\t/* current character and the last character in res array ,  if they meets the three condithion then we should throw the last char in res\\n\\t\\t1, current character is still not used in res array\\n\\t\\t2, current character is smaller than last char in res array(which means drop last char in res and use current array will make the res array become smaller)\\n\\t\\t3, there are some same character with the last char still exist behind the current character */\\n\\n        for(char c : arr){\\n\\t\\t\\twhile(i>0 && c < res[i-1] && !used[c] && map[res[i-1]] > 0){\\n                char tmp = res[--i];\\n                used[tmp] = false;\\n            }\\n\\t\\t\\n\\t\\t/* if current character is not used in res char, then put it in */\\n\\t\\t\\n            if(!used[c]){\\n                res[i++] = c;\\n                used[c] = true;\\n            }\\n            --map[c];\\n        }\\n        return new String(res);  \\n    }\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic String removeDuplicateLetters(String s) {\\n        int len = 0;\\n        int[] map = new int[128];\\n        char[] arr = s.toCharArray();\\n\\t\\t/*first, just scan the string to record every character\\'s number, and the total number of unique character which is also the output string\\'s length */\\n        for(char c : arr){\\n            if(map[c]++ == 0)len++;\\n        }\\n\\t\\t/*put result into this char array */\\n\\t\\tchar[] res = new char[len];\\n\\t\\t/*use an array to record, if a certain character is already put into the result*/\\n        boolean[] used = new boolean[128];\\n        int i = 0; \\n\\t\\t\\n\\t\\t/* current character and the last character in res array ,  if they meets the three condithion then we should throw the last char in res\\n\\t\\t1, current character is still not used in res array\\n\\t\\t2, current character is smaller than last char in res array(which means drop last char in res and use current array will make the res array become smaller)\\n\\t\\t3, there are some same character with the last char still exist behind the current character */\\n\\n        for(char c : arr){\\n\\t\\t\\twhile(i>0 && c < res[i-1] && !used[c] && map[res[i-1]] > 0){\\n                char tmp = res[--i];\\n                used[tmp] = false;\\n            }\\n\\t\\t\\n\\t\\t/* if current character is not used in res char, then put it in */\\n\\t\\t\\n            if(!used[c]){\\n                res[i++] = c;\\n                used[c] = true;\\n            }\\n            --map[c];\\n        }\\n        return new String(res);  \\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 445247,
                "title": "beats-100-0ms-easy-clean-c-code-with-comments-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n         string res;\\n         vector<int>cnt(26,0);   // arr to store cnt of each character\\n         vector<bool>visited(26,0);   //To check if char is already added to res string\\n         for(char &i : s) cnt[i-\\'a\\']++;   \\n         int unique=0;   // no of unique chars\\n         for(int i=0;i<26;i++) unique+=(cnt[i]>0);\\n         for(char &c : s)\\n         {\\n           \\n             cnt[c-\\'a\\']--;\\n             if(visited[c-\\'a\\']) continue;\\n             while(!res.empty() && c<res.back() && cnt[res.back()-\\'a\\']>0)       // It means we have added \\n\\t\\t\\t  //bigger char to the res string before the smaller current char where as we can even get the bigger char later also but still added so pop chars until they are bigger than current and we can find them later\\n             {\\n                 visited[res.back()-\\'a\\']=0;\\n                 res.pop_back();\\n             }\\n             visited[c-\\'a\\']=1;\\n             res+=c;\\n             if(res.size()==unique) break;      // If we have find all the unique chars already simply break no need to traverse more\\n         }\\n         return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n         string res;\\n         vector<int>cnt(26,0);   // arr to store cnt of each character\\n         vector<bool>visited(26,0);   //To check if char is already added to res string\\n         for(char &i : s) cnt[i-\\'a\\']++;   \\n         int unique=0;   // no of unique chars\\n         for(int i=0;i<26;i++) unique+=(cnt[i]>0);\\n         for(char &c : s)\\n         {\\n           \\n             cnt[c-\\'a\\']--;\\n             if(visited[c-\\'a\\']) continue;\\n             while(!res.empty() && c<res.back() && cnt[res.back()-\\'a\\']>0)       // It means we have added \\n\\t\\t\\t  //bigger char to the res string before the smaller current char where as we can even get the bigger char later also but still added so pop chars until they are bigger than current and we can find them later\\n             {\\n                 visited[res.back()-\\'a\\']=0;\\n                 res.pop_back();\\n             }\\n             visited[c-\\'a\\']=1;\\n             res+=c;\\n             if(res.size()==unique) break;      // If we have find all the unique chars already simply break no need to traverse more\\n         }\\n         return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097906,
                "title": "beats-100-solution-using-stack-t-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will here see if there is any character bigger than current character than we will see if it is occuring agina or not . \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Count the occurrences of each character in the string and store the counts in an array.\\n2. Iterate through each character in the string:\\nDecrement the count for the current character.\\n-If the character is already in charset, skip it.\\n-If the character is smaller than the top of the stack, pop characters from the stack until a smaller character is encountered or the stack is empty.\\n-Add the current character to charset and push it onto the stack.\\n3. At last we will construct the result by poping the stack element and adding it to result string.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) { // mere se pehle agar koi bada hai to baad me aya hai ki ni \\n            int n=s.length();\\n            stack<char>st;\\n            vector<bool>exist(26,false);\\n            // map<char,int>mp;\\n            int count[26]={};\\n            for(auto c:s)count[c-\\'a\\']++; // count he ocureance of evry letter in the given string \\n\\n            for(auto c: s){\\n                count[c-\\'a\\']--;\\n                if(exist[c-\\'a\\'])continue;\\n\\n                while(!st.empty() && c < st.top() && count[st.top()-\\'a\\']>0){\\n                    char rem= st.top();\\n                    exist[rem-\\'a\\']=false;\\n                    st.pop();\\n                }\\n                exist[c-\\'a\\']=true;\\n                st.push(c);\\n\\n            }\\n            string res=\"\";\\n            while(!st.empty()){\\n                res= st.top()+ res;\\n                st.pop();\\n            }\\n            return res;\\n\\n\\n                  \\n     }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) { // mere se pehle agar koi bada hai to baad me aya hai ki ni \\n            int n=s.length();\\n            stack<char>st;\\n            vector<bool>exist(26,false);\\n            // map<char,int>mp;\\n            int count[26]={};\\n            for(auto c:s)count[c-\\'a\\']++; // count he ocureance of evry letter in the given string \\n\\n            for(auto c: s){\\n                count[c-\\'a\\']--;\\n                if(exist[c-\\'a\\'])continue;\\n\\n                while(!st.empty() && c < st.top() && count[st.top()-\\'a\\']>0){\\n                    char rem= st.top();\\n                    exist[rem-\\'a\\']=false;\\n                    st.pop();\\n                }\\n                exist[c-\\'a\\']=true;\\n                st.push(c);\\n\\n            }\\n            string res=\"\";\\n            while(!st.empty()){\\n                res= st.top()+ res;\\n                st.pop();\\n            }\\n            return res;\\n\\n\\n                  \\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093060,
                "title": "video-solution-explanation-with-drawings-in-depth-c-java",
                "content": "# Intuition, approach, and complexity dicussed in detail in video solution\\nhttps://youtu.be/PnmfWs5AcGc\\n\\n# Code\\nC++\\n```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        int[] lastIndx = new int[26];\\n        int sz = s.length();\\n        for (int indx = 0; indx < sz; indx++) {\\n            lastIndx[s.charAt(indx) - \\'a\\'] = indx;\\n        }\\n        int[] visited = new int[26];\\n        Stack<Integer> charDiffStack = new Stack<>();\\n        for (int indx = 0; indx < sz; indx++) {\\n            int currCharDiff = s.charAt(indx) - \\'a\\';\\n            if (visited[currCharDiff] != 0) continue;\\n            while (!charDiffStack.empty() && charDiffStack.peek() > currCharDiff && lastIndx[charDiffStack.peek()] > indx) {\\n                visited[charDiffStack.peek()] = 0;\\n                charDiffStack.pop();\\n            }\\n            visited[currCharDiff] = 1;\\n            charDiffStack.push(currCharDiff);\\n        }\\n        StringBuilder res = new StringBuilder();\\n        while (!charDiffStack.empty()) {\\n            res.append((char) (charDiffStack.peek() + \\'a\\'));\\n            charDiffStack.pop();\\n        }\\n        return res.reverse().toString();\\n    }\\n}\\n```\\nJava\\n```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        int[] lastIndx = new int[26];\\n        int sz = s.length();\\n        for (int indx = 0; indx < sz; indx++) {\\n            lastIndx[s.charAt(indx) - \\'a\\'] = indx;\\n        }\\n        int[] visited = new int[26];\\n        Stack<Integer> charDiffStack = new Stack<>();\\n        for (int indx = 0; indx < sz; indx++) {\\n            int currCharDiff = s.charAt(indx) - \\'a\\';\\n            if (visited[currCharDiff] != 0) continue;\\n            while (!charDiffStack.empty() && charDiffStack.peek() > currCharDiff && lastIndx[charDiffStack.peek()] > indx) {\\n                visited[charDiffStack.peek()] = 0;\\n                charDiffStack.pop();\\n            }\\n            visited[currCharDiff] = 1;\\n            charDiffStack.push(currCharDiff);\\n        }\\n        StringBuilder res = new StringBuilder();\\n        while (!charDiffStack.empty()) {\\n            res.append((char) (charDiffStack.peek() + \\'a\\'));\\n            charDiffStack.pop();\\n        }\\n        return res.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        int[] lastIndx = new int[26];\\n        int sz = s.length();\\n        for (int indx = 0; indx < sz; indx++) {\\n            lastIndx[s.charAt(indx) - \\'a\\'] = indx;\\n        }\\n        int[] visited = new int[26];\\n        Stack<Integer> charDiffStack = new Stack<>();\\n        for (int indx = 0; indx < sz; indx++) {\\n            int currCharDiff = s.charAt(indx) - \\'a\\';\\n            if (visited[currCharDiff] != 0) continue;\\n            while (!charDiffStack.empty() && charDiffStack.peek() > currCharDiff && lastIndx[charDiffStack.peek()] > indx) {\\n                visited[charDiffStack.peek()] = 0;\\n                charDiffStack.pop();\\n            }\\n            visited[currCharDiff] = 1;\\n            charDiffStack.push(currCharDiff);\\n        }\\n        StringBuilder res = new StringBuilder();\\n        while (!charDiffStack.empty()) {\\n            res.append((char) (charDiffStack.peek() + \\'a\\'));\\n            charDiffStack.pop();\\n        }\\n        return res.reverse().toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        int[] lastIndx = new int[26];\\n        int sz = s.length();\\n        for (int indx = 0; indx < sz; indx++) {\\n            lastIndx[s.charAt(indx) - \\'a\\'] = indx;\\n        }\\n        int[] visited = new int[26];\\n        Stack<Integer> charDiffStack = new Stack<>();\\n        for (int indx = 0; indx < sz; indx++) {\\n            int currCharDiff = s.charAt(indx) - \\'a\\';\\n            if (visited[currCharDiff] != 0) continue;\\n            while (!charDiffStack.empty() && charDiffStack.peek() > currCharDiff && lastIndx[charDiffStack.peek()] > indx) {\\n                visited[charDiffStack.peek()] = 0;\\n                charDiffStack.pop();\\n            }\\n            visited[currCharDiff] = 1;\\n            charDiffStack.push(currCharDiff);\\n        }\\n        StringBuilder res = new StringBuilder();\\n        while (!charDiffStack.empty()) {\\n            res.append((char) (charDiffStack.peek() + \\'a\\'));\\n            charDiffStack.pop();\\n        }\\n        return res.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091969,
                "title": "java-hashmap-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    class Node{\\n        int val;\\n        boolean vis;\\n        Node(int val,boolean vis){\\n            this.val = val;\\n            this.vis = vis;\\n        }\\n    }\\n    public String removeDuplicateLetters(String s) {\\n        Map<Character,Node> map = new HashMap<>();\\n        for(char ch : s.toCharArray()){\\n            int temp = 1;\\n            if(map.containsKey(ch)){\\n                temp = map.get(ch).val+1;\\n            }\\n            map.put(ch,new Node(temp,false));\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(char ch: s.toCharArray()){\\n            if(map.containsKey(ch)){\\n                if(!map.get(ch).vis){\\n                    int temp = map.get(ch).val;\\n                    temp--;\\n                    if(temp != 0)map.put(ch,new Node(temp,true));\\n                    else map.remove(ch);\\n                        while(sb.length() != 0 && ch < sb.charAt(sb.length()-1) && map.containsKey(sb.charAt(sb.length()-1))){\\n                            char c = sb.charAt(sb.length()-1);\\n                            map.put(c,new Node(map.get(c).val,false));  \\n                            sb.deleteCharAt(sb.length()-1);\\n                        }\\n                    sb.append(ch);\\n                }else{\\n                    int temp = map.get(ch).val-1;\\n                    if(temp != 0)map.put(ch,new Node(temp,true));\\n                    else map.remove(ch);\\n                }\\n\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    class Node{\\n        int val;\\n        boolean vis;\\n        Node(int val,boolean vis){\\n            this.val = val;\\n            this.vis = vis;\\n        }\\n    }\\n    public String removeDuplicateLetters(String s) {\\n        Map<Character,Node> map = new HashMap<>();\\n        for(char ch : s.toCharArray()){\\n            int temp = 1;\\n            if(map.containsKey(ch)){\\n                temp = map.get(ch).val+1;\\n            }\\n            map.put(ch,new Node(temp,false));\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for(char ch: s.toCharArray()){\\n            if(map.containsKey(ch)){\\n                if(!map.get(ch).vis){\\n                    int temp = map.get(ch).val;\\n                    temp--;\\n                    if(temp != 0)map.put(ch,new Node(temp,true));\\n                    else map.remove(ch);\\n                        while(sb.length() != 0 && ch < sb.charAt(sb.length()-1) && map.containsKey(sb.charAt(sb.length()-1))){\\n                            char c = sb.charAt(sb.length()-1);\\n                            map.put(c,new Node(map.get(c).val,false));  \\n                            sb.deleteCharAt(sb.length()-1);\\n                        }\\n                    sb.append(ch);\\n                }else{\\n                    int temp = map.get(ch).val-1;\\n                    if(temp != 0)map.put(ch,new Node(temp,true));\\n                    else map.remove(ch);\\n                }\\n\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091666,
                "title": "o-n-beginner-friendly-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOnly put those characters in stack which form valid string.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Push in stack:**\\n- only those characters are pushed which are not already there in the stack using `visited` map.\\n\\n**Pop from Stack**\\n1. stack is not empty which is obvious and,\\n\\n2. the current character in string s is smaller than the top stack character, as we want to keep the smallest character at first,\\n\\n*But what if the character we want to pop doesn\\'t appear again?\\npoint 3 is the answer.*\\n\\n3. While popping we need to keep a check if the character does not appear again we will not pop it, using `lastIdx`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        unordered_map<char, int> lastIdx;\\n        unordered_map<char, bool> visited;\\n        stack<char> st;\\n        string ans = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n            lastIdx[s.at(i)] = i;\\n        \\n\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            char ch = s.at(i);\\n            if(visited[ch]) continue;\\n\\n            while(!st.empty() && ch < st.top() && i < lastIdx[st.top()])\\n            {\\n                visited[st.top()] = false;\\n                st.pop();\\n            }\\n            st.push(ch);\\n            visited[ch] = true;\\n        }\\n\\n        while(!st.empty())\\n        {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        unordered_map<char, int> lastIdx;\\n        unordered_map<char, bool> visited;\\n        stack<char> st;\\n        string ans = \"\";\\n        for(int i = 0; i < s.size(); i++)\\n            lastIdx[s.at(i)] = i;\\n        \\n\\n        for(int i = 0; i < s.size(); i++)\\n        {\\n            char ch = s.at(i);\\n            if(visited[ch]) continue;\\n\\n            while(!st.empty() && ch < st.top() && i < lastIdx[st.top()])\\n            {\\n                visited[st.top()] = false;\\n                st.pop();\\n            }\\n            st.push(ch);\\n            visited[ch] = true;\\n        }\\n\\n        while(!st.empty())\\n        {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091542,
                "title": "today-s-potd-with-100-runtime-and-memory-acceptance-optimised",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitialize a stack (st) to store characters, two vectors (last_occurrence and used) to keep track of the last occurrence of each character and whether a character is already in the result, respectively.\\n---\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a stack (st) to store characters, two vectors (last_occurrence and used) to keep track of the last occurrence of each character and whether a character is already in the result, respectively.\\n\\n2. Iterate through the input string s:\\n\\n- For each character currChar, check if it has not been used (used[currChar - \\'a\\'] is false).\\n- If it has not been used:\\n- While the stack is not empty, the current character currChar is smaller than the character at the top of the stack (st.top()), and there are more occurrences of the character at the top of the stack later in the string, pop characters from the stack and mark them as unused.\\n- Push the current character onto the stack and mark it as used.\\n\\n3. After processing the entire input string, create a result string of the same size as the stack (st.size()) and construct it in reverse order by popping characters from the stack.\\n\\n4. Return the result string, which contains the lexicographically smallest string without duplicate letters.\\n---\\n\\n\\n# Complexity\\n\\n---\\n\\n1.  Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- The code iterates through the input string s twice, once for calculating the last occurrence of each character and once for processing the string with the stack.\\n- Both iterations have a time complexity of O(N), where N is the length of the input string s.\\n- The final construction of the result string from the stack also takes O(N) time.\\n- Thus, the overall time complexity is O(N).\\n---\\n\\n\\n2.  Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The additional space used is mainly for the stack, which can have at most N characters, where N is the length of the input string s.\\n- The last_occurrence and used vectors each have a constant size of 26 (for the English alphabet).\\n- The result string also takes O(N) space.\\n- Therefore, the overall space complexity is O(N).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> last_occurrence(26, -1);\\n        vector<bool> used(26, false);\\n        stack<char> st;\\n\\n        // Calculate the last occurrence of each character in the string\\n        for (int i = 0; i < s.size(); ++i) {\\n            last_occurrence[s[i] - \\'a\\'] = i;\\n        }\\n\\n        for (int i = 0; i < s.size(); ++i) {\\n            char currChar = s[i];\\n\\n            if (!used[currChar - \\'a\\']) {\\n                while (!st.empty() && currChar < st.top() && last_occurrence[st.top() - \\'a\\'] > i) {\\n                    used[st.top() - \\'a\\'] = false;\\n                    st.pop();\\n                }\\n\\n                st.push(currChar);\\n                used[currChar - \\'a\\'] = true;\\n            }\\n        }\\n\\n        string result(st.size(), \\' \\');\\n\\n        // Construct the result string in reverse order from the stack\\n        for (int i = st.size() - 1; i >= 0; --i) {\\n            result[i] = st.top();\\n            st.pop();\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> last_occurrence(26, -1);\\n        vector<bool> used(26, false);\\n        stack<char> st;\\n\\n        // Calculate the last occurrence of each character in the string\\n        for (int i = 0; i < s.size(); ++i) {\\n            last_occurrence[s[i] - \\'a\\'] = i;\\n        }\\n\\n        for (int i = 0; i < s.size(); ++i) {\\n            char currChar = s[i];\\n\\n            if (!used[currChar - \\'a\\']) {\\n                while (!st.empty() && currChar < st.top() && last_occurrence[st.top() - \\'a\\'] > i) {\\n                    used[st.top() - \\'a\\'] = false;\\n                    st.pop();\\n                }\\n\\n                st.push(currChar);\\n                used[currChar - \\'a\\'] = true;\\n            }\\n        }\\n\\n        string result(st.size(), \\' \\');\\n\\n        // Construct the result string in reverse order from the stack\\n        for (int i = st.size() - 1; i >= 0; --i) {\\n            result[i] = st.top();\\n            st.pop();\\n        }\\n\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091248,
                "title": "kotlin-map-and-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun removeDuplicateLetters(s: String): String {\\n        val map = mutableMapOf<Char, Int>()\\n        val set = mutableSetOf<Char>()\\n\\n        for (i in s){\\n            map[i] = map.getOrDefault(i, 0 ) + 1\\n        }\\n\\n        for (i in s){\\n            map[i] = map[i]!! - 1\\n            if (!set.contains(i)){\\n                while(set.isNotEmpty() && i < set.last() && map[set.last()]!! > 0){\\n                    set.remove(set.last())\\n                }\\n                set.add(i)\\n            }\\n    }\\n        return set.joinToString(\"\")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun removeDuplicateLetters(s: String): String {\\n        val map = mutableMapOf<Char, Int>()\\n        val set = mutableSetOf<Char>()\\n\\n        for (i in s){\\n            map[i] = map.getOrDefault(i, 0 ) + 1\\n        }\\n\\n        for (i in s){\\n            map[i] = map[i]!! - 1\\n            if (!set.contains(i)){\\n                while(set.isNotEmpty() && i < set.last() && map[set.last()]!! > 0){\\n                    set.remove(set.last())\\n                }\\n                set.add(i)\\n            }\\n    }\\n        return set.joinToString(\"\")\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090745,
                "title": "remove-duplicate-letters",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1).\\n-  Fixed size of HashMap and stack (26 char) uses.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n       HashMap<Character, Integer> lastOccurrence = new HashMap<>();\\n        Stack<Character> stack = new Stack<>();\\n        boolean[] visited = new boolean[26]; // Assuming only lowercase letters are in the input\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            lastOccurrence.put(s.charAt(i), i);\\n        }\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n\\n            if (!visited[c - \\'a\\']) {\\n                while (!stack.isEmpty() && stack.peek() > c && lastOccurrence.get(stack.peek()) > i) {\\n                    visited[stack.pop() - \\'a\\'] = false;\\n                }\\n\\n                stack.push(c);\\n                visited[c - \\'a\\'] = true;\\n            }\\n        }\\n\\n        StringBuilder result = new StringBuilder();\\n        for (Character character : stack) {\\n            result.append(character);\\n        }\\n\\n        return result.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n       HashMap<Character, Integer> lastOccurrence = new HashMap<>();\\n        Stack<Character> stack = new Stack<>();\\n        boolean[] visited = new boolean[26]; // Assuming only lowercase letters are in the input\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            lastOccurrence.put(s.charAt(i), i);\\n        }\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n\\n            if (!visited[c - \\'a\\']) {\\n                while (!stack.isEmpty() && stack.peek() > c && lastOccurrence.get(stack.peek()) > i) {\\n                    visited[stack.pop() - \\'a\\'] = false;\\n                }\\n\\n                stack.push(c);\\n                visited[c - \\'a\\'] = true;\\n            }\\n        }\\n\\n        StringBuilder result = new StringBuilder();\\n        for (Character character : stack) {\\n            result.append(character);\\n        }\\n\\n        return result.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937182,
                "title": "my-c-easy-solution-beats-100-explained",
                "content": "# Approach:\\n- The approach used in this code is to maintain two arrays, `freq` and `stackfreq`, to keep track of the frequency of characters and whether a character is present in the stack, respectively. A stack is used to store characters in the order they should appear in the final result. The goal is to iterate through the string, handle cases where a character should be included in the stack, and then construct the final result from the stack.\\n\\n1. Initialize two arrays, `freq` and `stackfreq`, to keep track of character frequencies and whether a character is in the stack.\\n2. Iterate through the string:\\n   - Decrease the frequency count of the current character in `freq`.\\n   - If the current character is already in the stack, skip it.\\n   - If the stack is not empty and the current character is less than the top of the stack, pop characters from the stack while maintaining the lexicographical order and checking the frequency condition.\\n   - Push the current character onto the stack and update its frequency in `stackfreq`.\\n3. Create a temporary stack `temp` and transfer the characters from the main stack to `temp` while reversing their order.\\n4. Build the final answer string by popping characters from `temp` and appending them to the answer.\\n5. Return the answer.\\n\\n# Time Complexity:\\n***The amortised time complexity of this solution is O(N), where N is the length of the input string. In the worst case, each character is processed and pushed/popped from the stack once.***\\n\\n# Space Complexity:\\n***The space complexity is O(N) since the size of both `freq` and `stackfreq` arrays is constant (26) and the stack space is bounded by the length of the input string and can be O(N) at max.***\\n\\n# Code\\nhere\\'s the code:\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n\\n// data structures and variables\\n        int n = s.size();\\n        int freq[26] = {0};\\n        for (char ch: s) freq[ch-\\'a\\']++;\\n        \\n        int stackfreq[26] = {0};\\n        stack<char> st;\\n\\n// core logic\\n        for (int i=0; i<n; i++) {\\n            freq[s[i]-\\'a\\']--;\\n            if (stackfreq[s[i]-\\'a\\'] || (!st.empty() && s[i] == st.top())) {\\n                continue;\\n            }\\n            else if (!st.empty() && !stackfreq[s[i]-\\'a\\'] && s[i] < st.top()) {\\n                while (!st.empty() && s[i] < st.top() && freq[st.top()-\\'a\\'] ) {\\n                    stackfreq[st.top()-\\'a\\']--;\\n                    st.pop();\\n                }\\n            }\\n            st.push(s[i]);\\n            stackfreq[s[i]-\\'a\\']++;\\n        }\\n\\n// leftover stack contains our elements\\n         stack<char> temp;\\n         while (!st.empty()) {\\n             temp.push(st.top());\\n             st.pop();\\n         }\\n         string ans = \"\";\\n         while (!temp.empty()) {\\n             ans += temp.top();\\n             temp.pop();\\n         }\\n         return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n\\n// data structures and variables\\n        int n = s.size();\\n        int freq[26] = {0};\\n        for (char ch: s) freq[ch-\\'a\\']++;\\n        \\n        int stackfreq[26] = {0};\\n        stack<char> st;\\n\\n// core logic\\n        for (int i=0; i<n; i++) {\\n            freq[s[i]-\\'a\\']--;\\n            if (stackfreq[s[i]-\\'a\\'] || (!st.empty() && s[i] == st.top())) {\\n                continue;\\n            }\\n            else if (!st.empty() && !stackfreq[s[i]-\\'a\\'] && s[i] < st.top()) {\\n                while (!st.empty() && s[i] < st.top() && freq[st.top()-\\'a\\'] ) {\\n                    stackfreq[st.top()-\\'a\\']--;\\n                    st.pop();\\n                }\\n            }\\n            st.push(s[i]);\\n            stackfreq[s[i]-\\'a\\']++;\\n        }\\n\\n// leftover stack contains our elements\\n         stack<char> temp;\\n         while (!st.empty()) {\\n             temp.push(st.top());\\n             st.pop();\\n         }\\n         string ans = \"\";\\n         while (!temp.empty()) {\\n             ans += temp.top();\\n             temp.pop();\\n         }\\n         return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899766,
                "title": "c-super-easy-clean-code-stack-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int n = s.size();\\n\\n        int freq[26] = {0};\\n        for(int i=0; i<n; i++){\\n            freq[s[i] - \\'a\\']++;\\n        }\\n\\n        bool present[26] = {0};\\n\\n        stack<char> st;\\n        for(int i=0; i<n; i++){\\n            freq[s[i] - \\'a\\']--;\\n            if(present[s[i] - \\'a\\']) continue;\\n            while(!st.empty() && st.top() > s[i] && freq[st.top() - \\'a\\']){\\n                present[st.top() - \\'a\\'] = 0;\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n            present[s[i] - \\'a\\'] = 1;\\n        }\\n\\n        string ans = \"\";\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int n = s.size();\\n\\n        int freq[26] = {0};\\n        for(int i=0; i<n; i++){\\n            freq[s[i] - \\'a\\']++;\\n        }\\n\\n        bool present[26] = {0};\\n\\n        stack<char> st;\\n        for(int i=0; i<n; i++){\\n            freq[s[i] - \\'a\\']--;\\n            if(present[s[i] - \\'a\\']) continue;\\n            while(!st.empty() && st.top() > s[i] && freq[st.top() - \\'a\\']){\\n                present[st.top() - \\'a\\'] = 0;\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n            present[s[i] - \\'a\\'] = 1;\\n        }\\n\\n        string ans = \"\";\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741568,
                "title": "c-monotonic-stack-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> vis(26,0);\\n        unordered_map<char,int> mp;\\n        for(auto ch : s) mp[ch]++;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]--;\\n            if(vis[s[i]-\\'a\\']) continue;\\n            else{\\n                while(!ans.empty() && ans.back()>s[i] && mp[ans.back()]){\\n                    vis[ans.back()-\\'a\\']=0;\\n                    ans.pop_back();\\n                }\\n                ans.push_back(s[i]);\\n                vis[s[i]-\\'a\\']=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> vis(26,0);\\n        unordered_map<char,int> mp;\\n        for(auto ch : s) mp[ch]++;\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]--;\\n            if(vis[s[i]-\\'a\\']) continue;\\n            else{\\n                while(!ans.empty() && ans.back()>s[i] && mp[ans.back()]){\\n                    vis[ans.back()-\\'a\\']=0;\\n                    ans.pop_back();\\n                }\\n                ans.push_back(s[i]);\\n                vis[s[i]-\\'a\\']=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638512,
                "title": "100-beats-c-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n      //stores last index\\n      vector<int>li(26,0);\\n      // mark the visited characters\\n      vector<bool>vis(26,false);\\n      string ans=\"\";\\n      stack<char>st;\\n      for(int i=0; i<s.size(); i++){\\n          li[s[i]-\\'a\\']=i;\\n      }\\n      for(int i=0; i<s.length(); i++){\\n          int curr=s[i]-\\'a\\';\\n          if(vis[curr])  continue;\\n          while(st.size()>0 && st.top()>s[i] && i<li[st.top()-\\'a\\']){\\n              vis[st.top()-\\'a\\']=false;\\n              st.pop();\\n          }\\n          st.push(s[i]);\\n          vis[curr]=true;\\n      }\\n      while(!st.empty()){\\n          ans=st.top()+ans;\\n          st.pop();\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n      //stores last index\\n      vector<int>li(26,0);\\n      // mark the visited characters\\n      vector<bool>vis(26,false);\\n      string ans=\"\";\\n      stack<char>st;\\n      for(int i=0; i<s.size(); i++){\\n          li[s[i]-\\'a\\']=i;\\n      }\\n      for(int i=0; i<s.length(); i++){\\n          int curr=s[i]-\\'a\\';\\n          if(vis[curr])  continue;\\n          while(st.size()>0 && st.top()>s[i] && i<li[st.top()-\\'a\\']){\\n              vis[st.top()-\\'a\\']=false;\\n              st.pop();\\n          }\\n          st.push(s[i]);\\n          vis[curr]=true;\\n      }\\n      while(!st.empty()){\\n          ans=st.top()+ans;\\n          st.pop();\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432444,
                "title": "full-explanation-python-efficient-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe initialize an empty stack to store characters, a dictionary last_occurrence to store the last occurrence index of each character in the string, and a set visited to keep track of characters already visited.\\nWe populate the last_occurrence dictionary by iterating through the characters in the input string s and storing the last index of each character in the dictionary.\\nWe then iterate through the characters in the string s again.\\nFor each character, we check if it is already visited. If it is, we skip it and move on to the next character.\\nIf the stack is not empty and the current character is smaller than the top of the stack (i.e., it appears before the top of the stack lexicographically), and the top of the stack has more occurrences in the remaining string (i.e., its last occurrence is after the current index), we pop the top of the stack to maintain the lexicographically smallest result. We remove the popped character from the visited set.\\nAfter that, we append the current character to the stack and mark it as visited in the visited set.\\nFinally, we convert the stack to a string using the join() method and return the resulting string, which contains the characters in the input string s with duplicates removed while maintaining the lexicographical order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe main idea is to iteratively process each character in the input string s, and maintain a stack that stores characters in the order of their appearance. We also keep track of the last occurrence index of each character in a dictionary last_occurrence to determine if a character has more occurrences in the remaining string.\\n\\nThe greedy part of the approach is that we only push a character onto the stack if it is smaller than the top of the stack (i.e., it appears before the top of the stack lexicographically), and the top of the stack has more occurrences in the remaining string (i.e., its last occurrence is after the current index). This ensures that we maintain the lexicographically smallest result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(n), where n is the length of the input string s. This is because we iterate through the string s twice: once to populate the last_occurrence dictionary, and once to process each character in the string. Each iteration takes O(n) time, and the other operations such as appending characters to the stack or removing characters from the stack take constant time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is also O(n), as we need to store the last_occurrence dictionary, the stack, and the visited set, all of which can have a maximum size of n, where n is the length of the input string s.\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        stack = []  # Initialize an empty stack to store characters\\n        last_occurrence = {}  # Store the last occurrence index of each character in a dictionary\\n        visited = set()  # Keep track of characters already visited\\n        \\n        # Populate the last_occurrence dictionary with the last index of each character in the string\\n        for i in range(len(s)):\\n            last_occurrence[s[i]] = i\\n        \\n        # Iterate through the characters in the string\\n        for i in range(len(s)):\\n            # If the character is already visited, skip it\\n            if s[i] in visited:\\n                continue\\n            \\n            # If the stack is not empty and the current character is smaller than the top of the stack,\\n            # and the top of the stack has more occurrences in the remaining string, pop the top of the stack\\n            # to maintain the lexicographically smallest result\\n            while stack and s[i] < stack[-1] and last_occurrence[stack[-1]] > i:\\n                visited.remove(stack.pop())\\n            \\n            # Append the current character to the stack and mark it as visited\\n            stack.append(s[i])\\n            visited.add(s[i])\\n        \\n        # Convert the stack to a string and return the result\\n        return \"\".join(stack)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        stack = []  # Initialize an empty stack to store characters\\n        last_occurrence = {}  # Store the last occurrence index of each character in a dictionary\\n        visited = set()  # Keep track of characters already visited\\n        \\n        # Populate the last_occurrence dictionary with the last index of each character in the string\\n        for i in range(len(s)):\\n            last_occurrence[s[i]] = i\\n        \\n        # Iterate through the characters in the string\\n        for i in range(len(s)):\\n            # If the character is already visited, skip it\\n            if s[i] in visited:\\n                continue\\n            \\n            # If the stack is not empty and the current character is smaller than the top of the stack,\\n            # and the top of the stack has more occurrences in the remaining string, pop the top of the stack\\n            # to maintain the lexicographically smallest result\\n            while stack and s[i] < stack[-1] and last_occurrence[stack[-1]] > i:\\n                visited.remove(stack.pop())\\n            \\n            # Append the current character to the stack and mark it as visited\\n            stack.append(s[i])\\n            visited.add(s[i])\\n        \\n        # Convert the stack to a string and return the result\\n        return \"\".join(stack)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3190262,
                "title": "easy-c-beats-100-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<bool> visited(s.size(),false);\\n        vector<int> lt_occurance(26);\\n        stack<char> st;\\n\\n        for(int i=0;i<s.length();i++)\\n            lt_occurance[s[i]-\\'a\\']=i;\\n\\n        for(int i=0;i<s.length();i++){\\n            int curr=s[i]-\\'a\\';\\n            if(visited[curr])   continue;\\n\\n            while(!st.empty() && st.top()>s[i] && i<lt_occurance[st.top()-\\'a\\']){\\n                visited[st.top()-\\'a\\']=false;\\n                st.pop();\\n            }\\n\\n            st.push(s[i]);\\n            visited[curr]=true;\\n        }\\n\\n        string ans=\"\";\\n        while(!st.empty()){\\n          ans=st.top()+ans;\\n          st.pop();\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<bool> visited(s.size(),false);\\n        vector<int> lt_occurance(26);\\n        stack<char> st;\\n\\n        for(int i=0;i<s.length();i++)\\n            lt_occurance[s[i]-\\'a\\']=i;\\n\\n        for(int i=0;i<s.length();i++){\\n            int curr=s[i]-\\'a\\';\\n            if(visited[curr])   continue;\\n\\n            while(!st.empty() && st.top()>s[i] && i<lt_occurance[st.top()-\\'a\\']){\\n                visited[st.top()-\\'a\\']=false;\\n                st.pop();\\n            }\\n\\n            st.push(s[i]);\\n            visited[curr]=true;\\n        }\\n\\n        string ans=\"\";\\n        while(!st.empty()){\\n          ans=st.top()+ans;\\n          st.pop();\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181656,
                "title": "eay-to-understan-in-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s){\\n        vector<char> stack;\\n        unordered_map<char,int> chars;\\n        for(char c: s) chars[c]++;\\n        \\n        for(char c : s){\\n            chars[c]--;\\n            if(find(stack.begin(), stack.end(), c) != stack.end() )\\n                continue;\\n            while( !stack.empty() && c < stack.back() && chars[stack.back()] > 0 )\\n                stack.pop_back();\\n            stack.push_back(c);\\n            \\n        }\\n        return string(stack.begin(), stack.end());\\n    }\\n    \\n    string removeDuplicateLetters(string s) {\\n         return removeDuplicates(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s){\\n        vector<char> stack;\\n        unordered_map<char,int> chars;\\n        for(char c: s) chars[c]++;\\n        \\n        for(char c : s){\\n            chars[c]--;\\n            if(find(stack.begin(), stack.end(), c) != stack.end() )\\n                continue;\\n            while( !stack.empty() && c < stack.back() && chars[stack.back()] > 0 )\\n                stack.pop_back();\\n            stack.push_back(c);\\n            \\n        }\\n        return string(stack.begin(), stack.end());\\n    }\\n    \\n    string removeDuplicateLetters(string s) {\\n         return removeDuplicates(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812770,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n    \\n        vector<int> cnt(26,0)  , vis(26,0);\\n        \\n        string res = \"\";\\n        int n = s.size();\\n        \\n        for(int i = 0; i<n; ++i)\\n            cnt[s[i] - \\'a\\']++;\\n        \\n        for(int i = 0; i<n; ++i)\\n        {\\n            cnt[s[i] - \\'a\\']--;\\n            \\n          \\n            if(!vis[s[i]- \\'a\\'])\\n            {\\n     \\n                while(res.size() > 0 && res.back() > s[i] && cnt[res.back() - \\'a\\'] > 0)\\n                {\\n                    vis[res.back() - \\'a\\'] = 0;\\n                    res.pop_back();\\n                }\\n                \\n          \\n                res += s[i];\\n                vis[s[i] - \\'a\\'] = 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n    \\n        vector<int> cnt(26,0)  , vis(26,0);\\n        \\n        string res = \"\";\\n        int n = s.size();\\n        \\n        for(int i = 0; i<n; ++i)\\n            cnt[s[i] - \\'a\\']++;\\n        \\n        for(int i = 0; i<n; ++i)\\n        {\\n            cnt[s[i] - \\'a\\']--;\\n            \\n          \\n            if(!vis[s[i]- \\'a\\'])\\n            {\\n     \\n                while(res.size() > 0 && res.back() > s[i] && cnt[res.back() - \\'a\\'] > 0)\\n                {\\n                    vis[res.back() - \\'a\\'] = 0;\\n                    res.pop_back();\\n                }\\n                \\n          \\n                res += s[i];\\n                vis[s[i] - \\'a\\'] = 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774994,
                "title": "remove-duplicate-letters-c",
                "content": "\\n```\\n\\n#  we are working on 3 strategy\\n  1. for maintaining the lexographical order we will maintain it in stack like Next Smaller Element\\n  2. we will keep in mind lastoccurance of character by using a vector.\\n  3. pop only at that condition when that element is going to come again (i<lastoccur[element])\\n     \\nclass Solution \\n{\\n  public:\\n    string removeDuplicateLetters(string s) \\n    {\\n        vector<int> lastoccur(26, 0);\\n        for(int i=0;i<s.length();i++)\\n            lastoccur[s[i]-\\'a\\'] = i; \\n        vector<bool>seen(26, false); \\n        stack<char>st;\\n        for (int i=0;i<s.size();i++) \\n        {\\n            int curr=s[i]-\\'a\\';\\n            if(seen[curr])\\n                 continue;   \\n            while(!st.empty() && st.top()>s[i] && i<lastoccur[st.top()-\\'a\\'])\\n            {\\n                seen[st.top()-\\'a\\']=false; \\n                st.pop();\\n            }\\n            st.push(s[i]); \\n            seen[curr]=true; \\n        }\\n        string res=\"\";\\n        while(!st.empty())\\n        {\\n            res += st.top();\\n            st.pop();\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\n\\n#  we are working on 3 strategy\\n  1. for maintaining the lexographical order we will maintain it in stack like Next Smaller Element\\n  2. we will keep in mind lastoccurance of character by using a vector.\\n  3. pop only at that condition when that element is going to come again (i<lastoccur[element])\\n     \\nclass Solution \\n{\\n  public:\\n    string removeDuplicateLetters(string s) \\n    {\\n        vector<int> lastoccur(26, 0);\\n        for(int i=0;i<s.length();i++)\\n            lastoccur[s[i]-\\'a\\'] = i; \\n        vector<bool>seen(26, false); \\n        stack<char>st;\\n        for (int i=0;i<s.size();i++) \\n        {\\n            int curr=s[i]-\\'a\\';\\n            if(seen[curr])\\n                 continue;   \\n            while(!st.empty() && st.top()>s[i] && i<lastoccur[st.top()-\\'a\\'])\\n            {\\n                seen[st.top()-\\'a\\']=false; \\n                st.pop();\\n            }\\n            st.push(s[i]); \\n            seen[curr]=true; \\n        }\\n        string res=\"\";\\n        while(!st.empty())\\n        {\\n            res += st.top();\\n            st.pop();\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687478,
                "title": "java-solution-stack",
                "content": "### Please upvote this solution as well as *[this](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/discuss/2687474/JAVA-Solution-or-Stack)* :D\\n```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        int n = s.length();\\n        boolean[] visited = new boolean[26];\\n        int[] lastIndex = new int[26];\\n\\n        for (int i = 0; i < n; i++) {\\n            lastIndex[s.charAt(i) - \\'a\\'] = i;\\n        }\\n\\n        Stack<Integer> stack = new Stack<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            int c = s.charAt(i) - \\'a\\';\\n\\n            if(visited[c]) continue;\\n            visited[c] = true;\\n\\n            while (!stack.isEmpty() && stack.peek() > c && lastIndex[stack.peek()] > i) {\\n                visited[stack.pop()] = false;\\n            }\\n\\n            stack.push(c);\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n\\n        for (Integer i : stack) {\\n            ans.append((char)(i + \\'a\\'));\\n        }\\n\\n        return ans.toString();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        int n = s.length();\\n        boolean[] visited = new boolean[26];\\n        int[] lastIndex = new int[26];\\n\\n        for (int i = 0; i < n; i++) {\\n            lastIndex[s.charAt(i) - \\'a\\'] = i;\\n        }\\n\\n        Stack<Integer> stack = new Stack<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            int c = s.charAt(i) - \\'a\\';\\n\\n            if(visited[c]) continue;\\n            visited[c] = true;\\n\\n            while (!stack.isEmpty() && stack.peek() > c && lastIndex[stack.peek()] > i) {\\n                visited[stack.pop()] = false;\\n            }\\n\\n            stack.push(c);\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n\\n        for (Integer i : stack) {\\n            ans.append((char)(i + \\'a\\'));\\n        }\\n\\n        return ans.toString();\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475090,
                "title": "c-easy-understanding-better-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> lastIndex(26, 0);\\n        for (int i = 0; i < s.length(); i++){\\n            lastIndex[s[i] - \\'a\\'] = i; \\n        }\\n        \\n        vector<bool> seen(26, false); \\n        stack<char> st;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            int curr = s[i] - \\'a\\';\\n            \\n            if (seen[curr]){\\n                 continue;\\n            }\\n            \\n            while(st.size() > 0 && st.top() > s[i] && i < lastIndex[st.top() - \\'a\\']){\\n                seen[st.top() - \\'a\\'] = false; \\n                st.pop();\\n            }\\n            st.push(s[i]); \\n            seen[curr] = true; \\n        }\\n        \\n        string res = \"\";\\n        while (st.size() > 0){\\n            res += st.top();\\n            st.pop();\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        vector<int> lastIndex(26, 0);\\n        for (int i = 0; i < s.length(); i++){\\n            lastIndex[s[i] - \\'a\\'] = i; \\n        }\\n        \\n        vector<bool> seen(26, false); \\n        stack<char> st;\\n        \\n        for (int i = 0; i < s.size(); i++) {\\n            int curr = s[i] - \\'a\\';\\n            \\n            if (seen[curr]){\\n                 continue;\\n            }\\n            \\n            while(st.size() > 0 && st.top() > s[i] && i < lastIndex[st.top() - \\'a\\']){\\n                seen[st.top() - \\'a\\'] = false; \\n                st.pop();\\n            }\\n            st.push(s[i]); \\n            seen[curr] = true; \\n        }\\n        \\n        string res = \"\";\\n        while (st.size() > 0){\\n            res += st.top();\\n            st.pop();\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2442732,
                "title": "java-mono-stack",
                "content": "```java\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        // collect char counts\\n        int[] charCounts = new int[256];\\n        for(char c : s.toCharArray()) {\\n            charCounts[c]++;\\n        }\\n        \\n        boolean[] inStack = new boolean[256];\\n        Stack<Character> chars = new Stack<>();\\n        for(char c : s.toCharArray()) {\\n            charCounts[c]--;\\n            \\n            if(inStack[c]) {\\n                continue;\\n            }\\n            \\n            // pop all chars larger than c and will apear later\\n            while(!chars.isEmpty() && chars.peek() > c) {\\n                // if a char have not follow, stop\\n                if(charCounts[chars.peek()] == 0) {\\n                    break;\\n                }\\n                \\n                inStack[chars.pop()] = false;\\n            }\\n            \\n            // push c\\n            chars.push(c);\\n            inStack[c] = true;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while(!chars.isEmpty()) {\\n            sb.append(chars.pop());\\n        }\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public String removeDuplicateLetters(String s) {\\n        // collect char counts\\n        int[] charCounts = new int[256];\\n        for(char c : s.toCharArray()) {\\n            charCounts[c]++;\\n        }\\n        \\n        boolean[] inStack = new boolean[256];\\n        Stack<Character> chars = new Stack<>();\\n        for(char c : s.toCharArray()) {\\n            charCounts[c]--;\\n            \\n            if(inStack[c]) {\\n                continue;\\n            }\\n            \\n            // pop all chars larger than c and will apear later\\n            while(!chars.isEmpty() && chars.peek() > c) {\\n                // if a char have not follow, stop\\n                if(charCounts[chars.peek()] == 0) {\\n                    break;\\n                }\\n                \\n                inStack[chars.pop()] = false;\\n            }\\n            \\n            // push c\\n            chars.push(c);\\n            inStack[c] = true;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while(!chars.isEmpty()) {\\n            sb.append(chars.pop());\\n        }\\n        \\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2394647,
                "title": "c-stack-hashmap",
                "content": "1. maintain a mono-increasing stack to save the final results\\n2. check if the current letter needs to be kept or discarded\\n    already in stack--> skip\\n    otherwise-->keep---> push to stack\\n    check if the top elements can be popped out\\n    the condition of popping out is `the top element will appear again later`\\n    \\n```\\n    string removeDuplicateLetters(string s) {\\n        stack<char> inc_stack;\\n        unordered_map<char, int> letter_counter;\\n        vector<int> used(26, 0);\\n        for(auto chr : s)\\n            letter_counter[chr]++;\\n        \\n        for(auto chr : s){\\n            letter_counter[chr]--;\\n            // if the letter has been used(in stack), skip\\n            if(used[chr - \\'a\\'])\\n                continue;\\n            // check if this top element may appear latter\\n            while(!inc_stack.empty() && inc_stack.top() > chr && letter_counter[inc_stack.top()] > 0){\\n                // the top element will appear latter, we can discard it savely \\n                used[inc_stack.top() - \\'a\\'] = 0;\\n                inc_stack.pop();\\n            }\\n            // never meet the string before, savely push it into stack\\n            inc_stack.push(chr);\\n            used[chr - \\'a\\'] = 1;\\n        }\\n        \\n        string res = \"\";\\n        while(!inc_stack.empty()){\\n            res = inc_stack.top() + res;\\n            inc_stack.pop();\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "1. maintain a mono-increasing stack to save the final results\\n2. check if the current letter needs to be kept or discarded\\n    already in stack--> skip\\n    otherwise-->keep---> push to stack\\n    check if the top elements can be popped out\\n    the condition of popping out is `the top element will appear again later`\\n    \\n```\\n    string removeDuplicateLetters(string s) {\\n        stack<char> inc_stack;\\n        unordered_map<char, int> letter_counter;\\n        vector<int> used(26, 0);\\n        for(auto chr : s)\\n            letter_counter[chr]++;\\n        \\n        for(auto chr : s){\\n            letter_counter[chr]--;\\n            // if the letter has been used(in stack), skip\\n            if(used[chr - \\'a\\'])\\n                continue;\\n            // check if this top element may appear latter\\n            while(!inc_stack.empty() && inc_stack.top() > chr && letter_counter[inc_stack.top()] > 0){\\n                // the top element will appear latter, we can discard it savely \\n                used[inc_stack.top() - \\'a\\'] = 0;\\n                inc_stack.pop();\\n            }\\n            // never meet the string before, savely push it into stack\\n            inc_stack.push(chr);\\n            used[chr - \\'a\\'] = 1;\\n        }\\n        \\n        string res = \"\";\\n        while(!inc_stack.empty()){\\n            res = inc_stack.top() + res;\\n            inc_stack.pop();\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2294014,
                "title": "c-using-map-and-stack-clean-code",
                "content": "class Solution {\\npublic:\\n\\n    string removeDuplicateLetters(string s) {\\n        unordered_map<char, int> lastidx; // stores last occurance of each character in a string.\\n        int n = s.size();\\n        for(int i=0; i<n; ++i) lastidx[s[i]] = i; // iterate over s to store last occurance of each character in map.\\n        \\n        vector<int> vis(26, 0); // to check if we have taken the current character before or not.0 means not taken\\n        vector<char> st; // use vector to simulate stack.\\n        \\n        for(int i = 0; i < n; ++i){\\n            if(vis[s[i] - \\'a\\']) continue;// if we have already taken the character before just go to next index.\\n            else {\\n                while(!st.empty() and st.back() > s[i] and lastidx[st.back()] > i){\\n                    vis[st.back() - \\'a\\'] = 0; // By subtracting char of \\'a\\', we are converting the char to int.\\n                    st.pop_back();\\n                }\\n                st.push_back(s[i]);\\n                vis[s[i] - \\'a\\'] = 1;\\n            }\\n        }\\n\\t\\t// At last, stack contains the required string, so just iterate over it and store ans in string and return.\\n        string ans;\\n        for(auto c: st) ans += c;\\n\\t\\t\\n        return ans;\\n    }\\n};\\n\\n**Time: O(N),\\nSpace: O(N)\\nPLEASE UPVOTE IF HELPFUL!!!**\\nFor doubt or query, comment below.\\n\\nSimilar problem: Leetcode 1081: https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string removeDuplicateLetters(string s) {\\n        unordered_map<char, int> lastidx; // stores last occurance of each character in a string.\\n        int n = s.size();\\n        for(int i=0; i<n; ++i) lastidx[s[i]] = i; // iterate over s to store last occurance of each character in map.\\n        \\n        vector<int> vis(26, 0); // to check if we have taken the current character before or not.0 means not taken\\n        vector<char> st; // use vector to simulate stack.\\n        \\n        for(int i = 0; i < n; ++i){\\n            if(vis[s[i] - \\'a\\']) continue;// if we have already taken the character before just go to next index.\\n            else {\\n                while(!st.empty() and st.back() > s[i] and lastidx[st.back()] > i){\\n                    vis[st.back() - \\'a\\'] = 0; // By subtracting char of \\'a\\', we are converting the char to int.\\n                    st.pop_back();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2270618,
                "title": "python-o-n-stack-set-hashmap-easy-to-understand",
                "content": "**We are going to make use of SET, HASHMAP, AND STACK.**\\n\\n1.  First we are storing the last index of each and every element\\n2.  Then we are comparing each and every element wehther it is not present in the visited SET.\\n3.  IF it is not present.\\n4.  We are going to run a while loop.\\n5.  CONDITIONS = 1. STACK NOT EMPTY 2. STACK TOP > CURRENT ELEMENT VALUE 3. HASHMAP VALUE OF I WHIHC IS PRESENT IN STACK > CURRENT ELEMENT VALUE.\\n6.  IF  all conditions satsify then we are going to remove the element from the visited set, which is the element which we are going to pop out from the stack.\\n7.  If condition is not satisfied then we have to APPEND the current element value into the stack and also ADD the value into the set.\\n8.  Finally we have to JOIN all the avlues present in the stack into the set.\\n\\n\\nclass Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        \\n        \\n        last_index = {}\\n        stack = []\\n        visited = set()\\n        \\n        for i in range(len(s)):\\n            last_index[s[i]]  = i\\n\\n\\n        for i in range(len(s)):\\n            if s[i] not in visited:\\n                while stack and stack[-1] > s[i] and last_index[stack[-1]] > i:\\n                    visited.remove(stack.pop())\\n                stack.append(s[i])\\n                visited.add(s[i])\\n        return \\'\\'.join(stack)",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Ordered Set"
                ],
                "code": "class Solution:\\n    def removeDuplicateLetters(self, s: str) -> str:\\n        \\n        \\n        last_index = {}",
                "codeTag": "Java"
            },
            {
                "id": 2174706,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int hash[26]={0};\\n        bool vis[26]={0};\\n        int n=s.size();\\n        for(int i=0; i<n; i++) hash[s[i]-\\'a\\']++;\\n        string ans;\\n        for(char c:s) {\\n            hash[c-\\'a\\']--;\\n            if(vis[c-\\'a\\']) continue;\\n            while(!ans.empty()&&c<ans.back()&&hash[ans.back()-\\'a\\']) {\\n                vis[ans.back()-\\'a\\']=0;\\n                ans.pop_back();\\n            }\\n            ans+=c;\\n            vis[c-\\'a\\']=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int hash[26]={0};\\n        bool vis[26]={0};\\n        int n=s.size();\\n        for(int i=0; i<n; i++) hash[s[i]-\\'a\\']++;\\n        string ans;\\n        for(char c:s) {\\n            hash[c-\\'a\\']--;\\n            if(vis[c-\\'a\\']) continue;\\n            while(!ans.empty()&&c<ans.back()&&hash[ans.back()-\\'a\\']) {\\n                vis[ans.back()-\\'a\\']=0;\\n                ans.pop_back();\\n            }\\n            ans+=c;\\n            vis[c-\\'a\\']=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865016,
                "title": "simple-python-code-using-stack-and-hashtable",
                "content": "\\t\\thasht=dict()\\n        stack=[s[0]]\\n        \\n        for i in range(len(s)):\\n            hasht[s[i]]=i\\n            \\n        for i in range(1, len(s)):\\n            ## pop existing char from stack if a new smaller char is enccountered     \\n            while stack and s[i] not in stack and s[i]<stack[-1] and i<hasht[stack[-1]] :\\n                stack.pop()\\n            \\n            if s[i] not in stack:\\n                stack.append(s[i])\\n                \\n        return \"\".join(stack)",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t\\thasht=dict()\\n        stack=[s[0]]\\n        \\n        for i in range(len(s)):\\n            hasht[s[i]]=i\\n            \\n        for i in range(1, len(s)):\\n            ## pop existing char from stack if a new smaller char is enccountered     \\n            while stack and s[i] not in stack and s[i]<stack[-1] and i<hasht[stack[-1]] :\\n                stack.pop()\\n            \\n            if s[i] not in stack:\\n                stack.append(s[i])\\n                \\n        return \"\".join(stack)",
                "codeTag": "Unknown"
            },
            {
                "id": 1861374,
                "title": "java-solution-o-n",
                "content": "\\tpublic String removeDuplicateLetters(String s) \\n    {\\n        int last_occ[] = new int[26];\\n        HashSet<Character> hs = new HashSet<>();\\n        Stack<Character> stk = new Stack<>();\\n        int start = -1;\\n        \\n        for(int i=0;i<s.length();i++)\\n            last_occ[s.charAt(i)-\\'a\\'] = i;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char c = s.charAt(i);\\n            if(!hs.contains(c))\\n            {\\n                while(!stk.isEmpty() && stk.peek()>c && last_occ[stk.peek()-\\'a\\']>i)\\n                {\\n                    hs.remove(stk.pop());\\n                }\\n                hs.add(c);\\n                stk.push(c);\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(char x:stk)\\n            sb.append(x);\\n        \\n        return sb.toString();\\n    }",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "\\tpublic String removeDuplicateLetters(String s) \\n    {\\n        int last_occ[] = new int[26];\\n        HashSet<Character> hs = new HashSet<>();\\n        Stack<Character> stk = new Stack<>();\\n        int start = -1;\\n        \\n        for(int i=0;i<s.length();i++)\\n            last_occ[s.charAt(i)-\\'a\\'] = i;\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            char c = s.charAt(i);\\n            if(!hs.contains(c))\\n            {\\n                while(!stk.isEmpty() && stk.peek()>c && last_occ[stk.peek()-\\'a\\']>i)\\n                {\\n                    hs.remove(stk.pop());\\n                }\\n                hs.add(c);\\n                stk.push(c);\\n            }\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        for(char x:stk)\\n            sb.append(x);\\n        \\n        return sb.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1861361,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public String removeDuplicateLetters(String s) {\\n        Stack<Character> nm=new Stack<>();\\n        int a[] = new int[26];\\n        boolean b[] = new boolean[26];\\n        for(char c:s.toCharArray())\\n        {\\n            a[c-\\'a\\']++;\\n        }\\n        int k=s.length();\\n        for(int i=0;i<k;i++)\\n        {\\n            char f=s.charAt(i);\\n            a[f-\\'a\\']--;\\n            if(b[f-\\'a\\'])\\n                continue;\\n            while(!nm.isEmpty())\\n            {\\n                if(f<nm.peek()&&a[nm.peek()-\\'a\\']!=0)\\n                {\\n                    b[nm.peek()-\\'a\\']=false;\\n                    nm.pop();\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n            nm.push(f);\\n            b[f-\\'a\\']=true;\\n        }\\n        StringBuilder kk=new StringBuilder();\\n        Iterator ff = nm.iterator();\\n        while (ff.hasNext()) \\n        {\\n            kk.append(ff.next());\\n        }\\n        return kk.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "class Solution {\\n\\n    public String removeDuplicateLetters(String s) {\\n        Stack<Character> nm=new Stack<>();\\n        int a[] = new int[26];\\n        boolean b[] = new boolean[26];\\n        for(char c:s.toCharArray())\\n        {\\n            a[c-\\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1861229,
                "title": "without-stack-100-faster-than-other-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) \\n    {\\n        unordered_map<char, int> map;\\n        for (int i = 0; i < s.size(); i++)\\n            map[s[i]]++;\\n        string ans = \"\";\\n        vector<bool> visited(26, false);\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (visited[s[i] - \\'a\\'])\\n                map[s[i]]--;\\n            while (ans.size() > 0 && visited[s[i] - \\'a\\'] == false && ans.back() >= s[i] && map[ans.back()] > 1)\\n            {\\n                visited[ans.back() - \\'a\\'] = false;\\n                map[ans.back()]--;\\n                ans.pop_back();\\n            }\\n            if (!visited[s[i] - \\'a\\'])\\n            {\\n                ans.push_back(s[i]);\\n                visited[s[i] - \\'a\\'] = true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) \\n    {\\n        unordered_map<char, int> map;\\n        for (int i = 0; i < s.size(); i++)\\n            map[s[i]]++;\\n        string ans = \"\";\\n        vector<bool> visited(26, false);\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            if (visited[s[i] - \\'a\\'])\\n                map[s[i]]--;\\n            while (ans.size() > 0 && visited[s[i] - \\'a\\'] == false && ans.back() >= s[i] && map[ans.back()] > 1)\\n            {\\n                visited[ans.back() - \\'a\\'] = false;\\n                map[ans.back()]--;\\n                ans.pop_back();\\n            }\\n            if (!visited[s[i] - \\'a\\'])\\n            {\\n                ans.push_back(s[i]);\\n                visited[s[i] - \\'a\\'] = true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861180,
                "title": "simplest-map-and-stack-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        map<char, int>mp;\\n        int n = s.length();\\n        for(int i=0; i<n; i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        \\n        stack<char>st;\\n        vector<bool>visited(26, false);\\n        for(int i=0; i<n; i++)\\n        {\\n            mp[s[i]]--;\\n            if(visited[s[i]-\\'a\\'])\\n            {\\n                continue;\\n            }\\n            \\n            while(!st.empty() && st.top()>s[i] && mp[st.top()]>0)\\n            {\\n                visited[st.top()-\\'a\\'] = false;\\n                st.pop();\\n            }\\n            \\n            st.push(s[i]);\\n            visited[s[i]-\\'a\\'] = true;\\n        }\\n            \\n        string ans = \"\";\\n        while(!st.empty())\\n        {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n\\n//Pls upvote if u find the solution helpful...!! Thanks..!!\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        map<char, int>mp;\\n        int n = s.length();\\n        for(int i=0; i<n; i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n        \\n        stack<char>st;\\n        vector<bool>visited(26, false);\\n        for(int i=0; i<n; i++)\\n        {\\n            mp[s[i]]--;\\n            if(visited[s[i]-\\'a\\'])\\n            {\\n                continue;\\n            }\\n            \\n            while(!st.empty() && st.top()>s[i] && mp[st.top()]>0)\\n            {\\n                visited[st.top()-\\'a\\'] = false;\\n                st.pop();\\n            }\\n            \\n            st.push(s[i]);\\n            visited[s[i]-\\'a\\'] = true;\\n        }\\n            \\n        string ans = \"\";\\n        while(!st.empty())\\n        {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n\\n//Pls upvote if u find the solution helpful...!! Thanks..!!\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1631067,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 1853702,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 1565968,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 2072618,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 1566993,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 1565747,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 1566641,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 1566545,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 1566343,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 2072736,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 1631067,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 1853702,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 1565968,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 2072618,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 1566993,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 1565747,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 1566641,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 1566545,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 1566343,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 2072736,
                "content": [
                    {
                        "username": "ealejandria",
                        "content": "**Explanation of _smallest lexicographical order among all possible results_**\\n\\nFirst, lexicographical order is first determined by string length and then alphabetical order. Since the string length is predetermined by the constraints of the question (every letter appears once and only once) we only care about the alphabetical order.\\n\\nSecond, and more importantly, we\\'re looking for lexicographical order **among all possible results**. That means for the second example of \"cbacdcbc\" we first determine what all possible results are...\\n\\n\"**cba**c**d**cbc\" = \"cbad\"\\n\"**c**b**a**c**d**c**b**c\" = \"cadb\"\\n\"c**bacd**cbc\" = \"bacd\"\\n\"c**ba**c**dc**bc\" = \"badc\"\\n\"c**ba**c**d**cb**c**\" = \"badc\" (Note: This is a duplicate result but is a different subset of the original string than the last result.)\\n\"cb**acd**c**b**c\" = \"acdb\"\\n\"cb**a**c**dcb**c\" = \"adcb\"\\n\"cb**a**c**d**c**bc**\" = \"adbc\"\\n\\nand once we order the results lexicographically...\\n1. \"acdb\"\\n2. \"adbc\"\\n3. \"adcb\"\\n4. \"bacd\"\\n5. \"badc\"\\n6. \"badc\"\\n7. \"cadb\"\\n8. \"cbad\"\\n\\nwe see that our first result is \"acdb\".\\n\\nA common question I see in the discussions is \"Why isn\\'t the answer abcd\" and I hope this explanation helps demonstrate that, while \"abcd\" is indeed lexicographically smaller, it is not actually one of our results since it\\'s not a subset of the original string. Remember that our only operation available is _removing_ characters from the string; we cannot reorganize the characters.\\n\\nIt took me a minute to figure out after reading the question and I hope this helps other people out!"
                    },
                    {
                        "username": "vinaybhardwaj2334",
                        "content": "Now it makes sense to put this question in medium category."
                    },
                    {
                        "username": "Androw77",
                        "content": "Thanks I saw the first example and solved it based on abcd ur explanation cleared things out"
                    },
                    {
                        "username": "rajkariya2003",
                        "content": "Good explanation"
                    },
                    {
                        "username": "abhishekpati",
                        "content": "still i dont understand what the question is asking\\n"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "rahulgksvv",
                        "content": "Thanks for the explanation, was confused for a second"
                    },
                    {
                        "username": "kr_vishnu",
                        "content": "It should be in hard category"
                    },
                    {
                        "username": "sameer89",
                        "content": "I also think the same. I was able to think it was mono stack from the start but the \"trick\" is much more than that. Which is the basic definition of a leetcode hard."
                    },
                    {
                        "username": "user5400vw",
                        "content": "glad i\\'m not the only one who thinks so!"
                    },
                    {
                        "username": "ChenxiLu",
                        "content": "It used to be categorized as Hard, but downgraded to Medium for some reason. "
                    },
                    {
                        "username": "revaries",
                        "content": "Because clearly \"acdb\" is not in lexicographical order. Am I missing something"
                    },
                    {
                        "username": "bharshit468",
                        "content": "[@gary_gosh]bro ans string will be \"bloms\""
                    },
                    {
                        "username": "gary_gosh",
                        "content": "[@bharshit468](/bharshit468) what if the sting is \"lobombloms\""
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The must also be a subsequence of the original string. Other replies to this comment just not give this simple answer. Hope that helps. "
                    },
                    {
                        "username": "bharshit468",
                        "content": "condition is ---> every char ---> come only ones\n\nconsidered \"cbacdcbc\"\n\nlets try to iterate\n\nc come --> ans -> c\nb come ---> question your self is \"c\" also came in future yes so delete it and  start with ans = b\na come --> b also came in future delete start with a\nc come --> a is small  ans = \"ac\"\nd come ---> c is  small ans = \"acd\"\nc come --> oHH c is already a part of string skip it\nb come --> d is largest Ques . --> may a delete this?\n    ans is no because if we delete --> in future  b never come ---> so we have to consider this in our string\n    So, ans = \"acdb\"\nc come --> oHH c is already a part of string skip it\n\nSo, ans = \"acdb\" --> I think that's help you out\n"
                    },
                    {
                        "username": "CaptainStark07",
                        "content": "Key point is AMONG ALL POSSIBLE RESULT "
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "I think you are confused b/w \"Alphabetical Order\" and \"Lexicographically Smallest\""
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "workcool",
                        "content": "is this really a medium? always feel this is tricky enough to qualify for a hard rating.."
                    },
                    {
                        "username": "deepak1302",
                        "content": "Input: s = \"cbacdcbc\"\\nOutput: \"acdb\"\\n\\nin this output is \\'acdb\\' . Shouldn\\'t it be \\'abcd\\' ??? abcd is lexographically smaller than acdb"
                    },
                    {
                        "username": "knitin",
                        "content": "order to be consider of letters according to given in input ."
                    },
                    {
                        "username": "truongphamminh17",
                        "content": "read the question carefully bro"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "It is Medium, not Easy, man"
                    },
                    {
                        "username": "harshjivani8105",
                        "content": "ORDER SHOULD BE AS PER GIVEN IN QUESTION"
                    },
                    {
                        "username": "iamab6742",
                        "content": "It\\'s not ,we need to consider the order as given in the string acdb is a substring and amongst all the substring of size equal to 4 it comes before all others."
                    },
                    {
                        "username": "charanarc3",
                        "content": "abcd is not a sub sequence"
                    },
                    {
                        "username": "WHJ425",
                        "content": "Input:\\n\"bbcaac\"\\nOutput:\\n\"bac\"\\nExpected:\\n\"bca\""
                    },
                    {
                        "username": "yash_gajewar",
                        "content": "lexographically smallest \"substring\""
                    },
                    {
                        "username": "m_chamanara",
                        "content": "Expected is \"bac\" I just tried it\\n"
                    },
                    {
                        "username": "chenon",
                        "content": "I am confused about the lexical order of the result.\\nIsn\\'t the smallest letter always on the left most ?\\n\\n`Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is the smallest in lexicographical order among all possible results.`\\n\\nExample2 = \"cbacdcbc\"\\nOutput: \"acdb\" ?  \\nWhy not \"abcd\" ? **Can you show steps by steps ?**\\n\\nExample3 = \"zyxwvut\"\\noutput = \"zyxwvut\" , the order is kept\\n\\nExample3 = \"zyxwvutztux\", the letters appear about more twice.\\noutput = \"ywvtzux\"\\n\\n"
                    },
                    {
                        "username": "sameer89",
                        "content": "It has been too long but if someone is still confused: The order must be such that it appears in the original string. There is no subsequence of characters in `cbacdcbc` that form `abcd`\n```\nc b a c d c b c\n    0 1 2   3\n```"
                    },
                    {
                        "username": "maddy9",
                        "content": "I am lost in the example of s=\"cbacdcbc\" . The question is not very well explained. According to me the answer should be \"abcd\" but it is not. So I am lost. It would be great if someone can explain me what the question is saying\\n"
                    },
                    {
                        "username": "AnywaySo",
                        "content": "According to you, the problem should be Easy, not Medium."
                    },
                    {
                        "username": "brijesh_singh",
                        "content": "question has asked for the Lexicographically Smaller subsequence with non-repeating characters"
                    },
                    {
                        "username": "mohitkanwal2022",
                        "content": "\"abcd\" cannot be generated from this string \\n"
                    },
                    {
                        "username": "pratik-2707",
                        "content": "nope u didn\\'t understand the question ."
                    },
                    {
                        "username": "dhtmlkitchen",
                        "content": "\"You must make sure your result is the smallest in lexicographical order among all possible results.\"\\n\\nWhat does this mean? Can you give an example?"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Explanation:\nThere a many people confused in the comments. if you are one of the them then this comment is for you.\nThe goal of this problem is to find a string `answer` that satisfies these conditions: \n- the `answer` must contains all the letters that are there in the original string `s`.\n- the `answer` must not have any duplicate character.\n- the `answer` must be a ***subsequence*** of the original string `s`.\n- in case multiple strings pass the above 3 conditions, return the one which is ***lexicographically smallest***.\n\nHope that helps.\n(Please upvote so that other people can see this comment as well.)\n\n### Examples :\n\nLet original string `s` = \"cbacdcbc\"\n\n###### Then some of the wrong answers are :\n- \"abc\" ( doesnt contains all letters from `s` i.e. 'd' is missing. Condition 1 fails. )\n- \"acdbc\" ( contains duplicates i.e. 'c' is used twice. Condition 2 fails. )\n- \"abcd\" ( isn't a subsequence of `s`. Condition 3 fails. )\n\n###### Some candidates which pass the first 3 conditions (in lexicographical order) are :\n*\"acdb\"*, *\"adbc\"*, *\"adcb\"*, *\"bacd\"*, *\"badc\"*, *\"cadb\"*, *\"cbad\"*\nOut of these lexicographically smallest string is ***\"acdb\"***. And that is our answer.\n\nreturn `answer` = \"acdb\""
                    }
                ]
            },
            {
                "id": 2072538,
                "content": [
                    {
                        "username": "Verma_03",
                        "content": "Ram Ram bhai sareya ne"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Aaj hai mere leetcode hard ka 68 waah din aur yeh ques mere te hil na rha hai"
                    },
                    {
                        "username": "chenhaoyu",
                        "content": "I don't quite understand this sentence. \"You must make sure your result is the smallest in lexicographical order among all possible results.\", Can anyone give more examples about this?\\n\\nThanks!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Correction:-`\\n\\nThe answer must be a `subsequence` of string `s`."
                    },
                    {
                        "username": "jovizhu",
                        "content": "Why the return of \"cbacdcbc\" is \"acdb\"? Should be \"adbc\"?\\nCann't understand it.\\n\\nthanks"
                    },
                    {
                        "username": "helowl",
                        "content": "acdb is lexigraphically smallest"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Is this really a medium problem? Why do I find it hard? "
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@sentenzo](/sentenzo) Yeah, even that question is marked Medium somehow. "
                    },
                    {
                        "username": "sentenzo",
                        "content": "[Leetcode Problem Rating](https://zerotrac.github.io/leetcode_problem_rating/) gives it 2184 points \\u2014 which is also quite a lot..."
                    },
                    {
                        "username": "sentenzo",
                        "content": "[1081](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/description/) is identical to this one, and it was the [Q4 of Weekly Contest 140](https://leetcode.com/contest/weekly-contest-140/) \\u2014 so it should be marked as hard indeed."
                    },
                    {
                        "username": "roman-mc",
                        "content": "I\\'m sure it\\'s almost impossible to solve on a real interview, too obscure the problem at first, and it unfolds unexpectedly difficulty "
                    },
                    {
                        "username": "christen",
                        "content": "Hello, every one.\\n\\nI am not sure I quite understand the requirement.\\nThe answer for \"cbacdcbc\", should it be \"abcd\" ?\\n\\nThanks,"
                    },
                    {
                        "username": "Beingash22",
                        "content": "These Stack questions are really hard to figure out. At first, this looked straight away a map question."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Before submitting, make sure to have comprehensive testcases, e.g. \\n```\\n\"czrehqbgodazisnxknjnysgaytklkxybzmjnqjgeinniaewoqkrzmuxtavfcnsolkmcpnvawlowsaqucgnwzdvhnxlnxlpbnuhvcjipelapcuxfuimkxvvlwqbvrsgqpyxhqufjvemxuinxmdgpgwjomgejoxklagnckxyoscptmzweieedmecoubsvwkjiejtfuxuygxkprttvaqhqklyxxssmliwrtfcqbxcuoeprsxqdcffstcygumdiuufhclwwentneukzttlvnnkjqwpugadgnowagjcpfofcihire\"\\n\"azzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\"\\n\"g\"\\n\"zyxwvutsrqponmlkjihgfedcbaabcdefghijklmnopqrstuvwxyz\"\\n```\\nand feel free to check out the growing repo of testcases for the daily challenges: https://github.com/mquintus/l33tcode-testcase-generator/"
                    },
                    {
                        "username": "pcRipper",
                        "content": "i have not seen such a useful thing in a years, thank you so much!!!"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Time Limit Exceeded 289 / 290 testcases passed, come on..."
                    }
                ]
            },
            {
                "id": 1565435,
                "content": [
                    {
                        "username": "Verma_03",
                        "content": "Ram Ram bhai sareya ne"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Aaj hai mere leetcode hard ka 68 waah din aur yeh ques mere te hil na rha hai"
                    },
                    {
                        "username": "chenhaoyu",
                        "content": "I don't quite understand this sentence. \"You must make sure your result is the smallest in lexicographical order among all possible results.\", Can anyone give more examples about this?\\n\\nThanks!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Correction:-`\\n\\nThe answer must be a `subsequence` of string `s`."
                    },
                    {
                        "username": "jovizhu",
                        "content": "Why the return of \"cbacdcbc\" is \"acdb\"? Should be \"adbc\"?\\nCann't understand it.\\n\\nthanks"
                    },
                    {
                        "username": "helowl",
                        "content": "acdb is lexigraphically smallest"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Is this really a medium problem? Why do I find it hard? "
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@sentenzo](/sentenzo) Yeah, even that question is marked Medium somehow. "
                    },
                    {
                        "username": "sentenzo",
                        "content": "[Leetcode Problem Rating](https://zerotrac.github.io/leetcode_problem_rating/) gives it 2184 points \\u2014 which is also quite a lot..."
                    },
                    {
                        "username": "sentenzo",
                        "content": "[1081](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/description/) is identical to this one, and it was the [Q4 of Weekly Contest 140](https://leetcode.com/contest/weekly-contest-140/) \\u2014 so it should be marked as hard indeed."
                    },
                    {
                        "username": "roman-mc",
                        "content": "I\\'m sure it\\'s almost impossible to solve on a real interview, too obscure the problem at first, and it unfolds unexpectedly difficulty "
                    },
                    {
                        "username": "christen",
                        "content": "Hello, every one.\\n\\nI am not sure I quite understand the requirement.\\nThe answer for \"cbacdcbc\", should it be \"abcd\" ?\\n\\nThanks,"
                    },
                    {
                        "username": "Beingash22",
                        "content": "These Stack questions are really hard to figure out. At first, this looked straight away a map question."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Before submitting, make sure to have comprehensive testcases, e.g. \\n```\\n\"czrehqbgodazisnxknjnysgaytklkxybzmjnqjgeinniaewoqkrzmuxtavfcnsolkmcpnvawlowsaqucgnwzdvhnxlnxlpbnuhvcjipelapcuxfuimkxvvlwqbvrsgqpyxhqufjvemxuinxmdgpgwjomgejoxklagnckxyoscptmzweieedmecoubsvwkjiejtfuxuygxkprttvaqhqklyxxssmliwrtfcqbxcuoeprsxqdcffstcygumdiuufhclwwentneukzttlvnnkjqwpugadgnowagjcpfofcihire\"\\n\"azzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\"\\n\"g\"\\n\"zyxwvutsrqponmlkjihgfedcbaabcdefghijklmnopqrstuvwxyz\"\\n```\\nand feel free to check out the growing repo of testcases for the daily challenges: https://github.com/mquintus/l33tcode-testcase-generator/"
                    },
                    {
                        "username": "pcRipper",
                        "content": "i have not seen such a useful thing in a years, thank you so much!!!"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Time Limit Exceeded 289 / 290 testcases passed, come on..."
                    }
                ]
            },
            {
                "id": 2072545,
                "content": [
                    {
                        "username": "Verma_03",
                        "content": "Ram Ram bhai sareya ne"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Aaj hai mere leetcode hard ka 68 waah din aur yeh ques mere te hil na rha hai"
                    },
                    {
                        "username": "chenhaoyu",
                        "content": "I don't quite understand this sentence. \"You must make sure your result is the smallest in lexicographical order among all possible results.\", Can anyone give more examples about this?\\n\\nThanks!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Correction:-`\\n\\nThe answer must be a `subsequence` of string `s`."
                    },
                    {
                        "username": "jovizhu",
                        "content": "Why the return of \"cbacdcbc\" is \"acdb\"? Should be \"adbc\"?\\nCann't understand it.\\n\\nthanks"
                    },
                    {
                        "username": "helowl",
                        "content": "acdb is lexigraphically smallest"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Is this really a medium problem? Why do I find it hard? "
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@sentenzo](/sentenzo) Yeah, even that question is marked Medium somehow. "
                    },
                    {
                        "username": "sentenzo",
                        "content": "[Leetcode Problem Rating](https://zerotrac.github.io/leetcode_problem_rating/) gives it 2184 points \\u2014 which is also quite a lot..."
                    },
                    {
                        "username": "sentenzo",
                        "content": "[1081](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/description/) is identical to this one, and it was the [Q4 of Weekly Contest 140](https://leetcode.com/contest/weekly-contest-140/) \\u2014 so it should be marked as hard indeed."
                    },
                    {
                        "username": "roman-mc",
                        "content": "I\\'m sure it\\'s almost impossible to solve on a real interview, too obscure the problem at first, and it unfolds unexpectedly difficulty "
                    },
                    {
                        "username": "christen",
                        "content": "Hello, every one.\\n\\nI am not sure I quite understand the requirement.\\nThe answer for \"cbacdcbc\", should it be \"abcd\" ?\\n\\nThanks,"
                    },
                    {
                        "username": "Beingash22",
                        "content": "These Stack questions are really hard to figure out. At first, this looked straight away a map question."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Before submitting, make sure to have comprehensive testcases, e.g. \\n```\\n\"czrehqbgodazisnxknjnysgaytklkxybzmjnqjgeinniaewoqkrzmuxtavfcnsolkmcpnvawlowsaqucgnwzdvhnxlnxlpbnuhvcjipelapcuxfuimkxvvlwqbvrsgqpyxhqufjvemxuinxmdgpgwjomgejoxklagnckxyoscptmzweieedmecoubsvwkjiejtfuxuygxkprttvaqhqklyxxssmliwrtfcqbxcuoeprsxqdcffstcygumdiuufhclwwentneukzttlvnnkjqwpugadgnowagjcpfofcihire\"\\n\"azzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\"\\n\"g\"\\n\"zyxwvutsrqponmlkjihgfedcbaabcdefghijklmnopqrstuvwxyz\"\\n```\\nand feel free to check out the growing repo of testcases for the daily challenges: https://github.com/mquintus/l33tcode-testcase-generator/"
                    },
                    {
                        "username": "pcRipper",
                        "content": "i have not seen such a useful thing in a years, thank you so much!!!"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Time Limit Exceeded 289 / 290 testcases passed, come on..."
                    }
                ]
            },
            {
                "id": 1566779,
                "content": [
                    {
                        "username": "Verma_03",
                        "content": "Ram Ram bhai sareya ne"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Aaj hai mere leetcode hard ka 68 waah din aur yeh ques mere te hil na rha hai"
                    },
                    {
                        "username": "chenhaoyu",
                        "content": "I don't quite understand this sentence. \"You must make sure your result is the smallest in lexicographical order among all possible results.\", Can anyone give more examples about this?\\n\\nThanks!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Correction:-`\\n\\nThe answer must be a `subsequence` of string `s`."
                    },
                    {
                        "username": "jovizhu",
                        "content": "Why the return of \"cbacdcbc\" is \"acdb\"? Should be \"adbc\"?\\nCann't understand it.\\n\\nthanks"
                    },
                    {
                        "username": "helowl",
                        "content": "acdb is lexigraphically smallest"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Is this really a medium problem? Why do I find it hard? "
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@sentenzo](/sentenzo) Yeah, even that question is marked Medium somehow. "
                    },
                    {
                        "username": "sentenzo",
                        "content": "[Leetcode Problem Rating](https://zerotrac.github.io/leetcode_problem_rating/) gives it 2184 points \\u2014 which is also quite a lot..."
                    },
                    {
                        "username": "sentenzo",
                        "content": "[1081](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/description/) is identical to this one, and it was the [Q4 of Weekly Contest 140](https://leetcode.com/contest/weekly-contest-140/) \\u2014 so it should be marked as hard indeed."
                    },
                    {
                        "username": "roman-mc",
                        "content": "I\\'m sure it\\'s almost impossible to solve on a real interview, too obscure the problem at first, and it unfolds unexpectedly difficulty "
                    },
                    {
                        "username": "christen",
                        "content": "Hello, every one.\\n\\nI am not sure I quite understand the requirement.\\nThe answer for \"cbacdcbc\", should it be \"abcd\" ?\\n\\nThanks,"
                    },
                    {
                        "username": "Beingash22",
                        "content": "These Stack questions are really hard to figure out. At first, this looked straight away a map question."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Before submitting, make sure to have comprehensive testcases, e.g. \\n```\\n\"czrehqbgodazisnxknjnysgaytklkxybzmjnqjgeinniaewoqkrzmuxtavfcnsolkmcpnvawlowsaqucgnwzdvhnxlnxlpbnuhvcjipelapcuxfuimkxvvlwqbvrsgqpyxhqufjvemxuinxmdgpgwjomgejoxklagnckxyoscptmzweieedmecoubsvwkjiejtfuxuygxkprttvaqhqklyxxssmliwrtfcqbxcuoeprsxqdcffstcygumdiuufhclwwentneukzttlvnnkjqwpugadgnowagjcpfofcihire\"\\n\"azzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\"\\n\"g\"\\n\"zyxwvutsrqponmlkjihgfedcbaabcdefghijklmnopqrstuvwxyz\"\\n```\\nand feel free to check out the growing repo of testcases for the daily challenges: https://github.com/mquintus/l33tcode-testcase-generator/"
                    },
                    {
                        "username": "pcRipper",
                        "content": "i have not seen such a useful thing in a years, thank you so much!!!"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Time Limit Exceeded 289 / 290 testcases passed, come on..."
                    }
                ]
            },
            {
                "id": 2072766,
                "content": [
                    {
                        "username": "Verma_03",
                        "content": "Ram Ram bhai sareya ne"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Aaj hai mere leetcode hard ka 68 waah din aur yeh ques mere te hil na rha hai"
                    },
                    {
                        "username": "chenhaoyu",
                        "content": "I don't quite understand this sentence. \"You must make sure your result is the smallest in lexicographical order among all possible results.\", Can anyone give more examples about this?\\n\\nThanks!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Correction:-`\\n\\nThe answer must be a `subsequence` of string `s`."
                    },
                    {
                        "username": "jovizhu",
                        "content": "Why the return of \"cbacdcbc\" is \"acdb\"? Should be \"adbc\"?\\nCann't understand it.\\n\\nthanks"
                    },
                    {
                        "username": "helowl",
                        "content": "acdb is lexigraphically smallest"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Is this really a medium problem? Why do I find it hard? "
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@sentenzo](/sentenzo) Yeah, even that question is marked Medium somehow. "
                    },
                    {
                        "username": "sentenzo",
                        "content": "[Leetcode Problem Rating](https://zerotrac.github.io/leetcode_problem_rating/) gives it 2184 points \\u2014 which is also quite a lot..."
                    },
                    {
                        "username": "sentenzo",
                        "content": "[1081](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/description/) is identical to this one, and it was the [Q4 of Weekly Contest 140](https://leetcode.com/contest/weekly-contest-140/) \\u2014 so it should be marked as hard indeed."
                    },
                    {
                        "username": "roman-mc",
                        "content": "I\\'m sure it\\'s almost impossible to solve on a real interview, too obscure the problem at first, and it unfolds unexpectedly difficulty "
                    },
                    {
                        "username": "christen",
                        "content": "Hello, every one.\\n\\nI am not sure I quite understand the requirement.\\nThe answer for \"cbacdcbc\", should it be \"abcd\" ?\\n\\nThanks,"
                    },
                    {
                        "username": "Beingash22",
                        "content": "These Stack questions are really hard to figure out. At first, this looked straight away a map question."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Before submitting, make sure to have comprehensive testcases, e.g. \\n```\\n\"czrehqbgodazisnxknjnysgaytklkxybzmjnqjgeinniaewoqkrzmuxtavfcnsolkmcpnvawlowsaqucgnwzdvhnxlnxlpbnuhvcjipelapcuxfuimkxvvlwqbvrsgqpyxhqufjvemxuinxmdgpgwjomgejoxklagnckxyoscptmzweieedmecoubsvwkjiejtfuxuygxkprttvaqhqklyxxssmliwrtfcqbxcuoeprsxqdcffstcygumdiuufhclwwentneukzttlvnnkjqwpugadgnowagjcpfofcihire\"\\n\"azzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\"\\n\"g\"\\n\"zyxwvutsrqponmlkjihgfedcbaabcdefghijklmnopqrstuvwxyz\"\\n```\\nand feel free to check out the growing repo of testcases for the daily challenges: https://github.com/mquintus/l33tcode-testcase-generator/"
                    },
                    {
                        "username": "pcRipper",
                        "content": "i have not seen such a useful thing in a years, thank you so much!!!"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Time Limit Exceeded 289 / 290 testcases passed, come on..."
                    }
                ]
            },
            {
                "id": 2072542,
                "content": [
                    {
                        "username": "Verma_03",
                        "content": "Ram Ram bhai sareya ne"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Aaj hai mere leetcode hard ka 68 waah din aur yeh ques mere te hil na rha hai"
                    },
                    {
                        "username": "chenhaoyu",
                        "content": "I don't quite understand this sentence. \"You must make sure your result is the smallest in lexicographical order among all possible results.\", Can anyone give more examples about this?\\n\\nThanks!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Correction:-`\\n\\nThe answer must be a `subsequence` of string `s`."
                    },
                    {
                        "username": "jovizhu",
                        "content": "Why the return of \"cbacdcbc\" is \"acdb\"? Should be \"adbc\"?\\nCann't understand it.\\n\\nthanks"
                    },
                    {
                        "username": "helowl",
                        "content": "acdb is lexigraphically smallest"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Is this really a medium problem? Why do I find it hard? "
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@sentenzo](/sentenzo) Yeah, even that question is marked Medium somehow. "
                    },
                    {
                        "username": "sentenzo",
                        "content": "[Leetcode Problem Rating](https://zerotrac.github.io/leetcode_problem_rating/) gives it 2184 points \\u2014 which is also quite a lot..."
                    },
                    {
                        "username": "sentenzo",
                        "content": "[1081](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/description/) is identical to this one, and it was the [Q4 of Weekly Contest 140](https://leetcode.com/contest/weekly-contest-140/) \\u2014 so it should be marked as hard indeed."
                    },
                    {
                        "username": "roman-mc",
                        "content": "I\\'m sure it\\'s almost impossible to solve on a real interview, too obscure the problem at first, and it unfolds unexpectedly difficulty "
                    },
                    {
                        "username": "christen",
                        "content": "Hello, every one.\\n\\nI am not sure I quite understand the requirement.\\nThe answer for \"cbacdcbc\", should it be \"abcd\" ?\\n\\nThanks,"
                    },
                    {
                        "username": "Beingash22",
                        "content": "These Stack questions are really hard to figure out. At first, this looked straight away a map question."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Before submitting, make sure to have comprehensive testcases, e.g. \\n```\\n\"czrehqbgodazisnxknjnysgaytklkxybzmjnqjgeinniaewoqkrzmuxtavfcnsolkmcpnvawlowsaqucgnwzdvhnxlnxlpbnuhvcjipelapcuxfuimkxvvlwqbvrsgqpyxhqufjvemxuinxmdgpgwjomgejoxklagnckxyoscptmzweieedmecoubsvwkjiejtfuxuygxkprttvaqhqklyxxssmliwrtfcqbxcuoeprsxqdcffstcygumdiuufhclwwentneukzttlvnnkjqwpugadgnowagjcpfofcihire\"\\n\"azzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\"\\n\"g\"\\n\"zyxwvutsrqponmlkjihgfedcbaabcdefghijklmnopqrstuvwxyz\"\\n```\\nand feel free to check out the growing repo of testcases for the daily challenges: https://github.com/mquintus/l33tcode-testcase-generator/"
                    },
                    {
                        "username": "pcRipper",
                        "content": "i have not seen such a useful thing in a years, thank you so much!!!"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Time Limit Exceeded 289 / 290 testcases passed, come on..."
                    }
                ]
            },
            {
                "id": 1569068,
                "content": [
                    {
                        "username": "Verma_03",
                        "content": "Ram Ram bhai sareya ne"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Aaj hai mere leetcode hard ka 68 waah din aur yeh ques mere te hil na rha hai"
                    },
                    {
                        "username": "chenhaoyu",
                        "content": "I don't quite understand this sentence. \"You must make sure your result is the smallest in lexicographical order among all possible results.\", Can anyone give more examples about this?\\n\\nThanks!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Correction:-`\\n\\nThe answer must be a `subsequence` of string `s`."
                    },
                    {
                        "username": "jovizhu",
                        "content": "Why the return of \"cbacdcbc\" is \"acdb\"? Should be \"adbc\"?\\nCann't understand it.\\n\\nthanks"
                    },
                    {
                        "username": "helowl",
                        "content": "acdb is lexigraphically smallest"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Is this really a medium problem? Why do I find it hard? "
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@sentenzo](/sentenzo) Yeah, even that question is marked Medium somehow. "
                    },
                    {
                        "username": "sentenzo",
                        "content": "[Leetcode Problem Rating](https://zerotrac.github.io/leetcode_problem_rating/) gives it 2184 points \\u2014 which is also quite a lot..."
                    },
                    {
                        "username": "sentenzo",
                        "content": "[1081](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/description/) is identical to this one, and it was the [Q4 of Weekly Contest 140](https://leetcode.com/contest/weekly-contest-140/) \\u2014 so it should be marked as hard indeed."
                    },
                    {
                        "username": "roman-mc",
                        "content": "I\\'m sure it\\'s almost impossible to solve on a real interview, too obscure the problem at first, and it unfolds unexpectedly difficulty "
                    },
                    {
                        "username": "christen",
                        "content": "Hello, every one.\\n\\nI am not sure I quite understand the requirement.\\nThe answer for \"cbacdcbc\", should it be \"abcd\" ?\\n\\nThanks,"
                    },
                    {
                        "username": "Beingash22",
                        "content": "These Stack questions are really hard to figure out. At first, this looked straight away a map question."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Before submitting, make sure to have comprehensive testcases, e.g. \\n```\\n\"czrehqbgodazisnxknjnysgaytklkxybzmjnqjgeinniaewoqkrzmuxtavfcnsolkmcpnvawlowsaqucgnwzdvhnxlnxlpbnuhvcjipelapcuxfuimkxvvlwqbvrsgqpyxhqufjvemxuinxmdgpgwjomgejoxklagnckxyoscptmzweieedmecoubsvwkjiejtfuxuygxkprttvaqhqklyxxssmliwrtfcqbxcuoeprsxqdcffstcygumdiuufhclwwentneukzttlvnnkjqwpugadgnowagjcpfofcihire\"\\n\"azzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\"\\n\"g\"\\n\"zyxwvutsrqponmlkjihgfedcbaabcdefghijklmnopqrstuvwxyz\"\\n```\\nand feel free to check out the growing repo of testcases for the daily challenges: https://github.com/mquintus/l33tcode-testcase-generator/"
                    },
                    {
                        "username": "pcRipper",
                        "content": "i have not seen such a useful thing in a years, thank you so much!!!"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Time Limit Exceeded 289 / 290 testcases passed, come on..."
                    }
                ]
            },
            {
                "id": 2073082,
                "content": [
                    {
                        "username": "Verma_03",
                        "content": "Ram Ram bhai sareya ne"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Aaj hai mere leetcode hard ka 68 waah din aur yeh ques mere te hil na rha hai"
                    },
                    {
                        "username": "chenhaoyu",
                        "content": "I don't quite understand this sentence. \"You must make sure your result is the smallest in lexicographical order among all possible results.\", Can anyone give more examples about this?\\n\\nThanks!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Correction:-`\\n\\nThe answer must be a `subsequence` of string `s`."
                    },
                    {
                        "username": "jovizhu",
                        "content": "Why the return of \"cbacdcbc\" is \"acdb\"? Should be \"adbc\"?\\nCann't understand it.\\n\\nthanks"
                    },
                    {
                        "username": "helowl",
                        "content": "acdb is lexigraphically smallest"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Is this really a medium problem? Why do I find it hard? "
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@sentenzo](/sentenzo) Yeah, even that question is marked Medium somehow. "
                    },
                    {
                        "username": "sentenzo",
                        "content": "[Leetcode Problem Rating](https://zerotrac.github.io/leetcode_problem_rating/) gives it 2184 points \\u2014 which is also quite a lot..."
                    },
                    {
                        "username": "sentenzo",
                        "content": "[1081](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/description/) is identical to this one, and it was the [Q4 of Weekly Contest 140](https://leetcode.com/contest/weekly-contest-140/) \\u2014 so it should be marked as hard indeed."
                    },
                    {
                        "username": "roman-mc",
                        "content": "I\\'m sure it\\'s almost impossible to solve on a real interview, too obscure the problem at first, and it unfolds unexpectedly difficulty "
                    },
                    {
                        "username": "christen",
                        "content": "Hello, every one.\\n\\nI am not sure I quite understand the requirement.\\nThe answer for \"cbacdcbc\", should it be \"abcd\" ?\\n\\nThanks,"
                    },
                    {
                        "username": "Beingash22",
                        "content": "These Stack questions are really hard to figure out. At first, this looked straight away a map question."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Before submitting, make sure to have comprehensive testcases, e.g. \\n```\\n\"czrehqbgodazisnxknjnysgaytklkxybzmjnqjgeinniaewoqkrzmuxtavfcnsolkmcpnvawlowsaqucgnwzdvhnxlnxlpbnuhvcjipelapcuxfuimkxvvlwqbvrsgqpyxhqufjvemxuinxmdgpgwjomgejoxklagnckxyoscptmzweieedmecoubsvwkjiejtfuxuygxkprttvaqhqklyxxssmliwrtfcqbxcuoeprsxqdcffstcygumdiuufhclwwentneukzttlvnnkjqwpugadgnowagjcpfofcihire\"\\n\"azzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\"\\n\"g\"\\n\"zyxwvutsrqponmlkjihgfedcbaabcdefghijklmnopqrstuvwxyz\"\\n```\\nand feel free to check out the growing repo of testcases for the daily challenges: https://github.com/mquintus/l33tcode-testcase-generator/"
                    },
                    {
                        "username": "pcRipper",
                        "content": "i have not seen such a useful thing in a years, thank you so much!!!"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Time Limit Exceeded 289 / 290 testcases passed, come on..."
                    }
                ]
            },
            {
                "id": 2072679,
                "content": [
                    {
                        "username": "Verma_03",
                        "content": "Ram Ram bhai sareya ne"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Aaj hai mere leetcode hard ka 68 waah din aur yeh ques mere te hil na rha hai"
                    },
                    {
                        "username": "chenhaoyu",
                        "content": "I don't quite understand this sentence. \"You must make sure your result is the smallest in lexicographical order among all possible results.\", Can anyone give more examples about this?\\n\\nThanks!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Correction:-`\\n\\nThe answer must be a `subsequence` of string `s`."
                    },
                    {
                        "username": "jovizhu",
                        "content": "Why the return of \"cbacdcbc\" is \"acdb\"? Should be \"adbc\"?\\nCann't understand it.\\n\\nthanks"
                    },
                    {
                        "username": "helowl",
                        "content": "acdb is lexigraphically smallest"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Is this really a medium problem? Why do I find it hard? "
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@sentenzo](/sentenzo) Yeah, even that question is marked Medium somehow. "
                    },
                    {
                        "username": "sentenzo",
                        "content": "[Leetcode Problem Rating](https://zerotrac.github.io/leetcode_problem_rating/) gives it 2184 points \\u2014 which is also quite a lot..."
                    },
                    {
                        "username": "sentenzo",
                        "content": "[1081](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/description/) is identical to this one, and it was the [Q4 of Weekly Contest 140](https://leetcode.com/contest/weekly-contest-140/) \\u2014 so it should be marked as hard indeed."
                    },
                    {
                        "username": "roman-mc",
                        "content": "I\\'m sure it\\'s almost impossible to solve on a real interview, too obscure the problem at first, and it unfolds unexpectedly difficulty "
                    },
                    {
                        "username": "christen",
                        "content": "Hello, every one.\\n\\nI am not sure I quite understand the requirement.\\nThe answer for \"cbacdcbc\", should it be \"abcd\" ?\\n\\nThanks,"
                    },
                    {
                        "username": "Beingash22",
                        "content": "These Stack questions are really hard to figure out. At first, this looked straight away a map question."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Before submitting, make sure to have comprehensive testcases, e.g. \\n```\\n\"czrehqbgodazisnxknjnysgaytklkxybzmjnqjgeinniaewoqkrzmuxtavfcnsolkmcpnvawlowsaqucgnwzdvhnxlnxlpbnuhvcjipelapcuxfuimkxvvlwqbvrsgqpyxhqufjvemxuinxmdgpgwjomgejoxklagnckxyoscptmzweieedmecoubsvwkjiejtfuxuygxkprttvaqhqklyxxssmliwrtfcqbxcuoeprsxqdcffstcygumdiuufhclwwentneukzttlvnnkjqwpugadgnowagjcpfofcihire\"\\n\"azzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\"\\n\"g\"\\n\"zyxwvutsrqponmlkjihgfedcbaabcdefghijklmnopqrstuvwxyz\"\\n```\\nand feel free to check out the growing repo of testcases for the daily challenges: https://github.com/mquintus/l33tcode-testcase-generator/"
                    },
                    {
                        "username": "pcRipper",
                        "content": "i have not seen such a useful thing in a years, thank you so much!!!"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Time Limit Exceeded 289 / 290 testcases passed, come on..."
                    }
                ]
            },
            {
                "id": 2073074,
                "content": [
                    {
                        "username": "Verma_03",
                        "content": "Ram Ram bhai sareya ne"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "Aaj hai mere leetcode hard ka 68 waah din aur yeh ques mere te hil na rha hai"
                    },
                    {
                        "username": "chenhaoyu",
                        "content": "I don't quite understand this sentence. \"You must make sure your result is the smallest in lexicographical order among all possible results.\", Can anyone give more examples about this?\\n\\nThanks!"
                    },
                    {
                        "username": "syedmarwan",
                        "content": "It should follow the subsequence and be in the smallest lexicographical order, like the string cbacdcbc\\nc is occurring multiple times, so we the c which will occur in the smallest lexicographical set and a occurs only occurs once , so we have to use that single a.\\nHope this helps."
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Correction:-`\\n\\nThe answer must be a `subsequence` of string `s`."
                    },
                    {
                        "username": "jovizhu",
                        "content": "Why the return of \"cbacdcbc\" is \"acdb\"? Should be \"adbc\"?\\nCann't understand it.\\n\\nthanks"
                    },
                    {
                        "username": "helowl",
                        "content": "acdb is lexigraphically smallest"
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "Is this really a medium problem? Why do I find it hard? "
                    },
                    {
                        "username": "AasrishVinay",
                        "content": "[@sentenzo](/sentenzo) Yeah, even that question is marked Medium somehow. "
                    },
                    {
                        "username": "sentenzo",
                        "content": "[Leetcode Problem Rating](https://zerotrac.github.io/leetcode_problem_rating/) gives it 2184 points \\u2014 which is also quite a lot..."
                    },
                    {
                        "username": "sentenzo",
                        "content": "[1081](https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/description/) is identical to this one, and it was the [Q4 of Weekly Contest 140](https://leetcode.com/contest/weekly-contest-140/) \\u2014 so it should be marked as hard indeed."
                    },
                    {
                        "username": "roman-mc",
                        "content": "I\\'m sure it\\'s almost impossible to solve on a real interview, too obscure the problem at first, and it unfolds unexpectedly difficulty "
                    },
                    {
                        "username": "christen",
                        "content": "Hello, every one.\\n\\nI am not sure I quite understand the requirement.\\nThe answer for \"cbacdcbc\", should it be \"abcd\" ?\\n\\nThanks,"
                    },
                    {
                        "username": "Beingash22",
                        "content": "These Stack questions are really hard to figure out. At first, this looked straight away a map question."
                    },
                    {
                        "username": "mstuebs",
                        "content": "Before submitting, make sure to have comprehensive testcases, e.g. \\n```\\n\"czrehqbgodazisnxknjnysgaytklkxybzmjnqjgeinniaewoqkrzmuxtavfcnsolkmcpnvawlowsaqucgnwzdvhnxlnxlpbnuhvcjipelapcuxfuimkxvvlwqbvrsgqpyxhqufjvemxuinxmdgpgwjomgejoxklagnckxyoscptmzweieedmecoubsvwkjiejtfuxuygxkprttvaqhqklyxxssmliwrtfcqbxcuoeprsxqdcffstcygumdiuufhclwwentneukzttlvnnkjqwpugadgnowagjcpfofcihire\"\\n\"azzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq\"\\n\"g\"\\n\"zyxwvutsrqponmlkjihgfedcbaabcdefghijklmnopqrstuvwxyz\"\\n```\\nand feel free to check out the growing repo of testcases for the daily challenges: https://github.com/mquintus/l33tcode-testcase-generator/"
                    },
                    {
                        "username": "pcRipper",
                        "content": "i have not seen such a useful thing in a years, thank you so much!!!"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Time Limit Exceeded 289 / 290 testcases passed, come on..."
                    }
                ]
            },
            {
                "id": 2066109,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for an incorrect difficulty."
                    },
                    {
                        "username": "jimlinntu",
                        "content": "I suggest you **first** (VERY IMPORTANT, because this is way easier than the stack solution) understand: [A short O(n) recursive greedy solution](https://leetcode.com/problems/remove-duplicate-letters/discuss/76768/A-short-O(n)-recursive-greedy-solution)\\n\\nAnd then take a glimpse of the concept of: [Java O(n) solution using stack with detail explanation](https://leetcode.com/problems/remove-duplicate-letters/discuss/76762/Java-O(n)-solution-using-stack-with-detail-explanation)\\n\\nAnd then come back to see my clear explanation.\\nIn short, what I want to prove in the illustrations is that: the behavior of the recursive solution is as same as the stack solution!\\n\\n![image](https://assets.leetcode.com/users/images/1855659c-43ff-495c-8f0c-a7e79107c45c_1619789802.198157.png)\\n![image](https://assets.leetcode.com/users/images/8de71960-d817-441e-b65a-b6abc4983a81_1619789807.5926883.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "grasssu",
                        "content": "For the case \"aabcb\" my run code returns \"abc\" but when I submit the code the judge said my result is \"ab\". I printed the result again in run code and it is indeed \"abc\". Why is this happening?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicate-letters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Greedy - Solving Letter by Letter\n\n  \n**Approach 2:** Greedy - Solving with Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "menBilmayman",
                        "content": "In Example 2 the answer should be \"acdb\" as shown below: ![image](https://assets.leetcode.com/users/images/57a98c14-1bff-496c-9c32-0e97c33141aa_1641739861.4432662.png)\\nSo, \"acdb\" is lexicographically smallest string. \\n\\nBut we can construct \"abcd\" also. Why answer is \"acdb\"? Why \"acdb\" is lexicographically smaller than \"abcd\"?"
                    },
                    {
                        "username": "ealejandria",
                        "content": "While \"abcd\" is a lexicographically smaller string, it is not one of our possible results. The only operation we can perform on the original string is deleting characters, we cannot reorganize them."
                    },
                    {
                        "username": "KedarKK1",
                        "content": "When you start to do dsa & cp by yourself for decent amount of time, you realize that most of permutations & sequence, subsequence questions may use bfs or bit manipulation or both (sometimes dfs as well). Hurray! you've started to understand question & their pattern. Keep it up!"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Not as easy as I thought!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A good piece of advice: DO NOT TRY TO IMPLEMENT BIT MASKS, it is pretty tricky even after you've figured out a working solution. "
                    },
                    {
                        "username": "luanct",
                        "content": "lol, I return abcd instead of acdb\\uD83D\\uDE01"
                    },
                    {
                        "username": "123Anon123",
                        "content": "Can someone please explain why the stack solution is O(N). At each iteration, we can do ***i*** work due to the nested while loop and there are N iterations. So \\u2211i, i in [0,N) = O(N^2), right?"
                    },
                    {
                        "username": "captainspongebob1",
                        "content": "Any monotonic stack solution is O(n) because each element within the stack can only be removed once. In other words, every element can only be pushed and popped once from the stack, which makes it O(n) (despite it seeming like O(n^2) due to the nested loops)."
                    },
                    {
                        "username": "aitachii",
                        "content": "The maximum possible size of the stack is $O(26)$ since there are only `26` unique lowercase English letters in total. So the nested while loop will only reach at most `26` loops in the worst case. Something like `bcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz` will make the while loop do `25` loops.\n\nBasically: \nOuter Loop: $O(N)$\nInner Loop: $O(26)$ (worst case)\n\nTotal time complexity: $O(N*26)$ = $O(N)$"
                    }
                ]
            },
            {
                "id": 1575203,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for an incorrect difficulty."
                    },
                    {
                        "username": "jimlinntu",
                        "content": "I suggest you **first** (VERY IMPORTANT, because this is way easier than the stack solution) understand: [A short O(n) recursive greedy solution](https://leetcode.com/problems/remove-duplicate-letters/discuss/76768/A-short-O(n)-recursive-greedy-solution)\\n\\nAnd then take a glimpse of the concept of: [Java O(n) solution using stack with detail explanation](https://leetcode.com/problems/remove-duplicate-letters/discuss/76762/Java-O(n)-solution-using-stack-with-detail-explanation)\\n\\nAnd then come back to see my clear explanation.\\nIn short, what I want to prove in the illustrations is that: the behavior of the recursive solution is as same as the stack solution!\\n\\n![image](https://assets.leetcode.com/users/images/1855659c-43ff-495c-8f0c-a7e79107c45c_1619789802.198157.png)\\n![image](https://assets.leetcode.com/users/images/8de71960-d817-441e-b65a-b6abc4983a81_1619789807.5926883.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "grasssu",
                        "content": "For the case \"aabcb\" my run code returns \"abc\" but when I submit the code the judge said my result is \"ab\". I printed the result again in run code and it is indeed \"abc\". Why is this happening?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicate-letters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Greedy - Solving Letter by Letter\n\n  \n**Approach 2:** Greedy - Solving with Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "menBilmayman",
                        "content": "In Example 2 the answer should be \"acdb\" as shown below: ![image](https://assets.leetcode.com/users/images/57a98c14-1bff-496c-9c32-0e97c33141aa_1641739861.4432662.png)\\nSo, \"acdb\" is lexicographically smallest string. \\n\\nBut we can construct \"abcd\" also. Why answer is \"acdb\"? Why \"acdb\" is lexicographically smaller than \"abcd\"?"
                    },
                    {
                        "username": "ealejandria",
                        "content": "While \"abcd\" is a lexicographically smaller string, it is not one of our possible results. The only operation we can perform on the original string is deleting characters, we cannot reorganize them."
                    },
                    {
                        "username": "KedarKK1",
                        "content": "When you start to do dsa & cp by yourself for decent amount of time, you realize that most of permutations & sequence, subsequence questions may use bfs or bit manipulation or both (sometimes dfs as well). Hurray! you've started to understand question & their pattern. Keep it up!"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Not as easy as I thought!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A good piece of advice: DO NOT TRY TO IMPLEMENT BIT MASKS, it is pretty tricky even after you've figured out a working solution. "
                    },
                    {
                        "username": "luanct",
                        "content": "lol, I return abcd instead of acdb\\uD83D\\uDE01"
                    },
                    {
                        "username": "123Anon123",
                        "content": "Can someone please explain why the stack solution is O(N). At each iteration, we can do ***i*** work due to the nested while loop and there are N iterations. So \\u2211i, i in [0,N) = O(N^2), right?"
                    },
                    {
                        "username": "captainspongebob1",
                        "content": "Any monotonic stack solution is O(n) because each element within the stack can only be removed once. In other words, every element can only be pushed and popped once from the stack, which makes it O(n) (despite it seeming like O(n^2) due to the nested loops)."
                    },
                    {
                        "username": "aitachii",
                        "content": "The maximum possible size of the stack is $O(26)$ since there are only `26` unique lowercase English letters in total. So the nested while loop will only reach at most `26` loops in the worst case. Something like `bcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz` will make the while loop do `25` loops.\n\nBasically: \nOuter Loop: $O(N)$\nInner Loop: $O(26)$ (worst case)\n\nTotal time complexity: $O(N*26)$ = $O(N)$"
                    }
                ]
            },
            {
                "id": 1569066,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for an incorrect difficulty."
                    },
                    {
                        "username": "jimlinntu",
                        "content": "I suggest you **first** (VERY IMPORTANT, because this is way easier than the stack solution) understand: [A short O(n) recursive greedy solution](https://leetcode.com/problems/remove-duplicate-letters/discuss/76768/A-short-O(n)-recursive-greedy-solution)\\n\\nAnd then take a glimpse of the concept of: [Java O(n) solution using stack with detail explanation](https://leetcode.com/problems/remove-duplicate-letters/discuss/76762/Java-O(n)-solution-using-stack-with-detail-explanation)\\n\\nAnd then come back to see my clear explanation.\\nIn short, what I want to prove in the illustrations is that: the behavior of the recursive solution is as same as the stack solution!\\n\\n![image](https://assets.leetcode.com/users/images/1855659c-43ff-495c-8f0c-a7e79107c45c_1619789802.198157.png)\\n![image](https://assets.leetcode.com/users/images/8de71960-d817-441e-b65a-b6abc4983a81_1619789807.5926883.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "grasssu",
                        "content": "For the case \"aabcb\" my run code returns \"abc\" but when I submit the code the judge said my result is \"ab\". I printed the result again in run code and it is indeed \"abc\". Why is this happening?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicate-letters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Greedy - Solving Letter by Letter\n\n  \n**Approach 2:** Greedy - Solving with Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "menBilmayman",
                        "content": "In Example 2 the answer should be \"acdb\" as shown below: ![image](https://assets.leetcode.com/users/images/57a98c14-1bff-496c-9c32-0e97c33141aa_1641739861.4432662.png)\\nSo, \"acdb\" is lexicographically smallest string. \\n\\nBut we can construct \"abcd\" also. Why answer is \"acdb\"? Why \"acdb\" is lexicographically smaller than \"abcd\"?"
                    },
                    {
                        "username": "ealejandria",
                        "content": "While \"abcd\" is a lexicographically smaller string, it is not one of our possible results. The only operation we can perform on the original string is deleting characters, we cannot reorganize them."
                    },
                    {
                        "username": "KedarKK1",
                        "content": "When you start to do dsa & cp by yourself for decent amount of time, you realize that most of permutations & sequence, subsequence questions may use bfs or bit manipulation or both (sometimes dfs as well). Hurray! you've started to understand question & their pattern. Keep it up!"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Not as easy as I thought!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A good piece of advice: DO NOT TRY TO IMPLEMENT BIT MASKS, it is pretty tricky even after you've figured out a working solution. "
                    },
                    {
                        "username": "luanct",
                        "content": "lol, I return abcd instead of acdb\\uD83D\\uDE01"
                    },
                    {
                        "username": "123Anon123",
                        "content": "Can someone please explain why the stack solution is O(N). At each iteration, we can do ***i*** work due to the nested while loop and there are N iterations. So \\u2211i, i in [0,N) = O(N^2), right?"
                    },
                    {
                        "username": "captainspongebob1",
                        "content": "Any monotonic stack solution is O(n) because each element within the stack can only be removed once. In other words, every element can only be pushed and popped once from the stack, which makes it O(n) (despite it seeming like O(n^2) due to the nested loops)."
                    },
                    {
                        "username": "aitachii",
                        "content": "The maximum possible size of the stack is $O(26)$ since there are only `26` unique lowercase English letters in total. So the nested while loop will only reach at most `26` loops in the worst case. Something like `bcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz` will make the while loop do `25` loops.\n\nBasically: \nOuter Loop: $O(N)$\nInner Loop: $O(26)$ (worst case)\n\nTotal time complexity: $O(N*26)$ = $O(N)$"
                    }
                ]
            },
            {
                "id": 1567740,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for an incorrect difficulty."
                    },
                    {
                        "username": "jimlinntu",
                        "content": "I suggest you **first** (VERY IMPORTANT, because this is way easier than the stack solution) understand: [A short O(n) recursive greedy solution](https://leetcode.com/problems/remove-duplicate-letters/discuss/76768/A-short-O(n)-recursive-greedy-solution)\\n\\nAnd then take a glimpse of the concept of: [Java O(n) solution using stack with detail explanation](https://leetcode.com/problems/remove-duplicate-letters/discuss/76762/Java-O(n)-solution-using-stack-with-detail-explanation)\\n\\nAnd then come back to see my clear explanation.\\nIn short, what I want to prove in the illustrations is that: the behavior of the recursive solution is as same as the stack solution!\\n\\n![image](https://assets.leetcode.com/users/images/1855659c-43ff-495c-8f0c-a7e79107c45c_1619789802.198157.png)\\n![image](https://assets.leetcode.com/users/images/8de71960-d817-441e-b65a-b6abc4983a81_1619789807.5926883.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "grasssu",
                        "content": "For the case \"aabcb\" my run code returns \"abc\" but when I submit the code the judge said my result is \"ab\". I printed the result again in run code and it is indeed \"abc\". Why is this happening?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicate-letters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Greedy - Solving Letter by Letter\n\n  \n**Approach 2:** Greedy - Solving with Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "menBilmayman",
                        "content": "In Example 2 the answer should be \"acdb\" as shown below: ![image](https://assets.leetcode.com/users/images/57a98c14-1bff-496c-9c32-0e97c33141aa_1641739861.4432662.png)\\nSo, \"acdb\" is lexicographically smallest string. \\n\\nBut we can construct \"abcd\" also. Why answer is \"acdb\"? Why \"acdb\" is lexicographically smaller than \"abcd\"?"
                    },
                    {
                        "username": "ealejandria",
                        "content": "While \"abcd\" is a lexicographically smaller string, it is not one of our possible results. The only operation we can perform on the original string is deleting characters, we cannot reorganize them."
                    },
                    {
                        "username": "KedarKK1",
                        "content": "When you start to do dsa & cp by yourself for decent amount of time, you realize that most of permutations & sequence, subsequence questions may use bfs or bit manipulation or both (sometimes dfs as well). Hurray! you've started to understand question & their pattern. Keep it up!"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Not as easy as I thought!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A good piece of advice: DO NOT TRY TO IMPLEMENT BIT MASKS, it is pretty tricky even after you've figured out a working solution. "
                    },
                    {
                        "username": "luanct",
                        "content": "lol, I return abcd instead of acdb\\uD83D\\uDE01"
                    },
                    {
                        "username": "123Anon123",
                        "content": "Can someone please explain why the stack solution is O(N). At each iteration, we can do ***i*** work due to the nested while loop and there are N iterations. So \\u2211i, i in [0,N) = O(N^2), right?"
                    },
                    {
                        "username": "captainspongebob1",
                        "content": "Any monotonic stack solution is O(n) because each element within the stack can only be removed once. In other words, every element can only be pushed and popped once from the stack, which makes it O(n) (despite it seeming like O(n^2) due to the nested loops)."
                    },
                    {
                        "username": "aitachii",
                        "content": "The maximum possible size of the stack is $O(26)$ since there are only `26` unique lowercase English letters in total. So the nested while loop will only reach at most `26` loops in the worst case. Something like `bcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz` will make the while loop do `25` loops.\n\nBasically: \nOuter Loop: $O(N)$\nInner Loop: $O(26)$ (worst case)\n\nTotal time complexity: $O(N*26)$ = $O(N)$"
                    }
                ]
            },
            {
                "id": 1568706,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for an incorrect difficulty."
                    },
                    {
                        "username": "jimlinntu",
                        "content": "I suggest you **first** (VERY IMPORTANT, because this is way easier than the stack solution) understand: [A short O(n) recursive greedy solution](https://leetcode.com/problems/remove-duplicate-letters/discuss/76768/A-short-O(n)-recursive-greedy-solution)\\n\\nAnd then take a glimpse of the concept of: [Java O(n) solution using stack with detail explanation](https://leetcode.com/problems/remove-duplicate-letters/discuss/76762/Java-O(n)-solution-using-stack-with-detail-explanation)\\n\\nAnd then come back to see my clear explanation.\\nIn short, what I want to prove in the illustrations is that: the behavior of the recursive solution is as same as the stack solution!\\n\\n![image](https://assets.leetcode.com/users/images/1855659c-43ff-495c-8f0c-a7e79107c45c_1619789802.198157.png)\\n![image](https://assets.leetcode.com/users/images/8de71960-d817-441e-b65a-b6abc4983a81_1619789807.5926883.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "grasssu",
                        "content": "For the case \"aabcb\" my run code returns \"abc\" but when I submit the code the judge said my result is \"ab\". I printed the result again in run code and it is indeed \"abc\". Why is this happening?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicate-letters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Greedy - Solving Letter by Letter\n\n  \n**Approach 2:** Greedy - Solving with Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "menBilmayman",
                        "content": "In Example 2 the answer should be \"acdb\" as shown below: ![image](https://assets.leetcode.com/users/images/57a98c14-1bff-496c-9c32-0e97c33141aa_1641739861.4432662.png)\\nSo, \"acdb\" is lexicographically smallest string. \\n\\nBut we can construct \"abcd\" also. Why answer is \"acdb\"? Why \"acdb\" is lexicographically smaller than \"abcd\"?"
                    },
                    {
                        "username": "ealejandria",
                        "content": "While \"abcd\" is a lexicographically smaller string, it is not one of our possible results. The only operation we can perform on the original string is deleting characters, we cannot reorganize them."
                    },
                    {
                        "username": "KedarKK1",
                        "content": "When you start to do dsa & cp by yourself for decent amount of time, you realize that most of permutations & sequence, subsequence questions may use bfs or bit manipulation or both (sometimes dfs as well). Hurray! you've started to understand question & their pattern. Keep it up!"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Not as easy as I thought!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A good piece of advice: DO NOT TRY TO IMPLEMENT BIT MASKS, it is pretty tricky even after you've figured out a working solution. "
                    },
                    {
                        "username": "luanct",
                        "content": "lol, I return abcd instead of acdb\\uD83D\\uDE01"
                    },
                    {
                        "username": "123Anon123",
                        "content": "Can someone please explain why the stack solution is O(N). At each iteration, we can do ***i*** work due to the nested while loop and there are N iterations. So \\u2211i, i in [0,N) = O(N^2), right?"
                    },
                    {
                        "username": "captainspongebob1",
                        "content": "Any monotonic stack solution is O(n) because each element within the stack can only be removed once. In other words, every element can only be pushed and popped once from the stack, which makes it O(n) (despite it seeming like O(n^2) due to the nested loops)."
                    },
                    {
                        "username": "aitachii",
                        "content": "The maximum possible size of the stack is $O(26)$ since there are only `26` unique lowercase English letters in total. So the nested while loop will only reach at most `26` loops in the worst case. Something like `bcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz` will make the while loop do `25` loops.\n\nBasically: \nOuter Loop: $O(N)$\nInner Loop: $O(26)$ (worst case)\n\nTotal time complexity: $O(N*26)$ = $O(N)$"
                    }
                ]
            },
            {
                "id": 2072817,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for an incorrect difficulty."
                    },
                    {
                        "username": "jimlinntu",
                        "content": "I suggest you **first** (VERY IMPORTANT, because this is way easier than the stack solution) understand: [A short O(n) recursive greedy solution](https://leetcode.com/problems/remove-duplicate-letters/discuss/76768/A-short-O(n)-recursive-greedy-solution)\\n\\nAnd then take a glimpse of the concept of: [Java O(n) solution using stack with detail explanation](https://leetcode.com/problems/remove-duplicate-letters/discuss/76762/Java-O(n)-solution-using-stack-with-detail-explanation)\\n\\nAnd then come back to see my clear explanation.\\nIn short, what I want to prove in the illustrations is that: the behavior of the recursive solution is as same as the stack solution!\\n\\n![image](https://assets.leetcode.com/users/images/1855659c-43ff-495c-8f0c-a7e79107c45c_1619789802.198157.png)\\n![image](https://assets.leetcode.com/users/images/8de71960-d817-441e-b65a-b6abc4983a81_1619789807.5926883.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "grasssu",
                        "content": "For the case \"aabcb\" my run code returns \"abc\" but when I submit the code the judge said my result is \"ab\". I printed the result again in run code and it is indeed \"abc\". Why is this happening?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicate-letters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Greedy - Solving Letter by Letter\n\n  \n**Approach 2:** Greedy - Solving with Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "menBilmayman",
                        "content": "In Example 2 the answer should be \"acdb\" as shown below: ![image](https://assets.leetcode.com/users/images/57a98c14-1bff-496c-9c32-0e97c33141aa_1641739861.4432662.png)\\nSo, \"acdb\" is lexicographically smallest string. \\n\\nBut we can construct \"abcd\" also. Why answer is \"acdb\"? Why \"acdb\" is lexicographically smaller than \"abcd\"?"
                    },
                    {
                        "username": "ealejandria",
                        "content": "While \"abcd\" is a lexicographically smaller string, it is not one of our possible results. The only operation we can perform on the original string is deleting characters, we cannot reorganize them."
                    },
                    {
                        "username": "KedarKK1",
                        "content": "When you start to do dsa & cp by yourself for decent amount of time, you realize that most of permutations & sequence, subsequence questions may use bfs or bit manipulation or both (sometimes dfs as well). Hurray! you've started to understand question & their pattern. Keep it up!"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Not as easy as I thought!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A good piece of advice: DO NOT TRY TO IMPLEMENT BIT MASKS, it is pretty tricky even after you've figured out a working solution. "
                    },
                    {
                        "username": "luanct",
                        "content": "lol, I return abcd instead of acdb\\uD83D\\uDE01"
                    },
                    {
                        "username": "123Anon123",
                        "content": "Can someone please explain why the stack solution is O(N). At each iteration, we can do ***i*** work due to the nested while loop and there are N iterations. So \\u2211i, i in [0,N) = O(N^2), right?"
                    },
                    {
                        "username": "captainspongebob1",
                        "content": "Any monotonic stack solution is O(n) because each element within the stack can only be removed once. In other words, every element can only be pushed and popped once from the stack, which makes it O(n) (despite it seeming like O(n^2) due to the nested loops)."
                    },
                    {
                        "username": "aitachii",
                        "content": "The maximum possible size of the stack is $O(26)$ since there are only `26` unique lowercase English letters in total. So the nested while loop will only reach at most `26` loops in the worst case. Something like `bcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz` will make the while loop do `25` loops.\n\nBasically: \nOuter Loop: $O(N)$\nInner Loop: $O(26)$ (worst case)\n\nTotal time complexity: $O(N*26)$ = $O(N)$"
                    }
                ]
            },
            {
                "id": 2072607,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for an incorrect difficulty."
                    },
                    {
                        "username": "jimlinntu",
                        "content": "I suggest you **first** (VERY IMPORTANT, because this is way easier than the stack solution) understand: [A short O(n) recursive greedy solution](https://leetcode.com/problems/remove-duplicate-letters/discuss/76768/A-short-O(n)-recursive-greedy-solution)\\n\\nAnd then take a glimpse of the concept of: [Java O(n) solution using stack with detail explanation](https://leetcode.com/problems/remove-duplicate-letters/discuss/76762/Java-O(n)-solution-using-stack-with-detail-explanation)\\n\\nAnd then come back to see my clear explanation.\\nIn short, what I want to prove in the illustrations is that: the behavior of the recursive solution is as same as the stack solution!\\n\\n![image](https://assets.leetcode.com/users/images/1855659c-43ff-495c-8f0c-a7e79107c45c_1619789802.198157.png)\\n![image](https://assets.leetcode.com/users/images/8de71960-d817-441e-b65a-b6abc4983a81_1619789807.5926883.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "grasssu",
                        "content": "For the case \"aabcb\" my run code returns \"abc\" but when I submit the code the judge said my result is \"ab\". I printed the result again in run code and it is indeed \"abc\". Why is this happening?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicate-letters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Greedy - Solving Letter by Letter\n\n  \n**Approach 2:** Greedy - Solving with Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "menBilmayman",
                        "content": "In Example 2 the answer should be \"acdb\" as shown below: ![image](https://assets.leetcode.com/users/images/57a98c14-1bff-496c-9c32-0e97c33141aa_1641739861.4432662.png)\\nSo, \"acdb\" is lexicographically smallest string. \\n\\nBut we can construct \"abcd\" also. Why answer is \"acdb\"? Why \"acdb\" is lexicographically smaller than \"abcd\"?"
                    },
                    {
                        "username": "ealejandria",
                        "content": "While \"abcd\" is a lexicographically smaller string, it is not one of our possible results. The only operation we can perform on the original string is deleting characters, we cannot reorganize them."
                    },
                    {
                        "username": "KedarKK1",
                        "content": "When you start to do dsa & cp by yourself for decent amount of time, you realize that most of permutations & sequence, subsequence questions may use bfs or bit manipulation or both (sometimes dfs as well). Hurray! you've started to understand question & their pattern. Keep it up!"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Not as easy as I thought!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A good piece of advice: DO NOT TRY TO IMPLEMENT BIT MASKS, it is pretty tricky even after you've figured out a working solution. "
                    },
                    {
                        "username": "luanct",
                        "content": "lol, I return abcd instead of acdb\\uD83D\\uDE01"
                    },
                    {
                        "username": "123Anon123",
                        "content": "Can someone please explain why the stack solution is O(N). At each iteration, we can do ***i*** work due to the nested while loop and there are N iterations. So \\u2211i, i in [0,N) = O(N^2), right?"
                    },
                    {
                        "username": "captainspongebob1",
                        "content": "Any monotonic stack solution is O(n) because each element within the stack can only be removed once. In other words, every element can only be pushed and popped once from the stack, which makes it O(n) (despite it seeming like O(n^2) due to the nested loops)."
                    },
                    {
                        "username": "aitachii",
                        "content": "The maximum possible size of the stack is $O(26)$ since there are only `26` unique lowercase English letters in total. So the nested while loop will only reach at most `26` loops in the worst case. Something like `bcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz` will make the while loop do `25` loops.\n\nBasically: \nOuter Loop: $O(N)$\nInner Loop: $O(26)$ (worst case)\n\nTotal time complexity: $O(N*26)$ = $O(N)$"
                    }
                ]
            },
            {
                "id": 2066226,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for an incorrect difficulty."
                    },
                    {
                        "username": "jimlinntu",
                        "content": "I suggest you **first** (VERY IMPORTANT, because this is way easier than the stack solution) understand: [A short O(n) recursive greedy solution](https://leetcode.com/problems/remove-duplicate-letters/discuss/76768/A-short-O(n)-recursive-greedy-solution)\\n\\nAnd then take a glimpse of the concept of: [Java O(n) solution using stack with detail explanation](https://leetcode.com/problems/remove-duplicate-letters/discuss/76762/Java-O(n)-solution-using-stack-with-detail-explanation)\\n\\nAnd then come back to see my clear explanation.\\nIn short, what I want to prove in the illustrations is that: the behavior of the recursive solution is as same as the stack solution!\\n\\n![image](https://assets.leetcode.com/users/images/1855659c-43ff-495c-8f0c-a7e79107c45c_1619789802.198157.png)\\n![image](https://assets.leetcode.com/users/images/8de71960-d817-441e-b65a-b6abc4983a81_1619789807.5926883.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "grasssu",
                        "content": "For the case \"aabcb\" my run code returns \"abc\" but when I submit the code the judge said my result is \"ab\". I printed the result again in run code and it is indeed \"abc\". Why is this happening?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicate-letters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Greedy - Solving Letter by Letter\n\n  \n**Approach 2:** Greedy - Solving with Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "menBilmayman",
                        "content": "In Example 2 the answer should be \"acdb\" as shown below: ![image](https://assets.leetcode.com/users/images/57a98c14-1bff-496c-9c32-0e97c33141aa_1641739861.4432662.png)\\nSo, \"acdb\" is lexicographically smallest string. \\n\\nBut we can construct \"abcd\" also. Why answer is \"acdb\"? Why \"acdb\" is lexicographically smaller than \"abcd\"?"
                    },
                    {
                        "username": "ealejandria",
                        "content": "While \"abcd\" is a lexicographically smaller string, it is not one of our possible results. The only operation we can perform on the original string is deleting characters, we cannot reorganize them."
                    },
                    {
                        "username": "KedarKK1",
                        "content": "When you start to do dsa & cp by yourself for decent amount of time, you realize that most of permutations & sequence, subsequence questions may use bfs or bit manipulation or both (sometimes dfs as well). Hurray! you've started to understand question & their pattern. Keep it up!"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Not as easy as I thought!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A good piece of advice: DO NOT TRY TO IMPLEMENT BIT MASKS, it is pretty tricky even after you've figured out a working solution. "
                    },
                    {
                        "username": "luanct",
                        "content": "lol, I return abcd instead of acdb\\uD83D\\uDE01"
                    },
                    {
                        "username": "123Anon123",
                        "content": "Can someone please explain why the stack solution is O(N). At each iteration, we can do ***i*** work due to the nested while loop and there are N iterations. So \\u2211i, i in [0,N) = O(N^2), right?"
                    },
                    {
                        "username": "captainspongebob1",
                        "content": "Any monotonic stack solution is O(n) because each element within the stack can only be removed once. In other words, every element can only be pushed and popped once from the stack, which makes it O(n) (despite it seeming like O(n^2) due to the nested loops)."
                    },
                    {
                        "username": "aitachii",
                        "content": "The maximum possible size of the stack is $O(26)$ since there are only `26` unique lowercase English letters in total. So the nested while loop will only reach at most `26` loops in the worst case. Something like `bcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz` will make the while loop do `25` loops.\n\nBasically: \nOuter Loop: $O(N)$\nInner Loop: $O(26)$ (worst case)\n\nTotal time complexity: $O(N*26)$ = $O(N)$"
                    }
                ]
            },
            {
                "id": 1807838,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for an incorrect difficulty."
                    },
                    {
                        "username": "jimlinntu",
                        "content": "I suggest you **first** (VERY IMPORTANT, because this is way easier than the stack solution) understand: [A short O(n) recursive greedy solution](https://leetcode.com/problems/remove-duplicate-letters/discuss/76768/A-short-O(n)-recursive-greedy-solution)\\n\\nAnd then take a glimpse of the concept of: [Java O(n) solution using stack with detail explanation](https://leetcode.com/problems/remove-duplicate-letters/discuss/76762/Java-O(n)-solution-using-stack-with-detail-explanation)\\n\\nAnd then come back to see my clear explanation.\\nIn short, what I want to prove in the illustrations is that: the behavior of the recursive solution is as same as the stack solution!\\n\\n![image](https://assets.leetcode.com/users/images/1855659c-43ff-495c-8f0c-a7e79107c45c_1619789802.198157.png)\\n![image](https://assets.leetcode.com/users/images/8de71960-d817-441e-b65a-b6abc4983a81_1619789807.5926883.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "grasssu",
                        "content": "For the case \"aabcb\" my run code returns \"abc\" but when I submit the code the judge said my result is \"ab\". I printed the result again in run code and it is indeed \"abc\". Why is this happening?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicate-letters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Greedy - Solving Letter by Letter\n\n  \n**Approach 2:** Greedy - Solving with Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "menBilmayman",
                        "content": "In Example 2 the answer should be \"acdb\" as shown below: ![image](https://assets.leetcode.com/users/images/57a98c14-1bff-496c-9c32-0e97c33141aa_1641739861.4432662.png)\\nSo, \"acdb\" is lexicographically smallest string. \\n\\nBut we can construct \"abcd\" also. Why answer is \"acdb\"? Why \"acdb\" is lexicographically smaller than \"abcd\"?"
                    },
                    {
                        "username": "ealejandria",
                        "content": "While \"abcd\" is a lexicographically smaller string, it is not one of our possible results. The only operation we can perform on the original string is deleting characters, we cannot reorganize them."
                    },
                    {
                        "username": "KedarKK1",
                        "content": "When you start to do dsa & cp by yourself for decent amount of time, you realize that most of permutations & sequence, subsequence questions may use bfs or bit manipulation or both (sometimes dfs as well). Hurray! you've started to understand question & their pattern. Keep it up!"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Not as easy as I thought!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A good piece of advice: DO NOT TRY TO IMPLEMENT BIT MASKS, it is pretty tricky even after you've figured out a working solution. "
                    },
                    {
                        "username": "luanct",
                        "content": "lol, I return abcd instead of acdb\\uD83D\\uDE01"
                    },
                    {
                        "username": "123Anon123",
                        "content": "Can someone please explain why the stack solution is O(N). At each iteration, we can do ***i*** work due to the nested while loop and there are N iterations. So \\u2211i, i in [0,N) = O(N^2), right?"
                    },
                    {
                        "username": "captainspongebob1",
                        "content": "Any monotonic stack solution is O(n) because each element within the stack can only be removed once. In other words, every element can only be pushed and popped once from the stack, which makes it O(n) (despite it seeming like O(n^2) due to the nested loops)."
                    },
                    {
                        "username": "aitachii",
                        "content": "The maximum possible size of the stack is $O(26)$ since there are only `26` unique lowercase English letters in total. So the nested while loop will only reach at most `26` loops in the worst case. Something like `bcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz` will make the while loop do `25` loops.\n\nBasically: \nOuter Loop: $O(N)$\nInner Loop: $O(26)$ (worst case)\n\nTotal time complexity: $O(N*26)$ = $O(N)$"
                    }
                ]
            },
            {
                "id": 1574474,
                "content": [
                    {
                        "username": "dsapelnikov",
                        "content": "A downvote for an incorrect difficulty."
                    },
                    {
                        "username": "jimlinntu",
                        "content": "I suggest you **first** (VERY IMPORTANT, because this is way easier than the stack solution) understand: [A short O(n) recursive greedy solution](https://leetcode.com/problems/remove-duplicate-letters/discuss/76768/A-short-O(n)-recursive-greedy-solution)\\n\\nAnd then take a glimpse of the concept of: [Java O(n) solution using stack with detail explanation](https://leetcode.com/problems/remove-duplicate-letters/discuss/76762/Java-O(n)-solution-using-stack-with-detail-explanation)\\n\\nAnd then come back to see my clear explanation.\\nIn short, what I want to prove in the illustrations is that: the behavior of the recursive solution is as same as the stack solution!\\n\\n![image](https://assets.leetcode.com/users/images/1855659c-43ff-495c-8f0c-a7e79107c45c_1619789802.198157.png)\\n![image](https://assets.leetcode.com/users/images/8de71960-d817-441e-b65a-b6abc4983a81_1619789807.5926883.png)\\n\\n\\n\\n"
                    },
                    {
                        "username": "grasssu",
                        "content": "For the case \"aabcb\" my run code returns \"abc\" but when I submit the code the judge said my result is \"ab\". I printed the result again in run code and it is indeed \"abc\". Why is this happening?"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-duplicate-letters/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Greedy - Solving Letter by Letter\n\n  \n**Approach 2:** Greedy - Solving with Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "menBilmayman",
                        "content": "In Example 2 the answer should be \"acdb\" as shown below: ![image](https://assets.leetcode.com/users/images/57a98c14-1bff-496c-9c32-0e97c33141aa_1641739861.4432662.png)\\nSo, \"acdb\" is lexicographically smallest string. \\n\\nBut we can construct \"abcd\" also. Why answer is \"acdb\"? Why \"acdb\" is lexicographically smaller than \"abcd\"?"
                    },
                    {
                        "username": "ealejandria",
                        "content": "While \"abcd\" is a lexicographically smaller string, it is not one of our possible results. The only operation we can perform on the original string is deleting characters, we cannot reorganize them."
                    },
                    {
                        "username": "KedarKK1",
                        "content": "When you start to do dsa & cp by yourself for decent amount of time, you realize that most of permutations & sequence, subsequence questions may use bfs or bit manipulation or both (sometimes dfs as well). Hurray! you've started to understand question & their pattern. Keep it up!"
                    },
                    {
                        "username": "chooseanotherusername",
                        "content": "Not as easy as I thought!"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "A good piece of advice: DO NOT TRY TO IMPLEMENT BIT MASKS, it is pretty tricky even after you've figured out a working solution. "
                    },
                    {
                        "username": "luanct",
                        "content": "lol, I return abcd instead of acdb\\uD83D\\uDE01"
                    },
                    {
                        "username": "123Anon123",
                        "content": "Can someone please explain why the stack solution is O(N). At each iteration, we can do ***i*** work due to the nested while loop and there are N iterations. So \\u2211i, i in [0,N) = O(N^2), right?"
                    },
                    {
                        "username": "captainspongebob1",
                        "content": "Any monotonic stack solution is O(n) because each element within the stack can only be removed once. In other words, every element can only be pushed and popped once from the stack, which makes it O(n) (despite it seeming like O(n^2) due to the nested loops)."
                    },
                    {
                        "username": "aitachii",
                        "content": "The maximum possible size of the stack is $O(26)$ since there are only `26` unique lowercase English letters in total. So the nested while loop will only reach at most `26` loops in the worst case. Something like `bcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz` will make the while loop do `25` loops.\n\nBasically: \nOuter Loop: $O(N)$\nInner Loop: $O(26)$ (worst case)\n\nTotal time complexity: $O(N*26)$ = $O(N)$"
                    }
                ]
            },
            {
                "id": 1717005,
                "content": [
                    {
                        "username": "ajay_gc",
                        "content": "Somebody come up with a solution first and added test cases later and defined question as \"lexicographical order\". One of the most confusing question I have ever seen. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Intuition:\\n1. problems where subsequence of unique elements is needed to be created an array keeping track of last appearence is used\\n2. problems where an increasing / decreasing subseqence is needed to be found monotonic stack is used"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "In case somebody is thinking to solve using Trie, it gives Memory limit exceeded at 271th test case.\\n\\nBelow is my code:\\nclass Node{\\n    Node[] nodes=new Node[26];\\n}\\nclass Solution {\\n    Node root=new Node();\\n    int maxCnt=0;\\n    public String removeDuplicateLetters(String s) {\\n        char[] arr=s.toCharArray();\\n        boolean[] set=new boolean[26];\\n        for(int i=0;i<arr.length;i++){\\n            // System.out.println(arr[i]);\\n            if(set[arr[i]-\\'a\\']==false){\\n                maxCnt++;\\n            }\\n            set[arr[i]-\\'a\\']=true;\\n            addToTrie(arr, i);\\n        }\\n        return lookFor(root, new char[maxCnt], 0);\\n        // return \"\"+maxCnt;\\n    }\\n    public String lookFor(Node node, char[] arr, int a){\\n        // System.out.println(Arrays.toString(arr)+\" \"+a);\\n        if(a>maxCnt){\\n            return null;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(node.nodes[i]!=null){\\n                char x=arr[a];\\n                arr[a]=(char)(i+\\'a\\');\\n                if(a==maxCnt-1){\\n                    return new String(arr);\\n                }\\n                String temp=lookFor(node.nodes[i], arr, a+1);\\n                arr[a]=x;\\n                if(temp!=null){\\n                    return temp;\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n    public void addToTrie(char[] arr, int i){\\n        for(int j=0;j<26;j++){\\n            if((j!=arr[i]-\\'a\\') && root.nodes[j]!=null){\\n                add(root.nodes[j], arr[i]);\\n            }\\n        }\\n        if(root.nodes[arr[i]-\\'a\\']==null){\\n            root.nodes[arr[i]-\\'a\\']=new Node();\\n        }\\n    }\\n    public void add(Node node, char a){\\n        if(node.nodes[a-\\'a\\']==null){\\n            node.nodes[a-\\'a\\']=new Node();           \\n        }\\n        for(int i=0;i<26;i++){\\n            if(i!=a-\\'a\\' && node.nodes[i]!=null){\\n                add(node.nodes[i], a);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "dont post code in discussion section"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "s = \"abacb\" output = \"abc\"\\n\\nif we\\'re using monotonous stack how to ensure we shouldn\\'t pop out b & a from stack when we encounter a at index2 during iteration. because my output is \"acb\" which is larger in lexicographical order compered to \"abc\""
                    },
                    {
                        "username": "sagar-1209",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int n = s.length();\\n        map<char,int> mp;\\n        string ans = \"\";\\n        stack<char> st;\\n        stack<char> temp;\\n        for(auto it : s) mp[it]++;\\n        for(int i=0;i<n;i++){\\n            if(mp[s[i]]==0) continue;\\n            if(st.empty() && mp[s[i]]==1) {ans+=s[i]; mp[s[i]]--; continue;}\\n            if(st.empty()){\\n                st.push(s[i]);\\n                mp[s[i]]--;\\n                continue;\\n            }\\n            while(!st.empty() && st.top() >= s[i]) {\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n            if(!st.empty() && mp[s[i]]==1){\\n                while(!st.empty()){\\n                    temp.push(st.top());\\n                    mp[st.top()] = 0;\\n                    st.pop();\\n                }\\n                while(!temp.empty()){\\n                    ans+= temp.top();\\n                    temp.pop();\\n                }\\n            }\\n            else{\\n                mp[s[i]]--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\nin this code 281 test case pass out of 290.\\ncan you help in this code to find solution "
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem is medium to hard. Can be easily solved using a stack. \\nHint:-\\nKeep on popping form stack if the top element is > incoming element and the last index of top element > current index of the element\\nelse add to stack and update the visited array to true.\\nThis should be done if the element has not been visited before. So, keep the track of it by maintaining a visited array."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I coded a complete different alternative greedy algorithm after reading the hint...\nmaybe someone likes this alternative or its easier to understand!:)\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "samorV",
                        "content": "Useless hint, inaccurate difficulty => big fat downvote"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i must admit the hint got me on a complete different track but this worked also!\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Everyone be like discussion section might have better explanation for Lexicographically Smaller  than google and it always works."
                    },
                    {
                        "username": "user0917sU",
                        "content": "I donot understand why it is considered question of monotonic stack, the characters in stack are not in increasing or decreasing order. \nEx: \nI/P: s =\"cbacdcbc\"\nO/P: \"acdb\"\n\nBy definition, monotonic stack should be \"abcd\" as per question. Remove that tag please"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i just see a stack also "
                    }
                ]
            },
            {
                "id": 2076540,
                "content": [
                    {
                        "username": "ajay_gc",
                        "content": "Somebody come up with a solution first and added test cases later and defined question as \"lexicographical order\". One of the most confusing question I have ever seen. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Intuition:\\n1. problems where subsequence of unique elements is needed to be created an array keeping track of last appearence is used\\n2. problems where an increasing / decreasing subseqence is needed to be found monotonic stack is used"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "In case somebody is thinking to solve using Trie, it gives Memory limit exceeded at 271th test case.\\n\\nBelow is my code:\\nclass Node{\\n    Node[] nodes=new Node[26];\\n}\\nclass Solution {\\n    Node root=new Node();\\n    int maxCnt=0;\\n    public String removeDuplicateLetters(String s) {\\n        char[] arr=s.toCharArray();\\n        boolean[] set=new boolean[26];\\n        for(int i=0;i<arr.length;i++){\\n            // System.out.println(arr[i]);\\n            if(set[arr[i]-\\'a\\']==false){\\n                maxCnt++;\\n            }\\n            set[arr[i]-\\'a\\']=true;\\n            addToTrie(arr, i);\\n        }\\n        return lookFor(root, new char[maxCnt], 0);\\n        // return \"\"+maxCnt;\\n    }\\n    public String lookFor(Node node, char[] arr, int a){\\n        // System.out.println(Arrays.toString(arr)+\" \"+a);\\n        if(a>maxCnt){\\n            return null;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(node.nodes[i]!=null){\\n                char x=arr[a];\\n                arr[a]=(char)(i+\\'a\\');\\n                if(a==maxCnt-1){\\n                    return new String(arr);\\n                }\\n                String temp=lookFor(node.nodes[i], arr, a+1);\\n                arr[a]=x;\\n                if(temp!=null){\\n                    return temp;\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n    public void addToTrie(char[] arr, int i){\\n        for(int j=0;j<26;j++){\\n            if((j!=arr[i]-\\'a\\') && root.nodes[j]!=null){\\n                add(root.nodes[j], arr[i]);\\n            }\\n        }\\n        if(root.nodes[arr[i]-\\'a\\']==null){\\n            root.nodes[arr[i]-\\'a\\']=new Node();\\n        }\\n    }\\n    public void add(Node node, char a){\\n        if(node.nodes[a-\\'a\\']==null){\\n            node.nodes[a-\\'a\\']=new Node();           \\n        }\\n        for(int i=0;i<26;i++){\\n            if(i!=a-\\'a\\' && node.nodes[i]!=null){\\n                add(node.nodes[i], a);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "dont post code in discussion section"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "s = \"abacb\" output = \"abc\"\\n\\nif we\\'re using monotonous stack how to ensure we shouldn\\'t pop out b & a from stack when we encounter a at index2 during iteration. because my output is \"acb\" which is larger in lexicographical order compered to \"abc\""
                    },
                    {
                        "username": "sagar-1209",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int n = s.length();\\n        map<char,int> mp;\\n        string ans = \"\";\\n        stack<char> st;\\n        stack<char> temp;\\n        for(auto it : s) mp[it]++;\\n        for(int i=0;i<n;i++){\\n            if(mp[s[i]]==0) continue;\\n            if(st.empty() && mp[s[i]]==1) {ans+=s[i]; mp[s[i]]--; continue;}\\n            if(st.empty()){\\n                st.push(s[i]);\\n                mp[s[i]]--;\\n                continue;\\n            }\\n            while(!st.empty() && st.top() >= s[i]) {\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n            if(!st.empty() && mp[s[i]]==1){\\n                while(!st.empty()){\\n                    temp.push(st.top());\\n                    mp[st.top()] = 0;\\n                    st.pop();\\n                }\\n                while(!temp.empty()){\\n                    ans+= temp.top();\\n                    temp.pop();\\n                }\\n            }\\n            else{\\n                mp[s[i]]--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\nin this code 281 test case pass out of 290.\\ncan you help in this code to find solution "
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem is medium to hard. Can be easily solved using a stack. \\nHint:-\\nKeep on popping form stack if the top element is > incoming element and the last index of top element > current index of the element\\nelse add to stack and update the visited array to true.\\nThis should be done if the element has not been visited before. So, keep the track of it by maintaining a visited array."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I coded a complete different alternative greedy algorithm after reading the hint...\nmaybe someone likes this alternative or its easier to understand!:)\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "samorV",
                        "content": "Useless hint, inaccurate difficulty => big fat downvote"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i must admit the hint got me on a complete different track but this worked also!\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Everyone be like discussion section might have better explanation for Lexicographically Smaller  than google and it always works."
                    },
                    {
                        "username": "user0917sU",
                        "content": "I donot understand why it is considered question of monotonic stack, the characters in stack are not in increasing or decreasing order. \nEx: \nI/P: s =\"cbacdcbc\"\nO/P: \"acdb\"\n\nBy definition, monotonic stack should be \"abcd\" as per question. Remove that tag please"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i just see a stack also "
                    }
                ]
            },
            {
                "id": 2076011,
                "content": [
                    {
                        "username": "ajay_gc",
                        "content": "Somebody come up with a solution first and added test cases later and defined question as \"lexicographical order\". One of the most confusing question I have ever seen. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Intuition:\\n1. problems where subsequence of unique elements is needed to be created an array keeping track of last appearence is used\\n2. problems where an increasing / decreasing subseqence is needed to be found monotonic stack is used"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "In case somebody is thinking to solve using Trie, it gives Memory limit exceeded at 271th test case.\\n\\nBelow is my code:\\nclass Node{\\n    Node[] nodes=new Node[26];\\n}\\nclass Solution {\\n    Node root=new Node();\\n    int maxCnt=0;\\n    public String removeDuplicateLetters(String s) {\\n        char[] arr=s.toCharArray();\\n        boolean[] set=new boolean[26];\\n        for(int i=0;i<arr.length;i++){\\n            // System.out.println(arr[i]);\\n            if(set[arr[i]-\\'a\\']==false){\\n                maxCnt++;\\n            }\\n            set[arr[i]-\\'a\\']=true;\\n            addToTrie(arr, i);\\n        }\\n        return lookFor(root, new char[maxCnt], 0);\\n        // return \"\"+maxCnt;\\n    }\\n    public String lookFor(Node node, char[] arr, int a){\\n        // System.out.println(Arrays.toString(arr)+\" \"+a);\\n        if(a>maxCnt){\\n            return null;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(node.nodes[i]!=null){\\n                char x=arr[a];\\n                arr[a]=(char)(i+\\'a\\');\\n                if(a==maxCnt-1){\\n                    return new String(arr);\\n                }\\n                String temp=lookFor(node.nodes[i], arr, a+1);\\n                arr[a]=x;\\n                if(temp!=null){\\n                    return temp;\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n    public void addToTrie(char[] arr, int i){\\n        for(int j=0;j<26;j++){\\n            if((j!=arr[i]-\\'a\\') && root.nodes[j]!=null){\\n                add(root.nodes[j], arr[i]);\\n            }\\n        }\\n        if(root.nodes[arr[i]-\\'a\\']==null){\\n            root.nodes[arr[i]-\\'a\\']=new Node();\\n        }\\n    }\\n    public void add(Node node, char a){\\n        if(node.nodes[a-\\'a\\']==null){\\n            node.nodes[a-\\'a\\']=new Node();           \\n        }\\n        for(int i=0;i<26;i++){\\n            if(i!=a-\\'a\\' && node.nodes[i]!=null){\\n                add(node.nodes[i], a);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "dont post code in discussion section"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "s = \"abacb\" output = \"abc\"\\n\\nif we\\'re using monotonous stack how to ensure we shouldn\\'t pop out b & a from stack when we encounter a at index2 during iteration. because my output is \"acb\" which is larger in lexicographical order compered to \"abc\""
                    },
                    {
                        "username": "sagar-1209",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int n = s.length();\\n        map<char,int> mp;\\n        string ans = \"\";\\n        stack<char> st;\\n        stack<char> temp;\\n        for(auto it : s) mp[it]++;\\n        for(int i=0;i<n;i++){\\n            if(mp[s[i]]==0) continue;\\n            if(st.empty() && mp[s[i]]==1) {ans+=s[i]; mp[s[i]]--; continue;}\\n            if(st.empty()){\\n                st.push(s[i]);\\n                mp[s[i]]--;\\n                continue;\\n            }\\n            while(!st.empty() && st.top() >= s[i]) {\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n            if(!st.empty() && mp[s[i]]==1){\\n                while(!st.empty()){\\n                    temp.push(st.top());\\n                    mp[st.top()] = 0;\\n                    st.pop();\\n                }\\n                while(!temp.empty()){\\n                    ans+= temp.top();\\n                    temp.pop();\\n                }\\n            }\\n            else{\\n                mp[s[i]]--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\nin this code 281 test case pass out of 290.\\ncan you help in this code to find solution "
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem is medium to hard. Can be easily solved using a stack. \\nHint:-\\nKeep on popping form stack if the top element is > incoming element and the last index of top element > current index of the element\\nelse add to stack and update the visited array to true.\\nThis should be done if the element has not been visited before. So, keep the track of it by maintaining a visited array."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I coded a complete different alternative greedy algorithm after reading the hint...\nmaybe someone likes this alternative or its easier to understand!:)\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "samorV",
                        "content": "Useless hint, inaccurate difficulty => big fat downvote"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i must admit the hint got me on a complete different track but this worked also!\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Everyone be like discussion section might have better explanation for Lexicographically Smaller  than google and it always works."
                    },
                    {
                        "username": "user0917sU",
                        "content": "I donot understand why it is considered question of monotonic stack, the characters in stack are not in increasing or decreasing order. \nEx: \nI/P: s =\"cbacdcbc\"\nO/P: \"acdb\"\n\nBy definition, monotonic stack should be \"abcd\" as per question. Remove that tag please"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i just see a stack also "
                    }
                ]
            },
            {
                "id": 2074229,
                "content": [
                    {
                        "username": "ajay_gc",
                        "content": "Somebody come up with a solution first and added test cases later and defined question as \"lexicographical order\". One of the most confusing question I have ever seen. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Intuition:\\n1. problems where subsequence of unique elements is needed to be created an array keeping track of last appearence is used\\n2. problems where an increasing / decreasing subseqence is needed to be found monotonic stack is used"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "In case somebody is thinking to solve using Trie, it gives Memory limit exceeded at 271th test case.\\n\\nBelow is my code:\\nclass Node{\\n    Node[] nodes=new Node[26];\\n}\\nclass Solution {\\n    Node root=new Node();\\n    int maxCnt=0;\\n    public String removeDuplicateLetters(String s) {\\n        char[] arr=s.toCharArray();\\n        boolean[] set=new boolean[26];\\n        for(int i=0;i<arr.length;i++){\\n            // System.out.println(arr[i]);\\n            if(set[arr[i]-\\'a\\']==false){\\n                maxCnt++;\\n            }\\n            set[arr[i]-\\'a\\']=true;\\n            addToTrie(arr, i);\\n        }\\n        return lookFor(root, new char[maxCnt], 0);\\n        // return \"\"+maxCnt;\\n    }\\n    public String lookFor(Node node, char[] arr, int a){\\n        // System.out.println(Arrays.toString(arr)+\" \"+a);\\n        if(a>maxCnt){\\n            return null;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(node.nodes[i]!=null){\\n                char x=arr[a];\\n                arr[a]=(char)(i+\\'a\\');\\n                if(a==maxCnt-1){\\n                    return new String(arr);\\n                }\\n                String temp=lookFor(node.nodes[i], arr, a+1);\\n                arr[a]=x;\\n                if(temp!=null){\\n                    return temp;\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n    public void addToTrie(char[] arr, int i){\\n        for(int j=0;j<26;j++){\\n            if((j!=arr[i]-\\'a\\') && root.nodes[j]!=null){\\n                add(root.nodes[j], arr[i]);\\n            }\\n        }\\n        if(root.nodes[arr[i]-\\'a\\']==null){\\n            root.nodes[arr[i]-\\'a\\']=new Node();\\n        }\\n    }\\n    public void add(Node node, char a){\\n        if(node.nodes[a-\\'a\\']==null){\\n            node.nodes[a-\\'a\\']=new Node();           \\n        }\\n        for(int i=0;i<26;i++){\\n            if(i!=a-\\'a\\' && node.nodes[i]!=null){\\n                add(node.nodes[i], a);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "dont post code in discussion section"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "s = \"abacb\" output = \"abc\"\\n\\nif we\\'re using monotonous stack how to ensure we shouldn\\'t pop out b & a from stack when we encounter a at index2 during iteration. because my output is \"acb\" which is larger in lexicographical order compered to \"abc\""
                    },
                    {
                        "username": "sagar-1209",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int n = s.length();\\n        map<char,int> mp;\\n        string ans = \"\";\\n        stack<char> st;\\n        stack<char> temp;\\n        for(auto it : s) mp[it]++;\\n        for(int i=0;i<n;i++){\\n            if(mp[s[i]]==0) continue;\\n            if(st.empty() && mp[s[i]]==1) {ans+=s[i]; mp[s[i]]--; continue;}\\n            if(st.empty()){\\n                st.push(s[i]);\\n                mp[s[i]]--;\\n                continue;\\n            }\\n            while(!st.empty() && st.top() >= s[i]) {\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n            if(!st.empty() && mp[s[i]]==1){\\n                while(!st.empty()){\\n                    temp.push(st.top());\\n                    mp[st.top()] = 0;\\n                    st.pop();\\n                }\\n                while(!temp.empty()){\\n                    ans+= temp.top();\\n                    temp.pop();\\n                }\\n            }\\n            else{\\n                mp[s[i]]--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\nin this code 281 test case pass out of 290.\\ncan you help in this code to find solution "
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem is medium to hard. Can be easily solved using a stack. \\nHint:-\\nKeep on popping form stack if the top element is > incoming element and the last index of top element > current index of the element\\nelse add to stack and update the visited array to true.\\nThis should be done if the element has not been visited before. So, keep the track of it by maintaining a visited array."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I coded a complete different alternative greedy algorithm after reading the hint...\nmaybe someone likes this alternative or its easier to understand!:)\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "samorV",
                        "content": "Useless hint, inaccurate difficulty => big fat downvote"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i must admit the hint got me on a complete different track but this worked also!\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Everyone be like discussion section might have better explanation for Lexicographically Smaller  than google and it always works."
                    },
                    {
                        "username": "user0917sU",
                        "content": "I donot understand why it is considered question of monotonic stack, the characters in stack are not in increasing or decreasing order. \nEx: \nI/P: s =\"cbacdcbc\"\nO/P: \"acdb\"\n\nBy definition, monotonic stack should be \"abcd\" as per question. Remove that tag please"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i just see a stack also "
                    }
                ]
            },
            {
                "id": 2073688,
                "content": [
                    {
                        "username": "ajay_gc",
                        "content": "Somebody come up with a solution first and added test cases later and defined question as \"lexicographical order\". One of the most confusing question I have ever seen. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Intuition:\\n1. problems where subsequence of unique elements is needed to be created an array keeping track of last appearence is used\\n2. problems where an increasing / decreasing subseqence is needed to be found monotonic stack is used"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "In case somebody is thinking to solve using Trie, it gives Memory limit exceeded at 271th test case.\\n\\nBelow is my code:\\nclass Node{\\n    Node[] nodes=new Node[26];\\n}\\nclass Solution {\\n    Node root=new Node();\\n    int maxCnt=0;\\n    public String removeDuplicateLetters(String s) {\\n        char[] arr=s.toCharArray();\\n        boolean[] set=new boolean[26];\\n        for(int i=0;i<arr.length;i++){\\n            // System.out.println(arr[i]);\\n            if(set[arr[i]-\\'a\\']==false){\\n                maxCnt++;\\n            }\\n            set[arr[i]-\\'a\\']=true;\\n            addToTrie(arr, i);\\n        }\\n        return lookFor(root, new char[maxCnt], 0);\\n        // return \"\"+maxCnt;\\n    }\\n    public String lookFor(Node node, char[] arr, int a){\\n        // System.out.println(Arrays.toString(arr)+\" \"+a);\\n        if(a>maxCnt){\\n            return null;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(node.nodes[i]!=null){\\n                char x=arr[a];\\n                arr[a]=(char)(i+\\'a\\');\\n                if(a==maxCnt-1){\\n                    return new String(arr);\\n                }\\n                String temp=lookFor(node.nodes[i], arr, a+1);\\n                arr[a]=x;\\n                if(temp!=null){\\n                    return temp;\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n    public void addToTrie(char[] arr, int i){\\n        for(int j=0;j<26;j++){\\n            if((j!=arr[i]-\\'a\\') && root.nodes[j]!=null){\\n                add(root.nodes[j], arr[i]);\\n            }\\n        }\\n        if(root.nodes[arr[i]-\\'a\\']==null){\\n            root.nodes[arr[i]-\\'a\\']=new Node();\\n        }\\n    }\\n    public void add(Node node, char a){\\n        if(node.nodes[a-\\'a\\']==null){\\n            node.nodes[a-\\'a\\']=new Node();           \\n        }\\n        for(int i=0;i<26;i++){\\n            if(i!=a-\\'a\\' && node.nodes[i]!=null){\\n                add(node.nodes[i], a);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "dont post code in discussion section"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "s = \"abacb\" output = \"abc\"\\n\\nif we\\'re using monotonous stack how to ensure we shouldn\\'t pop out b & a from stack when we encounter a at index2 during iteration. because my output is \"acb\" which is larger in lexicographical order compered to \"abc\""
                    },
                    {
                        "username": "sagar-1209",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int n = s.length();\\n        map<char,int> mp;\\n        string ans = \"\";\\n        stack<char> st;\\n        stack<char> temp;\\n        for(auto it : s) mp[it]++;\\n        for(int i=0;i<n;i++){\\n            if(mp[s[i]]==0) continue;\\n            if(st.empty() && mp[s[i]]==1) {ans+=s[i]; mp[s[i]]--; continue;}\\n            if(st.empty()){\\n                st.push(s[i]);\\n                mp[s[i]]--;\\n                continue;\\n            }\\n            while(!st.empty() && st.top() >= s[i]) {\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n            if(!st.empty() && mp[s[i]]==1){\\n                while(!st.empty()){\\n                    temp.push(st.top());\\n                    mp[st.top()] = 0;\\n                    st.pop();\\n                }\\n                while(!temp.empty()){\\n                    ans+= temp.top();\\n                    temp.pop();\\n                }\\n            }\\n            else{\\n                mp[s[i]]--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\nin this code 281 test case pass out of 290.\\ncan you help in this code to find solution "
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem is medium to hard. Can be easily solved using a stack. \\nHint:-\\nKeep on popping form stack if the top element is > incoming element and the last index of top element > current index of the element\\nelse add to stack and update the visited array to true.\\nThis should be done if the element has not been visited before. So, keep the track of it by maintaining a visited array."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I coded a complete different alternative greedy algorithm after reading the hint...\nmaybe someone likes this alternative or its easier to understand!:)\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "samorV",
                        "content": "Useless hint, inaccurate difficulty => big fat downvote"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i must admit the hint got me on a complete different track but this worked also!\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Everyone be like discussion section might have better explanation for Lexicographically Smaller  than google and it always works."
                    },
                    {
                        "username": "user0917sU",
                        "content": "I donot understand why it is considered question of monotonic stack, the characters in stack are not in increasing or decreasing order. \nEx: \nI/P: s =\"cbacdcbc\"\nO/P: \"acdb\"\n\nBy definition, monotonic stack should be \"abcd\" as per question. Remove that tag please"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i just see a stack also "
                    }
                ]
            },
            {
                "id": 2073664,
                "content": [
                    {
                        "username": "ajay_gc",
                        "content": "Somebody come up with a solution first and added test cases later and defined question as \"lexicographical order\". One of the most confusing question I have ever seen. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Intuition:\\n1. problems where subsequence of unique elements is needed to be created an array keeping track of last appearence is used\\n2. problems where an increasing / decreasing subseqence is needed to be found monotonic stack is used"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "In case somebody is thinking to solve using Trie, it gives Memory limit exceeded at 271th test case.\\n\\nBelow is my code:\\nclass Node{\\n    Node[] nodes=new Node[26];\\n}\\nclass Solution {\\n    Node root=new Node();\\n    int maxCnt=0;\\n    public String removeDuplicateLetters(String s) {\\n        char[] arr=s.toCharArray();\\n        boolean[] set=new boolean[26];\\n        for(int i=0;i<arr.length;i++){\\n            // System.out.println(arr[i]);\\n            if(set[arr[i]-\\'a\\']==false){\\n                maxCnt++;\\n            }\\n            set[arr[i]-\\'a\\']=true;\\n            addToTrie(arr, i);\\n        }\\n        return lookFor(root, new char[maxCnt], 0);\\n        // return \"\"+maxCnt;\\n    }\\n    public String lookFor(Node node, char[] arr, int a){\\n        // System.out.println(Arrays.toString(arr)+\" \"+a);\\n        if(a>maxCnt){\\n            return null;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(node.nodes[i]!=null){\\n                char x=arr[a];\\n                arr[a]=(char)(i+\\'a\\');\\n                if(a==maxCnt-1){\\n                    return new String(arr);\\n                }\\n                String temp=lookFor(node.nodes[i], arr, a+1);\\n                arr[a]=x;\\n                if(temp!=null){\\n                    return temp;\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n    public void addToTrie(char[] arr, int i){\\n        for(int j=0;j<26;j++){\\n            if((j!=arr[i]-\\'a\\') && root.nodes[j]!=null){\\n                add(root.nodes[j], arr[i]);\\n            }\\n        }\\n        if(root.nodes[arr[i]-\\'a\\']==null){\\n            root.nodes[arr[i]-\\'a\\']=new Node();\\n        }\\n    }\\n    public void add(Node node, char a){\\n        if(node.nodes[a-\\'a\\']==null){\\n            node.nodes[a-\\'a\\']=new Node();           \\n        }\\n        for(int i=0;i<26;i++){\\n            if(i!=a-\\'a\\' && node.nodes[i]!=null){\\n                add(node.nodes[i], a);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "dont post code in discussion section"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "s = \"abacb\" output = \"abc\"\\n\\nif we\\'re using monotonous stack how to ensure we shouldn\\'t pop out b & a from stack when we encounter a at index2 during iteration. because my output is \"acb\" which is larger in lexicographical order compered to \"abc\""
                    },
                    {
                        "username": "sagar-1209",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int n = s.length();\\n        map<char,int> mp;\\n        string ans = \"\";\\n        stack<char> st;\\n        stack<char> temp;\\n        for(auto it : s) mp[it]++;\\n        for(int i=0;i<n;i++){\\n            if(mp[s[i]]==0) continue;\\n            if(st.empty() && mp[s[i]]==1) {ans+=s[i]; mp[s[i]]--; continue;}\\n            if(st.empty()){\\n                st.push(s[i]);\\n                mp[s[i]]--;\\n                continue;\\n            }\\n            while(!st.empty() && st.top() >= s[i]) {\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n            if(!st.empty() && mp[s[i]]==1){\\n                while(!st.empty()){\\n                    temp.push(st.top());\\n                    mp[st.top()] = 0;\\n                    st.pop();\\n                }\\n                while(!temp.empty()){\\n                    ans+= temp.top();\\n                    temp.pop();\\n                }\\n            }\\n            else{\\n                mp[s[i]]--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\nin this code 281 test case pass out of 290.\\ncan you help in this code to find solution "
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem is medium to hard. Can be easily solved using a stack. \\nHint:-\\nKeep on popping form stack if the top element is > incoming element and the last index of top element > current index of the element\\nelse add to stack and update the visited array to true.\\nThis should be done if the element has not been visited before. So, keep the track of it by maintaining a visited array."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I coded a complete different alternative greedy algorithm after reading the hint...\nmaybe someone likes this alternative or its easier to understand!:)\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "samorV",
                        "content": "Useless hint, inaccurate difficulty => big fat downvote"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i must admit the hint got me on a complete different track but this worked also!\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Everyone be like discussion section might have better explanation for Lexicographically Smaller  than google and it always works."
                    },
                    {
                        "username": "user0917sU",
                        "content": "I donot understand why it is considered question of monotonic stack, the characters in stack are not in increasing or decreasing order. \nEx: \nI/P: s =\"cbacdcbc\"\nO/P: \"acdb\"\n\nBy definition, monotonic stack should be \"abcd\" as per question. Remove that tag please"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i just see a stack also "
                    }
                ]
            },
            {
                "id": 2073587,
                "content": [
                    {
                        "username": "ajay_gc",
                        "content": "Somebody come up with a solution first and added test cases later and defined question as \"lexicographical order\". One of the most confusing question I have ever seen. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Intuition:\\n1. problems where subsequence of unique elements is needed to be created an array keeping track of last appearence is used\\n2. problems where an increasing / decreasing subseqence is needed to be found monotonic stack is used"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "In case somebody is thinking to solve using Trie, it gives Memory limit exceeded at 271th test case.\\n\\nBelow is my code:\\nclass Node{\\n    Node[] nodes=new Node[26];\\n}\\nclass Solution {\\n    Node root=new Node();\\n    int maxCnt=0;\\n    public String removeDuplicateLetters(String s) {\\n        char[] arr=s.toCharArray();\\n        boolean[] set=new boolean[26];\\n        for(int i=0;i<arr.length;i++){\\n            // System.out.println(arr[i]);\\n            if(set[arr[i]-\\'a\\']==false){\\n                maxCnt++;\\n            }\\n            set[arr[i]-\\'a\\']=true;\\n            addToTrie(arr, i);\\n        }\\n        return lookFor(root, new char[maxCnt], 0);\\n        // return \"\"+maxCnt;\\n    }\\n    public String lookFor(Node node, char[] arr, int a){\\n        // System.out.println(Arrays.toString(arr)+\" \"+a);\\n        if(a>maxCnt){\\n            return null;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(node.nodes[i]!=null){\\n                char x=arr[a];\\n                arr[a]=(char)(i+\\'a\\');\\n                if(a==maxCnt-1){\\n                    return new String(arr);\\n                }\\n                String temp=lookFor(node.nodes[i], arr, a+1);\\n                arr[a]=x;\\n                if(temp!=null){\\n                    return temp;\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n    public void addToTrie(char[] arr, int i){\\n        for(int j=0;j<26;j++){\\n            if((j!=arr[i]-\\'a\\') && root.nodes[j]!=null){\\n                add(root.nodes[j], arr[i]);\\n            }\\n        }\\n        if(root.nodes[arr[i]-\\'a\\']==null){\\n            root.nodes[arr[i]-\\'a\\']=new Node();\\n        }\\n    }\\n    public void add(Node node, char a){\\n        if(node.nodes[a-\\'a\\']==null){\\n            node.nodes[a-\\'a\\']=new Node();           \\n        }\\n        for(int i=0;i<26;i++){\\n            if(i!=a-\\'a\\' && node.nodes[i]!=null){\\n                add(node.nodes[i], a);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "dont post code in discussion section"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "s = \"abacb\" output = \"abc\"\\n\\nif we\\'re using monotonous stack how to ensure we shouldn\\'t pop out b & a from stack when we encounter a at index2 during iteration. because my output is \"acb\" which is larger in lexicographical order compered to \"abc\""
                    },
                    {
                        "username": "sagar-1209",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int n = s.length();\\n        map<char,int> mp;\\n        string ans = \"\";\\n        stack<char> st;\\n        stack<char> temp;\\n        for(auto it : s) mp[it]++;\\n        for(int i=0;i<n;i++){\\n            if(mp[s[i]]==0) continue;\\n            if(st.empty() && mp[s[i]]==1) {ans+=s[i]; mp[s[i]]--; continue;}\\n            if(st.empty()){\\n                st.push(s[i]);\\n                mp[s[i]]--;\\n                continue;\\n            }\\n            while(!st.empty() && st.top() >= s[i]) {\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n            if(!st.empty() && mp[s[i]]==1){\\n                while(!st.empty()){\\n                    temp.push(st.top());\\n                    mp[st.top()] = 0;\\n                    st.pop();\\n                }\\n                while(!temp.empty()){\\n                    ans+= temp.top();\\n                    temp.pop();\\n                }\\n            }\\n            else{\\n                mp[s[i]]--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\nin this code 281 test case pass out of 290.\\ncan you help in this code to find solution "
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem is medium to hard. Can be easily solved using a stack. \\nHint:-\\nKeep on popping form stack if the top element is > incoming element and the last index of top element > current index of the element\\nelse add to stack and update the visited array to true.\\nThis should be done if the element has not been visited before. So, keep the track of it by maintaining a visited array."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I coded a complete different alternative greedy algorithm after reading the hint...\nmaybe someone likes this alternative or its easier to understand!:)\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "samorV",
                        "content": "Useless hint, inaccurate difficulty => big fat downvote"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i must admit the hint got me on a complete different track but this worked also!\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Everyone be like discussion section might have better explanation for Lexicographically Smaller  than google and it always works."
                    },
                    {
                        "username": "user0917sU",
                        "content": "I donot understand why it is considered question of monotonic stack, the characters in stack are not in increasing or decreasing order. \nEx: \nI/P: s =\"cbacdcbc\"\nO/P: \"acdb\"\n\nBy definition, monotonic stack should be \"abcd\" as per question. Remove that tag please"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i just see a stack also "
                    }
                ]
            },
            {
                "id": 2073584,
                "content": [
                    {
                        "username": "ajay_gc",
                        "content": "Somebody come up with a solution first and added test cases later and defined question as \"lexicographical order\". One of the most confusing question I have ever seen. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Intuition:\\n1. problems where subsequence of unique elements is needed to be created an array keeping track of last appearence is used\\n2. problems where an increasing / decreasing subseqence is needed to be found monotonic stack is used"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "In case somebody is thinking to solve using Trie, it gives Memory limit exceeded at 271th test case.\\n\\nBelow is my code:\\nclass Node{\\n    Node[] nodes=new Node[26];\\n}\\nclass Solution {\\n    Node root=new Node();\\n    int maxCnt=0;\\n    public String removeDuplicateLetters(String s) {\\n        char[] arr=s.toCharArray();\\n        boolean[] set=new boolean[26];\\n        for(int i=0;i<arr.length;i++){\\n            // System.out.println(arr[i]);\\n            if(set[arr[i]-\\'a\\']==false){\\n                maxCnt++;\\n            }\\n            set[arr[i]-\\'a\\']=true;\\n            addToTrie(arr, i);\\n        }\\n        return lookFor(root, new char[maxCnt], 0);\\n        // return \"\"+maxCnt;\\n    }\\n    public String lookFor(Node node, char[] arr, int a){\\n        // System.out.println(Arrays.toString(arr)+\" \"+a);\\n        if(a>maxCnt){\\n            return null;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(node.nodes[i]!=null){\\n                char x=arr[a];\\n                arr[a]=(char)(i+\\'a\\');\\n                if(a==maxCnt-1){\\n                    return new String(arr);\\n                }\\n                String temp=lookFor(node.nodes[i], arr, a+1);\\n                arr[a]=x;\\n                if(temp!=null){\\n                    return temp;\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n    public void addToTrie(char[] arr, int i){\\n        for(int j=0;j<26;j++){\\n            if((j!=arr[i]-\\'a\\') && root.nodes[j]!=null){\\n                add(root.nodes[j], arr[i]);\\n            }\\n        }\\n        if(root.nodes[arr[i]-\\'a\\']==null){\\n            root.nodes[arr[i]-\\'a\\']=new Node();\\n        }\\n    }\\n    public void add(Node node, char a){\\n        if(node.nodes[a-\\'a\\']==null){\\n            node.nodes[a-\\'a\\']=new Node();           \\n        }\\n        for(int i=0;i<26;i++){\\n            if(i!=a-\\'a\\' && node.nodes[i]!=null){\\n                add(node.nodes[i], a);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "dont post code in discussion section"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "s = \"abacb\" output = \"abc\"\\n\\nif we\\'re using monotonous stack how to ensure we shouldn\\'t pop out b & a from stack when we encounter a at index2 during iteration. because my output is \"acb\" which is larger in lexicographical order compered to \"abc\""
                    },
                    {
                        "username": "sagar-1209",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int n = s.length();\\n        map<char,int> mp;\\n        string ans = \"\";\\n        stack<char> st;\\n        stack<char> temp;\\n        for(auto it : s) mp[it]++;\\n        for(int i=0;i<n;i++){\\n            if(mp[s[i]]==0) continue;\\n            if(st.empty() && mp[s[i]]==1) {ans+=s[i]; mp[s[i]]--; continue;}\\n            if(st.empty()){\\n                st.push(s[i]);\\n                mp[s[i]]--;\\n                continue;\\n            }\\n            while(!st.empty() && st.top() >= s[i]) {\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n            if(!st.empty() && mp[s[i]]==1){\\n                while(!st.empty()){\\n                    temp.push(st.top());\\n                    mp[st.top()] = 0;\\n                    st.pop();\\n                }\\n                while(!temp.empty()){\\n                    ans+= temp.top();\\n                    temp.pop();\\n                }\\n            }\\n            else{\\n                mp[s[i]]--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\nin this code 281 test case pass out of 290.\\ncan you help in this code to find solution "
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem is medium to hard. Can be easily solved using a stack. \\nHint:-\\nKeep on popping form stack if the top element is > incoming element and the last index of top element > current index of the element\\nelse add to stack and update the visited array to true.\\nThis should be done if the element has not been visited before. So, keep the track of it by maintaining a visited array."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I coded a complete different alternative greedy algorithm after reading the hint...\nmaybe someone likes this alternative or its easier to understand!:)\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "samorV",
                        "content": "Useless hint, inaccurate difficulty => big fat downvote"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i must admit the hint got me on a complete different track but this worked also!\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Everyone be like discussion section might have better explanation for Lexicographically Smaller  than google and it always works."
                    },
                    {
                        "username": "user0917sU",
                        "content": "I donot understand why it is considered question of monotonic stack, the characters in stack are not in increasing or decreasing order. \nEx: \nI/P: s =\"cbacdcbc\"\nO/P: \"acdb\"\n\nBy definition, monotonic stack should be \"abcd\" as per question. Remove that tag please"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i just see a stack also "
                    }
                ]
            },
            {
                "id": 2073519,
                "content": [
                    {
                        "username": "ajay_gc",
                        "content": "Somebody come up with a solution first and added test cases later and defined question as \"lexicographical order\". One of the most confusing question I have ever seen. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Intuition:\\n1. problems where subsequence of unique elements is needed to be created an array keeping track of last appearence is used\\n2. problems where an increasing / decreasing subseqence is needed to be found monotonic stack is used"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "In case somebody is thinking to solve using Trie, it gives Memory limit exceeded at 271th test case.\\n\\nBelow is my code:\\nclass Node{\\n    Node[] nodes=new Node[26];\\n}\\nclass Solution {\\n    Node root=new Node();\\n    int maxCnt=0;\\n    public String removeDuplicateLetters(String s) {\\n        char[] arr=s.toCharArray();\\n        boolean[] set=new boolean[26];\\n        for(int i=0;i<arr.length;i++){\\n            // System.out.println(arr[i]);\\n            if(set[arr[i]-\\'a\\']==false){\\n                maxCnt++;\\n            }\\n            set[arr[i]-\\'a\\']=true;\\n            addToTrie(arr, i);\\n        }\\n        return lookFor(root, new char[maxCnt], 0);\\n        // return \"\"+maxCnt;\\n    }\\n    public String lookFor(Node node, char[] arr, int a){\\n        // System.out.println(Arrays.toString(arr)+\" \"+a);\\n        if(a>maxCnt){\\n            return null;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(node.nodes[i]!=null){\\n                char x=arr[a];\\n                arr[a]=(char)(i+\\'a\\');\\n                if(a==maxCnt-1){\\n                    return new String(arr);\\n                }\\n                String temp=lookFor(node.nodes[i], arr, a+1);\\n                arr[a]=x;\\n                if(temp!=null){\\n                    return temp;\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n    public void addToTrie(char[] arr, int i){\\n        for(int j=0;j<26;j++){\\n            if((j!=arr[i]-\\'a\\') && root.nodes[j]!=null){\\n                add(root.nodes[j], arr[i]);\\n            }\\n        }\\n        if(root.nodes[arr[i]-\\'a\\']==null){\\n            root.nodes[arr[i]-\\'a\\']=new Node();\\n        }\\n    }\\n    public void add(Node node, char a){\\n        if(node.nodes[a-\\'a\\']==null){\\n            node.nodes[a-\\'a\\']=new Node();           \\n        }\\n        for(int i=0;i<26;i++){\\n            if(i!=a-\\'a\\' && node.nodes[i]!=null){\\n                add(node.nodes[i], a);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "dont post code in discussion section"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "s = \"abacb\" output = \"abc\"\\n\\nif we\\'re using monotonous stack how to ensure we shouldn\\'t pop out b & a from stack when we encounter a at index2 during iteration. because my output is \"acb\" which is larger in lexicographical order compered to \"abc\""
                    },
                    {
                        "username": "sagar-1209",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int n = s.length();\\n        map<char,int> mp;\\n        string ans = \"\";\\n        stack<char> st;\\n        stack<char> temp;\\n        for(auto it : s) mp[it]++;\\n        for(int i=0;i<n;i++){\\n            if(mp[s[i]]==0) continue;\\n            if(st.empty() && mp[s[i]]==1) {ans+=s[i]; mp[s[i]]--; continue;}\\n            if(st.empty()){\\n                st.push(s[i]);\\n                mp[s[i]]--;\\n                continue;\\n            }\\n            while(!st.empty() && st.top() >= s[i]) {\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n            if(!st.empty() && mp[s[i]]==1){\\n                while(!st.empty()){\\n                    temp.push(st.top());\\n                    mp[st.top()] = 0;\\n                    st.pop();\\n                }\\n                while(!temp.empty()){\\n                    ans+= temp.top();\\n                    temp.pop();\\n                }\\n            }\\n            else{\\n                mp[s[i]]--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\nin this code 281 test case pass out of 290.\\ncan you help in this code to find solution "
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem is medium to hard. Can be easily solved using a stack. \\nHint:-\\nKeep on popping form stack if the top element is > incoming element and the last index of top element > current index of the element\\nelse add to stack and update the visited array to true.\\nThis should be done if the element has not been visited before. So, keep the track of it by maintaining a visited array."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I coded a complete different alternative greedy algorithm after reading the hint...\nmaybe someone likes this alternative or its easier to understand!:)\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "samorV",
                        "content": "Useless hint, inaccurate difficulty => big fat downvote"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i must admit the hint got me on a complete different track but this worked also!\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Everyone be like discussion section might have better explanation for Lexicographically Smaller  than google and it always works."
                    },
                    {
                        "username": "user0917sU",
                        "content": "I donot understand why it is considered question of monotonic stack, the characters in stack are not in increasing or decreasing order. \nEx: \nI/P: s =\"cbacdcbc\"\nO/P: \"acdb\"\n\nBy definition, monotonic stack should be \"abcd\" as per question. Remove that tag please"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i just see a stack also "
                    }
                ]
            },
            {
                "id": 2073435,
                "content": [
                    {
                        "username": "ajay_gc",
                        "content": "Somebody come up with a solution first and added test cases later and defined question as \"lexicographical order\". One of the most confusing question I have ever seen. "
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Intuition:\\n1. problems where subsequence of unique elements is needed to be created an array keeping track of last appearence is used\\n2. problems where an increasing / decreasing subseqence is needed to be found monotonic stack is used"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "In case somebody is thinking to solve using Trie, it gives Memory limit exceeded at 271th test case.\\n\\nBelow is my code:\\nclass Node{\\n    Node[] nodes=new Node[26];\\n}\\nclass Solution {\\n    Node root=new Node();\\n    int maxCnt=0;\\n    public String removeDuplicateLetters(String s) {\\n        char[] arr=s.toCharArray();\\n        boolean[] set=new boolean[26];\\n        for(int i=0;i<arr.length;i++){\\n            // System.out.println(arr[i]);\\n            if(set[arr[i]-\\'a\\']==false){\\n                maxCnt++;\\n            }\\n            set[arr[i]-\\'a\\']=true;\\n            addToTrie(arr, i);\\n        }\\n        return lookFor(root, new char[maxCnt], 0);\\n        // return \"\"+maxCnt;\\n    }\\n    public String lookFor(Node node, char[] arr, int a){\\n        // System.out.println(Arrays.toString(arr)+\" \"+a);\\n        if(a>maxCnt){\\n            return null;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(node.nodes[i]!=null){\\n                char x=arr[a];\\n                arr[a]=(char)(i+\\'a\\');\\n                if(a==maxCnt-1){\\n                    return new String(arr);\\n                }\\n                String temp=lookFor(node.nodes[i], arr, a+1);\\n                arr[a]=x;\\n                if(temp!=null){\\n                    return temp;\\n                }\\n            }\\n        }\\n        return null;\\n    }\\n    public void addToTrie(char[] arr, int i){\\n        for(int j=0;j<26;j++){\\n            if((j!=arr[i]-\\'a\\') && root.nodes[j]!=null){\\n                add(root.nodes[j], arr[i]);\\n            }\\n        }\\n        if(root.nodes[arr[i]-\\'a\\']==null){\\n            root.nodes[arr[i]-\\'a\\']=new Node();\\n        }\\n    }\\n    public void add(Node node, char a){\\n        if(node.nodes[a-\\'a\\']==null){\\n            node.nodes[a-\\'a\\']=new Node();           \\n        }\\n        for(int i=0;i<26;i++){\\n            if(i!=a-\\'a\\' && node.nodes[i]!=null){\\n                add(node.nodes[i], a);\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "dont post code in discussion section"
                    },
                    {
                        "username": "gary_gosh",
                        "content": "s = \"abacb\" output = \"abc\"\\n\\nif we\\'re using monotonous stack how to ensure we shouldn\\'t pop out b & a from stack when we encounter a at index2 during iteration. because my output is \"acb\" which is larger in lexicographical order compered to \"abc\""
                    },
                    {
                        "username": "sagar-1209",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        int n = s.length();\\n        map<char,int> mp;\\n        string ans = \"\";\\n        stack<char> st;\\n        stack<char> temp;\\n        for(auto it : s) mp[it]++;\\n        for(int i=0;i<n;i++){\\n            if(mp[s[i]]==0) continue;\\n            if(st.empty() && mp[s[i]]==1) {ans+=s[i]; mp[s[i]]--; continue;}\\n            if(st.empty()){\\n                st.push(s[i]);\\n                mp[s[i]]--;\\n                continue;\\n            }\\n            while(!st.empty() && st.top() >= s[i]) {\\n                st.pop();\\n            }\\n            st.push(s[i]);\\n            if(!st.empty() && mp[s[i]]==1){\\n                while(!st.empty()){\\n                    temp.push(st.top());\\n                    mp[st.top()] = 0;\\n                    st.pop();\\n                }\\n                while(!temp.empty()){\\n                    ans+= temp.top();\\n                    temp.pop();\\n                }\\n            }\\n            else{\\n                mp[s[i]]--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n\\nin this code 281 test case pass out of 290.\\ncan you help in this code to find solution "
                    },
                    {
                        "username": "Storm97Breaker",
                        "content": "The problem is medium to hard. Can be easily solved using a stack. \\nHint:-\\nKeep on popping form stack if the top element is > incoming element and the last index of top element > current index of the element\\nelse add to stack and update the visited array to true.\\nThis should be done if the element has not been visited before. So, keep the track of it by maintaining a visited array."
                    },
                    {
                        "username": "lucasscodes",
                        "content": "I coded a complete different alternative greedy algorithm after reading the hint...\nmaybe someone likes this alternative or its easier to understand!:)\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "samorV",
                        "content": "Useless hint, inaccurate difficulty => big fat downvote"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i must admit the hint got me on a complete different track but this worked also!\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SahilNikam",
                        "content": "Everyone be like discussion section might have better explanation for Lexicographically Smaller  than google and it always works."
                    },
                    {
                        "username": "user0917sU",
                        "content": "I donot understand why it is considered question of monotonic stack, the characters in stack are not in increasing or decreasing order. \nEx: \nI/P: s =\"cbacdcbc\"\nO/P: \"acdb\"\n\nBy definition, monotonic stack should be \"abcd\" as per question. Remove that tag please"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "i just see a stack also "
                    }
                ]
            },
            {
                "id": 2073364,
                "content": [
                    {
                        "username": "deanstirrat",
                        "content": "this one was hard. Hint didn\\'t help"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "can someone optimise my recursive code ??\\nit passed 270 testcases\\n\\nclass Solution {\\npublic:\\n    vector<string> v;\\n    void solve(int index , string s , string temp , unordered_map<char,int>&m){\\n        if(index==s.size()) {\\n            if(temp.size() == m.size()){\\n            v.push_back(temp);\\n        }\\n         return;\\n        }\\n        if(temp.size() == m.size()){\\n            v.push_back(temp);\\n            return;\\n        }\\n        char ch = s[index];\\n        if(m[ch] == 1){\\n            m[ch]--;\\n            solve(index+1 , s , temp+ch, m);\\n            m[ch]++;\\n        }\\n        solve(index+1,s,temp,m);\\n    }\\n    string removeDuplicateLetters(string s) {\\n        int index = 0 ;\\n        string temp = \"\";\\n        unordered_map<char,int>m;\\n        for(auto i: s){\\n            if(m.find(i) == m.end()){\\n                m[i]=1;\\n            }\\n        }\\n        solve(index,s,temp,m);\\n        sort(v.begin() , v.end());\\n        for(auto i : v) cout<<i<<\" \";\\n        return v[0];\\n    }\\n};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this is really tricky to implement without using any bullet-proof algorithm. Should be classified as hard"
                    },
                    {
                        "username": "shivam4128",
                        "content": "Well the question is trying to say smallest lexiographical order without changing the order of each character w.r.t other characters \\nexample : cbacdcbc \\noutput :acdb not abcd because frequency of d is 1 and if you include d you can\\'t change it\\'s order with respect to characters previous to it and characters next to it . so a,c come before d and b after d"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@EliteWiZard](/bharshit468) explain this example  \"ecbacba\" whenever we take e then i don\\'t know that e come again or not we delete e or not  explain it"
                    },
                    {
                        "username": "bharshit468",
                        "content": "bro Ask a question ---> ki kya \"e\" future mai milaiga nhi tho definate we have to considered it  "
                    },
                    {
                        "username": "morningstar1",
                        "content": "You want to remove all duplicate letters such that you get the \"smallest\" lexical order.\\n\\'e\\' has no duplicates, so you\\'ll definitely take that first \\'e\\'"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think it should be in hard category. Even I saw some solutions but i cannot understand what is going on there"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "mine is a complete alternative and far more easy to understand!:)\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SeineAle",
                        "content": "It\\'s habitual now\\nOne of the 2 examples is always useless and trash"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "* Careful its about subsequence . Think of the solution accordingly."
                    },
                    {
                        "username": "v1k45__",
                        "content": "This is Slitly complicated......\\nso try to use Map wisely"
                    },
                    {
                        "username": "KrisChill",
                        "content": "So if the input is \"dbbcccaadddef\" then the output would be \"bcadef\" ?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 2073318,
                "content": [
                    {
                        "username": "deanstirrat",
                        "content": "this one was hard. Hint didn\\'t help"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "can someone optimise my recursive code ??\\nit passed 270 testcases\\n\\nclass Solution {\\npublic:\\n    vector<string> v;\\n    void solve(int index , string s , string temp , unordered_map<char,int>&m){\\n        if(index==s.size()) {\\n            if(temp.size() == m.size()){\\n            v.push_back(temp);\\n        }\\n         return;\\n        }\\n        if(temp.size() == m.size()){\\n            v.push_back(temp);\\n            return;\\n        }\\n        char ch = s[index];\\n        if(m[ch] == 1){\\n            m[ch]--;\\n            solve(index+1 , s , temp+ch, m);\\n            m[ch]++;\\n        }\\n        solve(index+1,s,temp,m);\\n    }\\n    string removeDuplicateLetters(string s) {\\n        int index = 0 ;\\n        string temp = \"\";\\n        unordered_map<char,int>m;\\n        for(auto i: s){\\n            if(m.find(i) == m.end()){\\n                m[i]=1;\\n            }\\n        }\\n        solve(index,s,temp,m);\\n        sort(v.begin() , v.end());\\n        for(auto i : v) cout<<i<<\" \";\\n        return v[0];\\n    }\\n};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this is really tricky to implement without using any bullet-proof algorithm. Should be classified as hard"
                    },
                    {
                        "username": "shivam4128",
                        "content": "Well the question is trying to say smallest lexiographical order without changing the order of each character w.r.t other characters \\nexample : cbacdcbc \\noutput :acdb not abcd because frequency of d is 1 and if you include d you can\\'t change it\\'s order with respect to characters previous to it and characters next to it . so a,c come before d and b after d"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@EliteWiZard](/bharshit468) explain this example  \"ecbacba\" whenever we take e then i don\\'t know that e come again or not we delete e or not  explain it"
                    },
                    {
                        "username": "bharshit468",
                        "content": "bro Ask a question ---> ki kya \"e\" future mai milaiga nhi tho definate we have to considered it  "
                    },
                    {
                        "username": "morningstar1",
                        "content": "You want to remove all duplicate letters such that you get the \"smallest\" lexical order.\\n\\'e\\' has no duplicates, so you\\'ll definitely take that first \\'e\\'"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think it should be in hard category. Even I saw some solutions but i cannot understand what is going on there"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "mine is a complete alternative and far more easy to understand!:)\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SeineAle",
                        "content": "It\\'s habitual now\\nOne of the 2 examples is always useless and trash"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "* Careful its about subsequence . Think of the solution accordingly."
                    },
                    {
                        "username": "v1k45__",
                        "content": "This is Slitly complicated......\\nso try to use Map wisely"
                    },
                    {
                        "username": "KrisChill",
                        "content": "So if the input is \"dbbcccaadddef\" then the output would be \"bcadef\" ?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 2073274,
                "content": [
                    {
                        "username": "deanstirrat",
                        "content": "this one was hard. Hint didn\\'t help"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "can someone optimise my recursive code ??\\nit passed 270 testcases\\n\\nclass Solution {\\npublic:\\n    vector<string> v;\\n    void solve(int index , string s , string temp , unordered_map<char,int>&m){\\n        if(index==s.size()) {\\n            if(temp.size() == m.size()){\\n            v.push_back(temp);\\n        }\\n         return;\\n        }\\n        if(temp.size() == m.size()){\\n            v.push_back(temp);\\n            return;\\n        }\\n        char ch = s[index];\\n        if(m[ch] == 1){\\n            m[ch]--;\\n            solve(index+1 , s , temp+ch, m);\\n            m[ch]++;\\n        }\\n        solve(index+1,s,temp,m);\\n    }\\n    string removeDuplicateLetters(string s) {\\n        int index = 0 ;\\n        string temp = \"\";\\n        unordered_map<char,int>m;\\n        for(auto i: s){\\n            if(m.find(i) == m.end()){\\n                m[i]=1;\\n            }\\n        }\\n        solve(index,s,temp,m);\\n        sort(v.begin() , v.end());\\n        for(auto i : v) cout<<i<<\" \";\\n        return v[0];\\n    }\\n};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this is really tricky to implement without using any bullet-proof algorithm. Should be classified as hard"
                    },
                    {
                        "username": "shivam4128",
                        "content": "Well the question is trying to say smallest lexiographical order without changing the order of each character w.r.t other characters \\nexample : cbacdcbc \\noutput :acdb not abcd because frequency of d is 1 and if you include d you can\\'t change it\\'s order with respect to characters previous to it and characters next to it . so a,c come before d and b after d"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@EliteWiZard](/bharshit468) explain this example  \"ecbacba\" whenever we take e then i don\\'t know that e come again or not we delete e or not  explain it"
                    },
                    {
                        "username": "bharshit468",
                        "content": "bro Ask a question ---> ki kya \"e\" future mai milaiga nhi tho definate we have to considered it  "
                    },
                    {
                        "username": "morningstar1",
                        "content": "You want to remove all duplicate letters such that you get the \"smallest\" lexical order.\\n\\'e\\' has no duplicates, so you\\'ll definitely take that first \\'e\\'"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think it should be in hard category. Even I saw some solutions but i cannot understand what is going on there"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "mine is a complete alternative and far more easy to understand!:)\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SeineAle",
                        "content": "It\\'s habitual now\\nOne of the 2 examples is always useless and trash"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "* Careful its about subsequence . Think of the solution accordingly."
                    },
                    {
                        "username": "v1k45__",
                        "content": "This is Slitly complicated......\\nso try to use Map wisely"
                    },
                    {
                        "username": "KrisChill",
                        "content": "So if the input is \"dbbcccaadddef\" then the output would be \"bcadef\" ?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 2073264,
                "content": [
                    {
                        "username": "deanstirrat",
                        "content": "this one was hard. Hint didn\\'t help"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "can someone optimise my recursive code ??\\nit passed 270 testcases\\n\\nclass Solution {\\npublic:\\n    vector<string> v;\\n    void solve(int index , string s , string temp , unordered_map<char,int>&m){\\n        if(index==s.size()) {\\n            if(temp.size() == m.size()){\\n            v.push_back(temp);\\n        }\\n         return;\\n        }\\n        if(temp.size() == m.size()){\\n            v.push_back(temp);\\n            return;\\n        }\\n        char ch = s[index];\\n        if(m[ch] == 1){\\n            m[ch]--;\\n            solve(index+1 , s , temp+ch, m);\\n            m[ch]++;\\n        }\\n        solve(index+1,s,temp,m);\\n    }\\n    string removeDuplicateLetters(string s) {\\n        int index = 0 ;\\n        string temp = \"\";\\n        unordered_map<char,int>m;\\n        for(auto i: s){\\n            if(m.find(i) == m.end()){\\n                m[i]=1;\\n            }\\n        }\\n        solve(index,s,temp,m);\\n        sort(v.begin() , v.end());\\n        for(auto i : v) cout<<i<<\" \";\\n        return v[0];\\n    }\\n};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this is really tricky to implement without using any bullet-proof algorithm. Should be classified as hard"
                    },
                    {
                        "username": "shivam4128",
                        "content": "Well the question is trying to say smallest lexiographical order without changing the order of each character w.r.t other characters \\nexample : cbacdcbc \\noutput :acdb not abcd because frequency of d is 1 and if you include d you can\\'t change it\\'s order with respect to characters previous to it and characters next to it . so a,c come before d and b after d"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@EliteWiZard](/bharshit468) explain this example  \"ecbacba\" whenever we take e then i don\\'t know that e come again or not we delete e or not  explain it"
                    },
                    {
                        "username": "bharshit468",
                        "content": "bro Ask a question ---> ki kya \"e\" future mai milaiga nhi tho definate we have to considered it  "
                    },
                    {
                        "username": "morningstar1",
                        "content": "You want to remove all duplicate letters such that you get the \"smallest\" lexical order.\\n\\'e\\' has no duplicates, so you\\'ll definitely take that first \\'e\\'"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think it should be in hard category. Even I saw some solutions but i cannot understand what is going on there"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "mine is a complete alternative and far more easy to understand!:)\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SeineAle",
                        "content": "It\\'s habitual now\\nOne of the 2 examples is always useless and trash"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "* Careful its about subsequence . Think of the solution accordingly."
                    },
                    {
                        "username": "v1k45__",
                        "content": "This is Slitly complicated......\\nso try to use Map wisely"
                    },
                    {
                        "username": "KrisChill",
                        "content": "So if the input is \"dbbcccaadddef\" then the output would be \"bcadef\" ?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 2073252,
                "content": [
                    {
                        "username": "deanstirrat",
                        "content": "this one was hard. Hint didn\\'t help"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "can someone optimise my recursive code ??\\nit passed 270 testcases\\n\\nclass Solution {\\npublic:\\n    vector<string> v;\\n    void solve(int index , string s , string temp , unordered_map<char,int>&m){\\n        if(index==s.size()) {\\n            if(temp.size() == m.size()){\\n            v.push_back(temp);\\n        }\\n         return;\\n        }\\n        if(temp.size() == m.size()){\\n            v.push_back(temp);\\n            return;\\n        }\\n        char ch = s[index];\\n        if(m[ch] == 1){\\n            m[ch]--;\\n            solve(index+1 , s , temp+ch, m);\\n            m[ch]++;\\n        }\\n        solve(index+1,s,temp,m);\\n    }\\n    string removeDuplicateLetters(string s) {\\n        int index = 0 ;\\n        string temp = \"\";\\n        unordered_map<char,int>m;\\n        for(auto i: s){\\n            if(m.find(i) == m.end()){\\n                m[i]=1;\\n            }\\n        }\\n        solve(index,s,temp,m);\\n        sort(v.begin() , v.end());\\n        for(auto i : v) cout<<i<<\" \";\\n        return v[0];\\n    }\\n};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this is really tricky to implement without using any bullet-proof algorithm. Should be classified as hard"
                    },
                    {
                        "username": "shivam4128",
                        "content": "Well the question is trying to say smallest lexiographical order without changing the order of each character w.r.t other characters \\nexample : cbacdcbc \\noutput :acdb not abcd because frequency of d is 1 and if you include d you can\\'t change it\\'s order with respect to characters previous to it and characters next to it . so a,c come before d and b after d"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@EliteWiZard](/bharshit468) explain this example  \"ecbacba\" whenever we take e then i don\\'t know that e come again or not we delete e or not  explain it"
                    },
                    {
                        "username": "bharshit468",
                        "content": "bro Ask a question ---> ki kya \"e\" future mai milaiga nhi tho definate we have to considered it  "
                    },
                    {
                        "username": "morningstar1",
                        "content": "You want to remove all duplicate letters such that you get the \"smallest\" lexical order.\\n\\'e\\' has no duplicates, so you\\'ll definitely take that first \\'e\\'"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think it should be in hard category. Even I saw some solutions but i cannot understand what is going on there"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "mine is a complete alternative and far more easy to understand!:)\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SeineAle",
                        "content": "It\\'s habitual now\\nOne of the 2 examples is always useless and trash"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "* Careful its about subsequence . Think of the solution accordingly."
                    },
                    {
                        "username": "v1k45__",
                        "content": "This is Slitly complicated......\\nso try to use Map wisely"
                    },
                    {
                        "username": "KrisChill",
                        "content": "So if the input is \"dbbcccaadddef\" then the output would be \"bcadef\" ?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 2073166,
                "content": [
                    {
                        "username": "deanstirrat",
                        "content": "this one was hard. Hint didn\\'t help"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "can someone optimise my recursive code ??\\nit passed 270 testcases\\n\\nclass Solution {\\npublic:\\n    vector<string> v;\\n    void solve(int index , string s , string temp , unordered_map<char,int>&m){\\n        if(index==s.size()) {\\n            if(temp.size() == m.size()){\\n            v.push_back(temp);\\n        }\\n         return;\\n        }\\n        if(temp.size() == m.size()){\\n            v.push_back(temp);\\n            return;\\n        }\\n        char ch = s[index];\\n        if(m[ch] == 1){\\n            m[ch]--;\\n            solve(index+1 , s , temp+ch, m);\\n            m[ch]++;\\n        }\\n        solve(index+1,s,temp,m);\\n    }\\n    string removeDuplicateLetters(string s) {\\n        int index = 0 ;\\n        string temp = \"\";\\n        unordered_map<char,int>m;\\n        for(auto i: s){\\n            if(m.find(i) == m.end()){\\n                m[i]=1;\\n            }\\n        }\\n        solve(index,s,temp,m);\\n        sort(v.begin() , v.end());\\n        for(auto i : v) cout<<i<<\" \";\\n        return v[0];\\n    }\\n};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this is really tricky to implement without using any bullet-proof algorithm. Should be classified as hard"
                    },
                    {
                        "username": "shivam4128",
                        "content": "Well the question is trying to say smallest lexiographical order without changing the order of each character w.r.t other characters \\nexample : cbacdcbc \\noutput :acdb not abcd because frequency of d is 1 and if you include d you can\\'t change it\\'s order with respect to characters previous to it and characters next to it . so a,c come before d and b after d"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@EliteWiZard](/bharshit468) explain this example  \"ecbacba\" whenever we take e then i don\\'t know that e come again or not we delete e or not  explain it"
                    },
                    {
                        "username": "bharshit468",
                        "content": "bro Ask a question ---> ki kya \"e\" future mai milaiga nhi tho definate we have to considered it  "
                    },
                    {
                        "username": "morningstar1",
                        "content": "You want to remove all duplicate letters such that you get the \"smallest\" lexical order.\\n\\'e\\' has no duplicates, so you\\'ll definitely take that first \\'e\\'"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think it should be in hard category. Even I saw some solutions but i cannot understand what is going on there"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "mine is a complete alternative and far more easy to understand!:)\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SeineAle",
                        "content": "It\\'s habitual now\\nOne of the 2 examples is always useless and trash"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "* Careful its about subsequence . Think of the solution accordingly."
                    },
                    {
                        "username": "v1k45__",
                        "content": "This is Slitly complicated......\\nso try to use Map wisely"
                    },
                    {
                        "username": "KrisChill",
                        "content": "So if the input is \"dbbcccaadddef\" then the output would be \"bcadef\" ?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 2073128,
                "content": [
                    {
                        "username": "deanstirrat",
                        "content": "this one was hard. Hint didn\\'t help"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "can someone optimise my recursive code ??\\nit passed 270 testcases\\n\\nclass Solution {\\npublic:\\n    vector<string> v;\\n    void solve(int index , string s , string temp , unordered_map<char,int>&m){\\n        if(index==s.size()) {\\n            if(temp.size() == m.size()){\\n            v.push_back(temp);\\n        }\\n         return;\\n        }\\n        if(temp.size() == m.size()){\\n            v.push_back(temp);\\n            return;\\n        }\\n        char ch = s[index];\\n        if(m[ch] == 1){\\n            m[ch]--;\\n            solve(index+1 , s , temp+ch, m);\\n            m[ch]++;\\n        }\\n        solve(index+1,s,temp,m);\\n    }\\n    string removeDuplicateLetters(string s) {\\n        int index = 0 ;\\n        string temp = \"\";\\n        unordered_map<char,int>m;\\n        for(auto i: s){\\n            if(m.find(i) == m.end()){\\n                m[i]=1;\\n            }\\n        }\\n        solve(index,s,temp,m);\\n        sort(v.begin() , v.end());\\n        for(auto i : v) cout<<i<<\" \";\\n        return v[0];\\n    }\\n};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this is really tricky to implement without using any bullet-proof algorithm. Should be classified as hard"
                    },
                    {
                        "username": "shivam4128",
                        "content": "Well the question is trying to say smallest lexiographical order without changing the order of each character w.r.t other characters \\nexample : cbacdcbc \\noutput :acdb not abcd because frequency of d is 1 and if you include d you can\\'t change it\\'s order with respect to characters previous to it and characters next to it . so a,c come before d and b after d"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@EliteWiZard](/bharshit468) explain this example  \"ecbacba\" whenever we take e then i don\\'t know that e come again or not we delete e or not  explain it"
                    },
                    {
                        "username": "bharshit468",
                        "content": "bro Ask a question ---> ki kya \"e\" future mai milaiga nhi tho definate we have to considered it  "
                    },
                    {
                        "username": "morningstar1",
                        "content": "You want to remove all duplicate letters such that you get the \"smallest\" lexical order.\\n\\'e\\' has no duplicates, so you\\'ll definitely take that first \\'e\\'"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think it should be in hard category. Even I saw some solutions but i cannot understand what is going on there"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "mine is a complete alternative and far more easy to understand!:)\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SeineAle",
                        "content": "It\\'s habitual now\\nOne of the 2 examples is always useless and trash"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "* Careful its about subsequence . Think of the solution accordingly."
                    },
                    {
                        "username": "v1k45__",
                        "content": "This is Slitly complicated......\\nso try to use Map wisely"
                    },
                    {
                        "username": "KrisChill",
                        "content": "So if the input is \"dbbcccaadddef\" then the output would be \"bcadef\" ?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 2073093,
                "content": [
                    {
                        "username": "deanstirrat",
                        "content": "this one was hard. Hint didn\\'t help"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "can someone optimise my recursive code ??\\nit passed 270 testcases\\n\\nclass Solution {\\npublic:\\n    vector<string> v;\\n    void solve(int index , string s , string temp , unordered_map<char,int>&m){\\n        if(index==s.size()) {\\n            if(temp.size() == m.size()){\\n            v.push_back(temp);\\n        }\\n         return;\\n        }\\n        if(temp.size() == m.size()){\\n            v.push_back(temp);\\n            return;\\n        }\\n        char ch = s[index];\\n        if(m[ch] == 1){\\n            m[ch]--;\\n            solve(index+1 , s , temp+ch, m);\\n            m[ch]++;\\n        }\\n        solve(index+1,s,temp,m);\\n    }\\n    string removeDuplicateLetters(string s) {\\n        int index = 0 ;\\n        string temp = \"\";\\n        unordered_map<char,int>m;\\n        for(auto i: s){\\n            if(m.find(i) == m.end()){\\n                m[i]=1;\\n            }\\n        }\\n        solve(index,s,temp,m);\\n        sort(v.begin() , v.end());\\n        for(auto i : v) cout<<i<<\" \";\\n        return v[0];\\n    }\\n};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this is really tricky to implement without using any bullet-proof algorithm. Should be classified as hard"
                    },
                    {
                        "username": "shivam4128",
                        "content": "Well the question is trying to say smallest lexiographical order without changing the order of each character w.r.t other characters \\nexample : cbacdcbc \\noutput :acdb not abcd because frequency of d is 1 and if you include d you can\\'t change it\\'s order with respect to characters previous to it and characters next to it . so a,c come before d and b after d"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@EliteWiZard](/bharshit468) explain this example  \"ecbacba\" whenever we take e then i don\\'t know that e come again or not we delete e or not  explain it"
                    },
                    {
                        "username": "bharshit468",
                        "content": "bro Ask a question ---> ki kya \"e\" future mai milaiga nhi tho definate we have to considered it  "
                    },
                    {
                        "username": "morningstar1",
                        "content": "You want to remove all duplicate letters such that you get the \"smallest\" lexical order.\\n\\'e\\' has no duplicates, so you\\'ll definitely take that first \\'e\\'"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think it should be in hard category. Even I saw some solutions but i cannot understand what is going on there"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "mine is a complete alternative and far more easy to understand!:)\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SeineAle",
                        "content": "It\\'s habitual now\\nOne of the 2 examples is always useless and trash"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "* Careful its about subsequence . Think of the solution accordingly."
                    },
                    {
                        "username": "v1k45__",
                        "content": "This is Slitly complicated......\\nso try to use Map wisely"
                    },
                    {
                        "username": "KrisChill",
                        "content": "So if the input is \"dbbcccaadddef\" then the output would be \"bcadef\" ?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 2073012,
                "content": [
                    {
                        "username": "deanstirrat",
                        "content": "this one was hard. Hint didn\\'t help"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "can someone optimise my recursive code ??\\nit passed 270 testcases\\n\\nclass Solution {\\npublic:\\n    vector<string> v;\\n    void solve(int index , string s , string temp , unordered_map<char,int>&m){\\n        if(index==s.size()) {\\n            if(temp.size() == m.size()){\\n            v.push_back(temp);\\n        }\\n         return;\\n        }\\n        if(temp.size() == m.size()){\\n            v.push_back(temp);\\n            return;\\n        }\\n        char ch = s[index];\\n        if(m[ch] == 1){\\n            m[ch]--;\\n            solve(index+1 , s , temp+ch, m);\\n            m[ch]++;\\n        }\\n        solve(index+1,s,temp,m);\\n    }\\n    string removeDuplicateLetters(string s) {\\n        int index = 0 ;\\n        string temp = \"\";\\n        unordered_map<char,int>m;\\n        for(auto i: s){\\n            if(m.find(i) == m.end()){\\n                m[i]=1;\\n            }\\n        }\\n        solve(index,s,temp,m);\\n        sort(v.begin() , v.end());\\n        for(auto i : v) cout<<i<<\" \";\\n        return v[0];\\n    }\\n};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this is really tricky to implement without using any bullet-proof algorithm. Should be classified as hard"
                    },
                    {
                        "username": "shivam4128",
                        "content": "Well the question is trying to say smallest lexiographical order without changing the order of each character w.r.t other characters \\nexample : cbacdcbc \\noutput :acdb not abcd because frequency of d is 1 and if you include d you can\\'t change it\\'s order with respect to characters previous to it and characters next to it . so a,c come before d and b after d"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@EliteWiZard](/bharshit468) explain this example  \"ecbacba\" whenever we take e then i don\\'t know that e come again or not we delete e or not  explain it"
                    },
                    {
                        "username": "bharshit468",
                        "content": "bro Ask a question ---> ki kya \"e\" future mai milaiga nhi tho definate we have to considered it  "
                    },
                    {
                        "username": "morningstar1",
                        "content": "You want to remove all duplicate letters such that you get the \"smallest\" lexical order.\\n\\'e\\' has no duplicates, so you\\'ll definitely take that first \\'e\\'"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think it should be in hard category. Even I saw some solutions but i cannot understand what is going on there"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "mine is a complete alternative and far more easy to understand!:)\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SeineAle",
                        "content": "It\\'s habitual now\\nOne of the 2 examples is always useless and trash"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "* Careful its about subsequence . Think of the solution accordingly."
                    },
                    {
                        "username": "v1k45__",
                        "content": "This is Slitly complicated......\\nso try to use Map wisely"
                    },
                    {
                        "username": "KrisChill",
                        "content": "So if the input is \"dbbcccaadddef\" then the output would be \"bcadef\" ?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 2072964,
                "content": [
                    {
                        "username": "deanstirrat",
                        "content": "this one was hard. Hint didn\\'t help"
                    },
                    {
                        "username": "dheerajx999",
                        "content": "can someone optimise my recursive code ??\\nit passed 270 testcases\\n\\nclass Solution {\\npublic:\\n    vector<string> v;\\n    void solve(int index , string s , string temp , unordered_map<char,int>&m){\\n        if(index==s.size()) {\\n            if(temp.size() == m.size()){\\n            v.push_back(temp);\\n        }\\n         return;\\n        }\\n        if(temp.size() == m.size()){\\n            v.push_back(temp);\\n            return;\\n        }\\n        char ch = s[index];\\n        if(m[ch] == 1){\\n            m[ch]--;\\n            solve(index+1 , s , temp+ch, m);\\n            m[ch]++;\\n        }\\n        solve(index+1,s,temp,m);\\n    }\\n    string removeDuplicateLetters(string s) {\\n        int index = 0 ;\\n        string temp = \"\";\\n        unordered_map<char,int>m;\\n        for(auto i: s){\\n            if(m.find(i) == m.end()){\\n                m[i]=1;\\n            }\\n        }\\n        solve(index,s,temp,m);\\n        sort(v.begin() , v.end());\\n        for(auto i : v) cout<<i<<\" \";\\n        return v[0];\\n    }\\n};"
                    },
                    {
                        "username": "danielmascena",
                        "content": "this is really tricky to implement without using any bullet-proof algorithm. Should be classified as hard"
                    },
                    {
                        "username": "shivam4128",
                        "content": "Well the question is trying to say smallest lexiographical order without changing the order of each character w.r.t other characters \\nexample : cbacdcbc \\noutput :acdb not abcd because frequency of d is 1 and if you include d you can\\'t change it\\'s order with respect to characters previous to it and characters next to it . so a,c come before d and b after d"
                    },
                    {
                        "username": "kranjeet0829",
                        "content": " [@EliteWiZard](/bharshit468) explain this example  \"ecbacba\" whenever we take e then i don\\'t know that e come again or not we delete e or not  explain it"
                    },
                    {
                        "username": "bharshit468",
                        "content": "bro Ask a question ---> ki kya \"e\" future mai milaiga nhi tho definate we have to considered it  "
                    },
                    {
                        "username": "morningstar1",
                        "content": "You want to remove all duplicate letters such that you get the \"smallest\" lexical order.\\n\\'e\\' has no duplicates, so you\\'ll definitely take that first \\'e\\'"
                    },
                    {
                        "username": "Asadbek525",
                        "content": "I think it should be in hard category. Even I saw some solutions but i cannot understand what is going on there"
                    },
                    {
                        "username": "lucasscodes",
                        "content": "mine is a complete alternative and far more easy to understand!:)\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4094072/hashing-binarysearch-alternative-well-commented/"
                    },
                    {
                        "username": "SeineAle",
                        "content": "It\\'s habitual now\\nOne of the 2 examples is always useless and trash"
                    },
                    {
                        "username": "ashishsaini772",
                        "content": "* Careful its about subsequence . Think of the solution accordingly."
                    },
                    {
                        "username": "v1k45__",
                        "content": "This is Slitly complicated......\\nso try to use Map wisely"
                    },
                    {
                        "username": "KrisChill",
                        "content": "So if the input is \"dbbcccaadddef\" then the output would be \"bcadef\" ?"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "yes"
                    }
                ]
            },
            {
                "id": 2072947,
                "content": [
                    {
                        "username": "davidashish1996",
                        "content": "I think the problem is wrongly quoted , i am experiencing wrong outputs for the 2 test cases.\\n\\n1.)  s= \"cbacdcbc\"\\n      o/p = \"acdb\"\\n2.)  s = \"bbcaac\"\\n     o/p=\"bac\"\\nIn the first one if we are following traditional approach that if any duplicate characters are coming then we are removing the last duplicate one then it\\'s not applicable in the first example for second one it\\'s working."
                    },
                    {
                        "username": "user5400vw",
                        "content": "in case you\\'re thinking of going knapsack, don\\'t.  it will end in a fiery ball of death."
                    },
                    {
                        "username": "santanusen",
                        "content": "Remember the position of the last occurrence of a letter.\\nIf selecting a letter from the current position causes a problem, discard it if it appears again at a later position (i.e. the position of last occurrence of the letter is yet to come) and, thus, can be chosen again."
                    },
                    {
                        "username": "Neeraj27",
                        "content": "solved it in various ways but these testcases \\nWhat order is it following (what way to do)\\nHere sorted output not required \\ns =\\n\"cbacdcbc\"\\nOutput\\n\"cbad\"\\nExpected\\n\"acdb\"\\n\\nHere sorted output required\\ns =\\n\"bcabc\"\\nOutput\\n\"bca\"\\nExpected\\n\"abc\"\\n"
                    },
                    {
                        "username": "neergx",
                        "content": "the output must be a subsequence of the given string and lexicographically smallest"
                    },
                    {
                        "username": "Verma_03",
                        "content": "Question needs to be more Explanatory....missing something\\nMiss some good test cases....:\")"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Those who are having confusion about \"the smallest in lexicographical order\", let me show you an example. \\nIn the first example, input : \"bcabc\"\\nso the output might be \"bca\", \"cab\",\"abc\" and \"bac\". They want you to remove the duplicates and not reaarange the characters. So out of these, the \"the smallest in lexicographical order\" ans will be \"abc\"."
                    },
                    {
                        "username": "PratikB17",
                        "content": "Can someone please explain what is lexicographic order means?"
                    },
                    {
                        "username": "neergx",
                        "content": "lexicographic means the order in which the given string occurs in dictionary"
                    },
                    {
                        "username": "aitachii",
                        "content": "The hint made it more confusing for me. How would you implement bitmasks here?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I use bitmask to solve it, it is a challange for details."
                    },
                    {
                        "username": "lolloo",
                        "content": " lexicographical order is hard to understand\\nThe question should just say it is the same order as the \"Sort by Name\" or \"Order by Name\" in a computer file system."
                    }
                ]
            },
            {
                "id": 2072862,
                "content": [
                    {
                        "username": "davidashish1996",
                        "content": "I think the problem is wrongly quoted , i am experiencing wrong outputs for the 2 test cases.\\n\\n1.)  s= \"cbacdcbc\"\\n      o/p = \"acdb\"\\n2.)  s = \"bbcaac\"\\n     o/p=\"bac\"\\nIn the first one if we are following traditional approach that if any duplicate characters are coming then we are removing the last duplicate one then it\\'s not applicable in the first example for second one it\\'s working."
                    },
                    {
                        "username": "user5400vw",
                        "content": "in case you\\'re thinking of going knapsack, don\\'t.  it will end in a fiery ball of death."
                    },
                    {
                        "username": "santanusen",
                        "content": "Remember the position of the last occurrence of a letter.\\nIf selecting a letter from the current position causes a problem, discard it if it appears again at a later position (i.e. the position of last occurrence of the letter is yet to come) and, thus, can be chosen again."
                    },
                    {
                        "username": "Neeraj27",
                        "content": "solved it in various ways but these testcases \\nWhat order is it following (what way to do)\\nHere sorted output not required \\ns =\\n\"cbacdcbc\"\\nOutput\\n\"cbad\"\\nExpected\\n\"acdb\"\\n\\nHere sorted output required\\ns =\\n\"bcabc\"\\nOutput\\n\"bca\"\\nExpected\\n\"abc\"\\n"
                    },
                    {
                        "username": "neergx",
                        "content": "the output must be a subsequence of the given string and lexicographically smallest"
                    },
                    {
                        "username": "Verma_03",
                        "content": "Question needs to be more Explanatory....missing something\\nMiss some good test cases....:\")"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Those who are having confusion about \"the smallest in lexicographical order\", let me show you an example. \\nIn the first example, input : \"bcabc\"\\nso the output might be \"bca\", \"cab\",\"abc\" and \"bac\". They want you to remove the duplicates and not reaarange the characters. So out of these, the \"the smallest in lexicographical order\" ans will be \"abc\"."
                    },
                    {
                        "username": "PratikB17",
                        "content": "Can someone please explain what is lexicographic order means?"
                    },
                    {
                        "username": "neergx",
                        "content": "lexicographic means the order in which the given string occurs in dictionary"
                    },
                    {
                        "username": "aitachii",
                        "content": "The hint made it more confusing for me. How would you implement bitmasks here?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I use bitmask to solve it, it is a challange for details."
                    },
                    {
                        "username": "lolloo",
                        "content": " lexicographical order is hard to understand\\nThe question should just say it is the same order as the \"Sort by Name\" or \"Order by Name\" in a computer file system."
                    }
                ]
            },
            {
                "id": 2072783,
                "content": [
                    {
                        "username": "davidashish1996",
                        "content": "I think the problem is wrongly quoted , i am experiencing wrong outputs for the 2 test cases.\\n\\n1.)  s= \"cbacdcbc\"\\n      o/p = \"acdb\"\\n2.)  s = \"bbcaac\"\\n     o/p=\"bac\"\\nIn the first one if we are following traditional approach that if any duplicate characters are coming then we are removing the last duplicate one then it\\'s not applicable in the first example for second one it\\'s working."
                    },
                    {
                        "username": "user5400vw",
                        "content": "in case you\\'re thinking of going knapsack, don\\'t.  it will end in a fiery ball of death."
                    },
                    {
                        "username": "santanusen",
                        "content": "Remember the position of the last occurrence of a letter.\\nIf selecting a letter from the current position causes a problem, discard it if it appears again at a later position (i.e. the position of last occurrence of the letter is yet to come) and, thus, can be chosen again."
                    },
                    {
                        "username": "Neeraj27",
                        "content": "solved it in various ways but these testcases \\nWhat order is it following (what way to do)\\nHere sorted output not required \\ns =\\n\"cbacdcbc\"\\nOutput\\n\"cbad\"\\nExpected\\n\"acdb\"\\n\\nHere sorted output required\\ns =\\n\"bcabc\"\\nOutput\\n\"bca\"\\nExpected\\n\"abc\"\\n"
                    },
                    {
                        "username": "neergx",
                        "content": "the output must be a subsequence of the given string and lexicographically smallest"
                    },
                    {
                        "username": "Verma_03",
                        "content": "Question needs to be more Explanatory....missing something\\nMiss some good test cases....:\")"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Those who are having confusion about \"the smallest in lexicographical order\", let me show you an example. \\nIn the first example, input : \"bcabc\"\\nso the output might be \"bca\", \"cab\",\"abc\" and \"bac\". They want you to remove the duplicates and not reaarange the characters. So out of these, the \"the smallest in lexicographical order\" ans will be \"abc\"."
                    },
                    {
                        "username": "PratikB17",
                        "content": "Can someone please explain what is lexicographic order means?"
                    },
                    {
                        "username": "neergx",
                        "content": "lexicographic means the order in which the given string occurs in dictionary"
                    },
                    {
                        "username": "aitachii",
                        "content": "The hint made it more confusing for me. How would you implement bitmasks here?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I use bitmask to solve it, it is a challange for details."
                    },
                    {
                        "username": "lolloo",
                        "content": " lexicographical order is hard to understand\\nThe question should just say it is the same order as the \"Sort by Name\" or \"Order by Name\" in a computer file system."
                    }
                ]
            },
            {
                "id": 2072778,
                "content": [
                    {
                        "username": "davidashish1996",
                        "content": "I think the problem is wrongly quoted , i am experiencing wrong outputs for the 2 test cases.\\n\\n1.)  s= \"cbacdcbc\"\\n      o/p = \"acdb\"\\n2.)  s = \"bbcaac\"\\n     o/p=\"bac\"\\nIn the first one if we are following traditional approach that if any duplicate characters are coming then we are removing the last duplicate one then it\\'s not applicable in the first example for second one it\\'s working."
                    },
                    {
                        "username": "user5400vw",
                        "content": "in case you\\'re thinking of going knapsack, don\\'t.  it will end in a fiery ball of death."
                    },
                    {
                        "username": "santanusen",
                        "content": "Remember the position of the last occurrence of a letter.\\nIf selecting a letter from the current position causes a problem, discard it if it appears again at a later position (i.e. the position of last occurrence of the letter is yet to come) and, thus, can be chosen again."
                    },
                    {
                        "username": "Neeraj27",
                        "content": "solved it in various ways but these testcases \\nWhat order is it following (what way to do)\\nHere sorted output not required \\ns =\\n\"cbacdcbc\"\\nOutput\\n\"cbad\"\\nExpected\\n\"acdb\"\\n\\nHere sorted output required\\ns =\\n\"bcabc\"\\nOutput\\n\"bca\"\\nExpected\\n\"abc\"\\n"
                    },
                    {
                        "username": "neergx",
                        "content": "the output must be a subsequence of the given string and lexicographically smallest"
                    },
                    {
                        "username": "Verma_03",
                        "content": "Question needs to be more Explanatory....missing something\\nMiss some good test cases....:\")"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Those who are having confusion about \"the smallest in lexicographical order\", let me show you an example. \\nIn the first example, input : \"bcabc\"\\nso the output might be \"bca\", \"cab\",\"abc\" and \"bac\". They want you to remove the duplicates and not reaarange the characters. So out of these, the \"the smallest in lexicographical order\" ans will be \"abc\"."
                    },
                    {
                        "username": "PratikB17",
                        "content": "Can someone please explain what is lexicographic order means?"
                    },
                    {
                        "username": "neergx",
                        "content": "lexicographic means the order in which the given string occurs in dictionary"
                    },
                    {
                        "username": "aitachii",
                        "content": "The hint made it more confusing for me. How would you implement bitmasks here?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I use bitmask to solve it, it is a challange for details."
                    },
                    {
                        "username": "lolloo",
                        "content": " lexicographical order is hard to understand\\nThe question should just say it is the same order as the \"Sort by Name\" or \"Order by Name\" in a computer file system."
                    }
                ]
            },
            {
                "id": 2072690,
                "content": [
                    {
                        "username": "davidashish1996",
                        "content": "I think the problem is wrongly quoted , i am experiencing wrong outputs for the 2 test cases.\\n\\n1.)  s= \"cbacdcbc\"\\n      o/p = \"acdb\"\\n2.)  s = \"bbcaac\"\\n     o/p=\"bac\"\\nIn the first one if we are following traditional approach that if any duplicate characters are coming then we are removing the last duplicate one then it\\'s not applicable in the first example for second one it\\'s working."
                    },
                    {
                        "username": "user5400vw",
                        "content": "in case you\\'re thinking of going knapsack, don\\'t.  it will end in a fiery ball of death."
                    },
                    {
                        "username": "santanusen",
                        "content": "Remember the position of the last occurrence of a letter.\\nIf selecting a letter from the current position causes a problem, discard it if it appears again at a later position (i.e. the position of last occurrence of the letter is yet to come) and, thus, can be chosen again."
                    },
                    {
                        "username": "Neeraj27",
                        "content": "solved it in various ways but these testcases \\nWhat order is it following (what way to do)\\nHere sorted output not required \\ns =\\n\"cbacdcbc\"\\nOutput\\n\"cbad\"\\nExpected\\n\"acdb\"\\n\\nHere sorted output required\\ns =\\n\"bcabc\"\\nOutput\\n\"bca\"\\nExpected\\n\"abc\"\\n"
                    },
                    {
                        "username": "neergx",
                        "content": "the output must be a subsequence of the given string and lexicographically smallest"
                    },
                    {
                        "username": "Verma_03",
                        "content": "Question needs to be more Explanatory....missing something\\nMiss some good test cases....:\")"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Those who are having confusion about \"the smallest in lexicographical order\", let me show you an example. \\nIn the first example, input : \"bcabc\"\\nso the output might be \"bca\", \"cab\",\"abc\" and \"bac\". They want you to remove the duplicates and not reaarange the characters. So out of these, the \"the smallest in lexicographical order\" ans will be \"abc\"."
                    },
                    {
                        "username": "PratikB17",
                        "content": "Can someone please explain what is lexicographic order means?"
                    },
                    {
                        "username": "neergx",
                        "content": "lexicographic means the order in which the given string occurs in dictionary"
                    },
                    {
                        "username": "aitachii",
                        "content": "The hint made it more confusing for me. How would you implement bitmasks here?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I use bitmask to solve it, it is a challange for details."
                    },
                    {
                        "username": "lolloo",
                        "content": " lexicographical order is hard to understand\\nThe question should just say it is the same order as the \"Sort by Name\" or \"Order by Name\" in a computer file system."
                    }
                ]
            },
            {
                "id": 2072684,
                "content": [
                    {
                        "username": "davidashish1996",
                        "content": "I think the problem is wrongly quoted , i am experiencing wrong outputs for the 2 test cases.\\n\\n1.)  s= \"cbacdcbc\"\\n      o/p = \"acdb\"\\n2.)  s = \"bbcaac\"\\n     o/p=\"bac\"\\nIn the first one if we are following traditional approach that if any duplicate characters are coming then we are removing the last duplicate one then it\\'s not applicable in the first example for second one it\\'s working."
                    },
                    {
                        "username": "user5400vw",
                        "content": "in case you\\'re thinking of going knapsack, don\\'t.  it will end in a fiery ball of death."
                    },
                    {
                        "username": "santanusen",
                        "content": "Remember the position of the last occurrence of a letter.\\nIf selecting a letter from the current position causes a problem, discard it if it appears again at a later position (i.e. the position of last occurrence of the letter is yet to come) and, thus, can be chosen again."
                    },
                    {
                        "username": "Neeraj27",
                        "content": "solved it in various ways but these testcases \\nWhat order is it following (what way to do)\\nHere sorted output not required \\ns =\\n\"cbacdcbc\"\\nOutput\\n\"cbad\"\\nExpected\\n\"acdb\"\\n\\nHere sorted output required\\ns =\\n\"bcabc\"\\nOutput\\n\"bca\"\\nExpected\\n\"abc\"\\n"
                    },
                    {
                        "username": "neergx",
                        "content": "the output must be a subsequence of the given string and lexicographically smallest"
                    },
                    {
                        "username": "Verma_03",
                        "content": "Question needs to be more Explanatory....missing something\\nMiss some good test cases....:\")"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Those who are having confusion about \"the smallest in lexicographical order\", let me show you an example. \\nIn the first example, input : \"bcabc\"\\nso the output might be \"bca\", \"cab\",\"abc\" and \"bac\". They want you to remove the duplicates and not reaarange the characters. So out of these, the \"the smallest in lexicographical order\" ans will be \"abc\"."
                    },
                    {
                        "username": "PratikB17",
                        "content": "Can someone please explain what is lexicographic order means?"
                    },
                    {
                        "username": "neergx",
                        "content": "lexicographic means the order in which the given string occurs in dictionary"
                    },
                    {
                        "username": "aitachii",
                        "content": "The hint made it more confusing for me. How would you implement bitmasks here?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I use bitmask to solve it, it is a challange for details."
                    },
                    {
                        "username": "lolloo",
                        "content": " lexicographical order is hard to understand\\nThe question should just say it is the same order as the \"Sort by Name\" or \"Order by Name\" in a computer file system."
                    }
                ]
            },
            {
                "id": 2072667,
                "content": [
                    {
                        "username": "davidashish1996",
                        "content": "I think the problem is wrongly quoted , i am experiencing wrong outputs for the 2 test cases.\\n\\n1.)  s= \"cbacdcbc\"\\n      o/p = \"acdb\"\\n2.)  s = \"bbcaac\"\\n     o/p=\"bac\"\\nIn the first one if we are following traditional approach that if any duplicate characters are coming then we are removing the last duplicate one then it\\'s not applicable in the first example for second one it\\'s working."
                    },
                    {
                        "username": "user5400vw",
                        "content": "in case you\\'re thinking of going knapsack, don\\'t.  it will end in a fiery ball of death."
                    },
                    {
                        "username": "santanusen",
                        "content": "Remember the position of the last occurrence of a letter.\\nIf selecting a letter from the current position causes a problem, discard it if it appears again at a later position (i.e. the position of last occurrence of the letter is yet to come) and, thus, can be chosen again."
                    },
                    {
                        "username": "Neeraj27",
                        "content": "solved it in various ways but these testcases \\nWhat order is it following (what way to do)\\nHere sorted output not required \\ns =\\n\"cbacdcbc\"\\nOutput\\n\"cbad\"\\nExpected\\n\"acdb\"\\n\\nHere sorted output required\\ns =\\n\"bcabc\"\\nOutput\\n\"bca\"\\nExpected\\n\"abc\"\\n"
                    },
                    {
                        "username": "neergx",
                        "content": "the output must be a subsequence of the given string and lexicographically smallest"
                    },
                    {
                        "username": "Verma_03",
                        "content": "Question needs to be more Explanatory....missing something\\nMiss some good test cases....:\")"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Those who are having confusion about \"the smallest in lexicographical order\", let me show you an example. \\nIn the first example, input : \"bcabc\"\\nso the output might be \"bca\", \"cab\",\"abc\" and \"bac\". They want you to remove the duplicates and not reaarange the characters. So out of these, the \"the smallest in lexicographical order\" ans will be \"abc\"."
                    },
                    {
                        "username": "PratikB17",
                        "content": "Can someone please explain what is lexicographic order means?"
                    },
                    {
                        "username": "neergx",
                        "content": "lexicographic means the order in which the given string occurs in dictionary"
                    },
                    {
                        "username": "aitachii",
                        "content": "The hint made it more confusing for me. How would you implement bitmasks here?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I use bitmask to solve it, it is a challange for details."
                    },
                    {
                        "username": "lolloo",
                        "content": " lexicographical order is hard to understand\\nThe question should just say it is the same order as the \"Sort by Name\" or \"Order by Name\" in a computer file system."
                    }
                ]
            },
            {
                "id": 2072636,
                "content": [
                    {
                        "username": "davidashish1996",
                        "content": "I think the problem is wrongly quoted , i am experiencing wrong outputs for the 2 test cases.\\n\\n1.)  s= \"cbacdcbc\"\\n      o/p = \"acdb\"\\n2.)  s = \"bbcaac\"\\n     o/p=\"bac\"\\nIn the first one if we are following traditional approach that if any duplicate characters are coming then we are removing the last duplicate one then it\\'s not applicable in the first example for second one it\\'s working."
                    },
                    {
                        "username": "user5400vw",
                        "content": "in case you\\'re thinking of going knapsack, don\\'t.  it will end in a fiery ball of death."
                    },
                    {
                        "username": "santanusen",
                        "content": "Remember the position of the last occurrence of a letter.\\nIf selecting a letter from the current position causes a problem, discard it if it appears again at a later position (i.e. the position of last occurrence of the letter is yet to come) and, thus, can be chosen again."
                    },
                    {
                        "username": "Neeraj27",
                        "content": "solved it in various ways but these testcases \\nWhat order is it following (what way to do)\\nHere sorted output not required \\ns =\\n\"cbacdcbc\"\\nOutput\\n\"cbad\"\\nExpected\\n\"acdb\"\\n\\nHere sorted output required\\ns =\\n\"bcabc\"\\nOutput\\n\"bca\"\\nExpected\\n\"abc\"\\n"
                    },
                    {
                        "username": "neergx",
                        "content": "the output must be a subsequence of the given string and lexicographically smallest"
                    },
                    {
                        "username": "Verma_03",
                        "content": "Question needs to be more Explanatory....missing something\\nMiss some good test cases....:\")"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Those who are having confusion about \"the smallest in lexicographical order\", let me show you an example. \\nIn the first example, input : \"bcabc\"\\nso the output might be \"bca\", \"cab\",\"abc\" and \"bac\". They want you to remove the duplicates and not reaarange the characters. So out of these, the \"the smallest in lexicographical order\" ans will be \"abc\"."
                    },
                    {
                        "username": "PratikB17",
                        "content": "Can someone please explain what is lexicographic order means?"
                    },
                    {
                        "username": "neergx",
                        "content": "lexicographic means the order in which the given string occurs in dictionary"
                    },
                    {
                        "username": "aitachii",
                        "content": "The hint made it more confusing for me. How would you implement bitmasks here?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I use bitmask to solve it, it is a challange for details."
                    },
                    {
                        "username": "lolloo",
                        "content": " lexicographical order is hard to understand\\nThe question should just say it is the same order as the \"Sort by Name\" or \"Order by Name\" in a computer file system."
                    }
                ]
            },
            {
                "id": 2072584,
                "content": [
                    {
                        "username": "davidashish1996",
                        "content": "I think the problem is wrongly quoted , i am experiencing wrong outputs for the 2 test cases.\\n\\n1.)  s= \"cbacdcbc\"\\n      o/p = \"acdb\"\\n2.)  s = \"bbcaac\"\\n     o/p=\"bac\"\\nIn the first one if we are following traditional approach that if any duplicate characters are coming then we are removing the last duplicate one then it\\'s not applicable in the first example for second one it\\'s working."
                    },
                    {
                        "username": "user5400vw",
                        "content": "in case you\\'re thinking of going knapsack, don\\'t.  it will end in a fiery ball of death."
                    },
                    {
                        "username": "santanusen",
                        "content": "Remember the position of the last occurrence of a letter.\\nIf selecting a letter from the current position causes a problem, discard it if it appears again at a later position (i.e. the position of last occurrence of the letter is yet to come) and, thus, can be chosen again."
                    },
                    {
                        "username": "Neeraj27",
                        "content": "solved it in various ways but these testcases \\nWhat order is it following (what way to do)\\nHere sorted output not required \\ns =\\n\"cbacdcbc\"\\nOutput\\n\"cbad\"\\nExpected\\n\"acdb\"\\n\\nHere sorted output required\\ns =\\n\"bcabc\"\\nOutput\\n\"bca\"\\nExpected\\n\"abc\"\\n"
                    },
                    {
                        "username": "neergx",
                        "content": "the output must be a subsequence of the given string and lexicographically smallest"
                    },
                    {
                        "username": "Verma_03",
                        "content": "Question needs to be more Explanatory....missing something\\nMiss some good test cases....:\")"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Those who are having confusion about \"the smallest in lexicographical order\", let me show you an example. \\nIn the first example, input : \"bcabc\"\\nso the output might be \"bca\", \"cab\",\"abc\" and \"bac\". They want you to remove the duplicates and not reaarange the characters. So out of these, the \"the smallest in lexicographical order\" ans will be \"abc\"."
                    },
                    {
                        "username": "PratikB17",
                        "content": "Can someone please explain what is lexicographic order means?"
                    },
                    {
                        "username": "neergx",
                        "content": "lexicographic means the order in which the given string occurs in dictionary"
                    },
                    {
                        "username": "aitachii",
                        "content": "The hint made it more confusing for me. How would you implement bitmasks here?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I use bitmask to solve it, it is a challange for details."
                    },
                    {
                        "username": "lolloo",
                        "content": " lexicographical order is hard to understand\\nThe question should just say it is the same order as the \"Sort by Name\" or \"Order by Name\" in a computer file system."
                    }
                ]
            },
            {
                "id": 2072549,
                "content": [
                    {
                        "username": "davidashish1996",
                        "content": "I think the problem is wrongly quoted , i am experiencing wrong outputs for the 2 test cases.\\n\\n1.)  s= \"cbacdcbc\"\\n      o/p = \"acdb\"\\n2.)  s = \"bbcaac\"\\n     o/p=\"bac\"\\nIn the first one if we are following traditional approach that if any duplicate characters are coming then we are removing the last duplicate one then it\\'s not applicable in the first example for second one it\\'s working."
                    },
                    {
                        "username": "user5400vw",
                        "content": "in case you\\'re thinking of going knapsack, don\\'t.  it will end in a fiery ball of death."
                    },
                    {
                        "username": "santanusen",
                        "content": "Remember the position of the last occurrence of a letter.\\nIf selecting a letter from the current position causes a problem, discard it if it appears again at a later position (i.e. the position of last occurrence of the letter is yet to come) and, thus, can be chosen again."
                    },
                    {
                        "username": "Neeraj27",
                        "content": "solved it in various ways but these testcases \\nWhat order is it following (what way to do)\\nHere sorted output not required \\ns =\\n\"cbacdcbc\"\\nOutput\\n\"cbad\"\\nExpected\\n\"acdb\"\\n\\nHere sorted output required\\ns =\\n\"bcabc\"\\nOutput\\n\"bca\"\\nExpected\\n\"abc\"\\n"
                    },
                    {
                        "username": "neergx",
                        "content": "the output must be a subsequence of the given string and lexicographically smallest"
                    },
                    {
                        "username": "Verma_03",
                        "content": "Question needs to be more Explanatory....missing something\\nMiss some good test cases....:\")"
                    },
                    {
                        "username": "abhinabroy",
                        "content": "Those who are having confusion about \"the smallest in lexicographical order\", let me show you an example. \\nIn the first example, input : \"bcabc\"\\nso the output might be \"bca\", \"cab\",\"abc\" and \"bac\". They want you to remove the duplicates and not reaarange the characters. So out of these, the \"the smallest in lexicographical order\" ans will be \"abc\"."
                    },
                    {
                        "username": "PratikB17",
                        "content": "Can someone please explain what is lexicographic order means?"
                    },
                    {
                        "username": "neergx",
                        "content": "lexicographic means the order in which the given string occurs in dictionary"
                    },
                    {
                        "username": "aitachii",
                        "content": "The hint made it more confusing for me. How would you implement bitmasks here?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I use bitmask to solve it, it is a challange for details."
                    },
                    {
                        "username": "lolloo",
                        "content": " lexicographical order is hard to understand\\nThe question should just say it is the same order as the \"Sort by Name\" or \"Order by Name\" in a computer file system."
                    }
                ]
            },
            {
                "id": 2072518,
                "content": [
                    {
                        "username": "2uringTested",
                        "content": "Remember that the question asks to \"REMOVE duplicate letters\" and NOT \"REMOVE and REARRANGE\", so you can only remove the letters from their existing positions, you must remove the duplicates from those positions which will result in smallest lexicographical string."
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Very bad problem description, you can understand the problem only by the proper analysis of the given testcases"
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n       sort(s.begin(),s.end());\\n        //base case \\n        if(s.length()==0){ \\n            return \"\";\\n    } \\n    char c=s[0];  \\n\\n\\n     string ans = removeDuplicateLetters(s.substr(1)); \\n    if(s[0]==ans[0]){ \\n        return ans;\\n    } \\n    else{ \\n        return c+ans;\\n    } \\n    \\n    }\\n};  \\n\\n\\nwhat\\'s wrong in this code ? \\n143/290 test cases passed "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "[@PradhiR2002](/PradhiR2002) We need to use stack here. There are some nice questions related to same concept. "
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "[@akshat_ag](/akshat_ag) Alternate way to solve this question ? "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "You did sorting which I think is not valid here since we aren\\'t allowed to reorganize."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i thought of  sorting first and checking the nearest possible to the sorted lexicographical possible in string s , Will it work ??"
                    },
                    {
                        "username": "rutwik_more_1440",
                        "content": "nope"
                    },
                    {
                        "username": "Katana1089",
                        "content": "WHAT\\'S WRONG WITH THIS CODE??\\n\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        string s1;\\n        map<char, int>m, m1;\\n        for(int i = 0; i<s.size(); i++)\\n            m[s[i]]++;\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            m[s[i]]--;\\n            if(m1[s[i]] == 0)\\n            {\\n                while(s1.size() > 0 && s[i] < s1[s1.size() - 1] && m[s1.size() - 1] > 0)\\n                    m1[s1.size() - 1] = 0, s1.pop_back();\\n                s1.push_back(s[i]), m1[s[i]] = 1;\\n            }\\n        }\\n        return s1;\\n    }\\n};"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "There is no need of a Stack here, we can do it using an extra string only.\\nPS- I meant we can treat a String as the stack bcoz we can insert or delete a character at the end of string using push_back, pop_back (in c++)."
                    },
                    {
                        "username": "Verma_03",
                        "content": "Here is the Solution Guyz....:-) [Keep Hustling]\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4092562/c-stack-easy-approach/"
                    },
                    {
                        "username": "kr68011",
                        "content": "How come for input \"cdadabcc\"\n\nanswer is \"adbc\" instead of \"abc\"?\nAdmin can you explain?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you should not discard the only character existing in the string"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I don\\'t  know what is wrong with this question. for input \"cbacdcbc\" according  to me the correct order of this should be \"abcd\" but the expected output is \"acdb\"  I mean how is it possible in lexicographical order."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "Yeah but there is no \"subsequence\" as abcd in cbacdcbc"
                    },
                    {
                        "username": "vikash_kumar_dsa2",
                        "content": "public:\\n    string reverseVowels(string s) {\\n        stack<char> st;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                st.push(s[i]);\\n            }\\n        }\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                s[i] = st.top();\\n                st.pop();\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2072497,
                "content": [
                    {
                        "username": "2uringTested",
                        "content": "Remember that the question asks to \"REMOVE duplicate letters\" and NOT \"REMOVE and REARRANGE\", so you can only remove the letters from their existing positions, you must remove the duplicates from those positions which will result in smallest lexicographical string."
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Very bad problem description, you can understand the problem only by the proper analysis of the given testcases"
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n       sort(s.begin(),s.end());\\n        //base case \\n        if(s.length()==0){ \\n            return \"\";\\n    } \\n    char c=s[0];  \\n\\n\\n     string ans = removeDuplicateLetters(s.substr(1)); \\n    if(s[0]==ans[0]){ \\n        return ans;\\n    } \\n    else{ \\n        return c+ans;\\n    } \\n    \\n    }\\n};  \\n\\n\\nwhat\\'s wrong in this code ? \\n143/290 test cases passed "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "[@PradhiR2002](/PradhiR2002) We need to use stack here. There are some nice questions related to same concept. "
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "[@akshat_ag](/akshat_ag) Alternate way to solve this question ? "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "You did sorting which I think is not valid here since we aren\\'t allowed to reorganize."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i thought of  sorting first and checking the nearest possible to the sorted lexicographical possible in string s , Will it work ??"
                    },
                    {
                        "username": "rutwik_more_1440",
                        "content": "nope"
                    },
                    {
                        "username": "Katana1089",
                        "content": "WHAT\\'S WRONG WITH THIS CODE??\\n\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        string s1;\\n        map<char, int>m, m1;\\n        for(int i = 0; i<s.size(); i++)\\n            m[s[i]]++;\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            m[s[i]]--;\\n            if(m1[s[i]] == 0)\\n            {\\n                while(s1.size() > 0 && s[i] < s1[s1.size() - 1] && m[s1.size() - 1] > 0)\\n                    m1[s1.size() - 1] = 0, s1.pop_back();\\n                s1.push_back(s[i]), m1[s[i]] = 1;\\n            }\\n        }\\n        return s1;\\n    }\\n};"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "There is no need of a Stack here, we can do it using an extra string only.\\nPS- I meant we can treat a String as the stack bcoz we can insert or delete a character at the end of string using push_back, pop_back (in c++)."
                    },
                    {
                        "username": "Verma_03",
                        "content": "Here is the Solution Guyz....:-) [Keep Hustling]\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4092562/c-stack-easy-approach/"
                    },
                    {
                        "username": "kr68011",
                        "content": "How come for input \"cdadabcc\"\n\nanswer is \"adbc\" instead of \"abc\"?\nAdmin can you explain?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you should not discard the only character existing in the string"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I don\\'t  know what is wrong with this question. for input \"cbacdcbc\" according  to me the correct order of this should be \"abcd\" but the expected output is \"acdb\"  I mean how is it possible in lexicographical order."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "Yeah but there is no \"subsequence\" as abcd in cbacdcbc"
                    },
                    {
                        "username": "vikash_kumar_dsa2",
                        "content": "public:\\n    string reverseVowels(string s) {\\n        stack<char> st;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                st.push(s[i]);\\n            }\\n        }\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                s[i] = st.top();\\n                st.pop();\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1873640,
                "content": [
                    {
                        "username": "2uringTested",
                        "content": "Remember that the question asks to \"REMOVE duplicate letters\" and NOT \"REMOVE and REARRANGE\", so you can only remove the letters from their existing positions, you must remove the duplicates from those positions which will result in smallest lexicographical string."
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Very bad problem description, you can understand the problem only by the proper analysis of the given testcases"
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n       sort(s.begin(),s.end());\\n        //base case \\n        if(s.length()==0){ \\n            return \"\";\\n    } \\n    char c=s[0];  \\n\\n\\n     string ans = removeDuplicateLetters(s.substr(1)); \\n    if(s[0]==ans[0]){ \\n        return ans;\\n    } \\n    else{ \\n        return c+ans;\\n    } \\n    \\n    }\\n};  \\n\\n\\nwhat\\'s wrong in this code ? \\n143/290 test cases passed "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "[@PradhiR2002](/PradhiR2002) We need to use stack here. There are some nice questions related to same concept. "
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "[@akshat_ag](/akshat_ag) Alternate way to solve this question ? "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "You did sorting which I think is not valid here since we aren\\'t allowed to reorganize."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i thought of  sorting first and checking the nearest possible to the sorted lexicographical possible in string s , Will it work ??"
                    },
                    {
                        "username": "rutwik_more_1440",
                        "content": "nope"
                    },
                    {
                        "username": "Katana1089",
                        "content": "WHAT\\'S WRONG WITH THIS CODE??\\n\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        string s1;\\n        map<char, int>m, m1;\\n        for(int i = 0; i<s.size(); i++)\\n            m[s[i]]++;\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            m[s[i]]--;\\n            if(m1[s[i]] == 0)\\n            {\\n                while(s1.size() > 0 && s[i] < s1[s1.size() - 1] && m[s1.size() - 1] > 0)\\n                    m1[s1.size() - 1] = 0, s1.pop_back();\\n                s1.push_back(s[i]), m1[s[i]] = 1;\\n            }\\n        }\\n        return s1;\\n    }\\n};"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "There is no need of a Stack here, we can do it using an extra string only.\\nPS- I meant we can treat a String as the stack bcoz we can insert or delete a character at the end of string using push_back, pop_back (in c++)."
                    },
                    {
                        "username": "Verma_03",
                        "content": "Here is the Solution Guyz....:-) [Keep Hustling]\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4092562/c-stack-easy-approach/"
                    },
                    {
                        "username": "kr68011",
                        "content": "How come for input \"cdadabcc\"\n\nanswer is \"adbc\" instead of \"abc\"?\nAdmin can you explain?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you should not discard the only character existing in the string"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I don\\'t  know what is wrong with this question. for input \"cbacdcbc\" according  to me the correct order of this should be \"abcd\" but the expected output is \"acdb\"  I mean how is it possible in lexicographical order."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "Yeah but there is no \"subsequence\" as abcd in cbacdcbc"
                    },
                    {
                        "username": "vikash_kumar_dsa2",
                        "content": "public:\\n    string reverseVowels(string s) {\\n        stack<char> st;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                st.push(s[i]);\\n            }\\n        }\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                s[i] = st.top();\\n                st.pop();\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1812408,
                "content": [
                    {
                        "username": "2uringTested",
                        "content": "Remember that the question asks to \"REMOVE duplicate letters\" and NOT \"REMOVE and REARRANGE\", so you can only remove the letters from their existing positions, you must remove the duplicates from those positions which will result in smallest lexicographical string."
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Very bad problem description, you can understand the problem only by the proper analysis of the given testcases"
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n       sort(s.begin(),s.end());\\n        //base case \\n        if(s.length()==0){ \\n            return \"\";\\n    } \\n    char c=s[0];  \\n\\n\\n     string ans = removeDuplicateLetters(s.substr(1)); \\n    if(s[0]==ans[0]){ \\n        return ans;\\n    } \\n    else{ \\n        return c+ans;\\n    } \\n    \\n    }\\n};  \\n\\n\\nwhat\\'s wrong in this code ? \\n143/290 test cases passed "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "[@PradhiR2002](/PradhiR2002) We need to use stack here. There are some nice questions related to same concept. "
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "[@akshat_ag](/akshat_ag) Alternate way to solve this question ? "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "You did sorting which I think is not valid here since we aren\\'t allowed to reorganize."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i thought of  sorting first and checking the nearest possible to the sorted lexicographical possible in string s , Will it work ??"
                    },
                    {
                        "username": "rutwik_more_1440",
                        "content": "nope"
                    },
                    {
                        "username": "Katana1089",
                        "content": "WHAT\\'S WRONG WITH THIS CODE??\\n\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        string s1;\\n        map<char, int>m, m1;\\n        for(int i = 0; i<s.size(); i++)\\n            m[s[i]]++;\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            m[s[i]]--;\\n            if(m1[s[i]] == 0)\\n            {\\n                while(s1.size() > 0 && s[i] < s1[s1.size() - 1] && m[s1.size() - 1] > 0)\\n                    m1[s1.size() - 1] = 0, s1.pop_back();\\n                s1.push_back(s[i]), m1[s[i]] = 1;\\n            }\\n        }\\n        return s1;\\n    }\\n};"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "There is no need of a Stack here, we can do it using an extra string only.\\nPS- I meant we can treat a String as the stack bcoz we can insert or delete a character at the end of string using push_back, pop_back (in c++)."
                    },
                    {
                        "username": "Verma_03",
                        "content": "Here is the Solution Guyz....:-) [Keep Hustling]\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4092562/c-stack-easy-approach/"
                    },
                    {
                        "username": "kr68011",
                        "content": "How come for input \"cdadabcc\"\n\nanswer is \"adbc\" instead of \"abc\"?\nAdmin can you explain?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you should not discard the only character existing in the string"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I don\\'t  know what is wrong with this question. for input \"cbacdcbc\" according  to me the correct order of this should be \"abcd\" but the expected output is \"acdb\"  I mean how is it possible in lexicographical order."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "Yeah but there is no \"subsequence\" as abcd in cbacdcbc"
                    },
                    {
                        "username": "vikash_kumar_dsa2",
                        "content": "public:\\n    string reverseVowels(string s) {\\n        stack<char> st;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                st.push(s[i]);\\n            }\\n        }\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                s[i] = st.top();\\n                st.pop();\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1758690,
                "content": [
                    {
                        "username": "2uringTested",
                        "content": "Remember that the question asks to \"REMOVE duplicate letters\" and NOT \"REMOVE and REARRANGE\", so you can only remove the letters from their existing positions, you must remove the duplicates from those positions which will result in smallest lexicographical string."
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Very bad problem description, you can understand the problem only by the proper analysis of the given testcases"
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n       sort(s.begin(),s.end());\\n        //base case \\n        if(s.length()==0){ \\n            return \"\";\\n    } \\n    char c=s[0];  \\n\\n\\n     string ans = removeDuplicateLetters(s.substr(1)); \\n    if(s[0]==ans[0]){ \\n        return ans;\\n    } \\n    else{ \\n        return c+ans;\\n    } \\n    \\n    }\\n};  \\n\\n\\nwhat\\'s wrong in this code ? \\n143/290 test cases passed "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "[@PradhiR2002](/PradhiR2002) We need to use stack here. There are some nice questions related to same concept. "
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "[@akshat_ag](/akshat_ag) Alternate way to solve this question ? "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "You did sorting which I think is not valid here since we aren\\'t allowed to reorganize."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i thought of  sorting first and checking the nearest possible to the sorted lexicographical possible in string s , Will it work ??"
                    },
                    {
                        "username": "rutwik_more_1440",
                        "content": "nope"
                    },
                    {
                        "username": "Katana1089",
                        "content": "WHAT\\'S WRONG WITH THIS CODE??\\n\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        string s1;\\n        map<char, int>m, m1;\\n        for(int i = 0; i<s.size(); i++)\\n            m[s[i]]++;\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            m[s[i]]--;\\n            if(m1[s[i]] == 0)\\n            {\\n                while(s1.size() > 0 && s[i] < s1[s1.size() - 1] && m[s1.size() - 1] > 0)\\n                    m1[s1.size() - 1] = 0, s1.pop_back();\\n                s1.push_back(s[i]), m1[s[i]] = 1;\\n            }\\n        }\\n        return s1;\\n    }\\n};"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "There is no need of a Stack here, we can do it using an extra string only.\\nPS- I meant we can treat a String as the stack bcoz we can insert or delete a character at the end of string using push_back, pop_back (in c++)."
                    },
                    {
                        "username": "Verma_03",
                        "content": "Here is the Solution Guyz....:-) [Keep Hustling]\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4092562/c-stack-easy-approach/"
                    },
                    {
                        "username": "kr68011",
                        "content": "How come for input \"cdadabcc\"\n\nanswer is \"adbc\" instead of \"abc\"?\nAdmin can you explain?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you should not discard the only character existing in the string"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I don\\'t  know what is wrong with this question. for input \"cbacdcbc\" according  to me the correct order of this should be \"abcd\" but the expected output is \"acdb\"  I mean how is it possible in lexicographical order."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "Yeah but there is no \"subsequence\" as abcd in cbacdcbc"
                    },
                    {
                        "username": "vikash_kumar_dsa2",
                        "content": "public:\\n    string reverseVowels(string s) {\\n        stack<char> st;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                st.push(s[i]);\\n            }\\n        }\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                s[i] = st.top();\\n                st.pop();\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1575302,
                "content": [
                    {
                        "username": "2uringTested",
                        "content": "Remember that the question asks to \"REMOVE duplicate letters\" and NOT \"REMOVE and REARRANGE\", so you can only remove the letters from their existing positions, you must remove the duplicates from those positions which will result in smallest lexicographical string."
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Very bad problem description, you can understand the problem only by the proper analysis of the given testcases"
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n       sort(s.begin(),s.end());\\n        //base case \\n        if(s.length()==0){ \\n            return \"\";\\n    } \\n    char c=s[0];  \\n\\n\\n     string ans = removeDuplicateLetters(s.substr(1)); \\n    if(s[0]==ans[0]){ \\n        return ans;\\n    } \\n    else{ \\n        return c+ans;\\n    } \\n    \\n    }\\n};  \\n\\n\\nwhat\\'s wrong in this code ? \\n143/290 test cases passed "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "[@PradhiR2002](/PradhiR2002) We need to use stack here. There are some nice questions related to same concept. "
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "[@akshat_ag](/akshat_ag) Alternate way to solve this question ? "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "You did sorting which I think is not valid here since we aren\\'t allowed to reorganize."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i thought of  sorting first and checking the nearest possible to the sorted lexicographical possible in string s , Will it work ??"
                    },
                    {
                        "username": "rutwik_more_1440",
                        "content": "nope"
                    },
                    {
                        "username": "Katana1089",
                        "content": "WHAT\\'S WRONG WITH THIS CODE??\\n\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        string s1;\\n        map<char, int>m, m1;\\n        for(int i = 0; i<s.size(); i++)\\n            m[s[i]]++;\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            m[s[i]]--;\\n            if(m1[s[i]] == 0)\\n            {\\n                while(s1.size() > 0 && s[i] < s1[s1.size() - 1] && m[s1.size() - 1] > 0)\\n                    m1[s1.size() - 1] = 0, s1.pop_back();\\n                s1.push_back(s[i]), m1[s[i]] = 1;\\n            }\\n        }\\n        return s1;\\n    }\\n};"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "There is no need of a Stack here, we can do it using an extra string only.\\nPS- I meant we can treat a String as the stack bcoz we can insert or delete a character at the end of string using push_back, pop_back (in c++)."
                    },
                    {
                        "username": "Verma_03",
                        "content": "Here is the Solution Guyz....:-) [Keep Hustling]\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4092562/c-stack-easy-approach/"
                    },
                    {
                        "username": "kr68011",
                        "content": "How come for input \"cdadabcc\"\n\nanswer is \"adbc\" instead of \"abc\"?\nAdmin can you explain?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you should not discard the only character existing in the string"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I don\\'t  know what is wrong with this question. for input \"cbacdcbc\" according  to me the correct order of this should be \"abcd\" but the expected output is \"acdb\"  I mean how is it possible in lexicographical order."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "Yeah but there is no \"subsequence\" as abcd in cbacdcbc"
                    },
                    {
                        "username": "vikash_kumar_dsa2",
                        "content": "public:\\n    string reverseVowels(string s) {\\n        stack<char> st;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                st.push(s[i]);\\n            }\\n        }\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                s[i] = st.top();\\n                st.pop();\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2073086,
                "content": [
                    {
                        "username": "2uringTested",
                        "content": "Remember that the question asks to \"REMOVE duplicate letters\" and NOT \"REMOVE and REARRANGE\", so you can only remove the letters from their existing positions, you must remove the duplicates from those positions which will result in smallest lexicographical string."
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Very bad problem description, you can understand the problem only by the proper analysis of the given testcases"
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n       sort(s.begin(),s.end());\\n        //base case \\n        if(s.length()==0){ \\n            return \"\";\\n    } \\n    char c=s[0];  \\n\\n\\n     string ans = removeDuplicateLetters(s.substr(1)); \\n    if(s[0]==ans[0]){ \\n        return ans;\\n    } \\n    else{ \\n        return c+ans;\\n    } \\n    \\n    }\\n};  \\n\\n\\nwhat\\'s wrong in this code ? \\n143/290 test cases passed "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "[@PradhiR2002](/PradhiR2002) We need to use stack here. There are some nice questions related to same concept. "
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "[@akshat_ag](/akshat_ag) Alternate way to solve this question ? "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "You did sorting which I think is not valid here since we aren\\'t allowed to reorganize."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i thought of  sorting first and checking the nearest possible to the sorted lexicographical possible in string s , Will it work ??"
                    },
                    {
                        "username": "rutwik_more_1440",
                        "content": "nope"
                    },
                    {
                        "username": "Katana1089",
                        "content": "WHAT\\'S WRONG WITH THIS CODE??\\n\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        string s1;\\n        map<char, int>m, m1;\\n        for(int i = 0; i<s.size(); i++)\\n            m[s[i]]++;\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            m[s[i]]--;\\n            if(m1[s[i]] == 0)\\n            {\\n                while(s1.size() > 0 && s[i] < s1[s1.size() - 1] && m[s1.size() - 1] > 0)\\n                    m1[s1.size() - 1] = 0, s1.pop_back();\\n                s1.push_back(s[i]), m1[s[i]] = 1;\\n            }\\n        }\\n        return s1;\\n    }\\n};"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "There is no need of a Stack here, we can do it using an extra string only.\\nPS- I meant we can treat a String as the stack bcoz we can insert or delete a character at the end of string using push_back, pop_back (in c++)."
                    },
                    {
                        "username": "Verma_03",
                        "content": "Here is the Solution Guyz....:-) [Keep Hustling]\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4092562/c-stack-easy-approach/"
                    },
                    {
                        "username": "kr68011",
                        "content": "How come for input \"cdadabcc\"\n\nanswer is \"adbc\" instead of \"abc\"?\nAdmin can you explain?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you should not discard the only character existing in the string"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I don\\'t  know what is wrong with this question. for input \"cbacdcbc\" according  to me the correct order of this should be \"abcd\" but the expected output is \"acdb\"  I mean how is it possible in lexicographical order."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "Yeah but there is no \"subsequence\" as abcd in cbacdcbc"
                    },
                    {
                        "username": "vikash_kumar_dsa2",
                        "content": "public:\\n    string reverseVowels(string s) {\\n        stack<char> st;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                st.push(s[i]);\\n            }\\n        }\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                s[i] = st.top();\\n                st.pop();\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1972992,
                "content": [
                    {
                        "username": "2uringTested",
                        "content": "Remember that the question asks to \"REMOVE duplicate letters\" and NOT \"REMOVE and REARRANGE\", so you can only remove the letters from their existing positions, you must remove the duplicates from those positions which will result in smallest lexicographical string."
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Very bad problem description, you can understand the problem only by the proper analysis of the given testcases"
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n       sort(s.begin(),s.end());\\n        //base case \\n        if(s.length()==0){ \\n            return \"\";\\n    } \\n    char c=s[0];  \\n\\n\\n     string ans = removeDuplicateLetters(s.substr(1)); \\n    if(s[0]==ans[0]){ \\n        return ans;\\n    } \\n    else{ \\n        return c+ans;\\n    } \\n    \\n    }\\n};  \\n\\n\\nwhat\\'s wrong in this code ? \\n143/290 test cases passed "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "[@PradhiR2002](/PradhiR2002) We need to use stack here. There are some nice questions related to same concept. "
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "[@akshat_ag](/akshat_ag) Alternate way to solve this question ? "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "You did sorting which I think is not valid here since we aren\\'t allowed to reorganize."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i thought of  sorting first and checking the nearest possible to the sorted lexicographical possible in string s , Will it work ??"
                    },
                    {
                        "username": "rutwik_more_1440",
                        "content": "nope"
                    },
                    {
                        "username": "Katana1089",
                        "content": "WHAT\\'S WRONG WITH THIS CODE??\\n\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        string s1;\\n        map<char, int>m, m1;\\n        for(int i = 0; i<s.size(); i++)\\n            m[s[i]]++;\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            m[s[i]]--;\\n            if(m1[s[i]] == 0)\\n            {\\n                while(s1.size() > 0 && s[i] < s1[s1.size() - 1] && m[s1.size() - 1] > 0)\\n                    m1[s1.size() - 1] = 0, s1.pop_back();\\n                s1.push_back(s[i]), m1[s[i]] = 1;\\n            }\\n        }\\n        return s1;\\n    }\\n};"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "There is no need of a Stack here, we can do it using an extra string only.\\nPS- I meant we can treat a String as the stack bcoz we can insert or delete a character at the end of string using push_back, pop_back (in c++)."
                    },
                    {
                        "username": "Verma_03",
                        "content": "Here is the Solution Guyz....:-) [Keep Hustling]\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4092562/c-stack-easy-approach/"
                    },
                    {
                        "username": "kr68011",
                        "content": "How come for input \"cdadabcc\"\n\nanswer is \"adbc\" instead of \"abc\"?\nAdmin can you explain?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you should not discard the only character existing in the string"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I don\\'t  know what is wrong with this question. for input \"cbacdcbc\" according  to me the correct order of this should be \"abcd\" but the expected output is \"acdb\"  I mean how is it possible in lexicographical order."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "Yeah but there is no \"subsequence\" as abcd in cbacdcbc"
                    },
                    {
                        "username": "vikash_kumar_dsa2",
                        "content": "public:\\n    string reverseVowels(string s) {\\n        stack<char> st;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                st.push(s[i]);\\n            }\\n        }\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                s[i] = st.top();\\n                st.pop();\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1823555,
                "content": [
                    {
                        "username": "2uringTested",
                        "content": "Remember that the question asks to \"REMOVE duplicate letters\" and NOT \"REMOVE and REARRANGE\", so you can only remove the letters from their existing positions, you must remove the duplicates from those positions which will result in smallest lexicographical string."
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Very bad problem description, you can understand the problem only by the proper analysis of the given testcases"
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n       sort(s.begin(),s.end());\\n        //base case \\n        if(s.length()==0){ \\n            return \"\";\\n    } \\n    char c=s[0];  \\n\\n\\n     string ans = removeDuplicateLetters(s.substr(1)); \\n    if(s[0]==ans[0]){ \\n        return ans;\\n    } \\n    else{ \\n        return c+ans;\\n    } \\n    \\n    }\\n};  \\n\\n\\nwhat\\'s wrong in this code ? \\n143/290 test cases passed "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "[@PradhiR2002](/PradhiR2002) We need to use stack here. There are some nice questions related to same concept. "
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "[@akshat_ag](/akshat_ag) Alternate way to solve this question ? "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "You did sorting which I think is not valid here since we aren\\'t allowed to reorganize."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i thought of  sorting first and checking the nearest possible to the sorted lexicographical possible in string s , Will it work ??"
                    },
                    {
                        "username": "rutwik_more_1440",
                        "content": "nope"
                    },
                    {
                        "username": "Katana1089",
                        "content": "WHAT\\'S WRONG WITH THIS CODE??\\n\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        string s1;\\n        map<char, int>m, m1;\\n        for(int i = 0; i<s.size(); i++)\\n            m[s[i]]++;\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            m[s[i]]--;\\n            if(m1[s[i]] == 0)\\n            {\\n                while(s1.size() > 0 && s[i] < s1[s1.size() - 1] && m[s1.size() - 1] > 0)\\n                    m1[s1.size() - 1] = 0, s1.pop_back();\\n                s1.push_back(s[i]), m1[s[i]] = 1;\\n            }\\n        }\\n        return s1;\\n    }\\n};"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "There is no need of a Stack here, we can do it using an extra string only.\\nPS- I meant we can treat a String as the stack bcoz we can insert or delete a character at the end of string using push_back, pop_back (in c++)."
                    },
                    {
                        "username": "Verma_03",
                        "content": "Here is the Solution Guyz....:-) [Keep Hustling]\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4092562/c-stack-easy-approach/"
                    },
                    {
                        "username": "kr68011",
                        "content": "How come for input \"cdadabcc\"\n\nanswer is \"adbc\" instead of \"abc\"?\nAdmin can you explain?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you should not discard the only character existing in the string"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I don\\'t  know what is wrong with this question. for input \"cbacdcbc\" according  to me the correct order of this should be \"abcd\" but the expected output is \"acdb\"  I mean how is it possible in lexicographical order."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "Yeah but there is no \"subsequence\" as abcd in cbacdcbc"
                    },
                    {
                        "username": "vikash_kumar_dsa2",
                        "content": "public:\\n    string reverseVowels(string s) {\\n        stack<char> st;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                st.push(s[i]);\\n            }\\n        }\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                s[i] = st.top();\\n                st.pop();\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1677786,
                "content": [
                    {
                        "username": "2uringTested",
                        "content": "Remember that the question asks to \"REMOVE duplicate letters\" and NOT \"REMOVE and REARRANGE\", so you can only remove the letters from their existing positions, you must remove the duplicates from those positions which will result in smallest lexicographical string."
                    },
                    {
                        "username": "DivyenduVimal",
                        "content": "Very bad problem description, you can understand the problem only by the proper analysis of the given testcases"
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n       sort(s.begin(),s.end());\\n        //base case \\n        if(s.length()==0){ \\n            return \"\";\\n    } \\n    char c=s[0];  \\n\\n\\n     string ans = removeDuplicateLetters(s.substr(1)); \\n    if(s[0]==ans[0]){ \\n        return ans;\\n    } \\n    else{ \\n        return c+ans;\\n    } \\n    \\n    }\\n};  \\n\\n\\nwhat\\'s wrong in this code ? \\n143/290 test cases passed "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "[@PradhiR2002](/PradhiR2002) We need to use stack here. There are some nice questions related to same concept. "
                    },
                    {
                        "username": "PradhiR2002",
                        "content": "[@akshat_ag](/akshat_ag) Alternate way to solve this question ? "
                    },
                    {
                        "username": "akshat_ag",
                        "content": "You did sorting which I think is not valid here since we aren\\'t allowed to reorganize."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i thought of  sorting first and checking the nearest possible to the sorted lexicographical possible in string s , Will it work ??"
                    },
                    {
                        "username": "rutwik_more_1440",
                        "content": "nope"
                    },
                    {
                        "username": "Katana1089",
                        "content": "WHAT\\'S WRONG WITH THIS CODE??\\n\\nclass Solution {\\npublic:\\n    string removeDuplicateLetters(string s) {\\n        string s1;\\n        map<char, int>m, m1;\\n        for(int i = 0; i<s.size(); i++)\\n            m[s[i]]++;\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            m[s[i]]--;\\n            if(m1[s[i]] == 0)\\n            {\\n                while(s1.size() > 0 && s[i] < s1[s1.size() - 1] && m[s1.size() - 1] > 0)\\n                    m1[s1.size() - 1] = 0, s1.pop_back();\\n                s1.push_back(s[i]), m1[s[i]] = 1;\\n            }\\n        }\\n        return s1;\\n    }\\n};"
                    },
                    {
                        "username": "vishalshrm539",
                        "content": "There is no need of a Stack here, we can do it using an extra string only.\\nPS- I meant we can treat a String as the stack bcoz we can insert or delete a character at the end of string using push_back, pop_back (in c++)."
                    },
                    {
                        "username": "Verma_03",
                        "content": "Here is the Solution Guyz....:-) [Keep Hustling]\\nhttps://leetcode.com/problems/remove-duplicate-letters/solutions/4092562/c-stack-easy-approach/"
                    },
                    {
                        "username": "kr68011",
                        "content": "How come for input \"cdadabcc\"\n\nanswer is \"adbc\" instead of \"abc\"?\nAdmin can you explain?"
                    },
                    {
                        "username": "thainguyenCSE",
                        "content": "you should not discard the only character existing in the string"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I don\\'t  know what is wrong with this question. for input \"cbacdcbc\" according  to me the correct order of this should be \"abcd\" but the expected output is \"acdb\"  I mean how is it possible in lexicographical order."
                    },
                    {
                        "username": "ashutosh_patel_",
                        "content": "Yeah but there is no \"subsequence\" as abcd in cbacdcbc"
                    },
                    {
                        "username": "vikash_kumar_dsa2",
                        "content": "public:\\n    string reverseVowels(string s) {\\n        stack<char> st;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                st.push(s[i]);\\n            }\\n        }\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i]==\\'a\\'||s[i]==\\'e\\'||s[i]==\\'i\\'||s[i]==\\'o\\'||s[i]==\\'u\\'||s[i]==\\'A\\'||s[i]==\\'E\\'||s[i]==\\'I\\'||s[i]==\\'O\\'||s[i]==\\'U\\'){\\n                s[i] = st.top();\\n                st.pop();\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]