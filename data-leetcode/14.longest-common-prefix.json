[
    {
        "title": "Longest Common Prefix",
        "question_content": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".\n&nbsp;\nExample 1:\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\nExample 2:\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n&nbsp;\nConstraints:\n\n\t1 <= strs.length <= 200\n\t0 <= strs[i].length <= 200\n\tstrs[i] consists of only lowercase English letters.",
        "solutions": [
            {
                "id": 3174307,
                "title": "well-explained-code-using-strings-in-java",
                "content": "\\n# Approach\\nThis code is used to find the longest common prefix of an array of strings, which is defined as the longest string that is a prefix of all the strings in the array. By sorting the array and then comparing the first and last elements, the code is able to find the common prefix that would be shared by all strings in the array.\\n\\n1. Sort the elements of an array of strings called \"strs\" in lexicographic (alphabetical) order using the Arrays.sort(strs) method.\\n2. Assign the first element of the sorted array (the lexicographically smallest string) to a string variable s1.\\n3. Assign the last element of the sorted array (the lexicographically largest string) to a string variable s2.\\n4. Initialize an integer variable idx to 0.\\n5. Start a while loop that continues while idx is less than the length of s1 and s2.\\n6. Within the while loop, check if the character at the current index in s1 is equal to the character at the same index in s2. If the characters are equal, increment the value of idx by 1.\\n7. If the characters are not equal, exit the while loop.\\n8. Return the substring of s1 that starts from the first character and ends at the idxth character (exclusive).\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n1. Sorting the array of strings takes O(Nlog(N)) time. This is because most of the common sorting algorithms like quicksort, mergesort, and heapsort have an average time complexity of O(Nlog(N)).\\n2. Iterating over the characters of the first and last strings takes O(M) time. This is because the code compares the characters of the two strings until it finds the first mismatch.\\n\\nTherefore, the total time complexity is O(Nlog(N) + M).\\n\\n\\n\\n\\n- Space complexity:\\nThe space used by the two string variables s1 and s2 is proportional to the length of the longest string in the array. Therefore, the space complexity is O(1) as it does not depend on the size of the input array.\\n\\n# Reason for Sorting \\n\\nThe reason why we sort the input array of strings and compare the first and last strings is that the longest common prefix of all the strings must be a prefix of the first string and a prefix of the last string in the sorted array. This is because strings are ordered based on their alphabetical order (Lexicographical order).\\nFor example, consider the input array of strings {\"flower\", \"flow\", \"flight\"}. After sorting the array, we get {\"flight\", \"flow\", \"flower\"}. The longest common prefix of all the strings is \"fl\", which is located at the beginning of the first string \"flight\" and the second string \"flow\". Therefore, by comparing the first and last strings of the sorted array, we can easily find the longest common prefix.\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        Arrays.sort(strs);\\n        String s1 = strs[0];\\n        String s2 = strs[strs.length-1];\\n        int idx = 0;\\n        while(idx < s1.length() && idx < s2.length()){\\n            if(s1.charAt(idx) == s2.charAt(idx)){\\n                idx++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return s1.substring(0, idx);\\n    }\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/078cc82b-d80b-4aef-ae08-ce75ef6c698d_1676176908.0916324.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        Arrays.sort(strs);\\n        String s1 = strs[0];\\n        String s2 = strs[strs.length-1];\\n        int idx = 0;\\n        while(idx < s1.length() && idx < s2.length()){\\n            if(s1.charAt(idx) == s2.charAt(idx)){\\n                idx++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return s1.substring(0, idx);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273176,
                "title": "python3-c-java-19-ms-beats-99-91",
                "content": "# Please UPVOTE\\uD83D\\uDE0A\\n![image.png](https://assets.leetcode.com/users/images/f54185ef-bb76-4c6e-807b-66e506e7fab0_1678294130.6935549.png)\\n\\nThis code implements the longestCommonPrefix function that takes a list of strings v as input and returns the longest common prefix of all the strings. Here is an explanation of how the code works:\\n\\n1. Initialize an empty string ans to store the common prefix.\\n2. Sort the input list v lexicographically. This step is necessary because the common prefix should be common to all the strings, so we need to find the common prefix of the first and last string in the sorted list.\\n3. Iterate through the characters of the first and last string in the sorted list, stopping at the length of the shorter string.\\n4. If the current character of the first string is not equal to the current character of the last string, return the common prefix found so far.\\n5. Otherwise, append the current character to the ans string.\\n6. Return the ans string containing the longest common prefix.\\n\\nNote that the code assumes that the input list v is non-empty, and that all the strings in v have at least one character. If either of these assumptions is not true, the code may fail.\\n# Python3\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, v: List[str]) -> str:\\n        ans=\"\"\\n        v=sorted(v)\\n        first=v[0]\\n        last=v[-1]\\n        for i in range(min(len(first),len(last))):\\n            if(first[i]!=last[i]):\\n                return ans\\n            ans+=first[i]\\n        return ans \\n\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& v) {\\n        string ans=\"\";\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        string first=v[0],last=v[n-1];\\n        for(int i=0;i<min(first.size(),last.size());i++){\\n            if(first[i]!=last[i]){\\n                return ans;\\n            }\\n            ans+=first[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Java \\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] v) {\\n        StringBuilder ans = new StringBuilder();\\n        Arrays.sort(v);\\n        String first = v[0];\\n        String last = v[v.length-1];\\n        for (int i=0; i<Math.min(first.length(), last.length()); i++) {\\n            if (first.charAt(i) != last.charAt(i)) {\\n                return ans.toString();\\n            }\\n            ans.append(first.charAt(i));\\n        }\\n        return ans.toString();\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, v: List[str]) -> str:\\n        ans=\"\"\\n        v=sorted(v)\\n        first=v[0]\\n        last=v[-1]\\n        for i in range(min(len(first),len(last))):\\n            if(first[i]!=last[i]):\\n                return ans\\n            ans+=first[i]\\n        return ans \\n\\n```\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& v) {\\n        string ans=\"\";\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        string first=v[0],last=v[n-1];\\n        for(int i=0;i<min(first.size(),last.size());i++){\\n            if(first[i]!=last[i]){\\n                return ans;\\n            }\\n            ans+=first[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] v) {\\n        StringBuilder ans = new StringBuilder();\\n        Arrays.sort(v);\\n        String first = v[0];\\n        String last = v[v.length-1];\\n        for (int i=0; i<Math.min(first.length(), last.length()); i++) {\\n            if (first.charAt(i) != last.charAt(i)) {\\n                return ans.toString();\\n            }\\n            ans.append(first.charAt(i));\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6918,
                "title": "short-python-solution",
                "content": "```\\n def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        if not strs:\\n            return \"\"\\n        shortest = min(strs,key=len)\\n        for i, ch in enumerate(shortest):\\n            for other in strs:\\n                if other[i] != ch:\\n                    return shortest[:i]\\n        return shortest \\n```",
                "solutionTags": [],
                "code": "```\\n def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        if not strs:\\n            return \"\"\\n        shortest = min(strs,key=len)\\n        for i, ch in enumerate(shortest):\\n            for other in strs:\\n                if other[i] != ch:\\n                    return shortest[:i]\\n        return shortest \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 721752,
                "title": "java-100-just-compare-two-strings",
                "content": "```class Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null || strs.length == 0)\\n            return \"\";\\n        \\n        Arrays.sort(strs);\\n        String first = strs[0];\\n        String last = strs[strs.length - 1];\\n        int c = 0;\\n        while(c < first.length())\\n        {\\n            if (first.charAt(c) == last.charAt(c))\\n                c++;\\n            else\\n                break;\\n        }\\n        return c == 0 ? \"\" : first.substring(0, c);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null || strs.length == 0)\\n            return \"\";\\n        \\n        Arrays.sort(strs);\\n        String first = strs[0];\\n        String last = strs[strs.length - 1];\\n        int c = 0;\\n        while(c < first.length())\\n        {\\n            if (first.charAt(c) == last.charAt(c))\\n                c++;\\n            else\\n                break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1405155,
                "title": "java-detailed-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String prefix = strs[0];\\n        for(int index=1;index<strs.length;index++){\\n            while(strs[index].indexOf(prefix) != 0){\\n                prefix=prefix.substring(0,prefix.length()-1);\\n            }\\n        }\\n        return prefix;\\n    }\\n}\\n\\n/*\\nPLEASE UPVOTE IF IT HELPS YOU! THANK YOU!\\nRecommend to dry run along with the example.\\n\\nWorking:\\n1)Take the first(index=0) string in the array as prefix.\\n2)Iterate from second(index=1) string till the end.\\n3)Use the indexOf() function to check if the prefix is there in the strs[i] or not.\\nIf the prefix is there the function returns 0 else -1.\\n4)Use the substring function to chop the last letter from prefix each time the function return -1.\\n\\neg:\\nstrs=[\"flower\", \"flow\", \"flight\"]\\nprefix=flower\\nindex=1\\n    while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flower\")!=0)\\n    Since flower as a whole is not in flow, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flowe\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flowe\")!=0)\\n    Since flowe as a whole is not in flow, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flow\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flow\")!=0)\\n    Since flow as a whole is in flow, it returns 0 so now prefix=flow\\nindex=2\\n    while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"flow\")!=0)\\n    Since flow as a whole is not in flight, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flo\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"flo\")!=0)\\n    Since flo as a whole is not in flight, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"fl\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"fl\")!=0)\\n    Since fl as a whole is in flight, it returns 0 so now prefix=fl\\nindex=3, for loop terminates and we return prefix which is equal to fl\\n*/\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String prefix = strs[0];\\n        for(int index=1;index<strs.length;index++){\\n            while(strs[index].indexOf(prefix) != 0){\\n                prefix=prefix.substring(0,prefix.length()-1);\\n            }\\n        }\\n        return prefix;\\n    }\\n}\\n\\n/*\\nPLEASE UPVOTE IF IT HELPS YOU! THANK YOU!\\nRecommend to dry run along with the example.\\n\\nWorking:\\n1)Take the first(index=0) string in the array as prefix.\\n2)Iterate from second(index=1) string till the end.\\n3)Use the indexOf() function to check if the prefix is there in the strs[i] or not.\\nIf the prefix is there the function returns 0 else -1.\\n4)Use the substring function to chop the last letter from prefix each time the function return -1.\\n\\neg:\\nstrs=[\"flower\", \"flow\", \"flight\"]\\nprefix=flower\\nindex=1\\n    while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flower\")!=0)\\n    Since flower as a whole is not in flow, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flowe\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flowe\")!=0)\\n    Since flowe as a whole is not in flow, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flow\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flow\")!=0)\\n    Since flow as a whole is in flow, it returns 0 so now prefix=flow\\nindex=2\\n    while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"flow\")!=0)\\n    Since flow as a whole is not in flight, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flo\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"flo\")!=0)\\n    Since flo as a whole is not in flight, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"fl\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"fl\")!=0)\\n    Since fl as a whole is in flight, it returns 0 so now prefix=fl\\nindex=3, for loop terminates and we return prefix which is equal to fl\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391089,
                "title": "c-easy-to-understand-solution-using-sort",
                "content": "The code below is very much self explanatory. \\n1. We first sort the array of strings.\\n2. Then, we choose the first and last string in the array. `[They are supposed to be the most different among all the pairs of strings in the sorted array]`\\n3. We just compare how many common characters match from index  `i = 0`  of these two strings.\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n        int n = str.size();\\n        if(n==0) return \"\";\\n        \\n        string ans  = \"\";\\n        sort(begin(str), end(str));\\n        string a = str[0];\\n        string b = str[n-1];\\n        \\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==b[i]){\\n                ans = ans + a[i];\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n        int n = str.size();\\n        if(n==0) return \"\";\\n        \\n        string ans  = \"\";\\n        sort(begin(str), end(str));\\n        string a = str[0];\\n        string b = str[n-1];\\n        \\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==b[i]){\\n                ans = ans + a[i];\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6910,
                "title": "java-code-with-13-lines",
                "content": "\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs == null || strs.length == 0)    return \"\";\\n        String pre = strs[0];\\n        int i = 1;\\n        while(i < strs.length){\\n            while(strs[i].indexOf(pre) != 0)\\n                pre = pre.substring(0,pre.length()-1);\\n            i++;\\n        }\\n        return pre;\\n    }",
                "solutionTags": [],
                "code": "\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs == null || strs.length == 0)    return \"\";\\n        String pre = strs[0];\\n        int i = 1;\\n        while(i < strs.length){\\n            while(strs[i].indexOf(pre) != 0)\\n                pre = pre.substring(0,pre.length()-1);\\n            i++;\\n        }\\n        return pre;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 172553,
                "title": "beat-100-python-submission-short-and-clean",
                "content": "**using enumerater**\n```\nclass Solution:\n    def longestCommonPrefix(self, m):\n        if not m: return ''\n\t\t\t\t#since list of string will be sorted and retrieved min max by alphebetic order\n        s1 = min(m)\n        s2 = max(m)\n\n        for i, c in enumerate(s1):\n            if c != s2[i]:\n                return s1[:i] #stop until hit the split index\n        return s1\n```",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def longestCommonPrefix(self, m):\n        if not m: return ''\n\t\t\t\t#since list of string will be sorted and retrieved min max by alphebetic order\n        s1 = min(m)\n        s2 = max(m)\n\n        for i, c in enumerate(s1):\n            if c != s2[i]:\n                return s1[:i] #stop until hit the split index\n        return s1\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669032,
                "title": "c-very-easy-explained",
                "content": "The longest common prefix is common to all the strings. So, we can fix one string and check the common prefix of this string with other strings. The minimum such length is found and the answer is the substring of the fixed string starting from 0 to the length of the above such minimum.\\nHere, I have fixed 0th string and checked other strings with this. \\n**Full Code:**\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& s) {\\n        int ans = s[0].length(), n = s.size();\\n        for(int i=1; i<n; i++){\\n            int j = 0;\\n            while(j<s[i].length() && s[i][j]==s[0][j])j++;\\n            ans = min(ans, j);\\n        }\\n        return s[0].substr(0, ans);\\n    }\\n};\\n```\\n**Incase you found the post useful, please give it an upvote.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& s) {\\n        int ans = s[0].length(), n = s.size();\\n        for(int i=1; i<n; i++){\\n            int j = 0;\\n            while(j<s[i].length() && s[i][j]==s[0][j])j++;\\n            ans = min(ans, j);\\n        }\\n        return s[0].substr(0, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184623,
                "title": "simplest-c-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end());\\n        int a=strs.size();\\n        string n=strs[0],m=strs[a-1],ans=\"\";\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]==m[i]){ans+=n[i];}\\n            else break;\\n        }\\n        return ans;\\n        \\n    }\\n};\\nDo UPVOTE if you like\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end());\\n        int a=strs.size();\\n        string n=strs[0],m=strs[a-1],ans=\"\";\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]==m[i]){ans+=n[i];}\\n            else break;\\n        }\\n        return ans;\\n        \\n    }\\n};\\nDo UPVOTE if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354496,
                "title": "python3-list-zip-str",
                "content": "*  list(zip(*strs))\\nstrs = [\"flower\",\"flow\",\"flight\"]\\n```\\nstrs = [\"flower\",\"flow\",\"flight\"]\\nl = list(zip(*strs))\\n>>> l = [(\\'f\\', \\'f\\', \\'f\\'), (\\'l\\', \\'l\\', \\'l\\'), (\\'o\\', \\'o\\', \\'i\\'), (\\'w\\', \\'w\\', \\'g\\')]\\n```\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        l = list(zip(*strs))\\n        prefix = \"\"\\n        for i in l:\\n            if len(set(i))==1:\\n                prefix += i[0]\\n            else:\\n                break\\n        return prefix\\n```\\n* traditional scan vertically\\n```\\n i      0  1  2  3  4  5\\n 0      f  l  o  w  e  r\\n 1\\t    f  l  o  w\\n 2\\t    f  l  i  g  h  t\\n\\t\\t\\nWe choose the first string in the list as a reference. in this case is str[0] = \"flower\"\\nthe outside for-loop go through each character of the str[0] or \"flower\". f->l->o->w->e->r\\nthe inside for-loop, go through the words, in this case is flow, flight.\\n\\n\\nstrs[j][i] means the the i\\'s character of the j words in the strs.\\n\\nthere are 3 cases when we proceed the scan:\\n\\ncase 1: strs[j][i] = c, strs[1][2] = \\'o\\' and strs[0][2] = \\'o\\';  keep going;\\ncase 2: strs[j][i] != c, strs[2][2] = \\'i\\' and strs[0][2] = \\'o\\';  break the rule, we can return strs[j][:i]. when comes to slicing a string, [:i] won\\'t include the index i;\\ncase 3: i = len(strs[j]) which means current word at strs[j] doesn\\'t have character at index i, since it\\'s 0 based index. the lenght equals i, the index ends at i - 1; break the rule, we can return.\\n\\n \\n```\\n\\n\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if strs == None or len(strs) == 0: return \"\"\\n        for i in range(len(strs[0])): \\n            c = strs[0][i]// \\n            for j in range(1,len(strs)):\\n                if i == len(strs[j]) or strs[j][i] != c:\\n                    return strs[0][:i]\\n        return strs[0] if strs else \"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nstrs = [\"flower\",\"flow\",\"flight\"]\\nl = list(zip(*strs))\\n>>> l = [(\\'f\\', \\'f\\', \\'f\\'), (\\'l\\', \\'l\\', \\'l\\'), (\\'o\\', \\'o\\', \\'i\\'), (\\'w\\', \\'w\\', \\'g\\')]\\n```\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        l = list(zip(*strs))\\n        prefix = \"\"\\n        for i in l:\\n            if len(set(i))==1:\\n                prefix += i[0]\\n            else:\\n                break\\n        return prefix\\n```\n```\\n i      0  1  2  3  4  5\\n 0      f  l  o  w  e  r\\n 1\\t    f  l  o  w\\n 2\\t    f  l  i  g  h  t\\n\\t\\t\\nWe choose the first string in the list as a reference. in this case is str[0] = \"flower\"\\nthe outside for-loop go through each character of the str[0] or \"flower\". f->l->o->w->e->r\\nthe inside for-loop, go through the words, in this case is flow, flight.\\n\\n\\nstrs[j][i] means the the i\\'s character of the j words in the strs.\\n\\nthere are 3 cases when we proceed the scan:\\n\\ncase 1: strs[j][i] = c, strs[1][2] = \\'o\\' and strs[0][2] = \\'o\\';  keep going;\\ncase 2: strs[j][i] != c, strs[2][2] = \\'i\\' and strs[0][2] = \\'o\\';  break the rule, we can return strs[j][:i]. when comes to slicing a string, [:i] won\\'t include the index i;\\ncase 3: i = len(strs[j]) which means current word at strs[j] doesn\\'t have character at index i, since it\\'s 0 based index. the lenght equals i, the index ends at i - 1; break the rule, we can return.\\n\\n \\n```\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if strs == None or len(strs) == 0: return \"\"\\n        for i in range(len(strs[0])): \\n            c = strs[0][i]// \\n            for j in range(1,len(strs)):\\n                if i == len(strs[j]) or strs[j][i] != c:\\n                    return strs[0][:i]\\n        return strs[0] if strs else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6924,
                "title": "sorted-the-array-java-solution-2-ms",
                "content": "Sort the array first, and then you can simply compare the first and last elements in the sorted array.\\n\\n\\n        public String longestCommonPrefix(String[] strs) {\\n            StringBuilder result = new StringBuilder();\\n            \\n            if (strs!= null && strs.length > 0){\\n            \\n                Arrays.sort(strs);\\n                \\n                char [] a = strs[0].toCharArray();\\n                char [] b = strs[strs.length-1].toCharArray();\\n                \\n                for (int i = 0; i < a.length; i ++){\\n                    if (b.length > i && b[i] == a[i]){\\n                        result.append(b[i]);\\n                    }\\n                    else {\\n                        return result.toString();\\n                    }\\n                }\\n            return result.toString();\\n        }",
                "solutionTags": [],
                "code": "Sort the array first, and then you can simply compare the first and last elements in the sorted array.\\n\\n\\n        public String longestCommonPrefix(String[] strs) {\\n            StringBuilder result = new StringBuilder();\\n            \\n            if (strs!= null && strs.length > 0){\\n            \\n                Arrays.sort(strs);\\n                \\n                char [] a = strs[0].toCharArray();\\n                char [] b = strs[strs.length-1].toCharArray();\\n                \\n                for (int i = 0; i < a.length; i ++){\\n                    if (b.length > i && b[i] == a[i]){\\n                        result.append(b[i]);\\n                    }\\n                    else {\\n                        return result.toString();\\n                    }\\n                }\\n            return result.toString();\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 6911,
                "title": "simple-python-solution",
                "content": "Might be a bit slow, but here's my relatively elegant Python solution:\\n\\n    class Solution:\\n        # @return a string\\n        def longestCommonPrefix(self, strs):\\n            if not strs:\\n                return \"\"\\n                \\n            for i, letter_group in enumerate(zip(*strs)):\\n                if len(set(letter_group)) > 1:\\n                    return strs[0][:i]\\n            else:\\n                return min(strs)",
                "solutionTags": [],
                "code": "Might be a bit slow, but here's my relatively elegant Python solution:\\n\\n    class Solution:\\n        # @return a string\\n        def longestCommonPrefix(self, strs):\\n            if not strs:\\n                return \"\"\\n                \\n            for i, letter_group in enumerate(zip(*strs)):\\n                if len(set(letter_group)) > 1:\\n                    return strs[0][:i]\\n            else:\\n                return min(strs)",
                "codeTag": "Java"
            },
            {
                "id": 2748936,
                "title": "simple-java-solution",
                "content": "```\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length==0) return \"\";\\n        String prefix=strs[0];\\n        for(int i=1;i<strs.length;i++){\\n            while(strs[i].indexOf(prefix)!=0){\\n                prefix=prefix.substring(0,prefix.length()-1);\\n            }\\n            \\n        }\\n        return prefix;\\n        \\n        \\n    }\\n//Please upvote",
                "solutionTags": [],
                "code": "```\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length==0) return \"\";\\n        String prefix=strs[0];\\n        for(int i=1;i<strs.length;i++){\\n            while(strs[i].indexOf(prefix)!=0){\\n                prefix=prefix.substring(0,prefix.length()-1);\\n            }\\n            \\n        }\\n        return prefix;\\n        \\n        \\n    }\\n//Please upvote",
                "codeTag": "Unknown"
            },
            {
                "id": 1351149,
                "title": "python-startswith",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        \\n        pre = strs[0]\\n        \\n        for i in strs:\\n            while not i.startswith(pre):\\n                pre = pre[:-1]\\n        \\n        return pre     \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        \\n        pre = strs[0]\\n        \\n        for i in strs:\\n            while not i.startswith(pre):\\n                pre = pre[:-1]\\n        \\n        return pre     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 6983,
                "title": "js-higher-order-function-solution-with-concise-and-easy-to-understand-code",
                "content": "reduce is just for this: take a list of strings and reduce them to one string\\n\\n    var longestCommonPrefix = function(strs) {\\n        'use strict';\\n        if (strs === undefined || strs.length === 0) { return ''; }\\n        \\n        return strs.reduce((prev, next) => {\\n            let i = 0;\\n            while (prev[i] && next[i] && prev[i] === next[i]) i++;\\n            return prev.slice(0, i);\\n        });\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "reduce is just for this: take a list of strings and reduce them to one string\\n\\n    var longestCommonPrefix = function(strs) {\\n        'use strict';\\n        if (strs === undefined || strs.length === 0) { return ''; }\\n        \\n        return strs.reduce((prev, next) => {\\n            let i = 0;\\n            while (prev[i] && next[i] && prev[i] === next[i]) i++;\\n            return prev.slice(0, i);\\n        });\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3031312,
                "title": "longest-common-prefix-in-python",
                "content": "# Intuition\\nCompare each letter of each word to check if they match, and add them to an empty string until you hit a character that doesn\\'t match. Return the string obtained so far.\\n\\n# Approach\\nInitialize an empty string. Zip the list, so you get the first characters of each word together in a tuple, the second letters in another tuple, and so on. Convert each such tuple into a set, and check if the length of the set is 1 - to understand if the elements were same (as sets store only 1 instance of a repeated element). If the length of the set is 1, add the first element of the tuple (any element is fine, as all elements are same but we take the first element just to be cautious) to the empty string. If the length of a set is not 1, return the string as is. Finally, return the string obtained thus far.\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        res = \"\"\\n        for a in zip(*strs):\\n            if len(set(a)) == 1: \\n                res += a[0]\\n            else: \\n                return res\\n        return res\\n                        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        res = \"\"\\n        for a in zip(*strs):\\n            if len(set(a)) == 1: \\n                res += a[0]\\n            else: \\n                return res\\n        return res\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393325,
                "title": "c-solution-100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs){\\n        int n =strs.size();\\n        string ans; \\n        sort(strs.begin(), strs.end());\\n        string a = strs[0];\\n        string b = strs[n-1];\\n        for(int i =0; i< a.size(); i++){\\n            if(a[i] == b[i]){\\n                ans += a[i];\\n            }else break;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs){\\n        int n =strs.size();\\n        string ans; \\n        sort(strs.begin(), strs.end());\\n        string a = strs[0];\\n        string b = strs[n-1];\\n        for(int i =0; i< a.size(); i++){\\n            if(a[i] == b[i]){\\n                ans += a[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 526694,
                "title": "javascript-simple-solution-using-every-with-explanation",
                "content": "# Approach\\n- First find the shortest string in the array; the length of this string is the maximum length of our prefix \\n\\t- this is because a prefix can\\'t be longer than the word it inhabits\\n- Next we iterate from `index 0` to `maxPrefixLength - 1`\\n- We use this index to check the corresponding character of each string together and compare them\\n- This is easily done using `Array.every`\\n- If all characters at `index i` match, then we add it to our `prefix` result string\\n- As soon as we hit one mismatch, that\\'s the end of the common prefix and we break out of our loop\\n- return prefix at the end, which may be empty\\n\\n# Solution\\n```\\nvar longestCommonPrefix = function(strs) {\\n  if (!strs.length) return \\'\\';\\n  let prefix = \\'\\';\\n  let maxPrefixLength = Math.min(...strs.map(str => str.length));\\n  for (let i = 0; i < maxPrefixLength; i++) {\\n    let char = strs[0][i];\\n    if (strs.every(str => str[i] === char)) {\\n      prefix += char;\\n    } else {\\n      break;\\n    }\\n  };  \\n  return prefix;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestCommonPrefix = function(strs) {\\n  if (!strs.length) return \\'\\';\\n  let prefix = \\'\\';\\n  let maxPrefixLength = Math.min(...strs.map(str => str.length));\\n  for (let i = 0; i < maxPrefixLength; i++) {\\n    let char = strs[0][i];\\n    if (strs.every(str => str[i] === char)) {\\n      prefix += char;\\n    } else {\\n      break;\\n    }\\n  };  \\n  return prefix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1136361,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func longestCommonPrefix(_ strs: [String]) -> String {\\n        \\n        if strs.isEmpty { return \"\" }\\n        var common = strs[0]\\n        \\n        for ch in strs {\\n            while !ch.hasPrefix(common) {\\n                common = String(common.dropLast())\\n            }\\n        }\\n        return common\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.004 (0.006) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.longestCommonPrefix([\"flower\",\"flow\",\"flight\"])\\n        XCTAssertEqual(value, \"fl\")\\n    }\\n    func test1() {\\n        let value = solution.longestCommonPrefix([\"dog\",\"racecar\",\"car\"])\\n        XCTAssertEqual(value, \"\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func longestCommonPrefix(_ strs: [String]) -> String {\\n        \\n        if strs.isEmpty { return \"\" }\\n        var common = strs[0]\\n        \\n        for ch in strs {\\n            while !ch.hasPrefix(common) {\\n                common = String(common.dropLast())\\n            }\\n        }\\n        return common\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.longestCommonPrefix([\"flower\",\"flow\",\"flight\"])\\n        XCTAssertEqual(value, \"fl\")\\n    }\\n    func test1() {\\n        let value = solution.longestCommonPrefix([\"dog\",\"racecar\",\"car\"])\\n        XCTAssertEqual(value, \"\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484683,
                "title": "python-3-beats-97-six-lines",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, S: List[str]) -> str:\\n        if not S: return \\'\\'\\n        m, M, i = min(S), max(S), 0\\n        for i in range(min(len(m),len(M))):\\n            if m[i] != M[i]: break\\n        else: i += 1\\n        return m[:i]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, S: List[str]) -> str:\\n        if not S: return \\'\\'\\n        m, M, i = min(S), max(S), 0\\n        for i in range(min(len(m),len(M))):\\n            if m[i] != M[i]: break\\n        else: i += 1\\n        return m[:i]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 6940,
                "title": "java-we-love-clear-code",
                "content": "    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null) return null;\\n        if (strs.length == 0) return \"\";\\n        \\n        Arrays.sort(strs);\\n        char[] first = strs[0].toCharArray();\\n        char[] last  = strs[strs.length - 1].toCharArray();\\n         \\n        int i = 0, len = Math.min(first.length, last.length);\\n        while (i < len && first[i] == last[i]) i++;\\n        return strs[0].substring(0, i);\\n    }",
                "solutionTags": [],
                "code": "    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null) return null;\\n        if (strs.length == 0) return \"\";\\n        \\n        Arrays.sort(strs);\\n        char[] first = strs[0].toCharArray();\\n        char[] last  = strs[strs.length - 1].toCharArray();\\n         \\n        int i = 0, len = Math.min(first.length, last.length);\\n        while (i < len && first[i] == last[i]) i++;\\n        return strs[0].substring(0, i);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1309953,
                "title": "5-lines-js-solution-beats-99-62-of-js-solutions",
                "content": "The thing is with js we can sort strings and when we sort an array of different strings they will be sorted alphabetically, which means all we left to do is find the common part between the first and the last values in the sorted array. As simple as this:\\n```\\nvar longestCommonPrefix = function(strs) {\\n  strs.sort();\\n  for (let i = 0; i < strs[0].length; i++) {\\n    if (strs[0][i] !== strs[strs.length - 1][i]) return strs[0].substr(0, i);\\n  }\\n  return strs[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nvar longestCommonPrefix = function(strs) {\\n  strs.sort();\\n  for (let i = 0; i < strs[0].length; i++) {\\n    if (strs[0][i] !== strs[strs.length - 1][i]) return strs[0].substr(0, i);\\n  }\\n  return strs[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6926,
                "title": "accepted-c-6-lines-4ms",
                "content": "    class Solution {\\n    public:\\n        string longestCommonPrefix(vector<string>& strs) {\\n            string prefix = \"\";\\n            for(int idx=0; strs.size()>0; prefix+=strs[0][idx], idx++)\\n                for(int i=0; i<strs.size(); i++)\\n                    if(idx >= strs[i].size() ||(i > 0 && strs[i][idx] != strs[i-1][idx]))\\n                        return prefix;\\n            return prefix;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string longestCommonPrefix(vector<string>& strs) {\\n            string prefix = \"\";\\n            for(int idx=0; strs.size()>0; prefix+=strs[0][idx], idx++)\\n                for(int i=0; i<strs.size(); i++)\\n                    if(idx >= strs[i].size() ||(i > 0 && strs[i][idx] != strs[i-1][idx]))\\n                        return prefix;\\n            return prefix;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 120133,
                "title": "simple-javascript-solution",
                "content": "```js\\nfunction longestCommonPrefix(strs) {\\n  if (!strs.length) return \\'\\';\\n  \\n  for (let i = 0; i < strs[0].length; i++) {\\n    for (let str of strs) {\\n      if (str[i] !== strs[0][i]) {\\n        return str.slice(0, i);\\n      }\\n    }\\n  }\\n  \\n  return strs[0];\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction longestCommonPrefix(strs) {\\n  if (!strs.length) return \\'\\';\\n  \\n  for (let i = 0; i < strs[0].length; i++) {\\n    for (let str of strs) {\\n      if (str[i] !== strs[0][i]) {\\n        return str.slice(0, i);\\n      }\\n    }\\n  }\\n  \\n  return strs[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2765214,
                "title": "python-prefix",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        shortest = min(strs,key=len)\\n        for i, ch in enumerate(shortest):\\n            for other in strs:\\n                if other[i] != ch:\\n                    return shortest[:i]\\n        return shortest \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        shortest = min(strs,key=len)\\n        for i, ch in enumerate(shortest):\\n            for other in strs:\\n                if other[i] != ch:\\n                    return shortest[:i]\\n        return shortest \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683825,
                "title": "js-two-approaches-with-explanation-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/10/longest-common-prefix.html\\nIt is very useful, and I just wanted to share it with you.\\n\\n\\n\\n```\\nvar longestCommonPrefix = function (strs) {\\n    // Return early on empty input\\n    if (!strs.length) return \\'\\';\\n\\n    // Loop through the letters of the first word\\n    for (let i = 0; i <= strs[0].length; i++) {\\n        // Check if this character is present in the same position of every string\\n        if (!strs.every((string) => string[i] === strs[0][i])) {\\n            // If not, return the string up to and including the previous character\\n            return strs[0].slice(0, i);\\n        }\\n    }\\n\\n    return strs[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestCommonPrefix = function (strs) {\\n    // Return early on empty input\\n    if (!strs.length) return \\'\\';\\n\\n    // Loop through the letters of the first word\\n    for (let i = 0; i <= strs[0].length; i++) {\\n        // Check if this character is present in the same position of every string\\n        if (!strs.every((string) => string[i] === strs[0][i])) {\\n            // If not, return the string up to and including the previous character\\n            return strs[0].slice(0, i);\\n        }\\n    }\\n\\n    return strs[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7139,
                "title": "my-1ms-java-solution",
                "content": "I have read many solutions but I just add couple of lines. I think finding the shortest string first can make the solution more effective.\\n\\n    public class Solution {\\n        public String longestCommonPrefix(String[] strs) {\\n            if (strs.length < 1 || strs == null) {\\n                return \"\";\\n            }\\n            if (strs.length == 1) {\\n                return strs[0];\\n            }\\n            //find the shortest String\\n            int shortest = 0;\\n            int len = strs[0].length();\\n            for (int i = 1; i < strs.length; i++) {\\n                int curLen = strs[i].length();\\n                if (curLen < len) {\\n                    len = curLen;\\n                    shortest = i;\\n                }\\n            }\\n            //find the longest common prefix\\n            String sub = strs[shortest];\\n            for (int i = 0; i < strs.length; i++) {\\n                while (strs[i].indexOf(sub) != 0) {\\n                    sub = sub.substring(0, sub.length()-1);\\n                }\\n            } \\n            return sub;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String longestCommonPrefix(String[] strs) {\\n            if (strs.length < 1 || strs == null) {\\n                return \"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1621297,
                "title": "python-runtime-94-46-and-memory-81-95",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n\\n        str1, str2 = min(strs), max(strs)\\n        i = 0\\n        while i < len(str1):\\n            if str1[i] != str2[i]:\\n                str1 = str1[:i]\\n            i +=1\\n\\n        return str1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n\\n        str1, str2 = min(strs), max(strs)\\n        i = 0\\n        while i < len(str1):\\n            if str1[i] != str2[i]:\\n                str1 = str1[:i]\\n            i +=1\\n\\n        return str1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339122,
                "title": "simple-c-soluton",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        string ans;\\n        for(int i=0;i<strs[0].size();i++)\\n        {\\n            for(int j=1;j<strs.size();j++)\\n            {\\n                if(strs[0][i] != strs[j][i])\\n                {\\n                    return ans;\\n                }\\n            }\\n            ans += strs[0][i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        string ans;\\n        for(int i=0;i<strs[0].size();i++)\\n        {\\n            for(int j=1;j<strs.size();j++)\\n            {\\n                if(strs[0][i] != strs[j][i])\\n                {\\n                    return ans;\\n                }\\n            }\\n            ans += strs[0][i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7138,
                "title": "5-line-python-with-zip-and-len-set",
                "content": "Just for fun :)\\n\\n    class Solution(object):\\n        def longestCommonPrefix(self, strs):\\n            \"\"\"\\n            :type strs: List[str]; rtype: str\\n            \"\"\"\\n            sz, ret = zip(*strs), \"\"\\n            # looping corrected based on @StefanPochmann's comment below\\n            for c in sz:\\n                if len(set(c)) > 1: break\\n                ret += c[0]\\n            return ret",
                "solutionTags": [
                    "Python"
                ],
                "code": "Just for fun :)\\n\\n    class Solution(object):\\n        def longestCommonPrefix(self, strs):\\n            \"\"\"\\n            :type strs: List[str]; rtype: str\\n            \"\"\"\\n            sz, ret = zip(*strs), \"\"\\n            # looping corrected based on @StefanPochmann's comment below\\n            for c in sz:\\n                if len(set(c)) > 1: break\\n                ret += c[0]\\n            return ret",
                "codeTag": "Java"
            },
            {
                "id": 6946,
                "title": "fast-and-simple-java-code-231ms",
                "content": "    public class Solution {\\n        public String longestCommonPrefix(List<String> strs) {\\n            if(strs.size()==0) return \"\";\\n            StringBuilder lcp=new StringBuilder();\\n            for(int i=0;i<strs.get(0).length();i++){\\n                char c=strs.get(0).charAt(i);\\n                for(String s:strs){\\n                    if(s.length()<i+1||c!=s.charAt(i)) return lcp.toString();\\n                }\\n                lcp.append(c);\\n            }\\n            return lcp.toString();\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String longestCommonPrefix(List<String> strs) {\\n            if(strs.size()==0) return \"\";\\n            StringBuilder lcp=new StringBuilder();\\n            for(int i=0;i<strs.get(0).length();i++){\\n                char c=strs.get(0).charAt(i);\\n                for(String s:strs){\\n                    if(s.length()<i+1||c!=s.charAt(i)) return lcp.toString();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3512602,
                "title": "c-java-python-javascript-fully-explained",
                "content": "# Intuition:\\nThe idea behind this solution is to start with the first string in the vector `strs` and consider it as the initial common prefix. Then, iterate through the remaining strings and continuously update the common prefix by removing characters from the end until the common prefix is found in the current string at the beginning. If the common prefix becomes empty at any point, it means there is no common prefix among the strings, so we return an empty string.\\n\\n# Approach:\\n1. Check if the vector `strs` is empty. If it is, there are no strings to compare, so we return an empty string.\\n2. Initialize a string variable `ans` with the first string in `strs`. This will be our initial common prefix.\\n3. Iterate through the remaining strings starting from the second string.\\n4. Inside the loop, use a while loop to check if the current string does not start with the current `ans`.\\n5. If the current string does not start with `ans`, remove the last character from `ans` by using the `substr` function and updating it to `ans.substr(0, ans.length() - 1)`.\\n6. Check if `ans` becomes empty after removing the character. If it does, it means there is no common prefix among the strings, so we return an empty string.\\n7. Repeat steps 4-6 until the current string starts with `ans`.\\n8. After the loop ends, the value of `ans` will be the longest common prefix among all the strings. Return `ans`.\\n\\n# Complexity:\\n- Time complexity: O(n), where n is the total number of characters in all the strings combined. This is because we iterate through each character of the strings to find the common prefix.\\n- Space complexity: O(1) because we are using a constant amount of space to store the common prefix (`ans`) and the loop variables.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.size()==0){\\n            return \"\";\\n        }\\n        string ans=strs[0];\\n        for(int i=1;i<strs.size();i++){\\n            while(strs[i].find(ans) != 0 ){\\n                cout<< ans.substr(0,ans.length() -1)<<endl;\\n                ans  = ans.substr(0,ans.length() -1);\\n                if(ans.empty()){\\n                    return \"\";\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs.length == 0) {\\n            return \"\";\\n        }\\n        String ans = strs[0];\\n        for (int i = 1; i < strs.length; i++) {\\n            while (strs[i].indexOf(ans) != 0) {\\n                ans = ans.substring(0, ans.length() - 1);\\n                if (ans.isEmpty()) {\\n                    return \"\";\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n---\\n\\n# Python\\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \\'\\'\\n        ans = strs[0]\\n        for i in range(1, len(strs)):\\n            while ans != strs[i][:len(ans)]:\\n                ans = ans[:-1]\\n                if ans == \\'\\':\\n                    return \\'\\'\\n        return ans\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar longestCommonPrefix = function(strs) {\\n    if (strs.length === 0) {\\n        return \\'\\';\\n    }\\n    let ans = strs[0];\\n    for (let i = 1; i < strs.length; i++) {\\n        while (strs[i].indexOf(ans) !== 0) {\\n            ans = ans.substring(0, ans.length - 1);\\n            if (ans === \\'\\') {\\n                return \\'\\';\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.size()==0){\\n            return \"\";\\n        }\\n        string ans=strs[0];\\n        for(int i=1;i<strs.size();i++){\\n            while(strs[i].find(ans) != 0 ){\\n                cout<< ans.substr(0,ans.length() -1)<<endl;\\n                ans  = ans.substr(0,ans.length() -1);\\n                if(ans.empty()){\\n                    return \"\";\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs.length == 0) {\\n            return \"\";\\n        }\\n        String ans = strs[0];\\n        for (int i = 1; i < strs.length; i++) {\\n            while (strs[i].indexOf(ans) != 0) {\\n                ans = ans.substring(0, ans.length() - 1);\\n                if (ans.isEmpty()) {\\n                    return \"\";\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \\'\\'\\n        ans = strs[0]\\n        for i in range(1, len(strs)):\\n            while ans != strs[i][:len(ans)]:\\n                ans = ans[:-1]\\n                if ans == \\'\\':\\n                    return \\'\\'\\n        return ans\\n\\n```\n```\\nvar longestCommonPrefix = function(strs) {\\n    if (strs.length === 0) {\\n        return \\'\\';\\n    }\\n    let ans = strs[0];\\n    for (let i = 1; i < strs.length; i++) {\\n        while (strs[i].indexOf(ans) !== 0) {\\n            ans = ans.substring(0, ans.length - 1);\\n            if (ans === \\'\\') {\\n                return \\'\\';\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1869031,
                "title": "c-0ms",
                "content": "\\tchar *longestCommonPrefix(char **strs, int strsSize)\\n\\t{\\n\\t\\tfor(int c=0;; ++c)\\n\\t\\t{\\n\\t\\t\\tif(strs[0][c] == \\'\\\\0\\') // the longest common prefix is the first string\\n\\t\\t\\t\\treturn strs[0];\\n\\t\\t\\tfor(int s=1; s<strsSize; ++s)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(strs[s][c] != strs[0][c]) // compare all strings character to the first one\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstrs[0][c] = \\'\\\\0\\'; // replace the current character with \\'\\\\0\\'\\n\\t\\t\\t\\t\\treturn strs[0];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tchar *longestCommonPrefix(char **strs, int strsSize)\\n\\t{\\n\\t\\tfor(int c=0;; ++c)\\n\\t\\t{\\n\\t\\t\\tif(strs[0][c] == \\'\\\\0\\') // the longest common prefix is the first string\\n\\t\\t\\t\\treturn strs[0];\\n\\t\\t\\tfor(int s=1; s<strsSize; ++s)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(strs[s][c] != strs[0][c]) // compare all strings character to the first one\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstrs[0][c] = \\'\\\\0\\'; // replace the current character with \\'\\\\0\\'\\n\\t\\t\\t\\t\\treturn strs[0];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 221978,
                "title": "javascript",
                "content": "```\\nvar longestCommonPrefix = function(strs) {\\n  if (strs.length === 0) return \\'\\';\\n  let r = \\'\\';\\n  for (let i = 0; i < strs[0].length; i++) {\\n    for (let j = 1; j < strs.length; j++) {\\n      if (strs[0][i] !== strs[j][i]) return r;\\n    }\\n    r += strs[0][i];\\n  }\\n  return r;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar longestCommonPrefix = function(strs) {\\n  if (strs.length === 0) return \\'\\';\\n  let r = \\'\\';\\n  for (let i = 0; i < strs[0].length; i++) {\\n    for (let j = 1; j < strs.length; j++) {\\n      if (strs[0][i] !== strs[j][i]) return r;\\n    }\\n    r += strs[0][i];\\n  }\\n  return r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2869179,
                "title": "python-99-faster-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str: #// strs = [\"flower\",\"flow\",\"flight\"]\\n        short = min(strs, key=len) #// short = \"flow\"\\n        for item in strs: #// When item = \"flight\"\\n            while len(short) > 0:\\n                if item.startswith(short): #// during loop 1 condition fails, during loop 2 condition fails, during loop 3 \"flight\" startswith fl is True\\n                    break\\n                else:\\n                    short = short[:-1] #// during loop 1 short = flo, during loop 2 short = fl\\n        return short\\n```\\n![leet.png](https://assets.leetcode.com/users/images/957926b9-2e91-4aca-bda2-0c413ba34ea2_1669969069.6613681.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str: #// strs = [\"flower\",\"flow\",\"flight\"]\\n        short = min(strs, key=len) #// short = \"flow\"\\n        for item in strs: #// When item = \"flight\"\\n            while len(short) > 0:\\n                if item.startswith(short): #// during loop 1 condition fails, during loop 2 condition fails, during loop 3 \"flight\" startswith fl is True\\n                    break\\n                else:\\n                    short = short[:-1] #// during loop 1 short = flo, during loop 2 short = fl\\n        return short\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763488,
                "title": "rust-0ms-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Longest Common Prefix.\\nMemory Usage: 2.2 MB, less than 60.00% of Rust online submissions for Longest Common Prefix.\\n```\\nimpl Solution {\\n    pub fn longest_common_prefix(strs: Vec<String>) -> String { \\n        match strs.is_empty() {\\n            true => \"\".to_string(),\\n            _ => {\\n                strs.iter().skip(1).fold(strs[0].clone(), |acc, x| {\\n                     acc\\n                        .chars()\\n                        .zip(x.chars())\\n                        .take_while(|(x,y)| x == y)\\n                        .map(|(x, _)| x)\\n                        .collect()\\n                })\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn longest_common_prefix(strs: Vec<String>) -> String { \\n        match strs.is_empty() {\\n            true => \"\".to_string(),\\n            _ => {\\n                strs.iter().skip(1).fold(strs[0].clone(), |acc, x| {\\n                     acc\\n                        .chars()\\n                        .zip(x.chars())\\n                        .take_while(|(x,y)| x == y)\\n                        .map(|(x, _)| x)\\n                        .collect()\\n                })\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 801411,
                "title": "javascript-clean-solution",
                "content": "```javascript\\nvar longestCommonPrefix = function(strs) {\\n    if(!strs.length) return \\'\\';\\n    \\n    for(let i = 0; i < strs[0].length; i++) {\\n        for(let s of strs) {\\n            if(s[i] !== strs[0][i]) return s.slice(0, i);\\n        }\\n    }\\n    return strs[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar longestCommonPrefix = function(strs) {\\n    if(!strs.length) return \\'\\';\\n    \\n    for(let i = 0; i < strs[0].length; i++) {\\n        for(let s of strs) {\\n            if(s[i] !== strs[0][i]) return s.slice(0, i);\\n        }\\n    }\\n    return strs[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 798212,
                "title": "fastest-python-solution-longest-common-prefix",
                "content": "\\n```\\nstr=[\"flower\",\"flow\",\"flight\"]\\n\\nafter zip(*strs)\\n\\n[(\\'f\\', \\'f\\', \\'f\\'), (\\'l\\', \\'l\\', \\'l\\'), (\\'o\\', \\'o\\', \\'i\\'), (\\'w\\', \\'w\\', \\'g\\')]\\n\\ntaken first set\\n\\nlen(set( \"f\",\"f\",\"f\"))=1\\n\\nand taken 3\\nlen(set(\"o\",\"o\",\"i\"))=2\\n\\n```\\n\\n```\\n\\nprefix=[]\\n        num = len(strs)\\n        for x in zip(*strs):\\n            if len(set(x)) == 1:\\n                prefix.append(x[0])\\n            else:\\n                break\\n        return \"\".join(prefix) \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nstr=[\"flower\",\"flow\",\"flight\"]\\n\\nafter zip(*strs)\\n\\n[(\\'f\\', \\'f\\', \\'f\\'), (\\'l\\', \\'l\\', \\'l\\'), (\\'o\\', \\'o\\', \\'i\\'), (\\'w\\', \\'w\\', \\'g\\')]\\n\\ntaken first set\\n\\nlen(set( \"f\",\"f\",\"f\"))=1\\n\\nand taken 3\\nlen(set(\"o\",\"o\",\"i\"))=2\\n\\n```\n```\\n\\nprefix=[]\\n        num = len(strs)\\n        for x in zip(*strs):\\n            if len(set(x)) == 1:\\n                prefix.append(x[0])\\n            else:\\n                break\\n        return \"\".join(prefix) \\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323909,
                "title": "python-simple-solution-implementing-vertical-scanning",
                "content": "```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        result = []\\n\\t\\t# Create one iterator per string using zip, it will stop at the shortest string\\n\\t\\t# s is a tuple of characters at current position for each string\\n\\t\\t# create a set to test unicity\\n        for s in zip(*strs):\\n            if len(set(s)) != 1:\\n                break\\n            result.append(s[0])\\n        return \"\".join(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        result = []\\n\\t\\t# Create one iterator per string using zip, it will stop at the shortest string\\n\\t\\t# s is a tuple of characters at current position for each string\\n\\t\\t# create a set to test unicity\\n        for s in zip(*strs):\\n            if len(set(s)) != 1:\\n                break\\n            result.append(s[0])\\n        return \"\".join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244957,
                "title": "idiomatic-and-elegant-rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn longest_common_prefix(input: Vec<String>) -> String {\\n        input.into_iter().reduce(|acc,cur|{\\n            acc.chars()\\n               .zip(cur.chars())\\n               .take_while(|(a,c)| a== c)\\n               .map(|(c,_)|c)\\n               .collect()\\n        }).unwrap()\\n    }\\n}\\n```\\n\\n# Intuition\\nThe longest common prefix (LCP) between `input[i+1]` and `input[i+2]` will always be as short or shorter than between `input[i]` and `input[i+1]`.\\nThis means this problem (taking as example input `[\"flight\",\"flow\",\"flip\"]`) can be solved like: `LCP(\"flat\",LCP(\"flip\",LCP(\"flow\", \"flight\")))`. \\nThe recursive call of an operation on the previous result of that operation is a classic example of [Iterator::reduce](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.reduce)\\n\\n# Approach\\n1. Apply reduce on the input\\n2. `acc` starts out as the first string in input.\\n3. `cur` starts out as the second string, and will become each string as we iterate through the input\\n4. zip `acc` and `cur`. This will create an iterator over tuples representing pairs of `acc[i]`, `cur[i]`. It will clip the longest one to the size of the shortest.\\n5. take as many chars as possible while they are equal in each zipped string\\n6. forget about one element of the tuple, in order to have an iterator over `char`\\n7. `collect` it into a `String` and return it from the closure. This will be `acc` argument in the next iteration\\n8. after the iteration, the final `acc` value will be returned. `unwrap` is necessary because `reduce` returns an `Option`\\n# Complexity\\n- Time complexity:\\n**O(n*s)**, where s is the shortest LCP so far.\\n- Space complexity:\\n**O(1)**\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn longest_common_prefix(input: Vec<String>) -> String {\\n        input.into_iter().reduce(|acc,cur|{\\n            acc.chars()\\n               .zip(cur.chars())\\n               .take_while(|(a,c)| a== c)\\n               .map(|(c,_)|c)\\n               .collect()\\n        }).unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517792,
                "title": "simple-go-solution",
                "content": "```\\nfunc longestCommonPrefix(strs []string) string {\\n    p := strs[0]\\n    for _, s := range strs {\\n        i := 0\\n        for ; i < len(s) && i < len(p) && p[i] == s[i]; i++ {}\\n        p = p[:i]\\n    }\\n    return p\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestCommonPrefix(strs []string) string {\\n    p := strs[0]\\n    for _, s := range strs {\\n        i := 0\\n        for ; i < len(s) && i < len(p) && p[i] == s[i]; i++ {}\\n        p = p[:i]\\n    }\\n    return p\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3160852,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\nSimple solution using startsWith JavaScript method\\n\\n# Complexity\\n- Time complexity: 60ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 41.8MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(arr) {\\n    let i = 1;\\n    let prf = arr[0];\\n    while(i < arr.length){\\n        if(!arr[i].startsWith(prf)){\\n            prf = prf.slice(0, -1)\\n        }else{\\n            i++\\n        }\\n    }\\n    return prf\\n\\n\\n};\\n\\n// \"\"\\n//\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(arr) {\\n    let i = 1;\\n    let prf = arr[0];\\n    while(i < arr.length){\\n        if(!arr[i].startsWith(prf)){\\n            prf = prf.slice(0, -1)\\n        }else{\\n            i++\\n        }\\n    }\\n    return prf\\n\\n\\n};\\n\\n// \"\"\\n//\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1422342,
                "title": "python-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef longestCommonPrefix(self, lst: List[str]) -> str:\\n\\t\\t\\tans = \"\"\\n\\t\\t\\tfor i in zip(*lst):\\n\\t\\t\\t\\tp = \"\".join(i)\\n\\t\\t\\t\\tif len(set(p)) != 1:\\n\\t\\t\\t\\t\\treturn (ans)\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans += p[0]\\n\\n\\t\\t\\treturn (ans)\\n\\t\\t\\t\\n# if you like the solution, Please upvote!!\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef longestCommonPrefix(self, lst: List[str]) -> str:\\n\\t\\t\\tans = \"\"\\n\\t\\t\\tfor i in zip(*lst):\\n\\t\\t\\t\\tp = \"\".join(i)\\n\\t\\t\\t\\tif len(set(p)) != 1:\\n\\t\\t\\t\\t\\treturn (ans)\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans += p[0]\\n\\n\\t\\t\\treturn (ans)\\n\\t\\t\\t\\n# if you like the solution, Please upvote!!\\n",
                "codeTag": "Java"
            },
            {
                "id": 1336046,
                "title": "python-horizontal-scanning",
                "content": "I got this question in an interview recently. I solved it using the most voted Python approach. [Link](https://leetcode.com/problems/longest-common-prefix/discuss/6918/Short-Python-Solution)\\nHowever, the interviewer told me that this solution isn\\'t the most optimized because it checks each character once if the two words aren\\'t the same. I told him I can whip a Trie solution, and he said that is an overkill. Finally, I came up with this solution which is scanning it horizontally. Hope it can help someone else out there. \\n\\n```\\nclass Solution: \\n\\tdef longestCommonPrefix(self, words: List[str]) -> str: \\n\\t\\tprefix = words[0]\\n\\t\\tfor word in words[1:]: \\n\\t\\t\\t# keep looping and current word sliced to len of prefix == prefix\\n\\t\\t\\twhile word[:len(prefix)] != prefix: \\n\\t\\t\\t\\tprefix = prefix[:-1]\\n\\t\\t\\t\\t# Covers edge case: if two words don\\'t have any similar characters\\n\\t\\t\\t\\tif not prefix: \\n\\t\\t\\t\\t\\treturn \"\"\\n\\t\\treturn prefix",
                "solutionTags": [
                    "Python"
                ],
                "code": "I got this question in an interview recently. I solved it using the most voted Python approach. [Link](https://leetcode.com/problems/longest-common-prefix/discuss/6918/Short-Python-Solution)\\nHowever, the interviewer told me that this solution isn\\'t the most optimized because it checks each character once if the two words aren\\'t the same. I told him I can whip a Trie solution, and he said that is an overkill. Finally, I came up with this solution which is scanning it horizontally. Hope it can help someone else out there. \\n\\n```\\nclass Solution: \\n\\tdef longestCommonPrefix(self, words: List[str]) -> str: \\n\\t\\tprefix = words[0]\\n\\t\\tfor word in words[1:]: \\n\\t\\t\\t# keep looping and current word sliced to len of prefix == prefix\\n\\t\\t\\twhile word[:len(prefix)] != prefix: \\n\\t\\t\\t\\tprefix = prefix[:-1]\\n\\t\\t\\t\\t# Covers edge case: if two words don\\'t have any similar characters\\n\\t\\t\\t\\tif not prefix: \\n\\t\\t\\t\\t\\treturn \"\"\\n\\t\\treturn prefix",
                "codeTag": "Java"
            },
            {
                "id": 3168831,
                "title": "python-80-simple-find-max-and-min-words",
                "content": "# Approach\\nImagine that all the words are ordered. Similar words will be next to each other (because of the lexicographic order). Then we need to compare the prefixes of the first and last word. So we need the maximum and minimum word.\\n\\nSee comments in the code.\\n\\n\\uD83D\\uDC49 [Explanation with an example in the comments](https://leetcode.com/problems/longest-common-prefix/solutions/3168831/python-80-simple-find-max-and-min-words/comments/1804509)\\n\\n**\\u2764\\uFE0F Please upvote if you liked this approach**\\n\\n# Complexity\\n- Time complexity: $$O(max(n, min(len(minWord), len(maxWord))))$$\\n\\nFinding max and min word: $$O(n)$$\\nLoop with i < N: $$O(min(len(minWord), len(maxWord)))$$\\nThus, we have to take the max from them.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        # this will be an answer\\n        pref = \\'\\'        \\n        # find min and max words among strs\\n        minWord = min(strs)\\n        maxWord = max(strs)\\n\\n        # for iteration\\n        i = 0\\n        N = min(len(minWord), len(maxWord))\\n        \\n        while i < N:\\n            # if chars are equal\\n            if minWord[i] == maxWord[i]:\\n                # add this char to the answer\\n                pref += minWord[i]\\n            else:\\n                # if not, break\\n                break\\n            i += 1\\n\\n        return pref\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        # this will be an answer\\n        pref = \\'\\'        \\n        # find min and max words among strs\\n        minWord = min(strs)\\n        maxWord = max(strs)\\n\\n        # for iteration\\n        i = 0\\n        N = min(len(minWord), len(maxWord))\\n        \\n        while i < N:\\n            # if chars are equal\\n            if minWord[i] == maxWord[i]:\\n                # add this char to the answer\\n                pref += minWord[i]\\n            else:\\n                # if not, break\\n                break\\n            i += 1\\n\\n        return pref\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204779,
                "title": "python-trie-clean-implementation",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.end = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def add_word(self, word):\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.end = True\\n    \\n    def longest_prefix(self):\\n        res = []\\n        cur = self.root\\n        while cur:\\n            # return when reaches the end of word or when there are more than 1 branches\\n            if cur.end or len(cur.children) > 1:\\n                return \\'\\'.join(res)\\n            c = list(cur.children)[0]\\n            res.append(c)\\n            cur = cur.children[c]\\n        return \\'\\'.join(res)\\n        \\nclass Solution:\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        if not strs:\\n            return \\'\\'\\n        T = Trie()\\n        for s in strs:\\n            T.add_word(s)\\n        return T.longest_prefix()\\n```\\n\\nTime complexity:\\n- building Trie: O(N\\\\*len(s)) where N = len(strs) and s is the longest word in strs\\n- finding longest prefix: O(M) where M is the length of LCP (which is in the range of 0 and the length of shortest string)",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.end = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def add_word(self, word):\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.end = True\\n    \\n    def longest_prefix(self):\\n        res = []\\n        cur = self.root\\n        while cur:\\n            # return when reaches the end of word or when there are more than 1 branches\\n            if cur.end or len(cur.children) > 1:\\n                return \\'\\'.join(res)\\n            c = list(cur.children)[0]\\n            res.append(c)\\n            cur = cur.children[c]\\n        return \\'\\'.join(res)\\n        \\nclass Solution:\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        if not strs:\\n            return \\'\\'\\n        T = Trie()\\n        for s in strs:\\n            T.add_word(s)\\n        return T.longest_prefix()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087422,
                "title": "python-brilliant-approach-taught-by-my-bf-xd",
                "content": "# Intuition\\n**EDIT** - Earlier I used sorting, which took O(M * NLOGN) complexity.Instead we can use min() and max() , which takes O(N*M) time.complexity. (N is no.of elements in the array and M is size of the string)\\n\\nIf you sort the given array (lexicographically), the **first** and **last** word will be the least similar (i.e, they vary the most)\\n- It is enough if you find the common prefix between the **first** and **last** word ( need not consider other words in the array )\\n\\n**Example:** arr = [\"aad\",\"aaf\", \"aaaa\", \"af\"]\\n1) Sorted arr is [\"aaaa\", \"aad\", \"aaf\", \"af\"]\\n2) *first* = \"aaaa\", *last* = \"af\"\\n3) Common prefix of *first* and *last* is ans = \"a\"\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) **Sort** the given array\\n2) Take the **first** and **last** word of the array\\n3) Find the common **prefix** of the first and last word\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*M) - since use min() and max() in python, where N is no.of elements in the array and M is size of the string\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) -  no extra space is used\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        first, last = min(strs), max(strs)\\n        prefix = \\'\\'\\n        for ind in range(min(len(first), len(last))):\\n            if first[ind] != last[ind]:\\n                break\\n            prefix += first[ind]\\n\\n        return prefix\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        first, last = min(strs), max(strs)\\n        prefix = \\'\\'\\n        for ind in range(min(len(first), len(last))):\\n            if first[ind] != last[ind]:\\n                break\\n            prefix += first[ind]\\n\\n        return prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981733,
                "title": "concise-and-easy-solutions-with-trivial-linq",
                "content": "1. Get the shortest word\\n2. Make sure that each of its characters can be found in every other word in the same place.\\n  a. If not, return what you have checked so far.\\n  b. If yes, go on.\\n\\nShort solution:\\n```csharp\\npublic class Solution\\n{\\n    public string LongestCommonPrefix(string[] ss)\\n    {\\n        string shortest = ss.OrderBy(s => s.Length).First();\\n\\n        for (int i = 0; i < shortest.Length; i++)\\n        {\\n            if (ss.Select(s => s[i]).Distinct().Count() > 1) return shortest[..i];\\n        }\\n\\n        return shortest;\\n    }\\n}\\n```\\n\\nAnother one, with `StringBuilder`:\\n```csharp\\npublic class Solution\\n{\\n    public string LongestCommonPrefix(string[] ss)\\n    {\\n        int i = 0;\\n        StringBuilder sb = new();\\n        string shortest = ss.OrderBy(s => s.Length).First();\\n\\n        foreach (char c in shortest)\\n        {\\n            if (ss.Any(s => s[i] != c)) break;\\n            sb.Append(c);\\n            i++;\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```\\n\\nWe can get rid of the explicit declaration of `i` by using LINQ/tuples:\\n```csharp\\npublic class Solution\\n{\\n    public string LongestCommonPrefix(string[] ss)\\n    {\\n        StringBuilder sb = new();\\n        string shortest = ss.OrderBy(s => s.Length).First();\\n\\n        foreach (var (c, i) in shortest.Select((c, i) => (c, i)))\\n        {\\n            if (ss.Any(s => s[i] != c)) break;\\n            sb.Append(c);\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public string LongestCommonPrefix(string[] ss)\\n    {\\n        string shortest = ss.OrderBy(s => s.Length).First();\\n\\n        for (int i = 0; i < shortest.Length; i++)\\n        {\\n            if (ss.Select(s => s[i]).Distinct().Count() > 1) return shortest[..i];\\n        }\\n\\n        return shortest;\\n    }\\n}\\n```\n```csharp\\npublic class Solution\\n{\\n    public string LongestCommonPrefix(string[] ss)\\n    {\\n        int i = 0;\\n        StringBuilder sb = new();\\n        string shortest = ss.OrderBy(s => s.Length).First();\\n\\n        foreach (char c in shortest)\\n        {\\n            if (ss.Any(s => s[i] != c)) break;\\n            sb.Append(c);\\n            i++;\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```\n```csharp\\npublic class Solution\\n{\\n    public string LongestCommonPrefix(string[] ss)\\n    {\\n        StringBuilder sb = new();\\n        string shortest = ss.OrderBy(s => s.Length).First();\\n\\n        foreach (var (c, i) in shortest.Select((c, i) => (c, i)))\\n        {\\n            if (ss.Any(s => s[i] != c)) break;\\n            sb.Append(c);\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292303,
                "title": "c-straightforward",
                "content": "```\\npublic class Solution {\\n    public string LongestCommonPrefix(string[] strs) {\\n        if (strs.Length == 0 || Array.IndexOf(strs, \"\") != -1)\\n            return \"\";\\n        string res = strs[0];\\n        int i = res.Length;\\n        foreach (string word in strs) {\\n            int j = 0;\\n            foreach (char c in word) {\\n                if (j >= i || res[j] != c)\\n                    break;\\n                j += 1;\\n            }\\n            i = Math.Min(i, j);\\n        }\\n        return res.Substring(0, i);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string LongestCommonPrefix(string[] strs) {\\n        if (strs.Length == 0 || Array.IndexOf(strs, \"\") != -1)\\n            return \"\";\\n        string res = strs[0];\\n        int i = res.Length;\\n        foreach (string word in strs) {\\n            int j = 0;\\n            foreach (char c in word) {\\n                if (j >= i || res[j] != c)\\n                    break;\\n                j += 1;\\n            }\\n            i = Math.Min(i, j);\\n        }\\n        return res.Substring(0, i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291991,
                "title": "using-simple-str-sort-method-5-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfind the min length str and or write in the sorting \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we use str.sort method becuse its sorting by alphabetical order\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nsort method Time Colplexity \\nO(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1);\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    // sort the array because its rearrange alphabetical order\\n   strs.sort();\\n\\n\\n  for (let i = 0; i < strs[0].length; i++) {\\n    if (strs[0][i] !== strs[strs.length - 1][i]){\\nreturn strs[0].substr(0, i);\\n    } \\n  }\\n\\n  return strs[0];  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    // sort the array because its rearrange alphabetical order\\n   strs.sort();\\n\\n\\n  for (let i = 0; i < strs[0].length; i++) {\\n    if (strs[0][i] !== strs[strs.length - 1][i]){\\nreturn strs[0].substr(0, i);\\n    } \\n  }\\n\\n  return strs[0];  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2516139,
                "title": "simple-python-solution-with-zip-and-set",
                "content": "`zip(*strs)` Iterate over all words in parallel, producing tuples with an letter from each one.  It will stop iteration on the shortest word. \\n\\n```\\n>>> list(zip(*[\"flower\",\"flow\",\"flight\"]))\\n[\\n(\\'f\\', \\'f\\', \\'f\\'),\\n(\\'l\\', \\'l\\', \\'l\\'),\\n(\\'o\\', \\'o\\', \\'i\\'), \\n(\\'w\\', \\'w\\', \\'g\\')\\n]\\n```\\n\\n\\n```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        match = 0\\n        \\n        for vals in zip(*strs):\\n            if len(set(vals)) == 1:\\n                match += 1\\n            else:\\n                break\\n        \\n        return strs[0][:match]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n>>> list(zip(*[\"flower\",\"flow\",\"flight\"]))\\n[\\n(\\'f\\', \\'f\\', \\'f\\'),\\n(\\'l\\', \\'l\\', \\'l\\'),\\n(\\'o\\', \\'o\\', \\'i\\'), \\n(\\'w\\', \\'w\\', \\'g\\')\\n]\\n```\n```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        match = 0\\n        \\n        for vals in zip(*strs):\\n            if len(set(vals)) == 1:\\n                match += 1\\n            else:\\n                break\\n        \\n        return strs[0][:match]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 587345,
                "title": "c-easy-solution-4ms",
                "content": "```\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string ans=\"\";\\n        int n=strs.size();\\n        if(n==0)\\n            return ans;\\n        int l=strs[0].length();\\n        for(string s:strs)\\n            if(l>s.length())\\n                l=s.length();\\n        int index=0;\\n        for(char c:strs[0])\\n        {\\n            for(int i=1;i<n;i++)\\n            {\\n                if(strs[i][index]!=c||index>l)\\n                    return ans;\\n            }\\n            ans+=c;\\n            index++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string ans=\"\";\\n        int n=strs.size();\\n        if(n==0)\\n            return ans;\\n        int l=strs[0].length();\\n        for(string s:strs)\\n            if(l>s.length())\\n                l=s.length();\\n        int index=0;\\n        for(char c:strs[0])\\n        {\\n            for(int i=1;i<n;i++)\\n            {\\n                if(strs[i][index]!=c||index>l)\\n                    return ans;\\n            }\\n            ans+=c;\\n            index++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 561757,
                "title": "c-memory-and-runtime-efficient-2-solutions-1-greedy-1-trie-implementation",
                "content": "**Greedy**\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.size() == 0) return \"\";\\n        if(strs.size() == 1) return strs[0];\\n        \\n        int small = INT_MAX;\\n        bool flag = true;\\n        string retStr;\\n        \\n        for(auto str : strs) if(str.length() < small) small = str.length();\\n        \\n        while(small != 0){\\n            flag = true;\\n            for(int i = 0; i < strs.size() - 1; i++){\\n                if(strs[i].substr(0, small) != strs[i + 1].substr(0, small)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                return strs[0].substr(0, small);\\n            }\\n            small--;\\n        }\\n        \\n        return retStr; \\n    }\\n};\\n```\\n\\n**Trie Implementation**\\n```\\nclass TrieNode{\\npublic:\\n    unordered_map<char, TrieNode*> children;\\n    char val;\\n    bool isWord = false;\\n    \\n    TrieNode(){}\\n    \\n    TrieNode(char v){\\n        this->val = v;\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    TrieNode* root;\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    /* Get TrieNode. */\\n    TrieNode* getTrieNode(){\\n        return root;\\n    }\\n    \\n    /** Inserts a word into the trie. */\\n    void insert(string word) {\\n        TrieNode* temp = root;\\n        \\n        for(auto ch : word){\\n            if(temp->children.find(ch) == temp->children.end()){\\n                temp->children[ch] = new TrieNode(ch);\\n            }     \\n            temp = temp->children[ch];\\n        }\\n        \\n        temp->isWord = true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        // insert all keys into trie\\n        Trie* pTrie = new Trie();\\n        \\n        for (string str : strs) { pTrie->insert(str); }\\n\\n        // Traverse the trie and find Longest Common Prefix\\n        string lcp(\"\");\\n        TrieNode* curr = pTrie->getTrieNode();\\n\\n        // Do till we find a leaf node or node has more than 1 children\\n        while (curr && !curr->isWord && (curr->children.size() == 1))\\n        {\\n            auto it = curr->children.begin();\\n            lcp += it->first;\\n            curr = it->second;\\n        }\\n\\n        return lcp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.size() == 0) return \"\";\\n        if(strs.size() == 1) return strs[0];\\n        \\n        int small = INT_MAX;\\n        bool flag = true;\\n        string retStr;\\n        \\n        for(auto str : strs) if(str.length() < small) small = str.length();\\n        \\n        while(small != 0){\\n            flag = true;\\n            for(int i = 0; i < strs.size() - 1; i++){\\n                if(strs[i].substr(0, small) != strs[i + 1].substr(0, small)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                return strs[0].substr(0, small);\\n            }\\n            small--;\\n        }\\n        \\n        return retStr; \\n    }\\n};\\n```\n```\\nclass TrieNode{\\npublic:\\n    unordered_map<char, TrieNode*> children;\\n    char val;\\n    bool isWord = false;\\n    \\n    TrieNode(){}\\n    \\n    TrieNode(char v){\\n        this->val = v;\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    TrieNode* root;\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    /* Get TrieNode. */\\n    TrieNode* getTrieNode(){\\n        return root;\\n    }\\n    \\n    /** Inserts a word into the trie. */\\n    void insert(string word) {\\n        TrieNode* temp = root;\\n        \\n        for(auto ch : word){\\n            if(temp->children.find(ch) == temp->children.end()){\\n                temp->children[ch] = new TrieNode(ch);\\n            }     \\n            temp = temp->children[ch];\\n        }\\n        \\n        temp->isWord = true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        // insert all keys into trie\\n        Trie* pTrie = new Trie();\\n        \\n        for (string str : strs) { pTrie->insert(str); }\\n\\n        // Traverse the trie and find Longest Common Prefix\\n        string lcp(\"\");\\n        TrieNode* curr = pTrie->getTrieNode();\\n\\n        // Do till we find a leaf node or node has more than 1 children\\n        while (curr && !curr->isWord && (curr->children.size() == 1))\\n        {\\n            auto it = curr->children.begin();\\n            lcp += it->first;\\n            curr = it->second;\\n        }\\n\\n        return lcp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 397075,
                "title": "java-o-n-log-n",
                "content": "// 1) sort the array. this way if you have [\"hall\", \"hallow\", \"hat\"]\\n// it would sort it so that hat is first and hallow is last\\n// 2) Compare only first and last element. Because the longest posssible prefix will\\n// be at the end and the shorest possible prefix will be in the begining\\n// 3) convert first and last element to char array\\n// 4) loop through first elemnt comparing each value to last element value\\n// 5)Make sure that when looping you do not go-out-of-bounds for the last element\\n// 6) if it is equal then append it to a string builder\\n// if it is not equal immediately return the result\\n\\n```\\nimport  java.util.*;\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if (strs == null || strs.length == 0) {\\n            return \"\";\\n        }\\n        // 1) string builder\\n        StringBuilder result = new StringBuilder();\\n        \\n        // Sort array\\n        Arrays.sort(strs);\\n        \\n        // split first and last to char\\n        char[] first = strs[0].toCharArray();\\n        char[] last = strs[strs.length - 1 ].toCharArray();\\n        \\n        // loop through\\n        for (int i = 0; i < first.length && i < last.length; i++) {\\n            if (first[i] == last[i]) {\\n                result.append(first[i]);                \\n            }\\n            else\\n                return result.toString();\\n        }\\n        return result.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport  java.util.*;\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if (strs == null || strs.length == 0) {\\n            return \"\";\\n        }\\n        // 1) string builder\\n        StringBuilder result = new StringBuilder();\\n        \\n        // Sort array\\n        Arrays.sort(strs);\\n        \\n        // split first and last to char\\n        char[] first = strs[0].toCharArray();\\n        char[] last = strs[strs.length - 1 ].toCharArray();\\n        \\n        // loop through\\n        for (int i = 0; i < first.length && i < last.length; i++) {\\n            if (first[i] == last[i]) {\\n                result.append(first[i]);                \\n            }\\n            else\\n                return result.toString();\\n        }\\n        return result.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833959,
                "title": "javascript-solution-14",
                "content": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nlet longestCommonPrefix = function(strs) {\\n        if(!strs.length) {\\n            return \\'\\';\\n        }\\n        for(let i = 0; i < strs[0].length; i++) {\\n            for(let s of strs) {\\n                if(s[i] !== strs[0][i]) {\\n                    return s.slice(0, i);\\n                }\\n            }\\n        }\\n        return strs[0];\\n    };\\n```\\n**Runtime: 80 ms, faster than 75.49% of JavaScript online submissions for Longest Common Prefix.**\\n\\n**Memory Usage: 39.2 MB, less than 10.70% of JavaScript online submissions for Longest Common Prefix.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nlet longestCommonPrefix = function(strs) {\\n        if(!strs.length) {\\n            return \\'\\';\\n        }\\n        for(let i = 0; i < strs[0].length; i++) {\\n            for(let s of strs) {\\n                if(s[i] !== strs[0][i]) {\\n                    return s.slice(0, i);\\n                }\\n            }\\n        }\\n        return strs[0];\\n    };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3405496,
                "title": "python-code-explained-with-approach-and-time-complexity",
                "content": "Intuition:\\nThe problem requires finding the longest common prefix among a list of strings. The approach is to assume that the prefix is the shortest string in the list and then compare it with all the other strings. The length of the prefix is then reduced by one character at a time until a match is found or the prefix becomes empty.\\n\\nApproach:\\n\\nIf the input list is empty, return an empty string.\\nAssume that the prefix is the shortest string in the list.\\nIterate over all the other strings in the list and compare them with the prefix.\\nIf a match is found, continue to the next string in the list.\\nIf a match is not found, reduce the length of the prefix by one character at a time until a match is found or the prefix becomes empty.\\nIf the prefix becomes empty, return an empty string.\\nIf all strings match the prefix, return the prefix.\\n\\nTime complexity:\\nThe time complexity of the given implementation is O(nm), where n is the number of strings in the input list and m is the length of the shortest string. This is because the algorithm iterates over all the strings in the list once, and for each string, it may reduce the length of the prefix by up to m characters. The min() function used to find the shortest string in the list has a time complexity of O(nm), where n is the number of strings in the list and m is the length of the longest string.\\n\\nSpace complexity:\\nThe space complexity of the given implementation is O(1), as it uses only constant extra space to store the prefix variable and the loop variables.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        \\n        prefix = min(strs, key=len)\\n        for s in strs:\\n            while not s.startswith(prefix):\\n                prefix = prefix[:-1]\\n                \\n        return prefix\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        \\n        prefix = min(strs, key=len)\\n        for s in strs:\\n            while not s.startswith(prefix):\\n                prefix = prefix[:-1]\\n                \\n        return prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923947,
                "title": "typescript-solution",
                "content": "```typescript\\nfunction longestCommonPrefix(strs: string[]): string {\\n  let prefix = strs[0];\\n\\n  for (let i = 1; i < strs.length; i++) {\\n    while (!strs[i].startsWith(prefix)) {\\n      prefix = prefix.slice(0, -1);\\n    }\\n\\n    if (prefix === \\'\\') {\\n      return prefix;\\n    }\\n  }\\n  \\n  return prefix;\\n};\\n```\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction longestCommonPrefix(strs: string[]): string {\\n  let prefix = strs[0];\\n\\n  for (let i = 1; i < strs.length; i++) {\\n    while (!strs[i].startsWith(prefix)) {\\n      prefix = prefix.slice(0, -1);\\n    }\\n\\n    if (prefix === \\'\\') {\\n      return prefix;\\n    }\\n  }\\n  \\n  return prefix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1214400,
                "title": "kotlin",
                "content": "```\\nfun longestCommonPrefix(ar: Array<String>) = StringBuilder().apply {\\n    ar.minBy { it.length }?.forEachIndexed { i, c -> if (ar.all { it[i] == c }) append(c) else return toString() }\\n}.toString()\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun longestCommonPrefix(ar: Array<String>) = StringBuilder().apply {\\n    ar.minBy { it.length }?.forEachIndexed { i, c -> if (ar.all { it[i] == c }) append(c) else return toString() }\\n}.toString()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2188782,
                "title": "keep-it-simple-and-go",
                "content": "```\\nfunc longestCommonPrefix(strs []string) string {\\n    for i := 0 ;; i++  {\\n        for _, str := range strs {\\n            if i == len(str) || str[i] != strs[0][i] {\\n                return strs[0][:i]\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestCommonPrefix(strs []string) string {\\n    for i := 0 ;; i++  {\\n        for _, str := range strs {\\n            if i == len(str) || str[i] != strs[0][i] {\\n                return strs[0][:i]\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7282,
                "title": "here-is-my-solution-in-c-0-ms",
                "content": "    #include<stdio.h>\\n    #include<string.h>\\n    char* longestCommonPrefix(char** strs, int strsSize) \\n    {\\n        int i=0; int j=0;int index;int tempindex=0;\\n        if(strsSize<1)\\n        return \"\";\\n        index=strlen(strs[0]);\\n        char *a;\\n        a= malloc(sizeof(char)*(index+1));\\n        strcpy(a,strs[0]);\\n        for(i=1;i<strsSize;i++)\\n        {   tempindex=0;\\n            for(j=0;j<index;j++)\\n            { \\n                if(a[j]==strs[i][j])\\n                tempindex++;\\n                else\\n                {a[j]='\\\\0';\\n                 break;\\n                }\\n            } \\n              if (tempindex==0)return (\"\");\\n              if(tempindex<index)index=tempindex;\\n            \\n        }\\n        return a;\\n        \\n    }",
                "solutionTags": [],
                "code": "    #include<stdio.h>\\n    #include<string.h>\\n    char* longestCommonPrefix(char** strs, int strsSize) \\n    {\\n        int i=0; int j=0;int index;int tempindex=0;\\n        if(strsSize<1)\\n        return \"\";\\n        index=strlen(strs[0]);\\n        char *a;\\n        a= malloc(sizeof(char)*(index+1));\\n        strcpy(a,strs[0]);\\n        for(i=1;i<strsSize;i++)\\n        {   tempindex=0;\\n            for(j=0;j<index;j++)\\n            { \\n                if(a[j]==strs[i][j])\\n                tempindex++;\\n                else\\n                {a[j]='\\\\0';\\n                 break;\\n                }\\n            } \\n              if (tempindex==0)return (\"\");\\n              if(tempindex<index)index=tempindex;\\n            \\n        }\\n        return a;\\n        \\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2744518,
                "title": "python3-solution",
                "content": "Simple & fast.\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs) == 0: return \"\"\\n        \\n        longPref = strs[0]\\n        \\n        for string in strs:\\n            for index in range(0, len(longPref)):\\n                if (index >= len(string) or longPref[index] != string[index]):\\n                    longPref = longPref[0:index]\\n                    break\\n                \\n        return longPref\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs) == 0: return \"\"\\n        \\n        longPref = strs[0]\\n        \\n        for string in strs:\\n            for index in range(0, len(longPref)):\\n                if (index >= len(string) or longPref[index] != string[index]):\\n                    longPref = longPref[0:index]\\n                    break\\n                \\n        return longPref\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537447,
                "title": "swift-faster-than-93-78-of-swift-online-submissions",
                "content": "```\\nclass Solution {\\n    func longestCommonPrefix(_ strs: [String]) -> String {\\n        if strs.isEmpty { return \"\" }\\n        if strs.count == 1 { return strs[0] }\\n\\n        let strs = strs.sorted()\\n        var output = \"\"\\n        for (char1, char2) in zip(strs.first!, strs.last!) {\\n            if char1 == char2 {\\n                output += String(char1)\\n            } else {\\n                break\\n            }\\n        }\\n        return output\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestCommonPrefix(_ strs: [String]) -> String {\\n        if strs.isEmpty { return \"\" }\\n        if strs.count == 1 { return strs[0] }\\n\\n        let strs = strs.sorted()\\n        var output = \"\"\\n        for (char1, char2) in zip(strs.first!, strs.last!) {\\n            if char1 == char2 {\\n                output += String(char1)\\n            } else {\\n                break\\n            }\\n        }\\n        return output\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6944,
                "title": "python-recursive-boring-solution-linear-time-and-constant-space-with-simple-explanation",
                "content": "````\\n# asymptotic O(n*m) (n=number of words, m=number of letters) time, and O(1) space complexity\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if not strs:\\n            return ''\\n        first_word = strs[0]\\n        for i in range(len(first_word)):\\n            for j in range(1,len(strs)):\\n                if i >= len(strs[j]): # first_word larger than current_word\\n                    return first_word[:i]\\n                if strs[j][i] != first_word[i]: # letters don't equal\\n                    return first_word[:i]\\n\\n        return first_word # made it to the end of the first word so this the common prefix\\n````\\nExplanation: No sorting (which adds additional O(nlogn) complexity) needed. The letters of the first word in the `strs` list will be used to compare against the letters of all of the other strings in the list. There are two main comparison cases while iterating over the letters of the first word: 1) The current index of the first word is larger then current index of the word being compared against. 2) The current first word letter does not match the letter in the word being compared against. In both cases, just return the substring of the first word up until this index. If you make it though the entire first word, then the entire first word is the common prefix.",
                "solutionTags": [
                    "Python"
                ],
                "code": "````\\n# asymptotic O(n*m) (n=number of words, m=number of letters) time, and O(1) space complexity\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if not strs:\\n            return ''\\n        first_word = strs[0]\\n        for i in range(len(first_word)):\\n            for j in range(1,len(strs)):\\n                if i >= len(strs[j]): # first_word larger than current_word\\n                    return first_word[:i]\\n                if strs[j][i] != first_word[i]: # letters don't equal\\n                    return first_word[:i]\\n\\n        return first_word # made it to the end of the first word so this the common prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049209,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Brute Force Solution\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n\\n    // Return early on empty input\\n    if (!strs.length) return \\'\\';\\n\\n    // Loop through the letters of the first string\\n    for (let i = 0; i <= strs[0].length; i++) {\\n        // Loop through the other strings\\n        for (let j = 1; j < strs.length; j++) {\\n            // Check if this character is also present in the same position of each string\\n            if (strs[0][i] !== strs[j][i]) {\\n                // If not, return the string up to and including the previous character\\n                return strs[0].slice(0, i);\\n            }\\n        }\\n    }\\n\\n    return strs[0];\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n\\n    // Return early on empty input\\n    if (!strs.length) return \\'\\';\\n\\n    // Loop through the letters of the first string\\n    for (let i = 0; i <= strs[0].length; i++) {\\n        // Loop through the other strings\\n        for (let j = 1; j < strs.length; j++) {\\n            // Check if this character is also present in the same position of each string\\n            if (strs[0][i] !== strs[j][i]) {\\n                // If not, return the string up to and including the previous character\\n                return strs[0].slice(0, i);\\n            }\\n        }\\n    }\\n\\n    return strs[0];\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2768776,
                "title": "c-prefix",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n = strs.size();\\n        \\n        // Sort the vector\\n        sort(strs.begin(), strs.end());\\n        string ans = \"\"; // for storing answer\\n        \\n        string a = strs[0]; // after sorting first element\\n        string b = strs[n-1]; // after sorting last element\\n        \\n        // We can compare for first and last , since they are sorted\\n        // i < a.length() ==> common prefix we can select least word\\n        for(int i = 0; i < a.length(); i++){\\n            if(a[i] == b[i]){\\n                // If same add in answer\\n                ans += a[i];\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n = strs.size();\\n        \\n        // Sort the vector\\n        sort(strs.begin(), strs.end());\\n        string ans = \"\"; // for storing answer\\n        \\n        string a = strs[0]; // after sorting first element\\n        string b = strs[n-1]; // after sorting last element\\n        \\n        // We can compare for first and last , since they are sorted\\n        // i < a.length() ==> common prefix we can select least word\\n        for(int i = 0; i < a.length(); i++){\\n            if(a[i] == b[i]){\\n                // If same add in answer\\n                ans += a[i];\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281741,
                "title": "c-100ms-faster-than-96",
                "content": "Could certainly be improved but I didn\\'t see any other C# solutions posted so I wanted to include something\\n\\n\\n```\\npublic class Solution {\\n    public string LongestCommonPrefix(string[] strs) {\\n        if(strs.Length == 1)\\n            return strs[0];\\n        \\n        var prefixString = \"\";\\n        \\n        if (strs == null || strs.Length == 0)\\n            return prefixString;\\n        \\n        // Go through all the letters of the first word\\n        for(int i = 0; i < strs[0].Length; i++){\\n            \\n            // Go through each of the remaining words\\n            foreach(string str in strs){\\n                // If i is higher then the length of the word\\n                // there is no longer a prefix to match\\n                if(i > str.Length - 1)\\n                    return prefixString;\\n                \\n                // If the i-th letter of the string doesn\\'t match the i-th \\n                // letter of the first word we\\'ve reached the end of the\\n                // common prefix\\n                if(strs[0][i] != str[i])\\n                    return prefixString;            \\n            }\\n            \\n            // If we make it through the inner foreach all of the \\n            prefixString += strs[0][i];\\n        }\\n        \\n        \\n        return prefixString;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string LongestCommonPrefix(string[] strs) {\\n        if(strs.Length == 1)\\n            return strs[0];\\n        \\n        var prefixString = \"\";\\n        \\n        if (strs == null || strs.Length == 0)\\n            return prefixString;\\n        \\n        // Go through all the letters of the first word\\n        for(int i = 0; i < strs[0].Length; i++){\\n            \\n            // Go through each of the remaining words\\n            foreach(string str in strs){\\n                // If i is higher then the length of the word\\n                // there is no longer a prefix to match\\n                if(i > str.Length - 1)\\n                    return prefixString;\\n                \\n                // If the i-th letter of the string doesn\\'t match the i-th \\n                // letter of the first word we\\'ve reached the end of the\\n                // common prefix\\n                if(strs[0][i] != str[i])\\n                    return prefixString;            \\n            }\\n            \\n            // If we make it through the inner foreach all of the \\n            prefixString += strs[0][i];\\n        }\\n        \\n        \\n        return prefixString;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7224,
                "title": "share-my-java-solution",
                "content": "Scan all the strings with the same pace, once we reach the end of a string or find a mismatch we return the result.\\n\\n    public String longestCommonPrefix(String[] strs) {\\n      if (strs == null || strs.length == 0) {\\n        return \"\";\\n      }\\n      \\n      for (int i = 0; i < strs[0].length(); i++) {\\n        for (int j = 1; j < strs.length; j++) {\\n          if (i >= strs[j].length() || strs[j].charAt(i) != strs[0].charAt(i)) {\\n            return strs[0].substring(0, i);\\n          }\\n        }\\n      }\\n      \\n      return strs[0];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Scan all the strings with the same pace, once we reach the end of a string or find a mismatch we return the result.\\n\\n    public String longestCommonPrefix(String[] strs) {\\n      if (strs == null || strs.length == 0) {\\n        return \"\";\\n      }\\n      \\n      for (int i = 0; i < strs[0].length(); i++) {\\n        for (int j = 1; j < strs.length; j++) {\\n          if (i >= strs[j].length() || strs[j].charAt(i) != strs[0].charAt(i)) {\\n            return strs[0].substring(0, i);\\n          }\\n        }\\n      }\\n      \\n      return strs[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2703310,
                "title": "comparision-of-characters-of-two-strings-java",
                "content": "1. If the ```strs``` array does not contain any element then return ```null``` string OR if it contains only one element then return that string.\\n2. Make a character array ```arr``` of the first element of ```strs``` array. This is done in order to compare the characters with the remaining elements of the ```strs``` array.\\n3. Make a variable ```i``` and assign it a value 0, another variable ```ans``` and assign it the value of Integer.MAX_VALUE\\n3. Place a pointer ```j``` on the 1st position of ```strs``` array and traverse it till the length of the array. Inside this loop, make a pointer ```k``` and traverse it till the **minimum** of the length of **j**th element of ```strs``` array and the length of ```arr``` array. (Minimum length is taken in order to avoid the IndexOutofBoundException)\\n4. Inside this second loop, check if the characters of that **j**th element matches with the **k**th character of ```arr``` array. Increment the value of ```i``` if this condition satisfies. Else break the loop if at any iteration the character doesn\\'t matches.\\n5. If ```i``` is less than ```ans``` then update the value of ```ans = i```. This is done because so as to minimize the length of the common valid prefix.\\n6. Update the value of ```i``` to 0 for the next iteration. This is how here the first loop ends.\\n7. Make an empty string ```res```. Initialize a for loop from 0 to ```ans``` and concatenate the subsequent characters of the ```arr``` array so as to make the final **longest common prefix**.\\n8. Finally, return ```res```.\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        char[] arr = strs[0].toCharArray();\\n        if(strs.length == 0){\\n            return \"\";\\n        }\\n        if(strs.length == 1){\\n            return strs[0];\\n        }\\n        int i = 0,ans = Integer.MAX_VALUE;\\n        for (int j = 1;j < strs.length;j++){\\n            for (int k = 0;k < Math.min(strs[j].length(),arr.length);k++){\\n                if(strs[j].charAt(k) == arr[k]){\\n                    i++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(i < ans){\\n                ans = i;\\n            }\\n            i = 0;\\n        }\\n        String res = \"\";\\n        for (int j = 0;j < ans;j++){\\n            res += arr[j];\\n        }\\n        return res;\\n    }\\n}\\n```\\n**If you got this, please upvote :)**",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```strs```\n```null```\n```arr```\n```strs```\n```strs```\n```i```\n```ans```\n```j```\n```strs```\n```k```\n```strs```\n```arr```\n```arr```\n```i```\n```i```\n```ans```\n```ans = i```\n```i```\n```res```\n```ans```\n```arr```\n```res```\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        char[] arr = strs[0].toCharArray();\\n        if(strs.length == 0){\\n            return \"\";\\n        }\\n        if(strs.length == 1){\\n            return strs[0];\\n        }\\n        int i = 0,ans = Integer.MAX_VALUE;\\n        for (int j = 1;j < strs.length;j++){\\n            for (int k = 0;k < Math.min(strs[j].length(),arr.length);k++){\\n                if(strs[j].charAt(k) == arr[k]){\\n                    i++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(i < ans){\\n                ans = i;\\n            }\\n            i = 0;\\n        }\\n        String res = \"\";\\n        for (int j = 0;j < ans;j++){\\n            res += arr[j];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695808,
                "title": "python-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought was to sort the array according to the length of the strings and then use the shortest string as the base prefix.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter sorting and getting the base prefix we simply check if the base prefix is the longest common prefix if that is not the case we check if excluding the last letter of base prefix gives us the longest common prefix, we do this until we run out of letters in base prefix and in this case we return empty string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\nm = min(array, key lambda x:len(x))\\nn = len(array)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        strs.sort(key = lambda x:len(x))\\n        prefix = strs[0]\\n        for i in range(len(strs[0]),0,-1):\\n            if all([prefix[:i] == strs[j][:i] for j in range(1,len(strs))]):\\n                return(prefix[:i])\\n        return \"\"\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        strs.sort(key = lambda x:len(x))\\n        prefix = strs[0]\\n        for i in range(len(strs[0]),0,-1):\\n            if all([prefix[:i] == strs[j][:i] for j in range(1,len(strs))]):\\n                return(prefix[:i])\\n        return \"\"\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587164,
                "title": "c-2-solutions-simple-and-clean",
                "content": "**Time complexity - O(n*m)\\nSpace complexity - O(1)**\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string ans;\\n        \\n        for(int i=0;i<strs[0].size();i++) {\\n            for(int j=1;j<strs.size();j++) {\\n                if(strs[0][i] != strs[j][i]) {\\n                    return ans;\\n                }\\n            }\\n            ans += strs[0][i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Optimized solution.**\\n**Time complexity - O(n logn)\\nSpace complexity - O(1)**\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string ans;\\n        \\n        sort(strs.begin(),strs.end());\\n        for(int i=0;i<strs[0].size();i++) {\\n            if(strs[0][i] != strs[strs.size()-1][i]) {\\n                return ans;\\n            }\\n            ans += strs[0][i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string ans;\\n        \\n        for(int i=0;i<strs[0].size();i++) {\\n            for(int j=1;j<strs.size();j++) {\\n                if(strs[0][i] != strs[j][i]) {\\n                    return ans;\\n                }\\n            }\\n            ans += strs[0][i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string ans;\\n        \\n        sort(strs.begin(),strs.end());\\n        for(int i=0;i<strs[0].size();i++) {\\n            if(strs[0][i] != strs[strs.size()-1][i]) {\\n                return ans;\\n            }\\n            ans += strs[0][i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158660,
                "title": "c-java-python3-javascript-solution-explanation",
                "content": "Which have included C#, Java, Python3,JavaScript solutions\\n(JavaScript version have been updated on 2022/06/16 )\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/)\\u2B50\\n\\n\\u2B07JavaScript Submission Detail (2022/06/16) \\u2B07\\n![image](https://assets.leetcode.com/users/images/60e91036-09f2-431f-b730-22bcf63a4c8f_1655382611.7401285.png)\\n\\n\\n\\n#### Example : Java Code \\u27A1 Runtime : 1ms\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```\\n**You can find a faster Java solution in the link.**\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to leave your comment.\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152670,
                "title": "c-easiest-solution-detailed-explanation-short-simple-code",
                "content": "```\\nstring longestCommonPrefix(vector<string>& strs) {\\n       \\n        int n=strs.size();\\n        sort(strs.begin(),strs.end());\\n        string ans;\\n//Since we need to find the longest common prefix, we just need to compare the 0th and the last string in strs after sorting and see which characters are common. Since it\\'s sorted, 0th & last strings\\' common characters will be the ans.\\n        string s1=strs[0];\\n        string s2=strs[n-1];\\n        \\n        for(int i=0; i<s1.size(); i++)\\n        {\\n            if(s1[i]==s2[i])\\n                ans=ans+s1[i];\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n```\\n*If this was helpful, don\\'t forget to upvote!*",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nstring longestCommonPrefix(vector<string>& strs) {\\n       \\n        int n=strs.size();\\n        sort(strs.begin(),strs.end());\\n        string ans;\\n//Since we need to find the longest common prefix, we just need to compare the 0th and the last string in strs after sorting and see which characters are common. Since it\\'s sorted, 0th & last strings\\' common characters will be the ans.\\n        string s1=strs[0];\\n        string s2=strs[n-1];\\n        \\n        for(int i=0; i<s1.size(); i++)\\n        {\\n            if(s1[i]==s2[i])\\n                ans=ans+s1[i];\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1545132,
                "title": "java-tc-o-n-minlen-sc-o-1-constant-space-vertical-scanning-solution",
                "content": "**Constant Space Solution - Using String.substring to save on auxillary space**\\n```\\n/**\\n * Vertical Scanning or Column Scanning. Here character at the same index is\\n * compared. If the character at the same index in all input strings is same,\\n * add it to the prefix. Else, return the found prefix.\\n *\\n * Using substring instead of string builder to save on space.\\n *\\n * Time Complexity: O(N * minLen)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Number of strings in strs. minLen = Length of the smallest string.\\n */\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int numStrs = strs.length;\\n        if (numStrs == 0 || \"\".equals(strs[0]) || \"\".equals(strs[numStrs - 1])) {\\n            return \"\";\\n        }\\n\\n        String firstStr = strs[0];\\n        if (numStrs == 1) {\\n            return firstStr;\\n        }\\n\\n        int prefixLen = 0;\\n\\n\\t\\t// No need to find the minLen as this nested loop will exit when we reach the\\n        // end of minLen string.\\n        while (prefixLen < firstStr.length()) {\\n            char c = firstStr.charAt(prefixLen);\\n            for (int i = 1; i < numStrs; i++) {\\n                if (strs[i].length() <= prefixLen || strs[i].charAt(prefixLen) != c) {\\n                    return firstStr.substring(0, prefixLen);\\n                }\\n            }\\n            prefixLen++;\\n        }\\n\\n        return firstStr.substring(0, prefixLen);\\n    }\\n}\\n```\\n\\n---\\n**This solution will take O(minLen) space. Using StringBuilder to keep track of the result**\\n```java\\n/**\\n * Vertical Scanning or Column Scanning. Here character at the same index is\\n * compared. If the character at the same index in all input strings is same,\\n * add it to the prefix. Else, return the found prefix.\\n *\\n * In this solution using StringBuilder to keep track of the result\\n *\\n * Time Complexity: O(N * minLen + N)\\n *\\n * Space Complexity: O(minLen)\\n *\\n * N = Number of strings in strs. minLen = Length of smallest string in strs.\\n */\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null || strs.length == 0) {\\n            return \"\";\\n        }\\n        if (strs.length == 1) {\\n            return strs[0];\\n        }\\n\\n        int minLen = Integer.MAX_VALUE;\\n        for (String s : strs) {\\n            minLen = Math.min(minLen, s.length());\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < minLen; i++) {\\n            char c1 = strs[0].charAt(i);\\n            for (int j = 1; j < strs.length; j++) {\\n                if (c1 != strs[j].charAt(i)) {\\n                    return sb.toString();\\n                }\\n            }\\n            sb.append(c1);\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n/**\\n * Vertical Scanning or Column Scanning. Here character at the same index is\\n * compared. If the character at the same index in all input strings is same,\\n * add it to the prefix. Else, return the found prefix.\\n *\\n * Using substring instead of string builder to save on space.\\n *\\n * Time Complexity: O(N * minLen)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Number of strings in strs. minLen = Length of the smallest string.\\n */\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int numStrs = strs.length;\\n        if (numStrs == 0 || \"\".equals(strs[0]) || \"\".equals(strs[numStrs - 1])) {\\n            return \"\";\\n        }\\n\\n        String firstStr = strs[0];\\n        if (numStrs == 1) {\\n            return firstStr;\\n        }\\n\\n        int prefixLen = 0;\\n\\n\\t\\t// No need to find the minLen as this nested loop will exit when we reach the\\n        // end of minLen string.\\n        while (prefixLen < firstStr.length()) {\\n            char c = firstStr.charAt(prefixLen);\\n            for (int i = 1; i < numStrs; i++) {\\n                if (strs[i].length() <= prefixLen || strs[i].charAt(prefixLen) != c) {\\n                    return firstStr.substring(0, prefixLen);\\n                }\\n            }\\n            prefixLen++;\\n        }\\n\\n        return firstStr.substring(0, prefixLen);\\n    }\\n}\\n```\n```java\\n/**\\n * Vertical Scanning or Column Scanning. Here character at the same index is\\n * compared. If the character at the same index in all input strings is same,\\n * add it to the prefix. Else, return the found prefix.\\n *\\n * In this solution using StringBuilder to keep track of the result\\n *\\n * Time Complexity: O(N * minLen + N)\\n *\\n * Space Complexity: O(minLen)\\n *\\n * N = Number of strings in strs. minLen = Length of smallest string in strs.\\n */\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null || strs.length == 0) {\\n            return \"\";\\n        }\\n        if (strs.length == 1) {\\n            return strs[0];\\n        }\\n\\n        int minLen = Integer.MAX_VALUE;\\n        for (String s : strs) {\\n            minLen = Math.min(minLen, s.length());\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < minLen; i++) {\\n            char c1 = strs[0].charAt(i);\\n            for (int j = 1; j < strs.length; j++) {\\n                if (c1 != strs[j].charAt(i)) {\\n                    return sb.toString();\\n                }\\n            }\\n            sb.append(c1);\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527474,
                "title": "c-solution",
                "content": "```c\\nchar * longestCommonPrefix(char ** strs, int strsSize){\\n    if (strsSize == 0) return \"\";\\n    if (strsSize == 1) return strs[0];\\n\\n    int len = 0, min = strlen(strs[0]);\\n    for (int i = 1; i < strsSize; ++i) {\\n        min = strlen(strs[i]) < min ? strlen(strs[i]) : min;\\n    }\\n\\n    for (int c = 0; c < min; ++c) {\\n        for (int s = 0; s < strsSize - 1; ++s) {\\n            if (strs[s][c] == strs[s+1][c]) {\\n                if (s == strsSize - 2) {\\n                    ++len;\\n                }\\n            } else {\\n                goto br;\\n            }\\n        }\\n    }\\n    br:\\n\\n    if (len > 0) {\\n        char* ret = malloc(len * sizeof(int));\\n        strs[0][len] = \\'\\\\0\\';\\n        strcpy(ret, strs[0]);\\n        return ret;\\n    }\\n\\n    return \"\";\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c\\nchar * longestCommonPrefix(char ** strs, int strsSize){\\n    if (strsSize == 0) return \"\";\\n    if (strsSize == 1) return strs[0];\\n\\n    int len = 0, min = strlen(strs[0]);\\n    for (int i = 1; i < strsSize; ++i) {\\n        min = strlen(strs[i]) < min ? strlen(strs[i]) : min;\\n    }\\n\\n    for (int c = 0; c < min; ++c) {\\n        for (int s = 0; s < strsSize - 1; ++s) {\\n            if (strs[s][c] == strs[s+1][c]) {\\n                if (s == strsSize - 2) {\\n                    ++len;\\n                }\\n            } else {\\n                goto br;\\n            }\\n        }\\n    }\\n    br:\\n\\n    if (len > 0) {\\n        char* ret = malloc(len * sizeof(int));\\n        strs[0][len] = \\'\\\\0\\';\\n        strcpy(ret, strs[0]);\\n        return ret;\\n    }\\n\\n    return \"\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 293568,
                "title": "python-easy-solution-runtime-95-faster",
                "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        lcp = \"\"\\n        for s in zip(*strs):\\n            if (s[0],) * len(s) == s:\\n                lcp += s[0]\\n            else:\\n                break\\n        return lcp\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        lcp = \"\"\\n        for s in zip(*strs):\\n            if (s[0],) * len(s) == s:\\n                lcp += s[0]\\n            else:\\n                break\\n        return lcp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160011,
                "title": "simple-and-clear-solution-in-c-java-python",
                "content": "Sort the string array first, then we only need to find out the longest common prefix between the first and last word.\\n#### C++\\n```\\n# include<algorithm>\\n\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n = strs.size();\\n        if(n == 0) {\\n            return \"\";\\n        }\\n        string res = \"\";\\n        sort(strs.begin(), strs.end());// sort the array\\n        string first = strs[0]; // first word\\n        string last = strs[n-1];// last word\\n        int limit = min(first.length(), last.length());\\n        for(int i = 0; i < limit; i++) {// find out the longest common prefix between first and last word\\n            if(first[i] == last[i]) {\\n                res += first[i];\\n            }    \\n            else {\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n#### Java\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int n = strs.length;\\n        if(n == 0) {\\n            return \"\";\\n        }\\n        StringBuffer sb = new StringBuffer();\\n        Arrays.sort(strs);// sort string array\\n        String first = strs[0];\\n        String last = strs[n-1];\\n        int limit = Math.min(first.length(), last.length());\\n        for(int i = 0; i < limit; i++) {// find out the longest common prefix between first and last word\\n            if(first.charAt(i) == last.charAt(i)) {\\n                sb.append(first.charAt(i));\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n#### Python\\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        n = len(strs)\\n        if n == 0:\\n            return \"\"\\n        \\n        res = \"\"\\n        strs.sort() # sort the string array\\n        first = strs[0]\\n        last = strs[-1]\\n        limit = min(len(first), len(last)) \\n        for i in range(limit): # find out the longest common prefix between first and last word\\n            if first[i] == last[i]:\\n                res += first[i]\\n            else:\\n                break\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n# include<algorithm>\\n\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n = strs.size();\\n        if(n == 0) {\\n            return \"\";\\n        }\\n        string res = \"\";\\n        sort(strs.begin(), strs.end());// sort the array\\n        string first = strs[0]; // first word\\n        string last = strs[n-1];// last word\\n        int limit = min(first.length(), last.length());\\n        for(int i = 0; i < limit; i++) {// find out the longest common prefix between first and last word\\n            if(first[i] == last[i]) {\\n                res += first[i];\\n            }    \\n            else {\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int n = strs.length;\\n        if(n == 0) {\\n            return \"\";\\n        }\\n        StringBuffer sb = new StringBuffer();\\n        Arrays.sort(strs);// sort string array\\n        String first = strs[0];\\n        String last = strs[n-1];\\n        int limit = Math.min(first.length(), last.length());\\n        for(int i = 0; i < limit; i++) {// find out the longest common prefix between first and last word\\n            if(first.charAt(i) == last.charAt(i)) {\\n                sb.append(first.charAt(i));\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        n = len(strs)\\n        if n == 0:\\n            return \"\"\\n        \\n        res = \"\"\\n        strs.sort() # sort the string array\\n        first = strs[0]\\n        last = strs[-1]\\n        limit = min(len(first), len(last)) \\n        for i in range(limit): # find out the longest common prefix between first and last word\\n            if first[i] == last[i]:\\n                res += first[i]\\n            else:\\n                break\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 129542,
                "title": "swift-16-ms",
                "content": "```\\nfunc longestCommonPrefix(_ strs: [String]) -> String {\\n    \\n   if strs.count == 0 { return \"\" }\\n    \\n    let shortestWord = strs.min{$0.count < $1.count}!\\n    var longestPrefix = shortestWord\\n    \\n        for str in strs {\\n            \\n            while !str.hasPrefix(longestPrefix), longestPrefix.count > 0 {\\n                longestPrefix.removeLast()\\n            }\\n            \\n            if longestPrefix.count == 0 { return longestPrefix }\\n        }\\n    \\n    return longestPrefix\\n}\\n```\\nThere is no need, actually, to use shortestWord. It just stayed there from one of my previous submission. But when I noticed that and removed it:\\n\\n```\\n    var longestPrefix = strs.min{$0.count < $1.count}!\\n```\\n\\nthen time went up to the 22 ms :)",
                "solutionTags": [],
                "code": "```\\nfunc longestCommonPrefix(_ strs: [String]) -> String {\\n    \\n   if strs.count == 0 { return \"\" }\\n    \\n    let shortestWord = strs.min{$0.count < $1.count}!\\n    var longestPrefix = shortestWord\\n    \\n        for str in strs {\\n            \\n            while !str.hasPrefix(longestPrefix), longestPrefix.count > 0 {\\n                longestPrefix.removeLast()\\n            }\\n            \\n            if longestPrefix.count == 0 { return longestPrefix }\\n        }\\n    \\n    return longestPrefix\\n}\\n```\n```\\n    var longestPrefix = strs.min{$0.count < $1.count}!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6950,
                "title": "clean-7-lines-c",
                "content": "**Solution 1**\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.empty()) return \"\";\\n        string res = strs[0];\\n        for(auto s: strs) res = match(res, s);\\n        return res;\\n    }\\n    \\n    string match(const string& pre, const string& s){\\n        int i = 0, len = min(pre.size(), s.size());\\n        for(; i < len; i++) if(s[i] != pre[i]) break;\\n        return pre.substr(0, i);\\n    }\\n};\\n```\\n***\\n**Solution 2**\\n\\nUsing sort and only compare the first string with the last string.\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.empty()) return \"\";\\n        sort(strs.begin(), strs.end());\\n        string a = strs[0], b = strs.back();\\n        int i = 0;\\n        for(; i < min(a.size(), b.size()); i++) if(a[i] != b[i]) break;\\n        return a.substr(0, i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.empty()) return \"\";\\n        string res = strs[0];\\n        for(auto s: strs) res = match(res, s);\\n        return res;\\n    }\\n    \\n    string match(const string& pre, const string& s){\\n        int i = 0, len = min(pre.size(), s.size());\\n        for(; i < len; i++) if(s[i] != pre[i]) break;\\n        return pre.substr(0, i);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.empty()) return \"\";\\n        sort(strs.begin(), strs.end());\\n        string a = strs[0], b = strs.back();\\n        int i = 0;\\n        for(; i < min(a.size(), b.size()); i++) if(a[i] != b[i]) break;\\n        return a.substr(0, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7258,
                "title": "3-diffrent-c-solutions-each-one-costs-8ms",
                "content": "First one: check from strs[0][0] to strs[i][0]. If matches, check strs[0][1] to strs[i][1].\\n\\nCode:\\n\\n    class Solution {\\n    public:\\n        string longestCommonPrefix(vector<string>& strs) {\\n            if(strs.size()==0)\\n            return \"\";\\n            string ans=\"\";\\n            int max=INT_MAX;\\n            for(auto& s:strs)\\n            {\\n                max=(max>s.length())?s.length():max;\\n            }\\n            for(int i=0;i<max;i++)\\n            {\\n                bool flag=true;\\n                char x=strs[0][i];\\n                for(auto& s:strs)\\n                {\\n                    if(s[i]!=x)\\n                    {\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n                if(flag==false)\\n                return ans;\\n                ans+=x;\\n            }\\n            return ans;\\n        }\\n    };\\n\\nSecond one: assume the prefix is strs[0]. Compair with strs[i], and cut the letters which don't match.\\n\\nCode:\\n\\n    class Solution {\\n    public:\\n        string longestCommonPrefix(vector<string>& strs) {\\n            if(strs.size()==0)\\n            return \"\";\\n            string ans=strs[0];\\n            int max=INT_MAX;\\n            for(auto& s:strs)\\n            {\\n                if(s.length()==0)\\n                return \"\";\\n                int i=0;\\n                for(i=0;i<ans.length()&&i<s.length();i++)\\n                {\\n                    if(s[i]!=ans[i])\\n                    break;\\n                }\\n                ans=ans.substr(0,i);\\n            }\\n    \\n            return ans;\\n        }\\n    };\\n\\nThird one:  use a Trie data structure to save the strs. Search the trie, and stops when a TrieNode has more than one son.\\n\\nCode:\\n\\n    class TrieNode{\\n    public:\\n    \\tbool val;\\n    \\tTrieNode* next[52];\\n    \\tint sons;\\n    \\tTrieNode() :val(false), sons(0)\\n    \\t{\\n    \\t\\tfor (int i = 0; i < 52; i++)\\n    \\t\\t\\tnext[i] = nullptr;\\n    \\t}\\n    };\\n    class Trie{\\n    private:\\n    \\tTrieNode* putst(string& s, TrieNode * node, int loc, TrieNode *father)\\n    \\t{\\n    \\t\\tif (s.length() == 0)\\n    \\t\\t{\\n    \\t\\t\\tnode->val = true;\\n    \\t\\t\\tnode->sons++;\\n    \\t\\t\\treturn node;\\n    \\t\\t}\\n    \\t\\tif (node == nullptr)\\n    \\t\\t{\\n    \\t\\t\\tnode = new TrieNode();\\n    \\t\\t\\tif (father != nullptr)\\n    \\t\\t\\t\\tfather->sons++;\\n    \\t\\t}\\n    \\t\\tif (loc == s.length())\\n    \\t\\t{\\n    \\t\\t\\tnode->val = true;\\n    \\t\\t\\treturn node;\\n    \\t\\t}\\n    \\t\\tif (s[loc] >= 'a')\\n    \\t\\t\\tnode->next[s[loc] - 'a'] = putst(s, node->next[s[loc] - 'a'], loc + 1, node);\\n    \\t\\telse\\n    \\t\\t\\tnode->next[s[loc] - 'A' + 26] = putst(s, node->next[s[loc] - 'A' + 26], loc + 1, node);\\n    \\t\\treturn node;\\n    \\t}\\n    public:\\n    \\tTrieNode *root;\\n    \\tvoid insert(string & str){ putst(str, root, 0, nullptr); }\\n    \\tTrie(){ root = new TrieNode(); }\\n    };\\n    class Solution {\\n    private:\\n    \\tstring findPre(TrieNode * node)\\n    \\t{\\n    \\t\\tif (node == nullptr || (node != nullptr&&node->sons > 1))\\n    \\t\\t\\treturn string(\"\");\\n    \\t\\tint i = 0;\\n    \\t\\tfor (i = 0; i < 52; i++)\\n    \\t\\t{\\n    \\t\\t\\tif (node->next[i] != nullptr)\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t}\\n    \\t\\tif (i == 52)\\n    \\t\\t\\treturn string(\"\");\\n    \\t\\tchar temp1 = ((i>25) ? ('A' + i) : ('a' + i));\\n    \\t\\tstring temp;\\n    \\t\\ttemp.insert(temp.begin(), temp1);\\n    \\t\\tif (node->val)\\n    \\t\\t{\\n    \\t\\t\\treturn string(\"\");\\n    \\t\\t}\\n    \\t\\telse\\n    \\t\\t{\\n    \\t\\t\\treturn temp + findPre(node->next[i]);\\n    \\t\\t}\\n    \\t}\\n    public:\\n    \\tstring longestCommonPrefix(vector<string>& strs) {\\n    \\t\\tTrie a;\\n    \\t\\tfor (auto& str : strs)\\n    \\t\\t\\ta.insert(str);\\n    \\t\\treturn findPre(a.root);\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string longestCommonPrefix(vector<string>& strs) {\\n            if(strs.size()==0)\\n            return \"\";\\n            string ans=\"\";\\n            int max=INT_MAX;\\n            for(auto& s:strs)\\n            {\\n                max=(max>s.length())?s.length():max;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3152934,
                "title": "beats-100-c-easy-solution",
                "content": "# Intuition\\n# Approach\\n1.short the string \\n   sort(str.begin(), str.end())\\n   it will short in alphabetically order\\n   such that no need to compair string in between start and last      string so\\n   \\n2.compair first string alphabet with last string alphabet\\n3.store in another string if alphabet gets equall;\\n\\n \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n     string ans=\"\"; //to store result \\n     sort(str.begin(), str.end()); \\n      string firstStr=str[0];\\n      string lastStr=str[str.size()-1]; \\n        for(int i=0; i<firstStr.size(); i++)\\n        {\\n           if(firstStr[i]==lastStr[i])//compair first string alphabet with last string alphabet\\n           {\\n             ans=ans+firstStr[i];\\n           }\\n            else \\n             break;\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n     string ans=\"\"; //to store result \\n     sort(str.begin(), str.end()); \\n      string firstStr=str[0];\\n      string lastStr=str[str.size()-1]; \\n        for(int i=0; i<firstStr.size(); i++)\\n        {\\n           if(firstStr[i]==lastStr[i])//compair first string alphabet with last string alphabet\\n           {\\n             ans=ans+firstStr[i];\\n           }\\n            else \\n             break;\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928400,
                "title": "easiest-faang-method-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis question uses the beauty of sort() in strings. \\n```\\nWhen Strings are sorted, the possibility of characters to be least\\ncommon is between 1st and last member of the sorted strings.\\n```\\nVery simple beginner friendly question. Yet the idea of sorting stings is what makes it tricky \\uD83D\\uDCA1\\n\\n# Complexity\\n- Time complexity: O(n logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n        string res=\"\";\\n        sort(str.begin(),str.end());\\n        string a=str[0];\\n        string b=str[str.size()-1];\\n        for(int i=0;i<str[0].size();i++){\\n            if(a[i]==b[i])\\n                res+=a[i];\\n            else\\n                break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "String"
                ],
                "code": "```\\nWhen Strings are sorted, the possibility of characters to be least\\ncommon is between 1st and last member of the sorted strings.\\n```\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n        string res=\"\";\\n        sort(str.begin(),str.end());\\n        string a=str[0];\\n        string b=str[str.size()-1];\\n        for(int i=0;i<str[0].size();i++){\\n            if(a[i]==b[i])\\n                res+=a[i];\\n            else\\n                break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175545,
                "title": "python-solution-beats-95-34-brute-force",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        strs.sort()\\n        lim = min(strs,key=len)\\n        res = \"\"\\n        for i in range(len(lim)):\\n            if strs[0][i] != strs[len(strs)-1][i]:\\n                break\\n            res += strs[0][i]\\n        return res\\n```\\n**.\\n.\\n.\\n.\\n.\\n.\\nPlease Upvote if you find this post useful...**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        strs.sort()\\n        lim = min(strs,key=len)\\n        res = \"\"\\n        for i in range(len(lim)):\\n            if strs[0][i] != strs[len(strs)-1][i]:\\n                break\\n            res += strs[0][i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031242,
                "title": "javascript-simple-solution-faster-than-87",
                "content": "```\\nvar longestCommonPrefix = function (strs) {\\n \\n  let lcp = \\'\\';\\n  if (!strs || !strs.length) return lcp;\\n  \\n  // sorting array alphabetically \\n  strs.sort()\\n  \\n  for (let i = 0; i < strs[0].length; ++i) {\\n    if (strs[0][i] !== strs[strs.length - 1][i]) {    // comparing only first and last item\\n      break;\\n    } else {\\n      lcp += strs[0][i];\\n    }\\n  }\\n  return lcp;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestCommonPrefix = function (strs) {\\n \\n  let lcp = \\'\\';\\n  if (!strs || !strs.length) return lcp;\\n  \\n  // sorting array alphabetically \\n  strs.sort()\\n  \\n  for (let i = 0; i < strs[0].length; ++i) {\\n    if (strs[0][i] !== strs[strs.length - 1][i]) {    // comparing only first and last item\\n      break;\\n    } else {\\n      lcp += strs[0][i];\\n    }\\n  }\\n  return lcp;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 783976,
                "title": "python-simple-solution-beats-100-runtime-12ms",
                "content": "The longest common prefix can be optimally found if we have the alphabetically smallest & largest strings. After that we just need compare them & return the longest common prefix. There is no need of sorting the array as the time complexity would be O(nlogn) for that.\\n\\n**min(an array of strings)** - returns the alphabetically smallest string\\nUse **max()** in a similar way.\\n\\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0: \\n\\t\\t\\treturn \"\"\\n        s1, s2 = min(strs), max(strs)\\n        i = 0\\n        while i < len(s1) and i < len(s2) and s1[i] == s2[i]: \\n\\t\\t\\ti += 1\\n        return s1[:i]\\n```\\n\\n**Modular Version** - 16ms\\nThe lcp helper compares two strings & returns the longest common prefix. It can be included within the original function itself, I wrote it this way because in my first solution I was using Brute Force to compare all the pairs of strings. Don\\'t judge me :) \\nThis way I could reuse my pre-written piece of code without having to change anything when optimizing the Brute Force.\\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \"\"\\n        return self.lcp_helper(min(strs), max(strs))\\n\\n    def lcp_helper(self, s1, s2):\\n        i = 0\\n        while i<len(s1) and i<len(s2) and s1[i]==s2[i]:\\n            i += 1\\n        return s1[:i]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0: \\n\\t\\t\\treturn \"\"\\n        s1, s2 = min(strs), max(strs)\\n        i = 0\\n        while i < len(s1) and i < len(s2) and s1[i] == s2[i]: \\n\\t\\t\\ti += 1\\n        return s1[:i]\\n```\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \"\"\\n        return self.lcp_helper(min(strs), max(strs))\\n\\n    def lcp_helper(self, s1, s2):\\n        i = 0\\n        while i<len(s1) and i<len(s2) and s1[i]==s2[i]:\\n            i += 1\\n        return s1[:i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777900,
                "title": "python-3-faster-than-85-less-than-95-memory-with-explanation",
                "content": "Ok, this was a tricky one. I am surprised it\\'s ranked easy. I made my algorithm, ran into an issue, peeked at discussions as I was convinced there should be a trick/easy way of doing it, realized no, went back and completed my solution. \\n\\nIt\\'s not the most elegant, sorry for the nested loops and if\\'s but let me know if you want further explanation.\\n\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        # compares first letter of all words, then moves to next letter\\n        s = \"\"\\n        if len(strs)==0: #edge case, no elements in list\\n            return s\\n        elif len(strs)==1: #edge case, single element in list\\n            return strs[0]\\n\\n        #word length of shortest word to prevent index out of range\\n        for a in range(len(min(strs))): \\n            #loops through each word in list, starting with second word\\n            for b in range(1, len(strs)): \\n                #compares nth character of first word to other words\\n                if strs[0][a]==strs[b][a]: \\n                    #only adds to pattern if nth character same up to the last word\\n                    if b==len(strs)-1: \\n                        s += strs[0][a]\\n                else: #exits when characters don\\'t match\\n                    return s\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        # compares first letter of all words, then moves to next letter\\n        s = \"\"\\n        if len(strs)==0: #edge case, no elements in list\\n            return s\\n        elif len(strs)==1: #edge case, single element in list\\n            return strs[0]\\n\\n        #word length of shortest word to prevent index out of range\\n        for a in range(len(min(strs))): \\n            #loops through each word in list, starting with second word\\n            for b in range(1, len(strs)): \\n                #compares nth character of first word to other words\\n                if strs[0][a]==strs[b][a]: \\n                    #only adds to pattern if nth character same up to the last word\\n                    if b==len(strs)-1: \\n                        s += strs[0][a]\\n                else: #exits when characters don\\'t match\\n                    return s\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7030,
                "title": "c-6-lines-o-n-len-of-prefix-most-optimal-i-can-think-of",
                "content": "I'm sure there is a more clever way, but this seems like the most optimal I can think of\\n* start at index 0\\n* check each string if they have the same char at the index\\n* if all have the same char increment the index\\n* terminate if any mismatch is found or any string has exceeded it's length\\n* also, avoids any string functions, adding strings, sub string, etc (except in my return)\\n\\nThis seems like it will terminate the quickest, as soon as any string runs out or any character is not a match.  It will do no unnecessary compares.\\n```\\n    public string LongestCommonPrefix(string[] strs) \\n    {\\n        int min = 0;\\n        while (strs.Length > 0)\\n        {\\n            foreach (string s in strs)\\n            {\\n                if (s.Length == min || s[min] != strs[0][min]) return strs[0].Substring(0, min);\\n            }\\n            min++;\\n        }\\n        return \"\";\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public string LongestCommonPrefix(string[] strs) \\n    {\\n        int min = 0;\\n        while (strs.Length > 0)\\n        {\\n            foreach (string s in strs)\\n            {\\n                if (s.Length == min || s[min] != strs[0][min]) return strs[0].Substring(0, min);\\n            }\\n            min++;\\n        }\\n        return \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2687169,
                "title": "javascript-solution",
                "content": "```\\nvar longestCommonPrefix = function(strs) {\\n    let cur = strs[0]\\n    let temp = \"\"\\n    for(let i = 1; i < strs.length; i++){\\n        for(let j = 0; j < cur.length; j++){\\n            if(cur[j] == strs[i][j]){\\n                temp += cur[j]\\n            } else {\\n                break\\n            }\\n        }\\n        cur = temp\\n        temp = \"\"\\n    }\\n    return cur\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestCommonPrefix = function(strs) {\\n    let cur = strs[0]\\n    let temp = \"\"\\n    for(let i = 1; i < strs.length; i++){\\n        for(let j = 0; j < cur.length; j++){\\n            if(cur[j] == strs[i][j]){\\n                temp += cur[j]\\n            } else {\\n                break\\n            }\\n        }\\n        cur = temp\\n        temp = \"\"\\n    }\\n    return cur\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297953,
                "title": "python-91-45-fasters-python-simplest-solution-with-explanation-beg-to-adv-string-o-n",
                "content": "```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        res = \"\" #Taking a empty string for saving the result \\n        for i in zip(*strs): # check out the bottom of this artical for its explanation.\\n            a = \"\".join(i) # joining the result of zip, check out the example\\n            if len(set(a)) != 1: # this will checkout, if the elements of the all the provided string on a same level (i.e a[i][i]) are identical or not.  If its identical then will always be equal to one.\\n                return res\\n            else:\\n                res += a[0] # if we are having identical element in the string will add it to our resulting string.\\n\\n        return res\\n```\\n```python\\nzip(*strs)\\nThis will club each element of the string on the same together \\nIt will club the element till the len of shortest string available in the list.\\nExample:-\\nYour input\\n[\"flower\",\"flow\",\"flight\"]\\nstdout\\n(\\'f\\', \\'f\\', \\'f\\')\\n(\\'l\\', \\'l\\', \\'l\\')\\n(\\'o\\', \\'o\\', \\'i\\')\\n(\\'w\\', \\'w\\', \\'g\\')\\nHere, in the we were having \\'flow\\' as a shortest string and the zip clubed till its length. \\n```\\n\\n***Found helpful, Do upvote !!***\\n![image](https://assets.leetcode.com/users/images/dd2ce5b2-49e1-49be-8855-101c82825214_1658127524.888506.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        res = \"\" #Taking a empty string for saving the result \\n        for i in zip(*strs): # check out the bottom of this artical for its explanation.\\n            a = \"\".join(i) # joining the result of zip, check out the example\\n            if len(set(a)) != 1: # this will checkout, if the elements of the all the provided string on a same level (i.e a[i][i]) are identical or not.  If its identical then will always be equal to one.\\n                return res\\n            else:\\n                res += a[0] # if we are having identical element in the string will add it to our resulting string.\\n\\n        return res\\n```\n```python\\nzip(*strs)\\nThis will club each element of the string on the same together \\nIt will club the element till the len of shortest string available in the list.\\nExample:-\\nYour input\\n[\"flower\",\"flow\",\"flight\"]\\nstdout\\n(\\'f\\', \\'f\\', \\'f\\')\\n(\\'l\\', \\'l\\', \\'l\\')\\n(\\'o\\', \\'o\\', \\'i\\')\\n(\\'w\\', \\'w\\', \\'g\\')\\nHere, in the we were having \\'flow\\' as a shortest string and the zip clubed till its length. \\n```",
                "codeTag": "Java"
            },
            {
                "id": 934491,
                "title": "python-trie-solution",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        root = self.root\\n        for ch in word:\\n            if ch not in root.children:\\n                root.children[ch] = TrieNode()\\n            root = root.children[ch]\\n        root.endOfWord = True\\n        \\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if not strs:\\n            return \\'\\'\\n        \\n        trie = Trie()\\n        \\n        for word in strs:\\n            trie.insert(word)\\n            \\n        root = trie.root\\n        res = \\'\\'\\n        while root:\\n            if len(root.children) > 1 or root.endOfWord:\\n                return res\\n            \\n            key = list(root.children)[0]\\n            res += key\\n            \\n            root = root.children[key]\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        root = self.root\\n        for ch in word:\\n            if ch not in root.children:\\n                root.children[ch] = TrieNode()\\n            root = root.children[ch]\\n        root.endOfWord = True\\n        \\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if not strs:\\n            return \\'\\'\\n        \\n        trie = Trie()\\n        \\n        for word in strs:\\n            trie.insert(word)\\n            \\n        root = trie.root\\n        res = \\'\\'\\n        while root:\\n            if len(root.children) > 1 or root.endOfWord:\\n                return res\\n            \\n            key = list(root.children)[0]\\n            res += key\\n            \\n            root = root.children[key]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7177,
                "title": "6-line-c-lightening-fast",
                "content": "    string longestCommonPrefix(vector<string>& strs) {\\n            if (strs.size()==0) return \"\";\\n            for (int i=0; i<strs[0].length(); i++)\\n                for (int j=0; j<strs.size(); j++)\\n                    if ( !(i<strs[j].length() && strs[0][i]==strs[j][i]) )\\n                        return strs[0].substr(0, i);\\n            return strs[0];\\n        }",
                "solutionTags": [],
                "code": "    string longestCommonPrefix(vector<string>& strs) {\\n            if (strs.size()==0) return \"\";\\n            for (int i=0; i<strs[0].length(); i++)\\n                for (int j=0; j<strs.size(); j++)\\n                    if ( !(i<strs[j].length() && strs[0][i]==strs[j][i]) )\\n                        return strs[0].substr(0, i);\\n            return strs[0];\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3914585,
                "title": "c-beginner-friendly-beats-100-of-c-users",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745752,
                "title": "python-short-simple",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        shortest = min(strs,key=len)\\n        for i, ch in enumerate(shortest):\\n            for other in strs:\\n                if other[i] != ch:\\n                    return shortest[:i]\\n        return shortest \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        shortest = min(strs,key=len)\\n        for i, ch in enumerate(shortest):\\n            for other in strs:\\n                if other[i] != ch:\\n                    return shortest[:i]\\n        return shortest \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330097,
                "title": "c-java-python3-javascript-solution-explanation",
                "content": "**Which have included C#, Java, Python3,JavaScript solutions**\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/)\\u2B50**\\n\\n\\n#### Example : Java Code \\u27A1 Runtime : 1ms\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```\\n**You can find a faster Java solution in the link.**\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to leave your comment.\\n\\n**\\uD83E\\uDDE1See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982614,
                "title": "kotlin-o-s-4-lines",
                "content": "```\\nclass Solution {\\n    fun longestCommonPrefix(strs: Array<String>): String {\\n        val w = strs[0]\\n        w.forEachIndexed { i, c ->\\n            if (strs.any { it.length == i || it[i] != c } ) return w.substring(0, i)\\n        }\\n        return w\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun longestCommonPrefix(strs: Array<String>): String {\\n        val w = strs[0]\\n        w.forEachIndexed { i, c ->\\n            if (strs.any { it.length == i || it[i] != c } ) return w.substring(0, i)\\n        }\\n        return w\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888715,
                "title": "100-fastest-typescript-solution",
                "content": "```\\nfunction longestCommonPrefix(strings: string[]): string {\\n  if (strings.length === 0) { return \"\" }\\n  if (strings.length === 1) { return strings[0] }\\n  let possiblePrefix = \"\"\\n  \\n  while (strings.every((str) => str.startsWith(possiblePrefix))) {\\n    const newPossiblePrefix = strings[0].substr(0, possiblePrefix.length + 1)\\n\\n    if (newPossiblePrefix.length > possiblePrefix.length) {\\n      possiblePrefix = newPossiblePrefix\\n    } else if (newPossiblePrefix.length === possiblePrefix.length) {\\n      return possiblePrefix\\n    } else { break }\\n  }\\n\\n  return possiblePrefix.slice(0, -1)\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction longestCommonPrefix(strings: string[]): string {\\n  if (strings.length === 0) { return \"\" }\\n  if (strings.length === 1) { return strings[0] }\\n  let possiblePrefix = \"\"\\n  \\n  while (strings.every((str) => str.startsWith(possiblePrefix))) {\\n    const newPossiblePrefix = strings[0].substr(0, possiblePrefix.length + 1)\\n\\n    if (newPossiblePrefix.length > possiblePrefix.length) {\\n      possiblePrefix = newPossiblePrefix\\n    } else if (newPossiblePrefix.length === possiblePrefix.length) {\\n      return possiblePrefix\\n    } else { break }\\n  }\\n\\n  return possiblePrefix.slice(0, -1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1678669,
                "title": "easy-and-optimized-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n        int n = str.size();\\n        string ans  = \"\";\\n        sort(begin(str), end(str));\\n        string a = str[0];\\n        string b = str[n-1];\\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==b[i]) ans = ans + a[i];\\n            else break;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n        int n = str.size();\\n        string ans  = \"\";\\n        sort(begin(str), end(str));\\n        string a = str[0];\\n        string b = str[n-1];\\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==b[i]) ans = ans + a[i];\\n            else break;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174581,
                "title": "0ms-faster-than-100-longest-common-prefix-java-soln",
                "content": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length == 0) return \"\";\\n        String prefix = strs[0];\\n        for(int i=1; i< strs.length; i++ ) {\\n            while(strs[i].indexOf(prefix) != 0) {\\n                prefix = prefix.substring(0, prefix.length()-1);\\n            }\\n        }\\n        \\n        return prefix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length == 0) return \"\";\\n        String prefix = strs[0];\\n        for(int i=1; i< strs.length; i++ ) {\\n            while(strs[i].indexOf(prefix) != 0) {\\n                prefix = prefix.substring(0, prefix.length()-1);\\n            }\\n        }\\n        \\n        return prefix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702828,
                "title": "easy-js-solution",
                "content": "```\\nvar longestCommonPrefix = function(arr) {\\n    if (!arr.length) return \"\";\\n    let prefix = \"\";\\n    for (let i = 0; i < arr[0].length; i++) {\\n        for (let j = 0; j < arr.length-1; j++) {\\n            if (arr[j][i] !== arr[j+1][i]) return prefix;\\n        }\\n        prefix += arr[0][i];\\n    }\\n    return prefix;\\n    // Time Complexity: O(M*N), M = length of shortest word, N = length of given array\\n    // Space Complexity: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestCommonPrefix = function(arr) {\\n    if (!arr.length) return \"\";\\n    let prefix = \"\";\\n    for (let i = 0; i < arr[0].length; i++) {\\n        for (let j = 0; j < arr.length-1; j++) {\\n            if (arr[j][i] !== arr[j+1][i]) return prefix;\\n        }\\n        prefix += arr[0][i];\\n    }\\n    return prefix;\\n    // Time Complexity: O(M*N), M = length of shortest word, N = length of given array\\n    // Space Complexity: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7004,
                "title": "my-2ms-java-solution-may-help-u",
                "content": "    public class Solution {\\n        public String longestCommonPrefix(String[] strs) {\\n            int len = strs.length;\\n    \\t\\tif (len == 0)\\n    \\t\\t\\treturn \"\";\\n    \\t\\tint minlen = 0x7fffffff;\\n    \\t\\tfor (int i = 0; i < len; ++i) \\n    \\t\\t\\tminlen = Math.min(minlen, strs[i].length());\\n    \\t\\tfor (int j = 0; j < minlen; ++j) \\n    \\t\\t\\tfor (int i = 1; i < len; ++i) \\n    \\t\\t\\t\\tif (strs[0].charAt(j) != strs[i].charAt(j)) \\n    \\t\\t\\t\\t\\treturn strs[0].substring(0, j);\\n    \\t\\treturn strs[0].substring(0, minlen);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String longestCommonPrefix(String[] strs) {\\n            int len = strs.length;\\n    \\t\\tif (len == 0)\\n    \\t\\t\\treturn \"\";\\n    \\t\\tint minlen = 0x7fffffff;\\n    \\t\\tfor (int i = 0; i < len; ++i) \\n    \\t\\t\\tminlen = Math.min(minlen, strs[i].length());\\n    \\t\\tfor (int j = 0; j < minlen; ++j) \\n    \\t\\t\\tfor (int i = 1; i < len; ++i) \\n    \\t\\t\\t\\tif (strs[0].charAt(j) != strs[i].charAt(j)) \\n    \\t\\t\\t\\t\\treturn strs[0].substring(0, j);\\n    \\t\\treturn strs[0].substring(0, minlen);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 7240,
                "title": "short-accepted-cpp-solution",
                "content": "     string longestCommonPrefix(vector<string> &strs) {\\n            string prefix = \"\";\\n            if(strs.empty()) return prefix;\\n            for(int j = 0; j < strs[0].length(); ++j)\\n            {\\n                for(int i = 1; i < strs.size(); ++i){\\n                    if(j >= strs[i].size() || strs[i][j] != strs[0][j])\\n                       return prefix;\\n                }\\n                prefix += strs[0][j];\\n            }\\n            return prefix;\\n        }",
                "solutionTags": [
                    "C++"
                ],
                "code": "     string longestCommonPrefix(vector<string> &strs) {\\n            string prefix = \"\";\\n            if(strs.empty()) return prefix;\\n            for(int j = 0; j < strs[0].length(); ++j)\\n            {\\n                for(int i = 1; i < strs.size(); ++i){\\n                    if(j >= strs[i].size() || strs[i][j] != strs[0][j])\\n                       return prefix;\\n                }\\n                prefix += strs[0][j];\\n            }\\n            return prefix;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3946986,
                "title": "java-runtime-1-ms-beats-82-61",
                "content": "# Intuition\\nMy initial thoughts on solving this problem involve finding the longest common prefix among a given array of strings. I plan to sort the array first to bring the strings with the common prefix closer to each other. Then, I will compare the first and last strings in the sorted array to find the common prefix.\\n\\n# Approach\\nI will sort the array of strings to ensure that the strings with the longest common prefix are close to each other. After sorting, I will take the first and last strings and compare their characters one by one until I encounter a mismatch. I will keep track of the count of matching characters to determine the length of the common prefix.\\n\\n# Complexity\\n- Time complexity: O(n * m)\\nHere, \\'n\\' is the number of strings in the array and \\'m\\' is the average length of the strings. Sorting the array takes O(n * log n) time, and then comparing the characters in the common prefix takes O(m) time. Thus, the overall time complexity is O(n * log n + m), which can be approximated as O(n * m).\\n\\n- Space complexity: O(1)\\n  The algorithm uses a constant amount of extra space for variables.\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        int count  = 0;\\n\\n        Arrays.sort(strs);\\n\\n        String start = strs[0];\\n\\n        String end  = strs[strs.length-1];\\n\\n        int i = 0 ;\\n        while (i<start.length() && i<end.length()){\\n\\n            if(start.charAt(i) == end.charAt(i)){\\n\\n                count++;\\n                i++;\\n            }\\n            else {\\n                break;\\n            }\\n\\n\\n        }\\n\\n        return start.substring(0,count);\\n        \\n\\n    }\\n}\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        int count  = 0;\\n\\n        Arrays.sort(strs);\\n\\n        String start = strs[0];\\n\\n        String end  = strs[strs.length-1];\\n\\n        int i = 0 ;\\n        while (i<start.length() && i<end.length()){\\n\\n            if(start.charAt(i) == end.charAt(i)){\\n\\n                count++;\\n                i++;\\n            }\\n            else {\\n                break;\\n            }\\n\\n\\n        }\\n\\n        return start.substring(0,count);\\n        \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451292,
                "title": "best-solution-by-java-in-runtime-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n         if (strs.length == 0){\\n                return \"\";\\n            }\\n\\n            String prefix = strs[0];\\n            int length = prefix.length();\\n\\n        for (int i = 1; i < strs.length; i++) {\\n            while (strs[i].indexOf(prefix) != 0){\\n                prefix = prefix.substring(0 , --length);\\n                if (length == 0){\\n                    return \"\";\\n                }\\n            }\\n            \\n        }\\n\\n        return prefix;\\n    }\\n}\\n```\\n\\n![b0e5afaa-48ec-4dcc-bd96-e39aa7a524f8_1681948924.2890832.png](https://assets.leetcode.com/users/images/7e978d3c-4abb-4d64-bb09-e5dfbf33b86d_1682356180.961795.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n         if (strs.length == 0){\\n                return \"\";\\n            }\\n\\n            String prefix = strs[0];\\n            int length = prefix.length();\\n\\n        for (int i = 1; i < strs.length; i++) {\\n            while (strs[i].indexOf(prefix) != 0){\\n                prefix = prefix.substring(0 , --length);\\n                if (length == 0){\\n                    return \"\";\\n                }\\n            }\\n            \\n        }\\n\\n        return prefix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684788,
                "title": "java-solution-simple-with-explanation-69-faster-then-other-9-line-code",
                "content": "![image](https://assets.leetcode.com/users/images/aafcadf5-cd6a-4bb6-ac77-7b3e89ffd06e_1665384459.5574121.png)\\n\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String r=\"\";\\n        int n=strs.length;\\n        Arrays.sort(strs);//Sorted first\\n        String s=strs[0];//smallest no of char\\n        String h=strs[n-1];//highest no of char\\n        for(int i =0;i<s.length();i++)//taken smallest length so that run time will be less\\n        {\\n            if(s.charAt(i)!=h.charAt(i)) break;\\n            r=r+s.charAt(i);  \\n        }\\n        return r;  \\n    }\\n}\\n\\n//Time complexity would be O(n)\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String r=\"\";\\n        int n=strs.length;\\n        Arrays.sort(strs);//Sorted first\\n        String s=strs[0];//smallest no of char\\n        String h=strs[n-1];//highest no of char\\n        for(int i =0;i<s.length();i++)//taken smallest length so that run time will be less\\n        {\\n            if(s.charAt(i)!=h.charAt(i)) break;\\n            r=r+s.charAt(i);  \\n        }\\n        return r;  \\n    }\\n}\\n\\n//Time complexity would be O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266870,
                "title": "c-using-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n=strs.size();\\n        string ans=\"\";\\n        sort(strs.begin(),strs.end());\\n        \\n        string a=strs[0];\\n        string b=strs[n-1];\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(a[i]==b[i])\\n            {\\n                ans+=a[i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nUpvote if you find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n=strs.size();\\n        string ans=\"\";\\n        sort(strs.begin(),strs.end());\\n        \\n        string a=strs[0];\\n        string b=strs[n-1];\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(a[i]==b[i])\\n            {\\n                ans+=a[i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264602,
                "title": "python-faster-98",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        \\n        ans = \\'\\'\\n        for i,val in enumerate(zip(*strs)):\\n            if len(set(val)) == 1:\\n                ans+= val[0]\\n            else:\\n                break\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        \\n        ans = \\'\\'\\n        for i,val in enumerate(zip(*strs)):\\n            if len(set(val)) == 1:\\n                ans+= val[0]\\n            else:\\n                break\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726743,
                "title": "c-solution-with-easy-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we find the smallest string and store in `str` & it\\u2019s size to `mn`\\n- We use 2 loops to access all the strings, if any point character of every element in a index doesn\\'t match then we\\u2019ll return string till that index.\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n = strs.size();\\n        int mn = INT_MAX, count = 0;\\n        string str;\\n        \\n        for(int i=0; i<n; i++){\\n            if(mn > strs[i].size()){\\n                mn = strs[i].size();\\n                str = strs[i];\\n            }\\n        }\\n        \\n        for(int i=0; i<mn; i++){\\n            for(int j=0; j<n; j++){\\n                if(strs[j][i] != str[i])\\n                    return str.substr(0, count);\\n            }\\n            count++;\\n        }\\n        return str.substr(0,count);        \\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n = strs.size();\\n        int mn = INT_MAX, count = 0;\\n        string str;\\n        \\n        for(int i=0; i<n; i++){\\n            if(mn > strs[i].size()){\\n                mn = strs[i].size();\\n                str = strs[i];\\n            }\\n        }\\n        \\n        for(int i=0; i<mn; i++){\\n            for(int j=0; j<n; j++){\\n                if(strs[j][i] != str[i])\\n                    return str.substr(0, count);\\n            }\\n            count++;\\n        }\\n        return str.substr(0,count);        \\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404383,
                "title": "python3-short-expressive-and-fast-solution-faster-than-99-73",
                "content": "```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n      prefix = \\'\\'\\n      for cmbn in zip(*strs):\\n        if len(set(cmbn)) > 1:\\n          break\\n        prefix += cmbn[0]\\n      return prefix\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n      prefix = \\'\\'\\n      for cmbn in zip(*strs):\\n        if len(set(cmbn)) > 1:\\n          break\\n        prefix += cmbn[0]\\n      return prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389414,
                "title": "easy-c-solution-4ms",
                "content": "Runtime: 4 ms, faster than 94.85% of C++ online submissions for Longest Common Prefix.\\nMemory Usage: 8.8 MB, less than 87.10% of C++ online submissions for Longest Common Prefix.\\n\\n```\\nstring longestCommonPrefix(vector<string>& strs) {\\n        \\n        if(strs.empty()) return \"\";\\n        \\n        for(int i=0; ; i++)\\n        {\\n            for(auto& s : strs)\\n            {\\n                if(i >= s.size() || s[i] != strs[0][i])\\n                    return strs[0].substr(0,i);\\n            }\\n        }\\n        \\n        return \"\";\\n    }",
                "solutionTags": [],
                "code": "Runtime: 4 ms, faster than 94.85% of C++ online submissions for Longest Common Prefix.\\nMemory Usage: 8.8 MB, less than 87.10% of C++ online submissions for Longest Common Prefix.\\n\\n```\\nstring longestCommonPrefix(vector<string>& strs) {\\n        \\n        if(strs.empty()) return \"\";\\n        \\n        for(int i=0; ; i++)\\n        {\\n            for(auto& s : strs)\\n            {\\n                if(i >= s.size() || s[i] != strs[0][i])\\n                    return strs[0].substr(0,i);\\n            }\\n        }\\n        \\n        return \"\";\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 164655,
                "title": "javascript-solution",
                "content": "```\\nvar longestCommonPrefix = function(strs) {\\n    if(!strs[0]) return \"\";\\n    let res = \"\";\\n    let cur = \"\";\\n    let i = 0;\\n    while(i < strs[0].length){\\n        cur = strs[0].substring(0, i + 1);\\n        let flag = strs.every(x => {\\n            return x.startsWith(cur);\\n        })\\n        if(flag === true){\\n            res = cur;\\n        }\\n        else break;\\n        i ++;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar longestCommonPrefix = function(strs) {\\n    if(!strs[0]) return \"\";\\n    let res = \"\";\\n    let cur = \"\";\\n    let i = 0;\\n    while(i < strs[0].length){\\n        cur = strs[0].substring(0, i + 1);\\n        let flag = strs.every(x => {\\n            return x.startsWith(cur);\\n        })\\n        if(flag === true){\\n            res = cur;\\n        }\\n        else break;\\n        i ++;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6934,
                "title": "simple-python-sol-32-ms",
                "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        result = \"\"       \\n        for n in zip(*strs):\\n            if len(set(n)) == 1:\\n                result += n[0]\\n            else:\\n                return result\\n        return result  \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        result = \"\"       \\n        for n in zip(*strs):\\n            if len(set(n)) == 1:\\n                result += n[0]\\n            else:\\n                return result\\n        return result  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825300,
                "title": "most-easy-javascript-solution-beat-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    if(!strs.length) return \\'\\'\\n    let longerstCommonPrefix = \\'\\'\\n    for(let i=0; i< strs[0].length; i++) {\\n        let char = strs[0][i]\\n        if(!char) return \\'\\'\\n        if(strs.every(str => str[i] === char)) {\\n            longerstCommonPrefix+=char\\n        } else break\\n    }\\n    return longerstCommonPrefix\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    if(!strs.length) return \\'\\'\\n    let longerstCommonPrefix = \\'\\'\\n    for(let i=0; i< strs[0].length; i++) {\\n        let char = strs[0][i]\\n        if(!char) return \\'\\'\\n        if(strs.every(str => str[i] === char)) {\\n            longerstCommonPrefix+=char\\n        } else break\\n    }\\n    return longerstCommonPrefix\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3386001,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity: O(S * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null || strs.length == 0) {\\n            return \"\";\\n        }\\n\\n        String prefix = strs[0];\\n\\n        for (int i = 1; i < strs.length; i++) {\\n            while (!strs[i].startsWith(prefix)) {\\n                prefix = prefix.substring(0, prefix.length() - 1);\\n                if (prefix.isEmpty()) {\\n                    return \"\";\\n                }\\n            }\\n        }\\n\\n        return prefix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null || strs.length == 0) {\\n            return \"\";\\n        }\\n\\n        String prefix = strs[0];\\n\\n        for (int i = 1; i < strs.length; i++) {\\n            while (!strs[i].startsWith(prefix)) {\\n                prefix = prefix.substring(0, prefix.length() - 1);\\n                if (prefix.isEmpty()) {\\n                    return \"\";\\n                }\\n            }\\n        }\\n\\n        return prefix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359811,
                "title": "simple-go-solution",
                "content": "# Code\\n```\\nfunc longestCommonPrefix(s []string) string {\\n\\tpref := s[0]\\n\\tfor i := 1; i < len(s); i++ {\\n\\t\\tfor !strings.HasPrefix(s[i], pref) {\\n\\t\\t\\tpref = pref[:len(pref)-1]\\n\\t\\t}\\n\\t\\tfmt.Println(s[i])\\n\\t}\\n\\treturn pref\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestCommonPrefix(s []string) string {\\n\\tpref := s[0]\\n\\tfor i := 1; i < len(s); i++ {\\n\\t\\tfor !strings.HasPrefix(s[i], pref) {\\n\\t\\t\\tpref = pref[:len(pref)-1]\\n\\t\\t}\\n\\t\\tfmt.Println(s[i])\\n\\t}\\n\\treturn pref\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2269966,
                "title": "java-better-than-100",
                "content": "An upvote would be appreciated, Thank you!\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length == 0)\\n        {\\n            return \"\";\\n        }\\n        String prefix=strs[0];\\n        for(int i=1;i<strs.length;i++)\\n        {\\n            while(strs[i].indexOf(prefix)!=0)\\n            {\\n                prefix=prefix.substring(0,prefix.length()-1);\\n            }\\n        }\\n        return prefix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length == 0)\\n        {\\n            return \"\";\\n        }\\n        String prefix=strs[0];\\n        for(int i=1;i<strs.length;i++)\\n        {\\n            while(strs[i].indexOf(prefix)!=0)\\n            {\\n                prefix=prefix.substring(0,prefix.length()-1);\\n            }\\n        }\\n        return prefix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141240,
                "title": "c-java-python3-solution-explanation",
                "content": "Here\\'s my blog written on 2022/06/12\\nWhich have include C#, Java, Python3 (JavaScript version will be updated in few days)\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/)\\u2B50\\n\\n#### Example : Java Code \\u27A1 Runtime : 1ms\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```\\n**You can find a faster solution in the link.**\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to leave your comment.\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899592,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func longestCommonPrefix(_ strs: [String]) -> String {\\n        guard strs.count > 0 else { return \"\" }\\n        let chars_array = strs.map({ Array($0) })\\n        var string = \"\"\\n        var i = 0\\n        \\n        while true {\\n            var c: Character? = nil\\n            for chars in chars_array {\\n                if i >= chars.count {\\n                    return string\\n                } else {\\n                    if c == nil {\\n                        c = chars[i]\\n                    } else if chars[i] != c! { return string }\\n                }  \\n            }\\n            string += String(c!)\\n            i += 1\\n        }\\n        \\n        return string\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestCommonPrefix(_ strs: [String]) -> String {\\n        guard strs.count > 0 else { return \"\" }\\n        let chars_array = strs.map({ Array($0) })\\n        var string = \"\"\\n        var i = 0\\n        \\n        while true {\\n            var c: Character? = nil\\n            for chars in chars_array {\\n                if i >= chars.count {\\n                    return string\\n                } else {\\n                    if c == nil {\\n                        c = chars[i]\\n                    } else if chars[i] != c! { return string }\\n                }  \\n            }\\n            string += String(c!)\\n            i += 1\\n        }\\n        \\n        return string\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751555,
                "title": "js-easy-clean-solution",
                "content": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    let firstStr = strs[0];\\n    for (let i = 0; i < firstStr.length; i++) {\\n        for (let s of strs) {\\n            if (s[i] !== firstStr[i]) return s.slice(0, i);\\n        }\\n    }\\n    return strs[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    let firstStr = strs[0];\\n    for (let i = 0; i < firstStr.length; i++) {\\n        for (let s of strs) {\\n            if (s[i] !== firstStr[i]) return s.slice(0, i);\\n        }\\n    }\\n    return strs[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 773126,
                "title": "python-sol-by-column-wise-slicing-w-comment",
                "content": "Python sol by column-wise slicing\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n\\t\\t\\n\\t\\t# generate column-wise slicing\\n        column_slices, common_prefix = zip(*strs), \\'\\'\\n        \\n        for current_column in column_slices:\\n            \\n            if len(set(current_column)) == 1:\\n\\t\\t\\t\\t# current column-wise slice\\'s character is the same\\n\\t\\t\\t\\t# update common prefix\\n                common_prefix += current_column[0]\\n            \\n            else:\\n\\t\\t\\t\\t# current column-wise slice\\'s character is different\\n                break\\n                \\n        return common_prefix\\n```\\n\\n---\\n\\n**Demo of zip(...)**, auto-align on length:\\n\\n![image](https://assets.leetcode.com/users/images/214b59f5-7200-435b-a974-1555668c69d5_1596559716.3218155.png)\\n\\n\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about zip( ... )](https://docs.python.org/3.3/library/functions.html#zip)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n\\t\\t\\n\\t\\t# generate column-wise slicing\\n        column_slices, common_prefix = zip(*strs), \\'\\'\\n        \\n        for current_column in column_slices:\\n            \\n            if len(set(current_column)) == 1:\\n\\t\\t\\t\\t# current column-wise slice\\'s character is the same\\n\\t\\t\\t\\t# update common prefix\\n                common_prefix += current_column[0]\\n            \\n            else:\\n\\t\\t\\t\\t# current column-wise slice\\'s character is different\\n                break\\n                \\n        return common_prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291314,
                "title": "ruby-solution",
                "content": "Take a base string (the first element in the array). Go through the the base string, and through each iteration check if the letter at index `i` exists in all the other words in the array. If it does, append it to the string `s`. If you reach a case where the letter at index `i` does not exist in some word in the array, break. \\n```\\ndef longest_common_prefix(strs)\\n    return \"\" if strs.empty? \\n    s = \"\"\\n    base = strs[0]\\n    for i in 0..base.length-1\\n        if strs.all?{|x| x[i] == base[i]}\\n            s += base[i]\\n        else\\n            break\\n        end\\n    end\\n    s\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef longest_common_prefix(strs)\\n    return \"\" if strs.empty? \\n    s = \"\"\\n    base = strs[0]\\n    for i in 0..base.length-1\\n        if strs.all?{|x| x[i] == base[i]}\\n            s += base[i]\\n        else\\n            break\\n        end\\n    end\\n    s\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 229160,
                "title": "python-7-lines-20ms-solution",
                "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        s = \\'\\'\\n        for i in zip(*strs):\\n            if len(set(i)) != 1:\\n                return s\\n            else:\\n                s += i[0]\\n        return s\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        s = \\'\\'\\n        for i in zip(*strs):\\n            if len(set(i)) != 1:\\n                return s\\n            else:\\n                s += i[0]\\n        return s\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 7066,
                "title": "my-simple-and-clean-c-code-solution",
                "content": "```   \\n string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.empty()) return \"\";\\n        string res = strs[0];\\n        for(int i=0; i<strs.size();i++)\\n            for(int j=0; j<res.size();j++)\\n                if(strs[i][j]!=res[j]) {res.resize(j); break;}\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```   \\n string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.empty()) return \"\";\\n        string res = strs[0];\\n        for(int i=0; i<strs.size();i++)\\n            for(int j=0; j<res.size();j++)\\n                if(strs[i][j]!=res[j]) {res.resize(j); break;}\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6968,
                "title": "simple-python-solution-using-min",
                "content": "    class Solution(object):\\n        def longestCommonPrefix(self, strs):\\n            if not strs: return ''\\n            first = min(strs)\\n            for i in range(len(first)):\\n                for s in strs:\\n                    if s[i] != first[i]:\\n                        return first[:i] if i > 0 else ''\\n            return first",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def longestCommonPrefix(self, strs):\\n            if not strs: return ''\\n            first = min(strs)\\n            for i in range(len(first)):\\n                for s in strs:\\n                    if s[i] != first[i]:\\n                        return first[:i] if i > 0 else ''\\n            return first",
                "codeTag": "Java"
            },
            {
                "id": 4062081,
                "title": "video-step-by-step-visualization-of-vertical-scanning-strategy",
                "content": "https://youtube.com/watch?v=SiNDN2M4dtQ\\n\\nThis solution is the <b>vertical scanning</b> approach that is discussed in the official solution, slightly modified for Python.  The idea is to scan the the first character of every word, then the second character, etc. until a mismatch is found.  At that point, we return a slice of the string which is the longest common prefix.\\n\\nThis is superior to horizontal scanning because even if a very short word is included in the array, the algorithm won\\'t do any extra work scanning the longer words and will still end when the end of the shortest word is reached.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \"\"\\n\\n        base = strs[0]\\n        for i in range(len(base)):\\n            for word in strs[1:]:\\n                if i == len(word) or word[i] != base[i]:\\n                    return base[0:i]\\n\\n        return base\\n  \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \"\"\\n\\n        base = strs[0]\\n        for i in range(len(base)):\\n            for word in strs[1:]:\\n                if i == len(word) or word[i] != base[i]:\\n                    return base[0:i]\\n\\n        return base\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010931,
                "title": "5-liner-easy-approach-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Firstly I was very confused about the problem because I have ignored the word \"prefix\". Prefix means the starting letters of the word. \\n- So if the starting letter of any word in the array will not be matched then we will simply return empty string and if first word will be matched in the every array of strings using every method then we will look for the second word ans so on..\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function (strs) {\\n    let output = \"\";\\n    for (let i = 0; i < strs[0].length; i++) {\\n        if(strs.every(str => str[i] === strs[0][i])) output += strs[0][i];\\n        else break;\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function (strs) {\\n    let output = \"\";\\n    for (let i = 0; i < strs[0].length; i++) {\\n        if(strs.every(str => str[i] === strs[0][i])) output += strs[0][i];\\n        else break;\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3302948,
                "title": "c-solution-easy-to-understand-100-fast",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n       string ans=\"\";\\n        vector<int>len;     //To store the length of every string present in the vector;\\n        int row=strs.size();  //size of row;\\n        for(int i=0;i<rows;i++)\\n        {\\n             len.emplace_back(strs[i].length()); \\n        }\\n        sort(len.begin(),len.end());  //Sort the len vector to find the minimum size;\\n        int col=len[0];   //Store the minimum size in column ;\\n        bool flag=true;\\n        for(int i=0;i<col;i++)\\n        { //column wise traversal\\n            for(int j=1;j<row;j++)\\n            {\\n                //Check every element in the column if it is equal to its next element or not\\n            \\n                if(strs[j-1][i]!=strs[j][i]){  \\n                    //If elements are not equal then make flag = false and break the loop   \\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag==true) \\n             count++; //This will store the numbers of column which are equal\\n        }\\n\\n         ans=strs[0].substr(0,count); //take the substring(of size equal to count) from any string present in strs vector;\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n       string ans=\"\";\\n        vector<int>len;     //To store the length of every string present in the vector;\\n        int row=strs.size();  //size of row;\\n        for(int i=0;i<rows;i++)\\n        {\\n             len.emplace_back(strs[i].length()); \\n        }\\n        sort(len.begin(),len.end());  //Sort the len vector to find the minimum size;\\n        int col=len[0];   //Store the minimum size in column ;\\n        bool flag=true;\\n        for(int i=0;i<col;i++)\\n        { //column wise traversal\\n            for(int j=1;j<row;j++)\\n            {\\n                //Check every element in the column if it is equal to its next element or not\\n            \\n                if(strs[j-1][i]!=strs[j][i]){  \\n                    //If elements are not equal then make flag = false and break the loop   \\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag==true) \\n             count++; //This will store the numbers of column which are equal\\n        }\\n\\n         ans=strs[0].substr(0,count); //take the substring(of size equal to count) from any string present in strs vector;\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459950,
                "title": "python-85-fast-88-less-space-easy-to-understand",
                "content": "Upvote if it helped. Thanks\\n\\n![image](https://assets.leetcode.com/users/images/f1fd820f-92fe-4d2c-8adf-bb3757ca241f_1661100206.6040626.png)\\n\\n\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        prefix = \"\"\\n\\t\\t\\n\\t\\t#here zip function creates tuples of all the characters of the string index wise. \\n\\t\\t# s= ((\\'f\\',\\'f\\',\\'f\\'), (\\'l\\', \\'l\\', \\'l\\') ........)\\n\\t\\t\\n        s = zip(*strs)\\n        for i in s:\\n            if len(set(i)) ==1 :\\n                prefix += i[0]\\n            else:\\n                break\\n        return prefix\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        prefix = \"\"\\n\\t\\t\\n\\t\\t#here zip function creates tuples of all the characters of the string index wise. \\n\\t\\t# s= ((\\'f\\',\\'f\\',\\'f\\'), (\\'l\\', \\'l\\', \\'l\\') ........)\\n\\t\\t\\n        s = zip(*strs)\\n        for i in s:\\n            if len(set(i)) ==1 :\\n                prefix += i[0]\\n            else:\\n                break\\n        return prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344186,
                "title": "most-optimal-solution-in-java",
                "content": "Easy code for all to understand.\\n\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length == 0){\\n            return \"\";\\n        }\\n        String prefix = strs[0];\\n        for(String s : strs){\\n            int len = Math.min(prefix.length(), s.length());\\n            for(int i = len; i >= 0; i--){\\n                if(prefix.indexOf(s.substring(0, i)) == 0){\\n                    prefix = s.substring(0, i);\\n                    break;\\n                }\\n            }\\n        }\\n        return prefix;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length == 0){\\n            return \"\";\\n        }\\n        String prefix = strs[0];\\n        for(String s : strs){\\n            int len = Math.min(prefix.length(), s.length());\\n            for(int i = len; i >= 0; i--){\\n                if(prefix.indexOf(s.substring(0, i)) == 0){\\n                    prefix = s.substring(0, i);\\n                    break;\\n                }\\n            }\\n        }\\n        return prefix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2244027,
                "title": "c-java-python3-javascript-solution-easy-code",
                "content": "**Which have included C#, Java, Python3,JavaScript solutions**\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/)\\u2B50**\\n\\n\\n#### Example : Java Code \\u27A1 Runtime : 1ms\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```\\n**You can find a faster Java solution in the link.**\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to leave your comment.\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241147,
                "title": "c-easy-simple-o-n-min-and-max-element",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n                \\n        string min=*min_element(strs.begin(),strs.end());  //smallest string\\n        string mx=*max_element(strs.begin(),strs.end()); //largest one\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        while(i<min.size() and min[i]==mx[j]) {   //loop until characters are matching\\n            i++;\\n            j++;\\n        }\\n        return mx.substr(0,i);    //return substring till any index i or j answer will be same\\n    }\\n};\\n\\nif(helpful)\\n\\tupVote();",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n                \\n        string min=*min_element(strs.begin(),strs.end());  //smallest string\\n        string mx=*max_element(strs.begin(),strs.end()); //largest one\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        while(i<min.size() and min[i]==mx[j]) {   //loop until characters are matching\\n            i++;\\n            j++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2204347,
                "title": "simple-javascript-solution-97-36-fast-with-95-67-less-memory-usage",
                "content": "![image](https://assets.leetcode.com/users/images/d638b758-4379-497b-a8a5-3b3843d0dcfe_1656320626.4312003.png)\\n\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n  if(strs.length === 1) return strs[0];\\n  \\n  strs.sort();\\n\\n  const strLastIndex = strs.length - 1;\\n  if(strs[0] === strs[strLastIndex]) return strs[0];\\n  \\n  let prefix = \"\";\\n  for(let i=0; i < strs[0].length; i++) {\\n    if(strs[0][i] === strs[strLastIndex][i]) {\\n      prefix += strs[0][i];\\n    } else {\\n      return prefix;\\n    }\\n  }\\n  \\n  return prefix;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n  if(strs.length === 1) return strs[0];\\n  \\n  strs.sort();\\n\\n  const strLastIndex = strs.length - 1;\\n  if(strs[0] === strs[strLastIndex]) return strs[0];\\n  \\n  let prefix = \"\";\\n  for(let i=0; i < strs[0].length; i++) {\\n    if(strs[0][i] === strs[strLastIndex][i]) {\\n      prefix += strs[0][i];\\n    } else {\\n      return prefix;\\n    }\\n  }\\n  \\n  return prefix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2019053,
                "title": "python-simplest-solution-in-o-nlog-n",
                "content": "Time: Avg case: O(nlog(n)) ; Worst case: O(mnlog(n)) [when all strings are of same size]; n: length of array; m: length of smallest string [Do correct me if I am wrong.]\\nSpace: O(1) on average; O(m) in worst case when all strings are same.; m: length of smallest string\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        strs.sort()\\n        pre = []\\n        \\n        for a,b in zip(strs[0], strs[-1]):\\n            if a == b:\\n                pre.append(a)\\n            else:\\n                break\\n        \\n        return \"\".join(pre)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        strs.sort()\\n        pre = []\\n        \\n        for a,b in zip(strs[0], strs[-1]):\\n            if a == b:\\n                pre.append(a)\\n            else:\\n                break\\n        \\n        return \"\".join(pre)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995677,
                "title": "c-100-faster-solution-explained",
                "content": "# C++ 100% Faster Solution Explained\\nWrite a function to find the longest common prefix string amongst an array of strings.\\nIf there is no common prefix, return an empty string \"\".\\n## Ex:\\n\\n\\tInput: strs = [\"flower\",\"flow\",\"flight\"]\\n\\tOutput: \"fl\"\\n\\n## Solution Logic:\\nThe coding for this solution is easy using the <b><a href=\"https://www.cplusplus.com/doc/tutorial/control/\">For Loop</a></b> to handle iteration. When we focus on the logic behind this problem, we must remember to account for all possible versions of the intput and how to deal with it:\\n### Iterating through everything - For Loops\\n<li>The <b>given vector has an undefined amount of elements</b>, and we must compare them all - therefore we cannot hardcode x number of comparisions between x number of strings\\n<li>We <b>only need to iterate to the end of one word</b> because <b>all words</b> must be equal - so if one word reaches the end, it cannot possibly be the same as the rest beyond its length\\n<li>Make sure the for-loops incase everything. <b>We must first iterate over the length of a string, then over the size of the vector</b> for desired results. Otherwise, if we swap the loops, the program will stop comparing the characters of the strings at the position equal to the length of the vector. EG: if we receive 3 strings of 10 letters each, the program will only compare the first 3 letters of each string rather than the entire string.\\n<br></br>\\n\\n### How to Tell When We Found the Largest Prefix - If Statement\\n<li>We reach a <b>position where the character</b> at that position in every given string <b>is not the same</b>\\n<li>We <b>reach the end of any string</b> - as anything beyond it does not exist to be the same as other strings\\n<br></br>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring longestCommonPrefix(vector<string>& strs) {\\n\\t\\t\\t//pos keeps track of the end of the common prefix, starts at 0 since its a prefix\\n\\t\\t\\tfor(int pos = 0; pos < strs[0].length(); ++pos) //iterates over the length of the first word\\n\\t\\t\\t\\tfor(int i = 1; i < strs.size(); ++i) //for all of the strings in the vector\\n\\t\\t\\t\\t\\t//compare each char of the first string to the char at the same pos in each following string\\n\\t\\t\\t\\t\\t//if we reach the end of any string or a pos where the chars do not match, we have the largest prefix\\n\\t\\t\\t\\t\\tif(pos == strs[i].length() || strs[i][pos] != strs[0][pos])\\n\\t\\t\\t\\t\\t\\treturn strs[0].substr(0, pos);\\n\\t\\t\\treturn strs[0];\\n\\t\\t}\\n\\t};\\n\\t\\nIf there\\'s anyway to explain this better please let my pea brain know thanks. If this helped and you have a moment, <b>please upvote so my professor knows I did my homework</b>. Thanks.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring longestCommonPrefix(vector<string>& strs) {\\n\\t\\t\\t//pos keeps track of the end of the common prefix, starts at 0 since its a prefix\\n\\t\\t\\tfor(int pos = 0; pos < strs[0].length(); ++pos) //iterates over the length of the first word\\n\\t\\t\\t\\tfor(int i = 1; i < strs.size(); ++i) //for all of the strings in the vector\\n\\t\\t\\t\\t\\t//compare each char of the first string to the char at the same pos in each following string\\n\\t\\t\\t\\t\\t//if we reach the end of any string or a pos where the chars do not match, we have the largest prefix\\n\\t\\t\\t\\t\\tif(pos == strs[i].length() || strs[i][pos] != strs[0][pos])\\n\\t\\t\\t\\t\\t\\treturn strs[0].substr(0, pos);\\n\\t\\t\\treturn strs[0];\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1663118,
                "title": "javascript-simple-solution-using-every-function",
                "content": "```\\nvar longestCommonPrefix = function(strs) {\\n    let prefix = \\'\\';\\n    \\n    for (let i = 0; i <= strs[0].length; i++) {\\n        const nextPrefix = strs[0].slice(0, i);\\n        \\n        if (strs.every(str => str.slice(0, i) === nextPrefix)) {\\n            prefix = nextPrefix;\\n        } else {\\n            break;\\n        }\\n    }\\n    \\n    return prefix;\\n};\\n```\\n\\nThe idea is to slice strings char by char, and using the `.every()` function to compare if each inputed strings have the same slices.\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestCommonPrefix = function(strs) {\\n    let prefix = \\'\\';\\n    \\n    for (let i = 0; i <= strs[0].length; i++) {\\n        const nextPrefix = strs[0].slice(0, i);\\n        \\n        if (strs.every(str => str.slice(0, i) === nextPrefix)) {\\n            prefix = nextPrefix;\\n        } else {\\n            break;\\n        }\\n    }\\n    \\n    return prefix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1585205,
                "title": "c-short-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string prefix = \"\";\\n        for(int i=0;i<strs[0].size();++i){\\n            for(int j=1;j<strs.size();++j){\\n                if(strs[j][i]!=strs[0][i]) return prefix;\\n            }\\n              prefix+=strs[0][i];\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string prefix = \"\";\\n        for(int i=0;i<strs[0].size();++i){\\n            for(int j=1;j<strs.size();++j){\\n                if(strs[j][i]!=strs[0][i]) return prefix;\\n            }\\n              prefix+=strs[0][i];\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410235,
                "title": "javascript-simple-solution",
                "content": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    let prefix = \\'\\';\\n    if (strs.length === 1) return strs[0];\\n    for (let i = 0; i < strs[0].length; i++) {\\n        let currentChar = strs[0][i];\\n        if (currentChar && strs.every((s) => s[i] == currentChar)) {\\n            prefix += currentChar;\\n        } else {\\n            return prefix;\\n        }\\n    }\\n    \\n    return prefix;\\n};\\n```\\n\\nStats:\\nRuntime: 72 ms, faster than 90.42% of JavaScript online submissions for Longest Common Prefix.\\nMemory Usage: 40.4 MB, less than 41.53% of JavaScript online submissions for Longest Common Prefix.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    let prefix = \\'\\';\\n    if (strs.length === 1) return strs[0];\\n    for (let i = 0; i < strs[0].length; i++) {\\n        let currentChar = strs[0][i];\\n        if (currentChar && strs.every((s) => s[i] == currentChar)) {\\n            prefix += currentChar;\\n        } else {\\n            return prefix;\\n        }\\n    }\\n    \\n    return prefix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936274,
                "title": "c-detailed-explanation-for-longest-common-prefix",
                "content": "```class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.size() == 0) {\\n            return \"\";\\n        }\\n        \\n        // First let\\'s assume that the entire first string\\n        // is the common prefix.\\n        //\\n        std::string prefix = strs[0];\\n        \\n        // Now we iterate through the list of strings, and \\n        // for each string, we see how much of it matches with\\n        // our prefix. The size of the prefix keeps decreasing.\\n        //\\n        for(int i = 1; i < strs.size(); ++i) {\\n            // As long as you don\\'t find the prefix, keep decreasing\\n            // it\\'s size.\\n            //\\n            while(strs[i].find(prefix) != 0) {\\n                prefix = prefix.substr(0, prefix.length() - 1);\\n            }\\n            if(prefix.length() == 0) return \"\";\\n        }\\n        \\n        return prefix;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.size() == 0) {\\n            return \"\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 795155,
                "title": "simple-o-nlogn-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int n=strs.size();\\n        string ans=\"\";\\n        if(n==0)\\n            return ans;\\n        vector<string> k=strs;\\n        sort(k.begin(),k.end());\\n        string one=k[0],two=k[n-1];\\n        int i=0,j=0;\\n        int x=one.length();\\n        int y=two.length();\\n        for(;i<x and j<y;i++,j++)\\n        {\\n            if(one[i]!=two[j])\\n                break;\\n            ans+=one[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int n=strs.size();\\n        string ans=\"\";\\n        if(n==0)\\n            return ans;\\n        vector<string> k=strs;\\n        sort(k.begin(),k.end());\\n        string one=k[0],two=k[n-1];\\n        int i=0,j=0;\\n        int x=one.length();\\n        int y=two.length();\\n        for(;i<x and j<y;i++,j++)\\n        {\\n            if(one[i]!=two[j])\\n                break;\\n            ans+=one[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565521,
                "title": "java-trie",
                "content": "This question is the best example to use a Trie. If you are familiar with Trie, then great. All you need is the \"insert\" function and a \"traversal\" function. Else follow the link mentioned below to understand.\\n\\nRefer to Trie : [ https://leetcode.com/problems/implement-trie-prefix-tree/solution/ ] \\n\\n```\\nclass Node {\\n    // Here : used a TreeMap because there is a need to maintain the insertion order\\n    TreeMap<Character, Node> children;\\n    boolean endOfWord;\\n    \\n    Node() {\\n        children = new TreeMap<>();\\n        endOfWord = false;\\n    }\\n}\\n\\nclass Solution {\\n    Node root;\\n    \\n\\t// insert the characters in trie\\n    public void insert(String word) {\\n        Node curr = this.root;\\n        for(int i=0;i<word.length();i++) {\\n            char ch = word.charAt(i);\\n            if( curr.children.get(ch) == null ) {\\n                curr.children.put(ch, new Node());\\n            }\\n            curr = curr.children.get(ch);\\n        }\\n        curr.endOfWord = true;\\n    }\\n    \\n\\t// Function : find the longest common prefix\\n    public String lcp() {\\n        \\n        StringBuilder result = new StringBuilder();\\n        Node curr = this.root;\\n        while(curr!=null && !curr.endOfWord && curr.children.size()==1) {\\n            \\n            // iterate the map and keep on appending the Character with the answer\\n\\t\\t\\t// much simpler iterator below \\n            Iterator<Map.Entry<Character, Node>> treemapItertor = curr.children.entrySet().iterator();\\n            \\n\\t\\t\\tif(treemapItertor.hasNext()) {\\n                Map.Entry<Character, Node> entry = treemapItertor.next();\\n\\t\\t\\t\\tresult.append(entry.getKey());\\n\\t\\t\\t\\tcurr = entry.getValue();\\n            }\\n        }\\n\\n\\t\\t/*  This can also be done like below : \\n\\t\\t\\t\\twhile(curr!=null && !curr.isEndOfWord && curr.children.size() == 1) {\\n\\t\\t\\t\\t\\tfor(Character key : curr.children.keySet()) {\\n\\t\\t\\t\\t\\t\\t result.append(key);\\n\\t\\t\\t\\t\\t\\tcurr = curr.children.get(key);\\n\\t\\t\\t\\t\\t\\tbreak;  // break out this for loop as we want only the single character\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t*/\\n        return result.toString();\\n    }\\n    public String longestCommonPrefix(String[] strs) {\\n        Solution trieObj = new Solution();\\n        trieObj.root = new Node();\\n        \\n        if(strs==null || strs.length==0) {\\n            return new String(\"\");\\n        }\\n\\t\\t// insert the words in Trie\\n        for(String s : strs) {\\n            trieObj.insert(s);\\n        }\\n\\t\\t// find the LCP !\\n        return trieObj.lcp();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Node {\\n    // Here : used a TreeMap because there is a need to maintain the insertion order\\n    TreeMap<Character, Node> children;\\n    boolean endOfWord;\\n    \\n    Node() {\\n        children = new TreeMap<>();\\n        endOfWord = false;\\n    }\\n}\\n\\nclass Solution {\\n    Node root;\\n    \\n\\t// insert the characters in trie\\n    public void insert(String word) {\\n        Node curr = this.root;\\n        for(int i=0;i<word.length();i++) {\\n            char ch = word.charAt(i);\\n            if( curr.children.get(ch) == null ) {\\n                curr.children.put(ch, new Node());\\n            }\\n            curr = curr.children.get(ch);\\n        }\\n        curr.endOfWord = true;\\n    }\\n    \\n\\t// Function : find the longest common prefix\\n    public String lcp() {\\n        \\n        StringBuilder result = new StringBuilder();\\n        Node curr = this.root;\\n        while(curr!=null && !curr.endOfWord && curr.children.size()==1) {\\n            \\n            // iterate the map and keep on appending the Character with the answer\\n\\t\\t\\t// much simpler iterator below \\n            Iterator<Map.Entry<Character, Node>> treemapItertor = curr.children.entrySet().iterator();\\n            \\n\\t\\t\\tif(treemapItertor.hasNext()) {\\n                Map.Entry<Character, Node> entry = treemapItertor.next();\\n\\t\\t\\t\\tresult.append(entry.getKey());\\n\\t\\t\\t\\tcurr = entry.getValue();\\n            }\\n        }\\n\\n\\t\\t/*  This can also be done like below : \\n\\t\\t\\t\\twhile(curr!=null && !curr.isEndOfWord && curr.children.size() == 1) {\\n\\t\\t\\t\\t\\tfor(Character key : curr.children.keySet()) {\\n\\t\\t\\t\\t\\t\\t result.append(key);\\n\\t\\t\\t\\t\\t\\tcurr = curr.children.get(key);\\n\\t\\t\\t\\t\\t\\tbreak;  // break out this for loop as we want only the single character\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t*/\\n        return result.toString();\\n    }\\n    public String longestCommonPrefix(String[] strs) {\\n        Solution trieObj = new Solution();\\n        trieObj.root = new Node();\\n        \\n        if(strs==null || strs.length==0) {\\n            return new String(\"\");\\n        }\\n\\t\\t// insert the words in Trie\\n        for(String s : strs) {\\n            trieObj.insert(s);\\n        }\\n\\t\\t// find the LCP !\\n        return trieObj.lcp();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 331851,
                "title": "python-trie",
                "content": "```python\\nclass TrieNode(object):\\n    \"\"\"Trie Node with a maximum of 26 links (a-z)\"\"\"\\n    ALPHABET = 26\\n\\n    def __init__(self):\\n        self._links = {}\\n        self.is_end = False\\n        self.link_size = 0\\n\\n    def contains_key(self, char):\\n        \"\"\"Check if charater has a child link in node\"\"\"\\n        return char in self._links\\n\\n    def get(self, char):\\n        \"\"\"Get child link for character\"\"\"\\n        return self._links[char]\\n\\n    def put(self, char, node):\\n        \"\"\"Set child link for character\"\"\"\\n        self._links[char] = node\\n        self.link_size += 1\\n        \\nclass Trie(object):\\n    \"\"\"Trie for strings of lower case letter a-z\"\"\"\\n    def __init__(self):\\n        self._root = TrieNode()\\n\\n    def insert(self, word):\\n        \"\"\"Insert word into the Trie\"\"\"\\n        node = self._root\\n        for char in word:\\n            if not node.contains_key(char):\\n                node.put(char, TrieNode())\\n            node = node.get(char)\\n        node.is_end = True\\n\\n    def _search_prefix(self, word):\\n        \"\"\"Search whole key or prefix in the Trie\\n           and return the node where the search ends\"\"\"\\n        node = self._root\\n        for char in word:\\n            if not node.contains_key(char):\\n                return None\\n            node = node.get(char)\\n        return node\\n\\n    def search(self, word):\\n        \"\"\"Search if a word is in the Trie\"\"\"\\n        node = self._search_prefix(word)\\n        return node is not None and node.is_end\\n\\n    def startswith(self, prefix):\\n        \"\"\"Search if prefix exist in Trie\"\"\"\\n        node = self._search_prefix(prefix)\\n        return node is not None\\n    \\n    def search_longest_prefix(self, word):\\n        \"\"\"Search longest prefix in Trie\"\"\"\\n        node = self._root\\n        prefix = \"\"\\n        for char in word:\\n            if (not node.contains_key(char) \\n                or node.link_size != 1\\n                or node.is_end):\\n                return prefix\\n            \\n            prefix += char\\n            node = node.get(char)\\n        \\n        return prefix\\n        \\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if not strs:\\n            return \"\"\\n        \\n        if len(strs) == 1:\\n            return strs[0]\\n        \\n        trie = Trie()\\n        for s in islice(strs, 1, None):\\n            trie.insert(s)\\n        \\n        return trie.search_longest_prefix(strs[0])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass TrieNode(object):\\n    \"\"\"Trie Node with a maximum of 26 links (a-z)\"\"\"\\n    ALPHABET = 26\\n\\n    def __init__(self):\\n        self._links = {}\\n        self.is_end = False\\n        self.link_size = 0\\n\\n    def contains_key(self, char):\\n        \"\"\"Check if charater has a child link in node\"\"\"\\n        return char in self._links\\n\\n    def get(self, char):\\n        \"\"\"Get child link for character\"\"\"\\n        return self._links[char]\\n\\n    def put(self, char, node):\\n        \"\"\"Set child link for character\"\"\"\\n        self._links[char] = node\\n        self.link_size += 1\\n        \\nclass Trie(object):\\n    \"\"\"Trie for strings of lower case letter a-z\"\"\"\\n    def __init__(self):\\n        self._root = TrieNode()\\n\\n    def insert(self, word):\\n        \"\"\"Insert word into the Trie\"\"\"\\n        node = self._root\\n        for char in word:\\n            if not node.contains_key(char):\\n                node.put(char, TrieNode())\\n            node = node.get(char)\\n        node.is_end = True\\n\\n    def _search_prefix(self, word):\\n        \"\"\"Search whole key or prefix in the Trie\\n           and return the node where the search ends\"\"\"\\n        node = self._root\\n        for char in word:\\n            if not node.contains_key(char):\\n                return None\\n            node = node.get(char)\\n        return node\\n\\n    def search(self, word):\\n        \"\"\"Search if a word is in the Trie\"\"\"\\n        node = self._search_prefix(word)\\n        return node is not None and node.is_end\\n\\n    def startswith(self, prefix):\\n        \"\"\"Search if prefix exist in Trie\"\"\"\\n        node = self._search_prefix(prefix)\\n        return node is not None\\n    \\n    def search_longest_prefix(self, word):\\n        \"\"\"Search longest prefix in Trie\"\"\"\\n        node = self._root\\n        prefix = \"\"\\n        for char in word:\\n            if (not node.contains_key(char) \\n                or node.link_size != 1\\n                or node.is_end):\\n                return prefix\\n            \\n            prefix += char\\n            node = node.get(char)\\n        \\n        return prefix\\n        \\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if not strs:\\n            return \"\"\\n        \\n        if len(strs) == 1:\\n            return strs[0]\\n        \\n        trie = Trie()\\n        for s in islice(strs, 1, None):\\n            trie.insert(s)\\n        \\n        return trie.search_longest_prefix(strs[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7108,
                "title": "java-solution-using-trie",
                "content": "Trie is a great solution for problems about prefix or string processing. And because of my intuition, I implementing a Trie for this question. May be its slow for this question, but I think it would definitely has advantage when the data set is very large. \\nAnyway, it an interesting method to use and practice. In case any one would want to see it, here is my code. \\n\\n```\\npublic class Solution {\\n    /**\\n     * Use a Trie to store all the strings. And this data structure is naturelly suited to find common prefix since it uses common prefix to store and search the strings. \\n     * All we have to do is print out the TrieNodes with only 1 child, indicating they are the common prefix of all the strings. \\n    **/\\n    \\n    public String longestCommonPrefix(String[] strs) {\\n        Trie trie = new Trie();\\n        for (String str : strs) {\\n            trie.insert(str);\\n        }\\n        TrieNode current = trie.root;\\n        String result = \"\";\\n        while (current.isEnd != true) {\\n            int count = 0;\\n            int index = 0;\\n            for (int i = 0; i < 26; i++) {\\n                if (current.childs[i] != null) {\\n                    count += 1;\\n                    index = i;\\n                }\\n            }\\n            if (count != 1) return result;  //Once we find a node whose childs number is not 1, say, either 0 or more than 1, common prefix have been found\\n            current = current.childs[index];\\n            result += String.valueOf(current.value);\\n        }\\n        return result;\\n        \\n    }\\n    \\n    class TrieNode {\\n        static final int numAlpha = 26;\\n        char value;\\n        int count;\\n        TrieNode[] childs;\\n        boolean isEnd;\\n        public TrieNode(char c) {\\n            value = c;\\n            count = 0;\\n            childs = new TrieNode[numAlpha];\\n            isEnd = false;\\n        }\\n    }\\n    \\n    class Trie {\\n        TrieNode root;\\n        public Trie() {\\n            root = new TrieNode(' ');\\n        }\\n        \\n        public void insert(String word) {\\n            if (this.search(word) == true) return;\\n            \\n            TrieNode current = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                if (c >= 'A' && c <= 'Z') {\\n                    c = (char)(c + 'a' - 'A');\\n                }\\n                if (current.childs[c - 'a'] != null) {\\n                    current = current.childs[c - 'a'];\\n                }\\n                else {\\n                    current.childs[c - 'a'] = new TrieNode(c);\\n                    current = current.childs[c - 'a'];\\n                }\\n                current.count++;\\n            }\\n            current.isEnd = true;\\n        }\\n        \\n        public boolean search(String word) {\\n            TrieNode current = root;\\n            \\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                int index = 0;\\n                if (c >= 'A' && c <= 'Z') {\\n                    index = c - 'A';\\n                }\\n                else {\\n                    index = c - 'a';\\n                }\\n                if (current.childs[index] == null) {\\n                    return false;\\n                }\\n                else {\\n                    current = current.childs[index];\\n                }\\n            }\\n            if (current.isEnd == true) {\\n                return true;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /**\\n     * Use a Trie to store all the strings. And this data structure is naturelly suited to find common prefix since it uses common prefix to store and search the strings. \\n     * All we have to do is print out the TrieNodes with only 1 child, indicating they are the common prefix of all the strings. \\n    **/\\n    \\n    public String longestCommonPrefix(String[] strs) {\\n        Trie trie = new Trie();\\n        for (String str : strs) {\\n            trie.insert(str);\\n        }\\n        TrieNode current = trie.root;\\n        String result = \"\";\\n        while (current.isEnd != true) {\\n            int count = 0;\\n            int index = 0;\\n            for (int i = 0; i < 26; i++) {\\n                if (current.childs[i] != null) {\\n                    count += 1;\\n                    index = i;\\n                }\\n            }\\n            if (count != 1) return result;  //Once we find a node whose childs number is not 1, say, either 0 or more than 1, common prefix have been found\\n            current = current.childs[index];\\n            result += String.valueOf(current.value);\\n        }\\n        return result;\\n        \\n    }\\n    \\n    class TrieNode {\\n        static final int numAlpha = 26;\\n        char value;\\n        int count;\\n        TrieNode[] childs;\\n        boolean isEnd;\\n        public TrieNode(char c) {\\n            value = c;\\n            count = 0;\\n            childs = new TrieNode[numAlpha];\\n            isEnd = false;\\n        }\\n    }\\n    \\n    class Trie {\\n        TrieNode root;\\n        public Trie() {\\n            root = new TrieNode(' ');\\n        }\\n        \\n        public void insert(String word) {\\n            if (this.search(word) == true) return;\\n            \\n            TrieNode current = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                if (c >= 'A' && c <= 'Z') {\\n                    c = (char)(c + 'a' - 'A');\\n                }\\n                if (current.childs[c - 'a'] != null) {\\n                    current = current.childs[c - 'a'];\\n                }\\n                else {\\n                    current.childs[c - 'a'] = new TrieNode(c);\\n                    current = current.childs[c - 'a'];\\n                }\\n                current.count++;\\n            }\\n            current.isEnd = true;\\n        }\\n        \\n        public boolean search(String word) {\\n            TrieNode current = root;\\n            \\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                int index = 0;\\n                if (c >= 'A' && c <= 'Z') {\\n                    index = c - 'A';\\n                }\\n                else {\\n                    index = c - 'a';\\n                }\\n                if (current.childs[index] == null) {\\n                    return false;\\n                }\\n                else {\\n                    current = current.childs[index];\\n                }\\n            }\\n            if (current.isEnd == true) {\\n                return true;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566649,
                "title": "longest-common-prefix-optimized-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty())\\n            return \"\";\\n        \\n        string prefix = strs[0];\\n        \\n        for (int i = 1; i < strs.size(); i++) {\\n            while (strs[i].find(prefix) != 0) {\\n                prefix = prefix.substr(0, prefix.length() - 1);\\n                \\n                if (prefix.empty())\\n                    return \"\";\\n            }\\n        }\\n        \\n        return prefix;\\n    }\\n};\\n```\\n\\nExplanation:\\n\\n1. We define a longestCommonPrefix function that takes a vector of strings strs as input and returns the longest common prefix string.\\n2. If the input vector strs is empty, we immediately return an empty string.\\n3. We initialize the prefix string with the first string in the vector strs.\\n4. We iterate through the remaining strings in the vector, starting from the second string (index 1).\\n5. In each iteration, we check if the prefix is a prefix of the current string strs[i] using the find function. If it is not a prefix, we remove the last character from the prefix by using substr with the starting index 0 and length prefix.length() - 1.\\n6. We continue this process until the prefix becomes a prefix of the current string or until it becomes an empty string. If the prefix becomes empty, it means there is no common prefix among the strings, so we return an empty string.\\n7. Finally, we return the resulting prefix string, which represents the longest common prefix among all the strings in the vector strs.\\n\\nThe time complexity of this solution is O(N * M), where N is the number of strings in the vector strs and M is the length of the shortest string in the vector.\\n\\n**PLEASE UPVOTE :)**\\n\\n",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty())\\n            return \"\";\\n        \\n        string prefix = strs[0];\\n        \\n        for (int i = 1; i < strs.size(); i++) {\\n            while (strs[i].find(prefix) != 0) {\\n                prefix = prefix.substr(0, prefix.length() - 1);\\n                \\n                if (prefix.empty())\\n                    return \"\";\\n            }\\n        }\\n        \\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504703,
                "title": "java-solution-easy-to-understand",
                "content": "# Approach\\nThe given code implements the `longestCommonPrefix` method, which takes an array of strings `strs` as input and returns the longest common prefix among the strings. Here is an explanation of the approach used in the code:\\n\\n1. Initialize a variable `ans` with the first string in the array `strs`. This is done assuming that the first string is the initial common prefix.\\n\\n2. Initialize an empty string `sub` to store the temporary common prefix between `ans` and the current string being checked.\\n\\n3. Iterate through the remaining strings in the `strs` array starting from the second string.\\n\\n4. For each string, iterate through its characters and compare them with the characters at the corresponding positions in `ans`. The inner loop runs until either the end of the current string or the end of `ans`, whichever is shorter.\\n\\n5. If the characters at the current position in both `ans` and the current string are the same, append that character to the `sub` string.\\n\\n6. If the characters at the current position are not the same, break out of the inner loop because it means that the common prefix ends at this point.\\n\\n7. Update `ans` to be equal to `sub`, which contains the common prefix found so far.\\n\\n8. Reset `sub` to an empty string for the next iteration.\\n\\n9. After all the strings have been processed, the value of `ans` will be the longest common prefix among all the strings.\\n\\n10. Finally, return the `ans` string as the result.\\n\\nNote: The code assumes that the input `strs` array is not empty and contains at least one string.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the given code is O(N * M), where N is the length of the input array strs and M is the length of the shortest string in strs\\n\\n- Space complexity:\\nThe space complexity of the code is O(M), where M is the length of the shortest string in strs.\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {     \\n        String ans = strs[0];\\n        String sub = \"\";\\n        \\n        for (int i = 1; i < strs.length; i++) {\\n            \\n            for (int j = 0; j < Math.min(ans.length(), strs[i].length()); j++) {\\n\\n                if (ans.charAt(j) == strs[i].charAt(j)) {\\n                    sub += ans.charAt(j);\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            ans = sub;\\n            sub = \"\";\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {     \\n        String ans = strs[0];\\n        String sub = \"\";\\n        \\n        for (int i = 1; i < strs.length; i++) {\\n            \\n            for (int j = 0; j < Math.min(ans.length(), strs[i].length()); j++) {\\n\\n                if (ans.charAt(j) == strs[i].charAt(j)) {\\n                    sub += ans.charAt(j);\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            ans = sub;\\n            sub = \"\";\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316480,
                "title": "powerful-logic-with-sort-approach-and-prefix-tree-python",
                "content": "# 1.  Sort approach:\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        ans=\"\"\\n        n=len(strs)\\n        strs.sort()\\n        for i in range(len(strs[0])):\\n            if strs[0][i]==strs[n-1][i]:\\n                ans+=strs[0][i]\\n            else:\\n                break\\n        return ans\\n```\\n\\n# Prefix Tree Approach\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if not strs:\\n            return \"\"\\n        short=min(strs,key=len)\\n        for i,v in enumerate(short):\\n            for w in strs:\\n                if w[i]!=short[i]:\\n                    return short[:i]\\n        return short \\n        \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        ans=\"\"\\n        n=len(strs)\\n        strs.sort()\\n        for i in range(len(strs[0])):\\n            if strs[0][i]==strs[n-1][i]:\\n                ans+=strs[0][i]\\n            else:\\n                break\\n        return ans\\n```\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if not strs:\\n            return \"\"\\n        short=min(strs,key=len)\\n        for i,v in enumerate(short):\\n            for w in strs:\\n                if w[i]!=short[i]:\\n                    return short[:i]\\n        return short \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194229,
                "title": "easy-approach-without-sorting-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncomparing the characters of the smallest string in the given string array!!\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        StringBuffer ans=new StringBuffer();\\n        if(strs.length==1)\\n        {\\n            return strs[0];\\n        }\\n        // FINDING THE SMALLEST STRING\\n        int min=strs[0].length();\\n  \\n        int index=0;\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            if(strs[i].length()<min)\\n            {\\n                min=strs[i].length();\\n                index=i;\\n            }\\n        }\\n        // COMPARING THE CHARACTERS OF ALL OTHER STRING WITH THE        SMALLEST STRING AND...\\n        String check=strs[index];\\n        <!-- System.out.println(check); -->\\n        for(int i=0;i<check.length();i++)\\n        {\\n            char ch=check.charAt(i);\\n            for(int j=0;j<strs.length;j++)\\n            {\\n                if(strs[j].charAt(i)!=ch)\\n                {\\n                    return ans+\"\";\\n                }\\n                \\n            }\\n            ans.append(ch);\\n        }\\n        return ans+\"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        StringBuffer ans=new StringBuffer();\\n        if(strs.length==1)\\n        {\\n            return strs[0];\\n        }\\n        // FINDING THE SMALLEST STRING\\n        int min=strs[0].length();\\n  \\n        int index=0;\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            if(strs[i].length()<min)\\n            {\\n                min=strs[i].length();\\n                index=i;\\n            }\\n        }\\n        // COMPARING THE CHARACTERS OF ALL OTHER STRING WITH THE        SMALLEST STRING AND...\\n        String check=strs[index];\\n        <!-- System.out.println(check); -->\\n        for(int i=0;i<check.length();i++)\\n        {\\n            char ch=check.charAt(i);\\n            for(int j=0;j<strs.length;j++)\\n            {\\n                if(strs[j].charAt(i)!=ch)\\n                {\\n                    return ans+\"\";\\n                }\\n                \\n            }\\n            ans.append(ch);\\n        }\\n        return ans+\"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773589,
                "title": "efficient-python-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Start from the first index of strs[0]\\n- Loop through strs (array)\\n- If not same: return prefix\\n- else: add prefix\\n\\n# Complexity\\n- Time complexity: $$O(n*n[0].length)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ *(Not counting result)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        prefix = \\'\\'\\n\\n        for p in range(len(strs[0])):\\n            for m in range(1, len(strs)):\\n                if p > len(strs[m])-1 or strs[m][p] != strs[0][p]:\\n                    return prefix\\n            prefix += strs[0][p]\\n        return prefix\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        prefix = \\'\\'\\n\\n        for p in range(len(strs[0])):\\n            for m in range(1, len(strs)):\\n                if p > len(strs[m])-1 or strs[m][p] != strs[0][p]:\\n                    return prefix\\n            prefix += strs[0][p]\\n        return prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553219,
                "title": "simplest-java-solution-ever-for-the-problem-with-explanation",
                "content": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        //if we see the string in arrays carefully we can say that if \\n        //arreange them in lexicogrphy order and check for the first and last \\n        //string for same prefix we will get the ans\\n        //no need to travels and check all the strings\\n                \\n        Arrays.sort(strs);//sorting the strs array\\n        String start = strs[0];//taking first string in sorted array\\n        String end = strs[strs.length-1];//taking last string in sorted array\\n        String s = \"\";//creating an empty string\\n        for(int i=0; i<start.length(); i++){\\n            if(start.charAt(i)==end.charAt(i)){//checking the elemet in first & last string\\n                s += start.charAt(i);//if same add in string s\\n            }\\n            else{\\n                break;//if letters are not same break the loop \\n            }\\n        }\\n        return s;\\n    }\\n}\\n```\\nIf u like the solution plz upvote",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        //if we see the string in arrays carefully we can say that if \\n        //arreange them in lexicogrphy order and check for the first and last \\n        //string for same prefix we will get the ans\\n        //no need to travels and check all the strings\\n                \\n        Arrays.sort(strs);//sorting the strs array\\n        String start = strs[0];//taking first string in sorted array\\n        String end = strs[strs.length-1];//taking last string in sorted array\\n        String s = \"\";//creating an empty string\\n        for(int i=0; i<start.length(); i++){\\n            if(start.charAt(i)==end.charAt(i)){//checking the elemet in first & last string\\n                s += start.charAt(i);//if same add in string s\\n            }\\n            else{\\n                break;//if letters are not same break the loop \\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430629,
                "title": "c-linq-solution",
                "content": "```\\npublic class Solution {\\n    public string LongestCommonPrefix(string[] strs)\\n    {\\n        if (!strs.Any())\\n            return string.Empty;\\n\\n        var shortestWord = strs.MinBy(a => a.Length);\\n        for (var i = shortestWord.Length; i > 0; i--)\\n        {\\n            if (strs.All(a => a.StartsWith(shortestWord[..i])))\\n                return shortestWord[..i];\\n        }\\n\\n        return string.Empty;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string LongestCommonPrefix(string[] strs)\\n    {\\n        if (!strs.Any())\\n            return string.Empty;\\n\\n        var shortestWord = strs.MinBy(a => a.Length);\\n        for (var i = shortestWord.Length; i > 0; i--)\\n        {\\n            if (strs.All(a => a.StartsWith(shortestWord[..i])))\\n                return shortestWord[..i];\\n        }\\n\\n        return string.Empty;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193815,
                "title": "python-3-liner-clean-code-zip-function",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        res=\"\"\\n        for i in list(zip(*strs)):\\n            if len(set(i))==1: res+=i[0]\\n            else: break\\n        return res\\n\\n```\\n***Pls upvote the solution if you find it helpful***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        res=\"\"\\n        for i in list(zip(*strs)):\\n            if len(set(i))==1: res+=i[0]\\n            else: break\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163267,
                "title": "python-beats-99-11-with-full-working-explanation",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:  # Time: O(n*n) and Space: O(1)\\n        res=\\'\\'\\n        for i in range(len(strs[0])):           # we take the first string from the list of strings as the base case\\n            for s in strs:                        # taking one string at a time and checking each of the strings\\' character at the same index i\\n                if i==len(s) or s[i]!=strs[0][i]:   # when anyone of the string reaches its end and at index i strings does not match\\n                    return res                      # we cannot go ahead now as per the LCP rules, and we need to return the longest common prefix\\n            res+=strs[0][i]                       # when all the conditions in if fails for every string at index i, that means that character at i is LCP\\n        return res                              # when for loop exit, means the whole base case was the LCP\\n```\\nFor example,\\nstrs = [\"flower\",\"flow\",\"flight\"]\\n{index, s} = {0, flower}, {1, flow}, {2, flight}\\nlen(flower) = 6, len(flow) = 4,  and len(flight) = 6\\nfor i = len(strs[0]) = len(flower) = 6 i.e. 0,1,2,3,4,5\\n1. i=0: \\n* for s=flower --> if 0==6 or s[0]!=strs[0][0] = False \\n* for s=flow   --> if 0==4 or s[0]!=strs[0][0] = False \\n* for s=flight --> if 0==6 or s[0]!=strs[0][0] = False\\n* res = res + strs[0][0] = \\'\\' + \\'f\\' = f \\n2. i=1:\\n* for s=flower --> if 1==6 or s[1]!=strs[0][1] = False \\n* for s=flow   --> if 1==4 or s[1]!=strs[0][1] = False \\n* for s=flight --> if 1==6 or s[1]!=strs[0][1] = False\\n* res = res + strs[0][0] = f + l = fl \\n3. i=2:\\n* for s=flower --> if 2==6 or s[2]!=strs[0][2] = False \\n* for s=flow   --> if 2==4 or s[2]!=strs[0][2] = False \\n* for s=flight --> if 2==6 or s[2]!=strs[0][2] = False\\n* res = res + strs[0][0] = fl + o  = flo \\n4. i=3:\\n* for s=flower --> if 3==6 or s[3]!=strs[0][3] = False \\n* for s=flow   --> if 3==4 or s[3]!=strs[0][3] = False \\n* for s=flight --> if 3==6 or s[3]!=strs[0][3] = False\\n* res = res + strs[0][0] = flow + w = flow \\n5. i=4:\\n* for s=flower --> if 4==6 or s[4]!=strs[0][4] = False \\n* for s=flow   --> if 4==4 or s[4]!=strs[0][4] = True and index out of bounds -->  Return result flow as the longest common prefix",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:  # Time: O(n*n) and Space: O(1)\\n        res=\\'\\'\\n        for i in range(len(strs[0])):           # we take the first string from the list of strings as the base case\\n            for s in strs:                        # taking one string at a time and checking each of the strings\\' character at the same index i\\n                if i==len(s) or s[i]!=strs[0][i]:   # when anyone of the string reaches its end and at index i strings does not match\\n                    return res                      # we cannot go ahead now as per the LCP rules, and we need to return the longest common prefix\\n            res+=strs[0][i]                       # when all the conditions in if fails for every string at index i, that means that character at i is LCP\\n        return res                              # when for loop exit, means the whole base case was the LCP\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564635,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1720944,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1565735,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1575665,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1565289,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1789281,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1573676,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1566468,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1684693,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1566066,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1564635,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1720944,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1565735,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1575665,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1565289,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1789281,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1573676,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1566468,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1684693,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1566066,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1635874,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1876481,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1881670,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1864054,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1729118,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1736231,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1718796,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1568113,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1853244,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1699911,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1695930,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1569693,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1860445,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1811602,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1765584,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 2007536,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1996844,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1693397,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1625417,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1576657,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1573975,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 1571040,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 1571041,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 1569953,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 1569195,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 2075698,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 2074749,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 2073826,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 2068399,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 2064571,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 2063625,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2063560,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2060562,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2050193,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2049154,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2048123,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2035198,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2034579,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2019638,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2017693,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2007273,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 2005432,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 2000031,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1999258,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1996744,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1990648,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1959953,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1944322,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1941834,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1941758,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1938741,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1936395,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1929205,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1928877,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1922509,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1921205,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1919733,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1919247,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1918369,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1918128,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1906633,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1905998,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1905748,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1903337,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1902847,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1901078,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1900758,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1898401,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1898235,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1897386,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1874278,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1873238,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1868675,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1861679,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1859803,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1857632,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1857009,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1856732,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1851865,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1846936,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1845152,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1843167,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1842345,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1840829,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1838850,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1833617,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1832789,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1832339,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1827431,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1827297,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1826740,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1815685,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1813606,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1811316,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1810914,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1810374,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1809618,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1807257,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1807228,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1807146,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1805457,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1804033,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1803861,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1800636,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1800532,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1799998,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1796736,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1794688,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1791785,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1782812,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1782389,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with ‘f’\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1780299,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with ‘f’\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1777075,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with ‘f’\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1776625,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with ‘f’\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1772751,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with ‘f’\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1767363,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with ‘f’\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1758845,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with ‘f’\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1755558,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with ‘f’\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1753950,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with ‘f’\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1743578,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with ‘f’\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1742786,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1742688,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1741875,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1739869,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1737343,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1736735,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1733842,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1733380,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1732191,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1731881,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1728419,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1726264,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1725500,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1722955,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1722619,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1722148,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1722111,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1721552,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1721458,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1718667,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1718349,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1716871,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1714098,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1713556,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1709875,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1707963,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1707681,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1707579,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1707380,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1704244,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1702173,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1701739,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1691108,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1690959,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1678402,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1673977,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1671252,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1671116,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1662522,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1657496,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            }
        ]
    }
]