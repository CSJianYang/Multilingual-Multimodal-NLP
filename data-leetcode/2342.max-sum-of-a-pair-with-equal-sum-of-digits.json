[
    {
        "title": "Max Sum of a Pair With Equal Sum of Digits",
        "question_content": "You are given a 0-indexed array nums consisting of positive integers. You can choose two indices i and j, such that i != j, and the sum of digits of the number nums[i] is equal to that of nums[j].\nReturn the maximum value of nums[i] + nums[j] that you can obtain over all possible indices i and j that satisfy the conditions.\n&nbsp;\nExample 1:\n\nInput: nums = [18,43,36,13,7]\nOutput: 54\nExplanation: The pairs (i, j) that satisfy the conditions are:\n- (0, 2), both numbers have a sum of digits equal to 9, and their sum is 18 + 36 = 54.\n- (1, 4), both numbers have a sum of digits equal to 7, and their sum is 43 + 7 = 50.\nSo the maximum sum that we can obtain is 54.\n\nExample 2:\n\nInput: nums = [10,12,19,14]\nOutput: -1\nExplanation: There are no two numbers that satisfy the conditions, so we return -1.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 109",
        "solutions": [
            {
                "id": 2292559,
                "title": "two-sum",
                "content": "Similarly to [1. Two Sum](https://leetcode.com/problems/two-sum/), we use hash map to match pairs.\\n                     \\nInstead of a compliment, we use the sum of digits as the key.\\n                        \\nAs we are looking for a maximum, we store largest number so far as a hash map value.\\n                        \\n**C++**\\n```cpp\\nint maximumSum(vector<int>& nums) {\\n    int res = -1, d_n[82] = {}; // 9 * 9\\n    for (int n : nums) {\\n        int d = 0;\\n        for (int nn = n; nn; nn /= 10)\\n            d += nn % 10;\\n        if (d_n[d])\\n            res = max(res, d_n[d] + n);\\n        d_n[d] = max(d_n[d], n);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maximumSum(vector<int>& nums) {\\n    int res = -1, d_n[82] = {}; // 9 * 9\\n    for (int n : nums) {\\n        int d = 0;\\n        for (int nn = n; nn; nn /= 10)\\n            d += nn % 10;\\n        if (d_n[d])\\n            res = max(res, d_n[d] + n);\\n        d_n[d] = max(d_n[d], n);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2292641,
                "title": "python-java-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef maximumSum(self, nums: List[int]) -> int:\\n\\t\\t\\td = {}\\n\\t\\t\\tres = -1\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\ts = sum([int(digit) for digit in str(num)])\\n\\t\\t\\t\\tif s not in d:\\n\\t\\t\\t\\t\\td[s] = num\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres = max(res, d[s] + num)\\n\\t\\t\\t\\t\\td[s] = max(d[s], num)\\n\\t\\t\\treturn res\\n\\t\\t\\t\\n\\t\\t\\t\\n\\tclass Solution {\\n\\t\\tpublic int maximumSum(int[] nums) {\\n\\t\\t\\tMap<Integer, Integer> map = new HashMap<>();\\n\\t\\t\\tint res = -1;\\n\\t\\t\\tfor (int num: nums) {\\n\\t\\t\\t\\tint s = 0;\\n\\t\\t\\t\\tfor (char digit: String.valueOf(num).toCharArray()) {\\n\\t\\t\\t\\t\\ts += Integer.valueOf(digit - \\'0\\');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (!map.containsKey(s)) {\\n\\t\\t\\t\\t\\tmap.put(s, num);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tres = Math.max(res, map.get(s) + num);\\n\\t\\t\\t\\t\\tmap.put(s, Math.max(map.get(s), num));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef maximumSum(self, nums: List[int]) -> int:\\n\\t\\t\\td = {}",
                "codeTag": "Java"
            },
            {
                "id": 2293144,
                "title": "c-easy-solution-100-faster-vector-pair",
                "content": "#### please upvote if you like the solution\\n![image](https://assets.leetcode.com/users/images/c9def8a0-a463-4c35-b487-6c81583d9f8a_1658032168.6277628.png)\\n\\nclass Solution {\\npublic:\\n\\n    int maximumSum(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        int ans=-1;\\n        vector<pair<int,int>> p;\\n        for( int i=0;i<n ;i++){ \\n            int a=0, sum=0;\\n            a=nums[i]; \\n             while (a != 0) {\\n                sum = sum + a % 10;\\n                 a = a / 10;\\n            }\\n           \\n            v.push_back(sum);\\n        }\\n        for(int i=0 ;i<n;i++){\\n            p.push_back(make_pair(v[i], nums[i]));\\n        }\\n        sort(p.begin(),p.end());\\n          \\n             for(int i=1;i<n ;i++){\\n                 if(p[i].first == p[i-1].first){\\n                     ans=max(ans,p[i].second+p[i-1].second);\\n                 }\\n             }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maximumSum(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> v;\\n        int ans=-1;\\n        vector<pair<int,int>> p;\\n        for( int i=0;i<n ;i++){ \\n            int a=0, sum=0;\\n            a=nums[i]; \\n             while (a != 0) {\\n                sum = sum + a % 10;\\n                 a = a / 10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2292615,
                "title": "java-clean-simple",
                "content": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int result = -1;\\n\\n        for (int item : nums) {\\n            int key = getNumberTotal(item);\\n\\n            if (!map.containsKey(key))\\n                map.put(key, item);\\n            else {\\n                result = Math.max(result, map.get(key) + item);\\n                map.put(key, Math.max(map.get(key), item));\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    int getNumberTotal(int num) {\\n        int result = 0;\\n        while (num > 0) {\\n            result += num % 10;\\n            num /= 10;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n**Update**:\\n\\nThanks for ***@harsh_ju_sharma***, we can use an int[82] arr to store the value as a map to save more time and memory!\\nhttps://leetcode.com/problems/max-sum-of-a-pair-with-equal-sum-of-digits/discuss/2294703/java-on-but-space-optimised-explained-ttt\\n\\n*Definitely go check his post to get the full explanation!*\\n\\n\\n```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        int[] map = new int[82];\\n        int result = -1;\\n\\n        for (int item : nums) {\\n            int key = getNumberTotal(item);\\n\\n            if (map[key] != 0)\\n                result = Math.max(result, map[key] + item);\\n            map[key] = Math.max(map[key], item);\\n        }\\n\\n        return result;\\n    }\\n\\n    int getNumberTotal(int num) {\\n        int result = 0;\\n        while (num > 0) {\\n            result += num % 10;\\n            num /= 10;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int result = -1;\\n\\n        for (int item : nums) {\\n            int key = getNumberTotal(item);\\n\\n            if (!map.containsKey(key))\\n                map.put(key, item);\\n            else {\\n                result = Math.max(result, map.get(key) + item);\\n                map.put(key, Math.max(map.get(key), item));\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    int getNumberTotal(int num) {\\n        int result = 0;\\n        while (num > 0) {\\n            result += num % 10;\\n            num /= 10;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        int[] map = new int[82];\\n        int result = -1;\\n\\n        for (int item : nums) {\\n            int key = getNumberTotal(item);\\n\\n            if (map[key] != 0)\\n                result = Math.max(result, map[key] + item);\\n            map[key] = Math.max(map[key], item);\\n        }\\n\\n        return result;\\n    }\\n\\n    int getNumberTotal(int num) {\\n        int result = 0;\\n        while (num > 0) {\\n            result += num % 10;\\n            num /= 10;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292940,
                "title": "java-python-3-compute-the-sum-of-digits-and-then-use-hashmap",
                "content": "1. Use a HashMap to save the sum of the digits of each number as the hash value (key of the map) and store the corresponding numbers into a list (value of the map).\\n2. Sort each list and find the max sum of the pairs.\\n\\n```java\\n    public int maximumSum(int[] nums) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int n : nums) {\\n            map.computeIfAbsent(digitSum(n), l -> new ArrayList<>()).add(n);\\n        }\\n        int max = -1;\\n        for (List<Integer> l : map.values()) {\\n            if (l.size() > 1) {\\n                Collections.sort(l);\\n                int sz = l.size();\\n                max = Math.max(max, l.get(sz - 1) + l.get(sz - 2));\\n            }\\n        }\\n        return max;\\n    }\\n    private int digitSum(int n) {\\n        int ans = 0;\\n        while (n > 0) {\\n            ans += n % 10;\\n            n /= 10;\\n        }\\n        return ans;\\n    }\\n```\\n\\n```python\\n    def maximumSum(self, nums: List[int]) -> int:\\n        \\n        def digitSum(n: int) -> int:\\n            s = 0\\n            while n > 0:\\n                n, r = divmod(n, 10)\\n                s += r\\n            return s\\n\\n        d = defaultdict(list)\\n        for num in nums:\\n            d[digitSum(num)].append(num)\\n        mx = -1    \\n        for l in d.values():\\n            if len(l) > 1:\\n                l.sort()    \\n                mx = max(mx, l[-1] + l[-2])\\n        return mx\\n```\\n\\n**Analysis:**\\n\\nTime: `O(nlogn)`, space: `O(n)`, where `n = nums.length`.\\n\\n----\\n\\nIn fact, we do NOT have to store all numbers for each hash value, just keep `2` largest numbers. Hence, we can optimize the above code from time `O(nlogn)` to `O(n)`.\\n\\n```java\\n    public int maximumSum(int[] nums) {\\n        Map<Integer, List<Integer>> digitSumToNums = new HashMap<>();\\n        for (int n : nums) {\\n            int digitSum = digitSum(n);\\n            digitSumToNums.computeIfAbsent(digitSum, l -> new ArrayList<>()).add(n);\\n            Collections.sort(digitSumToNums.get(digitSum));\\n            if (digitSumToNums.get(digitSum).size() > 2) {\\n                digitSumToNums.get(digitSum).remove(0);\\n            }\\n        }\\n        int max = -1;\\n        for (List<Integer> l : digitSumToNums.values()) {\\n            if (l.size() == 2) {\\n                max = Math.max(max, l.get(0) + l.get(1));\\n            }\\n        }\\n        return max;\\n    }\\n    private int digitSum(int n) {\\n        int ans = 0;\\n        while (n > 0) {\\n            ans += n % 10;\\n            n /= 10;\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def maximumSum(self, nums: List[int]) -> int:\\n        \\n        def digitSum(n: int) -> int:\\n            s = 0\\n            while n > 0:\\n                n, r = divmod(n, 10)\\n                s += r\\n            return s\\n\\n        digit_sum_to_nums = defaultdict(list)\\n        for num in nums:\\n            digit_sum = digitSum(num)\\n            digit_sum_to_nums[digit_sum].append(num)\\n            digit_sum_to_nums[digit_sum].sort(reverse=True)\\n            if len(digit_sum_to_nums[digit_sum]) > 2:\\n                digit_sum_to_nums[digit_sum].pop()\\n            \\n        mx = -1    \\n        for l in digit_sum_to_nums.values():\\n            if len(l) == 2:\\n                mx = max(mx, sum(l))\\n        return mx\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`, where `n = nums.length`.\\n",
                "solutionTags": [],
                "code": "```java\\n    public int maximumSum(int[] nums) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int n : nums) {\\n            map.computeIfAbsent(digitSum(n), l -> new ArrayList<>()).add(n);\\n        }\\n        int max = -1;\\n        for (List<Integer> l : map.values()) {\\n            if (l.size() > 1) {\\n                Collections.sort(l);\\n                int sz = l.size();\\n                max = Math.max(max, l.get(sz - 1) + l.get(sz - 2));\\n            }\\n        }\\n        return max;\\n    }\\n    private int digitSum(int n) {\\n        int ans = 0;\\n        while (n > 0) {\\n            ans += n % 10;\\n            n /= 10;\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def maximumSum(self, nums: List[int]) -> int:\\n        \\n        def digitSum(n: int) -> int:\\n            s = 0\\n            while n > 0:\\n                n, r = divmod(n, 10)\\n                s += r\\n            return s\\n\\n        d = defaultdict(list)\\n        for num in nums:\\n            d[digitSum(num)].append(num)\\n        mx = -1    \\n        for l in d.values():\\n            if len(l) > 1:\\n                l.sort()    \\n                mx = max(mx, l[-1] + l[-2])\\n        return mx\\n```\n```java\\n    public int maximumSum(int[] nums) {\\n        Map<Integer, List<Integer>> digitSumToNums = new HashMap<>();\\n        for (int n : nums) {\\n            int digitSum = digitSum(n);\\n            digitSumToNums.computeIfAbsent(digitSum, l -> new ArrayList<>()).add(n);\\n            Collections.sort(digitSumToNums.get(digitSum));\\n            if (digitSumToNums.get(digitSum).size() > 2) {\\n                digitSumToNums.get(digitSum).remove(0);\\n            }\\n        }\\n        int max = -1;\\n        for (List<Integer> l : digitSumToNums.values()) {\\n            if (l.size() == 2) {\\n                max = Math.max(max, l.get(0) + l.get(1));\\n            }\\n        }\\n        return max;\\n    }\\n    private int digitSum(int n) {\\n        int ans = 0;\\n        while (n > 0) {\\n            ans += n % 10;\\n            n /= 10;\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def maximumSum(self, nums: List[int]) -> int:\\n        \\n        def digitSum(n: int) -> int:\\n            s = 0\\n            while n > 0:\\n                n, r = divmod(n, 10)\\n                s += r\\n            return s\\n\\n        digit_sum_to_nums = defaultdict(list)\\n        for num in nums:\\n            digit_sum = digitSum(num)\\n            digit_sum_to_nums[digit_sum].append(num)\\n            digit_sum_to_nums[digit_sum].sort(reverse=True)\\n            if len(digit_sum_to_nums[digit_sum]) > 2:\\n                digit_sum_to_nums[digit_sum].pop()\\n            \\n        mx = -1    \\n        for l in digit_sum_to_nums.values():\\n            if len(l) == 2:\\n                mx = max(mx, sum(l))\\n        return mx\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2292858,
                "title": "first-two-of-same-key-priority-queue-approach-intuition",
                "content": "First by seeing I got intution for TRIE because the question was stating max pair sum which is same as Max-xor pair.\\n    \\nBut the catch here is they have given a KEY which should be common between the two pair i.e sum of digits should be same.\\n    \\nSo now i thought of making map.\\nAnd then I thought of putting the element in their respective sum of digit group.\\nAnd for every group we know only two will give maximum sum i.e first two largest.\\nFor that purpose I sorted the elements in decreasing order.\\nAnd just got maximum of sum of first two elements of every key.\\n\\n**Priority Queue Approach**:\\nWe always want two max value element having same sum of digits which will give us max_sum.\\nSo for that I used a priority_queue using which I will restrict the size to 2 every time. In this way I will have top two at last.\\nAnd now we just retrace and get top two with maximum sum.\\n\\n![image](https://assets.leetcode.com/users/images/0bb2d9b3-f973-4462-8b42-8dc978961d20_1658046663.3462887.png)\\n\\n\\n**C++ using priority Queue**\\n    \\n\\t//Calculate sum of digits of a given number\\n    int count(int num){\\n        int digitSum = 0;\\n        while(num > 0) {\\n            digitSum += num % 10;\\n            num /= 10;\\n        }\\n        return digitSum;\\n    }\\n    \\n    int maximumSum(vector<int>& A) {\\n        vector<priority_queue<int,vector<int>,greater<int>>> mp(82);\\n        \\n        //put in respective sum of digits keys  \\n        for(auto i:A){\\n            int cnt= count(i);\\n\\t\\t\\t//{Push and pop will be constant because the size of queue will be atmost 2 always}\\n            mp[cnt].push(i);\\n\\t\\t\\t//restrict the size to 2 always\\n            if(mp[cnt].size()>2) mp[cnt].pop();\\n        }\\n    \\n        //then first two of every are suitable for giving maximum sum\\n        long max_sum=0;\\n        for(auto f:mp){\\n            if(f.size()<2) continue;\\n\\t\\t\\t//get top two\\n            int first=  f.top();  f.pop();\\n            int second= f.top();\\n            long pair_sum= first+second;\\n            max_sum= max(max_sum,pair_sum); \\n        }\\n        \\n        return max_sum==0? -1 : max_sum;\\n    }\\n**Time** - O(N)\\n**Space** - O(82) , at masx the sum of digit of any number will 82 only, not more than that.\\n\\n**C++ using Sorting**\\n\\n      int maximumSum(vector<int>& A) {\\n        \\n        //Calculate sum of digits of a given number\\n        auto count=[&](int num){\\n            int sum=0;\\n            for(;num>0;num/10) sum+= num%10;\\n            return sum;\\n        };\\n        \\n        //sort in decreasing order\\n        sort(rbegin(A),rend(A));\\n        \\n        //map which \\n        unordered_map<int,vector<int>> mp;\\n        \\n        //put in respective sum of digits keys\\n        for(auto i:A) mp[count(i)].push_back(i);\\n        \\n        //then first two of every are suitable for giving maximum sum\\n        long max_sum=0;\\n        for(auto &[i,v]:mp){\\n            if(v.size()>=2) max_sum= max((long)max_sum,(long)(v[0]+v[1])); \\n        }\\n        \\n        return max_sum==0? -1 : max_sum;\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "First by seeing I got intution for TRIE because the question was stating max pair sum which is same as Max-xor pair.\\n    \\nBut the catch here is they have given a KEY which should be common between the two pair i.e sum of digits should be same.\\n    \\nSo now i thought of making map.\\nAnd then I thought of putting the element in their respective sum of digit group.\\nAnd for every group we know only two will give maximum sum i.e first two largest.\\nFor that purpose I sorted the elements in decreasing order.\\nAnd just got maximum of sum of first two elements of every key.\\n\\n**Priority Queue Approach**:\\nWe always want two max value element having same sum of digits which will give us max_sum.\\nSo for that I used a priority_queue using which I will restrict the size to 2 every time. In this way I will have top two at last.\\nAnd now we just retrace and get top two with maximum sum.\\n\\n![image](https://assets.leetcode.com/users/images/0bb2d9b3-f973-4462-8b42-8dc978961d20_1658046663.3462887.png)\\n\\n\\n**C++ using priority Queue**\\n    \\n\\t//Calculate sum of digits of a given number\\n    int count(int num){\\n        int digitSum = 0;\\n        while(num > 0) {\\n            digitSum += num % 10;\\n            num /= 10;\\n        }\\n        return digitSum;\\n    }\\n    \\n    int maximumSum(vector<int>& A) {\\n        vector<priority_queue<int,vector<int>,greater<int>>> mp(82);\\n        \\n        //put in respective sum of digits keys  \\n        for(auto i:A){\\n            int cnt= count(i);\\n\\t\\t\\t//{Push and pop will be constant because the size of queue will be atmost 2 always}\\n            mp[cnt].push(i);\\n\\t\\t\\t//restrict the size to 2 always\\n            if(mp[cnt].size()>2) mp[cnt].pop();\\n        }\\n    \\n        //then first two of every are suitable for giving maximum sum\\n        long max_sum=0;\\n        for(auto f:mp){\\n            if(f.size()<2) continue;\\n\\t\\t\\t//get top two\\n            int first=  f.top();  f.pop();\\n            int second= f.top();\\n            long pair_sum= first+second;\\n            max_sum= max(max_sum,pair_sum); \\n        }\\n        \\n        return max_sum==0? -1 : max_sum;\\n    }\\n**Time** - O(N)\\n**Space** - O(82) , at masx the sum of digit of any number will 82 only, not more than that.\\n\\n**C++ using Sorting**\\n\\n      int maximumSum(vector<int>& A) {\\n        \\n        //Calculate sum of digits of a given number\\n        auto count=[&](int num){\\n            int sum=0;\\n            for(;num>0;num/10) sum+= num%10;\\n            return sum;\\n        };\\n        \\n        //sort in decreasing order\\n        sort(rbegin(A),rend(A));\\n        \\n        //map which \\n        unordered_map<int,vector<int>> mp;\\n        \\n        //put in respective sum of digits keys\\n        for(auto i:A) mp[count(i)].push_back(i);\\n        \\n        //then first two of every are suitable for giving maximum sum\\n        long max_sum=0;\\n        for(auto &[i,v]:mp){\\n            if(v.size()>=2) max_sum= max((long)max_sum,(long)(v[0]+v[1])); \\n        }\\n        \\n        return max_sum==0? -1 : max_sum;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2292725,
                "title": "c-track-max-with-particular-sum",
                "content": "**Explanantion:-**\\n1. We  have to track maximum number with particular sum;\\n2.  For those who find it difficult to understand.\\n**lets say you are at ```ith``` index so you calculate sum of digits of that number(call it as digitSum). So now what you want is other number whose sum of digits =digitSum and index less then ```i```\\nHow can you check if there exist number whose sum of digits =digitSum?\\nYou can use map to store digitSum as key and number itself as value. \\nSo you may think there can be so many numbers with digitSum upto ```ith``` index.\\nBut you want your answer to be max . So you will use maximum number with digitSum.That\\'s why you need to store only max number whose digit sum=digitSum.**\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        int ans=-1, sz=nums.size();\\n        unordered_map<int,int>mp;\\n        for(auto & i:nums){\\n            string s=to_string(i);\\n            int sum=0;\\n            for(auto & ch:s)\\n                sum+=(ch-\\'0\\');\\n            if(mp.count(sum))\\n                ans=max(ans,i+mp[sum]);\\n            mp[sum]=max(i,mp[sum]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```ith```\n```i```\n```ith```\n```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        int ans=-1, sz=nums.size();\\n        unordered_map<int,int>mp;\\n        for(auto & i:nums){\\n            string s=to_string(i);\\n            int sum=0;\\n            for(auto & ch:s)\\n                sum+=(ch-\\'0\\');\\n            if(mp.count(sum))\\n                ans=max(ans,i+mp[sum]);\\n            mp[sum]=max(i,mp[sum]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345497,
                "title": "c-solution-easy-using-maps",
                "content": "```\\nint maximumSum(vector<int>& nums){\\n\\tunordered_map<int, vector<int> > umap;\\n\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\tint l =0, n= nums[i];\\n\\t\\twhile(n){\\n\\t\\t\\tl+=(n%10);\\n\\t\\t\\tn = n/10;\\n\\t\\t}\\n\\t\\tumap[l].push_back(nums[i]);            \\n\\t}\\n\\tint sum=-1;\\n\\tfor(auto i: umap){\\n\\t\\tif(i.second.size()!=1){\\n\\t\\t\\tint s;\\n\\t\\t\\tsort(i.second.begin(), i.second.end(), greater<int>());\\n\\t\\t\\ts= i.second[0] + i.second[1];\\n\\t\\t\\tsum = max(sum, s);\\n\\t\\t}\\n\\t}\\n\\treturn sum;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint maximumSum(vector<int>& nums){\\n\\tunordered_map<int, vector<int> > umap;\\n\\tfor(int i=0; i<nums.size(); i++){\\n\\t\\tint l =0, n= nums[i];\\n\\t\\twhile(n){\\n\\t\\t\\tl+=(n%10);\\n\\t\\t\\tn = n/10;\\n\\t\\t}\\n\\t\\tumap[l].push_back(nums[i]);            \\n\\t}\\n\\tint sum=-1;\\n\\tfor(auto i: umap){\\n\\t\\tif(i.second.size()!=1){\\n\\t\\t\\tint s;\\n\\t\\t\\tsort(i.second.begin(), i.second.end(), greater<int>());\\n\\t\\t\\ts= i.second[0] + i.second[1];\\n\\t\\t\\tsum = max(sum, s);\\n\\t\\t}\\n\\t}\\n\\treturn sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2292599,
                "title": "simple-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        map<int, vector<int>>mp;\\n        for(int i=0; i<nums.size(); i++){\\n            string str = to_string(nums[i]);\\n            int x = 0;\\n            for(int j=0; j<str.length(); j++){\\n                x+=str[j]-\\'0\\';\\n            }\\n            mp[x].push_back(nums[i]);\\n        }\\n        int ans = INT_MIN;\\n        for(auto it=mp.begin(); it!=mp.end(); it++){\\n            int sum=0;\\n            if((it->second).size()>1)\\n            {\\n                for(int i=0; i<(it->second).size()-1; i++)\\n                    sum = max(sum, (it->second)[i]+(it->second)[i+1]);\\n                ans = max(sum, ans);\\n            }\\n        }\\n        return ans==INT_MIN?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        map<int, vector<int>>mp;\\n        for(int i=0; i<nums.size(); i++){\\n            string str = to_string(nums[i]);\\n            int x = 0;\\n            for(int j=0; j<str.length(); j++){\\n                x+=str[j]-\\'0\\';\\n            }\\n            mp[x].push_back(nums[i]);\\n        }\\n        int ans = INT_MIN;\\n        for(auto it=mp.begin(); it!=mp.end(); it++){\\n            int sum=0;\\n            if((it->second).size()>1)\\n            {\\n                for(int i=0; i<(it->second).size()-1; i++)\\n                    sum = max(sum, (it->second)[i]+(it->second)[i+1]);\\n                ans = max(sum, ans);\\n            }\\n        }\\n        return ans==INT_MIN?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166553,
                "title": "c-easy-explanation-o-1-space-o-nlog-n-time",
                "content": "# Approach\\n1. SORTING ARRAY AND TRAVERSING FROM RIGHT TO LEFT TO ENSURE THAT IF THERE ARE TWO ELEMENTS OF SAME SUM OF DIGITS ,THEN THEIR SUM WILL BE MAXIMUM .\\n2. FOR KNOWING WE GOT TWO ELEMENTS ,AND THERE IS NO NEED TO ADD FURTHER MORE ELEMENTS .\\nWE WILL APPLY A CHECK . AND STORE THE CONTRIBUTION OF ELEMENT IN AN \\nans VECTOR {SIZE 82 (STORING 0 TO 81 INDEXES). HERE INDEX REPRESENT SUM OF DIGITS OF A NUMBER .}\\n\\n        if(check[x]<2){\\n            check[x]=check[x]+1;\\n            ans[x]+=nums[i];\\n        }\\n\\n3.WE WILL PUSH THE ANS[X] INTO THE STACK ST ONLY  IF WE FOUND THE TWO DISTINCT ELEMENTS IN THE NUMS ARRAY HAVING SAME SUM OF DIGITS \\nAND\\nI.STACK ST IS EMPTY .\\nII.ST.TOP() < ANS[X]{i.e. FOR STORING MAX SUM OF PAIR .}\\n\\n  if(check[x]==2){\\n            if(st.empty()){st.push(ans[x]);}\\n            else if(st.top()<ans[x]){\\n                st.push(ans[x]);\\n            }\\n        }\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn) --> sorting nums\\n\\n  O(1) --> sumofDigits will run at max 9 times.\\n O(1) --> Stack push / pop .\\n\\n- Space complexity:\\nO(1) --> check {82 size}\\nO(1) --> ans {82 size}\\nO(1) --> st {Only 1 element or no element will there in stack for whole iteration.}\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumofDigits(int n){\\n        long long sum=0;\\n        while(n!=0){\\n            sum+=(n%10);\\n            n/=10;\\n        }\\n        return sum;\\n    }\\n\\n    int maximumSum(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int>check(82,0);\\n        vector<int>ans(82,0);\\n        stack<int>st;\\n\\n        for(int i=n-1;i>=0;i--){\\n            int x=sumofDigits(nums[i]);\\n            if(check[x]<2){\\n                check[x]=check[x]+1;\\n                ans[x]+=nums[i];\\n            }\\n            if(check[x]==2){\\n                if(st.empty()){st.push(ans[x]);}\\n\\n                else if(st.top()<ans[x]){\\n                    st.push(ans[x]);\\n                }\\n            }\\n        }\\n        if(st.empty())return -1;\\n        return st.top();\\n    }\\n};\\n```\\n\\n![UPVOTE.jpeg](https://assets.leetcode.com/users/images/a809c084-cccb-423d-9d90-b45405f3ea74_1676003023.5817654.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumofDigits(int n){\\n        long long sum=0;\\n        while(n!=0){\\n            sum+=(n%10);\\n            n/=10;\\n        }\\n        return sum;\\n    }\\n\\n    int maximumSum(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int>check(82,0);\\n        vector<int>ans(82,0);\\n        stack<int>st;\\n\\n        for(int i=n-1;i>=0;i--){\\n            int x=sumofDigits(nums[i]);\\n            if(check[x]<2){\\n                check[x]=check[x]+1;\\n                ans[x]+=nums[i];\\n            }\\n            if(check[x]==2){\\n                if(st.empty()){st.push(ans[x]);}\\n\\n                else if(st.top()<ans[x]){\\n                    st.push(ans[x]);\\n                }\\n            }\\n        }\\n        if(st.empty())return -1;\\n        return st.top();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298920,
                "title": "easy-to-understand-c-code-priority-queue",
                "content": "Make a map where each sum is mapped to a priority queue, which contains all the indexes where that sum is found:\\n\\n`unordered_map<int, priority_queue<int>>mp;`\\n\\nFor each element of the nums array, compute the digit sum and add the mapping as follows:\\n\\n```\\nfor(int i =0; i<n; i++)\\n{\\n\\tmp[sol(nums[i])].push(nums[i]);\\n}\\n```\\n\\nFinally, go over each priority queue, if its size is greater than 1, take the top two numbers, and add them. Keep the sum only if its larger than the global max `mx` (which was initialized as INT_MIN) . \\n\\nIf our mx is still INT_MIN, then we could not find answer, return -1; else return mx.\\n\\n\\n\\n___\\n___\\n\\nCODE:\\n---\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int sol(int x)\\n    {\\n        int sum =0;\\n        \\n        while(x>0)\\n        {\\n            sum+=x%10;\\n            x/=10;\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    \\n    int maximumSum(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, priority_queue<int>>mp;\\n        \\n        for(int i =0; i<n; i++)\\n        {\\n\\t\\t\\t// store the numbers in priority_queue mapped to a specific sum\\n\\t\\t\\t// NOTE: priority_queue has the actual numbers from nums array, and not the indexes\\n            mp[sol(nums[i])].push(nums[i]);\\n        }\\n        \\n        int mx = INT_MIN; // maintain a global max answer variable\\n        for(auto&x : mp)\\n        {\\n\\t\\t\\t// x will be the priority queue\\n            if(x.second.size()>1)\\n            {\\n\\t\\t\\t\\t// take top two elements from pq, which are actually the numbers from nums array\\n                int xx = x.second.top();\\n                x.second.pop();\\n                int y = x.second.top();\\n                x.second.pop();\\n\\t\\t\\t\\t\\tmx = max(mx, xx+y); \\n            }\\n        }\\n        \\n        return (mx==INT_MIN) ? -1 : mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Map",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfor(int i =0; i<n; i++)\\n{\\n\\tmp[sol(nums[i])].push(nums[i]);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int sol(int x)\\n    {\\n        int sum =0;\\n        \\n        while(x>0)\\n        {\\n            sum+=x%10;\\n            x/=10;\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    \\n    int maximumSum(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        unordered_map<int, priority_queue<int>>mp;\\n        \\n        for(int i =0; i<n; i++)\\n        {\\n\\t\\t\\t// store the numbers in priority_queue mapped to a specific sum\\n\\t\\t\\t// NOTE: priority_queue has the actual numbers from nums array, and not the indexes\\n            mp[sol(nums[i])].push(nums[i]);\\n        }\\n        \\n        int mx = INT_MIN; // maintain a global max answer variable\\n        for(auto&x : mp)\\n        {\\n\\t\\t\\t// x will be the priority queue\\n            if(x.second.size()>1)\\n            {\\n\\t\\t\\t\\t// take top two elements from pq, which are actually the numbers from nums array\\n                int xx = x.second.top();\\n                x.second.pop();\\n                int y = x.second.top();\\n                x.second.pop();\\n\\t\\t\\t\\t\\tmx = max(mx, xx+y); \\n            }\\n        }\\n        \\n        return (mx==INT_MIN) ? -1 : mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293117,
                "title": "interesting-heap-solution-beats-100-python-explained",
                "content": "Just though of an interesting heap solution.\\n\\nMaintain a heap of length 2, containing the maximum values seen for each digit sum.\\n\\nReturn the heap with the best sum\\n\\n# Code\\n```\\nfrom heapq import heappush, heappop\\nclass SizedHeap:\\n    def __init__(self, size: int):\\n        self.heap = []\\n        self.size = size\\n    \\n    def push(self, element: int):\\n        if len(self.heap) < self.size:\\n            heappush(self.heap, element)\\n        elif element > self.heap[0]:\\n            heappop(self.heap)\\n            heappush(self.heap, element)\\n            \\n    def len(self) -> int:\\n        return len(self.heap)\\n            \\n    def sum(self) -> int:\\n        return sum(self.heap)\\n\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        sum_of_digits_max = defaultdict(lambda: SizedHeap(2))\\n        ans = -1\\n        \\n        for i, num in enumerate(nums):\\n            tmp = num\\n            s = 0\\n            while num:\\n                s += num % 10\\n                num = num // 10\\n            sum_of_digits_max[s].push(tmp)\\n        \\n        for sum_digit in sum_of_digits_max:\\n            if sum_of_digits_max[sum_digit].len() < 2: continue\\n            ans = max(ans, sum_of_digits_max[sum_digit].sum())\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush, heappop\\nclass SizedHeap:\\n    def __init__(self, size: int):\\n        self.heap = []\\n        self.size = size\\n    \\n    def push(self, element: int):\\n        if len(self.heap) < self.size:\\n            heappush(self.heap, element)\\n        elif element > self.heap[0]:\\n            heappop(self.heap)\\n            heappush(self.heap, element)\\n            \\n    def len(self) -> int:\\n        return len(self.heap)\\n            \\n    def sum(self) -> int:\\n        return sum(self.heap)\\n\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        sum_of_digits_max = defaultdict(lambda: SizedHeap(2))\\n        ans = -1\\n        \\n        for i, num in enumerate(nums):\\n            tmp = num\\n            s = 0\\n            while num:\\n                s += num % 10\\n                num = num // 10\\n            sum_of_digits_max[s].push(tmp)\\n        \\n        for sum_digit in sum_of_digits_max:\\n            if sum_of_digits_max[sum_digit].len() < 2: continue\\n            ans = max(ans, sum_of_digits_max[sum_digit].sum())\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292861,
                "title": "very-simple-and-easy-to-understand-c-solution-using-map",
                "content": "<b> UP Vote if you like the solution \\n```\\nclass Solution {\\npublic:\\n    //store it in a map using the sum of digits as the key\\n    //then check sum of larger two values of each of the key value pair\\n    int maximumSum(vector<int>& nums) {\\n        map<int, multiset<int>> mp;\\n        for(auto n: nums){\\n            int sum = 0;\\n            int t = n;\\n            while(t > 0){\\n                sum += t%10;\\n                t = t/10;\\n            }\\n            mp[sum].insert(n);\\n        }\\n        int ans = -1;\\n        //check last two large value sum is max or not\\n        for(auto m: mp){\\n            if(m.second.size() >= 2){\\n                auto it = (m.second.end());\\n                it--;\\n                int t = *it; \\n                it--;\\n                t += *it;\\n                ans = max(ans, t);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //store it in a map using the sum of digits as the key\\n    //then check sum of larger two values of each of the key value pair\\n    int maximumSum(vector<int>& nums) {\\n        map<int, multiset<int>> mp;\\n        for(auto n: nums){\\n            int sum = 0;\\n            int t = n;\\n            while(t > 0){\\n                sum += t%10;\\n                t = t/10;\\n            }\\n            mp[sum].insert(n);\\n        }\\n        int ans = -1;\\n        //check last two large value sum is max or not\\n        for(auto m: mp){\\n            if(m.second.size() >= 2){\\n                auto it = (m.second.end());\\n                it--;\\n                int t = *it; \\n                it--;\\n                t += *it;\\n                ans = max(ans, t);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292570,
                "title": "c-map-multi-set",
                "content": "**Using multimap for storing element (+Duplicate) in sorted order**\\n**Calc the digit sum of every element \\nsimultaneously store the sum and the elemnt in map of multiset**\\n\\n**element with same sum would be inserted in same multimap**\\n\\n**Traverse in map \\n-> if the freq is greater equal to 2\\n-> take the sum of last 2 elements form multimap**\\n```\\nclass Solution {\\nprivate:\\n\\t// For digit Sum\\n    int sum(int n){\\n        int ans = 0;\\n        while(n>0){\\n            ans += n%10;\\n            n /= 10;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        map<int,multiset<int>> m1;\\n        long long maxi = 0, mn = INT_MIN;\\n        \\n\\t\\t//  store digit sum with its corrreponding element\\n        for(int i=0;i<nums.size();i++){\\n            int s = sum(nums[i]);\\n            m1[s].insert(nums[i]);\\n        }\\n        \\n\\t\\t//  traverse through map\\n        for(auto it = m1.rbegin();it!=m1.rend();it++){\\n            if(it->second.size()>=2){        // Atleast 2 elements\\n                maxi = 0;\\n                auto i = it->second.end();\\n                maxi += *(--i);                // last element\\n                maxi += *(--i);                // second last element\\n                mn = max(maxi,mn);\\n            }\\n        }\\n        if(maxi==0)     return -1;                // if the is not such pair with same digit sum\\n        return max(maxi,mn);\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/15a90cc2-926f-4561-be43-45388b4c6b71_1658041985.0471632.png)\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\t// For digit Sum\\n    int sum(int n){\\n        int ans = 0;\\n        while(n>0){\\n            ans += n%10;\\n            n /= 10;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        map<int,multiset<int>> m1;\\n        long long maxi = 0, mn = INT_MIN;\\n        \\n\\t\\t//  store digit sum with its corrreponding element\\n        for(int i=0;i<nums.size();i++){\\n            int s = sum(nums[i]);\\n            m1[s].insert(nums[i]);\\n        }\\n        \\n\\t\\t//  traverse through map\\n        for(auto it = m1.rbegin();it!=m1.rend();it++){\\n            if(it->second.size()>=2){        // Atleast 2 elements\\n                maxi = 0;\\n                auto i = it->second.end();\\n                maxi += *(--i);                // last element\\n                maxi += *(--i);                // second last element\\n                mn = max(maxi,mn);\\n            }\\n        }\\n        if(maxi==0)     return -1;                // if the is not such pair with same digit sum\\n        return max(maxi,mn);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293503,
                "title": "very-easy-to-understand-using-hashmap",
                "content": "```\\nclass Solution {\\n\\tpublic int maximumSum(int[] arr) {\\n\\t\\tHashMap<Integer, ArrayList<Integer>> map = new HashMap<>();\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tint temp = getSum(arr[i]);\\n\\t\\t\\tmap.putIfAbsent(temp, new ArrayList<Integer>());\\n\\t\\t\\tmap.get(temp).add(arr[i]);\\n\\t\\t}\\n\\t\\tint ans = -1;\\n\\t\\tfor (Map.Entry<Integer, ArrayList<Integer>> i : map.entrySet()) {\\n\\t\\t\\tArrayList<Integer> list = i.getValue();\\n\\t\\t\\tCollections.sort(list);\\n\\t\\t\\tif (list.size() >= 2) {\\n\\t\\t\\t\\tans = Math.max(ans, list.get(list.size() - 1)+ list.get(list.size() - 2));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\n\\t}\\n\\n\\tpublic int getSum(int n) {\\n\\t\\tint sum = 0;\\n\\t\\twhile (n != 0) {\\n\\t\\t\\tsum = sum + n % 10;\\n\\t\\t\\tn = n / 10;\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int maximumSum(int[] arr) {\\n\\t\\tHashMap<Integer, ArrayList<Integer>> map = new HashMap<>();\\n\\t\\tfor (int i = 0; i < arr.length; i++) {\\n\\t\\t\\tint temp = getSum(arr[i]);\\n\\t\\t\\tmap.putIfAbsent(temp, new ArrayList<Integer>());\\n\\t\\t\\tmap.get(temp).add(arr[i]);\\n\\t\\t}\\n\\t\\tint ans = -1;\\n\\t\\tfor (Map.Entry<Integer, ArrayList<Integer>> i : map.entrySet()) {\\n\\t\\t\\tArrayList<Integer> list = i.getValue();\\n\\t\\t\\tCollections.sort(list);\\n\\t\\t\\tif (list.size() >= 2) {\\n\\t\\t\\t\\tans = Math.max(ans, list.get(list.size() - 1)+ list.get(list.size() - 2));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\n\\t}\\n\\n\\tpublic int getSum(int n) {\\n\\t\\tint sum = 0;\\n\\t\\twhile (n != 0) {\\n\\t\\t\\tsum = sum + n % 10;\\n\\t\\t\\tn = n / 10;\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297244,
                "title": "python3-dict-heaps-8-lines-w-explanation-t-m-1300ms-27mb",
                "content": "```\\nclass Solution:     # The plan here is to:\\n                    # \\n                    #   \\u2022 sort the elements of nums into a dict of maxheaps,\\n                    #     according to sum-of-digits.\\n                    #\\n                    #   \\u2022 For each key, determine whether there are at least two \\n                    #     elements in that key\\'s values, and if so, compute the\\n                    #     product of the greatest two elements.\\n                    #\\n                    #   \\u2022 return the the greatest such product as the answer.\\n\\n                    # For example:\\n\\t\\t\\t\\t\\t\\n                    #     nums = [6,15,13,12,24,21] \\u2013> {3:[12,21], 4:[13], 6:[6,15,24]}\\n\\t\\t\\t\\t\\t\\n                    #     Only two keys qualify, 3 and 6, for which the greatest two elements\\n                    #     are 12,21 and 15,24, respectively. 12+21 = 33 and 15+24 = 39,\\n                    #     so the answer is 39.\\n\\n    def maximumSum(self, nums: List[int]) -> int:\\n        d, mx = defaultdict(list), -1\\n        digits = lambda x: sum(map(int, list(str(x))))      # <-- sum-of-digits function\\n       \\n        for n in nums:                                      # <-- construct max-heaps\\n            heappush(d[digits(n)],-n)                       #     (note \"-n\") \\n\\n        for i in d:                                         # <-- pop the two greatest values off\\n            if len(d[i]) > 1:                               #     each maxheap (when possible) and\\n                mx= max(mx, -heappop(d[i])-heappop(d[i]))   #     compare with current max value.\\n                                                           \\n        return mx",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution:     # The plan here is to:\\n                    # \\n                    #   \\u2022 sort the elements of nums into a dict of maxheaps,\\n                    #     according to sum-of-digits.\\n                    #\\n                    #   \\u2022 For each key, determine whether there are at least two \\n                    #     elements in that key\\'s values, and if so, compute the\\n                    #     product of the greatest two elements.\\n                    #\\n                    #   \\u2022 return the the greatest such product as the answer.\\n\\n                    # For example:\\n\\t\\t\\t\\t\\t\\n                    #     nums = [6,15,13,12,24,21] \\u2013> {3:[12,21], 4:[13], 6:[6,15,24]}",
                "codeTag": "Java"
            },
            {
                "id": 2295632,
                "title": "c-easy-solution-using-the-concept-of-vector-pair",
                "content": "```\\nint maximumSum(vector<int>& v) {\\n        int n=v.size(),i;\\n        int ans=-1;\\n        vector<pair<int,int>>x;\\n        for(i=0;i<n;i++){\\n            int y = v[i];\\n            int z=0;\\n            while(y){\\n                z+=y%10;\\n                y/=10;\\n            }\\n            x.push_back(make_pair(z,v[i]));\\n        }\\n        sort(x.begin(),x.end());\\n        for(i=0;i<n-1;i++){\\n            int z =x[i].second+x[i+1].second;\\n            if(x[i].first==x[i+1].first){\\n                ans=max(ans,z);\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maximumSum(vector<int>& v) {\\n        int n=v.size(),i;\\n        int ans=-1;\\n        vector<pair<int,int>>x;\\n        for(i=0;i<n;i++){\\n            int y = v[i];\\n            int z=0;\\n            while(y){\\n                z+=y%10;\\n                y/=10;\\n            }\\n            x.push_back(make_pair(z,v[i]));\\n        }\\n        sort(x.begin(),x.end());\\n        for(i=0;i<n-1;i++){\\n            int z =x[i].second+x[i+1].second;\\n            if(x[i].first==x[i+1].first){\\n                ans=max(ans,z);\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3172149,
                "title": "clean-easy-solution-using-hashmap-faster-than-95-89-in-runtime",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximumSum(self, arr: List[int]) -> int:\\n        hashmap = defaultdict(list)\\n        for n in arr:\\n            digit_sum = 0\\n            num = n\\n            while num:\\n                digit_sum += num % 10\\n                num //= 10\\n            hashmap[digit_sum].append(n)\\n\\n        ans = -1\\n        for v in hashmap.values():\\n            if len(v) > 1:\\n                v = sorted(v,reverse=True)\\n                ans = max(ans, v[0] + v[1])\\n        return ans \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSum(self, arr: List[int]) -> int:\\n        hashmap = defaultdict(list)\\n        for n in arr:\\n            digit_sum = 0\\n            num = n\\n            while num:\\n                digit_sum += num % 10\\n                num //= 10\\n            hashmap[digit_sum].append(n)\\n\\n        ans = -1\\n        for v in hashmap.values():\\n            if len(v) > 1:\\n                v = sorted(v,reverse=True)\\n                ans = max(ans, v[0] + v[1])\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822445,
                "title": "ts-100-faster-173ms-hashmap-easy-to-understand",
                "content": "```\\nconst maximumSum = (nums: number[]): number => {\\n    let getDigitSum = num => {\\n        let digitSum = 0;\\n        while (num > 0) {\\n            digitSum += num % 10;\\n            num = Math.floor(num / 10);\\n        }\\n        return digitSum;\\n    }\\n    \\n    let dic = new Map();\\n    let ans = -1;\\n    for (const num of nums) {\\n        let digitSum = getDigitSum(num);\\n        if (dic.has(digitSum)) {\\n            ans = Math.max(ans, num + dic.get(digitSum));\\n        }\\n        dic.set(digitSum, Math.max(dic.get(digitSum) || 0, num));\\n    }\\n    \\n    return ans;\\n};\\n```\\nLet me know in comments if you have any doubts. I will be happy to answer.\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst maximumSum = (nums: number[]): number => {\\n    let getDigitSum = num => {\\n        let digitSum = 0;\\n        while (num > 0) {\\n            digitSum += num % 10;\\n            num = Math.floor(num / 10);\\n        }\\n        return digitSum;\\n    }\\n    \\n    let dic = new Map();\\n    let ans = -1;\\n    for (const num of nums) {\\n        let digitSum = getDigitSum(num);\\n        if (dic.has(digitSum)) {\\n            ans = Math.max(ans, num + dic.get(digitSum));\\n        }\\n        dic.set(digitSum, Math.max(dic.get(digitSum) || 0, num));\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2356674,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dsum(int n)\\n    {\\n        int sum=0;\\n        while(n!=0)\\n        {\\n            sum += n%10;\\n            n=n/10;\\n        }\\n        return sum;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map <int,int> mp;\\n        int ans=-1;\\n        for(int i =0;i<nums.size();i++)\\n        {\\n            int temp = dsum(nums[i]);\\n            if(mp.find(temp)!=mp.end())\\n            {\\n                int t = mp[temp]+nums[i];\\n                if(mp[temp]<nums[i])\\n                    mp[temp]=nums[i];\\n                ans = max(ans,t);\\n            }\\n            else\\n            {\\n                mp.insert({temp,nums[i]});\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dsum(int n)\\n    {\\n        int sum=0;\\n        while(n!=0)\\n        {\\n            sum += n%10;\\n            n=n/10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2319404,
                "title": "c-easy-solution-100-fast-with-approach",
                "content": "First we create vector of pairs, the first part of pair is also a pair which is the sum of digit of number and the number itself and second is it\\'s index.\\nThen we apply sorting on the vector, so first the vector will be sorted based on the maximum sum of digits then with the number.\\nFor eg:- \\n234, 81, 9, 44, 26, 8, 14, 5, 2 (First sorted according to digits sum, and then sorted according to number)\\nThen we compare if the sum of digits is equal to it\\'s next then we store it our answer, and also keep the track of maximum value while iterating the vector.\\nTime Complexity - **O(NlogN)**\\nSpace Complexity - **O(N)**\\n```\\n\\tint maximumSum(vector<int>& nums) \\n    {\\n        int n=nums.size(),x,y;\\n        vector<pair<pair<int,int>,int>> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=nums[i],sum=0;\\n            while(x!=0)\\n            {\\n                sum+=x%10;\\n                x/=10;\\n            }\\n            v.push_back({{sum,nums[i]},i});\\n        }\\n        sort(v.rbegin(),v.rend());\\n        if(n>1)\\n        {\\n            int ans=-1;\\n            for(int i=0;i<n-1;i++)            \\n            {\\n                if(v[i].first.first==v[i+1].first.first)\\n                {\\n                    ans=max(ans,nums[v[i].second]+nums[v[i+1].second]);\\n                }\\n            }\\n            return ans;\\n        }\\n        else \\n            return -1;\\n    }\\n```\\nThis is my first post on Leetcode Discussion hope you find it helpful and understanding. :)",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n\\tint maximumSum(vector<int>& nums) \\n    {\\n        int n=nums.size(),x,y;\\n        vector<pair<pair<int,int>,int>> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=nums[i],sum=0;\\n            while(x!=0)\\n            {\\n                sum+=x%10;\\n                x/=10;\\n            }\\n            v.push_back({{sum,nums[i]},i});\\n        }\\n        sort(v.rbegin(),v.rend());\\n        if(n>1)\\n        {\\n            int ans=-1;\\n            for(int i=0;i<n-1;i++)            \\n            {\\n                if(v[i].first.first==v[i+1].first.first)\\n                {\\n                    ans=max(ans,nums[v[i].second]+nums[v[i+1].second]);\\n                }\\n            }\\n            return ans;\\n        }\\n        else \\n            return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2298108,
                "title": "o-n-n-o-n-explanation-easy-understand",
                "content": "step 1 :first we store all the elements in the unorderedmap;\\nstep 2 find the sum of the given number ;\\nstep 3 we checks  the sum in te unorderedmap;\\nstep 4 then store  max ans in the answer;\\n**step 5 and also store the maximum element in the unorderedmap because next time if\\nfind the those same number wose sum is equal to previous sum then\\nwe add only those elemnts whose sum is maximum**\\n\\n\\n\\n\\n\\n**this solution gives TLE**\\n```\\nclass Solution {\\npublic:\\n  int  possible(int m)\\n    {\\n        int sum=0;\\n        while(m>0)\\n        {\\n            int d=m%10;\\n            sum=sum+d;\\n            m/=10;\\n        }\\n        return sum;\\n    }\\n\\n        int maximumSum(vector<int>& nums) {\\n         int n=nums.size(),ans=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n             int ok=possible(nums[i]);\\n          //  cout<<ok<<\" \"<<\"\\\\n\";\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int k=possible(nums[j]);\\n                //cout<<k<<\" \"<<\"\\\\n\";\\n                if(ok==k)\\n                {\\n                     int result=nums[i]+nums[j];\\n                    ans=max(ans,result);\\n                    \\n                }\\n            }\\n           \\n                \\n                \\n        }\\n            return ans;\\n    }\\n};\\n```\\n\\n\\n\\n\\n**2nd solution **\\n\\n```\\nclass Solution {\\npublic:\\n  int  possible(int m) // find sum of each elements\\n    {\\n        int sum=0;\\n        while(m>0)\\n        {\\n            int d=m%10;\\n            sum=sum+d;\\n            m/=10;\\n        }\\n        return sum;\\n    }\\n\\n    \\n    \\n        int maximumSum(vector<int>& nums) {\\n         int n=nums.size(),ans=-1;\\n         unordered_map<int,int>m; //store all the elements in te map;\\n        for(int i=0;i<n;i++)\\n        {\\n             int sum=possible(nums[i]);\\n            \\n               \\n            if(m.find(sum)==m.end())\\n            {\\n                m[sum]=nums[i];\\n            }          \\n                else\\n                {\\n                    ans=max(ans,nums[i]+m[sum]); //maximum ans store in ans;\\n                    m[sum]=max(m[sum],nums[i]); //also store in the map maximum elements this is most important \\n                }\\n                \\n        }\\n            return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int  possible(int m)\\n    {\\n        int sum=0;\\n        while(m>0)\\n        {\\n            int d=m%10;\\n            sum=sum+d;\\n            m/=10;\\n        }\\n        return sum;\\n    }\\n\\n        int maximumSum(vector<int>& nums) {\\n         int n=nums.size(),ans=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n             int ok=possible(nums[i]);\\n          //  cout<<ok<<\" \"<<\"\\\\n\";\\n            for(int j=i+1;j<n;j++)\\n            {\\n                int k=possible(nums[j]);\\n                //cout<<k<<\" \"<<\"\\\\n\";\\n                if(ok==k)\\n                {\\n                     int result=nums[i]+nums[j];\\n                    ans=max(ans,result);\\n                    \\n                }\\n            }\\n           \\n                \\n                \\n        }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2294703,
                "title": "java-o-n-but-space-optimised-explained-ttt",
                "content": "**Idea**\\n```\\n - The idea is to store all the nums[i] having the same sum_of_digits in a hashmap\\n - the hashmap can be structured as <Integer, int[]> to enhance space complexity \\n - for each (key, value) pair in the hashmap, value[] will store the largest and the second largest num that have a sum_of_digit as key\\n\\n```\\n\\n**Example**\\n\\n```\\nEg: nums = [18,43,36, 4,13,7, 45, 9]\\n\\n- the nums 18, 36, 45 and 9 have a sum_of_digit = 9 \\n\\tso we will have a <key, val> entry in our hashmap as < 9, [ 45, 36] >\\n\\t note how we will be storing the first 2 largest nums in out array\\n\\t\\n- the nums 43 and 7 add up to 7, so we make an entry as < 7, [43, 7] >\\n\\n- the num 6 will make an entry of <6, [6, -1]> \\n   the -1 indicates that only 1 num has sum_of_digit = 6, hence cannot be considered\\n  \\n- the num 4 is stores as <4, [13, -1]>\\n\\nFinally the hashmap is ready as \\n - < 9, [ 45, 36] >\\n - < 7, [43, 7] >\\n - <6, [6, -1]> \\n - <4, [13, -1]>\\n\\nWe can now iterate over all entries and find the best res\\nIn this case, res = 81 (for sum 9 -> 45 + 36 = 81)\\n```\\n\\n*The space optimisation takes place while storing the two largest nums that have a sum of digit = key in stead of storing all nums and then sorting them to get the two largest.*\\n\\n**Java**\\n```\\nclass Solution {\\n    \\n    HashMap<Integer, int[]> map = new HashMap<>();\\n    int res = -1;\\n    // make sure to use res as a global var as we can\\'t use local vars in lambda expressions \\n    \\n    public int maximumSum(int[] nums) {\\n        initialise(nums);\\n        \\n        map.forEach((k, v) -> {\\n            if(v[1] != -1){\\n                res = Math.max(res, v[0] + v[1]);\\n            }\\n        });\\n        return res;\\n    }\\n    \\n    public void initialise(int[] nums){\\n        for(int x: nums){  // O(N) operations\\n            calculateDigitSum(x);\\n        }\\n    }\\n    \\n    public void calculateDigitSum(int x){\\n        int sum = 0;\\n        int temp = x;\\n        while(x > 0){ // Worst case TC O(9) as the max val is 10^9\\n            sum += ( x % 10);\\n            x /= 10;\\n        }\\n        if(map.containsKey(sum)){\\n            int[] j = map.get(sum);\\n            int a = j[0], b = j[1];\\n            \\n            //insert sum at the right place \\n            if(temp > a && temp > b){\\n                j[0] = temp;\\n                j[1] = Math.max(a, b);\\n            }else j[1] = Math.max(b, temp);\\n        }else{\\n            map.put(sum, new int[]{temp, -1});\\n        }\\n    }\\n}\\n```\\n\\n```\\nTC: O(N) where N = nums.length\\nthe complexity to find sum of digits will be at max O(9)\\n\\nSC: constant - as at max there will be 82 entries in Hashmap \\nas the max value of nums[i] = 999999999 with a digit sum of 81. \\nHence, no matter what the length of nums, the max entries of hashmap will be 82\\n```\\n\\n*upvote helps :)*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n - The idea is to store all the nums[i] having the same sum_of_digits in a hashmap\\n - the hashmap can be structured as <Integer, int[]> to enhance space complexity \\n - for each (key, value) pair in the hashmap, value[] will store the largest and the second largest num that have a sum_of_digit as key\\n\\n```\n```\\nEg: nums = [18,43,36, 4,13,7, 45, 9]\\n\\n- the nums 18, 36, 45 and 9 have a sum_of_digit = 9 \\n\\tso we will have a <key, val> entry in our hashmap as < 9, [ 45, 36] >\\n\\t note how we will be storing the first 2 largest nums in out array\\n\\t\\n- the nums 43 and 7 add up to 7, so we make an entry as < 7, [43, 7] >\\n\\n- the num 6 will make an entry of <6, [6, -1]> \\n   the -1 indicates that only 1 num has sum_of_digit = 6, hence cannot be considered\\n  \\n- the num 4 is stores as <4, [13, -1]>\\n\\nFinally the hashmap is ready as \\n - < 9, [ 45, 36] >\\n - < 7, [43, 7] >\\n - <6, [6, -1]> \\n - <4, [13, -1]>\\n\\nWe can now iterate over all entries and find the best res\\nIn this case, res = 81 (for sum 9 -> 45 + 36 = 81)\\n```\n```\\nclass Solution {\\n    \\n    HashMap<Integer, int[]> map = new HashMap<>();\\n    int res = -1;\\n    // make sure to use res as a global var as we can\\'t use local vars in lambda expressions \\n    \\n    public int maximumSum(int[] nums) {\\n        initialise(nums);\\n        \\n        map.forEach((k, v) -> {\\n            if(v[1] != -1){\\n                res = Math.max(res, v[0] + v[1]);\\n            }\\n        });\\n        return res;\\n    }\\n    \\n    public void initialise(int[] nums){\\n        for(int x: nums){  // O(N) operations\\n            calculateDigitSum(x);\\n        }\\n    }\\n    \\n    public void calculateDigitSum(int x){\\n        int sum = 0;\\n        int temp = x;\\n        while(x > 0){ // Worst case TC O(9) as the max val is 10^9\\n            sum += ( x % 10);\\n            x /= 10;\\n        }\\n        if(map.containsKey(sum)){\\n            int[] j = map.get(sum);\\n            int a = j[0], b = j[1];\\n            \\n            //insert sum at the right place \\n            if(temp > a && temp > b){\\n                j[0] = temp;\\n                j[1] = Math.max(a, b);\\n            }else j[1] = Math.max(b, temp);\\n        }else{\\n            map.put(sum, new int[]{temp, -1});\\n        }\\n    }\\n}\\n```\n```\\nTC: O(N) where N = nums.length\\nthe complexity to find sum of digits will be at max O(9)\\n\\nSC: constant - as at max there will be 82 entries in Hashmap \\nas the max value of nums[i] = 999999999 with a digit sum of 81. \\nHence, no matter what the length of nums, the max entries of hashmap will be 82\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292768,
                "title": "java-solution-accepted",
                "content": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        HashMap<Integer,PriorityQueue<Integer>> map = new HashMap<>();\\n        for(int i : nums){\\n            int s = dSum(i);\\n            map.putIfAbsent(s,new PriorityQueue<>((n1,n2)->n2-n1));\\n            map.get(s).add(i);\\n        }\\n        \\n        int max = -1;\\n        for(int i:nums){\\n            int s = dSum(i);\\n            PriorityQueue<Integer> pq = map.get(s);\\n            if(pq.size() > 1){\\n                max = Math.max(max,pq.poll()+pq.poll());\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int dSum(int val){\\n        int sum = 0;\\n        while(val > 0){\\n            sum += val%10;\\n            val = val/10;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        HashMap<Integer,PriorityQueue<Integer>> map = new HashMap<>();\\n        for(int i : nums){\\n            int s = dSum(i);\\n            map.putIfAbsent(s,new PriorityQueue<>((n1,n2)->n2-n1));\\n            map.get(s).add(i);\\n        }\\n        \\n        int max = -1;\\n        for(int i:nums){\\n            int s = dSum(i);\\n            PriorityQueue<Integer> pq = map.get(s);\\n            if(pq.size() > 1){\\n                max = Math.max(max,pq.poll()+pq.poll());\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int dSum(int val){\\n        int sum = 0;\\n        while(val > 0){\\n            sum += val%10;\\n            val = val/10;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292673,
                "title": "python-two-sum",
                "content": "```python\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        dict_map = {}\\n        \\n        res = -1\\n        for num in nums:\\n            temp = num\\n            new_num = 0\\n            while temp:\\n                new_num += temp % 10\\n                temp = temp // 10\\n            if new_num in dict_map:\\n                new_res = num + dict_map[new_num]\\n                res = max(res, new_res)\\n                dict_map[new_num] = max(num, dict_map[new_num])\\n            else:\\n                dict_map[new_num] = num\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        dict_map = {}\\n        \\n        res = -1\\n        for num in nums:\\n            temp = num\\n            new_num = 0\\n            while temp:\\n                new_num += temp % 10\\n                temp = temp // 10\\n            if new_num in dict_map:\\n                new_res = num + dict_map[new_num]\\n                res = max(res, new_res)\\n                dict_map[new_num] = max(num, dict_map[new_num])\\n            else:\\n                dict_map[new_num] = num\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880879,
                "title": "c-easy-using-map-and-storing-two-max-elements-only",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int conversion(int num){\\n        int ans = 0;\\n        while(num > 0) {\\n            ans += num % 10;\\n            num /= 10;\\n        }\\n        return ans; \\n    }\\n    \\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int, pair<int, int>> mpp; // digit , two max nums[i]\\n        int maxi = -1;\\n        \\n        for(auto it : nums) {\\n            int dig = conversion(it);\\n            \\n            if(mpp.find(dig) != mpp.end()) {\\n                if(it > mpp[dig].first) {\\n                    mpp[dig].second = mpp[dig].first;\\n                    mpp[dig].first = it;\\n                } else if(it > mpp[dig].second) {\\n                    mpp[dig].second = it;\\n                }\\n\\n                if(mpp[dig].second != -1) {\\n                    int ans = mpp[dig].first + mpp[dig].second;\\n                    maxi = max(maxi, ans);\\n                }\\n            } else {\\n                mpp[dig] = make_pair(it, -1);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int conversion(int num){\\n        int ans = 0;\\n        while(num > 0) {\\n            ans += num % 10;\\n            num /= 10;\\n        }\\n        return ans; \\n    }\\n    \\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int, pair<int, int>> mpp; // digit , two max nums[i]\\n        int maxi = -1;\\n        \\n        for(auto it : nums) {\\n            int dig = conversion(it);\\n            \\n            if(mpp.find(dig) != mpp.end()) {\\n                if(it > mpp[dig].first) {\\n                    mpp[dig].second = mpp[dig].first;\\n                    mpp[dig].first = it;\\n                } else if(it > mpp[dig].second) {\\n                    mpp[dig].second = it;\\n                }\\n\\n                if(mpp[dig].second != -1) {\\n                    int ans = mpp[dig].first + mpp[dig].second;\\n                    maxi = max(maxi, ans);\\n                }\\n            } else {\\n                mpp[dig] = make_pair(it, -1);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757881,
                "title": "easy-implementation-using-map-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int digSum(int n){\\n        int sum = 0;\\n        while(n){\\n            sum += (n%10);\\n            n/=10;\\n        }\\n        return sum;\\n    }\\n\\n    int maximumSum(vector<int>& nums) {\\n        map<int,vector<int>>mp;\\n        for(auto num : nums){\\n            mp[digSum(num)].push_back(num);\\n        }\\n\\n        int ans = -1;\\n\\n        for(auto i : mp){\\n            if(i.second.size() <= 1) continue;\\n            vector<int>v = i.second;\\n            sort(v.begin(),v.end(),greater<int>());\\n            ans = max(ans, v[0]+v[1]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digSum(int n){\\n        int sum = 0;\\n        while(n){\\n            sum += (n%10);\\n            n/=10;\\n        }\\n        return sum;\\n    }\\n\\n    int maximumSum(vector<int>& nums) {\\n        map<int,vector<int>>mp;\\n        for(auto num : nums){\\n            mp[digSum(num)].push_back(num);\\n        }\\n\\n        int ans = -1;\\n\\n        for(auto i : mp){\\n            if(i.second.size() <= 1) continue;\\n            vector<int>v = i.second;\\n            sort(v.begin(),v.end(),greater<int>());\\n            ans = max(ans, v[0]+v[1]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265607,
                "title": "python-defaultdict-sort",
                "content": "```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        d = defaultdict(list)\\n        \\n        for n in nums:\\n            s = sum(map(int, str(n)))\\n            d[s].append(n)\\n            \\n        m = -1\\n        for v in d.values():\\n            if len(v) > 1:\\n                v.sort()\\n                m = max(m, v[-2] + v[-1])\\n\\n        return m\\n```",
                "solutionTags": [
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        d = defaultdict(list)\\n        \\n        for n in nums:\\n            s = sum(map(int, str(n)))\\n            d[s].append(n)\\n            \\n        m = -1\\n        for v in d.values():\\n            if len(v) > 1:\\n                v.sort()\\n                m = max(m, v[-2] + v[-1])\\n\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146355,
                "title": "c-solution-using-sorting-hashmap-beats-81",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,vector<int>>mp;\\n        int res=-1;\\n        for(int i=0;i<nums.size();i++){\\n            int val=nums[i];\\n            int sum=0;\\n            while(val>0){\\n                sum+=(val%10);\\n                val/=10;\\n            }\\n            mp[sum].push_back(nums[i]);\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            if(it->second.size()<=1)continue;\\n            sort(it->second.begin(),it->second.end());\\n            int n=it->second.size();\\n            res=max(res,it->second[n-2]+it->second[n-1]);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,vector<int>>mp;\\n        int res=-1;\\n        for(int i=0;i<nums.size();i++){\\n            int val=nums[i];\\n            int sum=0;\\n            while(val>0){\\n                sum+=(val%10);\\n                val/=10;\\n            }\\n            mp[sum].push_back(nums[i]);\\n        }\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            if(it->second.size()<=1)continue;\\n            sort(it->second.begin(),it->second.end());\\n            int n=it->second.size();\\n            res=max(res,it->second[n-2]+it->second[n-1]);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834135,
                "title": "smart-approach",
                "content": "//Step 1 : sort in non-increasing order\\n//Step 2 : store digit sum in map vector\\n//Step 3 : iterate map ---> if size of vector is greater than 1 then do operations , otherwise no operations\\n//step 4 : return maximum value calculated above ;\\nclass Solution\\n{\\npublic:\\n    int sum(int x)\\n    {\\n        int n =0;\\n        while(x>0)\\n        {\\n            n+=(x%10);\\n            x/=10;\\n        }\\n        return n;\\n    }\\n    int maximumSum(vector<int>& nums)\\n    {\\n        sort(nums.begin(),nums.end(),greater<int> ());\\n        \\n        map<int,vector<int>> mp;\\n        for(int i=0; i<nums.size();i++)\\n        {\\n            int x = sum(nums[i]);\\n            mp[x].push_back(nums[i]);\\n        }\\n        \\n        int maxi = -1;\\n        for(auto it : mp)\\n        {\\n            if(it.second.size()<=1) continue;\\n            vector<int> temp = it.second;\\n            maxi = max(maxi,(temp[0]+temp[1]));\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution\\n{\\npublic:\\n    int sum(int x)\\n    {\\n        int n =0;\\n        while(x>0)\\n        {\\n            n+=(x%10);\\n            x/=10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2715216,
                "title": "c-easy-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) \\n    {\\n        unordered_map<long long int,vector<int>>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int currnum = nums[i];\\n            long long int sum = 0;\\n\\n            while(currnum>0)\\n            {\\n                sum = sum + (currnum % 10);\\n                currnum = currnum/10;\\n            }\\n            mp[sum].push_back(nums[i]);\\n        }\\n        int ans=-1;\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if((it->second.size())>1)\\n            {\\n                sort(it->second.begin(),it->second.end());\\n                int temp=(it->second[it->second.size()-1]+it->second[it->second.size()-2]);\\t\\n                ans=max(ans,temp);\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) \\n    {\\n        unordered_map<long long int,vector<int>>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int currnum = nums[i];\\n            long long int sum = 0;\\n\\n            while(currnum>0)\\n            {\\n                sum = sum + (currnum % 10);\\n                currnum = currnum/10;\\n            }\\n            mp[sum].push_back(nums[i]);\\n        }\\n        int ans=-1;\\n        for(auto it=mp.begin();it!=mp.end();it++)\\n        {\\n            if((it->second.size())>1)\\n            {\\n                sort(it->second.begin(),it->second.end());\\n                int temp=(it->second[it->second.size()-1]+it->second[it->second.size()-2]);\\t\\n                ans=max(ans,temp);\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328303,
                "title": "java-easy-solution-100-faster-100-less-memory",
                "content": "\\'\\'\\'\\nclass Solution {\\n\\n    public int maximumSum(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        \\n        int maxSum=-1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int sum=0;\\n            int temp=nums[i];\\n            while(temp>0){\\n                sum+=temp%10;\\n                temp/=10;\\n            }\\n            if(!map.containsKey(sum)){\\n                map.put(sum,nums[i]);\\n            }else{\\n                maxSum=Math.max(map.get(sum)+nums[i],maxSum);\\n                map.put(sum,Math.max(nums[i],map.get(sum)));\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int maximumSum(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        \\n        int maxSum=-1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int sum=0;\\n            int temp=nums[i];\\n            while(temp>0){\\n                sum+=temp%10;\\n                temp/=10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2312889,
                "title": "python-solution-using-hash-map-with-explanation",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        c=defaultdict(list)\\n        nums.sort()\\n        ## Approach:\\n        ## Find some of digits of all numbers\\n        ## Store the sum value in a dictionary. The sum value is the key and the number itself is appended in a list\\n        ## This gives me all the numbers that has some particular value as sum\\n        ## Numbers are sorted in ascending order, so the list corresponding to the digits sums also gets sorted automatically\\n        for x in nums:\\n            y=x\\n            t=0\\n            while x:\\n                t+=x%10\\n                x//=10\\n            c[t].append(y)\\n\\n        res=-1\\n        for x in c:\\n            if len(c[x])>1:\\n                y=c[x]\\n                res=max(res,y[-1]+y[-2])\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        c=defaultdict(list)\\n        nums.sort()\\n        ## Approach:\\n        ## Find some of digits of all numbers\\n        ## Store the sum value in a dictionary. The sum value is the key and the number itself is appended in a list\\n        ## This gives me all the numbers that has some particular value as sum\\n        ## Numbers are sorted in ascending order, so the list corresponding to the digits sums also gets sorted automatically\\n        for x in nums:\\n            y=x\\n            t=0\\n            while x:\\n                t+=x%10\\n                x//=10\\n            c[t].append(y)\\n\\n        res=-1\\n        for x in c:\\n            if len(c[x])>1:\\n                y=c[x]\\n                res=max(res,y[-1]+y[-2])\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312018,
                "title": "using-map-int-vector-int-mp-and-greedy-apporach-nice-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumOfDigit(int n){\\n        int ans = 0;\\n        while(n>0){\\n            ans = ans + n%10;\\n            n = n / 10;\\n        }\\n        return ans;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int,vector<int>> mp;\\n        int ans = 0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;++i){\\n            mp[sumOfDigit(nums[i])].push_back(nums[i]);\\n        }\\n        \\n        int mx = 0;\\n        for(auto it:mp){\\n            ans = 0;\\n            vector<int> vec = it.second;\\n            if(vec.size()>1){\\n                ans += vec[vec.size()-2] + vec[vec.size()-1];\\n            }\\n            mx = max(mx,ans);\\n        }\\n        \\n        return mx>0?mx:-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumOfDigit(int n){\\n        int ans = 0;\\n        while(n>0){\\n            ans = ans + n%10;\\n            n = n / 10;\\n        }\\n        return ans;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        int n = nums.size();\\n        map<int,vector<int>> mp;\\n        int ans = 0;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;++i){\\n            mp[sumOfDigit(nums[i])].push_back(nums[i]);\\n        }\\n        \\n        int mx = 0;\\n        for(auto it:mp){\\n            ans = 0;\\n            vector<int> vec = it.second;\\n            if(vec.size()>1){\\n                ans += vec[vec.size()-2] + vec[vec.size()-1];\\n            }\\n            mx = max(mx,ans);\\n        }\\n        \\n        return mx>0?mx:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308675,
                "title": "java-hashmap-priority-queue",
                "content": "```\\npublic int maximumSum(int[] nums) {\\n        int maxSum = -1;\\n        Map<Integer, PriorityQueue<Integer>> numsSumMap = new HashMap<>();\\n        for (int num : nums) {\\n            int digitsSum = 0;\\n            int n = num;\\n            while (n > 0) {\\n                digitsSum += n % 10;\\n                n /= 10;\\n            }\\n            if (numsSumMap.containsKey(digitsSum)) {\\n                PriorityQueue<Integer> queue = numsSumMap.get(digitsSum);\\n                if (queue.size() > 0) maxSum = Math.max(maxSum, num + queue.peek());\\n                queue.offer(num);\\n            } else {\\n                PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n                queue.offer(num);\\n                numsSumMap.put(digitsSum, queue);\\n            }\\n        }\\n        return maxSum;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int maximumSum(int[] nums) {\\n        int maxSum = -1;\\n        Map<Integer, PriorityQueue<Integer>> numsSumMap = new HashMap<>();\\n        for (int num : nums) {\\n            int digitsSum = 0;\\n            int n = num;\\n            while (n > 0) {\\n                digitsSum += n % 10;\\n                n /= 10;\\n            }\\n            if (numsSumMap.containsKey(digitsSum)) {\\n                PriorityQueue<Integer> queue = numsSumMap.get(digitsSum);\\n                if (queue.size() > 0) maxSum = Math.max(maxSum, num + queue.peek());\\n                queue.offer(num);\\n            } else {\\n                PriorityQueue<Integer> queue = new PriorityQueue<>(Comparator.reverseOrder());\\n                queue.offer(num);\\n                numsSumMap.put(digitsSum, queue);\\n            }\\n        }\\n        return maxSum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2298479,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> sum;\\n        for(int i=0;i<nums.size();i++){\\n            int temp=nums[i],s=0;\\n            while(temp>0){\\n                s+=temp%10;\\n                temp=temp/10;\\n            }\\n            sum.push_back(s);\\n        }\\n        int maxi=0;\\n        for(int i=0;i<sum.size();i++){\\n            auto it=find(sum.begin()+i+1,sum.end(),sum[i]);\\n            if(it!=sum.end())\\n                maxi=max(maxi,nums[i]+nums[it-sum.begin()]);\\n        }\\n        if(maxi==0)return -1;\\n        \\n        return maxi;\\n    }\\n};******\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        vector<int> sum;\\n        for(int i=0;i<nums.size();i++){\\n            int temp=nums[i],s=0;\\n            while(temp>0){\\n                s+=temp%10;\\n                temp=temp/10;\\n            }\\n            sum.push_back(s);\\n        }\\n        int maxi=0;\\n        for(int i=0;i<sum.size();i++){\\n            auto it=find(sum.begin()+i+1,sum.end(),sum[i]);\\n            if(it!=sum.end())\\n                maxi=max(maxi,nums[i]+nums[it-sum.begin()]);\\n        }\\n        if(maxi==0)return -1;\\n        \\n        return maxi;\\n    }\\n};******\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298463,
                "title": "c-easy-noobie-logic",
                "content": "LET ME KNOW IF YOU HAVE ANY DOUBTS!\\n```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        vector<string>v;\\n        for(int i=0;i<nums.size();i++){\\n            v.push_back(to_string(nums[i])); //converting int to string\\n        }\\n        vector<pair<int,int>>v1;\\n        for(int i=0;i<v.size();i++){\\n            int sum=0;\\n            for(int j=0;j<v[i].size();j++){\\n                sum+=(int)(v[i][j]-\\'0\\');\\n            }\\n            v1.push_back({sum,nums[i]}); //{9,18}\\n        }\\n        int maxi=-1;\\n        \\n        sort(v1.begin(),v1.end());\\n        int temp=v1[0].first;\\n        int temp1=v1[0].second;\\n        int current=0;\\n        for(int i=1;i<v1.size();i++){\\n            if(temp==v1[i].first){\\n                current=temp1+v1[i].second; \\n                maxi=max(maxi,current);\\n                temp=v1[i].first;\\n                temp1=v1[i].second;\\n            }\\n            else{\\n                current=0;\\n                temp=v1[i].first;\\n                temp1=v1[i].second;\\n            }\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        vector<string>v;\\n        for(int i=0;i<nums.size();i++){\\n            v.push_back(to_string(nums[i])); //converting int to string\\n        }\\n        vector<pair<int,int>>v1;\\n        for(int i=0;i<v.size();i++){\\n            int sum=0;\\n            for(int j=0;j<v[i].size();j++){\\n                sum+=(int)(v[i][j]-\\'0\\');\\n            }\\n            v1.push_back({sum,nums[i]}); //{9,18}\\n        }\\n        int maxi=-1;\\n        \\n        sort(v1.begin(),v1.end());\\n        int temp=v1[0].first;\\n        int temp1=v1[0].second;\\n        int current=0;\\n        for(int i=1;i<v1.size();i++){\\n            if(temp==v1[i].first){\\n                current=temp1+v1[i].second; \\n                maxi=max(maxi,current);\\n                temp=v1[i].first;\\n                temp1=v1[i].second;\\n            }\\n            else{\\n                current=0;\\n                temp=v1[i].first;\\n                temp1=v1[i].second;\\n            }\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296352,
                "title": "c-code-that-beats-every-other-solution-100-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int getSum(int n)\\n    {\\n        int sum = 0;\\n        while (n != 0) {\\n            sum = sum + n % 10;\\n            n = n / 10;\\n        }\\n        return sum;\\n    }\\n\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        \\n        vector<int> n;\\n        int max= -1;\\n        for(int i=0;i<nums.size();i++){\\n            n.push_back(getSum(nums[i]));\\n            if(m.find(n[i])!=m.end()){\\n                int sum=nums[i]+m[n[i]];\\n                if(sum>=max){\\n                    max=sum;\\n                }\\n            }\\n            if(nums[i]>m[n[i]]){\\n            m[n[i]]=nums[i];\\n            }\\n        }\\n        \\n        return max;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getSum(int n)\\n    {\\n        int sum = 0;\\n        while (n != 0) {\\n            sum = sum + n % 10;\\n            n = n / 10;\\n        }\\n        return sum;\\n    }\\n\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        \\n        vector<int> n;\\n        int max= -1;\\n        for(int i=0;i<nums.size();i++){\\n            n.push_back(getSum(nums[i]));\\n            if(m.find(n[i])!=m.end()){\\n                int sum=nums[i]+m[n[i]];\\n                if(sum>=max){\\n                    max=sum;\\n                }\\n            }\\n            if(nums[i]>m[n[i]]){\\n            m[n[i]]=nums[i];\\n            }\\n        }\\n        \\n        return max;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296341,
                "title": "c-100-better-time-100-better-memory",
                "content": "Please Upvote if helpful. \\n```\\nclass Solution {\\npublic:\\n    int getSum(int x){\\n        int sum=0;\\n        while(x){\\n            sum+=x%10;\\n            x/=10;\\n        }\\n        return sum;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        map<int,multiset<int>> m;\\n        for(auto x: nums){\\n             m[getSum(x)].insert(x);\\n        }\\n        \\n        int sum=INT_MIN;\\n        \\n        for(auto x:m){\\n            if(x.second.size()>1){\\n                int ele= *(--x.second.end()) + *(--(--x.second.end()));\\n                sum=max(sum,ele);\\n            }\\n        }\\n        return sum==INT_MIN?-1:sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getSum(int x){\\n        int sum=0;\\n        while(x){\\n            sum+=x%10;\\n            x/=10;\\n        }\\n        return sum;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        map<int,multiset<int>> m;\\n        for(auto x: nums){\\n             m[getSum(x)].insert(x);\\n        }\\n        \\n        int sum=INT_MIN;\\n        \\n        for(auto x:m){\\n            if(x.second.size()>1){\\n                int ele= *(--x.second.end()) + *(--(--x.second.end()));\\n                sum=max(sum,ele);\\n            }\\n        }\\n        return sum==INT_MIN?-1:sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294626,
                "title": "c-faster-than-100-detailed-explanation-with-comments-array-of-vectors-used",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n    // function to calculate sum of digits for a number.\\n    int sumOfDigits(int num)\\n    {\\n        int total = 0;\\n        // while number is greater than 0, we keep on dividing  it by 10\\n        while (num > 0)\\n        {\\n            int last_digit = num % 10;\\n            // modulo(%) by 10 gives the last digit of current number.\\n            total = total + last_digit;\\n            // we keep on adding last digit of current number in our total\\n            num = num / 10;\\n            // we divide by 10 so that the last digit which we have already considered is now removed from the number.\\n        }\\n        return total;\\n    }\\n    int maximumSum(vector<int> &nums)\\n    {\\n        int n = 100;\\n        vector<int> arr[n];\\n        // we declare an array of vectors of size 100.\\n        // it means that we have an array of 100 vectors.\\n        // as per constraints for the largest number - 999999999\\n        // the sum of digits can be 81, so it\\'s safe to take array of vectors of size 100.\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            int total = sumOfDigits(nums[i]);\\n            // for each number of nums, we calculate sumofdigits\\n            // and push this sum into a vector which will contain a list of numbers having digit sum - total\\n            // like arr[0] - is a vector which will contain all numbers having sum of digit = 0\\n            // arr[20] - is a vector which will contain all numbers having sum of digit = 20\\n            arr[total].push_back(nums[i]);\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            // we check over all our vectors which are containing list of numbers having a particular sum of digits from 0 to 99.\\n            int size = arr[i].size();\\n            if (size > 1)\\n            {\\n                // if the vector is having more than one number, we sort it\\n                // as we want maximum sum of 2 numbers having same sumOfDigits.\\n                sort(arr[i].begin(), arr[i].end());\\n            }\\n        }\\n        int answer;\\n        int max_answer = -1; // we first initailize our final answer by -1 in case no such pair of numbers is found.\\n        for (int i = 0; i < n; i++)\\n        {\\n            int size = arr[i].size();\\n            if (size > 1)\\n            {\\n                // if we a have a vector containing more than 1 number having a particular sum of digits.\\n                // then we take the last two numbers from it.\\n                // as we have to give maximum sum of 2 numbers having same sumOfDigits.\\n                answer = arr[i][size - 1] + arr[i][size - 2];\\n                max_answer = max(answer, max_answer);\\n                // at each iteration, we compare our current answer with previous one and move onwards with the greater one.\\n            }\\n        }\\n        // after completing the iteration over all vectors, we return our final answer.\\n        return max_answer;\\n    }\\n    // time complexity - N LOG(N)\\n};\\n```\\nPlease upvote if you find it useful!!",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    // function to calculate sum of digits for a number.\\n    int sumOfDigits(int num)\\n    {\\n        int total = 0;\\n        // while number is greater than 0, we keep on dividing  it by 10\\n        while (num > 0)\\n        {\\n            int last_digit = num % 10;\\n            // modulo(%) by 10 gives the last digit of current number.\\n            total = total + last_digit;\\n            // we keep on adding last digit of current number in our total\\n            num = num / 10;\\n            // we divide by 10 so that the last digit which we have already considered is now removed from the number.\\n        }\\n        return total;\\n    }\\n    int maximumSum(vector<int> &nums)\\n    {\\n        int n = 100;\\n        vector<int> arr[n];\\n        // we declare an array of vectors of size 100.\\n        // it means that we have an array of 100 vectors.\\n        // as per constraints for the largest number - 999999999\\n        // the sum of digits can be 81, so it\\'s safe to take array of vectors of size 100.\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            int total = sumOfDigits(nums[i]);\\n            // for each number of nums, we calculate sumofdigits\\n            // and push this sum into a vector which will contain a list of numbers having digit sum - total\\n            // like arr[0] - is a vector which will contain all numbers having sum of digit = 0\\n            // arr[20] - is a vector which will contain all numbers having sum of digit = 20\\n            arr[total].push_back(nums[i]);\\n        }\\n        for (int i = 0; i < n; i++)\\n        {\\n            // we check over all our vectors which are containing list of numbers having a particular sum of digits from 0 to 99.\\n            int size = arr[i].size();\\n            if (size > 1)\\n            {\\n                // if the vector is having more than one number, we sort it\\n                // as we want maximum sum of 2 numbers having same sumOfDigits.\\n                sort(arr[i].begin(), arr[i].end());\\n            }\\n        }\\n        int answer;\\n        int max_answer = -1; // we first initailize our final answer by -1 in case no such pair of numbers is found.\\n        for (int i = 0; i < n; i++)\\n        {\\n            int size = arr[i].size();\\n            if (size > 1)\\n            {\\n                // if we a have a vector containing more than 1 number having a particular sum of digits.\\n                // then we take the last two numbers from it.\\n                // as we have to give maximum sum of 2 numbers having same sumOfDigits.\\n                answer = arr[i][size - 1] + arr[i][size - 2];\\n                max_answer = max(answer, max_answer);\\n                // at each iteration, we compare our current answer with previous one and move onwards with the greater one.\\n            }\\n        }\\n        // after completing the iteration over all vectors, we return our final answer.\\n        return max_answer;\\n    }\\n    // time complexity - N LOG(N)\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294624,
                "title": "c-complexity-o-n-x-o-n-easy-to-understand",
                "content": "## T.C -> O(N * (no. of digit in a longest number))\\n## S.C -> O(N)\\n```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        unordered_map<int, pair<int, int>> v;\\n        \\n        for(int &i: nums){\\n            \\n            int sum = 0, m, n = i;\\n            while(n>0){    \\n                m=n%10;    \\n                sum=sum+m;    \\n                n=n/10;    \\n            }\\n            if(v.find(sum) == v.end()){\\n                v[sum].first = i;\\n                v[sum].second = -1;                \\n            }\\n            else{\\n                int x = -1;\\n                if(v[sum].first < i){\\n                    x = v[sum].first;\\n                    v[sum].first = i;\\n                }\\n                else x = i;\\n                if(v[sum].second < x) v[sum].second = x;\\n            }\\n        }\\n        int ans = -1;\\n        \\n        for(auto &[k, val]: v){\\n            \\n            if(val.first != -1 && val.second != -1){\\n                ans = max(ans, val.first + val.second);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        unordered_map<int, pair<int, int>> v;\\n        \\n        for(int &i: nums){\\n            \\n            int sum = 0, m, n = i;\\n            while(n>0){    \\n                m=n%10;    \\n                sum=sum+m;    \\n                n=n/10;    \\n            }\\n            if(v.find(sum) == v.end()){\\n                v[sum].first = i;\\n                v[sum].second = -1;                \\n            }\\n            else{\\n                int x = -1;\\n                if(v[sum].first < i){\\n                    x = v[sum].first;\\n                    v[sum].first = i;\\n                }\\n                else x = i;\\n                if(v[sum].second < x) v[sum].second = x;\\n            }\\n        }\\n        int ans = -1;\\n        \\n        for(auto &[k, val]: v){\\n            \\n            if(val.first != -1 && val.second != -1){\\n                ans = max(ans, val.first + val.second);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294434,
                "title": "c-easy-solution-100-understandable-have-a-nice-day",
                "content": "```\\nclass Solution {\\npublic:\\n    //Function which provides us sum of Digits.\\n    int dsf(int v){\\n        int t=v,d=0;\\n        while(t){\\n            d=d+(t%10);\\n            t=t/10;\\n        }\\n        return d;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        //Creating a map, where key is sum of digit, and value will have a multiset with all those numbers with Sum of digits as key value.\\n        map<int,multiset<int>> mp;\\n        int maxSum=-1;\\n        for(int v:nums){\\n            int sod=dsf(v);\\n            mp[sod].insert(v);\\n        }\\n        \\n        //Traversing over Map, and moving over all these sets which we created before, because every set has only those values which have same sum of digits. so we will pick last 2 values from the set because both of them will be maximum in the set.\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            multiset<int> st=it->second;\\n            if(st.size()>=2){\\n                auto it=st.end();\\n                it--;\\n                int v1=*it;\\n                it--;\\n                int v2=*it;\\n                it--;\\n                \\n                maxSum=max(maxSum,v1+v2);\\n            }\\n            \\n        }\\n        \\n        return maxSum;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Function which provides us sum of Digits.\\n    int dsf(int v){\\n        int t=v,d=0;\\n        while(t){\\n            d=d+(t%10);\\n            t=t/10;\\n        }\\n        return d;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        //Creating a map, where key is sum of digit, and value will have a multiset with all those numbers with Sum of digits as key value.\\n        map<int,multiset<int>> mp;\\n        int maxSum=-1;\\n        for(int v:nums){\\n            int sod=dsf(v);\\n            mp[sod].insert(v);\\n        }\\n        \\n        //Traversing over Map, and moving over all these sets which we created before, because every set has only those values which have same sum of digits. so we will pick last 2 values from the set because both of them will be maximum in the set.\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            multiset<int> st=it->second;\\n            if(st.size()>=2){\\n                auto it=st.end();\\n                it--;\\n                int v1=*it;\\n                it--;\\n                int v2=*it;\\n                it--;\\n                \\n                maxSum=max(maxSum,v1+v2);\\n            }\\n            \\n        }\\n        \\n        return maxSum;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294104,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sorting && Unordered Map***\\n\\n* ***Time Complexity :- O(NlogN)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function for finding sum of digits in num\\n    \\n    int find_sum(int num)\\n    {\\n        int sum = 0;\\n        \\n        while(num)\\n        {\\n            sum += num % 10;\\n            \\n            num = num / 10;\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    int maximumSum(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // sort the array\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // declare a unordered map\\n        \\n        unordered_map<int, vector<int>> mp;\\n        \\n        // group the elements according to sum of their digit \\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // find sum of digit\\n            \\n            int sum = find_sum(nums[i]);\\n            \\n            // push into mp\\n            \\n            mp[sum].push_back(nums[i]);\\n        }\\n        \\n        int maxi = -1;\\n        \\n        // iterate over mp for finding maxi\\n        \\n        for(auto x : mp)\\n        {\\n            auto v = x.second;\\n            \\n            // find sum of two maximum element and update maxi\\n            \\n            if(v.size() >= 2)\\n            {\\n                maxi = max(maxi, v[v.size() - 1] + v[v.size() - 2]);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // function for finding sum of digits in num\\n    \\n    int find_sum(int num)\\n    {\\n        int sum = 0;\\n        \\n        while(num)\\n        {\\n            sum += num % 10;\\n            \\n            num = num / 10;\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    int maximumSum(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // sort the array\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // declare a unordered map\\n        \\n        unordered_map<int, vector<int>> mp;\\n        \\n        // group the elements according to sum of their digit \\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            // find sum of digit\\n            \\n            int sum = find_sum(nums[i]);\\n            \\n            // push into mp\\n            \\n            mp[sum].push_back(nums[i]);\\n        }\\n        \\n        int maxi = -1;\\n        \\n        // iterate over mp for finding maxi\\n        \\n        for(auto x : mp)\\n        {\\n            auto v = x.second;\\n            \\n            // find sum of two maximum element and update maxi\\n            \\n            if(v.size() >= 2)\\n            {\\n                maxi = max(maxi, v[v.size() - 1] + v[v.size() - 2]);\\n            }\\n        }\\n        \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293812,
                "title": "cpp-solution-easy-understanding-hash-map",
                "content": "**TIME COMPLEX : O(n log(n))  // as involves sorting\\nSPACE COMPLEX :  O(n)   // for using hashmap**\\n\\n```\\nint n= nums.size();\\n      \\n        map<int, vector<int>> mp; // key : sum of ith element of nums\\n                                  // value: all indices whose value sum up to key\\n        int sum;\\n        sort(nums.begin() , nums.end(),greater<int>()); \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int num= nums[i], sum=0;\\n            while(num)         // calculating the sum of element value\\n            {\\n               sum+=num%10;\\n               num/=10;\\n            }\\n            mp[sum].push_back(i);  // inserting the sum along with its index\\n        }\\n  \\n        int maxm=-1;\\n        for(auto it:mp)\\n        {\\n\\n            if(it.second.size() >1)  // only if there are pairs available\\n            {\\n              int num= nums[it.second[0]]+ nums[it.second[1]]; //taking the largest two                                                                      element\\n              maxm=max(maxm,num );\\n            }\\n\\n        }\\n        return maxm;\\n```\\n\\n  *PLEASE  UPVOTE IF THE SOLUTION WAS HELPFUL*\\n  \\n  ![image](https://assets.leetcode.com/users/images/a942113a-6f18-4115-93a0-230d55c82b87_1658049295.2062066.jpeg)\\n\\n\\n\\n\\t\\n\\t\\n\\t\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint n= nums.size();\\n      \\n        map<int, vector<int>> mp; // key : sum of ith element of nums\\n                                  // value: all indices whose value sum up to key\\n        int sum;\\n        sort(nums.begin() , nums.end(),greater<int>()); \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int num= nums[i], sum=0;\\n            while(num)         // calculating the sum of element value\\n            {\\n               sum+=num%10;\\n               num/=10;\\n            }\\n            mp[sum].push_back(i);  // inserting the sum along with its index\\n        }\\n  \\n        int maxm=-1;\\n        for(auto it:mp)\\n        {\\n\\n            if(it.second.size() >1)  // only if there are pairs available\\n            {\\n              int num= nums[it.second[0]]+ nums[it.second[1]]; //taking the largest two                                                                      element\\n              maxm=max(maxm,num );\\n            }\\n\\n        }\\n        return maxm;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2293768,
                "title": "c-priority-queue-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumOfDigit(int n){\\n        int ans = 0;\\n        while(n){\\n            ans += n%10;\\n            n /= 10;\\n        }\\n        return ans;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,priority_queue<int>> mp;\\n        for(int i : nums){\\n            mp[sumOfDigit(i)].push(i);\\n        }\\n        int mx = -1;\\n        for(auto i : mp){\\n            if(i.second.size()>=2){\\n                int a = i.second.top();\\n                i.second.pop();\\n                int b = i.second.top();\\n                i.second.pop();\\n                mx = max(a+b,mx);\\n            }\\n        }\\n        return mx;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int sumOfDigit(int n){\\n        int ans = 0;\\n        while(n){\\n            ans += n%10;\\n            n /= 10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2293347,
                "title": "c-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int getSum(int n)\\n    {\\n        int sum = 0;\\n        while (n != 0) {\\n            sum = sum + n % 10;\\n            n = n / 10;\\n        }\\n        return sum;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int, vector<int>> mp; \\n        \\n        for (auto num: nums) {\\n            int s= getSum(num); \\n            mp[s].push_back(num); \\n        }\\n        int mx=0; \\n        vector<int> values; \\n        int ans=-1; \\n        for (auto m: mp) {\\n            // cout<<m.first<<\" : \";\\n            // for (auto v: m.second) cout<<v<<\" \"; \\n            // cout<<endl;\\n            \\n            if (m.second.size() > 1) {\\n                values= m.second; \\n                sort(values.rbegin(), values.rend());\\n                ans= max(ans, values[0]+ values[1]); \\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getSum(int n)\\n    {\\n        int sum = 0;\\n        while (n != 0) {\\n            sum = sum + n % 10;\\n            n = n / 10;\\n        }\\n        return sum;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int, vector<int>> mp; \\n        \\n        for (auto num: nums) {\\n            int s= getSum(num); \\n            mp[s].push_back(num); \\n        }\\n        int mx=0; \\n        vector<int> values; \\n        int ans=-1; \\n        for (auto m: mp) {\\n            // cout<<m.first<<\" : \";\\n            // for (auto v: m.second) cout<<v<<\" \"; \\n            // cout<<endl;\\n            \\n            if (m.second.size() > 1) {\\n                values= m.second; \\n                sort(values.rbegin(), values.rend());\\n                ans= max(ans, values[0]+ values[1]); \\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2293305,
                "title": "python-one-pass-hash-table-easy-approach-beats-100-00-both-runtime-memory-remainder",
                "content": "```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        \\n        def getSum(n):\\n    \\n            sum = 0\\n            for digit in str(n): \\n              sum += int(digit)      \\n            return sum\\n\\n        hashmap = {}\\n        sumMax = -1\\n        for i in range(len(nums)):\\n            complement = getSum(nums[i])\\n            if complement in hashmap:\\n                sumMax = max(sumMax, nums[i] + hashmap[complement])\\n                if nums[i] > hashmap[complement]:\\n                    hashmap[complement] = nums[i]\\n            else:\\n                hashmap[complement] = nums[i]\\n\\n        return sumMax\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        \\n        def getSum(n):\\n    \\n            sum = 0\\n            for digit in str(n): \\n              sum += int(digit)      \\n            return sum\\n\\n        hashmap = {}\\n        sumMax = -1\\n        for i in range(len(nums)):\\n            complement = getSum(nums[i])\\n            if complement in hashmap:\\n                sumMax = max(sumMax, nums[i] + hashmap[complement])\\n                if nums[i] > hashmap[complement]:\\n                    hashmap[complement] = nums[i]\\n            else:\\n                hashmap[complement] = nums[i]\\n\\n        return sumMax\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293210,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        vector<pair<int, int>> temp;\\n        int maxi = -1;\\n        for(int i = 0; i < nums.size(); i++) {\\n            string s = to_string(nums[i]);\\n            int sum = 0;\\n            for(int j = 0; j < s.size(); j++) {\\n                sum += (s[j] - \\'0\\');\\n            }\\n            temp.push_back({sum, i});\\n        }\\n        sort(temp.begin(), temp.end());\\n        int i = 0;\\n        while(i < temp.size()) {\\n            int h = temp[i].first;\\n            priority_queue<int> pq;\\n            int j = i;\\n            for(; j < temp.size(); j++) {\\n                if(temp[j].first == h) {\\n                    cout << nums[temp[j].second] << endl;\\n                    pq.push(nums[temp[j].second]);\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if (pq.size() >= 2) {\\n                int sum = pq.top();\\n                pq.pop();\\n                sum += pq.top();\\n                maxi = max(maxi, sum);\\n            }\\n            i = j;\\n        }\\n        return maxi == -1 ? -1 : maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        vector<pair<int, int>> temp;\\n        int maxi = -1;\\n        for(int i = 0; i < nums.size(); i++) {\\n            string s = to_string(nums[i]);\\n            int sum = 0;\\n            for(int j = 0; j < s.size(); j++) {\\n                sum += (s[j] - \\'0\\');\\n            }\\n            temp.push_back({sum, i});\\n        }\\n        sort(temp.begin(), temp.end());\\n        int i = 0;\\n        while(i < temp.size()) {\\n            int h = temp[i].first;\\n            priority_queue<int> pq;\\n            int j = i;\\n            for(; j < temp.size(); j++) {\\n                if(temp[j].first == h) {\\n                    cout << nums[temp[j].second] << endl;\\n                    pq.push(nums[temp[j].second]);\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if (pq.size() >= 2) {\\n                int sum = pq.top();\\n                pq.pop();\\n                sum += pq.top();\\n                maxi = max(maxi, sum);\\n            }\\n            i = j;\\n        }\\n        return maxi == -1 ? -1 : maxi;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2293129,
                "title": "c-hashmap-priority-queue-100-faster",
                "content": "```\\n// Time Complexity is O(N) because priority queue is of size 2\\n// Create minheap of size 2 for every digit sum to store the top 2 values corresponding to a digit sum.\\n\\nclass Solution {\\npublic:\\n    int sod(int x)\\n    {\\n        int ans=0;\\n        while(x>0)\\n        {\\n            ans+=x%10;\\n            x=x/10;\\n        }\\n        return ans;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,priority_queue<int,vector<int>,greater<int>>>mp;\\n        for(auto i:nums)\\n        {\\n            int a=sod(i);\\n            mp[a].push(i);\\n            if(mp[a].size()>2)mp[a].pop();\\n        }\\n        int ans=-1;\\n        for(auto i:mp)\\n        {\\n            if(i.second.size()==2)\\n            {\\n                int x=i.second.top();\\n                i.second.pop();\\n                int y=i.second.top();\\n                i.second.pop();\\n                ans=max(ans,x+y);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// Time Complexity is O(N) because priority queue is of size 2\\n// Create minheap of size 2 for every digit sum to store the top 2 values corresponding to a digit sum.\\n\\nclass Solution {\\npublic:\\n    int sod(int x)\\n    {\\n        int ans=0;\\n        while(x>0)\\n        {\\n            ans+=x%10;\\n            x=x/10;\\n        }\\n        return ans;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,priority_queue<int,vector<int>,greater<int>>>mp;\\n        for(auto i:nums)\\n        {\\n            int a=sod(i);\\n            mp[a].push(i);\\n            if(mp[a].size()>2)mp[a].pop();\\n        }\\n        int ans=-1;\\n        for(auto i:mp)\\n        {\\n            if(i.second.size()==2)\\n            {\\n                int x=i.second.top();\\n                i.second.pop();\\n                int y=i.second.top();\\n                i.second.pop();\\n                ans=max(ans,x+y);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293084,
                "title": "c-priority-queue",
                "content": "**Approach**\\n1. Group the same `DigitSum` elements in `priority_queue`\\n2. Go over the `DigitSum` and calculate the max with 2 elements.\\n\\n**Time:** `O(N + 82 * K log K), N = Length of nums, K = Same digit sum elements`\\n**Space:** `O(82 * K log K)`\\n```\\nclass Solution {\\npublic:\\n    int DigitSum(int n) {\\n        int res = 0;\\n        while (n) {\\n            int rem = n % 10;\\n            res += rem;\\n            n /= 10;\\n        }\\n        return res;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        priority_queue<int> equal_sum[82];\\n        for (auto n : nums) {\\n            equal_sum[DigitSum(n)].push(n);\\n        }\\n        int sum = -1;\\n        for (int i = 0; i < 82; i++) {\\n            if (equal_sum[i].size() >= 2) {\\n                int top = equal_sum[i].top();\\n                equal_sum[i].pop();\\n                top += equal_sum[i].top();\\n                sum = max(sum, top);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int DigitSum(int n) {\\n        int res = 0;\\n        while (n) {\\n            int rem = n % 10;\\n            res += rem;\\n            n /= 10;\\n        }\\n        return res;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        priority_queue<int> equal_sum[82];\\n        for (auto n : nums) {\\n            equal_sum[DigitSum(n)].push(n);\\n        }\\n        int sum = -1;\\n        for (int i = 0; i < 82; i++) {\\n            if (equal_sum[i].size() >= 2) {\\n                int top = equal_sum[i].top();\\n                equal_sum[i].pop();\\n                top += equal_sum[i].top();\\n                sum = max(sum, top);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293039,
                "title": "easy-map-based-solution",
                "content": "Max Sum of a Pair With Equal Sum of Digits\\n```\\nclass Solution {\\npublic:\\n    int fn(int num)\\n    {\\n        int sum=0;\\n        while(num!=0)\\n        {\\n            int k=num%10;\\n            sum+=k;\\n            num/=10;\\n        }\\n        return sum;\\n    }\\n    int two(vector<int> &nums)\\n    {\\n       int max1=*max_element(nums.begin(), nums.end());\\n        nums.erase(find(nums.begin(), nums.end(), max1));\\n        int max2=*max_element(nums.begin(), nums.end());\\n        return max1+max2;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        int maxi=-1;\\n        map<int,vector<int>>mp;\\n        vector<int> v(nums.size(), 0);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          int k=fn(nums[i]);\\n            mp[k].push_back(nums[i]);\\n        }\\n       for(auto i:mp)\\n       {\\n           if(i.second.size()>1)\\n           {\\n               maxi=max(maxi, two(i.second));\\n           }\\n       }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fn(int num)\\n    {\\n        int sum=0;\\n        while(num!=0)\\n        {\\n            int k=num%10;\\n            sum+=k;\\n            num/=10;\\n        }\\n        return sum;\\n    }\\n    int two(vector<int> &nums)\\n    {\\n       int max1=*max_element(nums.begin(), nums.end());\\n        nums.erase(find(nums.begin(), nums.end(), max1));\\n        int max2=*max_element(nums.begin(), nums.end());\\n        return max1+max2;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        int maxi=-1;\\n        map<int,vector<int>>mp;\\n        vector<int> v(nums.size(), 0);\\n        for(int i=0;i<nums.size();i++)\\n        {\\n          int k=fn(nums[i]);\\n            mp[k].push_back(nums[i]);\\n        }\\n       for(auto i:mp)\\n       {\\n           if(i.second.size()>1)\\n           {\\n               maxi=max(maxi, two(i.second));\\n           }\\n       }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293011,
                "title": "javascript-hashmap-max-two-sum-543ms",
                "content": "```\\nconst maximumSum = (A) => {\\n    let m = new Map(), res = -1;\\n    for (const x of A) { // accumulate same digit sum in a hashmap\\n        let sum = sumOfDigit(x);\\n        if (!m.has(sum)) m.set(sum, []);\\n        m.get(sum).push(x);\\n    }\\n    for (const [sum, a] of m) { // two sum max of each same digit sum\\n        a.sort((x, y) => y - x);\\n        if (a.length >= 2) res = Math.max(res, a[0] + a[1]);\\n    }\\n    return res;\\n};\\n\\nconst sumOfDigit = (x) => {\\n    let s = x + \\'\\', res = 0;\\n    for (const c of s) res += c - \\'0\\';\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maximumSum = (A) => {\\n    let m = new Map(), res = -1;\\n    for (const x of A) { // accumulate same digit sum in a hashmap\\n        let sum = sumOfDigit(x);\\n        if (!m.has(sum)) m.set(sum, []);\\n        m.get(sum).push(x);\\n    }\\n    for (const [sum, a] of m) { // two sum max of each same digit sum\\n        a.sort((x, y) => y - x);\\n        if (a.length >= 2) res = Math.max(res, a[0] + a[1]);\\n    }\\n    return res;\\n};\\n\\nconst sumOfDigit = (x) => {\\n    let s = x + \\'\\', res = 0;\\n    for (const c of s) res += c - \\'0\\';\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2292954,
                "title": "java-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n     Map<Integer,Integer>map=new HashMap<>();\\n    int max=-1;\\n        for(int i=0;i<nums.length;i++){\\n          int sum=getsum(nums[i]);\\n            if(map.containsKey(sum)){\\n                max=Math.max(max,nums[i]+map.get(sum));\\n                if(map.get(sum)<nums[i])map.put(sum,nums[i]);\\n            }\\n            else{\\n                map.put(sum,nums[i]);\\n            }\\n        }\\n        return max;   \\n    }\\n    int getsum(int n){\\n        int sum = 0;\\n        while (n != 0){\\n            sum=sum+n%10;\\n            n = n/10;\\n        }\\n       return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n     Map<Integer,Integer>map=new HashMap<>();\\n    int max=-1;\\n        for(int i=0;i<nums.length;i++){\\n          int sum=getsum(nums[i]);\\n            if(map.containsKey(sum)){\\n                max=Math.max(max,nums[i]+map.get(sum));\\n                if(map.get(sum)<nums[i])map.put(sum,nums[i]);\\n            }\\n            else{\\n                map.put(sum,nums[i]);\\n            }\\n        }\\n        return max;   \\n    }\\n    int getsum(int n){\\n        int sum = 0;\\n        while (n != 0){\\n            sum=sum+n%10;\\n            n = n/10;\\n        }\\n       return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292882,
                "title": "python3-hash-table",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/e6b38b5fa8ff313543c0b854e395b2eddc7e8c93) for solutions of weekly 302. \\n\\n```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        ans = -1\\n        seen = {}\\n        for x in nums: \\n            sm = sum(int(d) for d in str(x))\\n            if sm in seen: \\n                ans = max(ans, seen[sm] + x)\\n                seen[sm] = max(seen[sm], x)\\n            else: seen[sm] = x\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        ans = -1\\n        seen = {}\\n        for x in nums: \\n            sm = sum(int(d) for d in str(x))\\n            if sm in seen: \\n                ans = max(ans, seen[sm] + x)\\n                seen[sm] = max(seen[sm], x)\\n            else: seen[sm] = x\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292820,
                "title": "c-solution-naive-approach-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    long long sum(int n){\\n        string s=to_string(n);\\n        long long ans =0;\\n        for(int i=0;i<s.size();i++){\\n            ans+=(s[i]-\\'0\\');\\n        }\\n        return ans;\\n    }\\n    pair<int,int> top(vector<int> arrA){\\n\\n        if(arrA.size()<2){\\n           return {};\\n        }\\n\\n        int first=INT_MIN;\\n        int second=INT_MIN;\\n\\n        for (int i = 0; i <arrA.size() ; i++) {\\n            int current = arrA[i];\\n            if(first<current){\\n                second = first;\\n                first = current;\\n            }else if(second<current){\\n                second = current;\\n            }\\n        }\\n        return {first,second};\\n    }\\n    int maximumSum(vector<int>& arr) {\\n       long long int maxi=-1;\\n\\n        map<long long ,vector<int>>mp;\\n        for(int i=0;i<arr.size();i++){\\n            // long long aa=\\n            mp[sum(arr[i])].push_back(arr[i]);\\n        }\\n        for(auto m:mp){\\n            if(m.second.size()>=2){\\n                pair<int,int>p=top(m.second);\\n                if(maxi<p.first+p.second){\\n                    maxi=p.first+p.second;\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long sum(int n){\\n        string s=to_string(n);\\n        long long ans =0;\\n        for(int i=0;i<s.size();i++){\\n            ans+=(s[i]-\\'0\\');\\n        }\\n        return ans;\\n    }\\n    pair<int,int> top(vector<int> arrA){\\n\\n        if(arrA.size()<2){\\n           return {};\\n        }\\n\\n        int first=INT_MIN;\\n        int second=INT_MIN;\\n\\n        for (int i = 0; i <arrA.size() ; i++) {\\n            int current = arrA[i];\\n            if(first<current){\\n                second = first;\\n                first = current;\\n            }else if(second<current){\\n                second = current;\\n            }\\n        }\\n        return {first,second};\\n    }\\n    int maximumSum(vector<int>& arr) {\\n       long long int maxi=-1;\\n\\n        map<long long ,vector<int>>mp;\\n        for(int i=0;i<arr.size();i++){\\n            // long long aa=\\n            mp[sum(arr[i])].push_back(arr[i]);\\n        }\\n        for(auto m:mp){\\n            if(m.second.size()>=2){\\n                pair<int,int>p=top(m.second);\\n                if(maxi<p.first+p.second){\\n                    maxi=p.first+p.second;\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292734,
                "title": "c-map-sorting-very-easy",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\t long long int getSum(int n)\\n\\t\\t {\\n\\t\\t\\tlong long int sum;\\n\\t\\t\\tfor (sum = 0; n > 0; sum += n % 10, n /= 10);\\n\\t\\t\\treturn sum;\\n\\t\\t }\\n\\t\\t int maximumSum(vector<int>& nums) {\\n\\t\\t\\tunordered_map<long long int, vector<long long int>>mp;\\n\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t\\tmp[getSum(nums[i])].push_back(nums[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tlong long int maxSum = -1;\\n\\n\\t\\t\\tfor(auto it:mp){\\n\\t\\t\\t\\tint n = it.second.size();\\n\\t\\t\\t\\tif(n>1){\\n\\t\\t\\t\\t\\tsort(it.second.begin(), it.second.end());\\n\\t\\t\\t\\t\\tmaxSum = max(maxSum, (it.second[n-2]+it.second[n-1]));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn maxSum;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t long long int getSum(int n)\\n\\t\\t {\\n\\t\\t\\tlong long int sum;\\n\\t\\t\\tfor (sum = 0; n > 0; sum += n % 10, n /= 10);\\n\\t\\t\\treturn sum;\\n\\t\\t }",
                "codeTag": "Java"
            },
            {
                "id": 2292656,
                "title": "convert-and-sort-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maximumSum(vector<int>& nums) {\\n\\t\\t\\tmap<int,vector<int>>mp;\\n\\t\\t\\tfor(int i=0;i<size(nums);i++){\\n\\t\\t\\t\\tint sum = 0,num = nums[i];\\n\\t\\t\\t\\twhile(num){\\n\\t\\t\\t\\t\\tsum+=(num%10);\\n\\t\\t\\t\\t\\tnum/=10;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmp[sum].push_back(nums[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint res = -1;\\n\\t\\t\\tfor(auto [key,val]:mp){\\n\\t\\t\\t\\tif(val.size()>1) {\\n\\t\\t\\t\\t   sort(begin(val),end(val),greater<int>());\\n\\t\\t\\t\\t\\tres = max(res,val[0]+val[1]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maximumSum(vector<int>& nums) {\\n\\t\\t\\tmap<int,vector<int>>mp;\\n\\t\\t\\tfor(int i=0;i<size(nums);i++){\\n\\t\\t\\t\\tint sum = 0,num = nums[i];\\n\\t\\t\\t\\twhile(num){\\n\\t\\t\\t\\t\\tsum+=(num%10);\\n\\t\\t\\t\\t\\tnum/=10;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2292610,
                "title": "visualized-solution-with-explanation-bucket-sorting",
                "content": "**Upvote if it\\'s helpful :)**\\n\\n![image](https://assets.leetcode.com/users/images/76cc20af-4ce6-4bd0-9e60-ea7878ef17e7_1658030475.042042.png)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int, vector<int>> buckets;\\n    \\n    int maximumSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(auto i : nums) {\\n            string cur = to_string(i);\\n            int sumDigits = 0;\\n            for(auto j : cur) {\\n                sumDigits += (j-\\'0\\'); \\n            }\\n            buckets[sumDigits].push_back(i);\\n        }\\n        \\n        int mx = INT_MIN;\\n        for(auto i = buckets.begin(); i != buckets.end(); i++) {\\n            int n = i->second.size();\\n            if(n >= 2) {\\n                mx = max(mx, (i->second[n-1])+(i->second[n-2]));\\n            }   \\n        }\\n        \\n        return (mx == INT_MIN) ? -1 : mx;\\n    }\\n};\\n```\\n\\n**Update: If you don\\'t know why I\\'m sorting the array, you can check this example:**\\n![image](https://assets.leetcode.com/users/images/71aceb9c-688f-4fa6-954a-6d821a398399_1658066212.0493336.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bucket Sort"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int, vector<int>> buckets;\\n    \\n    int maximumSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        for(auto i : nums) {\\n            string cur = to_string(i);\\n            int sumDigits = 0;\\n            for(auto j : cur) {\\n                sumDigits += (j-\\'0\\'); \\n            }\\n            buckets[sumDigits].push_back(i);\\n        }\\n        \\n        int mx = INT_MIN;\\n        for(auto i = buckets.begin(); i != buckets.end(); i++) {\\n            int n = i->second.size();\\n            if(n >= 2) {\\n                mx = max(mx, (i->second[n-1])+(i->second[n-2]));\\n            }   \\n        }\\n        \\n        return (mx == INT_MIN) ? -1 : mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040184,
                "title": "simple-c-solution-only-map-o-n",
                "content": "# Intuition\\nWe only need the 2 maximum elements for a particular sum\\n\\n# Approach\\n Create a map to store the curr maximum number for that sum\\n\\n# Complexity\\n- Time complexity:\\n  O(N)\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int num_sum(int x){\\n        int ans=0;\\n        while(x){\\n            ans+=x%10;\\n            x/=10;\\n        }\\n        return ans;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,int> mp;// sum, number\\n        int ans=-1;\\n        for(int i=0;i<nums.size();i++){\\n            int sum=num_sum(nums[i]);\\n            if(mp.find(sum)!=mp.end()){\\n                ans=max(ans,nums[i]+mp[sum]);\\n                mp[sum]=max(mp[sum],nums[i]);\\n            }else mp[sum]=nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int num_sum(int x){\\n        int ans=0;\\n        while(x){\\n            ans+=x%10;\\n            x/=10;\\n        }\\n        return ans;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,int> mp;// sum, number\\n        int ans=-1;\\n        for(int i=0;i<nums.size();i++){\\n            int sum=num_sum(nums[i]);\\n            if(mp.find(sum)!=mp.end()){\\n                ans=max(ans,nums[i]+mp[sum]);\\n                mp[sum]=max(mp[sum],nums[i]);\\n            }else mp[sum]=nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3617652,
                "title": "simple-readable-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        a = [[sum([int(x) for x in str(nums[i])]), nums[i]] for i in range(len(nums))]\\n        mx = 0\\n        b = [a[i][0] for i in range(len(a))]\\n        if len(b) == len(set(b)): return -1\\n\\n        d = defaultdict(list)\\n        for i in range(len(a)):\\n            d[a[i][0]].append(a[i][1])\\n\\n        c = list(d.values())\\n        for ar in c:\\n            if len(ar) >= 2:\\n                mx = max(sorted(ar)[-1]+sorted(ar)[-2], mx)\\n        return mx\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        a = [[sum([int(x) for x in str(nums[i])]), nums[i]] for i in range(len(nums))]\\n        mx = 0\\n        b = [a[i][0] for i in range(len(a))]\\n        if len(b) == len(set(b)): return -1\\n\\n        d = defaultdict(list)\\n        for i in range(len(a)):\\n            d[a[i][0]].append(a[i][1])\\n\\n        c = list(d.values())\\n        for ar in c:\\n            if len(ar) >= 2:\\n                mx = max(sorted(ar)[-1]+sorted(ar)[-2], mx)\\n        return mx\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545438,
                "title": "c-map-multiset-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        int ans = 0;\\n        map<int,multiset<int>> m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int tmp = nums[i];\\n            int sum = 0;\\n            while(tmp)\\n            {\\n                sum+=tmp%10;\\n                tmp/=10;\\n            }\\n            m[sum].insert(nums[i]);\\n        }\\n        for(auto &i:m)\\n        {\\n            if(i.second.size()>1)\\n            {\\n                auto it = i.second.end();\\n                it--;\\n                int sum = *it;\\n                it--;\\n                sum+=*it;\\n                ans = max(ans,sum);\\n            }\\n        }\\n        if(ans==0)\\n        return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        int ans = 0;\\n        map<int,multiset<int>> m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int tmp = nums[i];\\n            int sum = 0;\\n            while(tmp)\\n            {\\n                sum+=tmp%10;\\n                tmp/=10;\\n            }\\n            m[sum].insert(nums[i]);\\n        }\\n        for(auto &i:m)\\n        {\\n            if(i.second.size()>1)\\n            {\\n                auto it = i.second.end();\\n                it--;\\n                int sum = *it;\\n                it--;\\n                sum+=*it;\\n                ans = max(ans,sum);\\n            }\\n        }\\n        if(ans==0)\\n        return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394330,
                "title": "c-cakewalk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMAX HEAP + PAIR\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Define a helper function solve that takes an integer and returns the sum of its digits.\\n\\n- Create a priority queue \\'pq\\' of pairs of integers. The first element of the pair is the sum of digits of the integer, and the second element is the integer itself. This priority queue will be used to group the integers by their sum of digits.\\n\\n- Loop over the integers in the input vector nums, and for each integer, compute its sum of digits using the solve function, and push a pair of the sum of digits and the integer into the priority queue pq.\\n\\n- While the size of the priority queue pq is greater than or equal to 2, extract the two pairs with the highest sum of digits. If the sum of digits of the two pairs are equal, update the value of maxRes to the maximum between the sum of the integers in the pairs and the current value of maxRes. Otherwise, push the second pair back into the priority queue.\\n\\n# Complexity\\n- Time complexity: O(n logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(int x)\\n    {\\n        int number = 0;\\n\\n        while(x > 0)\\n        {\\n            int rem = x % 10;\\n            number += rem;\\n            x /= 10;\\n        }\\n\\n        return number;\\n    }\\n\\n    int maximumSum(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        priority_queue <pair <int, int>> pq;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            int split = solve(nums[i]);\\n            pq.push({split, nums[i]});\\n        }\\n\\n        int maxRes = -1;\\n        while(pq.size() >= 2)\\n        {\\n            int a = pq.top().first;\\n            int b = pq.top().second;\\n            pq.pop();\\n\\n            int c = pq.top().first;\\n            int d = pq.top().second;\\n            pq.pop();\\n\\n            if(a == c)\\n                maxRes = max(maxRes, b + d);\\n            else\\n                pq.push({c, d});    \\n        }   \\n\\n        return maxRes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(int x)\\n    {\\n        int number = 0;\\n\\n        while(x > 0)\\n        {\\n            int rem = x % 10;\\n            number += rem;\\n            x /= 10;\\n        }\\n\\n        return number;\\n    }\\n\\n    int maximumSum(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        priority_queue <pair <int, int>> pq;\\n\\n        for(int i = 0; i < n; i++)\\n        {\\n            int split = solve(nums[i]);\\n            pq.push({split, nums[i]});\\n        }\\n\\n        int maxRes = -1;\\n        while(pq.size() >= 2)\\n        {\\n            int a = pq.top().first;\\n            int b = pq.top().second;\\n            pq.pop();\\n\\n            int c = pq.top().first;\\n            int d = pq.top().second;\\n            pq.pop();\\n\\n            if(a == c)\\n                maxRes = max(maxRes, b + d);\\n            else\\n                pq.push({c, d});    \\n        }   \\n\\n        return maxRes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357001,
                "title": "java-clean-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int nsum;\\n        int ans = -1;\\n        for(int i : nums){\\n            nsum = nsum(i);\\n            if(!map.containsKey(nsum)){\\n                map.put(nsum, i);\\n            }else{\\n                ans = Math.max(ans, map.get(nsum) + i );\\n                map.put(nsum, Math.max(map.get(nsum), i));\\n            }\\n        }\\n            return ans;\\n    }\\n    public int nsum(int n){\\n        int sum =0;\\n        while(n != 0){\\n        sum += n % 10;\\n        n = n / 10; \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int nsum;\\n        int ans = -1;\\n        for(int i : nums){\\n            nsum = nsum(i);\\n            if(!map.containsKey(nsum)){\\n                map.put(nsum, i);\\n            }else{\\n                ans = Math.max(ans, map.get(nsum) + i );\\n                map.put(nsum, Math.max(map.get(nsum), i));\\n            }\\n        }\\n            return ans;\\n    }\\n    public int nsum(int n){\\n        int sum =0;\\n        while(n != 0){\\n        sum += n % 10;\\n        n = n / 10; \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231590,
                "title": "c-and-python-most-efficient-solution-clear-concise-heap-priority-queue-sorting",
                "content": "\\n\\n# Code\\n**C++ Solution using Priority Queue (Heap)**\\n```\\nclass Solution {\\npublic:\\n    int digitSum(int num) {\\n        int sum = 0;\\n        while (num>0) {\\n            sum += (num % 10);\\n            num /= 10;\\n        }\\n        return sum;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n       map<int,priority_queue<int>> hashmap;\\n       int ans = -1;\\n       for (auto &num:nums) hashmap[digitSum(num)].push(num);\\n       for (auto &val:hashmap) {\\n           if (val.second.size() > 1) {\\n               int fir = val.second.top();\\n               val.second.pop();\\n               int sec = val.second.top();\\n               ans = max(ans, fir+sec);\\n           }\\n       }\\n       return ans; \\n    }\\n};\\n```\\n**Python Solution using Sorting**\\n```\\nclass Solution:\\n    def maximumSum(self, arr: List[int]) -> int:\\n        hashmap = defaultdict(list)\\n        for n in arr:\\n            digit_sum = 0\\n            num = n\\n            while num:\\n                digit_sum += num % 10\\n                num //= 10\\n            hashmap[digit_sum].append(n)\\n\\n        ans = -1\\n        for v in hashmap.values():\\n            if len(v) > 1:\\n                v = sorted(v,reverse=True)\\n                ans = max(ans, v[0] + v[1])\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digitSum(int num) {\\n        int sum = 0;\\n        while (num>0) {\\n            sum += (num % 10);\\n            num /= 10;\\n        }\\n        return sum;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n       map<int,priority_queue<int>> hashmap;\\n       int ans = -1;\\n       for (auto &num:nums) hashmap[digitSum(num)].push(num);\\n       for (auto &val:hashmap) {\\n           if (val.second.size() > 1) {\\n               int fir = val.second.top();\\n               val.second.pop();\\n               int sec = val.second.top();\\n               ans = max(ans, fir+sec);\\n           }\\n       }\\n       return ans; \\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maximumSum(self, arr: List[int]) -> int:\\n        hashmap = defaultdict(list)\\n        for n in arr:\\n            digit_sum = 0\\n            num = n\\n            while num:\\n                digit_sum += num % 10\\n                num //= 10\\n            hashmap[digit_sum].append(n)\\n\\n        ans = -1\\n        for v in hashmap.values():\\n            if len(v) > 1:\\n                v = sorted(v,reverse=True)\\n                ans = max(ans, v[0] + v[1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219362,
                "title": "crisp-n-clear-o-n-javascript-memory-94-72-meaningful-vars",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n```\\nvar maximumSum = function(nums) {\\n\\tconst digitSumConfig = {};\\n\\tlet maxNumber = -1;\\n\\tfor (const iterator of nums) {\\n\\t\\tconst countDigits = (function() {\\n\\t\\t\\tconst stringIterator = String(iterator);\\n\\t\\t\\tlet sum = 0;\\n\\t\\t\\tfor (let index = 0; index < stringIterator.length; index++) {\\n\\t\\t\\t\\tsum += Number(stringIterator[index]);\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t})();\\n\\t\\tif (!digitSumConfig[countDigits]) {\\n\\t\\t\\tdigitSumConfig[countDigits] = {\\n\\t\\t\\t\\tlastMax: iterator,\\n\\t\\t\\t\\ttotalNumber: 1,\\n\\t\\t\\t\\tmaxNumber: iterator\\n\\t\\t\\t};\\n\\t\\t} else {\\n\\t\\t\\tconst lastMax = digitSumConfig[countDigits].lastMax;\\n\\t\\t\\tif (digitSumConfig[countDigits].totalNumber === 1) {\\n\\t\\t\\t\\tdigitSumConfig[countDigits].totalNumber = 2;\\n\\t\\t\\t\\tdigitSumConfig[countDigits].maxNumber += iterator;\\n\\n\\t\\t\\t\\tif (lastMax < iterator) {\\n\\t\\t\\t\\t\\tdigitSumConfig[countDigits].lastMax = iterator;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (digitSumConfig[countDigits].maxNumber > maxNumber) {\\n\\t\\t\\t\\t\\tmaxNumber = digitSumConfig[countDigits].maxNumber;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (iterator > lastMax) {\\n\\t\\t\\t\\t\\tdigitSumConfig[countDigits].lastMax = iterator;\\n\\t\\t\\t\\t\\tdigitSumConfig[countDigits].maxNumber = lastMax + iterator;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tconst anotherNumber = digitSumConfig[countDigits].maxNumber - lastMax;\\n\\t\\t\\t\\t\\tif (anotherNumber < iterator) {\\n\\t\\t\\t\\t\\t\\tdigitSumConfig[countDigits].maxNumber = lastMax + iterator;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (digitSumConfig[countDigits].maxNumber > maxNumber) {\\n\\t\\t\\t\\t\\tmaxNumber = digitSumConfig[countDigits].maxNumber;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn maxNumber;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumSum = function(nums) {\\n\\tconst digitSumConfig = {};\\n\\tlet maxNumber = -1;\\n\\tfor (const iterator of nums) {\\n\\t\\tconst countDigits = (function() {\\n\\t\\t\\tconst stringIterator = String(iterator);\\n\\t\\t\\tlet sum = 0;\\n\\t\\t\\tfor (let index = 0; index < stringIterator.length; index++) {\\n\\t\\t\\t\\tsum += Number(stringIterator[index]);\\n\\t\\t\\t}\\n\\t\\t\\treturn sum;\\n\\t\\t})();\\n\\t\\tif (!digitSumConfig[countDigits]) {\\n\\t\\t\\tdigitSumConfig[countDigits] = {\\n\\t\\t\\t\\tlastMax: iterator,\\n\\t\\t\\t\\ttotalNumber: 1,\\n\\t\\t\\t\\tmaxNumber: iterator\\n\\t\\t\\t};\\n\\t\\t} else {\\n\\t\\t\\tconst lastMax = digitSumConfig[countDigits].lastMax;\\n\\t\\t\\tif (digitSumConfig[countDigits].totalNumber === 1) {\\n\\t\\t\\t\\tdigitSumConfig[countDigits].totalNumber = 2;\\n\\t\\t\\t\\tdigitSumConfig[countDigits].maxNumber += iterator;\\n\\n\\t\\t\\t\\tif (lastMax < iterator) {\\n\\t\\t\\t\\t\\tdigitSumConfig[countDigits].lastMax = iterator;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (digitSumConfig[countDigits].maxNumber > maxNumber) {\\n\\t\\t\\t\\t\\tmaxNumber = digitSumConfig[countDigits].maxNumber;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (iterator > lastMax) {\\n\\t\\t\\t\\t\\tdigitSumConfig[countDigits].lastMax = iterator;\\n\\t\\t\\t\\t\\tdigitSumConfig[countDigits].maxNumber = lastMax + iterator;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tconst anotherNumber = digitSumConfig[countDigits].maxNumber - lastMax;\\n\\t\\t\\t\\t\\tif (anotherNumber < iterator) {\\n\\t\\t\\t\\t\\t\\tdigitSumConfig[countDigits].maxNumber = lastMax + iterator;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (digitSumConfig[countDigits].maxNumber > maxNumber) {\\n\\t\\t\\t\\t\\tmaxNumber = digitSumConfig[countDigits].maxNumber;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn maxNumber;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2999759,
                "title": "easy-c-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sumd(int n)\\n    {\\n        int ans=0;\\n        while(n>0)\\n        {\\n            ans+=n%10;\\n            n/=10;\\n\\n        }\\n        return ans;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n          \\n          sort(nums.begin(),nums.end());\\n          unordered_map<int,int>m;\\n          int ans=-1;\\n          for(int i=0;i<nums.size();i++)\\n          {\\n              //int t=sumd(nums[i]);\\n              if(m.find(sumd(nums[i]))!=m.end())\\n              {\\n                  ans=max(ans,nums[i]+m[sumd(nums[i])]);\\n                  m.erase(sumd(nums[i]));\\n\\n              }\\n              m[sumd(nums[i])]=nums[i];\\n          }\\n          return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumd(int n)\\n    {\\n        int ans=0;\\n        while(n>0)\\n        {\\n            ans+=n%10;\\n            n/=10;\\n\\n        }\\n        return ans;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n          \\n          sort(nums.begin(),nums.end());\\n          unordered_map<int,int>m;\\n          int ans=-1;\\n          for(int i=0;i<nums.size();i++)\\n          {\\n              //int t=sumd(nums[i]);\\n              if(m.find(sumd(nums[i]))!=m.end())\\n              {\\n                  ans=max(ans,nums[i]+m[sumd(nums[i])]);\\n                  m.erase(sumd(nums[i]));\\n\\n              }\\n              m[sumd(nums[i])]=nums[i];\\n          }\\n          return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816869,
                "title": "easiest-solution-c-plus-plus-unordered-map-with-pairs-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,vector<pair<int,int>>> mp;\\n        for(int i=0;i<nums.size();i++){\\n            string s = to_string(nums[i]);\\n            int a = 0;\\n            for(int j=0;j<s.length();j++) a+=s[j]-\\'0\\';\\n            mp[a].push_back({nums[i],i});\\n        }\\n        // for(auto i:mp){\\n        //     cout<<i.first<<\" \";\\n        // }\\n        int maxi = INT_MIN;\\n        for(auto i:mp){\\n            sort(i.second.begin(),i.second.end());\\n            if(i.second.size()>1) maxi=max(maxi,i.second[i.second.size()-1].first + i.second[i.second.size()-2].first);\\n        }\\n        return maxi!=INT_MIN?maxi:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,vector<pair<int,int>>> mp;\\n        for(int i=0;i<nums.size();i++){\\n            string s = to_string(nums[i]);\\n            int a = 0;\\n            for(int j=0;j<s.length();j++) a+=s[j]-\\'0\\';\\n            mp[a].push_back({nums[i],i});\\n        }\\n        // for(auto i:mp){\\n        //     cout<<i.first<<\" \";\\n        // }\\n        int maxi = INT_MIN;\\n        for(auto i:mp){\\n            sort(i.second.begin(),i.second.end());\\n            if(i.second.size()>1) maxi=max(maxi,i.second[i.second.size()-1].first + i.second[i.second.size()-2].first);\\n        }\\n        return maxi!=INT_MIN?maxi:-1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2769379,
                "title": "o-n-length-of-number-c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int sumofdigit(int n)\\n    {\\n        int sum = 0;\\n        while (n != 0) {\\n            sum = sum + n % 10;\\n            n = n / 10;\\n        }\\n        return sum;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxvalue=-1;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=sumofdigit(nums[i]);\\n            if(mp.find(sum)!=mp.end())\\n            {\\n                maxvalue=max(maxvalue,(nums[i]+mp[sum]));\\n                mp[sum]=max(mp[sum],nums[i]);\\n            }\\n            else{\\n                mp[sum]=nums[i];\\n            }\\n        }\\n        return maxvalue;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumofdigit(int n)\\n    {\\n        int sum = 0;\\n        while (n != 0) {\\n            sum = sum + n % 10;\\n            n = n / 10;\\n        }\\n        return sum;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxvalue=-1;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=sumofdigit(nums[i]);\\n            if(mp.find(sum)!=mp.end())\\n            {\\n                maxvalue=max(maxvalue,(nums[i]+mp[sum]));\\n                mp[sum]=max(mp[sum],nums[i]);\\n            }\\n            else{\\n                mp[sum]=nums[i];\\n            }\\n        }\\n        return maxvalue;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732835,
                "title": "c-brute-force-sum-of-digits-map-of-vectors",
                "content": "```\\nint digSum(int n) {\\n        //Calculates sum of digits\\n        int ans = 0;\\n        while(n) {\\n            ans += n%10;\\n            n/=10;\\n        }\\n        return ans;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        //A map of vector to store all possibilities on digSum\\n        //Vector to store values if same digiSum\\n        map<int,vector<int>> m;\\n        int n = nums.size(), ans = -1;\\n        for(int i=0;i<n;i++)  m[digSum(nums[i])].push_back(nums[i]);\\n        \\n        //Sorting each digiSum index to get max 2 values\\n        for(auto i:m){\\n            int x = i.first;\\n            sort(m[x].begin(),m[x].end());\\n        }\\n        for(auto i:m) {\\n            int x = i.first;\\n            //Check for presence of atleast 2 elements\\n            if(m[x].size()>1) {\\n                int curr = m[x][m[x].size()-1] + m[x][m[x].size()-2];\\n                ans = max(ans,curr);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint digSum(int n) {\\n        //Calculates sum of digits\\n        int ans = 0;\\n        while(n) {\\n            ans += n%10;\\n            n/=10;\\n        }\\n        return ans;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        //A map of vector to store all possibilities on digSum\\n        //Vector to store values if same digiSum\\n        map<int,vector<int>> m;\\n        int n = nums.size(), ans = -1;\\n        for(int i=0;i<n;i++)  m[digSum(nums[i])].push_back(nums[i]);\\n        \\n        //Sorting each digiSum index to get max 2 values\\n        for(auto i:m){\\n            int x = i.first;\\n            sort(m[x].begin(),m[x].end());\\n        }\\n        for(auto i:m) {\\n            int x = i.first;\\n            //Check for presence of atleast 2 elements\\n            if(m[x].size()>1) {\\n                int curr = m[x][m[x].size()-1] + m[x][m[x].size()-2];\\n                ans = max(ans,curr);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2601357,
                "title": "java-hashmap-math-simple-solution",
                "content": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int max = -1;\\n        for(int i=0;i<nums.length;i++){\\n            int num = nums[i];\\n            int sum=0;\\n            while(num>0){\\n                int r = num%10;\\n                sum=sum+r;\\n                num=num/10;\\n            }\\n            if(map.containsKey(sum)){\\n                int s = map.get(sum);\\n                if(s+nums[i]>max)\\n                    max=s+nums[i];\\n                if(nums[i]>s)\\n                    map.replace(sum,nums[i]);\\n            }\\n            else\\n                map.put(sum,nums[i]);\\n        }\\n        return max;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int max = -1;\\n        for(int i=0;i<nums.length;i++){\\n            int num = nums[i];\\n            int sum=0;\\n            while(num>0){\\n                int r = num%10;\\n                sum=sum+r;\\n                num=num/10;\\n            }\\n            if(map.containsKey(sum)){\\n                int s = map.get(sum);\\n                if(s+nums[i]>max)\\n                    max=s+nums[i];\\n                if(nums[i]>s)\\n                    map.replace(sum,nums[i]);\\n            }\\n            else\\n                map.put(sum,nums[i]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587028,
                "title": "c-easy-to-understand-85-faster-than-all",
                "content": "```\\nclass Solution {\\npublic:\\n    int digits(int n){\\n        int ans = 0;\\n        while(n){\\n            ans += n%10;\\n            n /= 10;\\n        }\\n        return ans;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        // max sum of digits can be 81\\n\\t\\tint m[82];\\n\\t\\t// initially we don\\'t have any number for sum of digits\\n        memset(m, -1, sizeof(m));\\n        int mx = -1;\\n        for(auto i:nums){\\n\\t\\t\\t// convert to sum of digits\\n            int x = digits(i);\\n\\t\\t\\t// if we already have a number for x\\n            if(m[x] != -1) mx = max(mx,i+m[x]);\\n\\t\\t\\t// update max value for x\\n            m[x] = max(m[x],i);\\n        }\\n        return mx;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int digits(int n){\\n        int ans = 0;\\n        while(n){\\n            ans += n%10;\\n            n /= 10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2452567,
                "title": "map-and-priority",
                "content": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        Map<Integer, Queue>map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n                Queue<Integer>pq = new PriorityQueue<>((a,b)->(b-a));\\n                pq.offer(nums[i]);\\n                Queue<Integer>q = map.get(sum(nums[i]));\\n                if(q==null){\\n                    map.put(sum(nums[i]), pq);\\n                }else{\\n                    q.offer(nums[i]);\\n                    map.put(sum(nums[i]), q);\\n                }\\n            }\\n        int max =-1;\\n        for(Map.Entry<Integer, Queue>m:map.entrySet()){\\n            Queue<Integer>temp = m.getValue();\\n            if(temp.size()>1){\\n                max = Math.max(max, temp.poll()+temp.poll());\\n            }\\n        }\\n        \\n        return max;  \\n       }\\n     \\n    public int sum(int n){\\n        int sum=0;\\n        while(n!=0){\\n            int p = n%10;\\n            sum=sum+p;\\n            n=n/10;\\n        }\\n        return sum;\\n    }\\n}\\n   \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        Map<Integer, Queue>map = new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n                Queue<Integer>pq = new PriorityQueue<>((a,b)->(b-a));\\n                pq.offer(nums[i]);\\n                Queue<Integer>q = map.get(sum(nums[i]));\\n                if(q==null){\\n                    map.put(sum(nums[i]), pq);\\n                }else{\\n                    q.offer(nums[i]);\\n                    map.put(sum(nums[i]), q);\\n                }\\n            }\\n        int max =-1;\\n        for(Map.Entry<Integer, Queue>m:map.entrySet()){\\n            Queue<Integer>temp = m.getValue();\\n            if(temp.size()>1){\\n                max = Math.max(max, temp.poll()+temp.poll());\\n            }\\n        }\\n        \\n        return max;  \\n       }\\n     \\n    public int sum(int n){\\n        int sum=0;\\n        while(n!=0){\\n            int p = n%10;\\n            sum=sum+p;\\n            n=n/10;\\n        }\\n        return sum;\\n    }\\n}\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2350197,
                "title": "3-simple-c-solution",
                "content": "![image](https://assets.leetcode.com/users/images/429ed183-cbad-46ea-b1f8-e9fb89d4114c_1659092092.056455.png)\\n\\n\\n**1. Usnig Map ans Sort**\\n```\\nclass Solution {\\n    int sumDigit(int n){\\n        int tmp=0;\\n        while(n > 0){\\n            tmp += n%10;\\n            n /= 10;\\n        }\\n        return tmp;\\n    }\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map <int,vector <int> > ump;\\n        int ans=-1;\\n        for(int i=0;i<nums.size();i++)\\n            ump[sumDigit(nums[i])].push_back(nums[i]);\\n        for(auto it:ump){\\n            auto jt = it.second;\\n            if(jt.size() > 1){\\n                sort(jt.begin(),jt.end());\\n                ans = max(ans,jt[jt.size()-1]+jt[jt.size()-2]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**2. Using Map and Priority queue**\\n```\\nclass Solution {\\n    int sumDigit(int n){\\n        int tmp=0;\\n        while(n > 0){\\n            tmp += n%10;\\n            n /= 10;\\n        }\\n        return tmp;\\n    }\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map <int,priority_queue <int> > ump;\\n        int ans=-1,tmp;\\n        for(int i=0;i<nums.size();i++)\\n            ump[sumDigit(nums[i])].push(nums[i]);\\n        for(auto it:ump){\\n            auto pq = it.second;\\n            if(pq.size() > 1){\\n                tmp = pq.top();\\n                pq.pop();\\n                tmp += pq.top();\\n                ans = max(ans,tmp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**3. Otimizing space for priority queue**\\n```\\nclass Solution {\\n    int sumDigit(int n){\\n        int tmp=0;\\n        while(n > 0){\\n            tmp += n%10;\\n            n /= 10;\\n        }\\n        return tmp;\\n    }\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map <int,priority_queue <int,vector <int>,greater <int>>> ump;\\n        int ans=-1,tmp,k;\\n        for(int i=0;i<nums.size();i++){\\n            k=sumDigit(nums[i]); \\n            ump[k].push(nums[i]);\\n            if(ump[k].size() > 2)\\n                ump[k].pop();\\n        }\\n        for(auto it:ump){\\n            auto pq = it.second;\\n            if(pq.size() > 1){\\n                tmp = pq.top();\\n                pq.pop();\\n                tmp += pq.top();\\n                ans = max(ans,tmp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    int sumDigit(int n){\\n        int tmp=0;\\n        while(n > 0){\\n            tmp += n%10;\\n            n /= 10;\\n        }\\n        return tmp;\\n    }\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map <int,vector <int> > ump;\\n        int ans=-1;\\n        for(int i=0;i<nums.size();i++)\\n            ump[sumDigit(nums[i])].push_back(nums[i]);\\n        for(auto it:ump){\\n            auto jt = it.second;\\n            if(jt.size() > 1){\\n                sort(jt.begin(),jt.end());\\n                ans = max(ans,jt[jt.size()-1]+jt[jt.size()-2]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int sumDigit(int n){\\n        int tmp=0;\\n        while(n > 0){\\n            tmp += n%10;\\n            n /= 10;\\n        }\\n        return tmp;\\n    }\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map <int,priority_queue <int> > ump;\\n        int ans=-1,tmp;\\n        for(int i=0;i<nums.size();i++)\\n            ump[sumDigit(nums[i])].push(nums[i]);\\n        for(auto it:ump){\\n            auto pq = it.second;\\n            if(pq.size() > 1){\\n                tmp = pq.top();\\n                pq.pop();\\n                tmp += pq.top();\\n                ans = max(ans,tmp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int sumDigit(int n){\\n        int tmp=0;\\n        while(n > 0){\\n            tmp += n%10;\\n            n /= 10;\\n        }\\n        return tmp;\\n    }\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map <int,priority_queue <int,vector <int>,greater <int>>> ump;\\n        int ans=-1,tmp,k;\\n        for(int i=0;i<nums.size();i++){\\n            k=sumDigit(nums[i]); \\n            ump[k].push(nums[i]);\\n            if(ump[k].size() > 2)\\n                ump[k].pop();\\n        }\\n        for(auto it:ump){\\n            auto pq = it.second;\\n            if(pq.size() > 1){\\n                tmp = pq.top();\\n                pq.pop();\\n                tmp += pq.top();\\n                ans = max(ans,tmp);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337552,
                "title": "hashmap-priority-queue-c",
                "content": "```\\nclass Solution {\\n    int SumOfDigits(int n) {\\n        int sum = 0;\\n        while(n) sum += n % 10, n /= 10;\\n        return sum;\\n    }\\n    \\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> m;\\n        for(int i : nums) {\\n            int sod = SumOfDigits(i);\\n            m[sod].push(i);\\n            if(m[sod].size() > 2) m[sod].pop();\\n        }\\n        \\n        int ans = -1;\\n        for(auto i : m) {\\n            if(i.second.size() < 2) continue;\\n            int a = i.second.top(); i.second.pop();\\n            int b = i.second.top(); i.second.pop();\\n            ans = max(ans, a + b);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    int SumOfDigits(int n) {\\n        int sum = 0;\\n        while(n) sum += n % 10, n /= 10;\\n        return sum;\\n    }\\n    \\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> m;\\n        for(int i : nums) {\\n            int sod = SumOfDigits(i);\\n            m[sod].push(i);\\n            if(m[sod].size() > 2) m[sod].pop();\\n        }\\n        \\n        int ans = -1;\\n        for(auto i : m) {\\n            if(i.second.size() < 2) continue;\\n            int a = i.second.top(); i.second.pop();\\n            int b = i.second.top(); i.second.pop();\\n            ans = max(ans, a + b);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2332218,
                "title": "python3-heap-keep-track-of-max",
                "content": "you only have to keep track of the maximum value for every number who\\'s digits sum up to a specific number. \\n\\nDeclare a hashmap perform heappush on the corresponding sumOfDigits that way you always have the max number for each sumOfDigits.\\nPython dosen\\'t have a maxHeap so push the negative one of each value (you can do this since the array only consists on positive integers).\\n\\n```\\n\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        res = -1\\n        lookup = collections.defaultdict(list)\\n        for num in nums:\\n            curSumDigits = self.getSumDigits(num)\\n            if curSumDigits in lookup:\\n                res = max(res, num + lookup[curSumDigits][0] * -1)\\n            heapq.heappush(lookup[curSumDigits], num*-1)\\n        return res\\n        \\n    def getSumDigits(self, number: int):\\n        sumDigits = 0\\n        for char in str(number):\\n            sumDigits += int(char)\\n        return sumDigits\\n\\t\\t\\n```\\n\\nYou can optimize this solution even further by removing the need for the heap entireley, since you just need to keep track of the max for each curSumDigt\\n\\n```\\n\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        res = -1\\n        lookup = collections.defaultdict(int)\\n        for num in nums:\\n            curSumDigits = self.getSumDigits(num)\\n            if curSumDigits in lookup:\\n                res = max(res, num + lookup[curSumDigits])\\n            lookup[curSumDigits] = max(num, lookup[curSumDigits])\\n        return res\\n        \\n    def getSumDigits(self, number: int):\\n        sumDigits = 0\\n        for char in str(number):\\n            sumDigits += int(char)\\n        return sumDigits\\n\\n```\\n\\n\\nExtra Test Cases\\n\\n```\\n\\n[18,43,36,13,7]\\n[10,12,19,14]\\n[3]\\n[15, 9, 7, 1, 12, 12, 13]\\n[4, 12, 18, 13, 19]\\n[1, 5, 17, 1, 11, 10]\\n[15]\\n[6, 2]\\n[6, 19, 6, 3, 12, 14, 11, 5, 4, 3]\\n[19, 1, 17, 5, 12, 19]\\n[19, 9, 5, 5]\\n[17, 11, 3, 5]\\n[13, 6, 8, 15, 18, 12, 7, 4, 4, 14]\\n[6, 11, 16, 8, 10, 16, 19, 5, 11, 3]\\n[12, 17, 10, 9, 3, 6, 16, 2]\\n[6, 4, 17, 1, 4, 11, 3, 8, 1, 7]\\n[16, 17]\\n[9, 17, 10, 14, 11, 18, 9]\\n[7, 13, 2]\\n[10, 18, 3, 1, 5]\\n[9, 2, 17, 15, 14, 10, 1, 10, 5, 19]\\n[15, 13, 10]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        res = -1\\n        lookup = collections.defaultdict(list)\\n        for num in nums:\\n            curSumDigits = self.getSumDigits(num)\\n            if curSumDigits in lookup:\\n                res = max(res, num + lookup[curSumDigits][0] * -1)\\n            heapq.heappush(lookup[curSumDigits], num*-1)\\n        return res\\n        \\n    def getSumDigits(self, number: int):\\n        sumDigits = 0\\n        for char in str(number):\\n            sumDigits += int(char)\\n        return sumDigits\\n\\t\\t\\n```\n```\\n\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        res = -1\\n        lookup = collections.defaultdict(int)\\n        for num in nums:\\n            curSumDigits = self.getSumDigits(num)\\n            if curSumDigits in lookup:\\n                res = max(res, num + lookup[curSumDigits])\\n            lookup[curSumDigits] = max(num, lookup[curSumDigits])\\n        return res\\n        \\n    def getSumDigits(self, number: int):\\n        sumDigits = 0\\n        for char in str(number):\\n            sumDigits += int(char)\\n        return sumDigits\\n\\n```\n```\\n\\n[18,43,36,13,7]\\n[10,12,19,14]\\n[3]\\n[15, 9, 7, 1, 12, 12, 13]\\n[4, 12, 18, 13, 19]\\n[1, 5, 17, 1, 11, 10]\\n[15]\\n[6, 2]\\n[6, 19, 6, 3, 12, 14, 11, 5, 4, 3]\\n[19, 1, 17, 5, 12, 19]\\n[19, 9, 5, 5]\\n[17, 11, 3, 5]\\n[13, 6, 8, 15, 18, 12, 7, 4, 4, 14]\\n[6, 11, 16, 8, 10, 16, 19, 5, 11, 3]\\n[12, 17, 10, 9, 3, 6, 16, 2]\\n[6, 4, 17, 1, 4, 11, 3, 8, 1, 7]\\n[16, 17]\\n[9, 17, 10, 14, 11, 18, 9]\\n[7, 13, 2]\\n[10, 18, 3, 1, 5]\\n[9, 2, 17, 15, 14, 10, 1, 10, 5, 19]\\n[15, 13, 10]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314886,
                "title": "java-solution-faster-than-100",
                "content": "class Solution {\\n    public int maximumSum(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int ans=-1;\\n        \\n        for(int i: nums)\\n        {\\n            int temp=i;\\n            int sum=0;\\n            while(temp>0)  //Calculating the sum of  the digits\\n            {\\n                sum+=(temp%10);\\n                temp/=10;\\n            }\\n            \\n            if(map.containsKey(sum))\\n            {\\n                ans=Math.max(ans,map.get(sum)+i);\\n                \\n        //If the value associated with \\'sum\\' in the hashmap is less than the current value, then replace it with the current value....\\n                if(i>map.get(sum))\\n                    map.put(sum,i);\\n            }\\n            else\\n                map.put(sum,i);//Store the sum with respect to that particular number\\n        }\\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maximumSum(int[] nums) {\\n        \\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int ans=-1;\\n        \\n        for(int i: nums)\\n        {\\n            int temp=i;\\n            int sum=0;\\n            while(temp>0)  //Calculating the sum of  the digits\\n            {\\n                sum+=(temp%10);\\n                temp/=10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2314818,
                "title": "runtime-288-ms-faster-than-100-00-of-c-max-sum-of-a-pair-with-equal-sum-of-digits",
                "content": "class Solution {\\n  \\npublic:\\n    \\n    int digit(int val){\\n        int n=0 ;\\n        \\n        while(val){\\n            n+=(val%10);\\n            val/=10;\\n        }\\n        return n;\\n    }\\n    \\n    int maximumSum(vector<int>& nums) {\\n        \\n        sort(nums.begin() , nums.end() , greater<int>());\\n        int n = nums.size();\\n        map<int , vector<int>> mp;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            \\n            int temp = digit(nums[i]);\\n            mp[temp].push_back(nums[i]);\\n            \\n        }\\n        int maxi = -1;\\n        \\n        for(auto& it:mp){\\n            \\n            if(it.second.size()<=1) continue;\\n            else{\\n                \\n            vector<int> temp = it.second;\\n            maxi = max(maxi , temp[0] + temp[1]);\\n            cout<<maxi<<\" \"<<endl;\\n                \\n            }\\n            \\n        }\\n\\n        \\n        return maxi;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n  \\npublic:\\n    \\n    int digit(int val){\\n        int n=0 ;\\n        \\n        while(val){\\n            n+=(val%10);\\n            val/=10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2300819,
                "title": "fastest-100-solution-clean-code-o-n-avg-time-cpp",
                "content": "![image](https://assets.leetcode.com/users/images/f00d9221-aba4-472f-abfc-dd60a5b815b6_1658171299.240942.png)\\n\\n```\\nclass Solution {\\npublic:\\n    int sumdigit(int k){\\n        int sum=0;\\n        while(k>=1){\\n            sum+= k%10;\\n            k= k/10;\\n        }\\n        return sum;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,vector<int> > mp;\\n        int ans=-1;\\n        for(auto &it: nums){\\n            mp[sumdigit(it)].push_back(it);\\n        }\\n        for(auto &it: mp){\\n            if(it.second.size()==1){\\n                continue;\\n            }\\n            sort(it.second.begin(),it.second.end());\\n            ans= max(ans,it.second[it.second.size()-2]+it.second[it.second.size()-1]);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int sumdigit(int k){\\n        int sum=0;\\n        while(k>=1){\\n            sum+= k%10;\\n            k= k/10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2298609,
                "title": "python-100-faster-easy-python-solution-o-n",
                "content": "```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        def solve(num):\\n            ans=0\\n            for i in  str(num):\\n                ans+=int(i)\\n            return ans\\n        arr=[]\\n        for i in range(len(nums)):\\n            cur=solve(nums[i])\\n            arr.append([nums[i],cur])\\n        maxi=-1\\n        arr.sort(key=lambda x:(x[1],x[0]))\\n        for i in range(len(arr)-1):\\n            if arr[i][1]==arr[i+1][1]:\\n                maxi=max(maxi,arr[i][0]+arr[i+1][0])\\n        return maxi\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        def solve(num):\\n            ans=0\\n            for i in  str(num):\\n                ans+=int(i)\\n            return ans\\n        arr=[]\\n        for i in range(len(nums)):\\n            cur=solve(nums[i])\\n            arr.append([nums[i],cur])\\n        maxi=-1\\n        arr.sort(key=lambda x:(x[1],x[0]))\\n        for i in range(len(arr)-1):\\n            if arr[i][1]==arr[i+1][1]:\\n                maxi=max(maxi,arr[i][0]+arr[i+1][0])\\n        return maxi\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298012,
                "title": "c-similar-to-two-sum-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int getSum(int x){\\n        int sum = 0 ;\\n        while(x){\\n            sum += x % 10 ;\\n            x /= 10 ;\\n        }\\n        return sum ;\\n    }\\n    \\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,int> mpp ;\\n        int ans = -1 ;\\n        \\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            int sum = getSum(nums[i]) ;\\n            if(mpp.find(sum) != end(mpp)) ans = max(ans,nums[i] + nums[mpp[sum]]) ;\\n\\t\\t\\t//only update if the current number is bigger or if nothing is present for this sum\\n            if(mpp.find(sum) == end(mpp) || nums[i] > nums[mpp[sum]]) mpp[sum] = i ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getSum(int x){\\n        int sum = 0 ;\\n        while(x){\\n            sum += x % 10 ;\\n            x /= 10 ;\\n        }\\n        return sum ;\\n    }\\n    \\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,int> mpp ;\\n        int ans = -1 ;\\n        \\n        for(int i = 0 ; i < nums.size() ; ++i ){\\n            int sum = getSum(nums[i]) ;\\n            if(mpp.find(sum) != end(mpp)) ans = max(ans,nums[i] + nums[mpp[sum]]) ;\\n\\t\\t\\t//only update if the current number is bigger or if nothing is present for this sum\\n            if(mpp.find(sum) == end(mpp) || nums[i] > nums[mpp[sum]]) mpp[sum] = i ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297035,
                "title": "java-easy-solution-beats-100-with-explanation",
                "content": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        int max = -1; //result value\\n\\t\\t// key - sum of digits, value - max number with this sum of digits\\n        Map<Integer,Integer>digitSums = new HashMap<>();\\n\\n        for (int num:nums){\\n            int digits = 0;\\n\\t\\t\\t//temp variable so as not to lose num\\n            int forDigits = num;\\n            //getting sum of all digits\\n\\t\\t\\twhile (forDigits>0){\\n                digits+=forDigits%10;\\n                forDigits/=10;\\n            }\\n\\t\\t\\t\\n            if (digitSums.get(digits)==null) digitSums.put(digits, num);\\n            else {\\n\\t\\t\\t\\tmax = Math.max(digitSums.get(digits)+num, max);\\n                //we need to store only max number from array for each sum of digits\\n                digitSums.put(digits, Math.max(digitSums.get(digits),num));\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        int max = -1; //result value\\n\\t\\t// key - sum of digits, value - max number with this sum of digits\\n        Map<Integer,Integer>digitSums = new HashMap<>();\\n\\n        for (int num:nums){\\n            int digits = 0;\\n\\t\\t\\t//temp variable so as not to lose num\\n            int forDigits = num;\\n            //getting sum of all digits\\n\\t\\t\\twhile (forDigits>0){\\n                digits+=forDigits%10;\\n                forDigits/=10;\\n            }\\n\\t\\t\\t\\n            if (digitSums.get(digits)==null) digitSums.put(digits, num);\\n            else {\\n\\t\\t\\t\\tmax = Math.max(digitSums.get(digits)+num, max);\\n                //we need to store only max number from array for each sum of digits\\n                digitSums.put(digits, Math.max(digitSums.get(digits),num));\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296901,
                "title": "did-as-same-as-what-the-question-suggested",
                "content": "```\\nclass Solution {\\npublic:\\n    int summ(int val)\\n    {\\n        \\n        if(val<10)\\n            return val;\\n        \\n        int res=0;\\n        \\n        while(val)\\n        {\\n            int t = val%10;\\n            res+=t;\\n            val/=10;\\n        }\\n        // if(res>=10)\\n        //     return summ(res);\\n        return res;\\n    }\\n    \\n    \\n    int maximumSum(vector<int>& a) {\\n        \\n        unordered_map<int ,vector<int>> mp;\\n        for(auto i:a)\\n        {\\n            int val = summ(i);\\n            mp[val].push_back(i);\\n        }\\n        \\n        \\n        int mx = -1;\\n        for(auto i : mp)\\n        {\\n            if(i.second.size()>=2)\\n            {\\n                sort(i.second.begin(),i.second.end());\\n                mx = max(mx,i.second[i.second.size()-1]+ i.second[i.second.size()-2]);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int summ(int val)\\n    {\\n        \\n        if(val<10)\\n            return val;\\n        \\n        int res=0;\\n        \\n        while(val)\\n        {\\n            int t = val%10;\\n            res+=t;\\n            val/=10;\\n        }\\n        // if(res>=10)\\n        //     return summ(res);\\n        return res;\\n    }\\n    \\n    \\n    int maximumSum(vector<int>& a) {\\n        \\n        unordered_map<int ,vector<int>> mp;\\n        for(auto i:a)\\n        {\\n            int val = summ(i);\\n            mp[val].push_back(i);\\n        }\\n        \\n        \\n        int mx = -1;\\n        for(auto i : mp)\\n        {\\n            if(i.second.size()>=2)\\n            {\\n                sort(i.second.begin(),i.second.end());\\n                mx = max(mx,i.second[i.second.size()-1]+ i.second[i.second.size()-2]);\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296413,
                "title": "c-linq-query",
                "content": "We can just `GroupBy` all the items of the array by their sum of digits; then for any group that has at least two items we can find the sum of two max items. The answer is the maximum of these sums. \\n\\n```\\npublic class Solution {\\n    \\n    private static int DigitalRoot(int value) {\\n        int result = 0;\\n        \\n        for (;value > 0; value /= 10)\\n            result += value % 10;\\n        \\n        return result;\\n    }\\n    \\n    public int MaximumSum(int[] nums) => nums\\n            .GroupBy(item => DigitalRoot(item))\\n            .Where(group => group.Count() >= 2)\\n            .Select(group => group.OrderByDescending(item => item).Take(2).Sum())\\n            .DefaultIfEmpty(-1)\\n            .Max();\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    private static int DigitalRoot(int value) {\\n        int result = 0;\\n        \\n        for (;value > 0; value /= 10)\\n            result += value % 10;\\n        \\n        return result;\\n    }\\n    \\n    public int MaximumSum(int[] nums) => nums\\n            .GroupBy(item => DigitalRoot(item))\\n            .Where(group => group.Count() >= 2)\\n            .Select(group => group.OrderByDescending(item => item).Take(2).Sum())\\n            .DefaultIfEmpty(-1)\\n            .Max();\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2295583,
                "title": "java-100-faster-hashmap",
                "content": "```\\n/*\\nTo understand the code properly, dry run the code\\nin your notebook for the input:\\nnums = [18,43,36,13,7]\\n*/\\n\\nclass Solution {\\n    public int SumOfDigits (int n) {\\n        int sum = 0 ;\\n        \\n        while (n > 0) {\\n            int r = n % 10 ;\\n            sum += r ;\\n            n /= 10 ;\\n        }\\n        \\n        return sum ;\\n    }\\n    \\n\\t// Dry run from here-----\\n    public int maximumSum(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>() ;\\n        int max = -1 ;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int sum = SumOfDigits(nums[i]) ;\\n            \\n            if (map.containsKey(sum)) {\\n                max = Math.max(max, nums[i]+nums[map.get(sum)]) ;\\n                if (nums[i] > nums[map.get(sum)]) {\\n                    map.put(sum, i) ;\\n                }\\n            }\\n            else {\\n                map.put(sum, i) ;\\n            }\\n        }\\n        \\n        return max ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n/*\\nTo understand the code properly, dry run the code\\nin your notebook for the input:\\nnums = [18,43,36,13,7]\\n*/\\n\\nclass Solution {\\n    public int SumOfDigits (int n) {\\n        int sum = 0 ;\\n        \\n        while (n > 0) {\\n            int r = n % 10 ;\\n            sum += r ;\\n            n /= 10 ;\\n        }\\n        \\n        return sum ;\\n    }\\n    \\n\\t// Dry run from here-----\\n    public int maximumSum(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<>() ;\\n        int max = -1 ;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            int sum = SumOfDigits(nums[i]) ;\\n            \\n            if (map.containsKey(sum)) {\\n                max = Math.max(max, nums[i]+nums[map.get(sum)]) ;\\n                if (nums[i] > nums[map.get(sum)]) {\\n                    map.put(sum, i) ;\\n                }\\n            }\\n            else {\\n                map.put(sum, i) ;\\n            }\\n        }\\n        \\n        return max ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294931,
                "title": "map-c-priority-queue",
                "content": "````````````````````\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        map<int,priority_queue<int>>mp;\\n\\t\\t// priority queue stores in decreasing order\\n        for(int i=0;i<nums.size();i++){\\n            int temp=0;\\n            int a=nums[i];\\n            while(a>0){\\n                temp+=a%10;\\n                a/=10;\\n            }\\n\\t\\t\\t// put the elements according to their same sum\\n            mp[temp].push(nums[i]);\\n        }\\n        \\n        int ans=INT_MIN;\\n        for(auto i: mp)\\n        {\\n            auto it=i.second;\\n\\t\\t\\t// if less than 2 elements of the same sum then continue\\n            if(it.size()<2) continue;\\n            int a=it.top();\\n            it.pop();\\n            int b=it.top();\\n            ans=max(ans,a+b);\\n        }\\n        \\n        if(ans==INT_MIN) return -1;\\n        return ans;\\n    }\\n};\\n\\n// if liked pls upvote",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "``````\n``````\n``````",
                "codeTag": "Unknown"
            },
            {
                "id": 2294870,
                "title": "using-map-sorting-easy-to-understand",
                "content": "**Step 1:** Group all elements whose digits\\' sum is same (Create a `map` where key is sum of digits and value is all elements with that sum) \\n\\n**Step 2:** Iterate over `map`\\n* sort all elements of `map\\'s value`\\n* sum two greater elements and compare with answer\\n\\n**C++ Solution:**\\n```\\nint maximumSum(vector<int>& nums) {\\n \\tmap<int, vector<int>>mp;    // key = sum of digits, value=all elements with that sum\\n \\tfor(auto it: nums){\\n\\t\\t\\tint temp=it, val=0;\\n\\t\\t\\twhile(temp!=0){\\n\\t\\t\\t\\tval+=temp%10;\\n\\t\\t\\t\\ttemp/=10;\\n\\t\\t\\t}\\n\\t\\t\\tmp[val].push_back(it);    \\n\\t }\\n\\n \\tint ans=-1;\\n \\tfor(auto it:mp){\\n\\t\\t\\tsort(it.second.rbegin(), it.second.rend());     //reverse sort (descending order)\\n\\t\\t\\tif(it.second.size()>1)\\n\\t\\t\\t\\tans=max(ans, it.second[0]+it.second[1]);  //compare and updating with first two greater elements sum \\n\\t }\\n\\t return ans;\\n}\\n```\\n\\n**If you like the solution, Please Upvote!!!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maximumSum(vector<int>& nums) {\\n \\tmap<int, vector<int>>mp;    // key = sum of digits, value=all elements with that sum\\n \\tfor(auto it: nums){\\n\\t\\t\\tint temp=it, val=0;\\n\\t\\t\\twhile(temp!=0){\\n\\t\\t\\t\\tval+=temp%10;\\n\\t\\t\\t\\ttemp/=10;\\n\\t\\t\\t}\\n\\t\\t\\tmp[val].push_back(it);    \\n\\t }\\n\\n \\tint ans=-1;\\n \\tfor(auto it:mp){\\n\\t\\t\\tsort(it.second.rbegin(), it.second.rend());     //reverse sort (descending order)\\n\\t\\t\\tif(it.second.size()>1)\\n\\t\\t\\t\\tans=max(ans, it.second[0]+it.second[1]);  //compare and updating with first two greater elements sum \\n\\t }\\n\\t return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2294868,
                "title": "python3-simple-solution-faster-than-100",
                "content": "```\\nfrom bisect import insort\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        k = {}\\n        \\n        def getSum(n):\\n            return sum(list(map(int, str(n).strip())))\\n            \\n        for i in nums:\\n            x = getSum(i)\\n            if x in k:\\n                insort(k[x],i)\\n                if len(k[x]) > 2:\\n                    k[x].pop(0)\\n            else:\\n                k[x] = [i]\\n        \\n        result = float(\"-inf\")\\n        \\n        for digitSum, arr in k.items():\\n            i, n = 0, len(arr)\\n            if n == 2:\\n                result = max(result, sum(arr))\\n        \\n        return result if result != float(\"-inf\") else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom bisect import insort\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        k = {}\\n        \\n        def getSum(n):\\n            return sum(list(map(int, str(n).strip())))\\n            \\n        for i in nums:\\n            x = getSum(i)\\n            if x in k:\\n                insort(k[x],i)\\n                if len(k[x]) > 2:\\n                    k[x].pop(0)\\n            else:\\n                k[x] = [i]\\n        \\n        result = float(\"-inf\")\\n        \\n        for digitSum, arr in k.items():\\n            i, n = 0, len(arr)\\n            if n == 2:\\n                result = max(result, sum(arr))\\n        \\n        return result if result != float(\"-inf\") else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294374,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        c=-1\\n        d = {}\\n        for i in range(len(nums)):\\n                s = sum([int(a) for a in str(nums[i])])\\n                if s not in d:\\n                    d[s]=nums[i]\\n                else:\\n                    c = max(c, d[s] + nums[i])\\n                    d[s] = max(d[s], nums[i])\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        c=-1\\n        d = {}\\n        for i in range(len(nums)):\\n                s = sum([int(a) for a in str(nums[i])])\\n                if s not in d:\\n                    d[s]=nums[i]\\n                else:\\n                    c = max(c, d[s] + nums[i])\\n                    d[s] = max(d[s], nums[i])\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294173,
                "title": "many-of-us-faced-issues-with-time-complexity-in-contest-i-do-let-me-explain-this",
                "content": "# What is Time Complexity? is it O(N) or O(N*L)\\n\\n**Actually, the Question was very very easy but seeing constraints especially 10^9 we thought it will not work because we were thinking about storing sum of the digits in hashmap and literally same thing what we do in TWO SUM problem which we thought would come to O(N*L) where N is array size and L is the length of digit**\\n\\n--------------------------------------------------------------------------------------------------------\\n**Here where we made mistake actually if I say here L is just constant and the answer is only O(N)**\\n\\n**Let me explain how, see below code:**\\n\\n```\\n    int sumDigit(int v){\\n        int sum = 0;\\n        while(v){\\n            int r = v%10;\\n            sum += r;\\n            v = v/10;\\n        }\\n        return sum;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        int mx = INT_MIN;\\n        unordered_map<int,int>ump;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int digit = sumDigit(nums[i]);\\n            \\n            if(ump[digit]!=0 && nums[i]+ump[digit] > mx){\\n                mx = nums[i]+ump[digit];\\n            }\\n            \\n            ump[digit] = max(ump[digit],nums[i]);\\n            \\n        }\\n        return mx == INT_MIN ? -1 : mx;\\n    }\\n```\\n\\n------\\n**Above code is what we thought when dealing with this question**\\n**but the thought is it Time Complexity: O(N*L)**\\n\\n----\\n**Actually, if we observe 10^9 is an element that will present in the array think like the size of the element is 10^9 which is 10 only if we count 10^9 == 10 as the size**\\n**So here inner loop is just working with a very very less size not exceeding 10**\\n**In the end, I think you have got what I mean to say**\\n**Therefore Time Complexity is O(N*10) in the worst case where we can remove the constant 10 so Time Complexity: O(N)**\\n\\n-----\\n**I hope you enjoy reading this post :) I tried my best to explain if still you have doubts comment on it**\\n\\n*\\uD83C\\uDF88 do support by upvoting it*",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    int sumDigit(int v){\\n        int sum = 0;\\n        while(v){\\n            int r = v%10;\\n            sum += r;\\n            v = v/10;\\n        }\\n        return sum;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        int mx = INT_MIN;\\n        unordered_map<int,int>ump;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int digit = sumDigit(nums[i]);\\n            \\n            if(ump[digit]!=0 && nums[i]+ump[digit] > mx){\\n                mx = nums[i]+ump[digit];\\n            }\\n            \\n            ump[digit] = max(ump[digit],nums[i]);\\n            \\n        }\\n        return mx == INT_MIN ? -1 : mx;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2293998,
                "title": "javascript",
                "content": "```\\nconst maximumSum = function(nums) {\\n    const hash = {}\\n    \\n    for (let num of nums) {\\n        const str = num + \\'\\'\\n        \\n        let sum = 0\\n        \\n        for (let ch of str) {\\n            sum += parseInt(ch)\\n        }\\n        \\n        if (!(sum in hash)) {\\n            hash[sum] = []\\n        }\\n        \\n        hash[sum].push(num)\\n    }\\n    \\n    let max = -1\\n    \\n    for (let prop in hash) {\\n        hash[prop].sort((a, b) => b - a)\\n        \\n        if (hash[prop].length > 1) {\\n            max = Math.max(max, hash[prop][0] + hash[prop][1])\\n        }\\n    }\\n    \\n    return max\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst maximumSum = function(nums) {\\n    const hash = {}\\n    \\n    for (let num of nums) {\\n        const str = num + \\'\\'\\n        \\n        let sum = 0\\n        \\n        for (let ch of str) {\\n            sum += parseInt(ch)\\n        }\\n        \\n        if (!(sum in hash)) {\\n            hash[sum] = []\\n        }\\n        \\n        hash[sum].push(num)\\n    }\\n    \\n    let max = -1\\n    \\n    for (let prop in hash) {\\n        hash[prop].sort((a, b) => b - a)\\n        \\n        if (hash[prop].length > 1) {\\n            max = Math.max(max, hash[prop][0] + hash[prop][1])\\n        }\\n    }\\n    \\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2293584,
                "title": "java-c-time-100-space-100-busket-sort",
                "content": "Runtime: 50 ms, faster than 100.00% of Java online submissions for Max Sum of a Pair With Equal Sum of Digits.\\nMemory Usage: 58.3 MB, less than 100.00% of Java online submissions for Max Sum of a Pair With Equal Sum of Digits.\\n```\\nclass Solution {\\n  public int maximumSum(int[] nums) {\\n    ArrayList<Integer> table[] = new ArrayList[82];\\n  \\n    \\n    for(int n: nums){\\n      int sum = 0, N = n;\\n      for(; n != 0; n/=10) sum += n%10;\\n      if(table[sum] == null) table[sum] = new ArrayList<Integer>();\\n      table[sum].add(N);\\n    }\\n    \\n    int ans = -1;\\n    for(ArrayList<Integer> v: table)\\n      if(v != null && v.size() > 1){\\n        int a = 0, b = 0;\\n         \\n        for(Integer x : v)\\n          if(x >= a){b = a; a = x;}\\n          else if(x > b) b = x;\\n      \\n        ans = Math.max(ans, a + b);\\n      }\\n    \\n    return ans;      \\n  }\\n}\\n```\\n\\nRuntime: 208 ms, faster than 100.00% of C++ online submissions for Max Sum of a Pair With Equal Sum of Digits.\\nMemory Usage: 67.9 MB, less than 100.00% of C++ online submissions for Max Sum of a Pair With Equal Sum of Digits.\\n```\\nclass Solution {\\npublic:\\n  int maximumSum(vector<int>& nums) {\\n    vector<vector<int>> table(82);\\n    \\n    for(auto n: nums){\\n      int sum = 0, N = n;\\n      for(; n; n/=10) sum += n%10;\\n      table[sum].push_back(N);\\n    }\\n    \\n    int ans = -1;\\n    for(auto &v: table)\\n      if(v.size() > 1){\\n        if(v[0] < v[1]) swap(v[0], v[1]);\\n        for(int i = 2; i != v.size(); i++)\\n          if(v[i] >= v[0]){v[1] = v[0]; v[0] = v[i];}\\n          else if(v[i] > v[1]) v[1] = v[i];\\n      \\n        ans = max(ans, v[0] + v[1]);\\n      }\\n    \\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n  public int maximumSum(int[] nums) {\\n    ArrayList<Integer> table[] = new ArrayList[82];\\n  \\n    \\n    for(int n: nums){\\n      int sum = 0, N = n;\\n      for(; n != 0; n/=10) sum += n%10;\\n      if(table[sum] == null) table[sum] = new ArrayList<Integer>();\\n      table[sum].add(N);\\n    }\\n    \\n    int ans = -1;\\n    for(ArrayList<Integer> v: table)\\n      if(v != null && v.size() > 1){\\n        int a = 0, b = 0;\\n         \\n        for(Integer x : v)\\n          if(x >= a){b = a; a = x;}\\n          else if(x > b) b = x;\\n      \\n        ans = Math.max(ans, a + b);\\n      }\\n    \\n    return ans;      \\n  }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n  int maximumSum(vector<int>& nums) {\\n    vector<vector<int>> table(82);\\n    \\n    for(auto n: nums){\\n      int sum = 0, N = n;\\n      for(; n; n/=10) sum += n%10;\\n      table[sum].push_back(N);\\n    }\\n    \\n    int ans = -1;\\n    for(auto &v: table)\\n      if(v.size() > 1){\\n        if(v[0] < v[1]) swap(v[0], v[1]);\\n        for(int i = 2; i != v.size(); i++)\\n          if(v[i] >= v[0]){v[1] = v[0]; v[0] = v[i];}\\n          else if(v[i] > v[1]) v[1] = v[i];\\n      \\n        ans = max(ans, v[0] + v[1]);\\n      }\\n    \\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293338,
                "title": "c-easy-solution-using-map-t-c-o-n",
                "content": "Just keep track of the sum of digits and where it occurs in the map\\n\\n```\\nclass Solution {\\n\\nprivate:\\n    int sumofdigits(int a){\\n        int ans=0;\\n        while(a!=0){\\n            ans=ans+(a%10);\\n            a=a/10;\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        int n=nums.size();\\n        int maximum=-1;\\n        map<int,int>map;\\n        for(int i=0;i<n;i++){\\n             int x=sumofdigits(nums[i]);\\n            if(map.find(x)!=map.end()){\\n                maximum=max(maximum,(nums[i]+map[x]));\\n                map[x]=max(map[x],nums[i]);\\n            }\\n            else{\\n                map[x]=nums[i];\\n            }\\n        }\\n        return maximum;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n\\nprivate:\\n    int sumofdigits(int a){\\n        int ans=0;\\n        while(a!=0){\\n            ans=ans+(a%10);\\n            a=a/10;\\n        }\\n        return ans;\\n    }\\n\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        int n=nums.size();\\n        int maximum=-1;\\n        map<int,int>map;\\n        for(int i=0;i<n;i++){\\n             int x=sumofdigits(nums[i]);\\n            if(map.find(x)!=map.end()){\\n                maximum=max(maximum,(nums[i]+map[x]));\\n                map[x]=max(map[x],nums[i]);\\n            }\\n            else{\\n                map[x]=nums[i];\\n            }\\n        }\\n        return maximum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293332,
                "title": "easy-c-100-faster-space-100-faster-time-complexcity",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        int res=-1;\\n        for(auto i:nums)\\n        {\\n            int sum=0,a=i;\\n            while(i>0)\\n                sum+=i%10,i/=10;\\n            if(mp.find(sum)!=mp.end())\\n            {\\n                res=max(res,mp[sum]+a);\\n                if(mp[sum]<a)\\n                    mp[sum]=a;\\n            }\\n            else\\n                mp[sum]=a;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        int res=-1;\\n        for(auto i:nums)\\n        {\\n            int sum=0,a=i;\\n            while(i>0)\\n                sum+=i%10,i/=10;\\n            if(mp.find(sum)!=mp.end())\\n            {\\n                res=max(res,mp[sum]+a);\\n                if(mp[sum]<a)\\n                    mp[sum]=a;\\n            }\\n            else\\n                mp[sum]=a;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293249,
                "title": "java-solution-hashmap-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) \\n    {\\n        int n=nums.length;\\n        int ans=-1;\\n        \\n        Map<Integer,Integer> map=new HashMap<>();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int s=findSum(nums[i]);\\n            \\n            if(map.containsKey(s))\\n            {\\n                ans=Math.max(ans,map.get(s)+nums[i]);\\n                \\n                if(map.get(s)<nums[i])\\n                map.put(s,nums[i]);\\n            }\\n            \\n            else\\n            map.put(s,nums[i]);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int findSum(int n)\\n    {\\n        int s=0;\\n        \\n        while(n>0)\\n        {\\n            s=s+(n%10);\\n            n=n/10;\\n        }\\n        \\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) \\n    {\\n        int n=nums.length;\\n        int ans=-1;\\n        \\n        Map<Integer,Integer> map=new HashMap<>();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int s=findSum(nums[i]);\\n            \\n            if(map.containsKey(s))\\n            {\\n                ans=Math.max(ans,map.get(s)+nums[i]);\\n                \\n                if(map.get(s)<nums[i])\\n                map.put(s,nums[i]);\\n            }\\n            \\n            else\\n            map.put(s,nums[i]);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int findSum(int n)\\n    {\\n        int s=0;\\n        \\n        while(n>0)\\n        {\\n            s=s+(n%10);\\n            n=n/10;\\n        }\\n        \\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293115,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\nprivate :  \\n        int getSum(int n) {\\n        int sum = 0;\\n        while (n != 0) {\\n            sum = sum + n % 10;\\n            n /=10;\\n        }\\n        return sum;\\n    }\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        /* [18,43,36,13,7]\\n          sort ->  43 36 18 13 7         \\n\\t\\t  Why  Sort ? need biggest value \\n           Map \\n\\t\\t   or else Sort in map value vector\\n         7   [43,7] \\n         4   13\\n         9   [36,18]      \\n        */\\n    sort(nums.begin(),nums.end(),greater<int>());\\n    unordered_map<int,vector<int>>map1;\\n    const int n = nums.size();\\n        for(int i = 0 ; i < n ;i++){\\n           map1[getSum(nums[i])].push_back(nums[i]);\\n        } \\n         int maxi = -1;\\n         for(auto it : map1){\\n             if(it.second.size()>=2){\\n                 maxi  = max(maxi,it.second[0]+it.second[1]);\\n             }\\n         }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\nprivate :  \\n        int getSum(int n) {\\n        int sum = 0;\\n        while (n != 0) {\\n            sum = sum + n % 10;\\n            n /=10;\\n        }\\n        return sum;\\n    }\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        /* [18,43,36,13,7]\\n          sort ->  43 36 18 13 7         \\n\\t\\t  Why  Sort ? need biggest value \\n           Map \\n\\t\\t   or else Sort in map value vector\\n         7   [43,7] \\n         4   13\\n         9   [36,18]      \\n        */\\n    sort(nums.begin(),nums.end(),greater<int>());\\n    unordered_map<int,vector<int>>map1;\\n    const int n = nums.size();\\n        for(int i = 0 ; i < n ;i++){\\n           map1[getSum(nums[i])].push_back(nums[i]);\\n        } \\n         int maxi = -1;\\n         for(auto it : map1){\\n             if(it.second.size()>=2){\\n                 maxi  = max(maxi,it.second[0]+it.second[1]);\\n             }\\n         }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293072,
                "title": "simple-o-n-10-c-solution",
                "content": "in a map simply store max and second max number for all sum values.\\n```\\nint maximumSum(vector<int>& nums) {\\n        map<int,vector<int>>mp;\\n        int ans=INT_MIN;\\n        for(auto n:nums){\\n            int t=n,s=0;\\n            while(t){\\n                s+=t%10;\\n                t/=10;\\n            }\\n            if(!mp.count(s)){\\n                mp[s].push_back(INT_MIN);\\n                mp[s].push_back(INT_MIN);\\n            }\\n            if(n>=mp[s][0]){\\n                mp[s][1]=mp[s][0];\\n                mp[s][0]=n;\\n            }else mp[s][1]=max(n,mp[s][1]);\\n\\t\\t\\t\\n            ans=max(ans,mp[s][0]+mp[s][1]);\\n        }\\n        if(ans<=0)return -1;\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint maximumSum(vector<int>& nums) {\\n        map<int,vector<int>>mp;\\n        int ans=INT_MIN;\\n        for(auto n:nums){\\n            int t=n,s=0;\\n            while(t){\\n                s+=t%10;\\n                t/=10;\\n            }\\n            if(!mp.count(s)){\\n                mp[s].push_back(INT_MIN);\\n                mp[s].push_back(INT_MIN);\\n            }\\n            if(n>=mp[s][0]){\\n                mp[s][1]=mp[s][0];\\n                mp[s][0]=n;\\n            }else mp[s][1]=max(n,mp[s][1]);\\n\\t\\t\\t\\n            ans=max(ans,mp[s][0]+mp[s][1]);\\n        }\\n        if(ans<=0)return -1;\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2293053,
                "title": "beats-100-c-easy-map",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n```\\nclass Solution {\\npublic:\\n    int sumofdigits(int n){\\n        int sum=0;\\n        while(n!=0){\\n            int rem=n%10;\\n            sum+=rem;\\n            n=n/10;\\n        }\\n        return sum;\\n    }\\n    \\n    int maximumSum(vector<int>& nums) {\\n        int maxi=-1;\\n        unordered_map<int, priority_queue<int>> hsh;\\n        for(int i=0;i<nums.size();i++){\\n            int sum=sumofdigits(nums[i]);\\n            hsh[sum].push(nums[i]);\\n            if(hsh[sum].size()>=2){\\n                int j=hsh[sum].top();\\n                hsh[sum].pop();\\n                int a=hsh[sum].top();\\n                hsh[sum].push(j);\\n                maxi=max(maxi, j+a);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sumofdigits(int n){\\n        int sum=0;\\n        while(n!=0){\\n            int rem=n%10;\\n            sum+=rem;\\n            n=n/10;\\n        }\\n        return sum;\\n    }\\n    \\n    int maximumSum(vector<int>& nums) {\\n        int maxi=-1;\\n        unordered_map<int, priority_queue<int>> hsh;\\n        for(int i=0;i<nums.size();i++){\\n            int sum=sumofdigits(nums[i]);\\n            hsh[sum].push(nums[i]);\\n            if(hsh[sum].size()>=2){\\n                int j=hsh[sum].top();\\n                hsh[sum].pop();\\n                int a=hsh[sum].top();\\n                hsh[sum].push(j);\\n                maxi=max(maxi, j+a);\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2293034,
                "title": "c-easy-solution-vector-pair-int-int",
                "content": "class Solution {\\n    int sum(int a)\\n    {\\n        int count=0;\\n        while(a>0)\\n        {\\n            count+=a%10;\\n            a=a/10;\\n        }\\n        return count;\\n    }\\npublic:\\n    int maximumSum(vector<int>& nums)\\n    {\\n        vector<pair<int,int>>v(nums.size());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[i].first=sum(nums[i]);\\n            v[i].second=nums[i];\\n        }\\n        sort(v.begin(),v.end());\\n        int ans=-1;\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            if(v[i].first==v[i+1].first)\\n            {\\n                ans=max(ans,v[i].second+v[i+1].second);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\n    int sum(int a)\\n    {\\n        int count=0;\\n        while(a>0)\\n        {\\n            count+=a%10;\\n            a=a/10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2292994,
                "title": "python3-solution-using-dictionary",
                "content": "Maintain a dictionary where key is sum of digits and value is list of numbers having sum equal key.\\nif we sort list in advance, list in dict will also be sorted.\\nnow, in lists stored in dict, calculate value of last two elements(if present)(as sum of numbers is max reqd.) and return max of them.\\n```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        d={}\\n        m=-1\\n        nums.sort()\\n        for n in nums:\\n            a=str(n)\\n            sa=0\\n            for c in a:\\n                sa+=int(c)\\n            if sa not in d.keys():\\n                d[sa]=[n]\\n            else:\\n                d[sa].append(n)\\n       \\n        for k,v in d.items():\\n            if len(v)>=2:\\n                m=max(m,v[-1]+v[-2])\\n        return m\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        d={}\\n        m=-1\\n        nums.sort()\\n        for n in nums:\\n            a=str(n)\\n            sa=0\\n            for c in a:\\n                sa+=int(c)\\n            if sa not in d.keys():\\n                d[sa]=[n]\\n            else:\\n                d[sa].append(n)\\n       \\n        for k,v in d.items():\\n            if len(v)>=2:\\n                m=max(m,v[-1]+v[-2])\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292986,
                "title": "c-priority-queue-solution-brute",
                "content": "* We need to finf the maximum value of nums[i]+nums[j] such that i!=j and getSum(nums[i]) == getSum(nums[j])\\n\\n* We can use a map<int, priority_queue<int>> to store the sum and num in pq;\\n* Then find the maximum of the possible answer.\\n\\n``` \\nclass Solution {\\npublic:\\n  \\n    int maximumSum(vector<int>& nums) {\\n        int maxi = -1;\\n        unordered_map<int, priority_queue<int>> mpp;\\n        for(auto num: nums) {\\n            mpp[getSum(num)].push(num);\\n        }\\n        \\n        for(auto it: mpp) {\\n            if(it.second.size() < 2)\\n                continue;\\n            int tem = it.second.top();\\n            it.second.pop();\\n            tem += it.second.top();\\n            maxi = max(maxi, tem);\\n        }\\n        return maxi;\\n    }\\n      int getSum(int num) {\\n        int sum = 0;\\n        while(num > 0) {\\n            sum += num % 10;\\n            num /= 10;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n  \\n    int maximumSum(vector<int>& nums) {\\n        int maxi = -1;\\n        unordered_map<int, priority_queue<int>> mpp;\\n        for(auto num: nums) {\\n            mpp[getSum(num)].push(num);\\n        }\\n        \\n        for(auto it: mpp) {\\n            if(it.second.size() < 2)\\n                continue;\\n            int tem = it.second.top();\\n            it.second.pop();\\n            tem += it.second.top();\\n            maxi = max(maxi, tem);\\n        }\\n        return maxi;\\n    }\\n      int getSum(int num) {\\n        int sum = 0;\\n        while(num > 0) {\\n            sum += num % 10;\\n            num /= 10;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292974,
                "title": "c-solution-easy",
                "content": "```\\n  int sum(int val){\\n        int ans=0;\\n        while(val){\\n            ans+=val%10;\\n            val=val/10;\\n        }\\n        return ans;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=-1;\\n        unordered_map<int,vector<int>>mp;\\n       for(auto it:nums){\\n           int val=sum(it);\\n           mp[val].push_back(it);\\n       }\\n       for(auto it:mp){\\n           int maxi=INT_MIN;\\n           int maxi1=INT_MIN;\\n         \\n              if(it.second.size()>=2){\\n                  sort(it.second.begin(),it.second.end());\\n                      maxi=it.second.back();\\n                      it.second.pop_back();\\n                      maxi1=it.second.back();\\n                      it.second.pop_back();\\n                       ans=max(ans,maxi+maxi1);\\n                  }\\n           \\n              }\\n          \\n           \\n       return ans;",
                "solutionTags": [],
                "code": "```\\n  int sum(int val){\\n        int ans=0;\\n        while(val){\\n            ans+=val%10;\\n            val=val/10;\\n        }\\n        return ans;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=-1;\\n        unordered_map<int,vector<int>>mp;\\n       for(auto it:nums){\\n           int val=sum(it);\\n           mp[val].push_back(it);\\n       }\\n       for(auto it:mp){\\n           int maxi=INT_MIN;\\n           int maxi1=INT_MIN;\\n         \\n              if(it.second.size()>=2){\\n                  sort(it.second.begin(),it.second.end());\\n                      maxi=it.second.back();\\n                      it.second.pop_back();\\n                      maxi1=it.second.back();\\n                      it.second.pop_back();\\n                       ans=max(ans,maxi+maxi1);\\n                  }\\n           \\n              }\\n          \\n           \\n       return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 2292911,
                "title": "c-easy-solution-unordered-map-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        \\n        unordered_map<int,priority_queue<int,vector<int>>>mp;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int sum =0;\\n            int val = nums[i];\\n            while(val)\\n            {\\n                sum += val%10;\\n                val = val/10;\\n            }\\n            mp[sum].push(nums[i]);\\n            \\n        }\\n        \\n        int maxi = INT_MIN;\\n        for(auto it : mp)\\n        {\\n            int sum = 0;\\n            if(it.second.size() > 1 )\\n            {\\n                sum += it.second.top();\\n                it.second.pop();\\n                sum += it.second.top();\\n            }\\n            maxi = max(maxi,sum);\\n        }\\n        \\n       return maxi==0?-1:maxi; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        \\n        unordered_map<int,priority_queue<int,vector<int>>>mp;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int sum =0;\\n            int val = nums[i];\\n            while(val)\\n            {\\n                sum += val%10;\\n                val = val/10;\\n            }\\n            mp[sum].push(nums[i]);\\n            \\n        }\\n        \\n        int maxi = INT_MIN;\\n        for(auto it : mp)\\n        {\\n            int sum = 0;\\n            if(it.second.size() > 1 )\\n            {\\n                sum += it.second.top();\\n                it.second.pop();\\n                sum += it.second.top();\\n            }\\n            maxi = max(maxi,sum);\\n        }\\n        \\n       return maxi==0?-1:maxi; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292897,
                "title": "similar-to-two-sum-unordered-map",
                "content": "```\\nint maximumSum(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int> mp;//{sum,number}\\n        \\n        int maxi=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int no=nums[i];\\n            while(no){\\n                sum+=no%10;\\n                no/=10;\\n            }\\n            if(mp.count(sum)){\\n                maxi=max(maxi,nums[i]+mp[sum]);\\n            }\\n            if(mp.count(sum)){\\n               int already=mp[sum];\\n                int curr=nums[i];\\n                mp[sum]=max(curr,already);\\n            }\\n            else{\\n                mp[sum]=nums[i];\\n            }\\n        }\\n       return maxi;\\n    }\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maximumSum(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int,int> mp;//{sum,number}\\n        \\n        int maxi=-1;\\n        \\n        for(int i=0;i<n;i++){\\n            int sum=0;\\n            int no=nums[i];\\n            while(no){\\n                sum+=no%10;\\n                no/=10;\\n            }\\n            if(mp.count(sum)){\\n                maxi=max(maxi,nums[i]+mp[sum]);\\n            }\\n            if(mp.count(sum)){\\n               int already=mp[sum];\\n                int curr=nums[i];\\n                mp[sum]=max(curr,already);\\n            }\\n            else{\\n                mp[sum]=nums[i];\\n            }\\n        }\\n       return maxi;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2292846,
                "title": "java-easy-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        HashMap<Integer,Integer> seen=new HashMap<>();\\n        int max=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            int num=nums[i];\\n            while(num!=0)\\n            {\\n                sum+=num%10;\\n                num=num/10;\\n            }\\n            if(seen.containsKey(sum))\\n            {\\n                max=Math.max(max,seen.get(sum)+nums[i]);\\n                if(nums[i]>seen.get(sum))\\n                    seen.put(sum,nums[i]);\\n            }\\n            else\\n               seen.put(sum,nums[i]);\\n        }\\n        if(max!=0)\\n            return max;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        HashMap<Integer,Integer> seen=new HashMap<>();\\n        int max=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            int num=nums[i];\\n            while(num!=0)\\n            {\\n                sum+=num%10;\\n                num=num/10;\\n            }\\n            if(seen.containsKey(sum))\\n            {\\n                max=Math.max(max,seen.get(sum)+nums[i]);\\n                if(nums[i]>seen.get(sum))\\n                    seen.put(sum,nums[i]);\\n            }\\n            else\\n               seen.put(sum,nums[i]);\\n        }\\n        if(max!=0)\\n            return max;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292814,
                "title": "c-priority-queue-hashmap-easy",
                "content": "**Upvote if found useful**\\n```\\nclass Solution {\\npublic:\\n    int digi(int n){\\n        int c = 0;\\n        while(n > 0){\\n            int rem = n%10;\\n            c += rem;\\n            n/=10;\\n        }\\n        return c;\\n    }\\n    \\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,priority_queue<int>> mp;\\n        for(int i = 0;i < nums.size();i++){\\n            int temp = digi(nums[i]);\\n            mp[temp].push(nums[i]);\\n        }\\n        int c = -1;\\n        for(auto&it : mp){\\n            if(it.second.size() <= 1) continue;\\n            int a = it.second.top();\\n            it.second.pop();\\n            int b = it.second.top();\\n            c = max(c,a+b);\\n            \\n        }\\n        return c;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int digi(int n){\\n        int c = 0;\\n        while(n > 0){\\n            int rem = n%10;\\n            c += rem;\\n            n/=10;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2292813,
                "title": "c-solution-using-hashmap-and-max-heap-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,priority_queue<int>> mp;\\n        for(int i=0;i<nums.size();i++){\\n            int k = nums[i];\\n            int sum =0;\\n            while(k!=0){\\n                int x=k%10;\\n                sum += x;\\n                k= k/10;\\n            }\\n            mp[sum].push(nums[i]);\\n        }\\n        int maxi =0;\\n        for(auto x:mp){\\n            int j = x.first;\\n            priority_queue<int> k = x.second;\\n            int n = k.size();\\n            if(n>=2){\\n                int f = k.top();\\n                k.pop();\\n                int s = k.top();\\n                maxi = max(maxi,f+s);\\n            }\\n        }\\n        return maxi==0?-1:maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,priority_queue<int>> mp;\\n        for(int i=0;i<nums.size();i++){\\n            int k = nums[i];\\n            int sum =0;\\n            while(k!=0){\\n                int x=k%10;\\n                sum += x;\\n                k= k/10;\\n            }\\n            mp[sum].push(nums[i]);\\n        }\\n        int maxi =0;\\n        for(auto x:mp){\\n            int j = x.first;\\n            priority_queue<int> k = x.second;\\n            int n = k.size();\\n            if(n>=2){\\n                int f = k.top();\\n                k.pop();\\n                int s = k.top();\\n                maxi = max(maxi,f+s);\\n            }\\n        }\\n        return maxi==0?-1:maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292788,
                "title": "python-faster-than-100",
                "content": "**Please Don\\'t Forget to Upvote!**\\n1. Iterate through nums array, add the digits and put the numbers of same total in a hashmap of list.\\n2. Keep the list size to be 2 at max\\n3. Finally iterate through the hashmap and get the max sum from lists of size 2\\n```\\nimport heapq\\nfrom collections import defaultdict\\ndef maximumSum(self, nums: List[int]) -> int:\\n\\tht = defaultdict(list)\\n\\n\\tfor n in nums:\\n\\t\\tval = n\\n\\t\\trem = 0\\n\\n\\t\\twhile n:\\n\\t\\t\\trem += n % 10\\n\\t\\t\\tn = n // 10\\n\\n\\t\\tht[rem].append(val)\\n\\t\\t\\n\\t\\t# I used heapq for convinience, its not necessary though\\n\\t\\tif len(ht[rem]) > 2:\\n\\t\\t\\theapq.heapify(ht[rem])\\n\\t\\t\\theapq.heappop(ht[rem])\\n\\n\\tans = -1\\n\\n\\tfor n in ht:\\n\\t\\tif len(ht[n]) > 1:\\n\\t\\t\\tans = max(sum(ht[n]), ans)\\n\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nfrom collections import defaultdict\\ndef maximumSum(self, nums: List[int]) -> int:\\n\\tht = defaultdict(list)\\n\\n\\tfor n in nums:\\n\\t\\tval = n\\n\\t\\trem = 0\\n\\n\\t\\twhile n:\\n\\t\\t\\trem += n % 10\\n\\t\\t\\tn = n // 10\\n\\n\\t\\tht[rem].append(val)\\n\\t\\t\\n\\t\\t# I used heapq for convinience, its not necessary though\\n\\t\\tif len(ht[rem]) > 2:\\n\\t\\t\\theapq.heapify(ht[rem])\\n\\t\\t\\theapq.heappop(ht[rem])\\n\\n\\tans = -1\\n\\n\\tfor n in ht:\\n\\t\\tif len(ht[n]) > 1:\\n\\t\\t\\tans = max(sum(ht[n]), ans)\\n\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2292714,
                "title": "c-hashmap-priority-queue-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,priority_queue<int>> m;\\n        for(auto x:nums)\\n        {\\n            m[fun(x)].push(x);\\n        }\\n        int res=-1;\\n        for(auto x:m)\\n        {\\n            if(x.second.size()>1)\\n            {\\n                int a=x.second.top();\\n                x.second.pop();\\n                a+=x.second.top();\\n                res=max(res,a);\\n            }\\n        }\\n        return res;\\n    }\\n    int fun(int n)\\n    {\\n        int c=0;\\n        while(n)\\n        {\\n            c+=n%10;\\n            n/=10;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,priority_queue<int>> m;\\n        for(auto x:nums)\\n        {\\n            m[fun(x)].push(x);\\n        }\\n        int res=-1;\\n        for(auto x:m)\\n        {\\n            if(x.second.size()>1)\\n            {\\n                int a=x.second.top();\\n                x.second.pop();\\n                a+=x.second.top();\\n                res=max(res,a);\\n            }\\n        }\\n        return res;\\n    }\\n    int fun(int n)\\n    {\\n        int c=0;\\n        while(n)\\n        {\\n            c+=n%10;\\n            n/=10;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2292686,
                "title": "c-simple-easy-peasy",
                "content": "```\\nclass Solution {\\n    int finddigitsum(int n)\\n    {\\n        int x=0;\\n        while(n>0)\\n        {\\n            x+=n%10;\\n            n=n/10;\\n        }\\n        return x;\\n    }\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        \\n        long long ans=INT_MIN;\\n        unordered_map<int ,int> mp;\\n    \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int dgtsm=finddigitsum(nums[i]);\\n            //cout<<dgtsm<<\" \";\\n            if(mp.find(dgtsm)==mp.end())\\n            {\\n                mp[dgtsm]=i;\\n            }\\n            else\\n            {\\n                int ind=mp[dgtsm];\\n                int val=nums[ind];\\n                long long p=val+nums[i];\\n                ans=max(ans,p);\\n                if(nums[i]>val)\\n                {\\n                    mp[dgtsm]=i;\\n                }\\n            }\\n            \\n        }\\n        if(ans==INT_MIN)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int finddigitsum(int n)\\n    {\\n        int x=0;\\n        while(n>0)\\n        {\\n            x+=n%10;\\n            n=n/10;\\n        }\\n        return x;\\n    }\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        \\n        long long ans=INT_MIN;\\n        unordered_map<int ,int> mp;\\n    \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int dgtsm=finddigitsum(nums[i]);\\n            //cout<<dgtsm<<\" \";\\n            if(mp.find(dgtsm)==mp.end())\\n            {\\n                mp[dgtsm]=i;\\n            }\\n            else\\n            {\\n                int ind=mp[dgtsm];\\n                int val=nums[ind];\\n                long long p=val+nums[i];\\n                ans=max(ans,p);\\n                if(nums[i]>val)\\n                {\\n                    mp[dgtsm]=i;\\n                }\\n            }\\n            \\n        }\\n        if(ans==INT_MIN)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2292657,
                "title": "solution-that-come-in-your-mind",
                "content": "class Solution {\\npublic:\\n\\n\\n int Sum(long n){\\n \\n    long sum = 0;\\n    while (n) {\\n        sum += (n % 10);\\n        n /= 10;\\n    }\\n    return sum;\\n}\\n    int maxa(vector<int> arr, int n){\\n\\n    unordered_map<int, int> mp;\\n    int ans = -1, ans1 = 0, ans2 = 0;\\n        int maxi=-1e9;\\n    for (int i = 0; i < n; i++) {\\n \\n        int temp = Sum(arr[i]);\\n\\n        if (mp[temp] != 0) {\\n            if (arr[i] + mp[temp] > ans) {\\n                ans1 = arr[i];\\n                ans2 = mp[temp];\\n                ans = ans1 + ans2;\\n            }\\n        }\\n\\n        mp[temp] = max(arr[i], mp[temp]);\\n    }\\n     maxi=max(maxi,ans);\\n        return maxi==-1e9?-1:maxi;\\n    \\n}\\n    int maximumSum(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxa(nums, n);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n int Sum(long n){\\n \\n    long sum = 0;\\n    while (n) {\\n        sum += (n % 10);\\n        n /= 10;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4098487,
                "title": "c-dictionary",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MaximumSum(int[] nums) {\\n        var dict = new Dictionary<int, List<int>>();\\n        var res = -1;\\n        foreach(var n in nums){\\n            var key = 0;\\n            var temp = n;\\n            while(temp > 0){\\n                key += temp % 10;\\n                temp /= 10;\\n            }\\n            if(!dict.ContainsKey(key))\\n                dict.Add(key, new List<int>());\\n            dict[key].Add(n);\\n        }\\n\\n        foreach(var k in dict.Keys){\\n            var len = dict[k].Count;\\n            if(len < 2) continue;\\n            dict[k].Sort();\\n            res = Math.Max(dict[k][len - 1] + dict[k][len - 2], res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaximumSum(int[] nums) {\\n        var dict = new Dictionary<int, List<int>>();\\n        var res = -1;\\n        foreach(var n in nums){\\n            var key = 0;\\n            var temp = n;\\n            while(temp > 0){\\n                key += temp % 10;\\n                temp /= 10;\\n            }\\n            if(!dict.ContainsKey(key))\\n                dict.Add(key, new List<int>());\\n            dict[key].Add(n);\\n        }\\n\\n        foreach(var k in dict.Keys){\\n            var len = dict[k].Count;\\n            if(len < 2) continue;\\n            dict[k].Sort();\\n            res = Math.Max(dict[k][len - 1] + dict[k][len - 2], res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097384,
                "title": "c-solution-using-priority-queue-with-t-c-o-n-and-s-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<priority_queue<int>> v(82);\\n        for(int i=0;i<n;++i){\\n            int sum = 0,og = nums[i];\\n            while(nums[i]){\\n                sum += (nums[i] % 10);\\n                nums[i] /= 10;\\n            }\\n            v[sum].push(og); \\n        }\\n        \\n        int ans = -1;\\n        for(int i=1;i<82;++i){\\n            int pair = 0;\\n            if(v[i].size() >= 2){\\n                pair += v[i].top();\\n                v[i].pop();\\n                pair += v[i].top();\\n                ans = max(ans,pair);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<priority_queue<int>> v(82);\\n        for(int i=0;i<n;++i){\\n            int sum = 0,og = nums[i];\\n            while(nums[i]){\\n                sum += (nums[i] % 10);\\n                nums[i] /= 10;\\n            }\\n            v[sum].push(og); \\n        }\\n        \\n        int ans = -1;\\n        for(int i=1;i<82;++i){\\n            int pair = 0;\\n            if(v[i].size() >= 2){\\n                pair += v[i].top();\\n                v[i].pop();\\n                pair += v[i].top();\\n                ans = max(ans,pair);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088573,
                "title": "brute-force-just-handle-some-edge-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,vector<int>>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int sum=0;\\n            int k=nums[i];\\n            while(nums[i])\\n            {\\n                int l=nums[i]%10;\\n                sum+=l;\\n                nums[i]/=10;\\n            }\\n            m[sum].push_back(k);\\n        }\\n        int ans=0;\\n        int count=0;\\n        for(auto i : m)\\n        {\\n            vector<int>temp=i.second;\\n            if(temp.size()==1)\\n            {\\n                count++;\\n                continue;\\n            }\\n            int maxe=0;\\n            int maxind=-1;\\n            int maxe2=0;\\n            for(int j=0;j<temp.size();j++)\\n            {\\n                if(temp[j]>maxe)\\n                {\\n                    maxe=temp[j];\\n                    maxind=j;\\n                }\\n            }\\n            for(int j=0;j<temp.size();j++)\\n            {\\n                if(temp[j]>=maxe2 && j!=maxind)\\n                {\\n                    maxe2=temp[j];\\n                }\\n            }\\n            ans=max(ans,maxe+maxe2);\\n        }\\n        if(count==m.size())\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,vector<int>>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int sum=0;\\n            int k=nums[i];\\n            while(nums[i])\\n            {\\n                int l=nums[i]%10;\\n                sum+=l;\\n                nums[i]/=10;\\n            }\\n            m[sum].push_back(k);\\n        }\\n        int ans=0;\\n        int count=0;\\n        for(auto i : m)\\n        {\\n            vector<int>temp=i.second;\\n            if(temp.size()==1)\\n            {\\n                count++;\\n                continue;\\n            }\\n            int maxe=0;\\n            int maxind=-1;\\n            int maxe2=0;\\n            for(int j=0;j<temp.size();j++)\\n            {\\n                if(temp[j]>maxe)\\n                {\\n                    maxe=temp[j];\\n                    maxind=j;\\n                }\\n            }\\n            for(int j=0;j<temp.size();j++)\\n            {\\n                if(temp[j]>=maxe2 && j!=maxind)\\n                {\\n                    maxe2=temp[j];\\n                }\\n            }\\n            ans=max(ans,maxe+maxe2);\\n        }\\n        if(count==m.size())\\n        {\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086263,
                "title": "max-sum-of-a-pair-with-equal-sum-of-digits-c-using-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        int sum=-1;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int temp = nums[i];\\n            int digsum =0;\\n            while(temp>0){\\n                digsum += temp%10;\\n                temp /= 10;\\n            }\\n            if(mp.find(digsum) != mp.end()){\\n               int add = mp[digsum] + nums[i];\\n                sum = max(sum , add);\\n            }\\n            mp[digsum] = max(mp[digsum] , nums[i]);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        int sum=-1;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int temp = nums[i];\\n            int digsum =0;\\n            while(temp>0){\\n                digsum += temp%10;\\n                temp /= 10;\\n            }\\n            if(mp.find(digsum) != mp.end()){\\n               int add = mp[digsum] + nums[i];\\n                sum = max(sum , add);\\n            }\\n            mp[digsum] = max(mp[digsum] , nums[i]);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084336,
                "title": "c-unordered-map-easy-to-unserstand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint findVal(int n){\\n    int val=0;\\n    while(n>0){\\n        int rem=n%10;\\n        val=val+rem;\\n        n/=10;\\n    }\\n    return val;\\n}\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,priority_queue<int>> mp;\\n        for(int i=0;i<nums.size();i++){\\n            int val=findVal(nums[i]);\\n            // cout<<val<<\" \";\\n            mp[val].push(nums[i]);\\n        }\\n        int ans=-1;\\n        for(auto it: mp){\\n            int val1=it.second.top();\\n            // cout<<it.first<<\" \"<<val1<<endl;\\n            it.second.pop();\\n            if(it.second.size()>0){\\n                int val2=it.second.top();\\n                int val=val1+val2;\\n                \\n                ans=max(ans,val);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint findVal(int n){\\n    int val=0;\\n    while(n>0){\\n        int rem=n%10;\\n        val=val+rem;\\n        n/=10;\\n    }\\n    return val;\\n}\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,priority_queue<int>> mp;\\n        for(int i=0;i<nums.size();i++){\\n            int val=findVal(nums[i]);\\n            // cout<<val<<\" \";\\n            mp[val].push(nums[i]);\\n        }\\n        int ans=-1;\\n        for(auto it: mp){\\n            int val1=it.second.top();\\n            // cout<<it.first<<\" \"<<val1<<endl;\\n            it.second.pop();\\n            if(it.second.size()>0){\\n                int val2=it.second.top();\\n                int val=val1+val2;\\n                \\n                ans=max(ans,val);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4079629,
                "title": "easy-without-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int digitsum(int num){\\n        int sum=0;\\n        while(num>0){\\n            sum += num%10;\\n            num= num/10;\\n        }\\n\\n        return sum;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n\\n        int n = nums.size();\\n        int max_value = -1;\\n        unordered_map<int,int> mp;\\n\\n        for(int i=0;i<n;i++){\\n            int val = digitsum(nums[i]);\\n            if(mp.find(val)==mp.end()){\\n                mp[val] = nums[i];\\n            }\\n            else{\\n                \\n                max_value = max(max_value,nums[i]+mp[val]);\\n                int p = mp[val];\\n                mp[val] = max(p,nums[i]);\\n            }   \\n            \\n        }\\n\\n        return max_value;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digitsum(int num){\\n        int sum=0;\\n        while(num>0){\\n            sum += num%10;\\n            num= num/10;\\n        }\\n\\n        return sum;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n\\n        int n = nums.size();\\n        int max_value = -1;\\n        unordered_map<int,int> mp;\\n\\n        for(int i=0;i<n;i++){\\n            int val = digitsum(nums[i]);\\n            if(mp.find(val)==mp.end()){\\n                mp[val] = nums[i];\\n            }\\n            else{\\n                \\n                max_value = max(max_value,nums[i]+mp[val]);\\n                int p = mp[val];\\n                mp[val] = max(p,nums[i]);\\n            }   \\n            \\n        }\\n\\n        return max_value;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075981,
                "title": "2342-max-sum-of-a-pair-with-equal-sum-of-digits",
                "content": "# Complexity\\n- Time complexity:\\no(n*m)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n    int result = -1;\\n    int sum;\\n    Map<Integer,Integer> map= new HashMap<>();\\n    for(int i: nums){\\n        sum = findSum(i);\\n        if(!map.containsKey(sum)) {\\n            map.put(sum, i);\\n        }else{\\n            result = Math.max(result, map.get(sum) + i);\\n            map.put(sum, Math.max(map.get(sum), i));\\n        }\\n        }\\n        return result;\\n    }\\n\\n       public int findSum(int n){\\n        int sum =0;\\n        while(n > 0){\\n        sum += n % 10;\\n        n = n / 10; \\n        }\\n        return sum;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n    int result = -1;\\n    int sum;\\n    Map<Integer,Integer> map= new HashMap<>();\\n    for(int i: nums){\\n        sum = findSum(i);\\n        if(!map.containsKey(sum)) {\\n            map.put(sum, i);\\n        }else{\\n            result = Math.max(result, map.get(sum) + i);\\n            map.put(sum, Math.max(map.get(sum), i));\\n        }\\n        }\\n        return result;\\n    }\\n\\n       public int findSum(int n){\\n        int sum =0;\\n        while(n > 0){\\n        sum += n % 10;\\n        n = n / 10; \\n        }\\n        return sum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069475,
                "title": "easy-c-solution-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getSum(int num){\\n        int sum = 0;\\n        while(num!=0){\\n            sum += num % 10;\\n            num = num / 10;\\n        }\\n        return sum;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        int max = -1;\\n        std::priority_queue<std::pair<int, int>> pq;\\n        for(int i = 0; i < nums.size(); i++){\\n            int x = getSum(nums[i]);\\n            pq.push({x, nums[i]});\\n        }\\n        while(pq.size() >= 2){\\n            std::pair<int, int> pair1 = pq.top();\\n            pq.pop();\\n            std::pair<int, int> pair2 = pq.top();\\n            int sum = pair1.second + pair2.second;\\n            if(sum > max && pair1.first == pair2.first){\\n                max = sum;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getSum(int num){\\n        int sum = 0;\\n        while(num!=0){\\n            sum += num % 10;\\n            num = num / 10;\\n        }\\n        return sum;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        int max = -1;\\n        std::priority_queue<std::pair<int, int>> pq;\\n        for(int i = 0; i < nums.size(); i++){\\n            int x = getSum(nums[i]);\\n            pq.push({x, nums[i]});\\n        }\\n        while(pq.size() >= 2){\\n            std::pair<int, int> pair1 = pq.top();\\n            pq.pop();\\n            std::pair<int, int> pair2 = pq.top();\\n            int sum = pair1.second + pair2.second;\\n            if(sum > max && pair1.first == pair2.first){\\n                max = sum;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063044,
                "title": "c-o-n-easy-using-map-and-storing-two-max-elements-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int maximumSum(vector<int>& nums) {\\n      int ans=-1;map<int, pair<int,int>> mp;\\n      for(int i=0;i<nums.size();i++){\\n        int n=nums[i];\\n        int sum=0;\\n        while(n>0){\\n         sum=sum+n%10;\\n         n=n/10;\\n        }\\n        if(mp.find(sum)==mp.end()) mp[sum]={nums[i],-1};\\n        else{\\n            if(nums[i]>mp[sum].first){\\n              mp[sum].second=mp[sum].first;\\n              mp[sum].first=nums[i];\\n            }\\n            else if(nums[i]>mp[sum].second) mp[sum].second=nums[i];\\n            ans=max(ans, mp[sum].first+mp[sum].second);\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maximumSum(vector<int>& nums) {\\n      int ans=-1;map<int, pair<int,int>> mp;\\n      for(int i=0;i<nums.size();i++){\\n        int n=nums[i];\\n        int sum=0;\\n        while(n>0){\\n         sum=sum+n%10;\\n         n=n/10;\\n        }\\n        if(mp.find(sum)==mp.end()) mp[sum]={nums[i],-1};\\n        else{\\n            if(nums[i]>mp[sum].first){\\n              mp[sum].second=mp[sum].first;\\n              mp[sum].first=nums[i];\\n            }\\n            else if(nums[i]>mp[sum].second) mp[sum].second=nums[i];\\n            ans=max(ans, mp[sum].first+mp[sum].second);\\n        }\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049477,
                "title": "java-o-n-time-and-space",
                "content": "# Intuition\\nFind the max value given the constraints of the problem.\\n\\n# Approach\\nCreate a hashmap of `Map<Integer, Integer>`. The key is going to be the digit sum `(aka, if you have 18. It will be 1 + 8 -> 9)` and the value will be the actual number we began with `(18)`. Keep a max counter initiated to `-1`. Loop through the given array and determine the digit sum for each value. Then check the hashmap and see if this value exists. If it does, it means that this is the second occurance of this digit sum. So add the stored value from the hash map and the value from the current index of the array. The `max` counter should then be checked if it needs to be updated. Finally update the hashmap were the key is the same, but the value is the max of the stored value and the array value. The reason for this is in case we come across another array value with the same digit sum.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        //Max counter for solution\\n        int max = -1;\\n        \\n        //Map to store the results of each digit sum\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        //Loop through the array\\n        for(int num : nums){\\n            //Find the digit sum (18 -- 1 + 8 -> 9)\\n            int digSum = digitSum(num);\\n\\n            //Check if the digit sum is in the map\\n            //If it is, get the value stored in the map\\n            //Set max to max of itself or the map value + the current value from the array\\n            //Else add the digit sum to the map\\n            if(map.containsKey(digSum)){\\n                int mappedVal = map.get(digSum);\\n                max = Math.max(max, mappedVal + num);\\n                map.put(digSum, Math.max(mappedVal, num));\\n            } else {\\n                map.put(digSum, num);\\n            }\\n        }\\n\\n        return max;\\n    }\\n\\n    //Returns the digit sum (18 -- 1 + 8 -> 9)\\n    private int digitSum(int num){\\n        int curr = 0;\\n        \\n        while(num != 0){\\n            curr += num % 10;\\n            num /= 10;\\n        }\\n\\n        return curr;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        //Max counter for solution\\n        int max = -1;\\n        \\n        //Map to store the results of each digit sum\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        //Loop through the array\\n        for(int num : nums){\\n            //Find the digit sum (18 -- 1 + 8 -> 9)\\n            int digSum = digitSum(num);\\n\\n            //Check if the digit sum is in the map\\n            //If it is, get the value stored in the map\\n            //Set max to max of itself or the map value + the current value from the array\\n            //Else add the digit sum to the map\\n            if(map.containsKey(digSum)){\\n                int mappedVal = map.get(digSum);\\n                max = Math.max(max, mappedVal + num);\\n                map.put(digSum, Math.max(mappedVal, num));\\n            } else {\\n                map.put(digSum, num);\\n            }\\n        }\\n\\n        return max;\\n    }\\n\\n    //Returns the digit sum (18 -- 1 + 8 -> 9)\\n    private int digitSum(int num){\\n        int curr = 0;\\n        \\n        while(num != 0){\\n            curr += num % 10;\\n            num /= 10;\\n        }\\n\\n        return curr;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044938,
                "title": "java-simple-solution-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        \\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        int ans=-1;\\n\\n        for(int num:nums){\\n          int key=getNumberSum(num);\\n          if(!map.containsKey(key))\\n           map.put(key,num);\\n           else{\\n               ans=Math.max(ans,map.get(key)+num);\\n               map.put(key,Math.max(map.get(key),num));\\n           }\\n          \\n        }\\n        return ans;\\n    }\\n    int getNumberSum(int num){\\n        int result=0;\\n        while(num>0){\\n            result+=num%10;\\n            num/=10;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        \\n        HashMap<Integer,Integer>map=new HashMap<>();\\n        int ans=-1;\\n\\n        for(int num:nums){\\n          int key=getNumberSum(num);\\n          if(!map.containsKey(key))\\n           map.put(key,num);\\n           else{\\n               ans=Math.max(ans,map.get(key)+num);\\n               map.put(key,Math.max(map.get(key),num));\\n           }\\n          \\n        }\\n        return ans;\\n    }\\n    int getNumberSum(int num){\\n        int result=0;\\n        while(num>0){\\n            result+=num%10;\\n            num/=10;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044530,
                "title": "c-simple-map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n      int sz=nums.size();\\n      //map is useful in stroing digit sum to index mapping\\n      unordered_map<int,vector<int>>mp;\\n       for(int i=0;i<sz;i++)\\n        {\\n               string s=to_string(nums[i]);\\n               int sum=0;\\n               //calculating digit sum\\n               for(auto it:s)\\n                  sum=sum+(it-\\'0\\');\\n               //storing sum to digit mapping \\n                 mp[sum].push_back(nums[i]);\\n        }\\n        int sum=-1;\\n        for(auto [k,v]:mp)\\n         {\\n           //sort all the values so that we can get the largest element at the end\\n            \\n             int sz=v.size();\\n             if(sz>1)\\n              {\\n                sort(v.begin(),v.end());\\n                sum=max(sum,v[sz-1]+v[sz-2]);\\n               }\\n         }\\n        return sum;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n      int sz=nums.size();\\n      //map is useful in stroing digit sum to index mapping\\n      unordered_map<int,vector<int>>mp;\\n       for(int i=0;i<sz;i++)\\n        {\\n               string s=to_string(nums[i]);\\n               int sum=0;\\n               //calculating digit sum\\n               for(auto it:s)\\n                  sum=sum+(it-\\'0\\');\\n               //storing sum to digit mapping \\n                 mp[sum].push_back(nums[i]);\\n        }\\n        int sum=-1;\\n        for(auto [k,v]:mp)\\n         {\\n           //sort all the values so that we can get the largest element at the end\\n            \\n             int sz=v.size();\\n             if(sz>1)\\n              {\\n                sort(v.begin(),v.end());\\n                sum=max(sum,v[sz-1]+v[sz-2]);\\n               }\\n         }\\n        return sum;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036901,
                "title": "c-beats-80-of-solutions-simplest-clean-and-concise-optimal-solution-using-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(n log(m)) **where n = nums.size() and m = largest number in nums.**\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n\\n        unordered_map<int, int> mp;\\n        int ans = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++) {\\n            int temp = nums[i];\\n            int digit = 0;\\n            while(temp > 0) {\\n                digit += temp % 10;\\n                temp = temp/10;\\n            }\\n            if(mp[digit] > 0) {\\n                ans = max(ans, mp[digit]+nums[i]);\\n                if(nums[i] > mp[digit]) {\\n                    mp[digit] = nums[i];\\n                }\\n            }\\n            else \\n                mp[digit] = nums[i];\\n        }\\n\\n        return ans == INT_MIN ? -1 : ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n\\n        unordered_map<int, int> mp;\\n        int ans = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++) {\\n            int temp = nums[i];\\n            int digit = 0;\\n            while(temp > 0) {\\n                digit += temp % 10;\\n                temp = temp/10;\\n            }\\n            if(mp[digit] > 0) {\\n                ans = max(ans, mp[digit]+nums[i]);\\n                if(nums[i] > mp[digit]) {\\n                    mp[digit] = nums[i];\\n                }\\n            }\\n            else \\n                mp[digit] = nums[i];\\n        }\\n\\n        return ans == INT_MIN ? -1 : ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036883,
                "title": "c-beats-80-solutions-simplest-solution-using-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(n log(m)) **where n = nums.size() and m = largest number in nums.**\\n\\n- Space complexity:\\nO(n) \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n\\n        unordered_map<int, int> mp;\\n        int ans = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++) {\\n            int temp = nums[i];\\n            int digit = 0;\\n            while(temp > 0) {\\n                digit += temp % 10;\\n                temp = temp/10;\\n            }\\n            if(mp[digit] > 0) {\\n                ans = max(ans, mp[digit]+nums[i]);\\n                if(nums[i] > mp[digit]) {\\n                    mp[digit] = nums[i];\\n                }\\n            }\\n            else \\n                mp[digit] = nums[i];\\n        }\\n\\n        return ans == INT_MIN ? -1 : ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n\\n        unordered_map<int, int> mp;\\n        int ans = INT_MIN;\\n\\n        for(int i=0; i<nums.size(); i++) {\\n            int temp = nums[i];\\n            int digit = 0;\\n            while(temp > 0) {\\n                digit += temp % 10;\\n                temp = temp/10;\\n            }\\n            if(mp[digit] > 0) {\\n                ans = max(ans, mp[digit]+nums[i]);\\n                if(nums[i] > mp[digit]) {\\n                    mp[digit] = nums[i];\\n                }\\n            }\\n            else \\n                mp[digit] = nums[i];\\n        }\\n\\n        return ans == INT_MIN ? -1 : ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013407,
                "title": "python-brute-force-optimal-solution",
                "content": "# **1. BRUTE FORCE APPROACH - TLE**\\nIn the Brute Force approach, for every number, we will go over the whole list to find numbers with the same digit sum and then see which one gives the maximum sum. And update the overall maximum value accordingly.\\n\\nBut this solution will give TLE for large test cases.\\n\\n```\\ndef maximumSum(self, nums: List[int]) -> int:\\n\\n\\t# Length of the list\\n\\tn = len(nums)\\n\\n\\t# Maixmum Sum value to return\\n\\tmaxVal = -1\\n\\n\\t# Go over each number\\n\\tfor i in range(n):\\n\\n\\t\\t# Current max Sum\\n\\t\\tcurrMax = -1\\n\\n\\t\\t# What is the sum of its digits\\n\\t\\tdigitSumi = 0\\n\\t\\tnum = nums[i]\\n\\t\\twhile num > 0:\\n\\t\\t\\tremainder = num % 10\\n\\t\\t\\tdigitSumi += remainder\\n\\t\\t\\tnum = num // 10\\n\\n\\t\\t# Go over every other number\\n\\t\\tfor j in range(n):\\n\\n\\t\\t\\t# If it is not same\\n\\t\\t\\tif i != j:\\n\\n\\t\\t\\t\\t# Get the sum of its digits\\n\\t\\t\\t\\tdigitSumj = 0\\n\\t\\t\\t\\tnum = nums[j]\\n\\t\\t\\t\\twhile num > 0:\\n\\t\\t\\t\\t\\tremainder = num % 10\\n\\t\\t\\t\\t\\tdigitSumj += remainder\\n\\t\\t\\t\\t\\tnum = num // 10\\n\\n\\t\\t\\t\\t# If sum is same\\n\\t\\t\\t\\tif digitSumi == digitSumj: currMax = max(currMax, nums[i] + nums[j])\\n\\n\\t\\t# Update the overall max\\n\\t\\tmaxVal = max(maxVal, currMax)\\n\\n\\t# Return the maximum value\\n\\treturn maxVal\\n```\\n\\n# **2. DICTIONARY + MINHEAP SOLUTION**\\nSince all we want are the two largest numbers with the same digit sum, what we can do is, we can create groups such that each group has all those numbers that have the same sum of digits.\\n\\n\\tFor example, if we have nums = [18,43,36,13,7]\\n\\t\\n\\tSince 18 and 36 have the same digit sum = 9\\n\\tThey will be in the same group\\n\\t\\n\\tSimilarly, 7 and 43 will be together in a different group\\n\\t\\nIn this way, once we group the numbers, then we can easily get the two largest numbers in each group and get their sum and update the overall maximum value accordingly.\\n\\nNow, since we want only the two largest numbers of each group, there is no need to keep more than two numbers in every group. We just keep the two greatest numbers and we do that using a minHeap. So, each group is a minHeap of size 2 which keeps at most two largest numbers.\\n\\n```\\ndef maximumSum(self, nums: List[int]) -> int:\\n        \\n        # Length of the list\\n        n = len(nums)\\n        \\n        # Maixmum Sum value to return\\n        maxVal = -1\\n        \\n        # Dictionary where each value is a minHeap\\n        groups = defaultdict(list)\\n        \\n        # Since we want the maximum 2 numbers having same sum of digits\\n        # What we can do is group numbers based on their digit sum\\n        \\n        # So, if we have lets say nums = [18,43,36,13,7]\\n        # Here, 18 and 36 have sum = 9 so we can put them both in a single group\\n        # Similarly, we can put 43 and 7 in the same group\\n        \\n        # Go we go over each element\\n        for num in nums:\\n            \\n            # Get the sum of its digits\\n            digitSum = 0\\n            temp = num\\n            while temp > 0:\\n                remainder = temp % 10\\n                digitSum += remainder\\n                temp //= 10\\n                \\n            # Now, this \"digitSum\" is a key in the dictionary\\n            # And the value is a minHeap so we will push the \"num\" into the minHeap\\n            heappush(groups[digitSum], num)\\n            \\n            # # We want only the two greatest numbers for each group\\n            # # So we can limit the minHeap size to 2\\n            if len(groups[digitSum]) > 2: heappop(groups[digitSum])\\n                \\n        \\n        # Now that we have our groups, we can go over each group,\\n        # take the sum of the two greatest numbers\\n        # And update the maximum value\\n        for key in groups:\\n            \\n            # If the group has less than 2 numbers, skip it\\n            if len(groups[key]) < 2: continue\\n                \\n            # Take the greatest two numbers from this group\\n            firstGreatest = heappop(groups[key])\\n            secondGreatest = heappop(groups[key])\\n            \\n            # Update the maximum sum value\\n            maxVal = max(maxVal, firstGreatest + secondGreatest)\\n\\n        # Return the maximum value\\n        return maxVal\\n```\\n\\n# **3. DICTIONARY + SIMPLE LIST SOLUTION**\\nFinally, we come to the most optimal approach. \\n\\nSince all we want are the two greatest numbers in each group, a minHeap is an overkill for this simple task. We can easily keep track of which is the greatest and secondgreatest in each group and update them accordingly if a new number has to be pushed into this group.\\n\\nWe will use a simple list and it will have at most two values only - The first greatest and second greatest.\\n\\nAs we find a number that belongs to a group, we can only push it if - \\n\\n\\t1. Either the group is empty\\n\\t2. The group has only one value\\n\\t3. Group has two values but either the number is greater than first or greater than second\\n\\nAnd well, these simple checks eliminate the need to use a minHeap.\\n\\n```\\ndef maximumSum(self, nums: List[int]) -> int:\\n        \\n        # Length of the list\\n        n = len(nums)\\n        \\n        # Maixmum Sum value to return\\n        maxVal = -1\\n        \\n        # Dictionary where each value is a list\\n        groups = defaultdict(list)\\n        \\n        # Since we want the maximum 2 numbers having same sum of digits\\n        # What we can do is group numbers based on their digit sum\\n        \\n        # So, if we have lets say nums = [18,43,36,13,7]\\n        # Here, 18 and 36 have sum = 9 so we can put them both in a single group\\n        # Similarly, we can put 43 and 7 in the same group\\n        \\n        # Go we go over each element\\n        for num in nums:\\n            \\n            # Get the sum of its digits\\n            digitSum = 0\\n            temp = num\\n            while temp > 0:\\n                remainder = temp % 10\\n                digitSum += remainder\\n                temp //= 10\\n                \\n            # Now, this \"digitSum\" is a key in the dictionary\\n            # And the value is a list so we will push the \"num\" into the list\\n            # But, since we only want the two largest numbers in each group\\n            # We can avoid keeping more than two numbers in each group \\n            \\n            # If the list doesn\\'t yet has any numbers already, simply push it\\n            if not groups[digitSum]: groups[digitSum].append(num)\\n            \\n            # Otherwise\\n            else:\\n                # If there is only one value in the list\\n                if len(groups[digitSum]) == 1:\\n                    # If the current number is greater than the value currently in the list\\n                    if num > groups[digitSum][0]:\\n                        # Then the current number is currently the greatest for this group\\n                        # So, the existing value should be the second greatest\\n                        secondGreatest = groups[digitSum][0]\\n                        groups[digitSum][0] = num\\n                        groups[digitSum].append(secondGreatest)\\n                    \\n                    # If current number is smaller or equal to value currently in the list\\n                    # Then it is the second greatest so simply push it to the list\\n                    else: groups[digitSum].append(num)\\n                \\n                # If there are already two values in the list\\n                else:\\n                    # If current num is the greatest\\n                    if num >= groups[digitSum][0]:\\n                        prevGreatest = groups[digitSum][0]\\n                        groups[digitSum][0] = num\\n                        groups[digitSum][1] = prevGreatest\\n                        \\n                    # If current num is second greatest\\n                    elif num >= groups[digitSum][1]: groups[digitSum][1] = num\\n        \\n        # Now that we have our groups, we can go over each group,\\n        # take the sum of the two greatest numbers\\n        # And update the maximum value\\n        for key in groups:\\n            \\n            # If the group has less than 2 numbers, skip it\\n            if len(groups[key]) < 2: continue\\n                \\n            # Take the greatest two numbers from this group\\n            firstGreatest = groups[key][0]\\n            secondGreatest = groups[key][1]\\n        \\n            # Update the maximum sum value\\n            maxVal = max(maxVal, firstGreatest + secondGreatest)\\n\\n        # Return the maximum value\\n        return maxVal\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef maximumSum(self, nums: List[int]) -> int:\\n\\n\\t# Length of the list\\n\\tn = len(nums)\\n\\n\\t# Maixmum Sum value to return\\n\\tmaxVal = -1\\n\\n\\t# Go over each number\\n\\tfor i in range(n):\\n\\n\\t\\t# Current max Sum\\n\\t\\tcurrMax = -1\\n\\n\\t\\t# What is the sum of its digits\\n\\t\\tdigitSumi = 0\\n\\t\\tnum = nums[i]\\n\\t\\twhile num > 0:\\n\\t\\t\\tremainder = num % 10\\n\\t\\t\\tdigitSumi += remainder\\n\\t\\t\\tnum = num // 10\\n\\n\\t\\t# Go over every other number\\n\\t\\tfor j in range(n):\\n\\n\\t\\t\\t# If it is not same\\n\\t\\t\\tif i != j:\\n\\n\\t\\t\\t\\t# Get the sum of its digits\\n\\t\\t\\t\\tdigitSumj = 0\\n\\t\\t\\t\\tnum = nums[j]\\n\\t\\t\\t\\twhile num > 0:\\n\\t\\t\\t\\t\\tremainder = num % 10\\n\\t\\t\\t\\t\\tdigitSumj += remainder\\n\\t\\t\\t\\t\\tnum = num // 10\\n\\n\\t\\t\\t\\t# If sum is same\\n\\t\\t\\t\\tif digitSumi == digitSumj: currMax = max(currMax, nums[i] + nums[j])\\n\\n\\t\\t# Update the overall max\\n\\t\\tmaxVal = max(maxVal, currMax)\\n\\n\\t# Return the maximum value\\n\\treturn maxVal\\n```\n```\\ndef maximumSum(self, nums: List[int]) -> int:\\n        \\n        # Length of the list\\n        n = len(nums)\\n        \\n        # Maixmum Sum value to return\\n        maxVal = -1\\n        \\n        # Dictionary where each value is a minHeap\\n        groups = defaultdict(list)\\n        \\n        # Since we want the maximum 2 numbers having same sum of digits\\n        # What we can do is group numbers based on their digit sum\\n        \\n        # So, if we have lets say nums = [18,43,36,13,7]\\n        # Here, 18 and 36 have sum = 9 so we can put them both in a single group\\n        # Similarly, we can put 43 and 7 in the same group\\n        \\n        # Go we go over each element\\n        for num in nums:\\n            \\n            # Get the sum of its digits\\n            digitSum = 0\\n            temp = num\\n            while temp > 0:\\n                remainder = temp % 10\\n                digitSum += remainder\\n                temp //= 10\\n                \\n            # Now, this \"digitSum\" is a key in the dictionary\\n            # And the value is a minHeap so we will push the \"num\" into the minHeap\\n            heappush(groups[digitSum], num)\\n            \\n            # # We want only the two greatest numbers for each group\\n            # # So we can limit the minHeap size to 2\\n            if len(groups[digitSum]) > 2: heappop(groups[digitSum])\\n                \\n        \\n        # Now that we have our groups, we can go over each group,\\n        # take the sum of the two greatest numbers\\n        # And update the maximum value\\n        for key in groups:\\n            \\n            # If the group has less than 2 numbers, skip it\\n            if len(groups[key]) < 2: continue\\n                \\n            # Take the greatest two numbers from this group\\n            firstGreatest = heappop(groups[key])\\n            secondGreatest = heappop(groups[key])\\n            \\n            # Update the maximum sum value\\n            maxVal = max(maxVal, firstGreatest + secondGreatest)\\n\\n        # Return the maximum value\\n        return maxVal\\n```\n```\\ndef maximumSum(self, nums: List[int]) -> int:\\n        \\n        # Length of the list\\n        n = len(nums)\\n        \\n        # Maixmum Sum value to return\\n        maxVal = -1\\n        \\n        # Dictionary where each value is a list\\n        groups = defaultdict(list)\\n        \\n        # Since we want the maximum 2 numbers having same sum of digits\\n        # What we can do is group numbers based on their digit sum\\n        \\n        # So, if we have lets say nums = [18,43,36,13,7]\\n        # Here, 18 and 36 have sum = 9 so we can put them both in a single group\\n        # Similarly, we can put 43 and 7 in the same group\\n        \\n        # Go we go over each element\\n        for num in nums:\\n            \\n            # Get the sum of its digits\\n            digitSum = 0\\n            temp = num\\n            while temp > 0:\\n                remainder = temp % 10\\n                digitSum += remainder\\n                temp //= 10\\n                \\n            # Now, this \"digitSum\" is a key in the dictionary\\n            # And the value is a list so we will push the \"num\" into the list\\n            # But, since we only want the two largest numbers in each group\\n            # We can avoid keeping more than two numbers in each group \\n            \\n            # If the list doesn\\'t yet has any numbers already, simply push it\\n            if not groups[digitSum]: groups[digitSum].append(num)\\n            \\n            # Otherwise\\n            else:\\n                # If there is only one value in the list\\n                if len(groups[digitSum]) == 1:\\n                    # If the current number is greater than the value currently in the list\\n                    if num > groups[digitSum][0]:\\n                        # Then the current number is currently the greatest for this group\\n                        # So, the existing value should be the second greatest\\n                        secondGreatest = groups[digitSum][0]\\n                        groups[digitSum][0] = num\\n                        groups[digitSum].append(secondGreatest)\\n                    \\n                    # If current number is smaller or equal to value currently in the list\\n                    # Then it is the second greatest so simply push it to the list\\n                    else: groups[digitSum].append(num)\\n                \\n                # If there are already two values in the list\\n                else:\\n                    # If current num is the greatest\\n                    if num >= groups[digitSum][0]:\\n                        prevGreatest = groups[digitSum][0]\\n                        groups[digitSum][0] = num\\n                        groups[digitSum][1] = prevGreatest\\n                        \\n                    # If current num is second greatest\\n                    elif num >= groups[digitSum][1]: groups[digitSum][1] = num\\n        \\n        # Now that we have our groups, we can go over each group,\\n        # take the sum of the two greatest numbers\\n        # And update the maximum value\\n        for key in groups:\\n            \\n            # If the group has less than 2 numbers, skip it\\n            if len(groups[key]) < 2: continue\\n                \\n            # Take the greatest two numbers from this group\\n            firstGreatest = groups[key][0]\\n            secondGreatest = groups[key][1]\\n        \\n            # Update the maximum sum value\\n            maxVal = max(maxVal, firstGreatest + secondGreatest)\\n\\n        # Return the maximum value\\n        return maxVal\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3984370,
                "title": "java-map-of-priority-queues-o-nlogn",
                "content": "# Intuition\\nMapping sumOfDigits with numbers from the array. Since I used PriorityQueues, they are preordered. So, in the second loop I just find max sum of two numbers, if a PriorityQueue has 2 or more elements.\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        Map<Integer, PriorityQueue<Integer>> map = new HashMap<>();\\n        for (int n : nums) map.computeIfAbsent(sumOfDigits(n), p -> new PriorityQueue<>(Comparator.reverseOrder())).offer(n);\\n        int max = -1;\\n        for (int key : map.keySet()) {\\n            PriorityQueue<Integer> pq = map.get(key);\\n            if (pq.size() > 1) max = Math.max(pq.poll() + pq.poll(), max);\\n        }\\n        return max;\\n    }\\n\\n    private Integer sumOfDigits(int n) {\\n        int sum = 0;\\n        while (n > 0) {\\n            sum += n % 10;\\n            n /= 10;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        Map<Integer, PriorityQueue<Integer>> map = new HashMap<>();\\n        for (int n : nums) map.computeIfAbsent(sumOfDigits(n), p -> new PriorityQueue<>(Comparator.reverseOrder())).offer(n);\\n        int max = -1;\\n        for (int key : map.keySet()) {\\n            PriorityQueue<Integer> pq = map.get(key);\\n            if (pq.size() > 1) max = Math.max(pq.poll() + pq.poll(), max);\\n        }\\n        return max;\\n    }\\n\\n    private Integer sumOfDigits(int n) {\\n        int sum = 0;\\n        while (n > 0) {\\n            sum += n % 10;\\n            n /= 10;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981058,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int ans = -1;\\n        for(int i=0;i<nums.length;i++){\\n            int n = nums[i],a = 0 , sum = -1;;\\n            while(n >0){\\n                a += n%10;\\n                n/=10;\\n            }\\n            //map.putIfAbsent(a, new ArrayList<>());\\n            if(!map.containsKey(a))\\n                map.put(a,nums[i]);\\n            else{\\n                sum = map.get(a) + nums[i];\\n                ans = ans > sum? ans:sum;\\n                map.put(a, Math.max(map.get(a), nums[i]));\\n            }\\n        }\\n        // int ans  = -1;\\n        // for(int key: map.keySet()){\\n        //     List list = map.get(key);\\n        //     Collections.sort(list);\\n        //     int n = list.size(), sum = -1;\\n        //     if(n >= 2)\\n        //         sum = (int)list.get(n-1) + (int)list.get(n-2);\\n        // }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int ans = -1;\\n        for(int i=0;i<nums.length;i++){\\n            int n = nums[i],a = 0 , sum = -1;;\\n            while(n >0){\\n                a += n%10;\\n                n/=10;\\n            }\\n            //map.putIfAbsent(a, new ArrayList<>());\\n            if(!map.containsKey(a))\\n                map.put(a,nums[i]);\\n            else{\\n                sum = map.get(a) + nums[i];\\n                ans = ans > sum? ans:sum;\\n                map.put(a, Math.max(map.get(a), nums[i]));\\n            }\\n        }\\n        // int ans  = -1;\\n        // for(int key: map.keySet()){\\n        //     List list = map.get(key);\\n        //     Collections.sort(list);\\n        //     int n = list.size(), sum = -1;\\n        //     if(n >= 2)\\n        //         sum = (int)list.get(n-1) + (int)list.get(n-2);\\n        // }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973174,
                "title": "java-solution-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n*m)\\nwhere n = size of nums array & m <= 10.\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        int max = 0;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            int sum = 0;\\n            int temp = nums[i];\\n\\n            while(temp > 0){\\n                sum += (temp%10);\\n                temp /= 10;\\n            }\\n            \\n            if(hm.containsKey(sum))\\n                max = Math.max(max, nums[i]+hm.get(sum));\\n            \\n            if(!hm.containsKey(sum) || hm.get(sum) < nums[i])\\n                hm.put(sum, nums[i]);\\n        }\\n\\n        return max;\\n    }\\n}\\nUP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        int max = 0;\\n\\n        for(int i = 0; i < nums.length; i++){\\n            int sum = 0;\\n            int temp = nums[i];\\n\\n            while(temp > 0){\\n                sum += (temp%10);\\n                temp /= 10;\\n            }\\n            \\n            if(hm.containsKey(sum))\\n                max = Math.max(max, nums[i]+hm.get(sum));\\n            \\n            if(!hm.containsKey(sum) || hm.get(sum) < nums[i])\\n                hm.put(sum, nums[i]);\\n        }\\n\\n        return max;\\n    }\\n}\\nUP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955204,
                "title": "straightforward-python",
                "content": "```\\ndef maximumSum(self, nums: List[int]) -> int:\\n        def sum_digits(n):\\n            sum_ = 0\\n            while n > 0:\\n                sum_ += n % 10\\n                n //= 10\\n            return sum_\\n        \\n        dc = defaultdict(list)\\n        for num in nums:\\n            dc[sum_digits(num)].append(num)\\n        \\n        maxx = -1\\n        for k, v in dc.items():\\n            if len(v) >= 2:\\n                v.sort(reverse=True)\\n                maxx = max(maxx, v[0] + v[1])\\n        \\n        return maxx\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\ndef maximumSum(self, nums: List[int]) -> int:\\n        def sum_digits(n):\\n            sum_ = 0\\n            while n > 0:\\n                sum_ += n % 10\\n                n //= 10\\n            return sum_\\n        \\n        dc = defaultdict(list)\\n        for num in nums:\\n            dc[sum_digits(num)].append(num)\\n        \\n        maxx = -1\\n        for k, v in dc.items():\\n            if len(v) >= 2:\\n                v.sort(reverse=True)\\n                maxx = max(maxx, v[0] + v[1])\\n        \\n        return maxx\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3942237,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- seggregate the given array grouped by the sum of their digits\\n- within each group take the two highest elements and their sum is the max sum for that group\\n- highest of all these is the answer\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstraightforward\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def sum_of_digits(self, num):\\n        sod = 0\\n        while num > 0:\\n            sod += num % 10\\n            num //= 10\\n        return sod\\n\\n    def form_map_with_sum_of_digits_as_keys(self, nums):\\n        mwsdk = {}\\n        for num in nums:\\n            sod = self.sum_of_digits(num)\\n            if sod in mwsdk:\\n                mwsdk[sod] = mwsdk[sod] + [num]\\n            else:\\n                mwsdk[sod] = [num]\\n        return mwsdk\\n\\n    def maximumSum(self, nums: List[int]) -> int:\\n        mwsdk = self.form_map_with_sum_of_digits_as_keys(nums)\\n        result = -1\\n        for key in mwsdk.keys():\\n            key_sum_nums = mwsdk[key]\\n            if len(key_sum_nums) > 1:\\n                key_sum_nums.sort()\\n                curr_sum = sum(key_sum_nums[-2:])\\n                if curr_sum > result:\\n                    result = curr_sum\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def sum_of_digits(self, num):\\n        sod = 0\\n        while num > 0:\\n            sod += num % 10\\n            num //= 10\\n        return sod\\n\\n    def form_map_with_sum_of_digits_as_keys(self, nums):\\n        mwsdk = {}\\n        for num in nums:\\n            sod = self.sum_of_digits(num)\\n            if sod in mwsdk:\\n                mwsdk[sod] = mwsdk[sod] + [num]\\n            else:\\n                mwsdk[sod] = [num]\\n        return mwsdk\\n\\n    def maximumSum(self, nums: List[int]) -> int:\\n        mwsdk = self.form_map_with_sum_of_digits_as_keys(nums)\\n        result = -1\\n        for key in mwsdk.keys():\\n            key_sum_nums = mwsdk[key]\\n            if len(key_sum_nums) > 1:\\n                key_sum_nums.sort()\\n                curr_sum = sum(key_sum_nums[-2:])\\n                if curr_sum > result:\\n                    result = curr_sum\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931857,
                "title": "easy-java-solution-hashmap-beats-85",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    static int digit(int n){\\n        \\n        int ans = 0;\\n\\n        while(n>0){\\n            ans=ans+n%10;\\n            n=n/10;\\n        }\\n        return ans;\\n    }   \\n\\n    public int maximumSum(int[] arr) {\\n        \\n        HashMap<Integer,Integer> hp = new HashMap<>();\\n        int ans = -1;\\n\\n        for(int n : arr){\\n            int sum = digit(n);\\n\\n            if(!hp.containsKey(sum)){\\n                hp.put(sum,n);\\n            }else{\\n                ans = Math.max(ans,hp.get(sum)+n);\\n                hp.put(sum, Math.max(hp.get(sum),n));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static int digit(int n){\\n        \\n        int ans = 0;\\n\\n        while(n>0){\\n            ans=ans+n%10;\\n            n=n/10;\\n        }\\n        return ans;\\n    }   \\n\\n    public int maximumSum(int[] arr) {\\n        \\n        HashMap<Integer,Integer> hp = new HashMap<>();\\n        int ans = -1;\\n\\n        for(int n : arr){\\n            int sum = digit(n);\\n\\n            if(!hp.containsKey(sum)){\\n                hp.put(sum,n);\\n            }else{\\n                ans = Math.max(ans,hp.get(sum)+n);\\n                hp.put(sum, Math.max(hp.get(sum),n));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926391,
                "title": "hash-map-with-max",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate a hashmap from the sum of digits of a number to the largest number in the array `nums` with that sum of digits. Then iterate through the array updating that hashmap and updating the maximum possible sum (the sum of the current number and the corresponding largest number with the same digit sum). There is no update if there is entry yet in the hashmap for that digit sum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        max_for_digit_sum = defaultdict(int)\\n        sum_of_digits = lambda num: sum(map(int, str(num)))\\n        max_sum = -1\\n        for num in nums:\\n            digit_sum = sum_of_digits(num)\\n            curr_sum = max_for_digit_sum[digit_sum] + num\\n            max_sum = max(max_sum, curr_sum) if curr_sum > num else max_sum\\n            max_for_digit_sum[digit_sum] = max(max_for_digit_sum[digit_sum], num)\\n        return max_sum\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        max_for_digit_sum = defaultdict(int)\\n        sum_of_digits = lambda num: sum(map(int, str(num)))\\n        max_sum = -1\\n        for num in nums:\\n            digit_sum = sum_of_digits(num)\\n            curr_sum = max_for_digit_sum[digit_sum] + num\\n            max_sum = max(max_sum, curr_sum) if curr_sum > num else max_sum\\n            max_for_digit_sum[digit_sum] = max(max_for_digit_sum[digit_sum], num)\\n        return max_sum\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924067,
                "title": "one-pass-using-hashmap",
                "content": "# Intuition\\nWe iterate over each number in nums.\\nWe get their digits sum. \\nThen we use it as the key for the hashmap.\\nWe set the maximum value inside the entire array at index 0 and the second maximum value at index 1.\\nThen we compute the sum.\\n\\n# Complexity\\n- Time complexity:\\nO(n*k) where is the average length of my number in nums\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n\\n        def get_sum(digit):\\n\\n            total = 0\\n\\n            while digit:\\n                total += digit % 10\\n                digit = digit // 10\\n\\n            return total\\n\\n        dic = {}\\n        ans = -1\\n\\n        for n in nums:\\n\\n            total = get_sum(n)\\n            dic[total] =  dic.get(total,[-1,-1])\\n\\n            if dic[total][0] < n:\\n                dic[total][0],dic[total][-1] = n, dic[total][0]\\n            elif dic[total][-1] < n:\\n                dic[total][-1] = n\\n            \\n            if dic[total][0] != -1 and dic[total][-1] != -1:\\n                ans =  max(ans,dic[total][0] + dic[total][-1])\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n\\n        def get_sum(digit):\\n\\n            total = 0\\n\\n            while digit:\\n                total += digit % 10\\n                digit = digit // 10\\n\\n            return total\\n\\n        dic = {}\\n        ans = -1\\n\\n        for n in nums:\\n\\n            total = get_sum(n)\\n            dic[total] =  dic.get(total,[-1,-1])\\n\\n            if dic[total][0] < n:\\n                dic[total][0],dic[total][-1] = n, dic[total][0]\\n            elif dic[total][-1] < n:\\n                dic[total][-1] = n\\n            \\n            if dic[total][0] != -1 and dic[total][-1] != -1:\\n                ans =  max(ans,dic[total][0] + dic[total][-1])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906514,
                "title": "o-n-time-complexity-solution-easy-3-steps",
                "content": "# Approach\\nUse a **hashmap** where: - \\n**key** = sum_of_digits of numbers in nums, \\n**value** = max number having that sum of digits\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        sum_digit_map = defaultdict(int)\\n        maxS = -1\\n\\n        for n in nums:\\n\\n            # STEP 1 : Get the sum of digits of the current number\\n            sum_digit = sum([int(x) for x in str(n)])\\n\\n            # STEP 2 : Check if we have previously seen that sum of digits\\n            if sum_digit in sum_digit_map:\\n                maxS = max(maxS, n + sum_digit_map[sum_digit])\\n\\n            # STEP 3 : Update the value of key sum_digit such that it always have the max value\\n            sum_digit_map[sum_digit] = max(sum_digit_map[sum_digit], n)\\n\\n        return maxS\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n        sum_digit_map = defaultdict(int)\\n        maxS = -1\\n\\n        for n in nums:\\n\\n            # STEP 1 : Get the sum of digits of the current number\\n            sum_digit = sum([int(x) for x in str(n)])\\n\\n            # STEP 2 : Check if we have previously seen that sum of digits\\n            if sum_digit in sum_digit_map:\\n                maxS = max(maxS, n + sum_digit_map[sum_digit])\\n\\n            # STEP 3 : Update the value of key sum_digit such that it always have the max value\\n            sum_digit_map[sum_digit] = max(sum_digit_map[sum_digit], n)\\n\\n        return maxS\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869465,
                "title": "kotlin-hash-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport kotlin.math.max\\n\\nclass Solution {\\n    fun maximumSum(nums: IntArray): Int {\\n        return approach1(nums)\\n        // return approach2(nums)\\n    }\\n\\n\\n    //----------Approach1----------\\n    private fun approach1(nums: IntArray): Int{\\n        if (nums.size < 2) return -1\\n\\n        var ans = -1\\n        val dic = mutableMapOf<Int, Int>()\\n\\n        nums.forEach{ num -> \\n            val sum = sumOfDigits(num)\\n            if(dic.contains(sum)){\\n                ans = max(ans, dic[sum]!! + num)\\n            }\\n\\n            dic[sum] = max(dic.getOrDefault(sum, 0), num)\\n        }\\n\\n        return ans\\n    }\\n\\n\\n    //----------Approach2----------\\n    private fun approach2(nums: IntArray): Int {\\n        if (nums.size < 2) return -1\\n\\n        var ans = -1\\n        val dic = mutableMapOf<Int, MutableList<Int>>()\\n\\n        nums.forEach { num ->\\n            val sum = sumOfDigits(num)\\n            dic[sum] = dic.getOrDefault(sum, mutableListOf())\\n            dic[sum]!!.add(num)\\n        }\\n\\n        dic.values.forEach { list ->\\n            val temp = list.sorted().reversed()\\n            if(temp.size > 1){\\n                ans = max(ans, temp[0] + temp[1])\\n            }\\n        }\\n\\n        return ans\\n    }\\n\\n    private fun sumOfDigits(num: Int): Int {\\n        var sum = 0\\n        num.toString().forEach {\\n            sum += it.toString().toInt()\\n        }\\n        return sum\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nimport kotlin.math.max\\n\\nclass Solution {\\n    fun maximumSum(nums: IntArray): Int {\\n        return approach1(nums)\\n        // return approach2(nums)\\n    }\\n\\n\\n    //----------Approach1----------\\n    private fun approach1(nums: IntArray): Int{\\n        if (nums.size < 2) return -1\\n\\n        var ans = -1\\n        val dic = mutableMapOf<Int, Int>()\\n\\n        nums.forEach{ num -> \\n            val sum = sumOfDigits(num)\\n            if(dic.contains(sum)){\\n                ans = max(ans, dic[sum]!! + num)\\n            }\\n\\n            dic[sum] = max(dic.getOrDefault(sum, 0), num)\\n        }\\n\\n        return ans\\n    }\\n\\n\\n    //----------Approach2----------\\n    private fun approach2(nums: IntArray): Int {\\n        if (nums.size < 2) return -1\\n\\n        var ans = -1\\n        val dic = mutableMapOf<Int, MutableList<Int>>()\\n\\n        nums.forEach { num ->\\n            val sum = sumOfDigits(num)\\n            dic[sum] = dic.getOrDefault(sum, mutableListOf())\\n            dic[sum]!!.add(num)\\n        }\\n\\n        dic.values.forEach { list ->\\n            val temp = list.sorted().reversed()\\n            if(temp.size > 1){\\n                ans = max(ans, temp[0] + temp[1])\\n            }\\n        }\\n\\n        return ans\\n    }\\n\\n    private fun sumOfDigits(num: Int): Int {\\n        var sum = 0\\n        num.toString().forEach {\\n            sum += it.toString().toInt()\\n        }\\n        return sum\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866111,
                "title": "twosum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        int ans = -1;\\n        int sumStore[82] = { };\\n        for(int& x : nums){\\n            int digitSum = 0;\\n            for(int y = x;y;y=y/10){\\n                digitSum += y%10;\\n            }\\n            if(sumStore[digitSum]){\\n                ans = max(ans,x+sumStore[digitSum]);\\n            }\\n            sumStore[digitSum] = max(sumStore[digitSum],x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        int ans = -1;\\n        int sumStore[82] = { };\\n        for(int& x : nums){\\n            int digitSum = 0;\\n            for(int y = x;y;y=y/10){\\n                digitSum += y%10;\\n            }\\n            if(sumStore[digitSum]){\\n                ans = max(ans,x+sumStore[digitSum]);\\n            }\\n            sumStore[digitSum] = max(sumStore[digitSum],x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3865828,
                "title": "simple-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            string s=to_string(nums[i]);\\n            int j=0,sum=0;\\n            while(j<s.size())\\n            {\\n                sum+=s[j]-\\'0\\';\\n                j++;\\n            }\\n           v.push_back(make_pair(sum,nums[i]));\\n        }\\n        sort(v.rbegin(),v.rend());\\n        int max1=-1;\\n        int sum=0;\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            if(v[i].first==v[i+1].first)\\n           { sum=v[i].second+v[i+1].second;\\n            max1=max(max1,sum);}\\n        }\\n        return max1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        vector<pair<int,int>>v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            string s=to_string(nums[i]);\\n            int j=0,sum=0;\\n            while(j<s.size())\\n            {\\n                sum+=s[j]-\\'0\\';\\n                j++;\\n            }\\n           v.push_back(make_pair(sum,nums[i]));\\n        }\\n        sort(v.rbegin(),v.rend());\\n        int max1=-1;\\n        int sum=0;\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            if(v[i].first==v[i+1].first)\\n           { sum=v[i].second+v[i+1].second;\\n            max1=max(max1,sum);}\\n        }\\n        return max1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863658,
                "title": "python-3-100-memory-efficient-and-clean-codes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumSum(self, nums):\\n        dict = {}\\n        count = -1\\n        for i in range(len(nums)):\\n            temp = str(nums[i])\\n            temp2 = 0\\n            for j in range(len(temp)):\\n                temp2 = temp2 + int(temp[j])\\n            if temp2 not in dict:\\n                dict[temp2] = [nums[i]]\\n            else:\\n                dict[temp2].append(nums[i])\\n        for i in dict.keys():\\n            if len(dict[i]) >= 2:\\n                dict[i] = sorted(dict[i])\\n                if count < dict[i][-1] + dict[i][-2]:\\n                    count = dict[i][-1] + dict[i][-2]\\n        return count\\n\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumSum(self, nums):\\n        dict = {}\\n        count = -1\\n        for i in range(len(nums)):\\n            temp = str(nums[i])\\n            temp2 = 0\\n            for j in range(len(temp)):\\n                temp2 = temp2 + int(temp[j])\\n            if temp2 not in dict:\\n                dict[temp2] = [nums[i]]\\n            else:\\n                dict[temp2].append(nums[i])\\n        for i in dict.keys():\\n            if len(dict[i]) >= 2:\\n                dict[i] = sorted(dict[i])\\n                if count < dict[i][-1] + dict[i][-2]:\\n                    count = dict[i][-1] + dict[i][-2]\\n        return count\\n\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863059,
                "title": "c-priority-queue",
                "content": "class Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        priority_queue<pair<int,int>> pq;\\n        int sum=0;\\n        for(auto num:nums){\\n            sum=0;\\n            int n=num;\\n            while(num>0){\\n                int rem=num%10;\\n                sum+=rem;\\n                num/=10;\\n            }\\n            pq.push(make_pair(sum,n));\\n        }\\n        int first1;\\n        int second1;\\n        int max1=-1;\\n        int size=pq.size()-1;\\n        while(size--){\\n            first1=pq.top().first;\\n            int value1=pq.top().second;\\n            pq.pop();\\n            second1=pq.top().first;\\n            cout<<first1<<\" \"<<second1<<endl;\\n            int value2=pq.top().second;\\n            if(first1==second1) max1=max(value1+value2,max1);\\n        }\\n        return max1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        priority_queue<pair<int,int>> pq;\\n        int sum=0;\\n        for(auto num:nums){\\n            sum=0;\\n            int n=num;\\n            while(num>0){\\n                int rem=num%10;\\n                sum+=rem;\\n                num/=10;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3860112,
                "title": "easy-cpp-solution-using-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int digitsum(int num){\\n        int ans = 0;\\n        while(num){\\n            ans += num%10;\\n            num /= 10;\\n        }\\n        return ans;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        //map will have all the elements with same digit sum into a vector \\n        unordered_map<int,vector<int>> mp;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            mp[digitsum(nums[i])].push_back(nums[i]);\\n        }\\n\\n        int ans = -1;\\n        for(auto it = mp.begin(); it != mp.end(); it++){\\n            if(it->second.size() > 1){\\n                sort(it->second.begin(),it->second.end());\\n                int n = it->second.size();\\n                ans = max(ans,it->second[n-1]+it->second[n-2]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int digitsum(int num){\\n        int ans = 0;\\n        while(num){\\n            ans += num%10;\\n            num /= 10;\\n        }\\n        return ans;\\n    }\\n    int maximumSum(vector<int>& nums) {\\n        //map will have all the elements with same digit sum into a vector \\n        unordered_map<int,vector<int>> mp;\\n        \\n        for(int i = 0; i < nums.size(); i++){\\n            mp[digitsum(nums[i])].push_back(nums[i]);\\n        }\\n\\n        int ans = -1;\\n        for(auto it = mp.begin(); it != mp.end(); it++){\\n            if(it->second.size() > 1){\\n                sort(it->second.begin(),it->second.end());\\n                int n = it->second.size();\\n                ans = max(ans,it->second[n-1]+it->second[n-2]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859898,
                "title": "easy-approach-c-map-no-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        \\n        map<int,int> mp;\\n\\n         int maxm=-1;\\n\\n        for(int i=0;i<nums.size();i++){\\n            int p = nums[i],d,sum=0;\\n\\n            while(p!=0){\\n                d = p%10;\\n                sum = sum + d;\\n                p = p/10;\\n            }\\n\\n           if(mp.find(sum)!=mp.end()){\\n               maxm = max(maxm,nums[i]+mp[sum]);\\n           }else{\\n               mp[sum] = nums[i];\\n           }\\n           mp[sum] = max(mp[sum],nums[i]);\\n            \\n        }\\n       \\n       \\n       return maxm;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        \\n        map<int,int> mp;\\n\\n         int maxm=-1;\\n\\n        for(int i=0;i<nums.size();i++){\\n            int p = nums[i],d,sum=0;\\n\\n            while(p!=0){\\n                d = p%10;\\n                sum = sum + d;\\n                p = p/10;\\n            }\\n\\n           if(mp.find(sum)!=mp.end()){\\n               maxm = max(maxm,nums[i]+mp[sum]);\\n           }else{\\n               mp[sum] = nums[i];\\n           }\\n           mp[sum] = max(mp[sum],nums[i]);\\n            \\n        }\\n       \\n       \\n       return maxm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829349,
                "title": "c-100-faster",
                "content": "\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int MaximumSum(int[] nums) \\n    {\\n        Dictionary<int, int> digits = new Dictionary<int, int>();\\n        int result = -1;\\n\\n        foreach (int num in nums)\\n        {\\n            int digitSum = 0;\\n            int currNum = num;\\n\\n            while (currNum > 0)\\n            {   \\n                digitSum += currNum%10;\\n                currNum /= 10;\\n            }\\n\\n            if (digits.ContainsKey(digitSum))\\n            {\\n                result = Math.Max(result, digits[digitSum] + num);\\n                digits[digitSum] = Math.Max(digits[digitSum], num);\\n            }\\n            else\\n            {\\n                digits[digitSum] = num;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int MaximumSum(int[] nums) \\n    {\\n        Dictionary<int, int> digits = new Dictionary<int, int>();\\n        int result = -1;\\n\\n        foreach (int num in nums)\\n        {\\n            int digitSum = 0;\\n            int currNum = num;\\n\\n            while (currNum > 0)\\n            {   \\n                digitSum += currNum%10;\\n                currNum /= 10;\\n            }\\n\\n            if (digits.ContainsKey(digitSum))\\n            {\\n                result = Math.Max(result, digits[digitSum] + num);\\n                digits[digitSum] = Math.Max(digits[digitSum], num);\\n            }\\n            else\\n            {\\n                digits[digitSum] = num;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3823948,
                "title": "fastest-solution-in-php-no-built-in-functions-calls",
                "content": "# Approach\\nNo built-in functions calls (except `max()`). Fastest solution in PHP at the moment of publishing: 100% beats of time and memory. But not enough data for comparison.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function maximumSum($nums) {\\n        $map = [];\\n        $max = -1;\\n        foreach ($nums as $num) {\\n            $numSum = $this->sumDigits($num);\\n            if (isset($map[$numSum])) {\\n                $max = max($max, $map[$numSum] + $num);\\n            }\\n            $map[$numSum] = max($map[$numSum], $num);\\n        }\\n\\n        return $max;\\n    }\\n\\n    private function sumDigits(int $num): int\\n    {\\n        $sum = 0;\\n        while ($num > 1) {\\n            $sum += $num % 10;\\n            $num /= 10;\\n        }\\n\\n        return $sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @return Integer\\n     */\\n    function maximumSum($nums) {\\n        $map = [];\\n        $max = -1;\\n        foreach ($nums as $num) {\\n            $numSum = $this->sumDigits($num);\\n            if (isset($map[$numSum])) {\\n                $max = max($max, $map[$numSum] + $num);\\n            }\\n            $map[$numSum] = max($map[$numSum], $num);\\n        }\\n\\n        return $max;\\n    }\\n\\n    private function sumDigits(int $num): int\\n    {\\n        $sum = 0;\\n        while ($num > 1) {\\n            $sum += $num % 10;\\n            $num /= 10;\\n        }\\n\\n        return $sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813122,
                "title": "java-solution-using-hashmap",
                "content": "Time complexity:O(N)\\n\\nSpace complexity:O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        HashMap<Integer, ArrayList<Integer>> map=new HashMap<>();\\n        \\n        int ans=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int ele=nums[i];\\n            int sum=0;\\n            while(ele>0){\\n                sum+=(ele%10);\\n                ele=ele/10;\\n            }\\n            //put ele and its digit sum in map so that if we get any element with equal sum then we can add it to nums[i] and calculate maximum ans\\n            \\n            ArrayList<Integer> list=new ArrayList<>();\\n            if(map.containsKey(sum))\\n            {\\n                list=map.get(sum);\\n                for(int j=0;j<list.size();j++){\\n                ans=Math.max(ans,list.get(j)+nums[i]);\\n                }\\n                \\n                \\n            }\\n            //update map with current element \\n            //if sum for current element is already present then add current element to list with key=sum\\n            //if sum is not present then put in map with key=sum and value=list(current elemnt)\\n             list.add(nums[i]);\\n             map.put(sum, list);\\n            \\n            \\n        }\\n        return ans;\\n\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        HashMap<Integer, ArrayList<Integer>> map=new HashMap<>();\\n        \\n        int ans=-1;\\n        for(int i=0;i<nums.length;i++){\\n            int ele=nums[i];\\n            int sum=0;\\n            while(ele>0){\\n                sum+=(ele%10);\\n                ele=ele/10;\\n            }\\n            //put ele and its digit sum in map so that if we get any element with equal sum then we can add it to nums[i] and calculate maximum ans\\n            \\n            ArrayList<Integer> list=new ArrayList<>();\\n            if(map.containsKey(sum))\\n            {\\n                list=map.get(sum);\\n                for(int j=0;j<list.size();j++){\\n                ans=Math.max(ans,list.get(j)+nums[i]);\\n                }\\n                \\n                \\n            }\\n            //update map with current element \\n            //if sum for current element is already present then add current element to list with key=sum\\n            //if sum is not present then put in map with key=sum and value=list(current elemnt)\\n             list.add(nums[i]);\\n             map.put(sum, list);\\n            \\n            \\n        }\\n        return ans;\\n\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798200,
                "title": "simplest-cpp-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        int maxSum = -1;\\n        for(int num:nums){\\n                // t represent sum of digits of num. \\n                int t = 0,temp = num; \\n                while(temp){\\n                    t += temp%10;\\n                    temp /= 10;\\n                }\\n            if(!mp[t]){\\n                mp[t] = num;\\n            }\\n            else{\\n                maxSum = max(maxSum,mp[t]+num);\\n                mp[t] = max(mp[t],num); // If the same sum appears in future so we only need the max value of num.\\n                \\n            }\\n            }\\n            return maxSum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        int maxSum = -1;\\n        for(int num:nums){\\n                // t represent sum of digits of num. \\n                int t = 0,temp = num; \\n                while(temp){\\n                    t += temp%10;\\n                    temp /= 10;\\n                }\\n            if(!mp[t]){\\n                mp[t] = num;\\n            }\\n            else{\\n                maxSum = max(maxSum,mp[t]+num);\\n                mp[t] = max(mp[t],num); // If the same sum appears in future so we only need the max value of num.\\n                \\n            }\\n            }\\n            return maxSum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792216,
                "title": "swift-hash-map-o-n",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n\\n# Code\\n```\\nclass Solution {\\n    func digitsSum(_ num: Int) -> Int {\\n        var digitSum = 0\\n        var num = num\\n        \\n        while num != 0 {\\n            digitSum += num % 10\\n            num /= 10\\n        }\\n        \\n        return digitSum\\n    }\\n    \\n    func maximumSum(_ nums: [Int]) -> Int {\\n        var map = [Int: Int]()\\n        \\n        var ans = -1\\n        for num in nums {\\n            let digitSum = digitsSum(num)\\n            \\n            if let old = map[digitSum] {\\n                ans = max(ans, num + old)\\n            }\\n            \\n            map[digitSum] = max(num, map[digitSum, default: num])\\n        }\\n        \\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func digitsSum(_ num: Int) -> Int {\\n        var digitSum = 0\\n        var num = num\\n        \\n        while num != 0 {\\n            digitSum += num % 10\\n            num /= 10\\n        }\\n        \\n        return digitSum\\n    }\\n    \\n    func maximumSum(_ nums: [Int]) -> Int {\\n        var map = [Int: Int]()\\n        \\n        var ans = -1\\n        for num in nums {\\n            let digitSum = digitsSum(num)\\n            \\n            if let old = map[digitSum] {\\n                ans = max(ans, num + old)\\n            }\\n            \\n            map[digitSum] = max(num, map[digitSum, default: num])\\n        }\\n        \\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783455,
                "title": "simple-python-code",
                "content": "# PYTHON CODE\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n      d = {}\\n      for i in nums:\\n        k = self.sum_of_digits(i)\\n        if k not in d:\\n          d[k] = [i]\\n        else:\\n          d[k].append(i)\\n      for key,value in d.items():\\n        d[key] = sorted(value,reverse = True)\\n      maxsum = 0 \\n      for i in d.values():\\n        if len(i) >= 2:\\n          l = sum(i[:2])\\n          maxsum = max(maxsum,l)\\n      if maxsum == 0:\\n        return -1 \\n      else:\\n        return maxsum\\n    def sum_of_digits(self,number):\\n      digits = map(int, str(number))\\n      return sum(digits)\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSum(self, nums: List[int]) -> int:\\n      d = {}\\n      for i in nums:\\n        k = self.sum_of_digits(i)\\n        if k not in d:\\n          d[k] = [i]\\n        else:\\n          d[k].append(i)\\n      for key,value in d.items():\\n        d[key] = sorted(value,reverse = True)\\n      maxsum = 0 \\n      for i in d.values():\\n        if len(i) >= 2:\\n          l = sum(i[:2])\\n          maxsum = max(maxsum,l)\\n      if maxsum == 0:\\n        return -1 \\n      else:\\n        return maxsum\\n    def sum_of_digits(self,number):\\n      digits = map(int, str(number))\\n      return sum(digits)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782131,
                "title": "c-group-by-digits-sum",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Group the numbers by their `digits sum` in a `map`\\n2. loop through `map`, if current group has more than 1 number find the largest 2 among them (sort the array)\\n3. take `ans = max(ans, first_largest_of_current_group + second_largest_of_current_group`\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int digitSum(int n) {\\n        int ans = 0;\\n        while(n) {\\n            ans += n % 10;\\n            n /= 10;\\n        }\\n        return ans;\\n    }\\n\\n    int maximumSum(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> mp;\\n\\n        for (int x : arr) {\\n            int d = digitSum(x);\\n            mp[d].push_back(x);\\n        }\\n        int ans = INT_MIN;\\n\\n        for(auto& [k, v] : mp) {\\n            if(v.size() > 1) {\\n                sort(v.rbegin(), v.rend());\\n                ans = max(ans, v[0] + v[1]);\\n            }\\n        }\\n        return ans == INT_MIN ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int digitSum(int n) {\\n        int ans = 0;\\n        while(n) {\\n            ans += n % 10;\\n            n /= 10;\\n        }\\n        return ans;\\n    }\\n\\n    int maximumSum(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> mp;\\n\\n        for (int x : arr) {\\n            int d = digitSum(x);\\n            mp[d].push_back(x);\\n        }\\n        int ans = INT_MIN;\\n\\n        for(auto& [k, v] : mp) {\\n            if(v.size() > 1) {\\n                sort(v.rbegin(), v.rend());\\n                ans = max(ans, v[0] + v[1]);\\n            }\\n        }\\n        return ans == INT_MIN ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779220,
                "title": "custom-data-structure-vector-of-heaps-no-sorting-required",
                "content": "# ComplexdSumy\\n- Time complexity: $$O(nlogn)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n       vector<priority_queue<int>> vec(82); //max sum is 81(for num = 999999999 => sum = 9*9 = 81)\\n       int maxSum = -1;\\n       for(auto n : nums)\\n       {\\n           int currDigitSum = 0;\\n           int num = n;\\n           while(num)\\n           {\\n               currDigitSum += num%10;\\n               num /= 10;\\n           }\\n           vec[currDigitSum].push(num); //store all numbers to their corresponding sum\\n       }\\n\\n       for(auto currDigitSum : vec)\\n       {\\n           if(currDigitSum.size() >= 2) //if two numbers have equal digitSum\\n           {\\n               int pairSum = 0; //select their 2 largest element\\n               pairSum += currDigitSum.top(); dSum.pop(); \\n               pairSum += currDigitSum.top();\\n               maxSum = max(maxi,two_element_sum); //overall, take maximum of all such sums of top 2 elements\\n           }\\n       }\\n       return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maximumSum(vector<int>& nums) {\\n       vector<priority_queue<int>> vec(82); //max sum is 81(for num = 999999999 => sum = 9*9 = 81)\\n       int maxSum = -1;\\n       for(auto n : nums)\\n       {\\n           int currDigitSum = 0;\\n           int num = n;\\n           while(num)\\n           {\\n               currDigitSum += num%10;\\n               num /= 10;\\n           }\\n           vec[currDigitSum].push(num); //store all numbers to their corresponding sum\\n       }\\n\\n       for(auto currDigitSum : vec)\\n       {\\n           if(currDigitSum.size() >= 2) //if two numbers have equal digitSum\\n           {\\n               int pairSum = 0; //select their 2 largest element\\n               pairSum += currDigitSum.top(); dSum.pop(); \\n               pairSum += currDigitSum.top();\\n               maxSum = max(maxi,two_element_sum); //overall, take maximum of all such sums of top 2 elements\\n           }\\n       }\\n       return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776536,
                "title": "java-solution-easy-to-understand-hashmap",
                "content": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        \\n        HashMap<Integer,List<Integer>> map = new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int copy = nums[i];\\n            int sum = 0;\\n            // fint the sum of the all digit in number\\n            while(copy != 0){\\n                \\n                int rem = copy%10;\\n                sum += rem;\\n                copy /= 10;\\n                \\n            }\\n            \\n            // fint the element with equal sum\\n            if(map.containsKey(sum) == false){\\n                List<Integer> list = new ArrayList<>();\\n                list.add(nums[i]);\\n                map.put(sum,list);\\n            }\\n            else{\\n                \\n                List<Integer> list = map.get(sum);\\n                list.add(nums[i]);\\n                map.put(sum,list);\\n            }\\n        }\\n        \\n        int ans = -1;\\n        \\n        for(int val : map.keySet()){\\n            \\n            List<Integer> list = map.get(val);\\n            int sum = -1;\\n            \\n            if(list.size()>=2){\\n                \\n                Collections.sort(list);\\n                sum += (list.get(list.size()-2)+list.get(list.size()-1))+1;\\n            }\\n            \\n            ans = Math.max(ans,sum);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maximumSum(int[] nums) {\\n        \\n        HashMap<Integer,List<Integer>> map = new HashMap<>();\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int copy = nums[i];\\n            int sum = 0;\\n            // fint the sum of the all digit in number\\n            while(copy != 0){\\n                \\n                int rem = copy%10;\\n                sum += rem;\\n                copy /= 10;\\n                \\n            }\\n            \\n            // fint the element with equal sum\\n            if(map.containsKey(sum) == false){\\n                List<Integer> list = new ArrayList<>();\\n                list.add(nums[i]);\\n                map.put(sum,list);\\n            }\\n            else{\\n                \\n                List<Integer> list = map.get(sum);\\n                list.add(nums[i]);\\n                map.put(sum,list);\\n            }\\n        }\\n        \\n        int ans = -1;\\n        \\n        for(int val : map.keySet()){\\n            \\n            List<Integer> list = map.get(val);\\n            int sum = -1;\\n            \\n            if(list.size()>=2){\\n                \\n                Collections.sort(list);\\n                sum += (list.get(list.size()-2)+list.get(list.size()-1))+1;\\n            }\\n            \\n            ans = Math.max(ans,sum);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1810002,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "How to get digit sum without converting it to string -> then splitting -> summing -> converting back to string -> and then converting to the number?\\n\\nHere is very simple algorithm\\n```\\nint digitSum = 0;\\nwhile (num > 0) {\\n    digitSum += num % 10;\\n    num /= 10;\\n}\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Don\\'t forget that with same sum of the digits ,there can be more than two different instances in the given array.\\nEg : 18,36,45 (sum of digits is 9) and all three can be present."
                    }
                ]
            },
            {
                "id": 1957363,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "How to get digit sum without converting it to string -> then splitting -> summing -> converting back to string -> and then converting to the number?\\n\\nHere is very simple algorithm\\n```\\nint digitSum = 0;\\nwhile (num > 0) {\\n    digitSum += num % 10;\\n    num /= 10;\\n}\\n```"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Don\\'t forget that with same sum of the digits ,there can be more than two different instances in the given array.\\nEg : 18,36,45 (sum of digits is 9) and all three can be present."
                    }
                ]
            }
        ]
    }
]