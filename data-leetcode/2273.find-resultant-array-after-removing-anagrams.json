[
    {
        "title": "Root Equals Sum of Children",
        "question_content": "You are given the root of a binary tree that consists of exactly 3 nodes: the root, its left child, and its right child.\nReturn true if the value of the root is equal to the sum of the values of its two children, or false otherwise.\n&nbsp;\nExample 1:\n\nInput: root = [10,4,6]\nOutput: true\nExplanation: The values of the root, its left child, and its right child are 10, 4, and 6, respectively.\n10 is equal to 4 + 6, so we return true.\n\nExample 2:\n\nInput: root = [5,3,1]\nOutput: false\nExplanation: The values of the root, its left child, and its right child are 5, 3, and 1, respectively.\n5 is not equal to 3 + 1, so we return false.\n\n&nbsp;\nConstraints:\n\n\tThe tree consists only of the root, its left child, and its right child.\n\t-100 <= Node.val <= 100",
        "solutions": [
            {
                "id": 2775146,
                "title": "java-easy-1-liner-o-1-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n       return root.val == root.right.val + root.left.val; \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n       return root.val == root.right.val + root.left.val; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977620,
                "title": "java-c-python-1line-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "**As a professional with a passion for problem-solving and collaboration, I am always looking to expand my network of like-minded individuals on LinkedIn. By connecting with me, we can work together to tackle complex challenges, share ideas, and grow both professionally and personally.**\\n\\n**Whether you\\'re an expert in your field or just starting out, I welcome connections from all backgrounds and experiences. By building a diverse and collaborative network, we can leverage our unique perspectives and skill sets to push the boundaries of what\\'s possible.**\\n\\n**So, if you\\'re interested in connecting and exploring the potential for future collaborations, please don\\'t hesitate to reach out. Let\\'s start a conversation and see where it takes us!**\\n\\n---\\n\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\n\\n---\\n***Java***\\n```\\nclass Solution\\n{\\n    public boolean checkTree(TreeNode root)\\n\\t{\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution\\n{\\npublic:\\n    bool checkTree(TreeNode* root)\\n\\t{\\n       if((root->left->val)+(root->right->val)==root->val) return true;\\n        return false;\\n    }\\n};\\n```\\n\\n***Python***\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public boolean checkTree(TreeNode root)\\n\\t{\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\npublic:\\n    bool checkTree(TreeNode* root)\\n\\t{\\n       if((root->left->val)+(root->right->val)==root->val) return true;\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934995,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)",
                "codeTag": "Java"
            },
            {
                "id": 2180137,
                "title": "python-easy-solution-with-explanation",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        # As per the def of binary tree node, we can compare the root value \\\\\\n        # with the TreeNode function, the root.left.val retrieves value of left node \\\\\\n        # the root.right.val retrieves value of right node. \\'==\\' compares two values\\n        if root.val == root.left.val + root.right.val:  \\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        # As per the def of binary tree node, we can compare the root value \\\\\\n        # with the TreeNode function, the root.left.val retrieves value of left node \\\\\\n        # the root.right.val retrieves value of right node. \\'==\\' compares two values\\n        if root.val == root.left.val + root.right.val:  \\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053858,
                "title": "javascript-solution-o-1-one-liner-81ms-basic-comparison-maths-examples",
                "content": "***Happy Coding..!* Feel free to ask Q\\'s...**\\n\\n```\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\n\\nconst checkTree = root => root.val === (root.left.val + root.right.val);\\n\\n```\\n\\n// Tree Node\\nfunction TreeNode(val, left, right) {\\n    this.val = (val === undefined ? 0 : val)\\n    this.left = (left === undefined ? null : left)\\n    this.right = (right === undefined ? null : right)\\n}\\n\\n// Test Case 1\\n// root = [10, 4, 6]\\nlet tNode1 = new TreeNode(10);\\nlet tNode2 = new TreeNode(4);\\nlet tNode3 = new TreeNode(6);\\n\\ntNode1.left = tNode2;\\ntNode1.right = tNode3;\\n\\nlet root = tNode1;\\nconsole.log(checkTree(root)); // true\\n\\n\\n***#happytohelpu***\\n\\n# ***Do upvote if you find this solution useful..***\\n",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\n\\nconst checkTree = root => root.val === (root.left.val + root.right.val);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3130162,
                "title": "easy-to-understand-for-beginners-python-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDirect Tree approach ATTACKKKKKKKKK\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val + root.right.val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val + root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058305,
                "title": "c-easy-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961431,
                "title": "hardest-binary-tree-problem-hard",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == (root->left->val+root->right->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == (root->left->val+root->right->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937186,
                "title": "javascript-one-liner",
                "content": "Let me know if you have any doubts. I try to answer/help.\\n\\nPlease upvote if you liked the solution.\\n\\n```\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1939586,
                "title": "cpp-one-liner-beats-100",
                "content": "Since we are guaranteed by the contstraints that ```root``` has a right and a left child all that we need to do is just check if the sum of the children values is equal to the value of the root.\\n```cpp\\nbool checkTree(TreeNode* root) {\\n   return root->val == root->left->val + root->right->val;    \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```root```\n```cpp\\nbool checkTree(TreeNode* root) {\\n   return root->val == root->left->val + root->right->val;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519510,
                "title": "my-checktree",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524372,
                "title": "python-one-line-solution-easy",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val+root.right.val\\n```\\n**An upvote will be encouraging**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val+root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795902,
                "title": "python-one-liner-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546066,
                "title": "javascript-easy-to-understand-one-line-solution",
                "content": "```/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3731720,
                "title": "i-ask-why-u-are-seeing-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLOL U Still opened this ......\\n# Code\\n```\\nNOTHING HERE BRO - SORRY !\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\nNOTHING HERE BRO - SORRY !\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3011338,
                "title": "using-single-line-expression-body",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) => root.val == root.left.val + root.right.val;\\n    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) => root.val == root.left.val + root.right.val;\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695970,
                "title": "python-simple-solution-in-4-lines",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == (root.left.val + root.right.val):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == (root.left.val + root.right.val):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602756,
                "title": "c-generic-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n      queue<TreeNode*>q;\\n      q.push(root);\\n      while(!q.empty()){\\n          int size = q.size();\\n          for(int i=0;i<size;i++){\\n          TreeNode* curr = q.front();\\n          q.pop();\\n          int parentValue = curr->val;\\n          int childValue = 0;\\n          int child = 0;\\n          if(curr->left){\\n              q.push(curr->left);\\n              childValue+=curr->left->val;\\n          }else{\\n              child++;\\n          }\\n          if(curr->right){\\n          q.push(curr->right);\\n          childValue+=curr->right->val;\\n          }else{\\n              child++;\\n          }\\n          if(child==2) continue;\\n          if(parentValue != childValue) return false;\\n          }\\n      }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n      queue<TreeNode*>q;\\n      q.push(root);\\n      while(!q.empty()){\\n          int size = q.size();\\n          for(int i=0;i<size;i++){\\n          TreeNode* curr = q.front();\\n          q.pop();\\n          int parentValue = curr->val;\\n          int childValue = 0;\\n          int child = 0;\\n          if(curr->left){\\n              q.push(curr->left);\\n              childValue+=curr->left->val;\\n          }else{\\n              child++;\\n          }\\n          if(curr->right){\\n          q.push(curr->right);\\n          childValue+=curr->right->val;\\n          }else{\\n              child++;\\n          }\\n          if(child==2) continue;\\n          if(parentValue != childValue) return false;\\n          }\\n      }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178260,
                "title": "python-oneliner",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.left.val+root.right.val == root.val\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.left.val+root.right.val == root.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935634,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let root_node = root.as_ref().unwrap().borrow();\\n        let left_node = root_node.left.as_ref().unwrap().borrow();\\n        let right_node = root_node.right.as_ref().unwrap().borrow();\\n\\n        root_node.val == left_node.val + right_node.val\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let root_node = root.as_ref().unwrap().borrow();\\n        let left_node = root_node.left.as_ref().unwrap().borrow();\\n        let right_node = root_node.right.as_ref().unwrap().borrow();\\n\\n        root_node.val == left_node.val + right_node.val\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2973035,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nbool checkTree(struct TreeNode* root){\\n    if(root->val == ((root->left->val) + (root->right->val))){\\n        return true;\\n    }else {\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nbool checkTree(struct TreeNode* root){\\n    if(root->val == ((root->left->val) + (root->right->val))){\\n        return true;\\n    }else {\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2945899,
                "title": "c-one-line-code-super-easy",
                "content": "![image](https://assets.leetcode.com/users/images/be24e3a1-f1ff-4926-b2f1-9e892f9e7992_1671888672.6683366.png)\\n\\n**TC->O(1) && SC->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool checkTree(TreeNode* root) {\\n\\t\\t\\treturn root->val==root->left->val+root->right->val;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool checkTree(TreeNode* root) {\\n\\t\\t\\treturn root->val==root->left->val+root->right->val;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2683146,
                "title": "python-one-liner-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef checkTree(self, root: Optional[TreeNode]) -> bool:\\n\\t\\t\\treturn root.val == (root.left.val + root.right.val)",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef checkTree(self, root: Optional[TreeNode]) -> bool:\\n\\t\\t\\treturn root.val == (root.left.val + root.right.val)",
                "codeTag": "Java"
            },
            {
                "id": 2603021,
                "title": "rust-0-ms-simple-solution-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/804824674/) employs simple operations with smart pointers. It demonstrated **0 ms runtime (100.00%)** and used **2.1 MB memory (67.14%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution \\n{\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool \\n    {\\n        // unfortunately, in Rust the use of smart pointers\\n        // is challenging due to security issues;\\n        // also, an Option requires unwrapping...\\n        \\n        // [1] unpack smart pointer and borrow TreeNode\\n        let root_node = root.as_ref().unwrap().borrow();\\n\\n        // [2] unpack left & right smart pointers and borrow their TreeNodes\\n        let left_node = root_node.left.as_ref().unwrap().borrow();\\n        let right_node = root_node.right.as_ref().unwrap().borrow();\\n\\n        root_node.val == left_node.val + right_node.val\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution \\n{\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool \\n    {\\n        // unfortunately, in Rust the use of smart pointers\\n        // is challenging due to security issues;\\n        // also, an Option requires unwrapping...\\n        \\n        // [1] unpack smart pointer and borrow TreeNode\\n        let root_node = root.as_ref().unwrap().borrow();\\n\\n        // [2] unpack left & right smart pointers and borrow their TreeNodes\\n        let left_node = root_node.left.as_ref().unwrap().borrow();\\n        let right_node = root_node.right.as_ref().unwrap().borrow();\\n\\n        root_node.val == left_node.val + right_node.val\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2581688,
                "title": "rust-solution-with-pattern-matching",
                "content": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        // type(root): Option<...>, use pattern matching to handle this\\n        match root {\\n            Some(root) =>  {\\n                // what happend when we use root.borrow() ?\\n                //    1. In rust, all smart pointers(like Rc<T> here) implement Deref trait.\\n                //    2. Deref coersion, a feature provided by rust. It will convert automatically\\n                //       for us:\\n                //           a reference to a type that implements Deref \\n                //       ->  a reference to a type that Deref can convert the original type into. \\n                //    3. The borrow() method accepts a &self paramater. However, the type of root is Rc<RefCell<TreeNode>>>.\\n                //    4. We can imagine the conversion here:\\n                //           Rc<RefCell<TreeNode>> -> &RefCell<TreeNode> -> &TreeNode\\n                //                               get reference         borrows the wrapped value.\\n                let root_node = root.borrow();\\n                // type(root_node.left/right) = Option<Rc<RefCell<TreeNode>>>\\n                // , which means we need to call .unwrap() method\\n                // why use .as_ref() here ?\\n                //     because we need to take care of the ownship\\'s problem :)\\n                let left_child = root_node.left.as_ref().unwrap().borrow();\\n                let right_child = root_node.right.as_ref().unwrap().borrow();\\n                root_node.val == left_child.val + right_child.val\\n            }\\n            // a empty root is ok\\n            None => true,\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        // type(root): Option<...>, use pattern matching to handle this\\n        match root {\\n            Some(root) =>  {\\n                // what happend when we use root.borrow() ?\\n                //    1. In rust, all smart pointers(like Rc<T> here) implement Deref trait.\\n                //    2. Deref coersion, a feature provided by rust. It will convert automatically\\n                //       for us:\\n                //           a reference to a type that implements Deref \\n                //       ->  a reference to a type that Deref can convert the original type into. \\n                //    3. The borrow() method accepts a &self paramater. However, the type of root is Rc<RefCell<TreeNode>>>.\\n                //    4. We can imagine the conversion here:\\n                //           Rc<RefCell<TreeNode>> -> &RefCell<TreeNode> -> &TreeNode\\n                //                               get reference         borrows the wrapped value.\\n                let root_node = root.borrow();\\n                // type(root_node.left/right) = Option<Rc<RefCell<TreeNode>>>\\n                // , which means we need to call .unwrap() method\\n                // why use .as_ref() here ?\\n                //     because we need to take care of the ownship\\'s problem :)\\n                let left_child = root_node.left.as_ref().unwrap().borrow();\\n                let right_child = root_node.right.as_ref().unwrap().borrow();\\n                root_node.val == left_child.val + right_child.val\\n            }\\n            // a empty root is ok\\n            None => true,\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2426866,
                "title": "with-explanation-comments-time-0-ms-100-space-12-6-mb-66-2",
                "content": "**Like it? ->Upvote please!**\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        //check if the left & the right values equals the main root value\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        //check if the left & the right values equals the main root value\\n        return root->val == root->left->val + root->right->val;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2239768,
                "title": "swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n                guard let root = root, let leftVal = root.left?.val, let rightVal = root.right?.val else { return false }\\n        return root.val == leftVal + rightVal\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n                guard let root = root, let leftVal = root.left?.val, let rightVal = root.right?.val else { return false }\\n        return root.val == leftVal + rightVal\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096471,
                "title": "beginner-friendly-solutoin-one-line-solution",
                "content": "**Time Complexity : O(1)**\\njava\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\njavascript\\n```\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val\\n};\\n```\\npython\\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        return root.val == root.left.val + root.right.val\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\n```\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val\\n};\\n```\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        return root.val == root.left.val + root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054085,
                "title": "c-one-liner",
                "content": "```\\npublic class Solution \\n{\\n    public bool CheckTree(TreeNode root) => root.val == root.left.val+root.right.val;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public bool CheckTree(TreeNode root) => root.val == root.left.val+root.right.val;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953001,
                "title": "java-o-1-one-line-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937707,
                "title": "one-liner-javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nconst checkTree = root => {\\n    return root.val === root.left.val + root.right.val \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst checkTree = root => {\\n    return root.val === root.left.val + root.right.val \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3448027,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if(root.val==root.right.val+root.left.val):\\n            return(True)\\n        return(False)\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if(root.val==root.right.val+root.left.val):\\n            return(True)\\n        return(False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360082,
                "title": "easy-to-understand-c-solution-beats-100-of-other-solutions",
                "content": "Please upvote if you like it.\\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if (root -> val == (root -> left -> val + root -> right -> val)){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if (root -> val == (root -> left -> val + root -> right -> val)){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3215805,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        return false;\\n        if(root->left->val+root->right->val==root->val)\\n        return true;\\n        else\\n        return false;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false; \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        return false;\\n        if(root->left->val+root->right->val==root->val)\\n        return true;\\n        else\\n        return false;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```\n```Java []\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761196,
                "title": "python-easy-solution",
                "content": "**Please upvote if you like my solution. Let me know in the comments if you have any suggestions to increase performance or readability.**\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```\\n\\n**Happy coding!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671683,
                "title": "c-java-python-one-line-code-faster-than-100",
                "content": "C++ : \\n-------------------------------------------------------------------\\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n\\nJAVA : \\n--------------------------------------------------------------------\\n```\\nclass Solution\\n{\\n    public boolean checkTree(TreeNode root)\\n\\t{\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```\\n\\n\\nPYTHON :\\n--------------------------------------------------------------------\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```\\n\\n\\nplz upvote; happy coding :)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\n    public boolean checkTree(TreeNode root)\\n\\t{\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663173,
                "title": "java-solution-one-line-code",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) { \\n        return (root.val == root.left.val + root.right.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) { \\n        return (root.val == root.left.val + root.right.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254854,
                "title": "one-line-js",
                "content": "```\\nconst checkTree =  (root) => root.val === root.right.val + root.left.val\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst checkTree =  (root) => root.val === root.right.val + root.left.val\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2246142,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val ==(root.left.val +root.right.val)\\n```",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val ==(root.left.val +root.right.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219867,
                "title": "kotlin-resolve-o-1-space",
                "content": "It is known from the condition that the binary tree consists of exactly 3 nodes. Therefore, there is no need to specify Nullable in the root: TreeNode argument. The final solution without using secure calls will take the following form:\\n```\\nclass Solution {\\n        fun checkTree(root: TreeNode) = root.`val` == root.left.`val` + root.right.`val`\\n    }\\n\\t",
                "solutionTags": [],
                "code": "class Solution {\\n        fun checkTree(root: TreeNode) = root.`val` == root.left.`val` + root.right.`val`\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3196201,
                "title": "java-easy-sol-0ms-beats-100-one-liner",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196200,
                "title": "beats-100-easy",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->left->val+root->right->val==root->val ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->left->val+root->right->val==root->val ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074170,
                "title": "java-applicable-to-all-trees-for-beginners-o-1",
                "content": "Can be used for all Trees\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// Applicable to all Trees\\nclass Solution \\n{\\n    int num = 0;\\n\\n    public boolean checkTree(TreeNode root) \\n    {\\n        inorder(root);\\n\\n        //subtract the root val and cmp them\\n        if((num - root.val) == root.val)\\n            return true;\\n\\n        return false;\\n    }\\n\\n    //recursive function\\n    public void inorder(TreeNode node)\\n    {\\n        //if reach the end\\n        if (node == null)\\n            return;\\n \\n        //recuring on the left child\\n        inorder(node.left);\\n \\n        //add all the values\\n        num += node.val;\\n \\n        //then recuring on the right child\\n        inorder(node.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// Applicable to all Trees\\nclass Solution \\n{\\n    int num = 0;\\n\\n    public boolean checkTree(TreeNode root) \\n    {\\n        inorder(root);\\n\\n        //subtract the root val and cmp them\\n        if((num - root.val) == root.val)\\n            return true;\\n\\n        return false;\\n    }\\n\\n    //recursive function\\n    public void inorder(TreeNode node)\\n    {\\n        //if reach the end\\n        if (node == null)\\n            return;\\n \\n        //recuring on the left child\\n        inorder(node.left);\\n \\n        //add all the values\\n        num += node.val;\\n \\n        //then recuring on the right child\\n        inorder(node.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925093,
                "title": "98-faster-solution-easy-to-understand",
                "content": "![Screenshot 2022-12-18 at 16.02.43.png](https://assets.leetcode.com/users/images/f4d30438-82c5-495e-9d39-e54807f78a6b_1671361444.7605064.png)\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val+root.right.val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val+root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895960,
                "title": "c-easiest-way-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        TreeNode* l = root->left;\\n        TreeNode* r = root->right;\\n\\n        return root->val == l->val + r->val;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        TreeNode* l = root->left;\\n        TreeNode* r = root->right;\\n\\n        return root->val == l->val + r->val;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827085,
                "title": "java-one-line-code",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val==root.left.val+root.right.val;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val==root.left.val+root.right.val;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792297,
                "title": "c-one-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n     return (root->val==(root->left->val + root->right->val));  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n     return (root->val==(root->left->val + root->right->val));  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766329,
                "title": "one-line-solution",
                "content": "```\\ndef checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==(root.left.val+root.right.val)\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\ndef checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==(root.left.val+root.right.val)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2761009,
                "title": "c-1-line-approach-o-1-time-complexity",
                "content": "bool checkTree(TreeNode* root) {\\n       \\n        if(root->val == (root->left->val + root->right->val))return true;\\n        else return false;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "bool checkTree(TreeNode* root) {\\n       \\n        if(root->val == (root->left->val + root->right->val))return true;\\n        else return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2755142,
                "title": "python-simple-python-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 58 ms, faster than 50.14% of Python3 online submissions for Root Equals Sum of Children.\\n# Memory Usage: 13.8 MB, less than 94.99% of Python3 online submissions for Root Equals Sum of Children.\\n\\n\\tclass Solution:\\n\\t\\tdef checkTree(self, root: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tif root != None:\\n\\n\\t\\t\\t\\tif root.val == root.left.val + root.right.val:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 58 ms, faster than 50.14% of Python3 online submissions for Root Equals Sum of Children.\\n# Memory Usage: 13.8 MB, less than 94.99% of Python3 online submissions for Root Equals Sum of Children.\\n\\n\\tclass Solution:\\n\\t\\tdef checkTree(self, root: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tif root != None:\\n\\n\\t\\t\\t\\tif root.val == root.left.val + root.right.val:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2744279,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2509473,
                "title": "three-different-solutions-for-beginner-s",
                "content": "##### **Solution : 1**\\n```\\n    def checkTree(self, root):\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        return False\\n```\\n\\n##### **Solution : 2**\\n```\\n    def checkTree(self, root):\\n        return (root.val == root.left.val + root.right.val)\\n```\\n\\n##### **Solution : 3**\\n```\\n    def checkTree(self, root):\\n        total = root.left.val + root.right.val\\n        return total == root.val\\n```\\n\\nLiked it? Please **UpVote**",
                "solutionTags": [],
                "code": "```\\n    def checkTree(self, root):\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        return False\\n```\n```\\n    def checkTree(self, root):\\n        return (root.val == root.left.val + root.right.val)\\n```\n```\\n    def checkTree(self, root):\\n        total = root.left.val + root.right.val\\n        return total == root.val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2506582,
                "title": "python-one-line-code-tree",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499960,
                "title": "java-solution-one-line-of-code-1ms-runtime-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return (root.left.val + root.right.val) == root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return (root.left.val + root.right.val) == root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403440,
                "title": "java-one-liner",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393335,
                "title": "safest-1-line-kotlin-solution-all-edge-cases-covered",
                "content": "```class Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return if((root?.`val` ?: 0) == (root?.right?.`val` ?: 0) + (root?.left?.`val` ?: 0)) true else false\\n    }\\n}",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "class Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return if((root?.`val` ?: 0) == (root?.right?.`val` ?: 0) + (root?.left?.`val` ?: 0)) true else false\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2262869,
                "title": "c-simple-oneline-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == root->left->val + root->right->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == root->left->val + root->right->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098710,
                "title": "c-one-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val==root->right->val+root->left->val?1:0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val==root->right->val+root->left->val?1:0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005563,
                "title": "python-solution",
                "content": "**Upvote** if you like solution and feel **free to ask** If you have any question.\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == (root.left.val + root.right.val):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == (root.left.val + root.right.val):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978941,
                "title": "haven-t-seen-this-much-simple-question",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val) \\n            return true; \\n        return false;\\n    }\\n}; // please upvote if it helps you!\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val) \\n            return true; \\n        return false;\\n    }\\n}; // please upvote if it helps you!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004701,
                "title": "0ms-beats-100-00-of-users-with-c-1-line-code",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->left->val+root->right->val==root->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->left->val+root->right->val==root->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985693,
                "title": "c-1-line-code-tc-o-n",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAs they have informed tree has only 3 nodes , so its easy to access them . left + right == root ?\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984030,
                "title": "easy-one-liner-solution-in-c",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->left->val + root->right->val == root->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->left->val + root->right->val == root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783934,
                "title": "fix-documentation-before",
                "content": "# Fix documentation\\nProperties of TreeNode were not type hinted, after fixing this, solution is easy!\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     public $val = null;\\n *     public TreeNode $left = null;\\n *     public TreeNode $right = null;\\n *     function __construct($val = 0, TreeNode $left = null, TreeNode $right = null) {\\n *         $this->val = $val;\\n *         $this->left = $left;\\n *         $this->right = $right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function checkTree(TreeNode $root) {\\n        return $root->val === ($root->left->val + $root->right->val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     public $val = null;\\n *     public TreeNode $left = null;\\n *     public TreeNode $right = null;\\n *     function __construct($val = 0, TreeNode $left = null, TreeNode $right = null) {\\n *         $this->val = $val;\\n *         $this->left = $left;\\n *         $this->right = $right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function checkTree(TreeNode $root) {\\n        return $root->val === ($root->left->val + $root->right->val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735396,
                "title": "easy-3-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665571,
                "title": "check-this-out",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        bool checkRootValue = root.val == (root.left.val + root.right.val) ? true : false;\\n        return checkRootValue;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        bool checkRootValue = root.val == (root.left.val + root.right.val) ? true : false;\\n        return checkRootValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410421,
                "title": "what-if-the-height-of-the-tree-was-more-than-two",
                "content": "\\n\\n**This code will work for the tree with  any number of height.**\\n# Code\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null&&root.right==null)\\n        return true;\\n        int sum=0;\\n        if(root.left!=null)\\n         sum+=root.left.val;\\n        \\n        if(root.right!=null) \\n        sum+=root.right.val;\\n       \\n        return (sum==root.val&&checkTree(root.left)&&checkTree(root.right));\\n    }\\n}\\n```\\nplease upvote if you find it helpful.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null&&root.right==null)\\n        return true;\\n        int sum=0;\\n        if(root.left!=null)\\n         sum+=root.left.val;\\n        \\n        if(root.right!=null) \\n        sum+=root.right.val;\\n       \\n        return (sum==root.val&&checkTree(root.left)&&checkTree(root.right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364957,
                "title": "c-1-liner",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val +root->right->val));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val +root->right->val));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253905,
                "title": "c-super-ez-tree-prob",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        if(root == null)\\n            return true;\\n        if(root.left == null && root.right != null)\\n            return (root.val == root.right.val);\\n        else if(root.right == null && root.left != null)\\n            return (root.val == root.left.val);\\n        else\\n            return (root.val == (root.right.val + root.left.val));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        if(root == null)\\n            return true;\\n        if(root.left == null && root.right != null)\\n            return (root.val == root.right.val);\\n        else if(root.right == null && root.left != null)\\n            return (root.val == root.left.val);\\n        else\\n            return (root.val == (root.right.val + root.left.val));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206666,
                "title": "java-100-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.right.val + root.left.val == root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.right.val + root.left.val == root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200221,
                "title": "java-1-liner-approach-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169261,
                "title": "js",
                "content": "# Intuition\\nCheck if the sume of the left and right children is equal to the value of the node.\\n\\n# Complexity\\n- Time complexity: O(1): performs a constant amount of work\\n\\n- Space complexity: O(1): does not use any additional variables / data structures\\n\\n# Code\\n```\\nconst checkTree = (root) => {\\n    return root.val === (root.left.val) + (root.right.val)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst checkTree = (root) => {\\n    return root.val === (root.left.val) + (root.right.val)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2939455,
                "title": "c-2-liner-easy-solution-beat-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n        if(root->val==(root->right->val + root->left->val))\\n        return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n        if(root->val==(root->right->val + root->left->val))\\n        return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854093,
                "title": "pattern-matching",
                "content": "# Intuition\\nBeing passed in a struct was a little weird compared to the example passing in a list. \\n\\n# Approach\\nPattern match the different inputs to return false with the last pattern doing the summation. Might not be the most efficient but it does work.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n#\\n# defmodule TreeNode do\\n#   @type t :: %__MODULE__{\\n#           val: integer,\\n#           left: TreeNode.t() | nil,\\n#           right: TreeNode.t() | nil\\n#         }\\n#   defstruct val: 0, left: nil, right: nil\\n# end\\n\\ndefmodule Solution do\\n  @spec check_tree(root :: TreeNode.t | nil) :: boolean\\n  def check_tree(nil), do: false\\n  def check_tree(%TreeNode{left: nil}), do: false\\n  def check_tree(%TreeNode{right: nil}), do: false\\n  def check_tree(%TreeNode{val: total, left: left, right: right}) do\\n    left.val + right.val == total\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n#\\n# defmodule TreeNode do\\n#   @type t :: %__MODULE__{\\n#           val: integer,\\n#           left: TreeNode.t() | nil,\\n#           right: TreeNode.t() | nil\\n#         }\\n#   defstruct val: 0, left: nil, right: nil\\n# end\\n\\ndefmodule Solution do\\n  @spec check_tree(root :: TreeNode.t | nil) :: boolean\\n  def check_tree(nil), do: false\\n  def check_tree(%TreeNode{left: nil}), do: false\\n  def check_tree(%TreeNode{right: nil}), do: false\\n  def check_tree(%TreeNode{val: total, left: left, right: right}) do\\n    left.val + right.val == total\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2821687,
                "title": "java-detailed-explanation-o-1-time-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJava Solution to Root Equals Sum Of Children.\\n\\nDetailed explanation included in code comments.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ constant time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ no additional space is used, only constant needed for the boolean returned by the function.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    /**\\n     * Checks A Binary Tree Root Node Consisting Of 3 Nodes (Root, Left Child, Right Child)\\n     * To See If Sum Of Children Node Values Equals Root Node Value.\\n     * @param TreeNode - Root node of a binary tree consisting of 3 nodes: root, left, and right children nodes.\\n     * @return boolean - True if sum of children node values equals root node value, false otherwise.\\n     */\\n    public boolean checkTree(TreeNode root) {\\n        // Sum of left and right children nodes of the root node equal root value\\n        if (root.left.val + root.right.val == root.val)\\n        {\\n            return true;\\n        }\\n\\n        // Return false when sum of right and left children nodes values not equal root node value\\n        return false;\\n\\n        // NOTE: Could also solve using one line shown below\\n        // return root.val == root.right.val + root.left.val; \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    /**\\n     * Checks A Binary Tree Root Node Consisting Of 3 Nodes (Root, Left Child, Right Child)\\n     * To See If Sum Of Children Node Values Equals Root Node Value.\\n     * @param TreeNode - Root node of a binary tree consisting of 3 nodes: root, left, and right children nodes.\\n     * @return boolean - True if sum of children node values equals root node value, false otherwise.\\n     */\\n    public boolean checkTree(TreeNode root) {\\n        // Sum of left and right children nodes of the root node equal root value\\n        if (root.left.val + root.right.val == root.val)\\n        {\\n            return true;\\n        }\\n\\n        // Return false when sum of right and left children nodes values not equal root node value\\n        return false;\\n\\n        // NOTE: Could also solve using one line shown below\\n        // return root.val == root.right.val + root.left.val; \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744869,
                "title": "c-recursive-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass Solution {\\npublic:\\n\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL || (root->left==NULL && root->right==NULL)){return true;}\\n        int l, r;\\n        if(root->left!=NULL){l=root->left->val;}else{l=0;}\\n        if(root->right!=NULL){r=root->right->val;}else{r=0;}\\n        if(root->val!=(l+r)){return false;}\\n        return checkTree(root->left) && checkTree(root->right);\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL || (root->left==NULL && root->right==NULL)){return true;}",
                "codeTag": "Java"
            },
            {
                "id": 2661568,
                "title": "java-solution-recursive-0ms",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->Auxillary stack space.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left!=null && root.right!=null)\\n        {\\n        if(root.val==root.left.val+root.right.val)return true;}\\n        checkTree(root.left);\\n        checkTree(root.right);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left!=null && root.right!=null)\\n        {\\n        if(root.val==root.left.val+root.right.val)return true;}\\n        checkTree(root.left);\\n        checkTree(root.right);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641237,
                "title": "c-one-liner",
                "content": "```\\nbool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val + root->right->val));\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val + root->right->val));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2637705,
                "title": "java-easy-to-understand-not-one-liner",
                "content": "Runtime - 1ms\\nUsing a \\'temp\\' TreeNode to store \\'root\\'.\\n\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        TreeNode temp = root; //Creating temp TreeNode\\n        int sum=0;\\n        root = root.left; //Traversing to left node\\n        sum = sum + root.val; //Adding left node value\\n        root = temp; //Returning to Root Node\\n        root = root.right;  //Traversing to right node\\n        sum = sum + root.val; //Adding right node value\\n        if(sum == temp.val) return true; //Final condition\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        TreeNode temp = root; //Creating temp TreeNode\\n        int sum=0;\\n        root = root.left; //Traversing to left node\\n        sum = sum + root.val; //Adding left node value\\n        root = temp; //Returning to Root Node\\n        root = root.right;  //Traversing to right node\\n        sum = sum + root.val; //Adding right node value\\n        if(sum == temp.val) return true; //Final condition\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589206,
                "title": "single-line-code-javascript",
                "content": "```\\nvar checkTree = function(root) {    \\n    return root.val === root.left.val + root.right.val ? true : false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar checkTree = function(root) {    \\n    return root.val === root.left.val + root.right.val ? true : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2579229,
                "title": "easy-one-liner-c",
                "content": "# One Line\\n\\n```\\nbool checkTree(TreeNode* root) {\\n        return (root->val) == (root->left)->val + (root->right)->val ? true : false;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool checkTree(TreeNode* root) {\\n        return (root->val) == (root->left)->val + (root->right)->val ? true : false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2552128,
                "title": "1-liner-java-c-very-easy",
                "content": "```\\n// Java Solution\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n\\n\\n\\n// C++ Solution\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n// Java Solution\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n\\n\\n\\n// C++ Solution\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506775,
                "title": "simplest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val + root->right->val));    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val + root->right->val));    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492642,
                "title": "java-5-lines-code-100-faster-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        int sum = 0;\\n        sum = root.left.val + root.right.val;\\n        if(root.val == sum){\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```\\n**Thanks for visiting :)**",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        int sum = 0;\\n        sum = root.left.val + root.right.val;\\n        if(root.val == sum){\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462159,
                "title": "python-simple-and-faster-solution",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        d=root.val\\n        self.res=0\\n        def dsf(root):\\n            if(root==None):\\n                return \\n            if(root.left==None and root.right==None):\\n                self.res+=root.val\\n            else:\\n                dsf(root.left)\\n                dsf(root.right)\\n        dsf(root)\\n        return self.res==d\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        d=root.val\\n        self.res=0\\n        def dsf(root):\\n            if(root==None):\\n                return \\n            if(root.left==None and root.right==None):\\n                self.res+=root.val\\n            else:\\n                dsf(root.left)\\n                dsf(root.right)\\n        dsf(root)\\n        return self.res==d\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433136,
                "title": "root-equals-sum-of-children-solution-java",
                "content": "class Solution {\\n  public boolean checkTree(TreeNode root) {\\n    return root.val == root.left.val + root.right.val;\\n  }\\n}\\n",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n  public boolean checkTree(TreeNode root) {\\n    return root.val == root.left.val + root.right.val;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2342925,
                "title": "root-equals-sum-of-children",
                "content": "```\\nvar checkTree = function(root) {\\n    // let binary = (root[0] === root[1]+root[2])? true: false\\n    return root.val === root.left.val+root.right.val\\n    //return binary;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkTree = function(root) {\\n    // let binary = (root[0] === root[1]+root[2])? true: false\\n    return root.val === root.left.val+root.right.val\\n    //return binary;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329524,
                "title": "python-100-faster-one-line",
                "content": "return (root.left.val + root.right.val) == root.val",
                "solutionTags": [
                    "Python"
                ],
                "code": "return (root.left.val + root.right.val) == root.val",
                "codeTag": "Unknown"
            },
            {
                "id": 2312637,
                "title": "why-why-why-why-why-why",
                "content": "return (root->val == root->left->val + root->right->val);",
                "solutionTags": [],
                "code": "return (root->val == root->left->val + root->right->val);",
                "codeTag": "Unknown"
            },
            {
                "id": 2276459,
                "title": "c-easiest-solution-10-ms-runtime-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        if(root->left->val + root->right->val==root->val) return true ;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        if(root->left->val + root->right->val==root->val) return true ;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256250,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val+root.right.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val+root.right.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227427,
                "title": "simple-c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196708,
                "title": "easy-one-liner-python-solution",
                "content": "Code: \\n```return root.val == (root.left.val + root.right.val)```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```return root.val == (root.left.val + root.right.val)```",
                "codeTag": "Unknown"
            },
            {
                "id": 2178290,
                "title": "one-line-killer-typescript-javascript",
                "content": "```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val === root.left.val + root.right.val\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val === root.left.val + root.right.val\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2156990,
                "title": "javascript-easy-solution",
                "content": "```\\nvar checkTree = function(root) {\\n    let value = root.left.val + root.right.val;\\n    value = value === root.val ? true : false;\\n    return value;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkTree = function(root) {\\n    let value = root.left.val + root.right.val;\\n    value = value === root.val ? true : false;\\n    return value;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2109950,
                "title": "easy-python-1-liner",
                "content": "```\\ndef checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2076045,
                "title": "php",
                "content": "```\\nfunction checkTree($root) {\\n        return $root->val === $root->left->val+$root->right->val;\\n        \\n    }\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nfunction checkTree($root) {\\n        return $root->val === $root->left->val+$root->right->val;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2028580,
                "title": "java-1-liner-short-simple-and-easy-using-shorthand-if-notation",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return ((root.left.val)+(root.right.val)==root.val)?true:false; // just used shorthand if notation in java - google it !\\n\\t\\t//root.right - > will get the right node & .val will get its value, similarly for others !\\n    }\\n}\\n```\\n\\n**Perform a dry run for better understanding !\\nHappy Coding !\\nDo upvote if it helped !**",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return ((root.left.val)+(root.right.val)==root.val)?true:false; // just used shorthand if notation in java - google it !\\n\\t\\t//root.right - > will get the right node & .val will get its value, similarly for others !\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010130,
                "title": "sharing-my-solution-in-11-languages",
                "content": "I cannot comprehend which company would ask this question and for which role ?\\nMaybe as an interviewer myself, if I ask a tree based question to a candidate, and the candidate is completely clueless - I would usually level-down the problem, but never ever to this type of level.\\n\\n@Leetcode please do not post such trivial problems on a site which is supposedly used by people preparing for coding contests/interviews.\\n\\nThis problem is good for Exercise in a textbook which has introductory chapter on Trees.\\n\\nEnough of ranting, let us discuss the solutions .....\\n\\n**C**\\n```\\nbool checkTree(struct TreeNode* root){\\n    return root->val == root->left->val + root->right->val;\\n}\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```\\n\\n\\n**C#**\\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\n\\n**Go**\\n```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val;\\n}\\n```\\n\\n\\n**Java**\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\n\\n**Javascript**\\n```\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```\\n\\n**PHP**\\n```\\nclass Solution {\\n\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function checkTree($root) {\\n        return $root->val == $root->left->val + $root->right->val;\\n    }\\n}\\n```\\n\\n**Python**\\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        \"\"\"\\n        :type root: Optional[TreeNode]\\n        :rtype: bool\\n        \"\"\"\\n        return root.val == root.left.val + root.right.val\\n```\\n\\n**Python3**\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n \\n```\\n\\n**Ruby**\\n```\\ndef check_tree(root)\\n    return root.val == root.left.val + root.right.val\\nend\\n```\\n\\n**TypeScript**\\n```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool checkTree(struct TreeNode* root){\\n    return root->val == root->left->val + root->right->val;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\n```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val;\\n}\\n```\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\n```\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```\n```\\nclass Solution {\\n\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function checkTree($root) {\\n        return $root->val == $root->left->val + $root->right->val;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        \"\"\"\\n        :type root: Optional[TreeNode]\\n        :rtype: bool\\n        \"\"\"\\n        return root.val == root.left.val + root.right.val\\n```\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n \\n```\n```\\ndef check_tree(root)\\n    return root.val == root.left.val + root.right.val\\nend\\n```\n```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1952848,
                "title": "hardest-question-needs-sophisticated-solution",
                "content": "```java\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n```\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1947025,
                "title": "every-programming-language-c-java-python-c-c-javascript-ruby-swift-go-scala-and-more",
                "content": "If you think this question is too easy, complete it in every programming language offered by LeetCode.\\n\\n**C++**:\\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```\\n\\n**Java**:\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.right.val + root.left.val;\\n    }\\n}\\n```\\n\\n**Python**:\\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        return root.val == root.right.val + root.left.val\\n```\\n\\n**Python 3**:\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.right.val + root.left.val\\n```\\n\\n**C**:\\n```\\nbool checkTree(struct TreeNode* root){\\n    return root->val == root->left->val + root->right->val;\\n}\\n```\\n\\n**C#**:\\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\n\\n**JavaScript**:\\n```\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```\\n\\n**Ruby**:\\n```\\ndef check_tree(root)\\n    return root.val == root.left.val + root.right.val\\nend\\n```\\n\\n**Swift**:\\n```\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        return root!.val == root!.left!.val + root!.right!.val\\n    }\\n}\\n```\\n\\n**Go**:\\n```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val;\\n}\\n```\\n\\n**Scala**:\\n```\\nobject Solution {\\n    def checkTree(root: TreeNode): Boolean = {\\n        return root.value == root.left.value + root.right.value\\n    }\\n}\\n```\\n\\n**Kotlin**:\\n```\\nclass Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return root!!.`val` == root!!.left!!.`val` + root!!.right!!.`val`\\n    }\\n}\\n```\\n\\n**Rust**:\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let root = root.as_ref().unwrap().borrow();    \\n        return root.val == root.left.as_ref().unwrap().borrow().val + root.right.as_ref().unwrap().borrow().val;\\n    }\\n}\\n```\\n\\n**PHP**:\\n```\\nclass Solution {\\n    function checkTree($root) {\\n        return $root->val == $root->left->val + $root->right->val;\\n    }\\n}\\n```\\n\\n**TypeScript**:\\n```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```\\n\\n**Racket**:\\n```\\n(define/contract (check-tree root)\\n  (-> (or/c tree-node? #f) boolean?)\\n    (eq? (tree-node-val root) (+ (tree-node-val (tree-node-left root)) (tree-node-val (tree-node-right root))))\\n  )\\n```\\n\\n**Erlang**:\\n```\\n-spec check_tree(Root :: #tree_node{} | null) -> boolean().\\ncheck_tree(Root) ->\\n  Root#tree_node.val == Root#tree_node.left#tree_node.val + Root#tree_node.right#tree_node.val.\\n```\\n\\n**Elixir**:\\n```\\ndefmodule Solution do\\n  @spec check_tree(root :: TreeNode.t | nil) :: boolean\\n  def check_tree(root) do\\n    root.val == root.left.val + root.right.val\\n  end\\nend\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Ruby",
                    "Swift",
                    "Scala",
                    "Rust"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.right.val + root.left.val;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        return root.val == root.right.val + root.left.val\\n```\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.right.val + root.left.val\\n```\n```\\nbool checkTree(struct TreeNode* root){\\n    return root->val == root->left->val + root->right->val;\\n}\\n```\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\n```\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```\n```\\ndef check_tree(root)\\n    return root.val == root.left.val + root.right.val\\nend\\n```\n```\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        return root!.val == root!.left!.val + root!.right!.val\\n    }\\n}\\n```\n```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val;\\n}\\n```\n```\\nobject Solution {\\n    def checkTree(root: TreeNode): Boolean = {\\n        return root.value == root.left.value + root.right.value\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return root!!.`val` == root!!.left!!.`val` + root!!.right!!.`val`\\n    }\\n}\\n```\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let root = root.as_ref().unwrap().borrow();    \\n        return root.val == root.left.as_ref().unwrap().borrow().val + root.right.as_ref().unwrap().borrow().val;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    function checkTree($root) {\\n        return $root->val == $root->left->val + $root->right->val;\\n    }\\n}\\n```\n```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```\n```\\n(define/contract (check-tree root)\\n  (-> (or/c tree-node? #f) boolean?)\\n    (eq? (tree-node-val root) (+ (tree-node-val (tree-node-left root)) (tree-node-val (tree-node-right root))))\\n  )\\n```\n```\\n-spec check_tree(Root :: #tree_node{} | null) -> boolean().\\ncheck_tree(Root) ->\\n  Root#tree_node.val == Root#tree_node.left#tree_node.val + Root#tree_node.right#tree_node.val.\\n```\n```\\ndefmodule Solution do\\n  @spec check_tree(root :: TreeNode.t | nil) :: boolean\\n  def check_tree(root) do\\n    root.val == root.left.val + root.right.val\\n  end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945881,
                "title": "c-solution",
                "content": "My little solution in C#\\n\\n\\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        \\n        int left = root.left.val;\\n        int right= root.right.val;\\n        \\n        return(left+right==root.val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        \\n        int left = root.left.val;\\n        int right= root.right.val;\\n        \\n        return(left+right==root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944211,
                "title": "javascript-js",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function (root) {\\n  return root.val === root.left.val + root.right.val;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function (root) {\\n  return root.val === root.left.val + root.right.val;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1940061,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val == root->left->val + root->right->val)\\n            return true; \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val == root->left->val + root->right->val)\\n            return true; \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938760,
                "title": "rust-0ms-pattern-matching",
                "content": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match root {\\n            Some(node) => match (node.borrow().left.as_ref(), node.borrow().right.as_ref()) {\\n                (Some(left), Some(right)) => {\\n                    left.borrow().val + right.borrow().val == node.borrow().val\\n                }\\n                _ => true,\\n            },\\n            None => true,\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match root {\\n            Some(node) => match (node.borrow().left.as_ref(), node.borrow().right.as_ref()) {\\n                (Some(left), Some(right)) => {\\n                    left.borrow().val + right.borrow().val == node.borrow().val\\n                }\\n                _ => true,\\n            },\\n            None => true,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1938094,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935170,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode node) {\\n        if(node.left == null){\\n            return true;\\n        }\\n        if(node.right==null){\\n            return true;\\n        }\\n        checkTree(node.left);\\n        checkTree(node.right);\\n        if(node.val == node.left.val + node.right.val){\\n            return true;\\n            \\n        }\\n        else{\\n            return false;\\n        }\\n        \\n      \\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode node) {\\n        if(node.left == null){\\n            return true;\\n        }\\n        if(node.right==null){\\n            return true;\\n        }\\n        checkTree(node.left);\\n        checkTree(node.right);\\n        if(node.val == node.left.val + node.right.val){\\n            return true;\\n            \\n        }\\n        else{\\n            return false;\\n        }\\n        \\n      \\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934711,
                "title": "don-t-see-the-point-of-this-problem",
                "content": "```\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val+root.right.val\\n```",
                "solutionTags": [],
                "code": "```\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val+root.right.val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4063581,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root.val==root.left.val+root.right.val) return true;\\n        else return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root.val==root.left.val+root.right.val) return true;\\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964841,
                "title": "100-faster-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        int sum = root->left->val + root->right->val;\\n\\n        return root->val == sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        int sum = root->left->val + root->right->val;\\n\\n        return root->val == sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877448,
                "title": "2-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\n       if(root.val==root.left.val+root.right.val)return true;\\n       return false;\\n        \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\n       if(root.val==root.left.val+root.right.val)return true;\\n       return false;\\n        \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793957,
                "title": "root-equals-sum-of-children",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/d16f0b89-7c41-4ab2-8a87-436262395422_1689877762.281462.png)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val==root.left.val+root.right.val:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val==root.left.val+root.right.val:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757098,
                "title": "clean-and-easy-with-type-hinting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     public $val = null;\\n *     public $left = null;\\n *     public $right = null;\\n *     function __construct($val = 0, $left = null, $right = null) {\\n *         $this->val = $val;\\n *         $this->left = $left;\\n *         $this->right = $right;\\n *     }\\n * }\\n */\\nclass Solution\\n{\\n    function checkTree(TreeNode $root): bool\\n    {\\n        return $root->left->val + $root->right->val === $root->val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     public $val = null;\\n *     public $left = null;\\n *     public $right = null;\\n *     function __construct($val = 0, $left = null, $right = null) {\\n *         $this->val = $val;\\n *         $this->left = $left;\\n *         $this->right = $right;\\n *     }\\n * }\\n */\\nclass Solution\\n{\\n    function checkTree(TreeNode $root): bool\\n    {\\n        return $root->left->val + $root->right->val === $root->val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698924,
                "title": "2-line-sol-beats-100-c",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val==(root->left->val+root->right->val)) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val==(root->left->val+root->right->val)) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555807,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        int s=0;\\n        if(root.left!=null) s+=root.left.val;\\n        if(root.right!=null) s+=root.right.val;\\n        \\n        return (root.val==s && checkTree(root.left) && checkTree(root.right)) ;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        int s=0;\\n        if(root.left!=null) s+=root.left.val;\\n        if(root.right!=null) s+=root.right.val;\\n        \\n        return (root.val==s && checkTree(root.left) && checkTree(root.right)) ;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532202,
                "title": "swift-recursive-solution",
                "content": "Recursive solution:\\n```\\nclass Solution {\\n\\n    func sum(_ root: TreeNode?) -> Int {\\n        guard let root = root else {\\n            return 0\\n        }\\n\\n        return root.val + sum(root.left) + sum(root.right)\\n    }\\n\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n\\n        return root.val == sum(root.left) + sum(root.right)\\n    }\\n}\\n```\\n\\nOne liner:\\n\\n```\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        return (root?.val ?? -1) - (root?.left?.val ?? 0) - (root?.right?.val ?? 0) == 0\\n    }\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\n    func sum(_ root: TreeNode?) -> Int {\\n        guard let root = root else {\\n            return 0\\n        }\\n\\n        return root.val + sum(root.left) + sum(root.right)\\n    }\\n\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n\\n        return root.val == sum(root.left) + sum(root.right)\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        return (root?.val ?? -1) - (root?.left?.val ?? 0) - (root?.right?.val ?? 0) == 0\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505689,
                "title": "easiest-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\n        TreeNode node1 =root.left;\\n        TreeNode node2 = root.right;\\n        if(root.val == (node1.val+node2.val)) return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\n        TreeNode node1 =root.left;\\n        TreeNode node2 = root.right;\\n        if(root.val == (node1.val+node2.val)) return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456779,
                "title": "0-ms-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root.val==root.left.val+root.right.val)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root.val==root.left.val+root.right.val)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355187,
                "title": "java-sol-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if((root.left.val+root.right.val) == root.val){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if((root.left.val+root.right.val) == root.val){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160860,
                "title": "c-and-c-one-line-solution",
                "content": "\\n# C++\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->right->val + root->left->val == root->val;\\n        \\n    }\\n    \\n};\\n```\\n\\n# C Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nbool checkTree(struct TreeNode* root){\\n    return root->right->val + root->left->val == root->val;\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->right->val + root->left->val == root->val;\\n        \\n    }\\n    \\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nbool checkTree(struct TreeNode* root){\\n    return root->right->val + root->left->val == root->val;\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103175,
                "title": "root-equals-sum-of-children-using-kotlin-best-complexity-o-1",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Author: Mohamed Shaban Ahmed\\n\\n/**\\n * Example:\\n * var ti = TreeNode(5)\\n * var v = ti.`val`\\n * Definition for a binary tree node.\\n * class TreeNode(var `val`: Int) {\\n *     var left: TreeNode? = null\\n *     var right: TreeNode? = null\\n * }\\n */\\nclass Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return root!!.`val` == (root!!.left!!.`val` + root!!.right!!.`val`)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Tree"
                ],
                "code": "```\\n//Author: Mohamed Shaban Ahmed\\n\\n/**\\n * Example:\\n * var ti = TreeNode(5)\\n * var v = ti.`val`\\n * Definition for a binary tree node.\\n * class TreeNode(var `val`: Int) {\\n *     var left: TreeNode? = null\\n *     var right: TreeNode? = null\\n * }\\n */\\nclass Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return root!!.`val` == (root!!.left!!.`val` + root!!.right!!.`val`)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101716,
                "title": "2236-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Runtime : 0 ms\\n- Beats : 100%\\n- Memory : 39.6 MB\\n- Beats : 97.64%\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode r) {\\n        return r.val == r.left.val + r.right.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode r) {\\n        return r.val == r.left.val + r.right.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075269,
                "title": "dart-null-safety-solution",
                "content": "# Code\\n```\\nclass Solution {\\n  bool checkTree(TreeNode? root) {\\n      if (root == null) return false;\\n\\n      final leftValue = root.left?.val ?? 0;\\n      final rightValue = root.right?.val ?? 0;\\n\\n      return root.val == leftValue + rightValue;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  bool checkTree(TreeNode? root) {\\n      if (root == null) return false;\\n\\n      final leftValue = root.left?.val ?? 0;\\n      final rightValue = root.right?.val ?? 0;\\n\\n      return root.val == leftValue + rightValue;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063740,
                "title": "recursive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc checkTree(root *TreeNode) bool {\\n\\n     if root==nil {\\n         return true\\n     }\\n     sum:=0\\n     if root.Left!= nil {\\n         sum+=root.Left.Val\\n     }\\n      if root.Right!=nil {\\n          sum+=root.Right.Val\\n      }\\n      if sum==root.Val {\\n          return true\\n      } else {\\n          return false\\n      }\\n      sum=0\\n    return checkTree(root.Left) && checkTree(root.Right)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc checkTree(root *TreeNode) bool {\\n\\n     if root==nil {\\n         return true\\n     }\\n     sum:=0\\n     if root.Left!= nil {\\n         sum+=root.Left.Val\\n     }\\n      if root.Right!=nil {\\n          sum+=root.Right.Val\\n      }\\n      if sum==root.Val {\\n          return true\\n      } else {\\n          return false\\n      }\\n      sum=0\\n    return checkTree(root.Left) && checkTree(root.Right)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3031466,
                "title": "c-easy-2-lines-code-beats-100",
                "content": "# C++ Easy solution\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val == root->left->val + root->right->val) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val == root->left->val + root->right->val) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853865,
                "title": "go-one-line-solution",
                "content": "```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2839553,
                "title": "c-one-liner-beats-100-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->left->val+ root->right->val== root->val) ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->left->val+ root->right->val== root->val) ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784979,
                "title": "for-all-depths",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    \\n    void help(TreeNode* r, int &sum)\\n    {\\n        if(!r)\\n            return ;\\n        if(!r->left && !r->right)\\n            sum+=r->val;\\n        help(r->left,sum);\\n        help(r->right,sum);\\n        \\n        \\n    }\\n    bool checkTree(TreeNode* r) {\\n        \\n        if(!r)\\n            return true;\\n        \\n        int sum = 0;\\n        help(r,sum);\\n        return r->val == sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    \\n    void help(TreeNode* r, int &sum)\\n    {\\n        if(!r)\\n            return ;\\n        if(!r->left && !r->right)\\n            sum+=r->val;\\n        help(r->left,sum);\\n        help(r->right,sum);\\n        \\n        \\n    }\\n    bool checkTree(TreeNode* r) {\\n        \\n        if(!r)\\n            return true;\\n        \\n        int sum = 0;\\n        help(r,sum);\\n        return r->val == sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751619,
                "title": "one-line-solution-c",
                "content": "Assuming that in the constraints of the problem it is specified that each input has only 3 nodes including the root, and its two right and left nodes. We can simply return an equality check between the sum of the two nodes and the root.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    public:\\n        bool checkTree(TreeNode* root) {\\n            return (root->val == (root->left->val + root->right->val));\\n        }\\n};\\n```\\n\\n**If that helped, an upvote would be welcome.**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    public:\\n        bool checkTree(TreeNode* root) {\\n            return (root->val == (root->left->val + root->right->val));\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744252,
                "title": "ruby-five-different-ways",
                "content": "# Intuition\\nWe are given the root node that has access its left and right children. Simply call its left and right right children values and see if the add up to the root\\'s value. Keep in mind that each node in the tree has a val, left, and right attribute. \\n\\n##### Root:\\nroot => root\\n\\nroot value => root.val\\n\\n##### Root\\'s Left:\\nleft child => root.left\\n\\nleft child value => root.left.val\\n\\n\\n##### Root\\'s Right:\\nright child => root.right\\n\\nright child value => root.right.val\\n\\n# Complexity\\n- Time complexity: O(1)\\nGenerally speaking operations take O(1) time and accessing the immediate children of the root node is constant as well.   \\n\\n- Space complexity: O(1)\\nSince no additional data structures are created to perform the calculations. \\n\\n# Code\\n\\n### ternary operator\\n```\\n# ternary operator\\n# time: O(1) \\n# space: O(1)\\ndef check_tree(root)\\n    root.left.val + root.right.val == root.val ? true : false\\nend\\n```\\n\\n### implicit boolean return \\n```\\n# implicit boolean return \\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    root.val == root.left.val + root.right.val\\nend\\n```\\n\\n### complement\\n```\\n# complement\\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    root.left.val == root.val - root.right.val \\nend\\n```\\n\\n### conditional part 1\\n```\\n# conditional part 1\\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    if root.val == root.left.val + root.right.val\\n        return true\\n    else\\n        return false\\n    end\\nend\\n```\\nOne can omit the return statement\\n\\n### conditional part 2  \\n```\\n# conditional part 2 \\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    return true if root.val == root.left.val + root.right.val\\n    return false\\nend\\n```\\n\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# ternary operator\\n# time: O(1) \\n# space: O(1)\\ndef check_tree(root)\\n    root.left.val + root.right.val == root.val ? true : false\\nend\\n```\n```\\n# implicit boolean return \\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    root.val == root.left.val + root.right.val\\nend\\n```\n```\\n# complement\\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    root.left.val == root.val - root.right.val \\nend\\n```\n```\\n# conditional part 1\\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    if root.val == root.left.val + root.right.val\\n        return true\\n    else\\n        return false\\n    end\\nend\\n```\n```\\n# conditional part 2 \\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    return true if root.val == root.left.val + root.right.val\\n    return false\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2739176,
                "title": "python3-single-liner-code",
                "content": "python3 solution in just one line\\n\\n```\\nreturn root.val == (root.right.val + root.left.val);\\n```",
                "solutionTags": [],
                "code": "```\\nreturn root.val == (root.right.val + root.left.val);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2693206,
                "title": "cpp-easy-to-understand",
                "content": "```\\nbool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n            return false;\\n        else if(root->val==(root->left->val+root->right->val))\\n            return true;\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "```\\nbool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n            return false;\\n        else if(root->val==(root->left->val+root->right->val))\\n            return true;\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2655474,
                "title": "c-simple-recursive-solution",
                "content": "```\\n// Please, UpVote if you like it :)\\n// Runtime: 8 ms, faster than 25.96% of C++ online submissions for Root Equals Sum of Children.\\n// Memory Usage: 12.6 MB, less than 14.35% of C++ online submissions for Root Equals Sum of Children.\\nbool checkTree(TreeNode* root) {\\n\\tif (!root || !root->left && !root->right)\\n\\t\\treturn true;\\n\\treturn (root->val == ((root->left) ? root->left->val : 0) + ((root->right) ? root->right->val : 0)) &&\\n\\t\\tcheckTree(root->left) &&\\n\\t\\tcheckTree(root->right);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n// Please, UpVote if you like it :)\\n// Runtime: 8 ms, faster than 25.96% of C++ online submissions for Root Equals Sum of Children.\\n// Memory Usage: 12.6 MB, less than 14.35% of C++ online submissions for Root Equals Sum of Children.\\nbool checkTree(TreeNode* root) {\\n\\tif (!root || !root->left && !root->right)\\n\\t\\treturn true;\\n\\treturn (root->val == ((root->left) ? root->left->val : 0) + ((root->right) ? root->right->val : 0)) &&\\n\\t\\tcheckTree(root->left) &&\\n\\t\\tcheckTree(root->right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2639773,
                "title": "go-simple-solution-in-go-golang",
                "content": "Hello Gophers!\\n\\n# Problem: Root Equals Sum of Children (Easy)\\n\\n## Solution 1: One Line Solution\\n\\n```go\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val\\n}\\n```\\n\\n## Solution 2: Best Practice\\n\\nLet\\'s say we are not sure if `root` is not nil or if it has children:\\n\\n```go\\nfunc checkTree(root *TreeNode) bool {\\n    if root == nil {\\n        return false\\n    }\\n    var sum int = 0\\n    if root.Left != nil {\\n        sum += root.Left.Val\\n    }\\n    if root.Right != nil {\\n        sum += root.Right.Val\\n    }\\n    return root.Val == sum\\n}\\n```\\n\\nI hope it helped! =)",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val\\n}\\n```\n```go\\nfunc checkTree(root *TreeNode) bool {\\n    if root == nil {\\n        return false\\n    }\\n    var sum int = 0\\n    if root.Left != nil {\\n        sum += root.Left.Val\\n    }\\n    if root.Right != nil {\\n        sum += root.Right.Val\\n    }\\n    return root.Val == sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2602398,
                "title": "c-starightforward",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593043,
                "title": "one-liner-pythonic-way",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2569744,
                "title": "java-one-liner",
                "content": "Please Upvote if Helpful\\n\\n***\\n\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\n\\n***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567885,
                "title": "python3-one-line-solution",
                "content": "```\\nreturn root.val == root.left.val + root.right.val\\n```",
                "solutionTags": [],
                "code": "```\\nreturn root.val == root.left.val + root.right.val\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2530043,
                "title": "c-solution-one-line-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == (root->left->val + root->right->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == (root->left->val + root->right->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529742,
                "title": "python-easy-solution",
                "content": "```python\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        def subtreeSum(node: Optional[TreeNode], value) -> int:\\n            if not node:\\n                return 0\\n\\n            return value + subtreeSum(node.left, node.val) + subtreeSum(node.right, node.val)\\n\\n        return root.val == (subtreeSum(root.left, root.left.val) + subtreeSum(root.right, root.right.val))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        def subtreeSum(node: Optional[TreeNode], value) -> int:\\n            if not node:\\n                return 0\\n\\n            return value + subtreeSum(node.left, node.val) + subtreeSum(node.right, node.val)\\n\\n        return root.val == (subtreeSum(root.left, root.left.val) + subtreeSum(root.right, root.right.val))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526561,
                "title": "java-simple-one-line-solution-the-most-minimalistic-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\t\\treturn root.val == root.left.val + root.right.val;\\n\\t}\\n}\\n```\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\t\\treturn root.val == root.left.val + root.right.val;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507139,
                "title": "java-solution-faster-than-100-00-of-submissions",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if (root == null) \\n            return false;\\n        else \\n            return (root.val == root.left.val + root.right.val); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if (root == null) \\n            return false;\\n        else \\n            return (root.val == root.left.val + root.right.val); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503005,
                "title": "javascript-sol",
                "content": "```\\nvar checkTree = function (root) {\\n    let node = root.val;\\n    let left = root.left.val;\\n    let right = root.right.val;\\n\\n    if (node == (left + right)) { return true }\\n    return false\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkTree = function (root) {\\n    let node = root.val;\\n    let left = root.left.val;\\n    let right = root.right.val;\\n\\n    if (node == (left + right)) { return true }\\n    return false\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2495069,
                "title": "javascript",
                "content": "```\\nconst checkTree = (root) => root.val === (root.right.val + root.left.val)\\n```\\n\\nRuntime: 62 ms, faster than 96.61% of JavaScript online submissions for Root Equals Sum of Children.\\nMemory Usage: 42.2 MB, less than 98.62% of JavaScript online submissions for Root Equals Sum of Children.",
                "solutionTags": [],
                "code": "```\\nconst checkTree = (root) => root.val === (root.right.val + root.left.val)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2480656,
                "title": "c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val==root->left->val+root->right->val)\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val==root->left->val+root->right->val)\\n            return true;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2475103,
                "title": "2236-root-equals-sum-of-children",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        if(root->left->val + root->right->val == root->val)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        if(root->left->val + root->right->val == root->val)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465225,
                "title": "java-1-line-easy",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448051,
                "title": "single-line-solution-clean-c-code",
                "content": "# If you liked this solution then do upvote.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440740,
                "title": "java-1-liner-1ms",
                "content": "# Please Upvote\\n\\n```\\nreturn root.val == (root.right.val + root.left.val);\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nreturn root.val == (root.right.val + root.left.val);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2420305,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val==(root.left).val+(root.right).val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val==(root.left).val+(root.right).val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1693829,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1564888,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1565649,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1735919,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1925445,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1570895,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1861691,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1726629,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1698119,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1576632,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1693829,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1564888,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1565649,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1735919,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1925445,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1570895,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1861691,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1726629,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1698119,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1576632,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 2047005,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 1945995,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 1737102,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2047791,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2001533,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 1998810,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2058053,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2051470,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2046940,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2046108,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 1997803,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1991957,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1990410,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1936881,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1926382,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1922463,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1903034,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1878259,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1853444,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1842313,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Resultant Array After Removing Anagrams",
        "question_content": "<p>You are given a <strong>0-indexed</strong> string array <code>words</code>, where <code>words[i]</code> consists of lowercase English letters.</p>\n\n<p>In one operation, select any index <code>i</code> such that <code>0 &lt; i &lt; words.length</code> and <code>words[i - 1]</code> and <code>words[i]</code> are <strong>anagrams</strong>, and <strong>delete</strong> <code>words[i]</code> from <code>words</code>. Keep performing this operation as long as you can select an index that satisfies the conditions.</p>\n\n<p>Return <code>words</code> <em>after performing all operations</em>. It can be shown that selecting the indices for each operation in <strong>any</strong> arbitrary order will lead to the same result.</p>\n\n<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once. For example, <code>&quot;dacb&quot;</code> is an anagram of <code>&quot;abdc&quot;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;abba&quot;,&quot;baba&quot;,&quot;bbaa&quot;,&quot;cd&quot;,&quot;cd&quot;]\n<strong>Output:</strong> [&quot;abba&quot;,&quot;cd&quot;]\n<strong>Explanation:</strong>\nOne of the ways we can obtain the resultant array is by using the following operations:\n- Since words[2] = &quot;bbaa&quot; and words[1] = &quot;baba&quot; are anagrams, we choose index 2 and delete words[2].\n  Now words = [&quot;abba&quot;,&quot;baba&quot;,&quot;cd&quot;,&quot;cd&quot;].\n- Since words[1] = &quot;baba&quot; and words[0] = &quot;abba&quot; are anagrams, we choose index 1 and delete words[1].\n  Now words = [&quot;abba&quot;,&quot;cd&quot;,&quot;cd&quot;].\n- Since words[2] = &quot;cd&quot; and words[1] = &quot;cd&quot; are anagrams, we choose index 2 and delete words[2].\n  Now words = [&quot;abba&quot;,&quot;cd&quot;].\nWe can no longer perform any operations, so [&quot;abba&quot;,&quot;cd&quot;] is the final answer.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]\n<strong>Output:</strong> [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]\n<strong>Explanation:</strong>\nNo two adjacent strings in words are anagrams of each other, so no operations are performed.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2040664,
                "title": "java-easy-two-methods-clean-simple",
                "content": "**Method 1**\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev =\"\";\\n        List<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```\\n\\n**Method 2**\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        Stack<String> stack = new Stack<>();\\n        for(int i = words.length-1;i>= 0;i--){\\n            String s = words[i];\\n            while(!stack.isEmpty() && anagram(stack.peek(),s) == true)stack.pop();\\n            stack.push(s);\\n        }\\n        List<String> res = new ArrayList<>();\\n        while(!stack.isEmpty())res.add(stack.pop());\\n        return res;\\n    }\\n    \\n    public boolean anagram(String p,String q){\\n        int arr[] = new int[26];\\n        for(char i : p.toCharArray())arr[i-\\'a\\']+=1;\\n        for(char i : q.toCharArray())arr[i-\\'a\\']-=1;\\n        for(int i : arr)if(i != 0)return false;\\n        return true;\\n    }\\n}\\n```\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev =\"\";\\n        List<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        Stack<String> stack = new Stack<>();\\n        for(int i = words.length-1;i>= 0;i--){\\n            String s = words[i];\\n            while(!stack.isEmpty() && anagram(stack.peek(),s) == true)stack.pop();\\n            stack.push(s);\\n        }\\n        List<String> res = new ArrayList<>();\\n        while(!stack.isEmpty())res.add(stack.pop());\\n        return res;\\n    }\\n    \\n    public boolean anagram(String p,String q){\\n        int arr[] = new int[26];\\n        for(char i : p.toCharArray())arr[i-\\'a\\']+=1;\\n        for(char i : q.toCharArray())arr[i-\\'a\\']-=1;\\n        for(int i : arr)if(i != 0)return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039752,
                "title": "weird-description",
                "content": "Misread this question 2 times and wasted like 20 minutes. \\n\\n**Python 3**\\nWanted to bubble-up this solution by one of our humble commenters below (whose name rhymes with batman). \\n\\nApparently, `itertools.groupby` groups *consecutive* elements by a key (which is `sorted` here). And `next` takes the first element from that group.\\n\\nIt pays to learn vast and powerful Python libraries.\\n\\n```python\\nclass Solution:\\n    def removeAnagrams(self, w: List[str]) -> List[str]:\\n        return [next(g) for _, g in groupby(w, sorted)]\\n```\\n\\nOriginal Solution\\n```python\\nclass Solution:\\n    def removeAnagrams(self, w: List[str]) -> List[str]:\\n        return [w[i] for i in range(0, len(w)) if i == 0 or sorted(w[i]) != sorted(w[i - 1])]\\n```\\n#### Silly Hash\\nThis solution won\\'t work if there are hash collisions (unless we add a check). The idea is to compute a hash using characters value but not position. \\n\\nIf the size of words is limited to 10, computing a hash would be faster than comparing counter for 26 characters.\\n\\n**C++**\\n```cpp\\nvector<string> removeAnagrams(vector<string>& words) {\\n    long long hash = -1;\\n    vector<string> res;\\n    for (auto &w : words)\\n        if (auto new_hash = accumulate(begin(w), end(w), 0LL, [](long long s, char ch){ return s + (1 << (ch - \\'a\\')); });\\n            hash != new_hash) {\\n            res.push_back(w);\\n            hash = new_hash;\\n        }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def removeAnagrams(self, w: List[str]) -> List[str]:\\n        return [next(g) for _, g in groupby(w, sorted)]\\n```\n```python\\nclass Solution:\\n    def removeAnagrams(self, w: List[str]) -> List[str]:\\n        return [w[i] for i in range(0, len(w)) if i == 0 or sorted(w[i]) != sorted(w[i - 1])]\\n```\n```cpp\\nvector<string> removeAnagrams(vector<string>& words) {\\n    long long hash = -1;\\n    vector<string> res;\\n    for (auto &w : words)\\n        if (auto new_hash = accumulate(begin(w), end(w), 0LL, [](long long s, char ch){ return s + (1 << (ch - \\'a\\')); });\\n            hash != new_hash) {\\n            res.push_back(w);\\n            hash = new_hash;\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039931,
                "title": "2-pointers-without-sorting",
                "content": "**Description**:\\n+ For every we will put our **first pointer** at a string and **second pointer** at the next position of first pointer.\\n+ Keep on moving the **second pointer** by one step ahead if the string it is pointing is a anagram of string at **first pointer**.\\n+  If we found a string pointed by **second pointer** is not an anagram of string at first pointer then put string at **first pointer** in the answer array.\\n\\n> Instead of deleting words, we will skip it, this will save our time.\\n\\n# C++\\n\\n    vector<string> removeAnagrams(vector<string>& A) {\\n        vector<string> ans;\\n        int n= size(A);\\n        for(int i=0;i<n;){\\n            int j=i+1;\\n            while( j<n and isang(A[i],A[j]) ) j++;\\n            ans.push_back(A[i]);\\n            i=j;\\n        }\\n        return ans;\\n    }\\n    //function for checking if two string are anagrams or not\\n    bool isang(string p,string q){\\n        vector<int> cnt(26);\\n        int res=0;\\n        for(auto i:p) cnt[i-\\'a\\']++;\\n        for(auto i:q) cnt[i-\\'a\\']--;         \\n        for(auto i:cnt) if(i!=0) return false;\\n        return true;\\n    }\\n\\n# Java\\n    public List<String> removeAnagrams(String[] A) {\\n        List<String> ans= new ArrayList<>();\\n        int n= A.length;\\n        for(int i=0;i<n;){\\n            int j=i+1;\\n            while( j<n && isang(A[i],A[j]) ) j++;\\n            ans.add(A[i]);\\n            i=j;\\n        }\\n        return ans;\\n    }\\n    //function for checking if two string are anagrams or not\\n    boolean isang(String p,String q){\\n        int[] cnt= new int[26];\\n        int res=0;\\n        for(int i=0;i<p.length();i++) cnt[p.charAt(i)-\\'a\\']++;\\n        for(int i=0;i<q.length();i++) cnt[q.charAt(i)-\\'a\\']--;\\n        for(int i:cnt) if(i!=0) return false;\\n        return true;\\n    }\\n\\t\\nTime - O(N * M)\\nSpace - O(1)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "**Description**:\\n+ For every we will put our **first pointer** at a string and **second pointer** at the next position of first pointer.\\n+ Keep on moving the **second pointer** by one step ahead if the string it is pointing is a anagram of string at **first pointer**.\\n+  If we found a string pointed by **second pointer** is not an anagram of string at first pointer then put string at **first pointer** in the answer array.\\n\\n> Instead of deleting words, we will skip it, this will save our time.\\n\\n# C++\\n\\n    vector<string> removeAnagrams(vector<string>& A) {\\n        vector<string> ans;\\n        int n= size(A);\\n        for(int i=0;i<n;){\\n            int j=i+1;\\n            while( j<n and isang(A[i],A[j]) ) j++;\\n            ans.push_back(A[i]);\\n            i=j;\\n        }\\n        return ans;\\n    }\\n    //function for checking if two string are anagrams or not\\n    bool isang(string p,string q){\\n        vector<int> cnt(26);\\n        int res=0;\\n        for(auto i:p) cnt[i-\\'a\\']++;\\n        for(auto i:q) cnt[i-\\'a\\']--;         \\n        for(auto i:cnt) if(i!=0) return false;\\n        return true;\\n    }\\n\\n# Java\\n    public List<String> removeAnagrams(String[] A) {\\n        List<String> ans= new ArrayList<>();\\n        int n= A.length;\\n        for(int i=0;i<n;){\\n            int j=i+1;\\n            while( j<n && isang(A[i],A[j]) ) j++;\\n            ans.add(A[i]);\\n            i=j;\\n        }\\n        return ans;\\n    }\\n    //function for checking if two string are anagrams or not\\n    boolean isang(String p,String q){\\n        int[] cnt= new int[26];\\n        int res=0;\\n        for(int i=0;i<p.length();i++) cnt[p.charAt(i)-\\'a\\']++;\\n        for(int i=0;i<q.length();i++) cnt[q.charAt(i)-\\'a\\']--;\\n        for(int i:cnt) if(i!=0) return false;\\n        return true;\\n    }\\n\\t\\nTime - O(N * M)\\nSpace - O(1)",
                "codeTag": "Unknown"
            },
            {
                "id": 2039775,
                "title": "easy-c-solution-using-sorting",
                "content": "We take the first element and sort it to compare it with the second element.\\nIf both elements or strings are equal, we then delete ith element, else we go to next element.\\n\\n**Why are we doing i--? :**\\n```\\nOkay, lets take an array a= [\"abb\", \"bax\", \"xab\", \"axb\"]\\nsuppose we start loop, following are the iterations:\\nloop 1: compare \"bax\" with \"abb\", not anagram\\nloop 2: compare \"xab\" with \"bax\", it is anagram and we delete i th(2th) element, i.e, \"xab\", now array is = [\"abb\", \"bax\", \"axb\"];\\n            now i is still 2, we increment it by 3. Since 3>sizeof(arr) we get out of the loop.\\n            See, \"bax\" and \"axb\" are still anagram and we are not checking them.\\n            So while deleting element we decrease size of i, so that we make sure to compare the left elements.\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1;i<words.size();i++){\\n            string x = words[i];\\n            sort(x.begin(),x.end());\\n            string y = words[i-1];\\n            sort(y.begin(),y.end());\\n            if(x == y){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```\\n\\n\\n\\nHope you get it now :)",
                "solutionTags": [],
                "code": "```\\nOkay, lets take an array a= [\"abb\", \"bax\", \"xab\", \"axb\"]\\nsuppose we start loop, following are the iterations:\\nloop 1: compare \"bax\" with \"abb\", not anagram\\nloop 2: compare \"xab\" with \"bax\", it is anagram and we delete i th(2th) element, i.e, \"xab\", now array is = [\"abb\", \"bax\", \"axb\"];\\n            now i is still 2, we increment it by 3. Since 3>sizeof(arr) we get out of the loop.\\n            See, \"bax\" and \"axb\" are still anagram and we are not checking them.\\n            So while deleting element we decrease size of i, so that we make sure to compare the left elements.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1;i<words.size();i++){\\n            string x = words[i];\\n            sort(x.begin(),x.end());\\n            string y = words[i-1];\\n            sort(y.begin(),y.end());\\n            if(x == y){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039991,
                "title": "python-beginner-friendly-explanation-with-time-and-space-complexity-analysis",
                "content": "Two words are condidered as **anagram** if they have the same letters with exactly same letter counts. The order of the letters in the words does not matter.\\n\\n`E.g.: abbaa, aabab, aabbb, bbaaa, etc.. are all anagrams of each other as both have 2 letters \\'a\\' and \\'b\\' and both the letters in all the words have the same count, i.e., |a| = 3 and |b| = 2`.\\n\\nNow Since, the order doesn\\'t matter, **sorting them all will make them equal**. \\nE.g.: In the above example, if we sort all the words we get \\'aaabb\\'. Which means all of them are anagrams of each other.\\n\\nI hope finding anagrams is clear.\\n\\nNow, if word[i] and word[i+1] are anagrams, then remove word[i + 1] from the list, do not increment the index and compare again, else ignore and increment the index.\\n\\nThe full code (***written during contest***) is given below:\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while i < len(words) - 1:\\n            if sorted(words[i]) == sorted(words[i + 1]):\\n                words.remove(words[i + 1])\\n                continue\\n            i += 1\\n        return words\\n```\\n\\n**Time and Space complexity Analysis:**\\n* Let n = size of words array, and m = max length of a word.\\n\\nThe loop runs for \\'n\\' times and sorting takes \\'mlogm\\' time, and both are nested (done simultaneously).  Hence, **time complexity = O(n * mlogm)**.\\nNote that the time complexity can be easily reduced to ***O(n *  m)*** as finding anagrams can be done efficiently in O(m) time.\\nWe do not use any extra space, so space complexity = O(1) but sorting takes some internal space O(m). Thus, **space complexity = O(m)**.\\n\\nDo Upvote, if helpful.\\n\\n**EDIT:** The corresponding one liner for the above code (inspired from votrubac):\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        return [words[i] for i in range(0, len(words)) if i == 0 or sorted(words[i]) != sorted(words[i - 1])]\\n```\\n\\n***But wait can\\'t we do better?***\\n\\nYes actually, we can still reduce the time complexity. \\n\\n**Idea:** As anagrams must have same letters with same letter counts. We can count each letter in both the strings in O(n) time and match their counts in O(n) time sequentially (not simultaneously). Hence, **optimized time complexity** = O(n + n)  **= O(n)**.\\n\\nCan we reduce the sapce complexity?? => We will see after this code.\\n\\nThe **optimized solution** is given below:\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        def get_counts(x):\\n            \"\"\"\\n            As there are only 26 alphabets, make an array of constant size = 26 \\n            such that its index 0 maps to letter \\'a\\', 1 maps to \\'b\\' and so on...\\n            upto index 25 that maps to letter \\'z\\'\\n            \\n            E.g.: If we want count of letter \\'c\\', we will get it from count[2], \\n                  as index 2 maps to letter \\'c\\'.\\n                  \\n            But how will we do the mapping?\\n            \\n            There is a function in Python that returns a corresponding integer value for a character.\\n            \\n            ord(c) => return ordinal value of character \\'c\\'.\\n            \\n            index of a = 0 right? => ord(\\'a\\') - ord(\\'a\\')\\n            index of b = 1        => ord(\\'b\\') - ord(\\'a\\')\\n            .\\n            .\\n            .\\n            index of z = 25       => ord(\\'z\\') - ord(\\'a\\')\\n            \\n            \"\"\"\\n            count = [0] * 26 \\n            for c in x:\\n                count[ord(c) - ord(\\'a\\')] += 1\\n            return count\\n        \\n        \\n        if not words:\\n            return []\\n        \\n        \\n        i = 0\\n        while i < len(words) - 1:\\n            # just replace sort function by get_count functions\\n            if get_counts(words[i]) == get_counts(words[i + 1]):\\n                words.remove(words[i + 1])\\n                continue\\n            i += 1\\n        return words\\n```\\n\\nIn the above code we have used a list, but it is always fixed in size (= 26 integers). Also apart from the list, we have used only fixed sized variables.\\n\\nSo **optimized space complexity = O(1)** = constant.\\n\\n`Hope it helps.` ***UPVOTE***.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while i < len(words) - 1:\\n            if sorted(words[i]) == sorted(words[i + 1]):\\n                words.remove(words[i + 1])\\n                continue\\n            i += 1\\n        return words\\n```\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        return [words[i] for i in range(0, len(words)) if i == 0 or sorted(words[i]) != sorted(words[i - 1])]\\n```\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        def get_counts(x):\\n            \"\"\"\\n            As there are only 26 alphabets, make an array of constant size = 26 \\n            such that its index 0 maps to letter \\'a\\', 1 maps to \\'b\\' and so on...\\n            upto index 25 that maps to letter \\'z\\'\\n            \\n            E.g.: If we want count of letter \\'c\\', we will get it from count[2], \\n                  as index 2 maps to letter \\'c\\'.\\n                  \\n            But how will we do the mapping?\\n            \\n            There is a function in Python that returns a corresponding integer value for a character.\\n            \\n            ord(c) => return ordinal value of character \\'c\\'.\\n            \\n            index of a = 0 right? => ord(\\'a\\') - ord(\\'a\\')\\n            index of b = 1        => ord(\\'b\\') - ord(\\'a\\')\\n            .\\n            .\\n            .\\n            index of z = 25       => ord(\\'z\\') - ord(\\'a\\')\\n            \\n            \"\"\"\\n            count = [0] * 26 \\n            for c in x:\\n                count[ord(c) - ord(\\'a\\')] += 1\\n            return count\\n        \\n        \\n        if not words:\\n            return []\\n        \\n        \\n        i = 0\\n        while i < len(words) - 1:\\n            # just replace sort function by get_count functions\\n            if get_counts(words[i]) == get_counts(words[i + 1]):\\n                words.remove(words[i + 1])\\n                continue\\n            i += 1\\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039961,
                "title": "easy-cpp-solution-for-beginners-simple",
                "content": "```\\n\\nclass Solution {\\npublic:\\n\\nvector<string> removeAnagrams(vector<string>& w) {\\n   vector<string>ans;\\n\\n\\tstring x=w[0];\\n\\tans.push_back(x);\\n\\tsort(x.begin(), x.end());\\n\\n\\n\\tfor(int i=1;i<w.size();i++){\\n\\t\\tstring z=w[i];\\n\\t\\tsort(z.begin(), z.end());\\n\\t\\tif(x==z)\\n\\t\\t\\tcontinue;\\n\\t\\telse{\\n\\t\\t\\tans.push_back(w[i]);\\n\\t\\t\\tx=z;\\n\\t\\t}\\n\\n        }\\n      \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\nvector<string> removeAnagrams(vector<string>& w) {\\n   vector<string>ans;\\n\\n\\tstring x=w[0];\\n\\tans.push_back(x);\\n\\tsort(x.begin(), x.end());\\n\\n\\n\\tfor(int i=1;i<w.size();i++){\\n\\t\\tstring z=w[i];\\n\\t\\tsort(z.begin(), z.end());\\n\\t\\tif(x==z)\\n\\t\\t\\tcontinue;\\n\\t\\telse{\\n\\t\\t\\tans.push_back(w[i]);\\n\\t\\t\\tx=z;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2039900,
                "title": "python-3-intuitive-how-to-approach-o-n-without-sorting",
                "content": "# Goal\\nReturn the list of words after removing anagrams\\n\\n\\n# Approach\\n## 1. How do we know if those words have the same anagram? \\n\\nThose words have the same anagram if the words have the same letters even though they have different orders of letters.\\n\\n\"baby\" and \"ybba\" are anagrams because they have 2b, 1a, and 1y. It means we count the letters in the word. So, to solve this problem, we need to store the counter of the letter of the word as a key tuple in the dictionary (hashmap) and the value will be the word itself. To make it easier, the counter of the letter will be the list of 26 integers with 0 as the initialized number.\\n\\ne.g \\n- \"ab\" will be [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n- \"bapak\" will be [2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n\\n## 2. What if the counter of letters as key tuple exists in anagram? \\n\\nCheck if the previous word doesn\\'t have the same anagram, we can put the current word into result\\n\\nE.g words = [\"ab\", \"c\", \"ba\"]\\n1. \"ab\", we will have dictionary:\\n{(1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0): \\'ab\\'}\\n2. \"c\" we will have dictionary: {(1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0): \\'ab\\', (0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0): \\'c\\'}\\n3. We know that the counter of phrase \"ba\" will be (1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) which is already exist in the dictionary. \\n\\nSo, does it mean we exclude phrase \"ba\"? The answer is NO because we should check the previous word == the word already stored in the same tuple counter or not. You could take a look the rule in the problem description that `select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words`. Therefore, if it\\'s not the same, we should include the word.\\n\\nCode:\\n\\n```python\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    res = []\\n    anagrams = {}\\n\\n    for i in range(len(words)):\\n      word = words[i]\\n      counter = [0]*26\\n      for c in word:\\n        counter[ord(c)-ord(\\'a\\')] += 1\\n\\n      if tuple(counter) not in anagrams:\\n        res.append(word)\\n      else:\\n        if anagrams[tuple(counter)] != words[i-1]:\\n          res.append(word)\\n      anagrams[tuple(counter)] = word\\n    return res\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n# Can we do better?\\nYes, we can improve the space complexity slightly better by getting rid of the dictionary (hashmap). We just need to store the previous into the previous list. Thanks @codebreaker176 for the better code.\\n\\n```python\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    res = []\\n    prev = []\\n\\n    for i in range(len(words)):\\n      word = words[i]\\n      counter = [0]*26\\n      for c in word:\\n        counter[ord(c)-ord(\\'a\\')] += 1\\n\\n      if counter != prev:\\n        res.append(word)\\n        prev = counter\\n    return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    res = []\\n    anagrams = {}\\n\\n    for i in range(len(words)):\\n      word = words[i]\\n      counter = [0]*26\\n      for c in word:\\n        counter[ord(c)-ord(\\'a\\')] += 1\\n\\n      if tuple(counter) not in anagrams:\\n        res.append(word)\\n      else:\\n        if anagrams[tuple(counter)] != words[i-1]:\\n          res.append(word)\\n      anagrams[tuple(counter)] = word\\n    return res\\n```\n```python\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    res = []\\n    prev = []\\n\\n    for i in range(len(words)):\\n      word = words[i]\\n      counter = [0]*26\\n      for c in word:\\n        counter[ord(c)-ord(\\'a\\')] += 1\\n\\n      if counter != prev:\\n        res.append(word)\\n        prev = counter\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832345,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1;i<words.size();i++){\\n            string x = words[i];\\n            sort(x.begin(),x.end());\\n            string y = words[i-1];\\n            sort(y.begin(),y.end());\\n            if(x == y){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1;i<words.size();i++){\\n            string x = words[i];\\n            sort(x.begin(),x.end());\\n            string y = words[i-1];\\n            sort(y.begin(),y.end());\\n            if(x == y){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044880,
                "title": "python-counter-clean-code",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        for i in range(1,len(words)):\\n            if Counter(res[-1]) != Counter(words[i]):\\n                res.append(words[i])\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        for i in range(1,len(words)):\\n            if Counter(res[-1]) != Counter(words[i]):\\n                res.append(words[i])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2045774,
                "title": "c-solution-with-picture-explanation-two-pointer-easy-solution",
                "content": "This is two-pointer approach. Keep the first pointer at the start of the array and keep moving the second pointer until you find a string which is not the anagram of the first pointer. Just when you find the desired string, move the first pointer to this position and start moving the second pointer ahead again.\\n\\n\\n![image](https://assets.leetcode.com/users/images/e705fbef-1f81-4183-a1d7-a18480ad6fa6_1652728455.4177735.jpeg)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {        \\n        vector<string> resultant_array;\\n        \\n\\t\\t// Keeping the first pointer at index 0 and the second pointer at index 1\\n        int ptr1 = 0;\\n        int ptr2 = 1;\\n        \\n        while(ptr2<=words.size()){\\n            string s1 = words[ptr1];\\n            sort(s1.begin(),s1.end());\\n            \\n            resultant_array.push_back(words[ptr1]);\\n            \\n            while(ptr2<words.size()){\\n                string s2 = words[ptr2];\\n                sort(s2.begin(), s2.end());\\n                \\n\\t\\t\\t\\t// Remember to compare the sorted arrays to check for anagrams\\n                if(s1!=s2){\\n                    break;\\n                }\\n                else{\\n                    ptr2++;\\n                }\\n            }\\n            \\n            ptr1 = ptr2;\\n            ptr2++;\\n        }\\n        \\n        return resultant_array;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {        \\n        vector<string> resultant_array;\\n        \\n\\t\\t// Keeping the first pointer at index 0 and the second pointer at index 1\\n        int ptr1 = 0;\\n        int ptr2 = 1;\\n        \\n        while(ptr2<=words.size()){\\n            string s1 = words[ptr1];\\n            sort(s1.begin(),s1.end());\\n            \\n            resultant_array.push_back(words[ptr1]);\\n            \\n            while(ptr2<words.size()){\\n                string s2 = words[ptr2];\\n                sort(s2.begin(), s2.end());\\n                \\n\\t\\t\\t\\t// Remember to compare the sorted arrays to check for anagrams\\n                if(s1!=s2){\\n                    break;\\n                }\\n                else{\\n                    ptr2++;\\n                }\\n            }\\n            \\n            ptr1 = ptr2;\\n            ptr2++;\\n        }\\n        \\n        return resultant_array;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162725,
                "title": "c-easiest-beginner-friendly-sol-o-n-m-26-time-and-o-n-m-space",
                "content": "# Intuition of this Problem:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Create a vector called \"count\" with 26 elements, all initialized to 0.\\n2. Compare the length of two strings, if they are not equal, return false.\\n3. Increment the count of elements in \"count\" corresponding to the characters in string s and decrement the count of elements corresponding to the characters in string t.\\n4. Call the function \"countAllZeroes\" to check if all elements in \"count\" are 0, if yes return true, otherwise return false.\\n5. Create a vector called \"uniqueWords\" and insert the first element of the \"words\" vector into it.\\n6. Loop through the rest of the \"words\" vector and compare the current word with the previous word in \"uniqueWords\". If they are anagrams, skip this word and continue with the next word. If they are not anagrams, insert this word into \"uniqueWords\".\\n7. Return \"uniqueWords\".\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    bool countAllZeroes(vector<int>& count) {\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool isAnagram(string s, string t) {\\n        int n = s.length();\\n        int m = t.length();\\n        if (n != m)\\n            return false;\\n        vector<int> count(26, 0);\\n        for (int i = 0; i < n; i++) {\\n            count[s[i] - \\'a\\']++;\\n            count[t[i] - \\'a\\']--;\\n        }\\n        if (countAllZeroes(count) == true)\\n            return true;\\n        return false;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> uniqueWords;\\n        uniqueWords.push_back(words[0]);\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isAnagram(words[i-1], words[i]))\\n                continue;\\n            else\\n                uniqueWords.push_back(words[i]);\\n        }\\n        return uniqueWords;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean countAllZeroes(int[] count) {\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean isAnagram(String s, String t) {\\n        int n = s.length();\\n        int m = t.length();\\n        if (n != m)\\n            return false;\\n        int[] count = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n            count[t.charAt(i) - \\'a\\']--;\\n        }\\n        if (countAllZeroes(count) == true)\\n            return true;\\n        return false;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> uniqueWords = new ArrayList<>();\\n        uniqueWords.add(words[0]);\\n        for (int i = 1; i < words.length; i++) {\\n            if (isAnagram(words[i-1], words[i]))\\n                continue;\\n            else\\n                uniqueWords.add(words[i]);\\n        }\\n        return uniqueWords;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def countAllZeroes(self, count):\\n        for i in range(26):\\n            if count[i] != 0:\\n                return False\\n        return True\\n    \\n    def isAnagram(self, s, t):\\n        n = len(s)\\n        m = len(t)\\n        if n != m:\\n            return False\\n        count = [0] * 26\\n        for i in range(n):\\n            count[ord(s[i]) - ord(\\'a\\')] += 1\\n            count[ord(t[i]) - ord(\\'a\\')] -= 1\\n        if self.countAllZeroes(count) == True:\\n            return True\\n        return False\\n    \\n    def removeAnagrams(self, words):\\n        uniqueWords = []\\n        uniqueWords.append(words[0])\\n        for i in range(1, len(words)):\\n            if self.isAnagram(words[i-1], words[i]):\\n                continue\\n            else:\\n                uniqueWords.append(words[i])\\n        return uniqueWords\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n * m * 26)**, where n is the number of words in the given list and m is the maximum length of a word. This is because for each pair of words, the time taken to check if they are anagrams of each other is O(m * 26), and this operation is repeated for n-1 pairs, giving us a time complexity of O(n * m * 26).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n * m)**, where n is the number of words in the given list and m is the maximum length of a word. This is because we are using a list uniqueWords to store the unique words, and its length can be at most n.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool countAllZeroes(vector<int>& count) {\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool isAnagram(string s, string t) {\\n        int n = s.length();\\n        int m = t.length();\\n        if (n != m)\\n            return false;\\n        vector<int> count(26, 0);\\n        for (int i = 0; i < n; i++) {\\n            count[s[i] - \\'a\\']++;\\n            count[t[i] - \\'a\\']--;\\n        }\\n        if (countAllZeroes(count) == true)\\n            return true;\\n        return false;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> uniqueWords;\\n        uniqueWords.push_back(words[0]);\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isAnagram(words[i-1], words[i]))\\n                continue;\\n            else\\n                uniqueWords.push_back(words[i]);\\n        }\\n        return uniqueWords;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean countAllZeroes(int[] count) {\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean isAnagram(String s, String t) {\\n        int n = s.length();\\n        int m = t.length();\\n        if (n != m)\\n            return false;\\n        int[] count = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n            count[t.charAt(i) - \\'a\\']--;\\n        }\\n        if (countAllZeroes(count) == true)\\n            return true;\\n        return false;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> uniqueWords = new ArrayList<>();\\n        uniqueWords.add(words[0]);\\n        for (int i = 1; i < words.length; i++) {\\n            if (isAnagram(words[i-1], words[i]))\\n                continue;\\n            else\\n                uniqueWords.add(words[i]);\\n        }\\n        return uniqueWords;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def countAllZeroes(self, count):\\n        for i in range(26):\\n            if count[i] != 0:\\n                return False\\n        return True\\n    \\n    def isAnagram(self, s, t):\\n        n = len(s)\\n        m = len(t)\\n        if n != m:\\n            return False\\n        count = [0] * 26\\n        for i in range(n):\\n            count[ord(s[i]) - ord(\\'a\\')] += 1\\n            count[ord(t[i]) - ord(\\'a\\')] -= 1\\n        if self.countAllZeroes(count) == True:\\n            return True\\n        return False\\n    \\n    def removeAnagrams(self, words):\\n        uniqueWords = []\\n        uniqueWords.append(words[0])\\n        for i in range(1, len(words)):\\n            if self.isAnagram(words[i-1], words[i]):\\n                continue\\n            else:\\n                uniqueWords.append(words[i])\\n        return uniqueWords\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753693,
                "title": "java-easy-solution",
                "content": "class Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        list.add(words[0]);\\n        for(int i=1;i<words.length;i++){\\n            if(!isAnagram(words[i-1],words[i])){\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n    \\n     public boolean isAnagram(String s, String t) {\\n        char[] ss = s.toCharArray();\\n        Arrays.sort(ss);\\n         String s1 = new String(ss);\\n        \\n        char[] tt = t.toCharArray();\\n       Arrays.sort(tt);\\n         String s2 = new String(tt);\\n       \\n        \\n        return s1.equals(s2);\\n    }\\n}\\n// please upvote if it helps :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        list.add(words[0]);\\n        for(int i=1;i<words.length;i++){\\n            if(!isAnagram(words[i-1],words[i])){\\n                list.add(words[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3154408,
                "title": "python-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while True:\\n            if i == len(words)-1:\\n                break\\n            if \\'\\'.join(sorted(words[i])) == \\'\\'.join(sorted(words[i+1])):\\n                words.pop(i+1)\\n                i-=1\\n            i+=1\\n        return words\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while True:\\n            if i == len(words)-1:\\n                break\\n            if \\'\\'.join(sorted(words[i])) == \\'\\'.join(sorted(words[i+1])):\\n                words.pop(i+1)\\n                i-=1\\n            i+=1\\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140655,
                "title": "fast-c-using-map-count-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply sort each string and check adjacent if equal they are anagrams and if not then push them in answer .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSorting and Hash map\\n**Note**: Instead of normal sort I have used count sort which can be done when we have limited number of characters since string has only 26 charcaters so we can use it . And its time complexity is only $$O(n)$$ so very fast than  normal sort that takes $$O(nlogn)$$\\n# Complexity\\n- Time complexity:O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(26) not taking answer as space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  string count_sort(string s) {\\n        int mp[26] = {0};\\n        for (char c : s) {\\n            mp[c - \\'a\\']++;\\n        }\\n        string t;\\n        for (int c = 0; c < 26; c++) {\\n            t += string(mp[c], c + \\'a\\');\\n        }\\n        return t;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n       vector<string>ans;\\n       int n=words.size();\\n       ans.push_back(words[0]);\\n       for(int i=1;i<n;i++)\\n       // insted of count_sort u can stl sort but takes nlogn\\n           if(count_sort(words[i])==count_sort(words[i-1]));\\n           else ans.push_back(words[i]);\\n       \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  string count_sort(string s) {\\n        int mp[26] = {0};\\n        for (char c : s) {\\n            mp[c - \\'a\\']++;\\n        }\\n        string t;\\n        for (int c = 0; c < 26; c++) {\\n            t += string(mp[c], c + \\'a\\');\\n        }\\n        return t;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n       vector<string>ans;\\n       int n=words.size();\\n       ans.push_back(words[0]);\\n       for(int i=1;i<n;i++)\\n       // insted of count_sort u can stl sort but takes nlogn\\n           if(count_sort(words[i])==count_sort(words[i-1]));\\n           else ans.push_back(words[i]);\\n       \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351539,
                "title": "java-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n```\\n\\t\\tList<String> ans = new ArrayList<>();\\n        String temp = \"\";\\n        for (String s: words){\\n            char[] carr = s.toCharArray();\\n            Arrays.sort(carr);\\n            String curr = new String(carr);\\n            if (!curr.equals(temp))\\n                ans.add(s);\\n            temp = curr;\\n        }\\n        return ans;",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2040051,
                "title": "python-easy-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        if len(words) == 1:\\n            return words\\n        \\n        i = 1\\n        while i < len(words):\\n            anagram = \"\".join(sorted(words[i]))\\n\\t\\t\\t# check if words[i-1] and words[i] are anagrams\\n            if anagram == \"\".join(sorted(words[i - 1])):\\n\\t\\t\\t\\t# if anagrams then remove second instance from the list of words\\n                words.pop(i)\\n            else:\\n                i += 1\\n                \\n        return words\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        if len(words) == 1:\\n            return words\\n        \\n        i = 1\\n        while i < len(words):\\n            anagram = \"\".join(sorted(words[i]))\\n\\t\\t\\t# check if words[i-1] and words[i] are anagrams\\n            if anagram == \"\".join(sorted(words[i - 1])):\\n\\t\\t\\t\\t# if anagrams then remove second instance from the list of words\\n                words.pop(i)\\n            else:\\n                i += 1\\n                \\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632776,
                "title": "remove-anagrams-4-liner-code-least-complexity",
                "content": "# KARRAR\\n>Anagrams...\\n>>Removing anagrams...\\n>>>Low time complexity...\\n>>>>Optimized and generalized solution...\\n>>>>>   Easy to understand...\\n-     PLEASE \\uD83D\\uDC4D\\uD83C\\uDFFB UPVOTE...\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:\\n            Simplest approach...\\n            Sort the arrays and compare there indeces...\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: Beats 88% (57 ms)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Beats 15% (16 MB)\\n\\n![image.png](https://assets.leetcode.com/users/images/939680b3-2168-420f-ba83-7b9ea6a45a55_1686651121.8875034.png)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        ans=[words[0]]\\n        for i in range(1,len(words)):\\n            if(sorted(words[i-1])!=sorted(words[i])):\\n                ans.append(words[i])\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        ans=[words[0]]\\n        for i in range(1,len(words)):\\n            if(sorted(words[i-1])!=sorted(words[i])):\\n                ans.append(words[i])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466371,
                "title": "simple-approach-c",
                "content": "# Approach\\nThe Approach to this problem is to keep the point in mind that, \"if two strings are anagrams, and we sort them, both of them would be equal\"\\nfor example, \\n\"abba\" and \"bbaa\" are anagrams, and when we sort them, both of them would be \"aabb\" and \"aabb\".\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size(); i++)\\n        {\\n            string s1 = words[i];\\n            string s2 = words[i-1];\\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            if(s1 == s2)\\n            {\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n            \\n        }\\n        return words;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size(); i++)\\n        {\\n            string s1 = words[i];\\n            string s2 = words[i-1];\\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            if(s1 == s2)\\n            {\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n            \\n        }\\n        return words;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141419,
                "title": "c-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        for(int i = words.size()-1;i>0;i--){\\n            string c1 = words[i];\\n            string c2 = words[i-1];\\n            sort(c1.begin() ,c1.end());\\n            sort(c2.begin() , c2.end());\\n            if(c1 == c2){\\n                words[i] = \"#\";\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i]!= \"#\"){\\n                ans.push_back(words[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        for(int i = words.size()-1;i>0;i--){\\n            string c1 = words[i];\\n            string c2 = words[i-1];\\n            sort(c1.begin() ,c1.end());\\n            sort(c2.begin() , c2.end());\\n            if(c1 == c2){\\n                words[i] = \"#\";\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i]!= \"#\"){\\n                ans.push_back(words[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040091,
                "title": "c-map-easy-stl",
                "content": "We will be maintaining a map for storing frequency of every word. If consecutive words have same frequency then word will become \"\".\\n```\\nclass Solution {\\npublic:\\n    bool map_compare (map<char,int>&lhs, map<char,int>&rhs) \\n    {\\n    // No predicate needed because there is operator== for pairs already.\\n    return lhs.size() == rhs.size()&& std::equal(lhs.begin(), lhs.end(),rhs.begin());\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        for(int i=0;i<words.size()-1;i++)\\n        {\\n            if(words[i]==\"\")continue;\\n            map<char,int>m1;\\n            for(char c:words[i])\\n            {\\n                m1[c]++;\\n            }\\n            for(int j=i+1;j<words.size();j++)\\n            {\\n                map<char,int>m2;\\n                for(char c:words[j])\\n                {\\n                    m2[c]++;\\n                }    \\n                if(map_compare(m1,m2)){\\n                    words[j]=\"\";                    \\n                } \\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        for(string word:words)\\n        {\\n            if(word!=\"\")ans.push_back(word);\\n        }\\n\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool map_compare (map<char,int>&lhs, map<char,int>&rhs) \\n    {\\n    // No predicate needed because there is operator== for pairs already.\\n    return lhs.size() == rhs.size()&& std::equal(lhs.begin(), lhs.end(),rhs.begin());\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        for(int i=0;i<words.size()-1;i++)\\n        {\\n            if(words[i]==\"\")continue;\\n            map<char,int>m1;\\n            for(char c:words[i])\\n            {\\n                m1[c]++;\\n            }\\n            for(int j=i+1;j<words.size();j++)\\n            {\\n                map<char,int>m2;\\n                for(char c:words[j])\\n                {\\n                    m2[c]++;\\n                }    \\n                if(map_compare(m1,m2)){\\n                    words[j]=\"\";                    \\n                } \\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        for(string word:words)\\n        {\\n            if(word!=\"\")ans.push_back(word);\\n        }\\n\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942687,
                "title": "c-solution-using-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1; i < words.size(); i++){ //start the loop from first index\\n            string a = words[i-1]; \\n            map <char, int> mp; //stores the details of the (i-1)st word\\n            for(int j = 0; j < a.length(); j++){\\n                mp[words[i-1][j]]++;\\n            }\\n            map <char, int> m; //stores the details of the i th word\\n            for(int h = 0; h < words[i].length(); h++){\\n                m[words[i][h]]++;\\n            }\\n            if(mp == m){ //if maps are equal then the words are anagrams\\n                words.erase(words.begin() + i);\\n                i--; //as we delete from the vector, we need to reset i to i-1\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1; i < words.size(); i++){ //start the loop from first index\\n            string a = words[i-1]; \\n            map <char, int> mp; //stores the details of the (i-1)st word\\n            for(int j = 0; j < a.length(); j++){\\n                mp[words[i-1][j]]++;\\n            }\\n            map <char, int> m; //stores the details of the i th word\\n            for(int h = 0; h < words[i].length(); h++){\\n                m[words[i][h]]++;\\n            }\\n            if(mp == m){ //if maps are equal then the words are anagrams\\n                words.erase(words.begin() + i);\\n                i--; //as we delete from the vector, we need to reset i to i-1\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056341,
                "title": "python-small-easy-to-understand-solution",
                "content": "Runtime: 52 ms, faster than 96.66% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\nMemory Usage: 13.8 MB, less than 75.32% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\n```\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    key = \"\"\\n    result = []\\n    \\n    for word in words:\\n      letters = list(word)\\n      letters.sort()\\n      new_key = \"\".join(letters)\\n      \\n      if new_key != key :\\n        key = new_key\\n        result.append(word)\\n        \\n    return result\\n```\\n\\n**More understanding variant :**\\n\\n**idea of solution :**\\n1. get first word from array and sorting it and retain as **key** and put first word in answer(**result**) \\n2. in loop will give all words from array starting with index 1\\n3. for each word will check : is the sorting rearranging of this word equal **key** or not ?\\n a. is eqaul : ignore this word\\n b. isn\\'t equal : put this word in answer and update **key**\\nRuntime: 56 ms, faster than 93.03% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\nMemory Usage: 13.8 MB, less than 75.32% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\n```\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    def sort_construct(word):\\n      letters = list(word)\\n      letters.sort()\\n      return \"\".join(letters)\\n    \\n    key = sort_construct(words[0])\\n    result = [words[0]]\\n    \\n    for i in range(1, len(words)):\\n      new_key = sort_construct(words[i])\\n      if new_key != key :\\n        key = new_key\\n        result.append(words[i])\\n        \\n    return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    key = \"\"\\n    result = []\\n    \\n    for word in words:\\n      letters = list(word)\\n      letters.sort()\\n      new_key = \"\".join(letters)\\n      \\n      if new_key != key :\\n        key = new_key\\n        result.append(word)\\n        \\n    return result\\n```\n```\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    def sort_construct(word):\\n      letters = list(word)\\n      letters.sort()\\n      return \"\".join(letters)\\n    \\n    key = sort_construct(words[0])\\n    result = [words[0]]\\n    \\n    for i in range(1, len(words)):\\n      new_key = sort_construct(words[i])\\n      if new_key != key :\\n        key = new_key\\n        result.append(words[i])\\n        \\n    return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043991,
                "title": "clear-and-easily-understandable",
                "content": "```\\nclass Solution {\\n\\tpublic static List<String> removeAnagrams(String[] words) {\\n\\t\\tList<String> ans = new ArrayList<>();\\n\\t\\tString next = \"\";\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\tchar tempArray[] = words[i].toCharArray();\\n\\t\\t\\tArrays.sort(tempArray);\\n\\t\\t\\tString temp = new String(tempArray);\\n\\t\\t\\tif ((!temp.equals(next))) {\\n\\t\\t\\t\\tans.add(words[i]);\\n\\t\\t\\t}\\n\\t\\t\\tnext = temp;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic static List<String> removeAnagrams(String[] words) {\\n\\t\\tList<String> ans = new ArrayList<>();\\n\\t\\tString next = \"\";\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\tchar tempArray[] = words[i].toCharArray();\\n\\t\\t\\tArrays.sort(tempArray);\\n\\t\\t\\tString temp = new String(tempArray);\\n\\t\\t\\tif ((!temp.equals(next))) {\\n\\t\\t\\t\\tans.add(words[i]);\\n\\t\\t\\t}\\n\\t\\t\\tnext = temp;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040665,
                "title": "c-one-pass-o-1-space",
                "content": "```\\n   int n=words.size();\\n        vector<string> ans;\\n        ans.emplace_back(words[0]);\\n        vector<int> f1(26,0);\\n        for(auto it : words[0]) f1[it-\\'a\\']++;\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<int> f2(26,0);\\n            for(auto it : words[i])\\n            {\\n                f2[it-\\'a\\']++;\\n            }\\n            if(f1==f2) continue;\\n            else \\n            {\\n                ans.emplace_back(words[i]);\\n                f1=f2;\\n            }\\n        }\\n        return ans;   \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   int n=words.size();\\n        vector<string> ans;\\n        ans.emplace_back(words[0]);\\n        vector<int> f1(26,0);\\n        for(auto it : words[0]) f1[it-\\'a\\']++;\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<int> f2(26,0);\\n            for(auto it : words[i])\\n            {\\n                f2[it-\\'a\\']++;\\n            }\\n            if(f1==f2) continue;\\n            else \\n            {\\n                ans.emplace_back(words[i]);\\n                f1=f2;\\n            }\\n        }\\n        return ans;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3409786,
                "title": "find-resultant-array-after-removing-anagrams-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int i=0;\\n        while(i<words.size()-1)\\n        {\\n            string s1 = words[i];\\n            sort(s1.begin(), s1.end());\\n            string s2 = words[i+1];\\n            sort(s2.begin(), s2.end());\\n\\n            if(s1==s2)\\n            {\\n                words.erase(words.begin()+i+1);\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int i=0;\\n        while(i<words.size()-1)\\n        {\\n            string s1 = words[i];\\n            sort(s1.begin(), s1.end());\\n            string s2 = words[i+1];\\n            sort(s2.begin(), s2.end());\\n\\n            if(s1==s2)\\n            {\\n                words.erase(words.begin()+i+1);\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762311,
                "title": "java-88-faster-not-using-maps",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    static short[] alph;\\n\\n    public List<String> removeAnagrams(String[] words) {\\n        alph = new short[26];\\n        if (words.length == 1) {\\n            List<String> list = new ArrayList<>();\\n            list.add(words[0]);\\n            return list;\\n        }\\n\\n        List<String> list = new ArrayList<>(words.length);\\n\\n        for (String word : words) {\\n            list.add(word);\\n        }\\n        int idx = 1;\\n        while (idx < list.size()) {\\n            if (hasNextAnagram(list, idx)) {\\n                list.remove(idx);\\n                continue;\\n            }\\n            idx++;\\n        }\\n        return list;\\n    }\\n\\n    private static boolean hasNextAnagram(List<String> list, int idx) {\\n        return isAnagram(list.get(idx), list.get(idx - 1));\\n    }\\n\\n    private static boolean isAnagram(String one, String two) {\\n        for (int i = 0; i < one.length(); i++) {\\n            char c = one.charAt(i);\\n            alph[c - \\'a\\']++;\\n        }\\n        for (int i = 0; i < two.length(); i++) {\\n            char c = two.charAt(i);\\n            alph[c - \\'a\\']--;\\n        }\\n        boolean isAnagram = true;\\n        for (int i = 0; i < alph.length; i++) {\\n            if (alph[i] != 0) {\\n                isAnagram = false;\\n            }\\n            alph[i] = 0;\\n        }\\n        return isAnagram;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static short[] alph;\\n\\n    public List<String> removeAnagrams(String[] words) {\\n        alph = new short[26];\\n        if (words.length == 1) {\\n            List<String> list = new ArrayList<>();\\n            list.add(words[0]);\\n            return list;\\n        }\\n\\n        List<String> list = new ArrayList<>(words.length);\\n\\n        for (String word : words) {\\n            list.add(word);\\n        }\\n        int idx = 1;\\n        while (idx < list.size()) {\\n            if (hasNextAnagram(list, idx)) {\\n                list.remove(idx);\\n                continue;\\n            }\\n            idx++;\\n        }\\n        return list;\\n    }\\n\\n    private static boolean hasNextAnagram(List<String> list, int idx) {\\n        return isAnagram(list.get(idx), list.get(idx - 1));\\n    }\\n\\n    private static boolean isAnagram(String one, String two) {\\n        for (int i = 0; i < one.length(); i++) {\\n            char c = one.charAt(i);\\n            alph[c - \\'a\\']++;\\n        }\\n        for (int i = 0; i < two.length(); i++) {\\n            char c = two.charAt(i);\\n            alph[c - \\'a\\']--;\\n        }\\n        boolean isAnagram = true;\\n        for (int i = 0; i < alph.length; i++) {\\n            if (alph[i] != 0) {\\n                isAnagram = false;\\n            }\\n            alph[i] = 0;\\n        }\\n        return isAnagram;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754510,
                "title": "c-solution",
                "content": "```\\n#define MAX_LENGTH      (100+4)\\n\\nint compareChar(const void* c1, const void* c2)\\n{\\n    // ascending order\\n    return (*(char*)c1 - *(char*)c2);\\n}\\n\\nbool isAnagrams(char* pSrc, char* pDst)\\n{\\n    int retVal = false;\\n\\n    char sortSrc[MAX_LENGTH];\\n    memset(sortSrc, 0, sizeof(sortSrc));\\n    snprintf(sortSrc, sizeof(sortSrc), \"%s\", pSrc);\\n    qsort(sortSrc, strlen(sortSrc), sizeof(char), compareChar);\\n\\n    char sortDst[MAX_LENGTH];\\n    memset(sortDst, 0, sizeof(sortDst));\\n    snprintf(sortDst, sizeof(sortDst), \"%s\", pDst);\\n    qsort(sortDst, strlen(sortDst), sizeof(char), compareChar);\\n\\n    if (strcmp(sortSrc, sortDst) == 0)\\n    {\\n        retVal = true;\\n    }\\n\\n    return retVal;\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** removeAnagrams(char ** words, int wordsSize, int* returnSize){\\n    (*returnSize) = 1;\\n\\n    int len;\\n    int i;\\n    for (i=1; i<wordsSize; ++i)\\n    {\\n        if (isAnagrams(words[(*returnSize)-1], words[i]) == true)\\n        {\\n            continue;\\n        }\\n\\n        if ((*returnSize) != i)\\n        {\\n            free(words[(*returnSize)]);\\n            words[(*returnSize)] = NULL;\\n\\n            len = strlen(words[i]) + 1;\\n            words[(*returnSize)] = (char*)malloc(len*sizeof(char));\\n            if (words[(*returnSize)] == NULL)\\n            {\\n                perror(\"malloc\");\\n                return words;\\n            }\\n            memset(words[(*returnSize)], 0, len*sizeof(char));\\n            snprintf(words[(*returnSize)], len*sizeof(char), \"%s\", words[i]);\\n        }\\n\\n        (*returnSize)++;\\n    }\\n\\n    return words;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define MAX_LENGTH      (100+4)\\n\\nint compareChar(const void* c1, const void* c2)\\n{\\n    // ascending order\\n    return (*(char*)c1 - *(char*)c2);\\n}\\n\\nbool isAnagrams(char* pSrc, char* pDst)\\n{\\n    int retVal = false;\\n\\n    char sortSrc[MAX_LENGTH];\\n    memset(sortSrc, 0, sizeof(sortSrc));\\n    snprintf(sortSrc, sizeof(sortSrc), \"%s\", pSrc);\\n    qsort(sortSrc, strlen(sortSrc), sizeof(char), compareChar);\\n\\n    char sortDst[MAX_LENGTH];\\n    memset(sortDst, 0, sizeof(sortDst));\\n    snprintf(sortDst, sizeof(sortDst), \"%s\", pDst);\\n    qsort(sortDst, strlen(sortDst), sizeof(char), compareChar);\\n\\n    if (strcmp(sortSrc, sortDst) == 0)\\n    {\\n        retVal = true;\\n    }\\n\\n    return retVal;\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** removeAnagrams(char ** words, int wordsSize, int* returnSize){\\n    (*returnSize) = 1;\\n\\n    int len;\\n    int i;\\n    for (i=1; i<wordsSize; ++i)\\n    {\\n        if (isAnagrams(words[(*returnSize)-1], words[i]) == true)\\n        {\\n            continue;\\n        }\\n\\n        if ((*returnSize) != i)\\n        {\\n            free(words[(*returnSize)]);\\n            words[(*returnSize)] = NULL;\\n\\n            len = strlen(words[i]) + 1;\\n            words[(*returnSize)] = (char*)malloc(len*sizeof(char));\\n            if (words[(*returnSize)] == NULL)\\n            {\\n                perror(\"malloc\");\\n                return words;\\n            }\\n            memset(words[(*returnSize)], 0, len*sizeof(char));\\n            snprintf(words[(*returnSize)], len*sizeof(char), \"%s\", words[i]);\\n        }\\n\\n        (*returnSize)++;\\n    }\\n\\n    return words;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2517232,
                "title": "vector-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& ans) {\\n     \\n        vector<string> words = ans;\\n        int i=0;\\n        while(i<words.size()-1){\\n            string s1 = words[i];\\n            string s2 = words[i+1];\\n            \\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            \\n            if(s1.compare(s2)==0){\\n                words.erase(words.begin()+i+1);\\n            }\\n            else i++;\\n        }\\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& ans) {\\n     \\n        vector<string> words = ans;\\n        int i=0;\\n        while(i<words.size()-1){\\n            string s1 = words[i];\\n            string s2 = words[i+1];\\n            \\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            \\n            if(s1.compare(s2)==0){\\n                words.erase(words.begin()+i+1);\\n            }\\n            else i++;\\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474416,
                "title": "easy-c-solution-o-n",
                "content": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        vector<string> temp;\\n        for(auto s:words)\\n        {\\n            sort(s.begin(),s.end());\\n            temp.push_back(s);\\n        }\\n        for(int i = 0;i<temp.size();i++)\\n        {\\n            if((i==0) || temp[i] != temp[i-1])\\n            {\\n                ans.push_back(words[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        vector<string> temp;\\n        for(auto s:words)\\n        {\\n            sort(s.begin(),s.end());\\n            temp.push_back(s);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2391910,
                "title": "python-one-liner-95-speed",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        return [words[0]]+[words[i] for i in range(1,len(words)) if sorted(words[i])!=sorted(words[i-1])]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        return [words[0]]+[words[i] for i in range(1,len(words)) if sorted(words[i])!=sorted(words[i-1])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345429,
                "title": "python-5-lines",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        for i in range(len(words)):\\n            #check anagram\\n            if sorted(words[i-1])!=sorted(words[i]):\\n                res.append(words[i])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        for i in range(len(words)):\\n            #check anagram\\n            if sorted(words[i-1])!=sorted(words[i]):\\n                res.append(words[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208901,
                "title": "time-0-n-and-space-0-1",
                "content": "````\\nvar removeAnagrams = function(words) {\\n    let n = words.length;\\n    \\n    for(let i=0; i<n-1; i++){\\n        if(isAnagram(words[i], words[i+1])){\\n            words.splice(i+1, 1);\\n            i--\\n            n--\\n        }\\n    }\\n    return words\\n};\\n\\nfunction isAnagram(a, b){\\n    \\n    let freqArr = new Array(26).fill(0);\\n    if(a.length != b.length) return false\\n    \\n    for(let i=0; i<a.length; i++){\\n        let idx1 = a[i].charCodeAt(0) - \"a\".charCodeAt(0);\\n        freqArr[idx1]++;\\n        let idx2 = b[i].charCodeAt(0) - \"a\".charCodeAt(0);\\n        freqArr[idx2]--\\n    }\\n\\n    \\n    for(let i=0; i<26; i++){\\n        if(freqArr[i] > 0){\\n            return false\\n        }\\n    }\\n    return true\\n}\\n````",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "````\\nvar removeAnagrams = function(words) {\\n    let n = words.length;\\n    \\n    for(let i=0; i<n-1; i++){\\n        if(isAnagram(words[i], words[i+1])){\\n            words.splice(i+1, 1);\\n            i--\\n            n--\\n        }\\n    }\\n    return words\\n};\\n\\nfunction isAnagram(a, b){\\n    \\n    let freqArr = new Array(26).fill(0);\\n    if(a.length != b.length) return false\\n    \\n    for(let i=0; i<a.length; i++){\\n        let idx1 = a[i].charCodeAt(0) - \"a\".charCodeAt(0);\\n        freqArr[idx1]++;\\n        let idx2 = b[i].charCodeAt(0) - \"a\".charCodeAt(0);\\n        freqArr[idx2]--\\n    }\\n\\n    \\n    for(let i=0; i<26; i++){\\n        if(freqArr[i] > 0){\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2192113,
                "title": "c-basic-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>v1;\\n        v1.push_back(words[0]);\\n        string prev=words[0];\\n        sort(prev.begin(),prev.end());\\n        \\n        for(int i=1;i<words.size();i++)\\n        {\\n            string s = words[i];\\n            sort(s.begin(),s.end());\\n            \\n            if(s!=prev)\\n            {\\n                v1.push_back(words[i]);\\n                prev = s;\\n            }\\n            \\n        }\\n        return v1;  \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>v1;\\n        v1.push_back(words[0]);\\n        string prev=words[0];\\n        sort(prev.begin(),prev.end());\\n        \\n        for(int i=1;i<words.size();i++)\\n        {\\n            string s = words[i];\\n            sort(s.begin(),s.end());\\n            \\n            if(s!=prev)\\n            {\\n                v1.push_back(words[i]);\\n                prev = s;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2127195,
                "title": "simple-and-easy-javascript-typescript-solution",
                "content": "My simple and easy JavaScript/TypeScript solution:\\n```\\nfunction removeAnagrams(words: string[]): string[] {\\n    const newWords = [];\\n    let prevSortedWord = \\'\\';\\n    for (const word of words) {\\n        const sortedWord = word.split(\\'\\').sort().join(\\'\\');\\n        if (sortedWord === prevSortedWord) continue;\\n        \\n        prevSortedWord = sortedWord;\\n        newWords.push(word);\\n    }\\n    return newWords;\\n};\\n```\\nRuntime:\\xA081 ms, faster than\\xA097.92%\\xA0of\\xA0TypeScript\\xA0online submissions for\\xA0Find Resultant Array After Removing Anagrams.\\nMemory Usage:\\xA048.7 MB, less than\\xA089.58%\\xA0of\\xA0TypeScript\\xA0online submissions for\\xA0Find Resultant Array After Removing Anagrams.\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Sorting"
                ],
                "code": "```\\nfunction removeAnagrams(words: string[]): string[] {\\n    const newWords = [];\\n    let prevSortedWord = \\'\\';\\n    for (const word of words) {\\n        const sortedWord = word.split(\\'\\').sort().join(\\'\\');\\n        if (sortedWord === prevSortedWord) continue;\\n        \\n        prevSortedWord = sortedWord;\\n        newWords.push(word);\\n    }\\n    return newWords;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2042605,
                "title": "c",
                "content": "```\\n    public IList<string> RemoveAnagrams(string[] words)\\n    {\\n        IList<string> result = new List<string>();\\n        result.Add(words[0]);\\n        for (int i = 1; i < words.Length; i++)\\n        {\\n            if (String.Concat(words[i].OrderBy(a => a)) != String.Concat(words[i - 1].OrderBy(a => a)))\\n                result.Add(words[i]);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public IList<string> RemoveAnagrams(string[] words)\\n    {\\n        IList<string> result = new List<string>();\\n        result.Add(words[0]);\\n        for (int i = 1; i < words.Length; i++)\\n        {\\n            if (String.Concat(words[i].OrderBy(a => a)) != String.Concat(words[i - 1].OrderBy(a => a)))\\n                result.Add(words[i]);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2039880,
                "title": "c-implementation-clean-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    bool anagram(string str1, string str2)\\n{\\n    // Get lengths of both strings\\n    int n1 = str1.length();\\n    int n2 = str2.length();\\n \\n    // If length of both strings is not same, then they\\n    // cannot be anagram\\n    if (n1 != n2)\\n        return false;\\n \\n    // Sort both the strings\\n    sort(str1.begin(), str1.end());\\n    sort(str2.begin(), str2.end());\\n \\n    // Compare sorted strings\\n    for (int i = 0; i < n1; i++)\\n        if (str1[i] != str2[i])\\n            return false;\\n \\n    return true;\\n}\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        vector<string>ans;\\n        int n=words.size();\\n        int i,j;\\n        map<int,int>ma;\\n        while(1)\\n        {\\n            bool be=false;\\n            \\n            for(i=1;i<n;i++)\\n            {\\n                if(ma[i]!=1 and anagram(words[i],words[i-1]))\\n                {\\n                    ma[i]=1;\\n                    be=true;\\n                    break;\\n                }\\n            }\\n            if(be==false)\\n                break;\\n            \\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(ma[i]!=1)\\n                ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Pls upvote the post if you found helpful.\\nDo comment down your doubts if any.\\nTill then, happy coding : )**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool anagram(string str1, string str2)\\n{\\n    // Get lengths of both strings\\n    int n1 = str1.length();\\n    int n2 = str2.length();\\n \\n    // If length of both strings is not same, then they\\n    // cannot be anagram\\n    if (n1 != n2)\\n        return false;\\n \\n    // Sort both the strings\\n    sort(str1.begin(), str1.end());\\n    sort(str2.begin(), str2.end());\\n \\n    // Compare sorted strings\\n    for (int i = 0; i < n1; i++)\\n        if (str1[i] != str2[i])\\n            return false;\\n \\n    return true;\\n}\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        vector<string>ans;\\n        int n=words.size();\\n        int i,j;\\n        map<int,int>ma;\\n        while(1)\\n        {\\n            bool be=false;\\n            \\n            for(i=1;i<n;i++)\\n            {\\n                if(ma[i]!=1 and anagram(words[i],words[i-1]))\\n                {\\n                    ma[i]=1;\\n                    be=true;\\n                    break;\\n                }\\n            }\\n            if(be==false)\\n                break;\\n            \\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(ma[i]!=1)\\n                ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039835,
                "title": "c-beginner-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n     vector<string>res;\\n        set<string>st;\\n        for(int i=0;i<words.size();i++){\\n            string temp=words[i];\\n            sort(temp.begin(),temp.end());\\n            if(st.count(temp)){\\n                continue;\\n            }\\n            else{\\n                res.push_back(words[i]);\\n                st.erase(st.begin(),st.end());\\n                st.insert(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n     vector<string>res;\\n        set<string>st;\\n        for(int i=0;i<words.size();i++){\\n            string temp=words[i];\\n            sort(temp.begin(),temp.end());\\n            if(st.count(temp)){\\n                continue;\\n            }\\n            else{\\n                res.push_back(words[i]);\\n                st.erase(st.begin(),st.end());\\n                st.insert(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039786,
                "title": "c-solution-easy-understanding-sorting",
                "content": "```\\n    vector<string> removeAnagrams(vector<string>& words) {\\n     vector<string>ans;\\n     ans.push_back(words[0]);\\n    for (int i = 1; i<words.size(); i++) \\n    { \\n        string a=words[i];\\n        string b=ans[ans.size()-1];\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        if(a!=b)\\n        {\\n            ans.push_back(words[i]);\\n        }\\n    }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n    vector<string> removeAnagrams(vector<string>& words) {\\n     vector<string>ans;\\n     ans.push_back(words[0]);\\n    for (int i = 1; i<words.size(); i++) \\n    { \\n        string a=words[i];\\n        string b=ans[ans.size()-1];\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        if(a!=b)\\n        {\\n            ans.push_back(words[i]);\\n        }\\n    }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2039762,
                "title": "java-store-previous-anagrams-string",
                "content": "Store the previous anagram string with characters sorted. Iterate over the words, if the anagramStr is newly seen, add the current to the result and update the lastAnagramStr; if the anagramStr is the same as lastAnagramStr, skip.\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> result = new LinkedList<>();\\n        String lastAnagramStr = null;\\n        for (String s : words) {\\n            char[] charArr = s.toCharArray();\\n            Arrays.sort(charArr);\\n            String curAnagramStr = new String(charArr);\\n            \\n            if (curAnagramStr.equals(lastAnagramStr)) {\\n                continue;\\n            }\\n            else {\\n                lastAnagramStr = curAnagramStr;\\n                result.add(s);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> result = new LinkedList<>();\\n        String lastAnagramStr = null;\\n        for (String s : words) {\\n            char[] charArr = s.toCharArray();\\n            Arrays.sort(charArr);\\n            String curAnagramStr = new String(charArr);\\n            \\n            if (curAnagramStr.equals(lastAnagramStr)) {\\n                continue;\\n            }\\n            else {\\n                lastAnagramStr = curAnagramStr;\\n                result.add(s);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039732,
                "title": "python-simple-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        if len(words)==1:\\n            return words\\n        i = 1 \\n        while i<len(words):\\n            if sorted(list(words[i]))==sorted(list(words[i-1])):\\n                words.pop(i)\\n            else:\\n                i+=1 \\n        return words\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        if len(words)==1:\\n            return words\\n        i = 1 \\n        while i<len(words):\\n            if sorted(list(words[i]))==sorted(list(words[i-1])):\\n                words.pop(i)\\n            else:\\n                i+=1 \\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039720,
                "title": "create-stack-and-compare-with-top-of-stack",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        stack = []\\n        for w in words:\\n            if len(stack) == 0 or sorted(w) != sorted(stack[-1]):\\n                stack.append(w)\\n        return stack\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        stack = []\\n        for w in words:\\n            if len(stack) == 0 or sorted(w) != sorted(stack[-1]):\\n                stack.append(w)\\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924820,
                "title": "java-solution-easy-to-understand",
                "content": "\\n\\n## Intuition\\nThe problem is about removing anagrams from an array of strings and returning a list of strings where each string is not an anagram of any other string in the list.\\n\\n## Approach\\n1. **isAnagram Method**: The `isAnagram` method checks whether two input strings are anagrams of each other or not. It sorts the characters of both strings and compares them. If the sorted arrays of characters are equal, then the strings are anagrams.\\n\\n2. **removeAnagrams Method**: The `removeAnagrams` method iterates through the array of strings and uses the `isAnagram` method to identify and mark anagrams.\\n   - It maintains a boolean array `vis` to track visited words (anagrams are marked as visited).\\n   - For each word at index `i`, it searches for the next non-visited word (starting from `i + 1`) and marks it as visited if it\\'s an anagram.\\n   - After marking all anagrams, the method adds the non-visited words to the result list.\\n\\n## Complexity\\n- **Time complexity**:\\n   - The `isAnagram` method sorts two char arrays, which takes O(k * log(k)) time complexity, where k is the length of the longest string in the array.\\n   - The main part of the time complexity comes from the nested loops in the `removeAnagrams` method. The outer loop runs in O(n) time, and for each word, the inner loop can run up to n - 1 times (when all words are anagrams of each other). The `isAnagram` method itself takes O(k * log(k)) time in the worst case. So, the overall time complexity is O(n^2 * k * log(k)).\\n\\n- **Space complexity**:\\n   - The space complexity of the `isAnagram` method is O(k), where k is the length of the longest string.\\n   - The `removeAnagrams` method uses a boolean array `vis` of size n to mark visited words, so the space complexity is O(n).\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAnagram(String s1,String s2){\\n        if(s1.length()!=s2.length())return false;\\n        char a[]=s1.toCharArray();\\n        char b[]=s2.toCharArray();\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        for(int i=0;i<a.length;i++){\\n            if(a[i]!=b[i])return false;\\n        }\\n        return true;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list=new ArrayList<>();\\n        boolean vis[]=new boolean[words.length];\\n        for(int i=0;i<words.length-1;i++){\\n            int j=i+1;\\n            while(vis[j]==true){\\n                j++;\\n            }\\n            if(isAnagram(words[i],words[j])){\\n                vis[j]=true;\\n            }\\n        }\\n        for(int i=0;i<words.length;i++){\\n            // System.out.print(i+\"--\"+vis[i]);\\n            if(vis[i]==false)\\n            {\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```\\n# Give me ThumsUp if it helps for you \\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDE09\\uD83D\\uDE09",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAnagram(String s1,String s2){\\n        if(s1.length()!=s2.length())return false;\\n        char a[]=s1.toCharArray();\\n        char b[]=s2.toCharArray();\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        for(int i=0;i<a.length;i++){\\n            if(a[i]!=b[i])return false;\\n        }\\n        return true;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list=new ArrayList<>();\\n        boolean vis[]=new boolean[words.length];\\n        for(int i=0;i<words.length-1;i++){\\n            int j=i+1;\\n            while(vis[j]==true){\\n                j++;\\n            }\\n            if(isAnagram(words[i],words[j])){\\n                vis[j]=true;\\n            }\\n        }\\n        for(int i=0;i<words.length;i++){\\n            // System.out.print(i+\"--\"+vis[i]);\\n            if(vis[i]==false)\\n            {\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752922,
                "title": "python-easy-solution-stack",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def check(self,word1: str,word2: str)->bool:\\n        word1=list(word1)\\n        word1.sort()\\n        word2=list(word2)\\n        word2.sort()\\n        if word1==word2:\\n            return 1\\n        return 0\\n\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        lis=[]\\n        for i in range(len(words)):\\n            if len(lis)==0 or Solution.check(self,lis[len(lis)-1],words[i])==0:\\n                lis.append(words[i])\\n        return lis            \\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def check(self,word1: str,word2: str)->bool:\\n        word1=list(word1)\\n        word1.sort()\\n        word2=list(word2)\\n        word2.sort()\\n        if word1==word2:\\n            return 1\\n        return 0\\n\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        lis=[]\\n        for i in range(len(words)):\\n            if len(lis)==0 or Solution.check(self,lis[len(lis)-1],words[i])==0:\\n                lis.append(words[i])\\n        return lis            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490966,
                "title": "pattern-c",
                "content": "# Intuition\\nBasic two pointer pattern.\\n\\nA lot of similar questions can be solved with this like \\nhttps://leetcode.com/problems/sort-array-by-parity-ii\\nremove element \\nRemove Duplicates from Sorted Array - LeetCode\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe can have two pointers as i=0,j=0 and k=0 as counter to replace the words vector according to question.\\nIncrease j till words[i] and words[j] aree not anagrams anymore\\n\\n         - - - - - -\\n         i     j\\n\\nso we got one element words[i] do the same for all the elements \\none corner case has to be taken into account\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(1);\\n\\n# Code\\nclass Solution {\\npublic:\\n\\n    bool anagram(string &str1,string &str2){\\n        int cnt[256]={0};\\n        int n=str1.length();\\n        int m=str2.length();\\n        if(n != m){\\n            return false;\\n        }\\n        for(int i=0;i<n;i++){\\n            cnt[str1[i]-\\'a\\']++;\\n            cnt[str2[i]-\\'a\\']--;\\n        }\\n        for(int i=0;i<256;i++){\\n            if(cnt[i] !=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int r= words.size();\\n        int i=0,j=0,k=0;\\n        while(j<r){\\n            \\n            while(j<r && anagram(words[j],words[i]) == true){\\n                j++;\\n            }\\n            \\n            if(j<r && !anagram(words[j],words[i])){\\n                words[k]=words[i];\\n                cout<<k;\\n                k++;\\n                i=j;\\n            }\\n        }\\n        // if(k==0){\\n        //     words.resize(1);\\n        // }\\n        // else{\\n        //     words.resize(k);\\n        // }\\n\\n        if(j==r){\\n            words[k]=words[i];\\n        }\\n        k++;\\n        words.resize(k);\\n        return  words;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool anagram(string &str1,string &str2){\\n        int cnt[256]={0}",
                "codeTag": "Java"
            },
            {
                "id": 3280257,
                "title": "easy-solution",
                "content": "# Code\\n```\\nfunc removeAnagrams(words []string) []string {\\n    \\n    j := 0\\n\\n    for i, v := range words {\\n        if v != \"\" {\\n             for j := i+1; j < len(words); j++ {\\n                if sort(v) == sort(words[j]) {\\n                    words[j] = \"\"\\n                }else{\\n                    break\\n                }\\n            }\\n            words[j] = v\\n            j++\\n        }\\n    }\\n    \\n\\n    return words[:j]\\n}\\n\\nfunc sort(str string) string {\\n  runes := []rune(str)\\n\\n    // Bubble sort the slice of runes\\n    for i := 0; i < len(runes); i++ {\\n        for j := i + 1; j < len(runes); j++ {\\n            if runes[i] > runes[j] {\\n                temp := runes[i]\\n                runes[i] = runes[j]\\n                runes[j] = temp\\n            }\\n        }\\n    }\\n\\n    // Convert the slice of runes back to a string\\n    sortedStr := string(runes)\\n\\n    return sortedStr\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeAnagrams(words []string) []string {\\n    \\n    j := 0\\n\\n    for i, v := range words {\\n        if v != \"\" {\\n             for j := i+1; j < len(words); j++ {\\n                if sort(v) == sort(words[j]) {\\n                    words[j] = \"\"\\n                }else{\\n                    break\\n                }\\n            }\\n            words[j] = v\\n            j++\\n        }\\n    }\\n    \\n\\n    return words[:j]\\n}\\n\\nfunc sort(str string) string {\\n  runes := []rune(str)\\n\\n    // Bubble sort the slice of runes\\n    for i := 0; i < len(runes); i++ {\\n        for j := i + 1; j < len(runes); j++ {\\n            if runes[i] > runes[j] {\\n                temp := runes[i]\\n                runes[i] = runes[j]\\n                runes[j] = temp\\n            }\\n        }\\n    }\\n\\n    // Convert the slice of runes back to a string\\n    sortedStr := string(runes)\\n\\n    return sortedStr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3202524,
                "title": "5-lines-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        x=[words[0]]\\n        for i in range(1,len(words)):\\n            if sorted(x[-1])!=sorted(words[i]):\\n                x.append(words[i])\\n        return x\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        x=[words[0]]\\n        for i in range(1,len(words)):\\n            if sorted(x[-1])!=sorted(words[i]):\\n                x.append(words[i])\\n        return x\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031282,
                "title": "itertools-is-awesome",
                "content": "Here\\'s a one-liner\\n\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        return (next(val) for _, val in groupby(words, key=sorted))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        return (next(val) for _, val in groupby(words, key=sorted))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902430,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n   for(let i =1;i<words.length; i++){\\n       if(isAnagram(words[i], words[i-1])){\\n           words.splice(i,1);\\n           i--;\\n       }\\n   } \\n    return words;\\n   function isAnagram(s1, s2){\\n       let arr1 = s1.split(\"\");\\n       let arr2 = s2.split(\"\");\\n       if(arr1.length != arr2.length) return false;\\n       for(let i =0; i<arr1.length; i++){\\n           if(arr2.includes(arr1[i])){\\n               arr2.splice(arr2.indexOf(arr1[i]),1);\\n           }\\n       }\\n       return arr2.length ===0;\\n   }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n   for(let i =1;i<words.length; i++){\\n       if(isAnagram(words[i], words[i-1])){\\n           words.splice(i,1);\\n           i--;\\n       }\\n   } \\n    return words;\\n   function isAnagram(s1, s2){\\n       let arr1 = s1.split(\"\");\\n       let arr2 = s2.split(\"\");\\n       if(arr1.length != arr2.length) return false;\\n       for(let i =0; i<arr1.length; i++){\\n           if(arr2.includes(arr1[i])){\\n               arr2.splice(arr2.indexOf(arr1[i]),1);\\n           }\\n       }\\n       return arr2.length ===0;\\n   }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2849481,
                "title": "simple-c-solution-for-beginners-c-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCompare the two adjacent elemets and if not equal push into result array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the two strings for comparision\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  O(nlogn)\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\\\\\n        vector<string> ans;\\n        ans.push_back(words[0]);\\n        for(int i=1;i<words.size();i++) {\\n            string a = words[i] , b = words[i-1];\\n            sort(a.begin() , a.end());\\n            sort(b.begin() , b.end());\\n            if(a != b) ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\\\\\n        vector<string> ans;\\n        ans.push_back(words[0]);\\n        for(int i=1;i<words.size();i++) {\\n            string a = words[i] , b = words[i-1];\\n            sort(a.begin() , a.end());\\n            sort(b.begin() , b.end());\\n            if(a != b) ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751510,
                "title": "python-counter-solution",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res=[words[0]] \\n        for i in range(1,len(words)):\\n            mp1,mp2=Counter(words[i-1]),Counter(words[i]) \\n            if mp1!=mp2:\\n                res.append(words[i]) \\n        return res\\n\\t\\t#misread easy to medium\\n        # s=[]\\n        # ans=[]\\n        # for i in words:\\n        #     mp=[0]*26 \\n        #     for j in i:\\n        #         mp[ord(j)-ord(\"a\")]+=1\\n        #     if str(mp) in s:\\n        #         continue\\n        #     else:\\n        #         ans.append(i)\\n        #         s.append(str(mp))\\n        # return ans\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res=[words[0]] \\n        for i in range(1,len(words)):\\n            mp1,mp2=Counter(words[i-1]),Counter(words[i]) \\n            if mp1!=mp2:\\n                res.append(words[i]) \\n        return res\\n\\t\\t#misread easy to medium\\n        # s=[]\\n        # ans=[]\\n        # for i in words:\\n        #     mp=[0]*26 \\n        #     for j in i:\\n        #         mp[ord(j)-ord(\"a\")]+=1\\n        #     if str(mp) in s:\\n        #         continue\\n        #     else:\\n        #         ans.append(i)\\n        #         s.append(str(mp))\\n        # return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2599969,
                "title": "java-string-sorting-simple-solution",
                "content": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev = \"\";\\n        ArrayList<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev = \"\";\\n        ArrayList<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597106,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        if(words.size()==1)\\n        {\\n            return {words[0]};\\n        }\\n        vector<string>ans;\\n        string temp1=\"\";\\n        string temp2=\"\";\\n        int i=0;\\n        int j=1;\\n        temp1=words[i];\\n        sort(temp1.begin(),temp1.end());\\n        temp2=words[j];\\n        sort(temp2.begin(),temp2.end());\\n        while(j<words.size())\\n        {\\n            temp2=words[j];\\n            sort(temp2.begin(),temp2.end());\\n            if(temp1==temp2)\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                ans.push_back(words[i]);\\n                i=j;\\n                temp1=words[i];\\n                sort(temp1.begin(),temp1.end());\\n                j++;\\n            }\\n        }\\n        if(temp1==temp2)\\n        {\\n            ans.push_back(words[i]);\\n        }\\n        else\\n        {\\n             ans.push_back(words[i]);\\n              ans.push_back(words[j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        if(words.size()==1)\\n        {\\n            return {words[0]};\\n        }\\n        vector<string>ans;\\n        string temp1=\"\";\\n        string temp2=\"\";\\n        int i=0;\\n        int j=1;\\n        temp1=words[i];\\n        sort(temp1.begin(),temp1.end());\\n        temp2=words[j];\\n        sort(temp2.begin(),temp2.end());\\n        while(j<words.size())\\n        {\\n            temp2=words[j];\\n            sort(temp2.begin(),temp2.end());\\n            if(temp1==temp2)\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                ans.push_back(words[i]);\\n                i=j;\\n                temp1=words[i];\\n                sort(temp1.begin(),temp1.end());\\n                j++;\\n            }\\n        }\\n        if(temp1==temp2)\\n        {\\n            ans.push_back(words[i]);\\n        }\\n        else\\n        {\\n             ans.push_back(words[i]);\\n              ans.push_back(words[j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549497,
                "title": "my-js-solution-easy-and-simple-to-understand",
                "content": "```javascript\\nconst removeAnagrams = function(words) {  \\n  if (words.length === 0) return [];\\n  \\n const result = [words[0]];\\n  for (let i = 1, j = 0; i < words.length; i++) {\\n    const isAnagramTrue = isAnagram(result[j], words[i]);\\n    \\n    if (!isAnagramTrue) {\\n      result.push(words[i]);\\n      j++;\\n    }\\n  }\\n\\n  return result;\\n};\\n\\nconst isAnagram = function (str1, str2) {\\n  const firstStr = str1;\\n  const secondStr = str2;\\n  \\n  if (firstStr === secondStr) return true;\\n  if (firstStr.length !== secondStr.length) return false;\\n  \\n  const firstHashMap = {};\\n  const secondHashMap = {};\\n  \\n  for (let i = 0; i < firstStr.length; i++) {\\n    if (firstHashMap[firstStr[i]])\\n      firstHashMap[firstStr[i]]++;\\n    else\\n      firstHashMap[firstStr[i]] = 1;\\n    \\n    if (secondHashMap[secondStr[i]])\\n      secondHashMap[secondStr[i]]++;\\n    else \\n      secondHashMap[secondStr[i]] = 1;\\n  }\\n\\n  \\n  for (let i = 0; i < firstStr.length; i++) {\\n    if (firstHashMap[firstStr[i]] !== secondHashMap[firstStr[i]]) return false;\\n  }\\n  \\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst removeAnagrams = function(words) {  \\n  if (words.length === 0) return [];\\n  \\n const result = [words[0]];\\n  for (let i = 1, j = 0; i < words.length; i++) {\\n    const isAnagramTrue = isAnagram(result[j], words[i]);\\n    \\n    if (!isAnagramTrue) {\\n      result.push(words[i]);\\n      j++;\\n    }\\n  }\\n\\n  return result;\\n};\\n\\nconst isAnagram = function (str1, str2) {\\n  const firstStr = str1;\\n  const secondStr = str2;\\n  \\n  if (firstStr === secondStr) return true;\\n  if (firstStr.length !== secondStr.length) return false;\\n  \\n  const firstHashMap = {};\\n  const secondHashMap = {};\\n  \\n  for (let i = 0; i < firstStr.length; i++) {\\n    if (firstHashMap[firstStr[i]])\\n      firstHashMap[firstStr[i]]++;\\n    else\\n      firstHashMap[firstStr[i]] = 1;\\n    \\n    if (secondHashMap[secondStr[i]])\\n      secondHashMap[secondStr[i]]++;\\n    else \\n      secondHashMap[secondStr[i]] = 1;\\n  }\\n\\n  \\n  for (let i = 0; i < firstStr.length; i++) {\\n    if (firstHashMap[firstStr[i]] !== secondHashMap[firstStr[i]]) return false;\\n  }\\n  \\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2531100,
                "title": "find-resultant-array-after-removing-anagrams-solution",
                "content": "C++ Simple Solution\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> res;\\n        for(int i=0;i<words.size();i++){\\n            string str = words[i];\\n            sort(words[i].begin(),words[i].end());\\n            if( i > 0 && words[i]==words[i-1]) continue;\\n            res.push_back(str);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> res;\\n        for(int i=0;i<words.size();i++){\\n            string str = words[i];\\n            sort(words[i].begin(),words[i].end());\\n            if( i > 0 && words[i]==words[i-1]) continue;\\n            res.push_back(str);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530295,
                "title": "c-solution-faster-than-100",
                "content": "```\\npublic class Solution {\\n    public IList<string> RemoveAnagrams(string[] words) {\\n            IList<string> list = new List<string>();\\n            Stack<string> stack = new Stack<string>();\\n            int n = words.Length;\\n            for (int i = 0; i < n; i++)\\n            {\\n                char[] str = words[i].ToCharArray();\\n                Array.Sort(str);\\n                if (stack.Count == 0)\\n                {\\n                    stack.Push(new string(str));\\n                    list.Add(words[i]);\\n                }\\n                else\\n                {\\n                    if(!stack.Peek().Equals(new string(str)))\\n                    {\\n                        list.Add(words[i]);\\n                        stack.Push(new string(str));\\n                    }\\n                }\\n            }\\n            return list;\\n    }\\n}",
                "solutionTags": [
                    "C#",
                    "String",
                    "Stack"
                ],
                "code": "class Solution {\\n    public IList<string> RemoveAnagrams(string[] words) {\\n            IList<string> list = new List<string>();\\n            Stack<string> stack = new Stack<string>();\\n            int n = words.Length;\\n            for (int i = 0; i < n; i++)\\n            {\\n                char[] str = words[i].ToCharArray();\\n                Array.Sort(str);\\n                if (stack.Count == 0)\\n                {\\n                    stack.Push(new string(str));\\n                    list.Add(words[i]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2372879,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        print(res)\\n        for i in range(1,len(words)):\\n            if sorted(words[i])!=sorted(words[i-1]):\\n                res.append(words[i])\\n        return res\\n```\\n***if useful then vote up***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        print(res)\\n        for i in range(1,len(words)):\\n            if sorted(words[i])!=sorted(words[i-1]):\\n                res.append(words[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345096,
                "title": "java-o-n-2-solution-with-comments-to-understand-2-pointer-method",
                "content": "**Please Upvote if  you liked and simply understand the solution it means world to me!!**\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        for (int i = 0; i < words.length;) {\\n\\t\\t// we will run loop from 0 to words.length for i.\\n            int j;\\n            for (j = i + 1; j < words.length; j++) {\\n\\t\\t\\t// we will check if anagram strings or not\\n\\t\\t\\t// if not then we will break the looop\\n                if (!isAnagram(words[i], words[j])) {\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// after breaking the loop we will add our first anagram number ar ith index \\n\\t\\t\\t//after that we will set i to j\\n            ans.add(words[i]);\\n            i = j;\\n        }\\n\\n        return ans;\\n    }\\n\\t\\n\\t// function to know wheather two strings are anagram or not\\n    boolean isAnagram(String s, String t) {\\n\\t\\n\\t//if lengths of both strings is not equal they cannot be anagram\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\t\\t\\n\\t\\t//conver the both strings into the character arrays\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n\\t\\t\\n\\t\\t//sort the respectively both arrays\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n\\n\\t\\t// check if elements of both sorted arrays are equal or not\\n        for (int i = 0; i < c2.length; i++) {\\n            if (c1[i] != c2[i]) {\\n\\t\\t\\t// if elements are not equal then return false.\\n                return false;\\n            }\\n        }\\n\\t\\t// loop over means all the elements are equal so it is anagram reutrning true\\n        return true;\\n}\\n}\\n```\\n**Thank You!!**\\n**if you liked solution please upvote!!**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        for (int i = 0; i < words.length;) {\\n\\t\\t// we will run loop from 0 to words.length for i.\\n            int j;\\n            for (j = i + 1; j < words.length; j++) {\\n\\t\\t\\t// we will check if anagram strings or not\\n\\t\\t\\t// if not then we will break the looop\\n                if (!isAnagram(words[i], words[j])) {\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// after breaking the loop we will add our first anagram number ar ith index \\n\\t\\t\\t//after that we will set i to j\\n            ans.add(words[i]);\\n            i = j;\\n        }\\n\\n        return ans;\\n    }\\n\\t\\n\\t// function to know wheather two strings are anagram or not\\n    boolean isAnagram(String s, String t) {\\n\\t\\n\\t//if lengths of both strings is not equal they cannot be anagram\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\t\\t\\n\\t\\t//conver the both strings into the character arrays\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n\\t\\t\\n\\t\\t//sort the respectively both arrays\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n\\n\\t\\t// check if elements of both sorted arrays are equal or not\\n        for (int i = 0; i < c2.length; i++) {\\n            if (c1[i] != c2[i]) {\\n\\t\\t\\t// if elements are not equal then return false.\\n                return false;\\n            }\\n        }\\n\\t\\t// loop over means all the elements are equal so it is anagram reutrning true\\n        return true;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338945,
                "title": "py-nerd-counter-frequency-list-no-sorting",
                "content": "### The main idea:\\n1. use Counter or Frequency list to identify anagrams\\n2. use `prev` (the most recent Counter) to remove adjcent anagrams\\n\\nComment below for any questions / corrections\\n\\n\\n### how to implement Freq. list\\n```\\nlst = [0] * 26\\noffset = ord(\\'a\\')\\nfor c in s:\\n\\tlst[ord(c) - offset] +=1\\n```\\n\\n### Main algo\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = []\\n        prev = None\\n        for w in words:\\n            count = Counter(w)\\n            if count != prev:\\n                res.append(w)\\n                prev = count\\n        return res\\n    # time O(n * k) visit each word, and Counter takes k = longest word len\\n    # space O(n) at most save n words\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nlst = [0] * 26\\noffset = ord(\\'a\\')\\nfor c in s:\\n\\tlst[ord(c) - offset] +=1\\n```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = []\\n        prev = None\\n        for w in words:\\n            count = Counter(w)\\n            if count != prev:\\n                res.append(w)\\n                prev = count\\n        return res\\n    # time O(n * k) visit each word, and Counter takes k = longest word len\\n    # space O(n) at most save n words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227786,
                "title": "simple-and-easy-c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> res;\\n        res.push_back(words[0]);\\n        for(int i=1;i<words.size();i++)\\n        {\\n            string temp1 = words[i];\\n            string temp2 = words[i-1];\\n            sort(temp1.begin(), temp1.end());\\n            sort(temp2.begin(), temp2.end());\\n            if(temp1!= temp2)\\n                res.push_back(words[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> res;\\n        res.push_back(words[0]);\\n        for(int i=1;i<words.size();i++)\\n        {\\n            string temp1 = words[i];\\n            string temp2 = words[i-1];\\n            sort(temp1.begin(), temp1.end());\\n            sort(temp2.begin(), temp2.end());\\n            if(temp1!= temp2)\\n                res.push_back(words[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2110139,
                "title": "stack-based-solution-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    bool isanagram(string x,string y)\\n    {\\n        sort(x.begin(),x.end());\\n        sort(y.begin(),y.end());\\n        if(x==y)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        int i=0;\\n        stack<string>s;\\n        s.push(words[0]);\\n        for(int i=1;i<words.size();i++)\\n        {\\n            if(isanagram(s.top(),words[i]))\\n            {\\n                continue;\\n            }\\n            s.push(words[i]);\\n        }\\n        while(!s.empty())\\n        {\\n            ans.push_back(s.top());\\n            s.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2104358,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        \\n        tmp = words[0] \\n        words = words[1:]\\n        ans = [tmp] \\n        while words: \\n            if sorted(words[0]) != sorted(tmp): \\n                tmp = words[0]\\n                ans.append(tmp)\\n            words.pop(0)\\n                \\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        \\n        tmp = words[0] \\n        words = words[1:]\\n        ans = [tmp] \\n        while words: \\n            if sorted(words[0]) != sorted(tmp): \\n                tmp = words[0]\\n                ans.append(tmp)\\n            words.pop(0)\\n                \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2104211,
                "title": "simple-python-solution-easy-to-understand",
                "content": "```\\n\\n```def removeAnagrams(self, words: List[str]) -> List[str]:\\n        \\n        save = []\\n        save.append(words[0])\\n        \\n        for i in range(1, len(words)):\\n            save.append(words[i])\\n            if sorted(words[i]) == sorted(words[i-1]):\\n                save.pop()\\n        \\n        return save",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085199,
                "title": "swift-simple-and-easy-to-understand-solution",
                "content": "```\\nlass Solution {\\n    func removeAnagrams(_ words: [String]) -> [String] {\\n\\n        var answer = words\\n        var i = 0\\n\\n        while i < answer.count - 1 {\\n\\n            if answer[i].sorted() == answer[i+1].sorted() {\\n                answer.remove(at: i+1)\\n            } else {\\n                i += 1\\n            }\\n        }\\n\\t\\t\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nlass Solution {\\n    func removeAnagrams(_ words: [String]) -> [String] {\\n\\n        var answer = words\\n        var i = 0\\n\\n        while i < answer.count - 1 {\\n\\n            if answer[i].sorted() == answer[i+1].sorted() {\\n                answer.remove(at: i+1)\\n            } else {\\n                i += 1\\n            }\\n        }\\n\\t\\t\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2081579,
                "title": "easy-cpp-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        vector<string>temp=words;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            sort(temp[i].begin(),temp[i].end());\\n        }\\n        unordered_map<string,int>s;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            auto it=s.find(temp[i]);\\n            \\n            if(it==s.end()||i-it->second>1)\\n            {\\n               ans.push_back(words[i]);\\n            }\\n            else if(it!=s.end())\\n            {\\n                s.erase(temp[i]);\\n            }\\n            s[temp[i]]=i;\\n            \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        vector<string>temp=words;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            sort(temp[i].begin(),temp[i].end());\\n        }\\n        unordered_map<string,int>s;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            auto it=s.find(temp[i]);\\n            \\n            if(it==s.end()||i-it->second>1)\\n            {\\n               ans.push_back(words[i]);\\n            }\\n            else if(it!=s.end())\\n            {\\n                s.erase(temp[i]);\\n            }\\n            s[temp[i]]=i;\\n            \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077569,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        res.add(words[0]);\\n        for(int i=1; i<words.length; i++){\\n            String left = toSorted(words[i-1]);\\n            String right = toSorted(words[i]);\\n            if(!left.equals(right)){\\n                res.add(words[i]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public String toSorted(String strs){\\n        char[] ch = strs.toCharArray();\\n        Arrays.sort(ch);\\n        String key = String.valueOf(ch);\\n       \\n        return key;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        res.add(words[0]);\\n        for(int i=1; i<words.length; i++){\\n            String left = toSorted(words[i-1]);\\n            String right = toSorted(words[i]);\\n            if(!left.equals(right)){\\n                res.add(words[i]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public String toSorted(String strs){\\n        char[] ch = strs.toCharArray();\\n        Arrays.sort(ch);\\n        String key = String.valueOf(ch);\\n       \\n        return key;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067894,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isequal(string x, string y) {\\n        vector<int> ans(26, 0);\\n        for (int j = 0; j < x.size(); j++) {\\n            ans[x[j] - \\'a\\']++;\\n        }\\n        for (int k = 0; k < y.size(); k++) {\\n            ans[y[k] - \\'a\\']--;\\n        }\\n        for (int k = 0; k < ans.size(); k++) {\\n            if (ans[k] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> harsh;\\n        for (int i = 0; i < words.size();) {\\n            int j = i + 1;\\n            for (; j < words.size() and isequal(words[i], words[j]);) {\\n                j++;\\n            }\\n            harsh.push_back(words[i]);\\n            i = j;\\n        }\\n        return harsh;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isequal(string x, string y) {\\n        vector<int> ans(26, 0);\\n        for (int j = 0; j < x.size(); j++) {\\n            ans[x[j] - \\'a\\']++;\\n        }\\n        for (int k = 0; k < y.size(); k++) {\\n            ans[y[k] - \\'a\\']--;\\n        }\\n        for (int k = 0; k < ans.size(); k++) {\\n            if (ans[k] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> harsh;\\n        for (int i = 0; i < words.size();) {\\n            int j = i + 1;\\n            for (; j < words.size() and isequal(words[i], words[j]);) {\\n                j++;\\n            }\\n            harsh.push_back(words[i]);\\n            i = j;\\n        }\\n        return harsh;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066230,
                "title": "python3-solution-readable",
                "content": "```\\nclass Solution:\\n    \\n    def anagram_detector(self, a: str, b: str) -> bool:\\n        a =sorted(list(a))\\n        b = sorted(list(b))\\n        if a == b:\\n            return True\\n        else:\\n            return False\\n        \\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        if len(words) == 1:\\n            return words\\n        while len(words) > 2:\\n            detected = False\\n            for i in range(1,len(words)):\\n                if self.anagram_detector(words[i],words[i-1]):\\n                    del words[i]\\n                    detected = True\\n                    break\\n            if not detected:\\n                return words\\n        if self.anagram_detector(words[0],words[1]):\\n            del words[1]\\n        return words\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def anagram_detector(self, a: str, b: str) -> bool:\\n        a =sorted(list(a))\\n        b = sorted(list(b))\\n        if a == b:\\n            return True\\n        else:\\n            return False\\n        \\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        if len(words) == 1:\\n            return words\\n        while len(words) > 2:\\n            detected = False\\n            for i in range(1,len(words)):\\n                if self.anagram_detector(words[i],words[i-1]):\\n                    del words[i]\\n                    detected = True\\n                    break\\n            if not detected:\\n                return words\\n        if self.anagram_detector(words[0],words[1]):\\n            del words[1]\\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064281,
                "title": "java-simple-fast-low-memory",
                "content": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        ArrayList<String> ans = new ArrayList<>(words.length);\\n        byte[] sign = new byte[26], tmp, buf = new byte[26];\\n        for (String s : words) {\\n            Arrays.fill(buf, (byte) 0);\\n            for (int i=0, slen=s.length(); i < slen; i++) {\\n                buf[s.charAt(i) - \\'a\\']++;\\n            }\\n            if (Arrays.equals(sign, buf)) continue;\\n            tmp = sign; sign = buf; buf = tmp; // swap\\n            ans.add(s);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        ArrayList<String> ans = new ArrayList<>(words.length);\\n        byte[] sign = new byte[26], tmp, buf = new byte[26];\\n        for (String s : words) {\\n            Arrays.fill(buf, (byte) 0);\\n            for (int i=0, slen=s.length(); i < slen; i++) {\\n                buf[s.charAt(i) - \\'a\\']++;\\n            }\\n            if (Arrays.equals(sign, buf)) continue;\\n            tmp = sign; sign = buf; buf = tmp; // swap\\n            ans.add(s);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054934,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String>res = new LinkedList<>();\\n        for (String word:words){\\n            if (res.isEmpty() || !isAnagram(word, res.get(res.size()-1)))res.add(word);\\n        }\\n        return res;\\n    }\\n    \\n    public Boolean isAnagram(String w1, String w2){\\n        if (w1.length()!=w2.length())return false;\\n        else {\\n            char[] word1 = w1.toCharArray();\\n            Arrays.sort(word1);\\n            char[] word2 = w2.toCharArray();\\n            Arrays.sort(word2);\\n            return Arrays.equals(word1, word2);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String>res = new LinkedList<>();\\n        for (String word:words){\\n            if (res.isEmpty() || !isAnagram(word, res.get(res.size()-1)))res.add(word);\\n        }\\n        return res;\\n    }\\n    \\n    public Boolean isAnagram(String w1, String w2){\\n        if (w1.length()!=w2.length())return false;\\n        else {\\n            char[] word1 = w1.toCharArray();\\n            Arrays.sort(word1);\\n            char[] word2 = w2.toCharArray();\\n            Arrays.sort(word2);\\n            return Arrays.equals(word1, word2);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054810,
                "title": "4-lines-solution-with-counter",
                "content": "What do you think about this solution?\\n\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n\\t\\t\\t# `Counter` makes a letter frequency dictionary\\n\\t\\t\\t#  the == operator compares the two dictionaries\\n\\t\\t\\t#  if anagrams then delete the next word\\n\\t\\t\\t#  otherwise, we increment the pointer\\n        \\n        pointer = 0\\n        while pointer < len(words)-1:\\n            if ( Counter(words[pointer]) == Counter(words[pointer+1])  ):\\n                words.pop(pointer+1)\\n            else:\\n                pointer+=1\\n        return words\\n\\t```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n\\t\\t\\t# `Counter` makes a letter frequency dictionary\\n\\t\\t\\t#  the == operator compares the two dictionaries\\n\\t\\t\\t#  if anagrams then delete the next word\\n\\t\\t\\t#  otherwise, we increment the pointer\\n        \\n        pointer = 0\\n        while pointer < len(words)-1:\\n            if ( Counter(words[pointer]) == Counter(words[pointer+1])  ):\\n                words.pop(pointer+1)\\n            else:\\n                pointer+=1\\n        return words\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2053561,
                "title": "c-easy-understanding-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n    /* \\n      words[i-1] and words[i] are anagrams when:\\n        +) words[i-1].size() == words[i].size();\\n        +) occurrence of each letter in words[i] equals to that in words[i-1]\\n    */\\n    for (int i = 1; i < words.size();){\\n        // We iterate from 1 to the end of list\\n        map<char, int> mp1, mp2;\\n        // We use map to store the occurrence of each letter in words[i] and words[i-1]\\n        for(char &x : words[i-1]) mp1[x]++;\\n        for(char &x : words[i]) mp2[x]++;\\n        if(mp1 == mp2){\\n            // If words[i] and words[i-1] are anagrams, we delete words[i] from the list\\n            words.erase(words.begin()+i);\\n        }else i++;\\n    }\\n    return words;        \\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n    /* \\n      words[i-1] and words[i] are anagrams when:\\n        +) words[i-1].size() == words[i].size();\\n        +) occurrence of each letter in words[i] equals to that in words[i-1]\\n    */\\n    for (int i = 1; i < words.size();){\\n        // We iterate from 1 to the end of list\\n        map<char, int> mp1, mp2;\\n        // We use map to store the occurrence of each letter in words[i] and words[i-1]\\n        for(char &x : words[i-1]) mp1[x]++;\\n        for(char &x : words[i]) mp2[x]++;\\n        if(mp1 == mp2){\\n            // If words[i] and words[i-1] are anagrams, we delete words[i] from the list\\n            words.erase(words.begin()+i);\\n        }else i++;\\n    }\\n    return words;        \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050674,
                "title": "java-solution",
                "content": "```java \\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        ArrayList<String> a = new ArrayList<String>();\\n        a.add(words[0]);\\n        for(int i=1;i<words.length;i++)\\n        {\\n            if(check(words[i],words[i-1])==false)\\n                a.add(words[i]);\\n        }\\n        return a;\\n    }\\n    \\n    private boolean check(String s, String t)\\n    {\\n        int[] a = new int[26];\\n        int[] b = new int[26];\\n        \\n        for(int i=0;i<Math.max(s.length(),t.length());i++)\\n        {\\n            if(i<s.length())\\n            a[s.charAt(i)-\\'a\\']++;\\n            if(i<t.length())\\n            b[t.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            if(a[i]!=b[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        ArrayList<String> a = new ArrayList<String>();\\n        a.add(words[0]);\\n        for(int i=1;i<words.length;i++)\\n        {\\n            if(check(words[i],words[i-1])==false)\\n                a.add(words[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2046324,
                "title": "python3-simple",
                "content": "itertools.groupby is very cool but this is more beginner friendly\\n\\n```python\\ndef removeAnagrams(self, words: List[str]) -> List[str]:\\n        last_sorted_word = \\'\\'\\n        res = []\\n        for w in words:\\n            cur_sorted_word = \\'\\'.join(sorted(w))\\n            if cur_sorted_word != last_sorted_word:\\n                res.append(w)\\n            last_sorted_word = cur_sorted_word\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef removeAnagrams(self, words: List[str]) -> List[str]:\\n        last_sorted_word = \\'\\'\\n        res = []\\n        for w in words:\\n            cur_sorted_word = \\'\\'.join(sorted(w))\\n            if cur_sorted_word != last_sorted_word:\\n                res.append(w)\\n            last_sorted_word = cur_sorted_word\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2042701,
                "title": "python-beat-both-100-no-sort-but-dictionary",
                "content": "sort will cause log(l) factor. \\nTo match, we have two approches. One is to make them ordered, so that we can compare one by one, at cost of O(logL) (L is length)\\nBut we want to know if exist or not. So why don\\'t we use dictionary(counter) instead?  Same length, and for each char, the count is same. Then the COUNT of each char is matched. and it saves a logL.\\n```\\nclass Solution(object):\\n    def removeAnagrams(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        D = Counter(words[0])\\n        res = [words[0]]\\n        for word in words[1:]:\\n            temp = Counter(word)\\n            \\n            found = True\\n            if len(temp) != len(D):\\n                found = False\\n            for key in temp:\\n                if temp[key]!= D[key]:\\n                    found = False\\n                    break\\n            if not found:\\n                res.append(word)\\n            D = temp\\n        return res\\n\\t\\t``",
                "solutionTags": [
                    "Python"
                ],
                "code": "sort will cause log(l) factor. \\nTo match, we have two approches. One is to make them ordered, so that we can compare one by one, at cost of O(logL) (L is length)\\nBut we want to know if exist or not. So why don\\'t we use dictionary(counter) instead?  Same length, and for each char, the count is same. Then the COUNT of each char is matched. and it saves a logL.\\n```\\nclass Solution(object):\\n    def removeAnagrams(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        D = Counter(words[0])\\n        res = [words[0]]\\n        for word in words[1:]:\\n            temp = Counter(word)\\n            \\n            found = True\\n            if len(temp) != len(D):\\n                found = False\\n            for key in temp:\\n                if temp[key]!= D[key]:\\n                    found = False\\n                    break\\n            if not found:\\n                res.append(word)\\n            D = temp\\n        return res\\n\\t\\t``",
                "codeTag": "Java"
            },
            {
                "id": 2041969,
                "title": "without-sorting-c-o-n-using-set",
                "content": "```\\nvector<string> removeAnagrams(vector<string>& words) {\\n        unordered_set<int> set;\\n        for(int i = 0; i < words.size() - 1; i++) {\\n            string s = words[i];\\n            string t = words[i + 1];\\n\\n            if(s.size() == t.size()) {\\n                vector<int> v(26, 0);\\n                int sChars = s.size();\\n\\n                for(int j = 0; j < s.length(); j++) v[s[j] - \\'a\\']++;\\n\\n                vector<int> h = v;\\n                int tChars = sChars;\\n\\n                for(int k = 0; k < t.size(); k++)\\n                    if(h[t[k] - \\'a\\']-- >= 1)\\n                        tChars--;\\n\\n                if(tChars == 0) set.insert(i + 1);\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i = 0; i < words.size(); i++) {\\n            if(set.find(i) == set.end())\\n                ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> removeAnagrams(vector<string>& words) {\\n        unordered_set<int> set;\\n        for(int i = 0; i < words.size() - 1; i++) {\\n            string s = words[i];\\n            string t = words[i + 1];\\n\\n            if(s.size() == t.size()) {\\n                vector<int> v(26, 0);\\n                int sChars = s.size();\\n\\n                for(int j = 0; j < s.length(); j++) v[s[j] - \\'a\\']++;\\n\\n                vector<int> h = v;\\n                int tChars = sChars;\\n\\n                for(int k = 0; k < t.size(); k++)\\n                    if(h[t[k] - \\'a\\']-- >= 1)\\n                        tChars--;\\n\\n                if(tChars == 0) set.insert(i + 1);\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i = 0; i < words.size(); i++) {\\n            if(set.find(i) == set.end())\\n                ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2041397,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn remove_anagrams(words: Vec<String>) -> Vec<String> {\\n        let mut res = vec![];\\n        let mut prev_count = [0; 26];\\n        for word in words {\\n            let mut count = [0; 26];\\n            word.bytes().for_each(|b| count[(b - b\\'a\\') as usize] += 1);\\n            \\n            if prev_count != count {\\n                res.push(word);\\n            }\\n            prev_count = count;\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn remove_anagrams(words: Vec<String>) -> Vec<String> {\\n        let mut res = vec![];\\n        let mut prev_count = [0; 26];\\n        for word in words {\\n            let mut count = [0; 26];\\n            word.bytes().for_each(|b| count[(b - b\\'a\\') as usize] += 1);\\n            \\n            if prev_count != count {\\n                res.push(word);\\n            }\\n            prev_count = count;\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2041302,
                "title": "c-map-vector-easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& s) {\\n         unordered_map<string,int> mp;\\n        vector<string> ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string t=s[i];\\n            sort(t.begin(),t.end());\\n            if(!mp.count(t) or i-mp[t]>1)\\n                ans.push_back(s[i]); \\n            mp[t]=i;\\n        }\\n      \\n    return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& s) {\\n         unordered_map<string,int> mp;\\n        vector<string> ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string t=s[i];\\n            sort(t.begin(),t.end());\\n            if(!mp.count(t) or i-mp[t]>1)\\n                ans.push_back(s[i]); \\n            mp[t]=i;\\n        }\\n      \\n    return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040180,
                "title": "100-faster-and-easy-solution-explained-5-liner",
                "content": "```\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        stack=[words[0]]      #We need a stack for this beacuse we have to delete those who are same as first one \\n        for i in range(len(words)):\\n            if stack:\\n                pr=sorted(stack[-1])       #We have to sort last element of stack and our current element\\n                cur=sorted(words[i])\\n                if pr!=cur :     #If they are equal we don\\'t add it to stack else we append it to stack\\n                    stack.append(words[i])            \\n        return stack\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        stack=[words[0]]      #We need a stack for this beacuse we have to delete those who are same as first one \\n        for i in range(len(words)):\\n            if stack:\\n                pr=sorted(stack[-1])       #We have to sort last element of stack and our current element\\n                cur=sorted(words[i])\\n                if pr!=cur :     #If they are equal we don\\'t add it to stack else we append it to stack\\n                    stack.append(words[i])            \\n        return stack\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2040106,
                "title": "c-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string sortStr(string s){\\n        sort(s.begin(),s.end());\\n        return s;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        int i=0;\\n        int j=0;\\n        while(i<words.size() || j<words.size()){\\n            string temp = sortStr(words[j]);\\n            \\n            ans.push_back(words[j]);\\n            while(i<words.size() and temp==sortStr(words[i]))\\n                i++;\\n        j = i;\\n        i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string sortStr(string s){\\n        sort(s.begin(),s.end());\\n        return s;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        int i=0;\\n        int j=0;\\n        while(i<words.size() || j<words.size()){\\n            string temp = sortStr(words[j]);\\n            \\n            ans.push_back(words[j]);\\n            while(i<words.size() and temp==sortStr(words[i]))\\n                i++;\\n        j = i;\\n        i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040097,
                "title": "unnecessarily-complicated-the-description-c-solution",
                "content": "If the anagram of current word is present in the map and the index of that anagram is current index - 1, we get the required word.\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        unordered_map<string, int> found;\\n \\n        for (int i = 0; i < words.size(); i++) {\\n              string word = words[i];\\n              sort(begin(word), end(word));\\n\\n        if (found.find(word) == found.end() || found[word] != i - 1) {\\n            ans.push_back(words[i]);\\n        }\\n        found[word] = i;\\n    }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        unordered_map<string, int> found;\\n \\n        for (int i = 0; i < words.size(); i++) {\\n              string word = words[i];\\n              sort(begin(word), end(word));\\n\\n        if (found.find(word) == found.end() || found[word] != i - 1) {\\n            ans.push_back(words[i]);\\n        }\\n        found[word] = i;\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039952,
                "title": "find-resultant-array-after-removing-anagrams",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int i=1;\\n        while(i<words.size()){\\n            string a = words[i];\\n            string b = words[i-1];\\n            sort(a.begin(),a.end());\\n            sort(b.begin(),b.end());\\n            if(a == b){\\n                words.erase (words.begin()+i);\\n            }else{\\n                i++;\\n            }\\n        }\\n        \\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int i=1;\\n        while(i<words.size()){\\n            string a = words[i];\\n            string b = words[i-1];\\n            sort(a.begin(),a.end());\\n            sort(b.begin(),b.end());\\n            if(a == b){\\n                words.erase (words.begin()+i);\\n            }else{\\n                i++;\\n            }\\n        }\\n        \\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039935,
                "title": "easy-c",
                "content": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n       for(int i = 1;i<words.size();i++){\\n            string str1 = words[i];\\n            sort(str1.begin(),str1.end());\\n            string str2 = words[i-1];\\n            sort(str2.begin(),str2.end());\\n            if(str1 == str1){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n       for(int i = 1;i<words.size();i++){\\n            string str1 = words[i];\\n            sort(str1.begin(),str1.end());\\n            string str2 = words[i-1];\\n            sort(str2.begin(),str2.end());\\n            if(str1 == str1){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2039928,
                "title": "easy-n-k-log-k-solution-k-is-average-size-of-string",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) \\n    {\\n        int n=words.size();\\n        vector<pair<int,string>>g;\\n        for(int i=0;i<n;i++)\\n        {\\n            //temporary vectory storing original strings with index\\n            g.push_back({i,words[i]});\\n        }\\n        for(int i=0;i<n;i++)\\n          {  \\n            //sorting string for comparison\\n            sort(words[i].begin(),words[i].end());\\n          }\\n        vector<pair<string,int>>v;\\n        v.push_back({words[0],0});\\n        for(int i=1;i<n;i++)\\n        {\\n            if(words[i]==(v[(v.size()-1)].first))\\n            {\\n                //dont put into vector if same string\\n            }\\n            else\\n            {\\n                v.push_back({words[i],i});\\n            }\\n        }\\n        vector<string>ans;\\n        int len=v.size();\\n        for(int i=0;i<len;i++)\\n        {\\n            int t=v[i].second;\\n            for(int j=0;j<n;j++)\\n            {\\n                int t1=g[j].first;\\n                //retrieving original string\\n                if(t==t1)\\n                {\\n                    ans.push_back(g[j].second);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) \\n    {\\n        int n=words.size();\\n        vector<pair<int,string>>g;\\n        for(int i=0;i<n;i++)\\n        {\\n            //temporary vectory storing original strings with index\\n            g.push_back({i,words[i]}",
                "codeTag": "Java"
            },
            {
                "id": 2039920,
                "title": "cpp-2-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int i=0,j=1;\\n        int n = words.size();\\n        vector<string> res;\\n        while(j<n){\\n            string str1 = words[j], str2= words[i];\\n            sort(str1.begin(),str1.end());\\n            sort(str2.begin(),str2.end());\\n            if(str1==str2){\\n                words[j] = \"-1\";\\n                j++;\\n            }\\n            else{\\n                i=j;\\n                j++;\\n            }\\n        }\\n        for(auto str:words){\\n            if(str!=\"-1\"){\\n                res.push_back(str);\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int i=0,j=1;\\n        int n = words.size();\\n        vector<string> res;\\n        while(j<n){\\n            string str1 = words[j], str2= words[i];\\n            sort(str1.begin(),str1.end());\\n            sort(str2.begin(),str2.end());\\n            if(str1==str2){\\n                words[j] = \"-1\";\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2039901,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        for (int i = words.length - 1; i > 0; i--){\\n            if(helper(words[i], words[i-1]) == false){\\n                ans.add(words[i]);\\n            }\\n        }\\n        ans.add(words[0]);\\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n    \\n    public boolean helper(String s1, String s2){\\n        if(s1.length() != s2.length()) return false;\\n        char[] c1 = s1.toCharArray();\\n        char[] c2 = s2.toCharArray();\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n        for(int i = 0; i < c1.length; i++){\\n            if(c1[i] != c2[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        for (int i = words.length - 1; i > 0; i--){\\n            if(helper(words[i], words[i-1]) == false){\\n                ans.add(words[i]);\\n            }\\n        }\\n        ans.add(words[0]);\\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n    \\n    public boolean helper(String s1, String s2){\\n        if(s1.length() != s2.length()) return false;\\n        char[] c1 = s1.toCharArray();\\n        char[] c2 = s2.toCharArray();\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n        for(int i = 0; i < c1.length; i++){\\n            if(c1[i] != c2[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039864,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        unordered_map<char,int> mp;\\n        for(char c:s1) mp[c]++;\\n        for(char c:s2) mp[c]--;\\n        \\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            if(itr->second != 0) return false;\\n        }\\n        return true;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        for(string word:words)\\n        {\\n            if(ans.empty()) ans.push_back(word);\\n            else\\n            {\\n                if(isAnagram(word,ans[ans.size()-1]))\\n                    continue;\\n                ans.push_back(word);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        unordered_map<char,int> mp;\\n        for(char c:s1) mp[c]++;\\n        for(char c:s2) mp[c]--;\\n        \\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            if(itr->second != 0) return false;\\n        }\\n        return true;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        for(string word:words)\\n        {\\n            if(ans.empty()) ans.push_back(word);\\n            else\\n            {\\n                if(isAnagram(word,ans[ans.size()-1]))\\n                    continue;\\n                ans.push_back(word);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039828,
                "title": "c-easy-to-understand-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        int n=words.size();\\n        int i=0;\\n        while(i<n){\\n            string s=words[i];\\n            int cnt[26]={0};\\n            for(auto k:s) cnt[k-\\'a\\']++;\\n            int j=i+1;\\n            while(j<n){\\n                string s2=words[j];\\n                int cnt2[26]={0};\\n                for(auto k:s2) cnt2[k-\\'a\\']++;\\n                bool f=0;\\n                for(int k=0;k<26;k++){\\n                    if(cnt[k]!=cnt2[k]){ f=1; break;}\\n                }\\n                if(f) break; \\n                j++;\\n            }\\n            i=j;\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        int n=words.size();\\n        int i=0;\\n        while(i<n){\\n            string s=words[i];\\n            int cnt[26]={0};\\n            for(auto k:s) cnt[k-\\'a\\']++;\\n            int j=i+1;\\n            while(j<n){\\n                string s2=words[j];\\n                int cnt2[26]={0};\\n                for(auto k:s2) cnt2[k-\\'a\\']++;\\n                bool f=0;\\n                for(int k=0;k<26;k++){\\n                    if(cnt[k]!=cnt2[k]){ f=1; break;}\\n                }\\n                if(f) break; \\n                j++;\\n            }\\n            i=j;\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039804,
                "title": "c-simple-and-straight-forward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        if(words.size()<=1){\\n            return words;\\n        }\\n        vector<string> temp = words;\\n        for(int i=0;i<words.size();i++){\\n            sort(temp[i].begin(),temp[i].end()); // sorting to make work easier in temporary array\\n        }\\n        vector<string> ans;\\n        // for(int i=0;i<words.size();i++){\\n        //     cout<<temp[i]<<endl;\\n        // }\\n        int i=0,j=1;\\n        // we will add the first words[i] which comes in array with anagrams\\n        while( (i < words.size()) && (j < words.size())){\\n            if(temp[i]!=temp[j]){ // we push first anagram , when next is not equal to previous as it means the word has changed and we update to new word anagram\\n                ans.push_back(words[i]);\\n                i=j;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n            \\n            \\n            // cout<<ans[i]<<endl;\\n        }\\n        j = words.size()-1;\\n        if(  (temp[j-1] != temp[j])){\\n                ans.push_back(words[j]);\\n                // break;\\n                \\n        }\\n        if((j==words.size()-1) && (temp[j-1] == temp[j])){\\n            ans.push_back(words[i]);\\n                // break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        if(words.size()<=1){\\n            return words;\\n        }\\n        vector<string> temp = words;\\n        for(int i=0;i<words.size();i++){\\n            sort(temp[i].begin(),temp[i].end()); // sorting to make work easier in temporary array\\n        }\\n        vector<string> ans;\\n        // for(int i=0;i<words.size();i++){\\n        //     cout<<temp[i]<<endl;\\n        // }\\n        int i=0,j=1;\\n        // we will add the first words[i] which comes in array with anagrams\\n        while( (i < words.size()) && (j < words.size())){\\n            if(temp[i]!=temp[j]){ // we push first anagram , when next is not equal to previous as it means the word has changed and we update to new word anagram\\n                ans.push_back(words[i]);\\n                i=j;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n            \\n            \\n            // cout<<ans[i]<<endl;\\n        }\\n        j = words.size()-1;\\n        if(  (temp[j-1] != temp[j])){\\n                ans.push_back(words[j]);\\n                // break;\\n                \\n        }\\n        if((j==words.size()-1) && (temp[j-1] == temp[j])){\\n            ans.push_back(words[i]);\\n                // break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2039790,
                "title": "c-short-solutions-with-explanation-2-approaches-for-comparing-words",
                "content": "**Approach 1:** Using Multiset\\n\\nMultisets are a type of associative containers similar to the set, with the exception that multiple elements can have the same values.\\n* Compare multisets of adjacent words\\n* If multisets are equal, erase next word and decrease the index\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i=0; i < words.size()-1; i++)\\n            if(multiset<char>(words[i].begin(), words[i].end()) == multiset<char>(words[i+1].begin(), words[i+1].end()))\\n                words.erase(words.begin() + 1 + i--);\\n        return words;\\n    }\\n};\\n```\\n**Approach 2:** Using Map\\n* Make maps for adjacent words to count frequency for all letters\\n* If maps are equal, erase next word and decrease the index\\n```\\nclass Solution {\\npublic:\\n    bool isagm(string s1,string s2){\\n        map<char,int>m1,m2;\\n        for(auto i:s1)  m1[i]++;\\n        for(auto i:s2)  m2[i]++;\\n        return m1==m2;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i=0; i < words.size()-1; i++)\\n            if(isagm(words[i], words[i+1]))     words.erase(words.begin() + 1 + i--);\\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i=0; i < words.size()-1; i++)\\n            if(multiset<char>(words[i].begin(), words[i].end()) == multiset<char>(words[i+1].begin(), words[i+1].end()))\\n                words.erase(words.begin() + 1 + i--);\\n        return words;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isagm(string s1,string s2){\\n        map<char,int>m1,m2;\\n        for(auto i:s1)  m1[i]++;\\n        for(auto i:s2)  m2[i]++;\\n        return m1==m2;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i=0; i < words.size()-1; i++)\\n            if(isagm(words[i], words[i+1]))     words.erase(words.begin() + 1 + i--);\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039788,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n          int index  = 1 ;\\n          vector<string> ans, word_cp ; \\n          word_cp = words ; \\n          int j =0 ; \\n          for(int i = 0 ; i < words.size(); i ++) {\\n              sort(words[i].begin(), words[i].end()); \\n               if(ans.size() == 0 ) {\\n                    ans.push_back(word_cp[i]); \\n               }else {\\n                   if(ans.size() > 0  and words[j] != words[i]) {\\n                        j = i ; \\n                        ans.push_back(word_cp[i]); \\n                   } \\n               }\\n          }\\n        return ans ; \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n          int index  = 1 ;\\n          vector<string> ans, word_cp ; \\n          word_cp = words ; \\n          int j =0 ; \\n          for(int i = 0 ; i < words.size(); i ++) {\\n              sort(words[i].begin(), words[i].end()); \\n               if(ans.size() == 0 ) {\\n                    ans.push_back(word_cp[i]); \\n               }else {\\n                   if(ans.size() > 0  and words[j] != words[i]) {\\n                        j = i ; \\n                        ans.push_back(word_cp[i]); \\n                   } \\n               }\\n          }\\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039787,
                "title": "iterative-solution-o-n-loop",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i =0 \\n        while i < len(words)-1:\\n            if Counter(words[i]) == Counter(words[i+1]):\\n                words.pop(i+1)\\n            else:\\n                i += 1\\n        return words\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i =0 \\n        while i < len(words)-1:\\n            if Counter(words[i]) == Counter(words[i+1]):\\n                words.pop(i+1)\\n            else:\\n                i += 1\\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039781,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\n    bool areAnagram(string str1, string str2){\\n        int n1 = str1.length();\\n        int n2 = str2.length();\\n        if (n1 != n2)\\n            return false;\\n\\n        sort(str1.begin(), str1.end());\\n        sort(str2.begin(), str2.end());\\n\\n        for (int i = 0; i < n1; i++)\\n            if (str1[i] != str2[i])\\n                return false;\\n\\n        return true;\\n    }\\npublic:\\n    vector<string> removeAnagrams(vector<string>& w) {\\n        for(int i=1; i<w.size(); i++){\\n            if(areAnagram(w[i-1], w[i])){\\n                w.erase(w.begin() + i);\\n                i--;\\n            }\\n        }\\n        return w;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    bool areAnagram(string str1, string str2){\\n        int n1 = str1.length();\\n        int n2 = str2.length();\\n        if (n1 != n2)\\n            return false;\\n\\n        sort(str1.begin(), str1.end());\\n        sort(str2.begin(), str2.end());\\n\\n        for (int i = 0; i < n1; i++)\\n            if (str1[i] != str2[i])\\n                return false;\\n\\n        return true;\\n    }\\npublic:\\n    vector<string> removeAnagrams(vector<string>& w) {\\n        for(int i=1; i<w.size(); i++){\\n            if(areAnagram(w[i-1], w[i])){\\n                w.erase(w.begin() + i);\\n                i--;\\n            }\\n        }\\n        return w;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039709,
                "title": "easy-solution-with-sort-how-i-wasted-first-30-minutes-in-contest",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 0 ; i < words.size() -1; i++){\\n            int idx = i;\\n            string s1 = words[i];\\n            sort(s1.begin(),s1.end());\\n            string s2 = words[i+1];\\n            sort(s2.begin(),s2.end());\\n            if(s1 == s2){\\n                words.erase(words.begin() + i+1);\\n                i = idx - 1;\\n            }\\n         }\\n        return words;\\n        \\n    }\\n};\\n```\\n\\n**2 days ago i have solved question no 49. Group Anagrams  problem and today in contest when i saw the test cases of this problem i think it\\'s almost same . . and i have started solving with my previous approach . and wasted 30 minutes . \\nand then read the question carefully .**\\n\\n***So specially beginners please always read the question carefully . don\\'t be overconfident*** \\n",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 0 ; i < words.size() -1; i++){\\n            int idx = i;\\n            string s1 = words[i];\\n            sort(s1.begin(),s1.end());\\n            string s2 = words[i+1];\\n            sort(s2.begin(),s2.end());\\n            if(s1 == s2){\\n                words.erase(words.begin() + i+1);\\n                i = idx - 1;\\n            }\\n         }\\n        return words;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081776,
                "title": "find-resultant-array-after-removing-anagrams",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate a function to check anagaram between two words, if true remove them and repeat the process\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\n const removeAnagrams =   function(words) {\\n    if(words.length === 0) { return false}\\n    let i = 0;\\n     while (i < words.length - 1) {\\n        if(!words[i+1]){ return;}\\n\\n        const ifAnagram =  validAnagram(words[i], words[i+1])\\n   if (ifAnagram){\\n       words.splice(i+1,1)\\n  \\n   }else{\\n   i+=1}\\n    }\\n    return words\\n};\\n\\n function validAnagram(str1, str2) {\\n  if (str1.length !== str2.length) {\\n    return false;\\n  }\\n\\n  let first = {};\\n  let second = {};\\n\\n  for (let i = 0; i < str1.length; i++) {\\n    first[str1[i]] = (first[str1[i]] || 0) + 1;\\n    second[str2[i]] = (second[str2[i]] || 0) + 1;\\n  }\\n\\n  console.log(first, second);\\n\\n  for (let key in first) {\\n    if (!(key in second)) {\\n      return false;\\n    }\\n    if (second[key] !== first[key]) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\n const removeAnagrams =   function(words) {\\n    if(words.length === 0) { return false}\\n    let i = 0;\\n     while (i < words.length - 1) {\\n        if(!words[i+1]){ return;}\\n\\n        const ifAnagram =  validAnagram(words[i], words[i+1])\\n   if (ifAnagram){\\n       words.splice(i+1,1)\\n  \\n   }else{\\n   i+=1}\\n    }\\n    return words\\n};\\n\\n function validAnagram(str1, str2) {\\n  if (str1.length !== str2.length) {\\n    return false;\\n  }\\n\\n  let first = {};\\n  let second = {};\\n\\n  for (let i = 0; i < str1.length; i++) {\\n    first[str1[i]] = (first[str1[i]] || 0) + 1;\\n    second[str2[i]] = (second[str2[i]] || 0) + 1;\\n  }\\n\\n  console.log(first, second);\\n\\n  for (let key in first) {\\n    if (!(key in second)) {\\n      return false;\\n    }\\n    if (second[key] !== first[key]) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079550,
                "title": "easy-cpp-solution-beats-93-3-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/7f806d18-d0f6-4b9e-b408-0189ba787cdf_1695453036.5051134.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        int sz=words.size();\\n        vector<bool> vis(sz, false);\\n        for(int i=0; i<sz; i++){\\n            if(vis[i]) continue;\\n            int t = 0;\\n            string tmp = words[i];\\n            sort(tmp.begin(), tmp.end());\\n            for(int j=i+1; j<sz; j++){\\n                if(t != j-i-1) break;\\n                if(words[i].length() == words[j].length() && vis[j] == false){\\n                    string tmp2 = words[j];\\n                    sort(tmp2.begin(), tmp2.end());\\n                    if(tmp == tmp2){\\n                        vis[j] = true;\\n                        t++;\\n                    }\\n                }\\n            }\\n            ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        int sz=words.size();\\n        vector<bool> vis(sz, false);\\n        for(int i=0; i<sz; i++){\\n            if(vis[i]) continue;\\n            int t = 0;\\n            string tmp = words[i];\\n            sort(tmp.begin(), tmp.end());\\n            for(int j=i+1; j<sz; j++){\\n                if(t != j-i-1) break;\\n                if(words[i].length() == words[j].length() && vis[j] == false){\\n                    string tmp2 = words[j];\\n                    sort(tmp2.begin(), tmp2.end());\\n                    if(tmp == tmp2){\\n                        vis[j] = true;\\n                        t++;\\n                    }\\n                }\\n            }\\n            ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072676,
                "title": "70-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    if(words.length <= 0){\\n        return []\\n    }\\n    for(let i = 0; i < words.length-1;i++){\\n        let x = words[i].split(\"\").sort().join(\"\")\\n        let y = words[i+1].split(\"\").sort().join(\"\")\\n\\n        if(x == y){\\n            words.splice(i+1,1)\\n            i--;\\n        }\\n    }\\n    return words\\n\\n  \\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    if(words.length <= 0){\\n        return []\\n    }\\n    for(let i = 0; i < words.length-1;i++){\\n        let x = words[i].split(\"\").sort().join(\"\")\\n        let y = words[i+1].split(\"\").sort().join(\"\")\\n\\n        if(x == y){\\n            words.splice(i+1,1)\\n            i--;\\n        }\\n    }\\n    return words\\n\\n  \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061949,
                "title": "easy-simple-c-solution",
                "content": "\\n# Approach\\nSort the words and compare. Always add accept the first array element.\\n\\n# Complexity\\n- Time complexity:\\nO(m * n log n)\\n\\n- Space complexity:\\nO(m + n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<string> RemoveAnagrams(string[] words) {\\n        List<string> wordList = new();\\n        for(int i = 0; i<words.Length; i++)\\n        {   \\n            if(i==0)\\n            {\\n                wordList.Add(words[i]);\\n                continue;\\n            }\\n            //char and sort words i, i-1 and i+1\\n            char[] less = words[i-1].ToCharArray();\\n            char[] same = words[i].ToCharArray();\\n            Array.Sort(less);\\n            Array.Sort(same);\\n            string str = new string(same);\\n            string strLess = new string(less);\\n            if(str != strLess)\\n                wordList.Add(words[i]);\\n            \\n        }\\n        return wordList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> RemoveAnagrams(string[] words) {\\n        List<string> wordList = new();\\n        for(int i = 0; i<words.Length; i++)\\n        {   \\n            if(i==0)\\n            {\\n                wordList.Add(words[i]);\\n                continue;\\n            }\\n            //char and sort words i, i-1 and i+1\\n            char[] less = words[i-1].ToCharArray();\\n            char[] same = words[i].ToCharArray();\\n            Array.Sort(less);\\n            Array.Sort(same);\\n            string str = new string(same);\\n            string strLess = new string(less);\\n            if(str != strLess)\\n                wordList.Add(words[i]);\\n            \\n        }\\n        return wordList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059240,
                "title": "find-resultant-array-after-removing-anagrams-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        stack<string> s1;\\n        for(int i=0;i<words.size();i++){\\n            if(s1.empty()){\\n                s1.push(words[i]);\\n            }\\n            else{\\n                string s=s1.top(),s2=words[i];\\n                sort(s.begin(),s.end());\\n                sort(s2.begin(),s2.end());\\n                if(s==s2){\\n                    continue;\\n                }\\n                else{\\n                    s1.push(words[i]);\\n                }\\n            }\\n        }\\n        vector<string> ans;\\n        while(!s1.empty()){\\n            ans.push_back(s1.top());\\n            s1.pop();\\n        } \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        stack<string> s1;\\n        for(int i=0;i<words.size();i++){\\n            if(s1.empty()){\\n                s1.push(words[i]);\\n            }\\n            else{\\n                string s=s1.top(),s2=words[i];\\n                sort(s.begin(),s.end());\\n                sort(s2.begin(),s2.end());\\n                if(s==s2){\\n                    continue;\\n                }\\n                else{\\n                    s1.push(words[i]);\\n                }\\n            }\\n        }\\n        vector<string> ans;\\n        while(!s1.empty()){\\n            ans.push_back(s1.top());\\n            s1.pop();\\n        } \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052298,
                "title": "java-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        list.add(words[0]);\\n        for(int i=1;i<words.length;i++){\\n            if(!isAnagram(words[i],words[i-1])){\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n    public boolean isAnagram(String s1,String s2){\\n        if(s1.length()!=s2.length())\\n            return false;\\n        if(s1==s2)\\n            return true;\\n        int[] arr = new int[26];    \\n        for(int i=0;i<s1.length();i++){\\n            arr[s1.charAt(i)-\\'a\\']++;\\n            arr[s2.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(arr[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        list.add(words[0]);\\n        for(int i=1;i<words.length;i++){\\n            if(!isAnagram(words[i],words[i-1])){\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n    public boolean isAnagram(String s1,String s2){\\n        if(s1.length()!=s2.length())\\n            return false;\\n        if(s1==s2)\\n            return true;\\n        int[] arr = new int[26];    \\n        for(int i=0;i<s1.length();i++){\\n            arr[s1.charAt(i)-\\'a\\']++;\\n            arr[s2.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(arr[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024985,
                "title": "easy-c-sorting-and-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIterating through the string vector\\nsorting the each string element\\nChecking if it is already present in hashmap\\nIf not present pushing it into the result vector\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will push the very first element in the result vector.\\nThen we will sort the string a put that string in map \\nwhen frequency is 1 we will push the string in the result vector.\\nif frequecy is greater than 1 we will not push that string in the result.\\nreturn the result vector\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nmlogn)\\nn - number of strings\\nm -  avg length of a string\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(nm)\\nn - given string vector\\nm -  size of result string vector\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>res;\\n        unordered_map<string,int>mp;\\n        res.push_back(words[0]);\\n        sort(words[0].begin(),words[0].end());\\n        mp[words[0]]++;\\n        for(int i=1;i<words.size();i++){\\n            string temp = words[i];\\n            sort(words[i].begin(),words[i].end());\\n            mp[words[i]]++;\\n            if(mp[words[i]] == 1 || (words[i-1] != words[i])){\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>res;\\n        unordered_map<string,int>mp;\\n        res.push_back(words[0]);\\n        sort(words[0].begin(),words[0].end());\\n        mp[words[0]]++;\\n        for(int i=1;i<words.size();i++){\\n            string temp = words[i];\\n            sort(words[i].begin(),words[i].end());\\n            mp[words[i]]++;\\n            if(mp[words[i]] == 1 || (words[i-1] != words[i])){\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016784,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> result = new ArrayList<>();\\n        \\n        if (words.length == 0) {\\n            return result;\\n        }\\n\\n        result.add(words[0]);\\n\\n        for (int i = 1; i < words.length; i++) {\\n            if (!areAnagrams(words[i], words[i - 1])) {\\n                result.add(words[i]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private boolean areAnagrams(String s1, String s2) {\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n\\n        int[] charCount = new int[26];\\n        \\n        for (int i = 0; i < s1.length(); i++) {\\n            charCount[s1.charAt(i) - \\'a\\']++;\\n            charCount[s2.charAt(i) - \\'a\\']--;\\n        }\\n\\n        for (int count : charCount) {\\n            if (count != 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> result = new ArrayList<>();\\n        \\n        if (words.length == 0) {\\n            return result;\\n        }\\n\\n        result.add(words[0]);\\n\\n        for (int i = 1; i < words.length; i++) {\\n            if (!areAnagrams(words[i], words[i - 1])) {\\n                result.add(words[i]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private boolean areAnagrams(String s1, String s2) {\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n\\n        int[] charCount = new int[26];\\n        \\n        for (int i = 0; i < s1.length(); i++) {\\n            charCount[s1.charAt(i) - \\'a\\']++;\\n            charCount[s2.charAt(i) - \\'a\\']--;\\n        }\\n\\n        for (int count : charCount) {\\n            if (count != 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013537,
                "title": "easy-to-understand-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n         List<String> ans = new ArrayList<>();\\n         if(words.length == 1)\\n         return Arrays.asList(words[0]);\\n         \\n         for(int i = words.length-1 ; i> 0 ;i--){\\n             char[] ch1 = words[i].toCharArray();\\n             char[] ch2 = words[i-1].toCharArray();\\n             Arrays.sort(ch1);\\n             Arrays.sort(ch2);\\n             if(!Arrays.equals(ch1,ch2)){\\n                 ans.add(words[i]);\\n             }\\n             if(i == 1)\\n             ans.add(words[i-1]);\\n         }\\n         Collections.reverse(ans);\\n         return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n         List<String> ans = new ArrayList<>();\\n         if(words.length == 1)\\n         return Arrays.asList(words[0]);\\n         \\n         for(int i = words.length-1 ; i> 0 ;i--){\\n             char[] ch1 = words[i].toCharArray();\\n             char[] ch2 = words[i-1].toCharArray();\\n             Arrays.sort(ch1);\\n             Arrays.sort(ch2);\\n             if(!Arrays.equals(ch1,ch2)){\\n                 ans.add(words[i]);\\n             }\\n             if(i == 1)\\n             ans.add(words[i-1]);\\n         }\\n         Collections.reverse(ans);\\n         return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006864,
                "title": "c-simple-just-do-what-ask-simple-sorting-apporach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int sz=words.size();\\n         vector<string> res;\\n          for(int i=0;i<sz;i++)\\n            {\\n              \\n              string curr=words[i];\\n              //just sort the curr string so that we can check anagaram of that string\\n               sort(curr.begin(),curr.end());\\n                int j=i+1;\\n                for(;j<sz;j++)\\n                  {\\n                    string s=words[j];\\n                    //sort adjacnet string also that we can compare 2 string\\n                      sort(begin(s),end(s));\\n                      //if both are equal then just continue\\n                      if(s==curr)\\n                           continue;\\n                      else\\n                      break;\\n                  }\\n            \\n                  res.push_back(words[i]);\\n                \\n                        i=j-1;\\n            }\\n            return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int sz=words.size();\\n         vector<string> res;\\n          for(int i=0;i<sz;i++)\\n            {\\n              \\n              string curr=words[i];\\n              //just sort the curr string so that we can check anagaram of that string\\n               sort(curr.begin(),curr.end());\\n                int j=i+1;\\n                for(;j<sz;j++)\\n                  {\\n                    string s=words[j];\\n                    //sort adjacnet string also that we can compare 2 string\\n                      sort(begin(s),end(s));\\n                      //if both are equal then just continue\\n                      if(s==curr)\\n                           continue;\\n                      else\\n                      break;\\n                  }\\n            \\n                  res.push_back(words[i]);\\n                \\n                        i=j-1;\\n            }\\n            return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985510,
                "title": "easy-solution-beats-95-time",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n        w = []\\n        w.append(words[0])\\n\\n        for i in range(1,len(words)):\\n            if sorted(words[i]) == sorted(words[i-1]):\\n                continue\\n            else:\\n                w.append(words[i])\\n        return w\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n        w = []\\n        w.append(words[0])\\n\\n        for i in range(1,len(words)):\\n            if sorted(words[i]) == sorted(words[i-1]):\\n                continue\\n            else:\\n                w.append(words[i])\\n        return w\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985262,
                "title": "simple-java-solution-without-sort",
                "content": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        char[][] table = new char[words.length][26];\\n        for(int i = 0; i < words.length; i++){\\n            String word = words[i];\\n            for(char c : word.toCharArray()){\\n                table[i][c - \\'a\\']++;\\n            }\\n        }\\n        int i = 0;\\n        while(i < words.length){\\n            res.add(words[i]);\\n            int j = i + 1;\\n            while(j < words.length && words[i].length() == words[j].length() && Arrays.equals(table[i], table[j])){\\n                j++;\\n            }\\n            i = j;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        char[][] table = new char[words.length][26];\\n        for(int i = 0; i < words.length; i++){\\n            String word = words[i];\\n            for(char c : word.toCharArray()){\\n                table[i][c - \\'a\\']++;\\n            }\\n        }\\n        int i = 0;\\n        while(i < words.length){\\n            res.add(words[i]);\\n            int j = i + 1;\\n            while(j < words.length && words[i].length() == words[j].length() && Arrays.equals(table[i], table[j])){\\n                j++;\\n            }\\n            i = j;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980926,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list= new  ArrayList();\\n        boolean vis[]=new boolean[words.length];\\n        for(int i=0;i<words.length-1;i++){\\n            int j=i+1;\\n            if(isAnagram(words[i] , words[j] )){\\n                vis[j]=true;\\n            }\\n            \\n        }\\n        for(int i=0;i<words.length;i++){\\n            // System.out.print(i+\"--\"+vis[i]);\\n            if(vis[i]==false)\\n            {\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n\\n        \\n        \\n        \\n    }\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())return false;\\n        char[]c0=s.toCharArray();\\n        char[]c1=t.toCharArray();\\n        Arrays.sort(c0);\\n        Arrays.sort(c1);\\n        return Arrays.equals(c0,c1);\\n\\n\\n\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list= new  ArrayList();\\n        boolean vis[]=new boolean[words.length];\\n        for(int i=0;i<words.length-1;i++){\\n            int j=i+1;\\n            if(isAnagram(words[i] , words[j] )){\\n                vis[j]=true;\\n            }\\n            \\n        }\\n        for(int i=0;i<words.length;i++){\\n            // System.out.print(i+\"--\"+vis[i]);\\n            if(vis[i]==false)\\n            {\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n\\n        \\n        \\n        \\n    }\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())return false;\\n        char[]c0=s.toCharArray();\\n        char[]c1=t.toCharArray();\\n        Arrays.sort(c0);\\n        Arrays.sort(c1);\\n        return Arrays.equals(c0,c1);\\n\\n\\n\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979398,
                "title": "simple-c-only-sorting-techniq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size(); i++)\\n        {\\n            string str1 = words[i];\\n            string str2 = words[i-1];\\n\\n            sort(str1.begin(), str1.end());\\n            sort(str2.begin(), str2.end());\\n\\n            if(str1==str2)\\n            {\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n            \\n        }\\n        return words;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size(); i++)\\n        {\\n            string str1 = words[i];\\n            string str2 = words[i-1];\\n\\n            sort(str1.begin(), str1.end());\\n            sort(str2.begin(), str2.end());\\n\\n            if(str1==str2)\\n            {\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n            \\n        }\\n        return words;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977773,
                "title": "python-one-liner-beats-98-98-with-comments",
                "content": "# Intuition\\nIf two sorted words are the same they are anagrams.\\n\\n# Approach\\nLoop through the list and check if $$adjacent$$ words are anagrams. The first word will always meet the requirement, so we can add that to the final list.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def removeAnagrams(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        return [words[0]] + [words[i] for i in range(1, len(words)) if sorted(words[i]) != sorted(words[i-1])]\\n        # Check if the previous word is an anagram of the current word. Add the first word in words as well.\\n        \\n```\\n\\n**Please upvote if this helped!!!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeAnagrams(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        return [words[0]] + [words[i] for i in range(1, len(words)) if sorted(words[i]) != sorted(words[i-1])]\\n        # Check if the previous word is an anagram of the current word. Add the first word in words as well.\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976691,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private boolean isAnagram(String str1, String str2){\\n        if(str1.length() != str2.length())return false;\\n        int[] ans =  new int[26];\\n        for(int i=0; i<str1.length(); i++){\\n            ans[str1.charAt(i)-\\'a\\']++;\\n            ans[str2.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(ans[i] != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list =  new ArrayList<>();\\n        boolean ans[]=new boolean[words.length];\\n        for(int i=0; i<words.length-1; i++){\\n            int j = i+1;\\n            while(ans[j]){\\n                j++;\\n            }\\n            if(isAnagram(words[i], words[j])){\\n                ans[j] =  true;\\n            }\\n        }\\n\\n        for(int i=0; i<words.length; i++){\\n            if(ans[i] == false){\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private boolean isAnagram(String str1, String str2){\\n        if(str1.length() != str2.length())return false;\\n        int[] ans =  new int[26];\\n        for(int i=0; i<str1.length(); i++){\\n            ans[str1.charAt(i)-\\'a\\']++;\\n            ans[str2.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(ans[i] != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list =  new ArrayList<>();\\n        boolean ans[]=new boolean[words.length];\\n        for(int i=0; i<words.length-1; i++){\\n            int j = i+1;\\n            while(ans[j]){\\n                j++;\\n            }\\n            if(isAnagram(words[i], words[j])){\\n                ans[j] =  true;\\n            }\\n        }\\n\\n        for(int i=0; i<words.length; i++){\\n            if(ans[i] == false){\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976357,
                "title": "easy-logic-java-using-2-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String convertString(String[] words, int i){\\n        String str = words[i];\\n            char arr[] = str.toCharArray();\\n            Arrays.sort(arr);\\n\\n            str = new String(arr); \\n            return str;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        //go from n to 0\\n        //check i and i-1\\n        List<String> res = new ArrayList<>();\\n        int i = words.length-1;\\n            //string in sorted manner\\n            //now compare i with i-1\\n            while(i>0){\\n                String str1 = convertString(words, i);\\n                String str2 = convertString(words, i-1);\\n                \\n                if(!str1.equals(str2)){\\n                    res.add(words[i]);\\n                }\\n                i--;\\n            }\\n            res.add(words[0]); \\n\\n            Collections.reverse(res);\\n            return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertString(String[] words, int i){\\n        String str = words[i];\\n            char arr[] = str.toCharArray();\\n            Arrays.sort(arr);\\n\\n            str = new String(arr); \\n            return str;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        //go from n to 0\\n        //check i and i-1\\n        List<String> res = new ArrayList<>();\\n        int i = words.length-1;\\n            //string in sorted manner\\n            //now compare i with i-1\\n            while(i>0){\\n                String str1 = convertString(words, i);\\n                String str2 = convertString(words, i-1);\\n                \\n                if(!str1.equals(str2)){\\n                    res.add(words[i]);\\n                }\\n                i--;\\n            }\\n            res.add(words[0]); \\n\\n            Collections.reverse(res);\\n            return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973732,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        for word in words[1:]:\\n            curr = \"\".join(sorted(word))\\n            if curr != \"\".join(sorted(res[-1])):\\n                res.append(word)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        for word in words[1:]:\\n            curr = \"\".join(sorted(word))\\n            if curr != \"\".join(sorted(res[-1])):\\n                res.append(word)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970787,
                "title": "runtime-59ms-beats-95-24-memory-45-39-mb-beats-100",
                "content": "```\\nfunction removeAnagrams(words: string[]): string[] {\\n    let i = 1\\n\\n    while (i < words.length) {\\n        if (isAnagram(words[i - 1], words[i])) {\\n            words.splice(i,1)\\n            i = 1\\n            continue\\n        }\\n\\n        i++\\n    }\\n\\n    return words\\n};\\n\\n\\nconst isAnagram = (word1: string, word2: string): boolean => {\\n    if (word1.length !== word2.length) return false\\n    if (word1 === word2) return true\\n\\n    for (let i = 0; i < word1.length; i++) {\\n        const letter = word1[i]\\n        word2 = word2.replace(letter, \\'\\')\\n    }\\n\\n    return !word2\\n}\\n```\\n\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction removeAnagrams(words: string[]): string[] {\\n    let i = 1\\n\\n    while (i < words.length) {\\n        if (isAnagram(words[i - 1], words[i])) {\\n            words.splice(i,1)\\n            i = 1\\n            continue\\n        }\\n\\n        i++\\n    }\\n\\n    return words\\n};\\n\\n\\nconst isAnagram = (word1: string, word2: string): boolean => {\\n    if (word1.length !== word2.length) return false\\n    if (word1 === word2) return true\\n\\n    for (let i = 0; i < word1.length; i++) {\\n        const letter = word1[i]\\n        word2 = word2.replace(letter, \\'\\')\\n    }\\n\\n    return !word2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932999,
                "title": "rust-0ms-linear-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn remove_anagrams(words: Vec<String>) -> Vec<String> {\\n        let maps = words\\n            .iter()\\n            .map(|w| {\\n                let mut lut = [0; 26];\\n                for c in w.chars() {\\n                    lut[c as usize - \\'a\\' as usize] += 1;\\n                }\\n                lut\\n            })\\n            .collect::<Vec<[i32; 26]>>();\\n\\n        let mut res = vec![];\\n\\n        res.push(words[0].clone());\\n        for i in 1..words.len() {\\n            if maps[i] != maps[i - 1] {\\n                res.push(words[i].clone());\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn remove_anagrams(words: Vec<String>) -> Vec<String> {\\n        let maps = words\\n            .iter()\\n            .map(|w| {\\n                let mut lut = [0; 26];\\n                for c in w.chars() {\\n                    lut[c as usize - \\'a\\' as usize] += 1;\\n                }\\n                lut\\n            })\\n            .collect::<Vec<[i32; 26]>>();\\n\\n        let mut res = vec![];\\n\\n        res.push(words[0].clone());\\n        for i in 1..words.len() {\\n            if maps[i] != maps[i - 1] {\\n                res.push(words[i].clone());\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924581,
                "title": "clean-easy-to-understand-solution-beats-100-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n     boolean isAnagram(String word1, String word2){\\n        if(word1 == null || word2 == null)return false;\\n\\n        int[] freq=new int[26];\\n\\n        for(int i=0;i<word1.length();i++){\\n            int ascii = word1.charAt(i) - \\'a\\';\\n            freq[ascii] = freq[ascii] + 1;\\n        }\\n\\n        for(int i=0;i<word2.length();i++){\\n            int ascii = word2.charAt(i) - \\'a\\';\\n            freq[ascii] = freq[ascii] - 1;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(freq[i] != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public List<String> removeAnagrams(String[] words){\\n        List<String> ans = new ArrayList<>();\\n        while(true){\\n            boolean changed = false;\\n            for(int i=words.length-1;i>=1;i--){\\n                if(words[i] == null)\\n                    continue;\\n                if(isAnagram(words[i],words[i-1])){\\n                    words[i] = null;\\n                    changed = true;\\n                }\\n            }\\n            if(changed == false){\\n                for(int i= 0; i< words.length; i++){\\n                    if(words[i] != null){\\n                        ans.add(words[i]);\\n                    }\\n                }\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     boolean isAnagram(String word1, String word2){\\n        if(word1 == null || word2 == null)return false;\\n\\n        int[] freq=new int[26];\\n\\n        for(int i=0;i<word1.length();i++){\\n            int ascii = word1.charAt(i) - \\'a\\';\\n            freq[ascii] = freq[ascii] + 1;\\n        }\\n\\n        for(int i=0;i<word2.length();i++){\\n            int ascii = word2.charAt(i) - \\'a\\';\\n            freq[ascii] = freq[ascii] - 1;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(freq[i] != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public List<String> removeAnagrams(String[] words){\\n        List<String> ans = new ArrayList<>();\\n        while(true){\\n            boolean changed = false;\\n            for(int i=words.length-1;i>=1;i--){\\n                if(words[i] == null)\\n                    continue;\\n                if(isAnagram(words[i],words[i-1])){\\n                    words[i] = null;\\n                    changed = true;\\n                }\\n            }\\n            if(changed == false){\\n                for(int i= 0; i< words.length; i++){\\n                    if(words[i] != null){\\n                        ans.add(words[i]);\\n                    }\\n                }\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923974,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1;i<words.size();i++){\\n            string temp1 = words[i];\\n            sort(temp1.begin(),temp1.end());\\n            string temp2 = words[i-1];\\n            sort(temp2.begin(),temp2.end());\\n            if(temp1 == temp2){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1;i<words.size();i++){\\n            string temp1 = words[i];\\n            sort(temp1.begin(),temp1.end());\\n            string temp2 = words[i-1];\\n            sort(temp2.begin(),temp2.end());\\n            if(temp1 == temp2){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915665,
                "title": "simple-c-one-traversal-no-map-used",
                "content": "# Complexity\\n- Time complexity: O(n * (wordLen log(wordLen)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) Not considering returing vector\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n = words.size();\\n        vector<string> res;\\n\\n        res.push_back(words[0]);\\n        for(int i=1; i<n; i++){\\n            string prevStr = words[i-1];\\n            string currStr = words[i];\\n\\n            sort(prevStr.begin(), prevStr.end());\\n            sort(currStr.begin(), currStr.end());\\n\\n            if(prevStr != currStr)\\n                res.push_back(words[i]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n = words.size();\\n        vector<string> res;\\n\\n        res.push_back(words[0]);\\n        for(int i=1; i<n; i++){\\n            string prevStr = words[i-1];\\n            string currStr = words[i];\\n\\n            sort(prevStr.begin(), prevStr.end());\\n            sort(currStr.begin(), currStr.end());\\n\\n            if(prevStr != currStr)\\n                res.push_back(words[i]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915357,
                "title": "python3-list-of-sorted-words-beats-99-26",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        srt = [sorted(words[0])]\\n        res = [words[0]]\\n        for word in words[1:]:\\n            sorted_word = sorted(word)\\n            if sorted_word != srt[-1]:\\n                srt.append(sorted_word)\\n                res.append(word)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        srt = [sorted(words[0])]\\n        res = [words[0]]\\n        for word in words[1:]:\\n            sorted_word = sorted(word)\\n            if sorted_word != srt[-1]:\\n                srt.append(sorted_word)\\n                res.append(word)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911604,
                "title": "python-2-pointers-while",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        j = i+1\\n        n = len(words)\\n        res = []\\n        while j < n:\\n            if sorted(words[i]) == sorted(words[j]): \\n                if j == i+1:\\n                    res.append(words[i])\\n            else: \\n                if j == i+1:\\n                    res.append(words[i])\\n                i = j\\n            j += 1\\n\\n        if j == i+1:\\n            res.append(words[i])  \\n        return res\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        j = i+1\\n        n = len(words)\\n        res = []\\n        while j < n:\\n            if sorted(words[i]) == sorted(words[j]): \\n                if j == i+1:\\n                    res.append(words[i])\\n            else: \\n                if j == i+1:\\n                    res.append(words[i])\\n                i = j\\n            j += 1\\n\\n        if j == i+1:\\n            res.append(words[i])  \\n        return res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906583,
                "title": "easiest-c-code",
                "content": "# Code\\n```\\npublic class Solution {\\n    private int[] GetCharMap(string s) {\\n        int[] map = new int[26];\\n\\n        foreach (char c in s) {\\n            map[c - \\'a\\']++;\\n        }\\n\\n        return map;\\n    }\\n\\n    private bool IsSameCharMap(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.Length; i++) {\\n            if (arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    public IList<string> RemoveAnagrams(string[] words) {\\n        List<string> result = new List<string> { words[0] };\\n        int[] charMap = GetCharMap(words[0]);\\n\\n        for (int i = 1; i < words.Length; i++) {\\n            int[] nextCharMap = GetCharMap(words[i]);\\n\\n            if (!IsSameCharMap(charMap, nextCharMap)) {\\n                charMap = nextCharMap;\\n                result.Add(words[i]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    private int[] GetCharMap(string s) {\\n        int[] map = new int[26];\\n\\n        foreach (char c in s) {\\n            map[c - \\'a\\']++;\\n        }\\n\\n        return map;\\n    }\\n\\n    private bool IsSameCharMap(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.Length; i++) {\\n            if (arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    public IList<string> RemoveAnagrams(string[] words) {\\n        List<string> result = new List<string> { words[0] };\\n        int[] charMap = GetCharMap(words[0]);\\n\\n        for (int i = 1; i < words.Length; i++) {\\n            int[] nextCharMap = GetCharMap(words[i]);\\n\\n            if (!IsSameCharMap(charMap, nextCharMap)) {\\n                charMap = nextCharMap;\\n                result.Add(words[i]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899171,
                "title": "by-using-one-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    for(var i=0;i<words.length-1;i++)\\n    {\\n        var x=words[i].split(\"\").sort().join(\"\");\\n        var y=words[i+1].split(\"\").sort().join(\"\");\\n        if(x==y)\\n        {\\n            words.splice(i+1,1)\\n            i--;\\n        }\\n    }\\n    return words;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    for(var i=0;i<words.length-1;i++)\\n    {\\n        var x=words[i].split(\"\").sort().join(\"\");\\n        var y=words[i+1].split(\"\").sort().join(\"\");\\n        if(x==y)\\n        {\\n            words.splice(i+1,1)\\n            i--;\\n        }\\n    }\\n    return words;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3892186,
                "title": "java-best-solution-4-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n     Brute Force\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nklogk)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        ArrayList<String> list=new ArrayList<>();\\n        String temp=\"\";\\n        for(String s:words){\\n            char[] c=s.toCharArray();\\n            Arrays.sort(c);\\n            String current=new String(c);\\n            if(!current.equals(temp))\\n                list.add(s);\\n            temp=current;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        ArrayList<String> list=new ArrayList<>();\\n        String temp=\"\";\\n        for(String s:words){\\n            char[] c=s.toCharArray();\\n            Arrays.sort(c);\\n            String current=new String(c);\\n            if(!current.equals(temp))\\n                list.add(s);\\n            temp=current;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879943,
                "title": "simplest-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = []\\n        left = [0] * 26\\n        for w in words:\\n            right = [0] * 26\\n            for c in w:\\n                right[ord(c)-ord(\\'a\\')] +=1\\n\\n            if left != right:\\n                res.append(w)\\n            left, right = right, left \\n        \\n        return res\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = []\\n        left = [0] * 26\\n        for w in words:\\n            right = [0] * 26\\n            for c in w:\\n                right[ord(c)-ord(\\'a\\')] +=1\\n\\n            if left != right:\\n                res.append(w)\\n            left, right = right, left \\n        \\n        return res\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879899,
                "title": "easy-to-understand-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought is to use what I learned from validAnagrams. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used a while loop to loop through the words list. If words[i] and words[i+1] are anagrams, I will pop words[i+1] from the list. And then, in the next loop, the words[i+1] becomes the next element of the poped element from last cycle.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nI am not sure about the time complexity, I guess it\\'s O(n2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nI am guessing O(n) for space complexity\\n# Code\\n```\\n\\nclass Solution:\\n\\n    def checkAnagrams(self, string1, string2):\\n        dict1 = {}\\n        dict2 = {}\\n        for char in string1:\\n            dict1[char] = 1 + dict1.get(char, 0)\\n        for char in string2:\\n            dict2[char] = 1 + dict2.get(char, 0)\\n        return dict1 == dict2\\n\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while i < len(words) - 1:\\n            if self.checkAnagrams(words[i], words[i+1]):\\n                words.pop(i+1)\\n            else:\\n                i+=1\\n\\n        return words\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n\\n    def checkAnagrams(self, string1, string2):\\n        dict1 = {}\\n        dict2 = {}\\n        for char in string1:\\n            dict1[char] = 1 + dict1.get(char, 0)\\n        for char in string2:\\n            dict2[char] = 1 + dict2.get(char, 0)\\n        return dict1 == dict2\\n\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while i < len(words) - 1:\\n            if self.checkAnagrams(words[i], words[i+1]):\\n                words.pop(i+1)\\n            else:\\n                i+=1\\n\\n        return words\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877970,
                "title": "very-simple-and-easy-cpp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t){\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        return (s == t) ? true : false;\\n    }\\n    vector<string> removeAnagrams(vector<string>& v) {\\n        int n = v.size();\\n        vector<string> ans = {v[0]}; \\n        \\n        for(int i = 0; i<n ;i++){\\n            if( isAnagram(v[i] , ans[ans.size()-1]) ){\\n                // do nothing\\n            }\\n            else{\\n                ans.push_back(v[i]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t){\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        return (s == t) ? true : false;\\n    }\\n    vector<string> removeAnagrams(vector<string>& v) {\\n        int n = v.size();\\n        vector<string> ans = {v[0]}; \\n        \\n        for(int i = 0; i<n ;i++){\\n            if( isAnagram(v[i] , ans[ans.size()-1]) ){\\n                // do nothing\\n            }\\n            else{\\n                ans.push_back(v[i]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868647,
                "title": "js-short-60-90",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nconst sortWord = (word) => word.split(\\'\\').sort().join(\\'\\');\\n\\nconst removeAnagrams = (words) => {\\n    for (let i = 1; i < words.length;) {\\n        if (sortWord(words[i - 1]) === sortWord(words[i])) words.splice(i, 1);\\n        else i++;\\n    }\\n\\n    return words;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nconst sortWord = (word) => word.split(\\'\\').sort().join(\\'\\');\\n\\nconst removeAnagrams = (words) => {\\n    for (let i = 1; i < words.length;) {\\n        if (sortWord(words[i - 1]) === sortWord(words[i])) words.splice(i, 1);\\n        else i++;\\n    }\\n\\n    return words;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3861202,
                "title": "find-resultant-array-after-removing-anagrams",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String  s = \"\";\\n        List<String> li = new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] arr =words[i].toCharArray();\\n            Arrays.sort(arr);\\n            String cur = String.valueOf(arr);\\n            if(!cur.equals(s)){\\n                li.add(words[i]);\\n                s = cur;\\n            }\\n        }\\n        return li;\\n        \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String  s = \"\";\\n        List<String> li = new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] arr =words[i].toCharArray();\\n            Arrays.sort(arr);\\n            String cur = String.valueOf(arr);\\n            if(!cur.equals(s)){\\n                li.add(words[i]);\\n                s = cur;\\n            }\\n        }\\n        return li;\\n        \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842125,
                "title": "one-line-solution-runtime-40ms-100-00",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n        return list(map(lambda word: next(word[1]), groupby(words, key= sorted)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n        return list(map(lambda word: next(word[1]), groupby(words, key= sorted)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833155,
                "title": "cpp-easy-code-clean-code",
                "content": "\\n# Complexity\\n- Time complexity:O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isanagram(string s,string t){\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        return s==t;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n=words.size();\\n        for(int i=n-1;i>0;i--){\\n            if(isanagram(words[i],words[i-1])){\\n                words[i]=\"AMAN\";\\n            }\\n        }\\n        vector<string> ans;\\n        for(auto e: words){\\n            if(e==\"AMAN\")continue;\\n            ans.push_back(e);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isanagram(string s,string t){\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        return s==t;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n=words.size();\\n        for(int i=n-1;i>0;i--){\\n            if(isanagram(words[i],words[i-1])){\\n                words[i]=\"AMAN\";\\n            }\\n        }\\n        vector<string> ans;\\n        for(auto e: words){\\n            if(e==\"AMAN\")continue;\\n            ans.push_back(e);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826214,
                "title": "js-ez",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    for (let i = words.length - 1; i > 0; i--) {\\n        if (isAnagram(words[i], words[i - 1])) {\\n            words.splice(i, 1);\\n        }\\n    }\\n\\n    return words;\\n};\\n\\nconst isAnagram = (wordOne, wordTwo) => {\\n    return wordOne.split(\"\").sort().join(\"\") === wordTwo.split(\"\").sort().join(\"\")\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    for (let i = words.length - 1; i > 0; i--) {\\n        if (isAnagram(words[i], words[i - 1])) {\\n            words.splice(i, 1);\\n        }\\n    }\\n\\n    return words;\\n};\\n\\nconst isAnagram = (wordOne, wordTwo) => {\\n    return wordOne.split(\"\").sort().join(\"\") === wordTwo.split(\"\").sort().join(\"\")\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3822486,
                "title": "java-very-easy-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/2fa81ae1-1e2a-48d1-9974-f32a110a86f3_1690442496.7153208.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev =\"\";\\n        List<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev =\"\";\\n        List<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820055,
                "title": "java-solution-using-string-comparison",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isanagram(String s1,String s2){\\n        char[] a=s1.toCharArray();\\n        char[] b=s2.toCharArray();\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        String s11=String.valueOf(a);\\n        String s22=String.valueOf(b);\\n        return s11.equals(s22);\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n       List<String> list=new ArrayList<>();\\n       list.add(words[0]);\\n       for(int i=1;i<words.length;i++){\\n           if(!isanagram(words[i-1],words[i])){\\n               list.add(words[i]);\\n           }\\n       } \\n       return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isanagram(String s1,String s2){\\n        char[] a=s1.toCharArray();\\n        char[] b=s2.toCharArray();\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        String s11=String.valueOf(a);\\n        String s22=String.valueOf(b);\\n        return s11.equals(s22);\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n       List<String> list=new ArrayList<>();\\n       list.add(words[0]);\\n       for(int i=1;i<words.length;i++){\\n           if(!isanagram(words[i-1],words[i])){\\n               list.add(words[i]);\\n           }\\n       } \\n       return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813406,
                "title": "php-two-pointers-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n    /**\\n     * @param String[] $words\\n     * @return String[]\\n     */\\n    function removeAnagrams($words) {     \\n        $left = 0;\\n        $right = 1;\\n        while (isset($words[$right])) {\\n            // Check if the current word is an anagram of the next word\\n            if ($this->isAnagram($words[$left], $words[$right]) === true) {\\n                unset($words[$right]); // Remove the anagram from the array\\n            } else {\\n                $left = $right; // Move the left pointer to the next non-anagram word\\n            }\\n            $right++; // Move the right pointer to the next word to be compared\\n        }\\n\\n        return $words;\\n    }\\n\\n    /**\\n     * Check if two words are anagrams.\\n     * Anagrams are words that have the same characters but in a different order.\\n     * @param string $current The first word\\n     * @param string $next The second word\\n     * @return bool True if the words are anagrams, False otherwise\\n     */\\n    function isAnagram(string $current, string $next) {\\n        $a = str_split($current);\\n        $b = str_split($next);\\n        sort($a);                 // Sort the characters of the first word in alphabetical order\\n        sort($b);                 // Sort the characters of the second word in alphabetical order\\n        return implode($a) == implode($b); // Check if the sorted words are equal, i.e., they are anagrams\\n    }\\n \\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n    /**\\n     * @param String[] $words\\n     * @return String[]\\n     */\\n    function removeAnagrams($words) {     \\n        $left = 0;\\n        $right = 1;\\n        while (isset($words[$right])) {\\n            // Check if the current word is an anagram of the next word\\n            if ($this->isAnagram($words[$left], $words[$right]) === true) {\\n                unset($words[$right]); // Remove the anagram from the array\\n            } else {\\n                $left = $right; // Move the left pointer to the next non-anagram word\\n            }\\n            $right++; // Move the right pointer to the next word to be compared\\n        }\\n\\n        return $words;\\n    }\\n\\n    /**\\n     * Check if two words are anagrams.\\n     * Anagrams are words that have the same characters but in a different order.\\n     * @param string $current The first word\\n     * @param string $next The second word\\n     * @return bool True if the words are anagrams, False otherwise\\n     */\\n    function isAnagram(string $current, string $next) {\\n        $a = str_split($current);\\n        $b = str_split($next);\\n        sort($a);                 // Sort the characters of the first word in alphabetical order\\n        sort($b);                 // Sort the characters of the second word in alphabetical order\\n        return implode($a) == implode($b); // Check if the sorted words are equal, i.e., they are anagrams\\n    }\\n \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804154,
                "title": "remove-anagrams-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def removeAnagrams(self, words):\\n        def anagrams(str1,str2):\\n            str1,str2 = str1.lower(), str2.lower()\\n            if sorted(str1) == sorted(str2):\\n                return True\\n            else:\\n                return False\\n\\n        i = 0\\n        length = len(words)\\n        while(i<length-1):\\n            if anagrams(words[i],words[i+1]):\\n                words.pop(i+1)\\n                i -= 1\\n                length -= 1\\n            i += 1\\n        return words\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeAnagrams(self, words):\\n        def anagrams(str1,str2):\\n            str1,str2 = str1.lower(), str2.lower()\\n            if sorted(str1) == sorted(str2):\\n                return True\\n            else:\\n                return False\\n\\n        i = 0\\n        length = len(words)\\n        while(i<length-1):\\n            if anagrams(words[i],words[i+1]):\\n                words.pop(i+1)\\n                i -= 1\\n                length -= 1\\n            i += 1\\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795474,
                "title": "stack-based-solution",
                "content": "# Intuition : \\nusing merging interval intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : \\nusing stack instead of map\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        stack<string>s;\\n        s.push(words[0]);\\n        for(int i=1;i<words.size();i++){\\n            string a = words[i];\\n            string b = s.top();\\n            sort(b.begin(),b.end());\\n            sort(a.begin(),a.end());\\n            if(a==b){\\n                continue;\\n            }\\n            else{\\n                s.push(words[i]);\\n            }\\n        }\\n        vector<string>ans;\\n        while(!s.empty()){\\n            string a = s.top();\\n            ans.push_back(a);\\n            s.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        stack<string>s;\\n        s.push(words[0]);\\n        for(int i=1;i<words.size();i++){\\n            string a = words[i];\\n            string b = s.top();\\n            sort(b.begin(),b.end());\\n            sort(a.begin(),a.end());\\n            if(a==b){\\n                continue;\\n            }\\n            else{\\n                s.push(words[i]);\\n            }\\n        }\\n        vector<string>ans;\\n        while(!s.empty()){\\n            string a = s.top();\\n            ans.push_back(a);\\n            s.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793306,
                "title": "easy-java-solution-two-pointer",
                "content": "# Complexity\\n- Time complexity:  O(n*log(n)) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(n + m) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] strs) {\\n        List<Integer> toBeRemoved = new ArrayList<>();\\n        List<String> res = new ArrayList<>();\\n        int prev = 0;\\n        int current = 1;\\n        while (current < strs.length) {\\n            if (isAnagram(strs[current], strs[prev]))\\n                toBeRemoved.add(current);\\n            else\\n                prev = current;\\n\\n            current++;\\n        }\\n        for (int str = 0; str < strs.length; str++) {\\n            if (!toBeRemoved.contains(str)) {\\n                res.add(strs[str]);\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean isAnagram(String str1, String str2) {\\n        char[] chars = str1.toCharArray();\\n        Arrays.sort(chars);\\n        String sortedStr1 = new String(chars);\\n        chars = str2.toCharArray();\\n        Arrays.sort(chars);\\n        String sortedStr2 = new String(chars);\\n        return sortedStr1.equals(sortedStr2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] strs) {\\n        List<Integer> toBeRemoved = new ArrayList<>();\\n        List<String> res = new ArrayList<>();\\n        int prev = 0;\\n        int current = 1;\\n        while (current < strs.length) {\\n            if (isAnagram(strs[current], strs[prev]))\\n                toBeRemoved.add(current);\\n            else\\n                prev = current;\\n\\n            current++;\\n        }\\n        for (int str = 0; str < strs.length; str++) {\\n            if (!toBeRemoved.contains(str)) {\\n                res.add(strs[str]);\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean isAnagram(String str1, String str2) {\\n        char[] chars = str1.toCharArray();\\n        Arrays.sort(chars);\\n        String sortedStr1 = new String(chars);\\n        chars = str2.toCharArray();\\n        Arrays.sort(chars);\\n        String sortedStr2 = new String(chars);\\n        return sortedStr1.equals(sortedStr2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791459,
                "title": "python-simple-python-solution-sorting",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 69 ms, faster than 71.36% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\n# Memory Usage: 16.4 MB, less than 25.48% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\n\\n\\tclass Solution:\\n\\t\\tdef removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n\\t\\t\\tresult = [words[0]]\\n\\n\\t\\t\\tfor word in words[1:]:\\n\\n\\t\\t\\t\\tif sorted(result[-1]) != sorted(word):\\n\\t\\t\\t\\t\\tresult.append(word)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Time complexity: O(N)\\n# Space complexity: O(N)\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack",
                    "Sorting"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 69 ms, faster than 71.36% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\n# Memory Usage: 16.4 MB, less than 25.48% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\n\\n\\tclass Solution:\\n\\t\\tdef removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n\\t\\t\\tresult = [words[0]]\\n\\n\\t\\t\\tfor word in words[1:]:\\n\\n\\t\\t\\t\\tif sorted(result[-1]) != sorted(word):\\n\\t\\t\\t\\t\\tresult.append(word)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Time complexity: O(N)\\n# Space complexity: O(N)\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3790903,
                "title": "for-loop-and-counter",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        check = Counter(words[0])\\n        result = [0]\\n        for i in range(1, len(words)):\\n            word = Counter(words[i])\\n            if check != word:\\n                result.append(i)\\n                check = word\\n        return [words[i] for i in result]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        check = Counter(words[0])\\n        result = [0]\\n        for i in range(1, len(words)):\\n            word = Counter(words[i])\\n            if check != word:\\n                result.append(i)\\n                check = word\\n        return [words[i] for i in result]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787106,
                "title": "easy-javascript-solution-satisfying-all-test-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    let sortedWords = words.map((word) => {\\n        return word.split(\"\").sort().join(\"\");\\n    });\\n\\n     for(let i=0; i< sortedWords.length;i++) {\\n         if(sortedWords[i+1] === sortedWords[i]) {\\n             sortedWords.splice(i+1,1);\\n             words.splice(i+1,1);\\n             i--;\\n         }\\n     }\\n\\n    return words;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    let sortedWords = words.map((word) => {\\n        return word.split(\"\").sort().join(\"\");\\n    });\\n\\n     for(let i=0; i< sortedWords.length;i++) {\\n         if(sortedWords[i+1] === sortedWords[i]) {\\n             sortedWords.splice(i+1,1);\\n             words.splice(i+1,1);\\n             i--;\\n         }\\n     }\\n\\n    return words;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3785264,
                "title": "c-solution",
                "content": "```\\nvector<string> removeAnagrams(vector<string>& words) {\\n\\tvector<string> res;\\n\\tfor (int i = 0; i < words.size(); i++) {\\n\\t\\tres.push_back(words[i]);\\n\\t\\tstring sorted = words[i];\\n\\t\\tsort(begin(sorted), end(sorted));\\n\\t\\tint j = i + 1;\\n\\t\\twhile (j < words.size()) {\\n\\t\\t\\tstring sortedj = words[j++];\\n\\t\\t\\tsort(begin(sortedj), end(sortedj));\\n\\t\\t\\tif (sorted == sortedj)\\n\\t\\t\\t\\ti++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<string> removeAnagrams(vector<string>& words) {\\n\\tvector<string> res;\\n\\tfor (int i = 0; i < words.size(); i++) {\\n\\t\\tres.push_back(words[i]);\\n\\t\\tstring sorted = words[i];\\n\\t\\tsort(begin(sorted), end(sorted));\\n\\t\\tint j = i + 1;\\n\\t\\twhile (j < words.size()) {\\n\\t\\t\\tstring sortedj = words[j++];\\n\\t\\t\\tsort(begin(sortedj), end(sortedj));\\n\\t\\t\\tif (sorted == sortedj)\\n\\t\\t\\t\\ti++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3776388,
                "title": "easy-to-understand-python-3",
                "content": "## **Runtime**\\n- 65ms\\nBeats 85.32% of users with Python3\\n\\n## **Memory**\\n- 16.34mb\\nBeats 62.96%of users with Python3\\n\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = []\\n        p = words[0]\\n        for i in words:\\n            if sorted(i) != sorted(p):\\n                res.append(p)\\n                p = i\\n        res.append(p)\\n        return res\\n                \\n\\n                \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = []\\n        p = words[0]\\n        for i in words:\\n            if sorted(i) != sorted(p):\\n                res.append(p)\\n                p = i\\n        res.append(p)\\n        return res\\n                \\n\\n                \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772853,
                "title": "find-resultant-array-after-removing-anagrams-c-9ms-solution-easy-approch-o-n-2logn",
                "content": "# Intuition :-\\n<ul><li>The one basic intution about \"Anagrams\" is that an \"Anagram\" is a string which has the same frequency of character with another string. (or) ,</li>\\n<br/>\\n<li>An \"anagram\" of a string is another string that contains the same characters, only the order of characters can be different eg:- \"abba\" is an anagram of \"abab\" and vice-verse as freq of a=2 and b=2 here.</li>\\n<br/>\\n<li>Now coming to idea the basic approch to this is sorting the string and checking.</li>\\n</ul>\\n\\n# Approach :-\\n<ul><li>At first we store the words vector into a temporary vector for our processing and maintaining the string we want.</li>  \\n    <br/>\\n    <li>Now for anagram we sort the words as after sorting we check weather the loop have any one equal word or not if not we return n-1 as all the words in words vector are anagrams.</li>\\n    <br/>\\n<li>If not then in the below for loop we check weather the two adjacent words that is words[i]==words[i+1] if they are we also have to check if this word already present in our ans if it is we can\\'t insert more of this as we want all the words(elements) of res to be anagram same if they are not equal also.</li>\\n    <br/>\\n<li>Fianlly we check if the beginning word is equal to adjacent or not as we were not able to insert if it was into res.</li>\\n<br/>\\n<li>Finally returning res as answer.</li>\\n</ul>\\n\\n# Complexity :-\\n- Time complexity:\\nO((n^2)logn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n = words.size();\\n        vector<string>temp;\\n        vector<string>res;\\n        unordered_map<string,bool>m;\\n\\n        temp = words;\\n\\n        for(int i=0;i<n;i++) {\\n            sort(temp[i].begin(),temp[i].end());\\n        }\\n\\n        int c=0;\\n        for(int i=0;i<n-1;i++) {\\n            if(temp[i]!=temp[i+1]) c++;\\n        }\\n        \\n        // If all the words are anagrams.\\n        if(c==n-1) res = words;\\n\\n        // If not then we process and find the only anagrams.\\n        else {\\n            for(int i=0;i<n-1;i++) {\\n                if(m[temp[i]]!=true && temp[i]==temp[i+1]) {\\n                    res.push_back(words[i]);\\n                    m[temp[i]] = true;\\n                }\\n                else {\\n                    if(temp[i]!=temp[i+1]) {\\n                        res.push_back(words[i+1]);\\n                        m[temp[i+1]] = true;\\n                    }\\n                }\\n            }\\n\\n            if(temp.size()>1 && temp[0]!=temp[1]) {\\n                res.insert(res.begin(),words[0]);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n<img src=\"https://i.imgflip.com/7abc56.jpg\" alt=\"Please Upvote\">",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n = words.size();\\n        vector<string>temp;\\n        vector<string>res;\\n        unordered_map<string,bool>m;\\n\\n        temp = words;\\n\\n        for(int i=0;i<n;i++) {\\n            sort(temp[i].begin(),temp[i].end());\\n        }\\n\\n        int c=0;\\n        for(int i=0;i<n-1;i++) {\\n            if(temp[i]!=temp[i+1]) c++;\\n        }\\n        \\n        // If all the words are anagrams.\\n        if(c==n-1) res = words;\\n\\n        // If not then we process and find the only anagrams.\\n        else {\\n            for(int i=0;i<n-1;i++) {\\n                if(m[temp[i]]!=true && temp[i]==temp[i+1]) {\\n                    res.push_back(words[i]);\\n                    m[temp[i]] = true;\\n                }\\n                else {\\n                    if(temp[i]!=temp[i+1]) {\\n                        res.push_back(words[i+1]);\\n                        m[temp[i+1]] = true;\\n                    }\\n                }\\n            }\\n\\n            if(temp.size()>1 && temp[0]!=temp[1]) {\\n                res.insert(res.begin(),words[0]);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770019,
                "title": "o-1-sc-and-o-n-log-n-tc-simple-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n * log(n))\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        int n = words.length;\\n        \\n        List<String> li = new ArrayList<>();\\n        int i = 0;\\n        while(i<n){\\n            li.add(words[i]);\\n            char curr[] = words[i].toCharArray();\\n            Arrays.sort(curr);\\n            String current = new String(curr);\\n            String prev = current;\\n            while(current.equals(prev)){\\n                i++;\\n                if(i<n){\\n                    curr = words[i].toCharArray();\\n                    Arrays.sort(curr);\\n                    prev = new String(curr);\\n                }else{\\n                    break;\\n                }\\n                \\n            }\\n        }\\n\\n        return li;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        int n = words.length;\\n        \\n        List<String> li = new ArrayList<>();\\n        int i = 0;\\n        while(i<n){\\n            li.add(words[i]);\\n            char curr[] = words[i].toCharArray();\\n            Arrays.sort(curr);\\n            String current = new String(curr);\\n            String prev = current;\\n            while(current.equals(prev)){\\n                i++;\\n                if(i<n){\\n                    curr = words[i].toCharArray();\\n                    Arrays.sort(curr);\\n                    prev = new String(curr);\\n                }else{\\n                    break;\\n                }\\n                \\n            }\\n        }\\n\\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766658,
                "title": "java-comparing-alphabet-arrays-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        int[] prev = new int[26];\\n        for(String word: words) {\\n            int[] curr = new int[26];\\n            for(char ch: word.toCharArray()) curr[ch - \\'a\\']++;\\n            if(list.isEmpty()|| !Arrays.equals(curr, prev)) {\\n                list.add(word);\\n                prev = curr;\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        int[] prev = new int[26];\\n        for(String word: words) {\\n            int[] curr = new int[26];\\n            for(char ch: word.toCharArray()) curr[ch - \\'a\\']++;\\n            if(list.isEmpty()|| !Arrays.equals(curr, prev)) {\\n                list.add(word);\\n                prev = curr;\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758014,
                "title": "c-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nexplained line by line in below code see\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i=1;i<words.size();i++)\\n        {\\n            string frst=words[i];\\n            sort(frst.begin(),frst.end());\\n            string scnd=words[i-1];\\n            sort(scnd.begin(),scnd.end());\\n            if(frst==scnd)\\n            {\\n                words.erase(words.begin()+i);\\n                i--;\\n            }\\n           \\n        }\\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i=1;i<words.size();i++)\\n        {\\n            string frst=words[i];\\n            sort(frst.begin(),frst.end());\\n            string scnd=words[i-1];\\n            sort(scnd.begin(),scnd.end());\\n            if(frst==scnd)\\n            {\\n                words.erase(words.begin()+i);\\n                i--;\\n            }\\n           \\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754616,
                "title": "brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute Force\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force, use for loops\\n\\n# Complexity\\n- Time complexity: O(len(words) * len(words[i]))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n**        #mark elements to be removed**\\n        mark_idx = [0] * len(words)\\n\\n**        #itr through the list, mark**\\n        for i in range(len(words) - 1):\\n            my_array = [0] * 26\\n            for j in range(len(words[i])):\\n                my_array[ord(words[i][j]) - 97] += 1\\n            comp_array = [0] * 26\\n            for l in range(len(words[i+1])):\\n                comp_array[ord(words[i+1][l]) - 97] += 1\\n            if all(elt1 == elt2 for elt1, elt2 in zip(my_array, comp_array)):\\n                mark_idx[i+1] = 1\\n\\n**        #list to return**\\n        return_array = []\\n        for i in range(len(words)):\\n            if (mark_idx[i] == 0):\\n                return_array.append(words[i])\\n        return return_array\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n**        #mark elements to be removed**\\n        mark_idx = [0] * len(words)\\n\\n**        #itr through the list, mark**\\n        for i in range(len(words) - 1):\\n            my_array = [0] * 26\\n            for j in range(len(words[i])):\\n                my_array[ord(words[i][j]) - 97] += 1\\n            comp_array = [0] * 26\\n            for l in range(len(words[i+1])):\\n                comp_array[ord(words[i+1][l]) - 97] += 1\\n            if all(elt1 == elt2 for elt1, elt2 in zip(my_array, comp_array)):\\n                mark_idx[i+1] = 1\\n\\n**        #list to return**\\n        return_array = []\\n        for i in range(len(words)):\\n            if (mark_idx[i] == 0):\\n                return_array.append(words[i])\\n        return return_array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741761,
                "title": "two-pointers-erase-not-reqd-c-easy",
                "content": "# Intuition\\nTwo Pointers without using erase function\\n\\n# Complexity\\n- Time complexity:\\nO(nklogk)  (k is the max length of string)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n=words.size();\\n        vector<string> ans;\\n        // ans.push_back(words[0]);\\n        int prev=0,i=1;\\n        if(n==1)\\n            return words;\\n        while(i<n)\\n        {\\n            while(i<n && isanagram(words[i],words[prev]))\\n            {\\n                i++;\\n            }\\n            ans.push_back(words[prev]);\\n            if(i==n-1)\\n                ans.push_back(words[i]);\\n            prev=i;\\n            i++;\\n        }\\n        return ans;\\n    }\\n   bool isanagram(string a,string b)\\n   {\\n       if(a.length()!=b.length())\\n        return false;\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        if(a==b)\\n            return true;\\n        return false;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n=words.size();\\n        vector<string> ans;\\n        // ans.push_back(words[0]);\\n        int prev=0,i=1;\\n        if(n==1)\\n            return words;\\n        while(i<n)\\n        {\\n            while(i<n && isanagram(words[i],words[prev]))\\n            {\\n                i++;\\n            }\\n            ans.push_back(words[prev]);\\n            if(i==n-1)\\n                ans.push_back(words[i]);\\n            prev=i;\\n            i++;\\n        }\\n        return ans;\\n    }\\n   bool isanagram(string a,string b)\\n   {\\n       if(a.length()!=b.length())\\n        return false;\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        if(a==b)\\n            return true;\\n        return false;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740806,
                "title": "remove-anagrams-js-intuitive-92",
                "content": "1. Solution simple but slow ( double sorting ) - Beats 26.5 %\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    \\n    for (let i = 1; i < words.length; i++) {\\n        if (anagram(words[i-1], words[i])) {\\n            words.splice(i, 1), i--\\n        }\\n    }\\n\\n    function anagram(str1, str2) {\\n        if (str1.length != str2.length) return false\\n        return str1.split(\\'\\').sort().join() == str2.split(\\'\\').sort().join()\\n    }\\n\\n    return words\\n};\\n```\\n2. Solution 2x times faster ( once sort every words[i] ) - Beats 92.37 %\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    prev = \\'\\'\\n\\n    for (let i = 0; i < words.length; i++) {\\n        str = words[i].split(\\'\\').sort().join(\\'\\')\\n        str == prev && words.splice(i, 1) && i--\\n        prev = str\\n    }\\n\\n    return words\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    \\n    for (let i = 1; i < words.length; i++) {\\n        if (anagram(words[i-1], words[i])) {\\n            words.splice(i, 1), i--\\n        }\\n    }\\n\\n    function anagram(str1, str2) {\\n        if (str1.length != str2.length) return false\\n        return str1.split(\\'\\').sort().join() == str2.split(\\'\\').sort().join()\\n    }\\n\\n    return words\\n};\\n```\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    prev = \\'\\'\\n\\n    for (let i = 0; i < words.length; i++) {\\n        str = words[i].split(\\'\\').sort().join(\\'\\')\\n        str == prev && words.splice(i, 1) && i--\\n        prev = str\\n    }\\n\\n    return words\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1683714,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 1786585,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 1714798,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 2036581,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 2016048,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 2005525,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 1828179,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 1721292,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            }
        ]
    }
]