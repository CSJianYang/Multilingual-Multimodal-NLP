[
    {
        "title": "Most Frequent Even Element",
        "question_content": "Given an integer array nums, return the most frequent even element.\nIf there is a tie, return the smallest one. If there is no such element, return -1.\n&nbsp;\nExample 1:\n\nInput: nums = [0,1,2,2,4,4,1]\nOutput: 2\nExplanation:\nThe even elements are 0, 2, and 4. Of these, 2 and 4 appear the most.\nWe return the smallest one, which is 2.\nExample 2:\n\nInput: nums = [4,4,4,9,2,4]\nOutput: 4\nExplanation: 4 is the even element appears the most.\n\nExample 3:\n\nInput: nums = [29,47,21,41,13,37,25,7]\nOutput: -1\nExplanation: There is no even element.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 2000\n\t0 <= nums[i] <= 105",
        "solutions": [
            {
                "id": 2560064,
                "title": "single-pass-with-comments-c-java-python",
                "content": "# Intuition:\\nGet smallest value with greatest frequency\\n\\n`Time`- O(n)    **[Single Pass Of Array]**\\n`Space` - O(n) **[When all 2000 elements are even and unique]**\\n\\n<iframe src=\"https://leetcode.com/playground/azvtJqPi/shared\" frameBorder=\"0\" width=\"700\" height=\"430\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "# Intuition:\\nGet smallest value with greatest frequency\\n\\n`Time`- O(n)    **[Single Pass Of Array]**\\n`Space` - O(n) **[When all 2000 elements are even and unique]**\\n\\n<iframe src=\"https://leetcode.com/playground/azvtJqPi/shared\" frameBorder=\"0\" width=\"700\" height=\"430\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2560040,
                "title": "c-using-map-very-simple-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int, int> mp;\\n        for(auto n: nums) mp[n]++;\\n        int ans = -1, mx = -1;\\n        for(auto m: mp){\\n            if(m.first%2 == 0 && m.second > mx){\\n                mx = m.second;\\n                ans = m.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int, int> mp;\\n        for(auto n: nums) mp[n]++;\\n        int ans = -1, mx = -1;\\n        for(auto m: mp){\\n            if(m.first%2 == 0 && m.second > mx){\\n                mx = m.second;\\n                ans = m.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177488,
                "title": "best-c-solution-ever-hash-table-counting-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Array + Counting + Hash Table(Unordered map).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(N), We iterate over Array(nums) once and make a constant time HashMap(Unordered map) insertion on each iteration. Therefore, the algorithm runs in O(N) time. Where N is the size of the Array(nums).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(N), Unordered map space. \\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), We iterate over Array(nums) once and make a constant time HashMap(Unordered map)\\n    insertion on each iteration. Therefore, the algorithm runs in O(N) time. Where N is the size of the Array\\n    (nums).\\n\\n    Space Complexity : O(N), Unordered map space. \\n\\n    Solved using Array + Hash Table + Counting.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        for(auto num : nums){\\n            if(num%2 == 0){\\n                map[num]++;\\n            }\\n        }\\n        unordered_map<int, int>::iterator it;\\n        int maxFreqEvenNumber = -1;\\n        int maxFreq = 0;\\n        for(it = map.begin(); it != map.end(); it++){\\n            if(it->second > maxFreq){\\n                maxFreq = it->second;\\n                maxFreqEvenNumber = it->first;\\n            }\\n            else if(it->second == maxFreq){\\n                maxFreqEvenNumber = min(maxFreqEvenNumber, it->first);\\n            }\\n        }\\n        return maxFreqEvenNumber;\\n    }\\n};\\n\\n```\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), We iterate over Array(nums) once and make a constant time HashMap(Unordered map)\\n    insertion on each iteration. Therefore, the algorithm runs in O(N) time. Where N is the size of the Array\\n    (nums).\\n\\n    Space Complexity : O(N), Unordered map space. \\n\\n    Solved using Array + Hash Table + Counting.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        for(auto num : nums){\\n            if(num%2 == 0){\\n                map[num]++;\\n            }\\n        }\\n        unordered_map<int, int>::iterator it;\\n        int maxFreqEvenNumber = -1;\\n        int maxFreq = 0;\\n        for(it = map.begin(); it != map.end(); it++){\\n            if(it->second > maxFreq){\\n                maxFreq = it->second;\\n                maxFreqEvenNumber = it->first;\\n            }\\n            else if(it->second == maxFreq){\\n                maxFreqEvenNumber = min(maxFreqEvenNumber, it->first);\\n            }\\n        }\\n        return maxFreqEvenNumber;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561204,
                "title": "c-java-use-hashmap-easy-approach",
                "content": "\\n##### HASHMAP SOLUTION \\n \\n```\\nTime- O(n) [Single Pass Of Array]\\nSpace - O(n) [When all 2000 elements are even and unique]\\n```\\n**CPP :**\\n\\n```\\nclass Solution {\\npublic:\\n      \\n    int mostFrequentEven(vector<int>& nums) {\\n            map<int,int>counts;\\n            \\n            for(int i:nums){\\n                if(i%2==0)\\n                   counts[i]++;    \\n            }\\n            \\n            int ans=-1 ,freq=INT_MIN; \\n            \\n            for(auto i: counts){\\n                //cout<<i.first <<\" \"<<i.second<<endl;\\n                    if(i.second>freq){\\n                            ans=i.first, freq=i.second;\\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```\\n**JAVA :**\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n            \\n        HashMap<Integer,Integer>counts =new HashMap<>();\\n            for(int i:nums)\\n            {\\n            if(i%2==0)                    \\n                    counts.put(i,counts.getOrDefault(i,0)+1);                                               }\\n            int ans=-1 ,maxFreq=-1;\\n            \\n            for(Integer num:counts.keySet()){\\n                    \\n                if(counts.get(num)>maxFreq){\\n                   maxFreq=counts.get(num);\\n                        ans=num;\\n                }\\n                else if(counts.get(num)==maxFreq && ans>num){\\n                        ans=num;                        \\n                }                    \\n            }\\n            return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nTime- O(n) [Single Pass Of Array]\\nSpace - O(n) [When all 2000 elements are even and unique]\\n```\n```\\nclass Solution {\\npublic:\\n      \\n    int mostFrequentEven(vector<int>& nums) {\\n            map<int,int>counts;\\n            \\n            for(int i:nums){\\n                if(i%2==0)\\n                   counts[i]++;    \\n            }\\n            \\n            int ans=-1 ,freq=INT_MIN; \\n            \\n            for(auto i: counts){\\n                //cout<<i.first <<\" \"<<i.second<<endl;\\n                    if(i.second>freq){\\n                            ans=i.first, freq=i.second;\\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n            \\n        HashMap<Integer,Integer>counts =new HashMap<>();\\n            for(int i:nums)\\n            {\\n            if(i%2==0)                    \\n                    counts.put(i,counts.getOrDefault(i,0)+1);                                               }\\n            int ans=-1 ,maxFreq=-1;\\n            \\n            for(Integer num:counts.keySet()){\\n                    \\n                if(counts.get(num)>maxFreq){\\n                   maxFreq=counts.get(num);\\n                        ans=num;\\n                }\\n                else if(counts.get(num)==maxFreq && ans>num){\\n                        ans=num;                        \\n                }                    \\n            }\\n            return ans;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2562857,
                "title": "python3-1-line-o-n",
                "content": "## Old with collections.Counter\\n```python\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        return min(Counter(x for x in nums if not x % 2).items(), key=lambda x: (-x[1], x[0]), default=[-1])[0]\\n```\\n\\n## New (Improved!) with statistics.multimode\\nDisclaimer: May not be O(n) until Python 3.11. See comments for details.\\n\\n```python\\n        return min(multimode(x for x in nums if not x % 2), default=-1)\\n```\\n\\nYou could also use ` or [-1]` instead of `, default=-1` in code golf but it seems a little uglier.\\n",
                "solutionTags": [
                    "Python",
                    "Probability and Statistics"
                ],
                "code": "```python\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        return min(Counter(x for x in nums if not x % 2).items(), key=lambda x: (-x[1], x[0]), default=[-1])[0]\\n```\n```python\\n        return min(multimode(x for x in nums if not x % 2), default=-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560307,
                "title": "sort-vs-hash-map",
                "content": "#### Hash Map\\n**C++**\\n```cpp\\nint mostFrequentEven(vector<int>& nums) {\\n    unordered_map<int, int> m;\\n    int max_cnt = 0, res = INT_MAX;\\n    for(int n : nums)\\n        if (n % 2 == 0)\\n            if (int cnt = ++m[n]; cnt >= max_cnt) {\\n                res = max_cnt < cnt ? n : min(res, n);\\n                max_cnt = cnt;\\n            }\\n    return res == INT_MAX ? -1 : res;\\n}\\n```\\n#### Sort\\nAlternatively, we can sort the elements, and then count the repetitions.\\n\\nTo make sorting more efficient, we first remove all odd elements.\\n\\n**C++**\\n```cpp\\nint mostFrequentEven(vector<int>& nums) {\\n    auto even_end = remove_if(begin(nums), end(nums), [](int n){ return n % 2; });\\n    sort(begin(nums), even_end);\\n    int cnt = 0, max_cnt = 0, res = -1;\\n    for (auto it = begin(nums); it != even_end; ++it) {\\n        cnt = it != begin(nums) && *it == *prev(it) ? cnt + 1 : 1;    \\n        res = max_cnt < cnt ? *it : res;\\n        max_cnt = max(max_cnt, cnt);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint mostFrequentEven(vector<int>& nums) {\\n    unordered_map<int, int> m;\\n    int max_cnt = 0, res = INT_MAX;\\n    for(int n : nums)\\n        if (n % 2 == 0)\\n            if (int cnt = ++m[n]; cnt >= max_cnt) {\\n                res = max_cnt < cnt ? n : min(res, n);\\n                max_cnt = cnt;\\n            }\\n    return res == INT_MAX ? -1 : res;\\n}\\n```\n```cpp\\nint mostFrequentEven(vector<int>& nums) {\\n    auto even_end = remove_if(begin(nums), end(nums), [](int n){ return n % 2; });\\n    sort(begin(nums), even_end);\\n    int cnt = 0, max_cnt = 0, res = -1;\\n    for (auto it = begin(nums); it != even_end; ++it) {\\n        cnt = it != begin(nums) && *it == *prev(it) ? cnt + 1 : 1;    \\n        res = max_cnt < cnt ? *it : res;\\n        max_cnt = max(max_cnt, cnt);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2560659,
                "title": "java-simple-hashmap",
                "content": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        \\n        Map<Integer,Integer> map=new HashMap<>();\\n        \\n        int max=-1;\\n        int res=Integer.MAX_VALUE;\\n        \\n        for(int i:nums){\\n            \\n           \\n            if(i%2 == 0){                        //Only even element\\n            map.put(i,map.getOrDefault(i,0)+1);\\n            \\n            \\n            if(map.get(i)>max){                 //Check if greater than Max Val\\n            max=Math.max(max,map.get(i));\\n            res=i;\\n            }                                   \\n            else if(map.get(i)==max && res>i){  //Check if equals to Max Val and element is less than current res\\n            res=i;\\n            }\\n            }\\n        }\\n        \\n        return res==Integer.MAX_VALUE? -1: res; \\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        \\n        Map<Integer,Integer> map=new HashMap<>();\\n        \\n        int max=-1;\\n        int res=Integer.MAX_VALUE;\\n        \\n        for(int i:nums){\\n            \\n           \\n            if(i%2 == 0){                        //Only even element\\n            map.put(i,map.getOrDefault(i,0)+1);\\n            \\n            \\n            if(map.get(i)>max){                 //Check if greater than Max Val\\n            max=Math.max(max,map.get(i));\\n            res=i;\\n            }                                   \\n            else if(map.get(i)==max && res>i){  //Check if equals to Max Val and element is less than current res\\n            res=i;\\n            }\\n            }\\n        }\\n        \\n        return res==Integer.MAX_VALUE? -1: res; \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839662,
                "title": "python-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        seen = {}\\n        for item in nums:\\n            if item % 2 ==0:\\n                seen[item] = 1 if item not in seen else seen[item] + 1\\n        maxx = 0    \\n        output = -1        \\n        for num, count in seen.items():\\n            if count > maxx:\\n                maxx, output = count, num\\n            elif count == maxx:\\n                output = min(num,output)\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        seen = {}\\n        for item in nums:\\n            if item % 2 ==0:\\n                seen[item] = 1 if item not in seen else seen[item] + 1\\n        maxx = 0    \\n        output = -1        \\n        for num, count in seen.items():\\n            if count > maxx:\\n                maxx, output = count, num\\n            elif count == maxx:\\n                output = min(num,output)\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581151,
                "title": "python-3-2-lines-counter-t-m-95-86",
                "content": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        ctr = Counter(nums)\\n        return max([c for c in ctr if not c%2], key = lambda x:(ctr[x], -x), default = -1)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        ctr = Counter(nums)\\n        return max([c for c in ctr if not c%2], key = lambda x:(ctr[x], -x), default = -1)",
                "codeTag": "Java"
            },
            {
                "id": 2611296,
                "title": "100-o-n-easy-short-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```\\n```\\n        int[] arr = new int[100001];\\n        int ans = 1;\\n        for(int i : nums){\\n            if(i % 2 == 0){\\n                arr[i]++;\\n                if ( (arr[ans] < arr[i]) || (arr[ans] == arr[i] && ans > i) ){\\n                    ans = i;\\n                }\\n            }\\n        }\\n        return ans == 1 ? -1 : ans;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2564772,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\nI\\'ll explain my solution line by line daily and you can find the full list in my [Discord](https://discord.gg/Nqm4jJcyBf).\\nIf you like it, please give a star, watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post.\\n\\n**C++**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        // init ans to -1 here in case there is no such element\\n        int ans = -1, mx = 0;\\n        // use hash map to store the frequency of each element\\n        map<int, int> m;\\n        for (auto &x : nums) m[x]++;\\n        // iterate each element in the hash map\\n        for (auto &x : m) {\\n            // x.first is the element\\n            // x.second is the frequency of that element\\n            // if the element is even -> x.first % 2 == 0 \\n            // and if the count is greater than the current maximum -> x.second > mx\\n            if (x.first % 2 == 0 && x.second > mx) {\\n                // then we can update the maximum\\n                mx = x.second;\\n                // and this element can be the answer\\n                ans = x.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        // init ans to -1 here in case there is no such element\\n        int ans = -1, mx = 0;\\n        // use hash map to store the frequency of each element\\n        map<int, int> m;\\n        for (auto &x : nums) m[x]++;\\n        // iterate each element in the hash map\\n        for (auto &x : m) {\\n            // x.first is the element\\n            // x.second is the frequency of that element\\n            // if the element is even -> x.first % 2 == 0 \\n            // and if the count is greater than the current maximum -> x.second > mx\\n            if (x.first % 2 == 0 && x.second > mx) {\\n                // then we can update the maximum\\n                mx = x.second;\\n                // and this element can be the answer\\n                ans = x.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462841,
                "title": "most-frequent-even-element-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int i, element=-1, max=0;\\n        unordered_map<int, int> m;\\n\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                m[nums[i]]++;\\n            }\\n        }\\n        for(auto it:m)\\n        {\\n            if(it.second>max)\\n            {\\n                max = it.second;\\n                element = it.first;\\n            }\\n            else if(it.second==max && it.first<element)\\n            {\\n                element = it.first;\\n            }\\n        }\\n        return element;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/4e1bbbd6-8303-4a11-a8fd-23a3a550641f_1682667259.8784928.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int i, element=-1, max=0;\\n        unordered_map<int, int> m;\\n\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                m[nums[i]]++;\\n            }\\n        }\\n        for(auto it:m)\\n        {\\n            if(it.second>max)\\n            {\\n                max = it.second;\\n                element = it.first;\\n            }\\n            else if(it.second==max && it.first<element)\\n            {\\n                element = it.first;\\n            }\\n        }\\n        return element;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563072,
                "title": "less-than-and-faster-than-100-00-of-python-simple",
                "content": "```\\nclass Solution(object):\\n    def mostFrequentEven(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums = [n for n in nums if n % 2 == 0]\\n        nums.sort()\\n        return max(nums,key=nums.count) if len(nums) > 0 else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def mostFrequentEven(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums = [n for n in nums if n % 2 == 0]\\n        nums.sort()\\n        return max(nums,key=nums.count) if len(nums) > 0 else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795601,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n      \\n    int mostFrequentEven(vector<int>& nums) {\\n            map<int,int>counts;\\n            \\n            for(int i:nums){\\n                if(i%2==0)\\n                   counts[i]++;    \\n            }\\n            \\n            int ans=-1 ,freq=INT_MIN; \\n            \\n            for(auto i: counts){\\n                //cout<<i.first <<\" \"<<i.second<<endl;\\n                    if(i.second>freq){\\n                            ans=i.first, freq=i.second;\\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      \\n    int mostFrequentEven(vector<int>& nums) {\\n            map<int,int>counts;\\n            \\n            for(int i:nums){\\n                if(i%2==0)\\n                   counts[i]++;    \\n            }\\n            \\n            int ans=-1 ,freq=INT_MIN; \\n            \\n            for(auto i: counts){\\n                //cout<<i.first <<\" \"<<i.second<<endl;\\n                    if(i.second>freq){\\n                            ans=i.first, freq=i.second;\\n                    }\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2562939,
                "title": "javascript-solution-using-a-map-object",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nvar mostFrequentEven = function (nums) {\\n    let evenNumMap = new Map()\\n    let max = 0\\n\\t\\n\\t//Popuates evenNumMap and finds the most frequent even number.\\n    for (let num of nums) {\\n        if (!evenNumMap.has(num) && num % 2 === 0) {\\n            evenNumMap.set(num, 1)\\n        } else if (evenNumMap.has(num) && num % 2 === 0) {\\n            evenNumMap.set(num, evenNumMap.get(num) + 1)\\n        }\\n\\n        if (evenNumMap.get(num) > max) max = evenNumMap.get(num)\\n    }\\n\\n    let smallestMaxKey = Infinity\\n\\t\\n\\t//Finds the smallest key with the value max.\\n    for (let [num, count] of evenNumMap) {\\n        if (count === max && num < smallestMaxKey) smallestMaxKey = num\\n    }\\n\\n    return smallestMaxKey === Infinity ? -1 : smallestMaxKey\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mostFrequentEven = function (nums) {\\n    let evenNumMap = new Map()\\n    let max = 0\\n\\t\\n\\t//Popuates evenNumMap and finds the most frequent even number.\\n    for (let num of nums) {\\n        if (!evenNumMap.has(num) && num % 2 === 0) {\\n            evenNumMap.set(num, 1)\\n        } else if (evenNumMap.has(num) && num % 2 === 0) {\\n            evenNumMap.set(num, evenNumMap.get(num) + 1)\\n        }\\n\\n        if (evenNumMap.get(num) > max) max = evenNumMap.get(num)\\n    }\\n\\n    let smallestMaxKey = Infinity\\n\\t\\n\\t//Finds the smallest key with the value max.\\n    for (let [num, count] of evenNumMap) {\\n        if (count === max && num < smallestMaxKey) smallestMaxKey = num\\n    }\\n\\n    return smallestMaxKey === Infinity ? -1 : smallestMaxKey\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3077910,
                "title": "easy-to-understand-c-solution-using-map-sc-o-n",
                "content": "# Intuition \\n \\n\\n# Approach\\nI used the map to store the frequency.\\n\\n# Complexity\\n- Time complexity:\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map <int,int> mp;\\n        int k;\\n        int maxi=INT_MIN;\\n        int flag=0;\\n        for(int i:nums) mp[i]++;\\n        for(auto &it:mp){\\n            if((it.second>maxi) &&((it.first)%2==0)){\\n             maxi=it.second;\\n            k=it.first;\\n            flag=1;\\n            }\\n        }\\n        if(flag)\\n            return k;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map <int,int> mp;\\n        int k;\\n        int maxi=INT_MIN;\\n        int flag=0;\\n        for(int i:nums) mp[i]++;\\n        for(auto &it:mp){\\n            if((it.second>maxi) &&((it.first)%2==0)){\\n             maxi=it.second;\\n            k=it.first;\\n            flag=1;\\n            }\\n        }\\n        if(flag)\\n            return k;\\n        else\\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946020,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int>counts;\\n            \\n            for(int i:nums){\\n                if(i%2==0)\\n                   counts[i]++;    \\n            }\\n            \\n            int ans=-1 ,freq=INT_MIN; \\n            \\n            for(auto i: counts){\\n                //cout<<i.first <<\" \"<<i.second<<endl;\\n                    if(i.second>freq){\\n                            ans=i.first, freq=i.second;\\n                    }\\n            }\\n            return ans;  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int>counts;\\n            \\n            for(int i:nums){\\n                if(i%2==0)\\n                   counts[i]++;    \\n            }\\n            \\n            int ans=-1 ,freq=INT_MIN; \\n            \\n            for(auto i: counts){\\n                //cout<<i.first <<\" \"<<i.second<<endl;\\n                    if(i.second>freq){\\n                            ans=i.first, freq=i.second;\\n                    }\\n            }\\n            return ans;  }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2898203,
                "title": "java-easy-to-understand-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        Map<Integer, Integer> ans = new HashMap<>();\\n        for (int v : nums) {\\n            if (v % 2 == 0) {\\n                ans.put(v, ans.getOrDefault(v, 0) + 1);\\n            }\\n        }\\n        int result = -1, mx = 0;\\n        for (var y : ans.entrySet()) {\\n            int x = y.getKey(), t = y.getValue();\\n            if (mx < t || (mx == t && result > x)) {\\n                mx = t;\\n                result = x;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        Map<Integer, Integer> ans = new HashMap<>();\\n        for (int v : nums) {\\n            if (v % 2 == 0) {\\n                ans.put(v, ans.getOrDefault(v, 0) + 1);\\n            }\\n        }\\n        int result = -1, mx = 0;\\n        for (var y : ans.entrySet()) {\\n            int x = y.getKey(), t = y.getValue();\\n            if (mx < t || (mx == t && result > x)) {\\n                mx = t;\\n                result = x;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849884,
                "title": "using-unordered-map-simple-solution-beating-96",
                "content": "# Intuition\\nWe can use unordered map to store frequency of even elements and then check for some basic conditions.\\n\\n# Approach\\nFirst of all, sort the vector given in ascending order, since, we have to return smallest in the case of a tie. Then use an unordered map to store frequency of elements, if the the element is even. Then check if the frequency of that element is greater than the maximum frequency so far. If yes, then update the maximum frequency so far and also update the value of the element into a variable which has to assigned by -1 initially. Then return that integer variable. If there would be no even numbers, the variable would never be updated and will return -1. The code is attached for reference.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) \\n    {\\n        sort(nums.begin() , nums.end());\\n        unordered_map<int , int> mp;\\n        int mx = 0, ans = -1;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(!(nums[i] & 1))\\n            {\\n                mp[nums[i]]++;\\n                if(mp[nums[i]] > mx)\\n                {\\n                    mx = mp[nums[i]];\\n                    ans = nums[i];\\n                }                \\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) \\n    {\\n        sort(nums.begin() , nums.end());\\n        unordered_map<int , int> mp;\\n        int mx = 0, ans = -1;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            if(!(nums[i] & 1))\\n            {\\n                mp[nums[i]]++;\\n                if(mp[nums[i]] > mx)\\n                {\\n                    mx = mp[nums[i]];\\n                    ans = nums[i];\\n                }                \\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619769,
                "title": "python-most-frequent-even-element-2404",
                "content": "class Solution:\\n\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d={}\\n        l=[]\\n        for i in nums:\\n            if i%2 == 0:\\n                if i not in d:\\n                    d[i]=1\\n                else:\\n                    d[i]+=1\\n        if len(d)==0:\\n            return -1\\n        else:\\n            t = max(d.values())\\n            for k,v in d.items():\\n                if v == t:\\n                    l.append(k)\\n            return min(l)\\n\\t\\t\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d={}",
                "codeTag": "Java"
            },
            {
                "id": 2560831,
                "title": "c-o-n-clean-code-hashmap",
                "content": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int,int> ump;\\n    \\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2==0)\\n                ump[nums[i]]++;\\n        }\\n        \\n        int num=-1,freq=0;\\n        for(auto i:ump){\\n            if(i.second>freq){\\n                freq=i.second;\\n                num=i.first;\\n            }\\n            else if(i.second==freq && i.first<num)\\n                num=i.first;\\n        }\\n        \\n        return num;\\n    }\\n};\\n```\\n\\nPlease upvote if you find this helpful :)\\n",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int,int> ump;\\n    \\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            if(nums[i]%2==0)\\n                ump[nums[i]]++;\\n        }\\n        \\n        int num=-1,freq=0;\\n        for(auto i:ump){\\n            if(i.second>freq){\\n                freq=i.second;\\n                num=i.first;\\n            }\\n            else if(i.second==freq && i.first<num)\\n                num=i.first;\\n        }\\n        \\n        return num;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560284,
                "title": "python3-2-line",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b89b2c654a0b8ced9885ecdb433ad5f929a1d4b4) for solutions of weekly 310. \\n\\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        freq = Counter(x for x in nums if x&1 == 0)\\n        return min(freq, key=lambda x: (-freq[x], x), default=-1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        freq = Counter(x for x in nums if x&1 == 0)\\n        return min(freq, key=lambda x: (-freq[x], x), default=-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560162,
                "title": "c-easy-using-map",
                "content": "```\\nint mostFrequentEven(vector<int>& nums) {\\n\\tmap<int,int> mp;\\n\\tfor(int i = 0;i<nums.size();i++)\\n\\tif(nums[i]%2 == 0)\\n\\tmp[nums[i]]++;\\n\\t\\n\\tint maxi = 0;\\n\\tint ans = -1; \\n\\t for (auto it = mp.rbegin(); it != mp.rend(); it++) {\\n            if(maxi <= it->second))\\n            {\\n                maxi = it -> second;\\n                ans = it -> first;\\n            }\\n    }\\n\\treturn ans;\\n\\t}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint mostFrequentEven(vector<int>& nums) {\\n\\tmap<int,int> mp;\\n\\tfor(int i = 0;i<nums.size();i++)\\n\\tif(nums[i]%2 == 0)\\n\\tmp[nums[i]]++;\\n\\t\\n\\tint maxi = 0;\\n\\tint ans = -1; \\n\\t for (auto it = mp.rbegin(); it != mp.rend(); it++) {\\n            if(maxi <= it->second))\\n            {\\n                maxi = it -> second;\\n                ans = it -> first;\\n            }\\n    }\\n\\treturn ans;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3382679,
                "title": "simple-c-solution-using-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int> m;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            \\n            m[nums[i]]++;\\n            \\n             }\\n\\n    int max_count = 0, res = -1;\\n    for (auto i : m) {\\n        if (max_count < i.second && i.first%2==0 ) {\\n            res = i.first;\\n            max_count = i.second;\\n        }\\n    }\\n  \\n    return res;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int> m;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++){\\n            \\n            m[nums[i]]++;\\n            \\n             }\\n\\n    int max_count = 0, res = -1;\\n    for (auto i : m) {\\n        if (max_count < i.second && i.first%2==0 ) {\\n            res = i.first;\\n            max_count = i.second;\\n        }\\n    }\\n  \\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939508,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int, int> m;\\n        for(auto i: nums){\\n            if(i%2==0)  // adding only even integers\\n                m[i]++;\\n        }\\n        int max = -1, most_frequent_element = -1;\\n        for(auto i: m){\\n            if(i.second > max){\\n                max = i.second;\\n                most_frequent_element = i.first;\\n            }\\n        }\\n        return most_frequent_element;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int, int> m;\\n        for(auto i: nums){\\n            if(i%2==0)  // adding only even integers\\n                m[i]++;\\n        }\\n        int max = -1, most_frequent_element = -1;\\n        for(auto i: m){\\n            if(i.second > max){\\n                max = i.second;\\n                most_frequent_element = i.first;\\n            }\\n        }\\n        return most_frequent_element;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897231,
                "title": "c-easy-approach-map",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint mostFrequentEven(vector<int>& nums) {\\n\\t\\tmap<int, int> mp;\\n\\t\\tint maxFreqNum = INT_MAX, maxFreq = 0;\\n\\t\\tfor(auto i: nums){\\n\\t\\t\\tif(i & 1) continue; //i is odd\\n\\t\\t\\tmp[i]++;\\n\\t\\t\\tif(mp[i] >= maxFreq){\\n\\t\\t\\t\\tmaxFreqNum = mp[i] == maxFreq ? min(i, maxFreqNum) : i;\\n\\t\\t\\t\\tmaxFreq = mp[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn (maxFreqNum == INT_MAX) ? -1 : maxFreqNum;\\n\\t}\\n};\\n```\\nI hope it will help you :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint mostFrequentEven(vector<int>& nums) {\\n\\t\\tmap<int, int> mp;\\n\\t\\tint maxFreqNum = INT_MAX, maxFreq = 0;\\n\\t\\tfor(auto i: nums){\\n\\t\\t\\tif(i & 1) continue; //i is odd\\n\\t\\t\\tmp[i]++;\\n\\t\\t\\tif(mp[i] >= maxFreq){\\n\\t\\t\\t\\tmaxFreqNum = mp[i] == maxFreq ? min(i, maxFreqNum) : i;\\n\\t\\t\\t\\tmaxFreq = mp[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn (maxFreqNum == INT_MAX) ? -1 : maxFreqNum;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795372,
                "title": "easy-python-code-beats-100-intuitive-approach-beginner-level",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        h={}\\n        for i in nums:\\n            if i%2==0:\\n                if i in h:\\n                    h[i]+=1\\n                else:\\n                    h[i]=1\\n        o=0\\n        ans=-1\\n        for i in h.keys():\\n            if h[i]>o:\\n                o=h[i]\\n                ans=i\\n            if h[i]==o and i<ans:\\n                ans=i\\n        return ans\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        h={}\\n        for i in nums:\\n            if i%2==0:\\n                if i in h:\\n                    h[i]+=1\\n                else:\\n                    h[i]=1\\n        o=0\\n        ans=-1\\n        for i in h.keys():\\n            if h[i]>o:\\n                o=h[i]\\n                ans=i\\n            if h[i]==o and i<ans:\\n                ans=i\\n        return ans\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564407,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int max_freq = 0, element = -1;\\n        for(int num: nums){\\n            if(num % 2 == 0)    map.put(num, map.getOrDefault(num, 0)+1);\\n            if(num % 2 == 0 && max_freq <= map.get(num)){\\n                if(max_freq == map.get(num)){\\n                    element = Math.min(element, num);\\n                }else{\\n                    element = num;\\n                    max_freq = map.get(element);\\n                }\\n            }\\n        }\\n        return element;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar mostFrequentEven = function(nums) {\\n    let map = new Map();\\n    let max_freq = 0, element = -1;\\n    for(let num of nums){\\n        if(num % 2 == 0)    map.set(num, (map.get(num) || 0) + 1);\\n        if(num % 2 == 0 && max_freq <= map.get(num)){\\n            if(max_freq == map.get(num)){\\n                element = Math.min(element, num);\\n            }else{\\n                element = num;\\n                max_freq = map.get(element);\\n            }\\n        }\\n    }\\n    return element;\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def mostFrequentEven(self, nums):\\n        mymap = {}\\n        max_freq, element = 0, -1\\n        for num in nums:\\n            if num % 2 == 0:\\n                if num in mymap:\\n                    mymap[num] += 1\\n                else:\\n                    mymap[num] = 1 \\n            if num % 2 == 0 and max_freq <= mymap[num]:\\n                if max_freq == mymap[num]:\\n                    element = min(element, num)\\n                else:\\n                    element = num\\n                    max_freq = mymap[element]\\n        return element\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int max_freq = 0, element = -1;\\n        for(int num: nums){\\n            if(num % 2 == 0)    map.put(num, map.getOrDefault(num, 0)+1);\\n            if(num % 2 == 0 && max_freq <= map.get(num)){\\n                if(max_freq == map.get(num)){\\n                    element = Math.min(element, num);\\n                }else{\\n                    element = num;\\n                    max_freq = map.get(element);\\n                }\\n            }\\n        }\\n        return element;\\n    }\\n}\\n```\n```\\nvar mostFrequentEven = function(nums) {\\n    let map = new Map();\\n    let max_freq = 0, element = -1;\\n    for(let num of nums){\\n        if(num % 2 == 0)    map.set(num, (map.get(num) || 0) + 1);\\n        if(num % 2 == 0 && max_freq <= map.get(num)){\\n            if(max_freq == map.get(num)){\\n                element = Math.min(element, num);\\n            }else{\\n                element = num;\\n                max_freq = map.get(element);\\n            }\\n        }\\n    }\\n    return element;\\n};\\n```\n```\\nclass Solution(object):\\n    def mostFrequentEven(self, nums):\\n        mymap = {}\\n        max_freq, element = 0, -1\\n        for num in nums:\\n            if num % 2 == 0:\\n                if num in mymap:\\n                    mymap[num] += 1\\n                else:\\n                    mymap[num] = 1 \\n            if num % 2 == 0 and max_freq <= mymap[num]:\\n                if max_freq == mymap[num]:\\n                    element = min(element, num)\\n                else:\\n                    element = num\\n                    max_freq = mymap[element]\\n        return element\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563040,
                "title": "python-solution-easy-understanding",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def mostFrequentEven(self, nums) -> int:\\n        counter = Counter([i for i in nums if i % 2 == 0])\\n        if not counter:\\n            return -1\\n        res = {x: count for x, count in counter.items() if count == max(counter.values())}\\n        return min(res.keys())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def mostFrequentEven(self, nums) -> int:\\n        counter = Counter([i for i in nums if i % 2 == 0])\\n        if not counter:\\n            return -1\\n        res = {x: count for x, count in counter.items() if count == max(counter.values())}\\n        return min(res.keys())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562508,
                "title": "rust-7ms-fastest-100-solution-with-btreemap-with-detailed-comments",
                "content": "This [solution](https://leetcode.com/submissions/detail/797131469/) employs a functional-style approach with BTreeMaps to compute frequencies of even numbers and deduce the most frequent of them. It demonstrated **7 ms runtime (100%)** and used **2.2 MB memory (100%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nuse std::collections::BTreeMap;\\n\\nimpl Solution \\n{\\n    pub fn most_frequent_even(nums: Vec<i32>) -> i32 \\n    {\\n        // [1] to compute frequencies, we use BTreeMap that maintains sorted keys\\n        let mut freq: BTreeMap<i32,i32> = BTreeMap::new();\\n        \\n        // [2] populate HashMap with frequencies of even numbers\\n        nums.into_iter().for_each(|r| if r % 2 == 0 { *freq.entry(r).or_default() += 1 });\\n        \\n        // [3] find maximum frequency among even numbers, or return -1\\n        freq.into_iter().rev().max_by_key(|&pair| pair.1).unwrap_or((-1,-1)).0   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::BTreeMap;\\n\\nimpl Solution \\n{\\n    pub fn most_frequent_even(nums: Vec<i32>) -> i32 \\n    {\\n        // [1] to compute frequencies, we use BTreeMap that maintains sorted keys\\n        let mut freq: BTreeMap<i32,i32> = BTreeMap::new();\\n        \\n        // [2] populate HashMap with frequencies of even numbers\\n        nums.into_iter().for_each(|r| if r % 2 == 0 { *freq.entry(r).or_default() += 1 });\\n        \\n        // [3] find maximum frequency among even numbers, or return -1\\n        freq.into_iter().rev().max_by_key(|&pair| pair.1).unwrap_or((-1,-1)).0   \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2560581,
                "title": "one-pass-and-two-pass-solution-using-hashmap-o-n-time-o-n-space",
                "content": "1. Two Pass | O(n) Time | O(n) Space | n = nums.length\\n\\n\\t```cpp\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint mostFrequentEven(vector<int> &nums) {\\n\\t\\t\\tint maxFreq = 0;\\n\\t\\t\\tmap<int, int> mp;\\n\\t\\t\\tfor (int &num : nums) {\\n\\t\\t\\t\\tif (num % 2 == 0) {\\n\\t\\t\\t\\t\\tmp[num]++;\\n\\t\\t\\t\\t\\tmaxFreq = max(maxFreq, mp[num]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor (auto &[key, value] : mp) {\\n\\t\\t\\t\\tif (value == maxFreq) {\\n\\t\\t\\t\\t\\treturn key;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};\\n\\t```\\n\\n<br>\\n\\n2. One Pass | O(n) Time | O(n) Space | n = nums.length\\n\\t```cpp\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint mostFrequentEven(vector<int> &nums) {\\n\\t\\t\\tunordered_map<int, int> mp;\\n\\t\\t\\tint key = INT_MAX, maxFreq = 0;\\n\\t\\t\\tfor (int &num : nums) {\\n\\t\\t\\t\\tif (num % 2 == 0) {\\n\\t\\t\\t\\t\\tmp[num]++;\\n\\t\\t\\t\\t\\tif (mp[num] > maxFreq || (mp[num] == maxFreq && num < key)) {\\n\\t\\t\\t\\t\\t\\tkey = num;\\n\\t\\t\\t\\t\\t\\tmaxFreq = mp[num];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxFreq ? key : -1;\\n\\t\\t}\\n\\t};\\n\\t```\\n\\nPlease do **upvote** and **share**.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint mostFrequentEven(vector<int> &nums) {\\n\\t\\t\\tint maxFreq = 0;\\n\\t\\t\\tmap<int, int> mp;\\n\\t\\t\\tfor (int &num : nums) {\\n\\t\\t\\t\\tif (num % 2 == 0) {\\n\\t\\t\\t\\t\\tmp[num]++;\\n\\t\\t\\t\\t\\tmaxFreq = max(maxFreq, mp[num]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor (auto &[key, value] : mp) {\\n\\t\\t\\t\\tif (value == maxFreq) {\\n\\t\\t\\t\\t\\treturn key;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};\\n\\t```\n```cpp\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint mostFrequentEven(vector<int> &nums) {\\n\\t\\t\\tunordered_map<int, int> mp;\\n\\t\\t\\tint key = INT_MAX, maxFreq = 0;\\n\\t\\t\\tfor (int &num : nums) {\\n\\t\\t\\t\\tif (num % 2 == 0) {\\n\\t\\t\\t\\t\\tmp[num]++;\\n\\t\\t\\t\\t\\tif (mp[num] > maxFreq || (mp[num] == maxFreq && num < key)) {\\n\\t\\t\\t\\t\\t\\tkey = num;\\n\\t\\t\\t\\t\\t\\tmaxFreq = mp[num];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxFreq ? key : -1;\\n\\t\\t}\\n\\t};\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2560161,
                "title": "rust-with-comments",
                "content": "This is my unrevised submission for the 2022-09-11 Weekly Contest 310. Build a histogram of the frequencies of numbers, just considering the numbers that are even. Iterate in reverse to get the smallest number with the highest count. Very quick and dirty, just to get the easy problem done as quickly as possible.\\n\\n```\\nimpl Solution {\\n    pub fn most_frequent_even(nums: Vec<i32>) -> i32 {\\n        let mut hist = [-1; 100001];\\n        for num in nums {\\n            if num % 2 == 0 {\\n                hist[num as usize + 1] += 1;\\n            }\\n        }\\n        hist.into_iter().enumerate().rev().max_by_key(|(_, freq)| *freq).map(|(i, _)| (i as i32) - 1).unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn most_frequent_even(nums: Vec<i32>) -> i32 {\\n        let mut hist = [-1; 100001];\\n        for num in nums {\\n            if num % 2 == 0 {\\n                hist[num as usize + 1] += 1;\\n            }\\n        }\\n        hist.into_iter().enumerate().rev().max_by_key(|(_, freq)| *freq).map(|(i, _)| (i as i32) - 1).unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3903851,
                "title": "using-ordered-map",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n log m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int> mp;\\n\\n        int n = nums.size();\\n\\n        for(int i=0;i<n;i++) {\\n            if(nums[i]%2 == 0)\\n                mp[nums[i]]++;\\n        }\\n\\n        int maxNum = -1;\\n        int maxFreq = 0;\\n        for(auto it:mp) {\\n            \\n\\n            if(it.second > maxFreq) {\\n                maxFreq = it.second;\\n                maxNum = it.first;\\n            }\\n        }\\n\\n        return maxNum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int> mp;\\n\\n        int n = nums.size();\\n\\n        for(int i=0;i<n;i++) {\\n            if(nums[i]%2 == 0)\\n                mp[nums[i]]++;\\n        }\\n\\n        int maxNum = -1;\\n        int maxFreq = 0;\\n        for(auto it:mp) {\\n            \\n\\n            if(it.second > maxFreq) {\\n                maxFreq = it.second;\\n                maxNum = it.first;\\n            }\\n        }\\n\\n        return maxNum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447442,
                "title": "c-easy-soln-without-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n       int maxi=-1,count=0;\\n       for(int i=0;i<nums.size();)\\n       {\\n            int x=nums[i],freq=0;\\n            if(x%2==0)\\n            {\\n                while(i<nums.size() and nums[i]==x)\\n                {\\n                    i++;\\n                    freq++;\\n                }\\n                if(freq>count)\\n                {\\n                    count=freq;\\n                    maxi=x;\\n                }\\n                continue;\\n            }\\n            i++;\\n        }\\n       return maxi; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n       sort(nums.begin(),nums.end());\\n       int maxi=-1,count=0;\\n       for(int i=0;i<nums.size();)\\n       {\\n            int x=nums[i],freq=0;\\n            if(x%2==0)\\n            {\\n                while(i<nums.size() and nums[i]==x)\\n                {\\n                    i++;\\n                    freq++;\\n                }\\n                if(freq>count)\\n                {\\n                    count=freq;\\n                    maxi=x;\\n                }\\n                continue;\\n            }\\n            i++;\\n        }\\n       return maxi; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377327,
                "title": "hash-table-implementation-java-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        Map<Integer, Integer> table = new HashMap();\\n        int result = -1;\\n        int frequency = -1;\\n        \\n        for(int key : nums)\\n            if(key % 2 == 0)\\n                table.put(key, table.getOrDefault(key, 0)+1);\\n        \\n        if(table.size() == 0) return -1;\\n\\n        for(int key : table.keySet()){\\n            if(table.get(key) > frequency){\\n                frequency = table.get(key);\\n                result = key;\\n            }\\n\\n            if(table.get(key) == frequency && key < result)\\n               result = key;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        Map<Integer, Integer> table = new HashMap();\\n        int result = -1;\\n        int frequency = -1;\\n        \\n        for(int key : nums)\\n            if(key % 2 == 0)\\n                table.put(key, table.getOrDefault(key, 0)+1);\\n        \\n        if(table.size() == 0) return -1;\\n\\n        for(int key : table.keySet()){\\n            if(table.get(key) > frequency){\\n                frequency = table.get(key);\\n                result = key;\\n            }\\n\\n            if(table.get(key) == frequency && key < result)\\n               result = key;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259500,
                "title": "one-linear-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar mostFrequentEven = function(nums) {\\n    return Number(\\n        Object.entries(\\n            nums.reduce((acc, num) => {\\n                if (num % 2 === 0) {\\n                    acc[num] = (acc[num] ?? 0) + 1;\\n                }\\n\\n                return acc;\\n            }, {}),\\n        ).sort(([num1, fr1], [num2, fr2]) => {\\n            if (fr1 !== fr2) {\\n                return fr2 - fr1;\\n            }\\n\\n            return num1 - num2;\\n        })[0]?.[0] ?? -1,\\n    );\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar mostFrequentEven = function(nums) {\\n    return Number(\\n        Object.entries(\\n            nums.reduce((acc, num) => {\\n                if (num % 2 === 0) {\\n                    acc[num] = (acc[num] ?? 0) + 1;\\n                }\\n\\n                return acc;\\n            }, {}),\\n        ).sort(([num1, fr1], [num2, fr2]) => {\\n            if (fr1 !== fr2) {\\n                return fr2 - fr1;\\n            }\\n\\n            return num1 - num2;\\n        })[0]?.[0] ?? -1,\\n    );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3059676,
                "title": "very-easy-cpp-solution-using-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                m[nums[i]]++;\\n            }\\n        }\\n        int ans=-1;\\n        int count=0;\\n        for(auto it:m)\\n        {\\n            if(count<it.second)\\n            {\\n                ans=it.first;\\n                count=it.second;\\n            }\\n            if(count==it.second)\\n            {\\n                ans=min(ans,it.first);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                m[nums[i]]++;\\n            }\\n        }\\n        int ans=-1;\\n        int count=0;\\n        for(auto it:m)\\n        {\\n            if(count<it.second)\\n            {\\n                ans=it.first;\\n                count=it.second;\\n            }\\n            if(count==it.second)\\n            {\\n                ans=min(ans,it.first);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046484,
                "title": "easy-c-solution-with-explanation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int>m;\\n        for(auto x:nums){ //inserted all the even no. with there frequency in a map\\n           if(x%2==0)\\n           m[x]++;\\n        }\\n        if(m.size()==0)// if map is empty return -1\\n         return -1;\\n        int max=0,a=0;\\n        for(auto x:m){   //return the maximum frequency even no. as it sorted so minimum value no. will be returned\\n            if(x.second>max){\\n                max = x.second;\\n                a = x.first;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int>m;\\n        for(auto x:nums){ //inserted all the even no. with there frequency in a map\\n           if(x%2==0)\\n           m[x]++;\\n        }\\n        if(m.size()==0)// if map is empty return -1\\n         return -1;\\n        int max=0,a=0;\\n        for(auto x:m){   //return the maximum frequency even no. as it sorted so minimum value no. will be returned\\n            if(x.second>max){\\n                max = x.second;\\n                a = x.first;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009486,
                "title": "easiest-code-ever",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        map<int , int> freq;\\n        for(auto x:nums){\\n            freq[x]++;\\n        }\\n        int evefreq=0,ans=-1;\\n        for(auto y:freq){\\n            if(y.first%2==0 && y.second> evefreq){\\n                ans=y.first;\\n                evefreq=y.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n = nums.size(),i;\\n        map<int , int> freq;\\n        for(auto x:nums){\\n            freq[x]++;\\n        }\\n        int evefreq=0,ans=-1;\\n        for(auto y:freq){\\n            if(y.first%2==0 && y.second> evefreq){\\n                ans=y.first;\\n                evefreq=y.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907341,
                "title": "easy-to-understand-c-solution-using-maps",
                "content": "# Intuition\\nWe wanted to store count of each element for further reference so it was a question of hashmap\\n\\n# Approach\\nRan a for-loop to insert even element into map and created a \\'flag\\' variable to check whether an even element is present or not. If not, we directly return back -1 else, we compare the elements\\n\\n# Complexity\\n- Time complexity:\\n$$O(n+m)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n                if(nums[i]%2==0){\\n                    flag = true;\\n                    m[nums[i]]++;\\n                }\\n                }\\n\\n        if(flag==false){\\n            return -1;\\n        }\\n        \\n        int num =0;\\n        int numcounter = 0;\\n        for(auto it: m){\\n                if(it.second>numcounter){\\n                        num = it.first;\\n                        numcounter = it.second;\\n                }\\n\\n                if(it.second == numcounter){\\n                    if(it.first < num){\\n                        num = it.first;\\n                    }\\n                }\\n        }\\n\\n        return num;\\n\\n       \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        bool flag = false;\\n        for(int i=0; i<nums.size(); i++){\\n                if(nums[i]%2==0){\\n                    flag = true;\\n                    m[nums[i]]++;\\n                }\\n                }\\n\\n        if(flag==false){\\n            return -1;\\n        }\\n        \\n        int num =0;\\n        int numcounter = 0;\\n        for(auto it: m){\\n                if(it.second>numcounter){\\n                        num = it.first;\\n                        numcounter = it.second;\\n                }\\n\\n                if(it.second == numcounter){\\n                    if(it.first < num){\\n                        num = it.first;\\n                    }\\n                }\\n        }\\n\\n        return num;\\n\\n       \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844814,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst approach : Storing all the even numbers in the map and finding most occur one.\\n\\nSecond approach : Creating Max size Array and store all the freqs inside of it and return the most occur even one.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nBoth case : $$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nFirst Solution : $$O(n)$$\\nSecond Solution :$$O(m)$$ (m = biggest Number)\\n# Code\\nFirst\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        HashMap<Integer,Integer>numberCounts =new HashMap<>();\\n        int result=-1 ,maxFreq=-1;\\n        for(int num:nums)\\n            if(num%2==0)                    \\n                numberCounts.put(num,numberCounts.getOrDefault(num,0)+1);                                               \\n            \\n            \\n        for(Integer num:numberCounts.keySet()){      \\n            if(numberCounts.get(num)>maxFreq){\\n                maxFreq=numberCounts.get(num);\\n                result=num;\\n            }\\n            else if(numberCounts.get(num)==maxFreq && result>num)\\n                result=num;                        \\n                                \\n        }\\n        return result;\\n\\n    }\\n}\\n```\\n\\nSecond\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        int[] arr = new int[100001];\\n        int result = 1;\\n        for(int num : nums){\\n            if(num % 2 == 0){\\n                arr[num]++;\\n                if ( (arr[result] < arr[num]) || (arr[result] == arr[num] && result > num) ){\\n                    result = num;\\n                }\\n            }\\n        }\\n        return result == 1 ? -1 : result;\\n\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        HashMap<Integer,Integer>numberCounts =new HashMap<>();\\n        int result=-1 ,maxFreq=-1;\\n        for(int num:nums)\\n            if(num%2==0)                    \\n                numberCounts.put(num,numberCounts.getOrDefault(num,0)+1);                                               \\n            \\n            \\n        for(Integer num:numberCounts.keySet()){      \\n            if(numberCounts.get(num)>maxFreq){\\n                maxFreq=numberCounts.get(num);\\n                result=num;\\n            }\\n            else if(numberCounts.get(num)==maxFreq && result>num)\\n                result=num;                        \\n                                \\n        }\\n        return result;\\n\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        int[] arr = new int[100001];\\n        int result = 1;\\n        for(int num : nums){\\n            if(num % 2 == 0){\\n                arr[num]++;\\n                if ( (arr[result] < arr[num]) || (arr[result] == arr[num] && result > num) ){\\n                    result = num;\\n                }\\n            }\\n        }\\n        return result == 1 ? -1 : result;\\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798240,
                "title": "clean-concise-solution-hashmap",
                "content": "![image](https://assets.leetcode.com/users/images/8fdaa7cd-5c83-4cc1-adb0-80e6a79d8c45_1668046873.1513233.png)\\n\\n**Please upvote!**\\n```\\nint mostFrequentEven(vector<int>& nums) {\\n    unordered_map<int, int> counts;\\n    int ans = INT_MAX;\\n    for (int num : nums) {\\n        if (num % 2 == 0 && ++counts[num] >= counts[ans])\\n            ans = (counts[num] == counts[ans]) ? min(ans, num) : num;\\n    }\\n    return (ans == INT_MAX) ? -1 : ans;\\n}\\n```\\n**Please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint mostFrequentEven(vector<int>& nums) {\\n    unordered_map<int, int> counts;\\n    int ans = INT_MAX;\\n    for (int num : nums) {\\n        if (num % 2 == 0 && ++counts[num] >= counts[ans])\\n            ans = (counts[num] == counts[ans]) ? min(ans, num) : num;\\n    }\\n    return (ans == INT_MAX) ? -1 : ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2776682,
                "title": "js-very-easy-solution-o-n",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar mostFrequentEven = function(nums) {\\n    const hashmap = new Map();\\n    let output;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        const num = nums[i];\\n        if (!(num%2)) {\\n            const newValue = hashmap.get(num) + 1;\\n            hashmap.set(num, hashmap.has(num) ? newValue : 1);\\n            if (output === undefined || newValue > hashmap.get(output)) {\\n                output = num;\\n            } else if (hashmap.get(num) === hashmap.get(output)) {\\n                output = Math.min(num, output);\\n            }\\n        }\\n    }\\n\\n    return output === undefined ? -1 : output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar mostFrequentEven = function(nums) {\\n    const hashmap = new Map();\\n    let output;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        const num = nums[i];\\n        if (!(num%2)) {\\n            const newValue = hashmap.get(num) + 1;\\n            hashmap.set(num, hashmap.has(num) ? newValue : 1);\\n            if (output === undefined || newValue > hashmap.get(output)) {\\n                output = num;\\n            } else if (hashmap.get(num) === hashmap.get(output)) {\\n                output = Math.min(num, output);\\n            }\\n        }\\n    }\\n\\n    return output === undefined ? -1 : output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734572,
                "title": "easy-soution",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int>mp;\\n        int count=0,maxi=0,res;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2!=0)\\n                count++;\\n            else\\n            {\\n                mp[nums[i]]++;\\n            }\\n        }\\n        if(count==nums.size())\\n            return -1;\\n        for(auto it:mp)\\n        {\\n            if(it.second>maxi){\\n                res=it.first;\\n                maxi=it.second;\\n            }\\n        }\\n        return res;\\n    }\\n};\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int>mp;\\n        int count=0,maxi=0,res;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]%2!=0)\\n                count++;\\n            else\\n            {\\n                mp[nums[i]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2724378,
                "title": "easy-to-understand-c",
                "content": "class Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n      unordered_map<int,int>y;\\n        for(auto it:nums){\\n            if(it%2==0){\\n                y[it]++;\\n            }\\n        }\\n        int w=0,s=-1;\\n        for(auto it:y){\\n            if(it.second>w){\\n                  w=it.second;\\n            s=it.first;\\n            }\\n            if(it.second==w){\\n                if(it.first<s){\\n                    s=it.first;\\n                }\\n            }\\n        }\\n   return s; }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n      unordered_map<int,int>y;\\n        for(auto it:nums){\\n            if(it%2==0){\\n                y[it]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2665504,
                "title": "c-solution-hashing-brute-force",
                "content": "**SOLVED USING BRUTE FORCE APPROACH and HASHING** \\n\\n```\\n/** 2404. MOST FREQUENT EVEN ELEMENT **/\\n\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n\\t    int ans = -1;\\n\\t\\t\\n\\t\\t//vector to find the maximum frequency of the elements\\n        vector<int> findMax;\\n\\t\\t\\n\\t\\t//vector to store the frequency of even numbers only\\n        vector<int> even;\\n\\t\\t\\n\\t\\t//hashing\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]%2==0){\\n            mp[nums[i]]++;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//finding maximum frequency\\n        int max=0;\\n        for(auto i: mp){\\n           findMax.push_back(i.second); \\n        }\\n\\t\\t\\n\\t\\t//if there is no even number in the array then its frequency will also be null hence return -1\\n        if(findMax.size()==0) return ans;\\n\\t\\t\\n        sort(findMax.begin(),findMax.end());\\n        max=findMax[findMax.size()-1];\\n\\t\\t\\n\\t\\t\\n\\t\\t//as we need to return the even number with max frequency , hence store only those numbers \\n\\t\\t// whose frequency is equal to max\\n        for(auto i:mp){\\n            if(i.second==max){\\n                even.push_back(i.first);\\n            }\\n        }\\n\\t\\t\\n\\t\\t//sorting the even numbers because if the frequency of any number of elements is same \\n\\t\\t// then we need to return the smallest among those \\n        sort(even.begin(),even.end());\\n       \\n        if(even.size()>=1) return even[0];\\n        else  return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/** 2404. MOST FREQUENT EVEN ELEMENT **/\\n\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n\\t    int ans = -1;\\n\\t\\t\\n\\t\\t//vector to find the maximum frequency of the elements\\n        vector<int> findMax;\\n\\t\\t\\n\\t\\t//vector to store the frequency of even numbers only\\n        vector<int> even;\\n\\t\\t\\n\\t\\t//hashing\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<nums.size();++i){\\n            if(nums[i]%2==0){\\n            mp[nums[i]]++;\\n            }\\n        }\\n\\t\\t\\n\\t\\t//finding maximum frequency\\n        int max=0;\\n        for(auto i: mp){\\n           findMax.push_back(i.second); \\n        }\\n\\t\\t\\n\\t\\t//if there is no even number in the array then its frequency will also be null hence return -1\\n        if(findMax.size()==0) return ans;\\n\\t\\t\\n        sort(findMax.begin(),findMax.end());\\n        max=findMax[findMax.size()-1];\\n\\t\\t\\n\\t\\t\\n\\t\\t//as we need to return the even number with max frequency , hence store only those numbers \\n\\t\\t// whose frequency is equal to max\\n        for(auto i:mp){\\n            if(i.second==max){\\n                even.push_back(i.first);\\n            }\\n        }\\n\\t\\t\\n\\t\\t//sorting the even numbers because if the frequency of any number of elements is same \\n\\t\\t// then we need to return the smallest among those \\n        sort(even.begin(),even.end());\\n       \\n        if(even.size()>=1) return even[0];\\n        else  return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639769,
                "title": "faster-than-100-00-of-typescript-online-submissions-using-hashmap",
                "content": "```\\nfunction mostFrequentEven(nums: number[]): number {\\n    if (nums.length === 0) return -1\\n    \\n    // in state we store the frequency of each number\\n    const state = new Map()\\n    let maxfrequency = 0\\n    let mostFrequentNum = -1\\n    \\n    for (const num of nums) {\\n        // skip odd number\\n        if (num % 2 !== 0) continue\\n        \\n        // extract current num\\'s frequency (0 by default)\\n        const frequency = (state.get(num) ?? 0) + 1\\n        // set incremented frequency in state\\n        state.set(num, frequency)\\n        // If there is a tie, return the smallest one\\n        if (frequency === maxfrequency) {\\n            if (num < mostFrequentNum) {\\n                mostFrequentNum = num\\n            }\\n        }\\n        // if current num\\'s frequncy is greater then replace the mostFrequentNum by num\\n        if (frequency > maxfrequency) {\\n            maxfrequency = frequency\\n            mostFrequentNum = num\\n        }\\n    }\\n    \\n    return mostFrequentNum\\n};\\n\\n*Runtime: 84 ms*\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction mostFrequentEven(nums: number[]): number {\\n    if (nums.length === 0) return -1\\n    \\n    // in state we store the frequency of each number\\n    const state = new Map()\\n    let maxfrequency = 0\\n    let mostFrequentNum = -1\\n    \\n    for (const num of nums) {\\n        // skip odd number\\n        if (num % 2 !== 0) continue\\n        \\n        // extract current num\\'s frequency (0 by default)\\n        const frequency = (state.get(num) ?? 0) + 1\\n        // set incremented frequency in state\\n        state.set(num, frequency)\\n        // If there is a tie, return the smallest one\\n        if (frequency === maxfrequency) {\\n            if (num < mostFrequentNum) {\\n                mostFrequentNum = num\\n            }\\n        }\\n        // if current num\\'s frequncy is greater then replace the mostFrequentNum by num\\n        if (frequency > maxfrequency) {\\n            maxfrequency = frequency\\n            mostFrequentNum = num\\n        }\\n    }\\n    \\n    return mostFrequentNum\\n};\\n\\n*Runtime: 84 ms*\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2585120,
                "title": "hashmap-counter-simple-4-line-code",
                "content": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        nums.sort()\\n        a=Counter(nums).most_common()\\n        a.sort(key=lambda x:-x[1])\\n        for i in range(len(a)):\\n            if a[i][0]%2==0:\\n                return a[i][0]\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        nums.sort()\\n        a=Counter(nums).most_common()\\n        a.sort(key=lambda x:-x[1])\\n        for i in range(len(a)):\\n            if a[i][0]%2==0:\\n                return a[i][0]\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572274,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        Arrays.sort(nums);\\n\\t\\t\\n\\t\\t//Creating the frequency map i.e. keeping track of occurrence of each element\\n\\t\\t\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n            }else{\\n                map.put(nums[i], 1);\\n            }\\n        }\\n\\t\\t\\n\\t\\t//Checking for the occurrences of even no.s and checking which of the even no. in the array has occurred the most\\n\\t\\t\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] % 2 == 0){\\n                if(map.get(nums[i]) > max){\\n                    max = map.get(nums[i]);\\n                }\\n            }\\n            \\n        }\\n        \\n\\t\\t// Checking for the number that has occured maximum no. of times and which is also an even no.\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] % 2 == 0 && map.get(nums[i]) == max){\\n                return nums[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        Arrays.sort(nums);\\n\\t\\t\\n\\t\\t//Creating the frequency map i.e. keeping track of occurrence of each element\\n\\t\\t\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])){\\n                map.put(nums[i], map.get(nums[i]) + 1);\\n            }else{\\n                map.put(nums[i], 1);\\n            }\\n        }\\n\\t\\t\\n\\t\\t//Checking for the occurrences of even no.s and checking which of the even no. in the array has occurred the most\\n\\t\\t\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] % 2 == 0){\\n                if(map.get(nums[i]) > max){\\n                    max = map.get(nums[i]);\\n                }\\n            }\\n            \\n        }\\n        \\n\\t\\t// Checking for the number that has occured maximum no. of times and which is also an even no.\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] % 2 == 0 && map.get(nums[i]) == max){\\n                return nums[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568525,
                "title": "easy-python",
                "content": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        c ={}\\n        for i in nums:\\n            if i%2==0:\\n                if i in c:\\n                    c[i]+=1\\n                else:\\n                    c[i]=1\\n        if len(c)==0:\\n            return -1\\n        max_ = max(c.values())\\n        ans=999999\\n        for i in c:\\n            if c[i]==max_:\\n                ans = min(i,ans)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        c ={}\\n        for i in nums:\\n            if i%2==0:\\n                if i in c:\\n                    c[i]+=1\\n                else:\\n                    c[i]=1\\n        if len(c)==0:\\n            return -1\\n        max_ = max(c.values())\\n        ans=999999\\n        for i in c:\\n            if c[i]==max_:\\n                ans = min(i,ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567659,
                "title": "java-hashmap",
                "content": "\\tclass Solution {\\n\\t\\tpublic int mostFrequentEven(int[] nums) {\\n\\t\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\t\\tint res=-1; \\n\\t\\t\\tmap.put(res, 0);\\n\\t\\t\\tfor(int i=0; i<nums.length; ++i){\\n\\t\\t\\t\\tif(nums[i]%2==0){\\n\\t\\t\\t\\t\\tmap.put(nums[i], map.getOrDefault(nums[i], 0)+1); \\n\\t\\t\\t\\t\\tif(map.get(nums[i]) > map.get(res) || map.get(nums[i]) == map.get(res) && nums[i] < res)\\n\\t\\t\\t\\t\\t\\tres = nums[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res; \\n\\t\\t}\\n\\t}\\n\\n\\t// Time O(n)\\n\\t// Space O(n)",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int mostFrequentEven(int[] nums) {\\n\\t\\t\\tHashMap<Integer, Integer> map = new HashMap<>();\\n\\t\\t\\tint res=-1; \\n\\t\\t\\tmap.put(res, 0);\\n\\t\\t\\tfor(int i=0; i<nums.length; ++i){\\n\\t\\t\\t\\tif(nums[i]%2==0){\\n\\t\\t\\t\\t\\tmap.put(nums[i], map.getOrDefault(nums[i], 0)+1); \\n\\t\\t\\t\\t\\tif(map.get(nums[i]) > map.get(res) || map.get(nums[i]) == map.get(res) && nums[i] < res)\\n\\t\\t\\t\\t\\t\\tres = nums[i];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2560816,
                "title": "java-solution-using-hashmap-and-sorting",
                "content": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        Map<Integer,Integer> nm=new HashMap<>();\\n        for(int i:nums)\\n        {\\n            if(i%2==0)\\n            {\\n                nm.put(i, nm.getOrDefault(i,0)+1);\\n            }\\n        }\\n        if(nm.size()==0)\\n            return -1;\\n        List<Map.Entry<Integer,Integer>> kk=new ArrayList<>(nm.entrySet());\\n        Collections.sort(kk, new Comparator<Map.Entry<Integer,Integer>>(){\\n            public int compare(Map.Entry<Integer,Integer> e1, Map.Entry<Integer,Integer> e2)\\n            {\\n                if(e2.getValue()==e1.getValue())\\n                {\\n                    return e1.getKey()-e2.getKey();\\n                }\\n                else\\n                {\\n                    return e2.getValue()-e1.getValue();\\n                }\\n            }\\n        });\\n        for(Map.Entry<Integer,Integer> k:kk)\\n        {\\n            if(k.getKey()%2==0)\\n            {\\n                return k.getKey();\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        Map<Integer,Integer> nm=new HashMap<>();\\n        for(int i:nums)\\n        {\\n            if(i%2==0)\\n            {\\n                nm.put(i, nm.getOrDefault(i,0)+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2560389,
                "title": "c-using-map-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int> m;\\n        for(auto &it:nums)\\n        {\\n            if(it%2==0)\\n                m[it]++;\\n        }\\n        int c=0,ans=-1;\\n        for(auto &it:m)\\n        {\\n            if(it.second>c)\\n            {\\n                ans=it.first;\\n                c=it.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int> m;\\n        for(auto &it:nums)\\n        {\\n            if(it%2==0)\\n                m[it]++;\\n        }\\n        int c=0,ans=-1;\\n        for(auto &it:m)\\n        {\\n            if(it.second>c)\\n            {\\n                ans=it.first;\\n                c=it.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560360,
                "title": "c-unordered-map-very-simple-and-intuitive-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n\\t\\t//push everything into the map\\n        for(auto i:nums) mp[i]++;\\n        \\n        int maxi = -1, max_element=-1;\\n        \\n        for(auto i:mp){\\n            \\n\\t\\t\\t//to handle the case where we have to take the minimum of two elements if have the same number of times if a number is occuring\\n            if(i.second==maxi and i.first%2==0)\\n                max_element = min(max_element, i.first);\\n            \\n\\t\\t\\t//if some element has more number of occurences than our previous max\\n            if(i.second>maxi and i.first%2==0)\\n                max_element=i.first, maxi=i.second;\\n        }\\n        \\n        \\n        return max_element;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        \\n        unordered_map<int,int> mp;\\n        \\n\\t\\t//push everything into the map\\n        for(auto i:nums) mp[i]++;\\n        \\n        int maxi = -1, max_element=-1;\\n        \\n        for(auto i:mp){\\n            \\n\\t\\t\\t//to handle the case where we have to take the minimum of two elements if have the same number of times if a number is occuring\\n            if(i.second==maxi and i.first%2==0)\\n                max_element = min(max_element, i.first);\\n            \\n\\t\\t\\t//if some element has more number of occurences than our previous max\\n            if(i.second>maxi and i.first%2==0)\\n                max_element=i.first, maxi=i.second;\\n        }\\n        \\n        \\n        return max_element;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560306,
                "title": "beats-100",
                "content": "```\\nfunc mostFrequentEven(nums []int) int {\\n    res, maxFreq := -1, -1<<31\\n    \\n    frequency := make(map[int]int)\\n    \\n    for _, num := range nums {\\n        if num%2 == 0 {\\n            frequency[num]++\\n        }\\n    }\\n\\n    for num, freq := range frequency {\\n        if freq >= maxFreq {\\n            if freq == maxFreq {\\n                res = min(res, num)\\n            } else {\\n                res = num\\n            }\\n            \\n            maxFreq = freq\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mostFrequentEven(nums []int) int {\\n    res, maxFreq := -1, -1<<31\\n    \\n    frequency := make(map[int]int)\\n    \\n    for _, num := range nums {\\n        if num%2 == 0 {\\n            frequency[num]++\\n        }\\n    }\\n\\n    for num, freq := range frequency {\\n        if freq >= maxFreq {\\n            if freq == maxFreq {\\n                res = min(res, num)\\n            } else {\\n                res = num\\n            }\\n            \\n            maxFreq = freq\\n        }\\n    }\\n    \\n    return res\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2560165,
                "title": "easy-clear-solution-python3",
                "content": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        ccc = collections.Counter(nums)\\n        mxe=-1\\n        mx=0\\n        for i in ccc.keys():\\n            if ccc[i]>mx and i%2==0:\\n                mx=ccc[i]\\n                mxe=i\\n            if ccc[i]==mx and i%2==0:\\n                if i<mxe:\\n                    mxe=i\\n        return mxe\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        ccc = collections.Counter(nums)\\n        mxe=-1\\n        mx=0\\n        for i in ccc.keys():\\n            if ccc[i]>mx and i%2==0:\\n                mx=ccc[i]\\n                mxe=i\\n            if ccc[i]==mx and i%2==0:\\n                if i<mxe:\\n                    mxe=i\\n        return mxe\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096638,
                "title": "python-simple-code-97-6-beats-hashmap",
                "content": "**If you got help from this,... Plz Upvote .. it encourage me**\\n\\nHashMap Solution:\\n# Code\\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d = {}\\n        for ele in nums:\\n            if ele%2 == 0:\\n                d[ele] = d.get(ele,0) + 1\\n\\n        if not d:\\n            return -1\\n\\n        maxv = max(d.values())\\n\\n        return min([ele for ele in d if d[ele] == maxv])\\n        # Or\\n        maxe = [ele for ele in d if d[ele] == maxv]\\n        return min(maxe)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d = {}\\n        for ele in nums:\\n            if ele%2 == 0:\\n                d[ele] = d.get(ele,0) + 1\\n\\n        if not d:\\n            return -1\\n\\n        maxv = max(d.values())\\n\\n        return min([ele for ele in d if d[ele] == maxv])\\n        # Or\\n        maxe = [ele for ele in d if d[ele] == maxv]\\n        return min(maxe)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058216,
                "title": "98-runtime-98-memory-o-n-o-n-fast-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/18523e29-bd4b-43c5-b4c8-6c908eabea90_1695011251.9115882.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d, max, res = {}, 0, -1; d_get = d.get\\n\\n        for n in nums: \\n            if n % 2 == 0: d[n] = d_get(n,0) + 1\\n        \\n        for num, count in d.items():\\n            if count >= max:\\n                if count > max: max = count; res = num\\n                else: res = min(num, res)\\n\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d, max, res = {}, 0, -1; d_get = d.get\\n\\n        for n in nums: \\n            if n % 2 == 0: d[n] = d_get(n,0) + 1\\n        \\n        for num, count in d.items():\\n            if count >= max:\\n                if count > max: max = count; res = num\\n                else: res = min(num, res)\\n\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001689,
                "title": "simplest-approach-in-python-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe code first filters out the even numbers from the input list and stores them in the even list. Then, it counts the frequency of each even number using a Counter and iterates through the even list to find the even number with the highest frequency.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize an empty list even to store even numbers.\\n\\nIterate through the input list nums, and for each element i, check if it is even (i.e., i % 2 == 0). If it is even, add it to the even list.\\n\\nIf the even list is empty, it means there are no even numbers in the input list, so return -1.\\n\\nSort the even list in ascending order.\\n\\nUse the Counter class to count the frequency of each element in the even list and store the result in the ec variable.\\n\\nIterate through the even list again. For each element i, check if its frequency in ec (ec[i]) is equal to the maximum frequency among all elements in ec (max(ec.values())). If it is, return i as the most frequent even number.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nOverall, the time complexity is O(n + k * log(k)).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(k), where k is the number of even elements in nums.\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def mostFrequentEven(self, nums):\\n        # Initialize an empty list to store even numbers\\n        even = []\\n        \\n        # Iterate through the input list to filter even numbers\\n        for i in nums:\\n            if i % 2 == 0:\\n                even.append(i)\\n        \\n        # If there are no even numbers, return -1\\n        if not even:\\n            return -1\\n        \\n        # Sort the even numbers\\n        even = sorted(even)\\n        \\n        # Count the frequency of each even number\\n        ec = Counter(even)\\n        \\n        # Iterate through even numbers to find the most frequent one\\n        for i in even:\\n            if ec[i] == max(ec.values()):\\n                return i\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution(object):\\n    def mostFrequentEven(self, nums):\\n        # Initialize an empty list to store even numbers\\n        even = []\\n        \\n        # Iterate through the input list to filter even numbers\\n        for i in nums:\\n            if i % 2 == 0:\\n                even.append(i)\\n        \\n        # If there are no even numbers, return -1\\n        if not even:\\n            return -1\\n        \\n        # Sort the even numbers\\n        even = sorted(even)\\n        \\n        # Count the frequency of each even number\\n        ec = Counter(even)\\n        \\n        # Iterate through even numbers to find the most frequent one\\n        for i in even:\\n            if ec[i] == max(ec.values()):\\n                return i\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735920,
                "title": "simple-easy-to-understand-solution-using-hashmap-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        int maxFreq = 0;\\n        int element = Integer.MAX_VALUE;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]%2==0){\\n                int curr = map.getOrDefault(nums[i],0)+1;\\n                map.put(nums[i],curr);\\n                if(curr > maxFreq  || (curr == maxFreq && nums[i]<element)){\\n                    maxFreq = curr;\\n                    element = nums[i];\\n                }\\n            }\\n        }\\n\\n        return maxFreq==0 ? -1 : element;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n\\n        int maxFreq = 0;\\n        int element = Integer.MAX_VALUE;\\n        \\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]%2==0){\\n                int curr = map.getOrDefault(nums[i],0)+1;\\n                map.put(nums[i],curr);\\n                if(curr > maxFreq  || (curr == maxFreq && nums[i]<element)){\\n                    maxFreq = curr;\\n                    element = nums[i];\\n                }\\n            }\\n        }\\n\\n        return maxFreq==0 ? -1 : element;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607538,
                "title": "worst-ugly-and-bad-code-in-kotlin",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun mostFrequentEven(nums: IntArray): Int {\\n        val hm = HashMap<Int, Int>()\\n        var max = 0\\n        var small = Int.MAX_VALUE\\n\\n        if (nums.size == 1) {\\n            if (nums[0]%2 == 0) return nums[0]\\n            else return -1\\n        }\\n\\n        for (i in 0 until nums.size) {\\n            if (nums[i] % 2 == 0) {\\n                hm[nums[i]] = hm.getOrDefault(nums[i], 0) + 1\\n                if (hm[nums[i]]!! > max) {\\n                    max = hm[nums[i]]!!\\n                }\\n            }\\n        }\\n\\n        for ((key, value) in hm) {\\n            if (value == max && key < small) {\\n                small = key\\n            }\\n        }\\n\\n        return if (small == Int.MAX_VALUE) -1 else small\\n\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun mostFrequentEven(nums: IntArray): Int {\\n        val hm = HashMap<Int, Int>()\\n        var max = 0\\n        var small = Int.MAX_VALUE\\n\\n        if (nums.size == 1) {\\n            if (nums[0]%2 == 0) return nums[0]\\n            else return -1\\n        }\\n\\n        for (i in 0 until nums.size) {\\n            if (nums[i] % 2 == 0) {\\n                hm[nums[i]] = hm.getOrDefault(nums[i], 0) + 1\\n                if (hm[nums[i]]!! > max) {\\n                    max = hm[nums[i]]!!\\n                }\\n            }\\n        }\\n\\n        for ((key, value) in hm) {\\n            if (value == max && key < small) {\\n                small = key\\n            }\\n        }\\n\\n        return if (small == Int.MAX_VALUE) -1 else small\\n\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512453,
                "title": "easy-c-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int, int> elemFrequency;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2 == 0)\\n            {\\n                elemFrequency[nums[i]]++;\\n            }\\n        }\\n        int maxFrequency=INT_MIN;\\n        int res=-1;\\n        for(auto x:elemFrequency)\\n        {   \\n            if(maxFrequency == x.second)\\n            {\\n                res=min(x.first, res);\\n            }\\n            if(maxFrequency<x.second)\\n            {\\n                res=x.first;\\n                maxFrequency=x.second;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n=nums.size();\\n        unordered_map<int, int> elemFrequency;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2 == 0)\\n            {\\n                elemFrequency[nums[i]]++;\\n            }\\n        }\\n        int maxFrequency=INT_MIN;\\n        int res=-1;\\n        for(auto x:elemFrequency)\\n        {   \\n            if(maxFrequency == x.second)\\n            {\\n                res=min(x.first, res);\\n            }\\n            if(maxFrequency<x.second)\\n            {\\n                res=x.first;\\n                maxFrequency=x.second;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243496,
                "title": "simple-and-quick",
                "content": "Explanation: We will go through the nums list. Ignore the odd numbers. Capture the freq of even numbers. At every iteration keep checking if current num\\'s freq is greater than the max freq. \\nIf so update the max freq and max element. Also, If current freq is same as max freq then update the max element as the smaller number between current num and max elements.\\n\\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        freqMap = {}\\n        maxFreq = -math.inf\\n        maxFreqElement = -1\\n        \\n        for num in nums:\\n            if num & 1:\\n                continue\\n            if num in freqMap:\\n                freqMap[num] += 1\\n            else:\\n                freqMap[num] = 1\\n            \\n            if freqMap[num] > maxFreq:\\n                maxFreq = freqMap[num]\\n                maxFreqElement = num\\n            \\n            if freqMap[num] == maxFreq:\\n                maxFreqElement = min(maxFreqElement, num)\\n                \\n        return maxFreqElement\\n```\\n\\nWe can also use bucket sort for this. This is just for the sake of completion. \\n\\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        freqMap = {}\\n        N = len(nums)\\n        for num in nums:\\n            if num & 1:\\n                continue\\n            if num in freqMap:\\n                freqMap[num] += 1\\n            else:\\n                freqMap[num] = 1\\n        \\n        bucket = [[] for i in range(N+1)]\\n        \\n        for key in freqMap:\\n            bucket[freqMap[key]].append(key)\\n        \\n        for i in range(len(bucket)-1, -1, -1):\\n            if bucket[i]:\\n                minimun = bucket[i][0]\\n                for val in bucket[i]:\\n                    minimun = min(minimun, val)\\n                return minimun\\n        \\n        return -1\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        freqMap = {}\\n        maxFreq = -math.inf\\n        maxFreqElement = -1\\n        \\n        for num in nums:\\n            if num & 1:\\n                continue\\n            if num in freqMap:\\n                freqMap[num] += 1\\n            else:\\n                freqMap[num] = 1\\n            \\n            if freqMap[num] > maxFreq:\\n                maxFreq = freqMap[num]\\n                maxFreqElement = num\\n            \\n            if freqMap[num] == maxFreq:\\n                maxFreqElement = min(maxFreqElement, num)\\n                \\n        return maxFreqElement\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180133,
                "title": "easy-to-understand-clear-code-c",
                "content": "\\n\\n# Approach\\nWe create the map and store the nums and its frequency of element and return the maximum frequency element.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n    \\n    map<int ,int >mp;\\n\\n    for (auto n : nums) mp[n]++;\\n    int ans = -1 ,max = INT_MIN;\\n\\n    for(auto m: mp) {\\n       if(m.first%2==0 && m.second>max){\\n           ans= m.first;\\n           max= m.second;\\n       }\\n    }\\n    return ans;\\n   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n    \\n    map<int ,int >mp;\\n\\n    for (auto n : nums) mp[n]++;\\n    int ans = -1 ,max = INT_MIN;\\n\\n    for(auto m: mp) {\\n       if(m.first%2==0 && m.second>max){\\n           ans= m.first;\\n           max= m.second;\\n       }\\n    }\\n    return ans;\\n   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3161852,
                "title": "ruby-from-junior-delete-odds-sort-tally-delete-not-max-return-first",
                "content": "\\n\\n# Code\\n```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef most_frequent_even(nums)\\n    ha = nums.delete_if { | item | item.odd? }.sort.tally\\n    return -1 if ha.size == 0\\n\\n    ma = ha.values.max\\n    h = ha.delete_if { |k,v| v != ma}\\n    h.keys[0]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef most_frequent_even(nums)\\n    ha = nums.delete_if { | item | item.odd? }.sort.tally\\n    return -1 if ha.size == 0\\n\\n    ma = ha.values.max\\n    h = ha.delete_if { |k,v| v != ma}\\n    h.keys[0]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3078726,
                "title": "c-one-line-solution-linq",
                "content": "# Intuition\\nSame as some other solutions. Group Evens and take smallest number that is tied for the most. This can be slower due to sorting.\\n\\n# Approach\\n```?.``` and ```??``` help to reduce lines.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MostFrequentEven(int[] nums) {\\n        return nums.Where(x => x % 2 == 0).GroupBy(x => x).OrderByDescending(x => x.Count()).ThenBy(x => x.Key).FirstOrDefault()?.Key ?? -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Sort"
                ],
                "code": "```?.```\n```??```\n```\\npublic class Solution {\\n    public int MostFrequentEven(int[] nums) {\\n        return nums.Where(x => x % 2 == 0).GroupBy(x => x).OrderByDescending(x => x.Count()).ThenBy(x => x.Key).FirstOrDefault()?.Key ?? -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036241,
                "title": "c-easy-and-fast-using-map",
                "content": "# Intuition & Approach\\nuse a map not unordred one and store the keys being the no and values as their occurence. now iterate over the map to find the maximum value , ie the value of maximum occurence.\\nAgain iterate over the map and check is the occurence == maximum occuence (occurence is stored as value in map). if yes then equate ans as the key and break the solution...\\nedge point : since its a map (ordered_one) so you will definitely gets the smallest value at first instance \\n\\n# Complexity\\n- Time complexity:\\n O(nlogn)\\n\\n- Space complexity:\\n<!-- O(n) -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int mostFrequentEven(vector<int> &v)\\n    {\\n        map<int, int> m;\\n        // inserting the vlaues into the map with value being the count of the no\\n        for (int i = 0; i < v.size(); i++)\\n        {\\n            if (v[i] % 2 == 0)\\n                m[v[i]]++;\\n        }\\n        // to  find the max frequency\\n        int max_count = 0;\\n        int ans = -1;\\n        for (auto i : m)\\n        {\\n            if (max_count < i.second)\\n                max_count = i.second;\\n        }\\n        // to find the element which appears first with maximum count in map\\n        for (auto i : m)\\n        {\\n            if (i.second == max_count){\\n                ans = i.first;\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n<!-- its a request  -->\\n<!-- please upvote if u find it helpful & sorry for any typing mistakes\\uD83D\\uDE00 -->",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution\\n{\\npublic:\\n    int mostFrequentEven(vector<int> &v)\\n    {\\n        map<int, int> m;\\n        // inserting the vlaues into the map with value being the count of the no\\n        for (int i = 0; i < v.size(); i++)\\n        {\\n            if (v[i] % 2 == 0)\\n                m[v[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2967673,
                "title": "easy-o-n-java-solution-hashmap-beats-90-runtime-and-99-memory",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        HashMap<Integer, Integer> mp = new HashMap<>();\\n        int n = nums.length, max = Integer.MIN_VALUE, ans = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++) {\\n            if((nums[i]&1) == 0) {\\n                mp.put(nums[i], mp.getOrDefault(nums[i], 0) + 1);\\n                max = Math.max(max, mp.get(nums[i]));\\n            }\\n        }\\n        for(Map.Entry<Integer, Integer> el : mp.entrySet()) {\\n            if(el.getValue() == max) {\\n                ans = Math.min(ans, el.getKey());\\n            }\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        HashMap<Integer, Integer> mp = new HashMap<>();\\n        int n = nums.length, max = Integer.MIN_VALUE, ans = Integer.MAX_VALUE;\\n        for(int i = 0; i < n; i++) {\\n            if((nums[i]&1) == 0) {\\n                mp.put(nums[i], mp.getOrDefault(nums[i], 0) + 1);\\n                max = Math.max(max, mp.get(nums[i]));\\n            }\\n        }\\n        for(Map.Entry<Integer, Integer> el : mp.entrySet()) {\\n            if(el.getValue() == max) {\\n                ans = Math.min(ans, el.getKey());\\n            }\\n        }\\n        return ans == Integer.MAX_VALUE ? -1 : ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943139,
                "title": "easy-solution-using-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums)\\n    {\\n       map<int,int>m;\\n       long int c=0;\\n       int el=-1;\\n       for(int i=0; i<nums.size(); i++)\\n       {\\n           m[nums[i]]++;\\n       }\\n       for(auto it:m)\\n       {\\n           if(it.first%2==0 && c<it.second)\\n           {\\n               el=it.first;\\n               c=it.second;\\n           }\\n       }\\n       return el;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums)\\n    {\\n       map<int,int>m;\\n       long int c=0;\\n       int el=-1;\\n       for(int i=0; i<nums.size(); i++)\\n       {\\n           m[nums[i]]++;\\n       }\\n       for(auto it:m)\\n       {\\n           if(it.first%2==0 && c<it.second)\\n           {\\n               el=it.first;\\n               c=it.second;\\n           }\\n       }\\n       return el;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2789881,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n=INT_MIN;\\n        int y=INT_MAX;\\n        unordered_map<int,int>nit;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n                nit[nums[i]]++;\\n        }\\n        for(auto i=nit.begin();i!=nit.end();i++)\\n        {\\n            if(i->second==n)\\n                y=min(y,i->first);\\n            else if(i->second>n)\\n            {\\n                n=i->second;\\n                y=i->first;\\n            }\\n        }\\n        if(y==INT_MAX)\\n            return -1;\\n        \\n            return y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n=INT_MIN;\\n        int y=INT_MAX;\\n        unordered_map<int,int>nit;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]%2==0)\\n                nit[nums[i]]++;\\n        }\\n        for(auto i=nit.begin();i!=nit.end();i++)\\n        {\\n            if(i->second==n)\\n                y=min(y,i->first);\\n            else if(i->second>n)\\n            {\\n                n=i->second;\\n                y=i->first;\\n            }\\n        }\\n        if(y==INT_MAX)\\n            return -1;\\n        \\n            return y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724350,
                "title": "c-easy-solution-map-beginners-friendly-easy-to-understand",
                "content": "**Do Up Vote if you Like The Solution !!**\\n\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int res = -1 , count = 0;\\n        map<int,int> mp;\\n        for(auto it : nums)\\n            mp[it]++;\\n        for(auto it : mp){\\n            if(it.first%2==0){\\n                if(it.second>count){\\n                count = max(count,it.second);\\n                res = it.first;\\n            }\\n          }\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int res = -1 , count = 0;\\n        map<int,int> mp;\\n        for(auto it : nums)\\n            mp[it]++;\\n        for(auto it : mp){\\n            if(it.first%2==0){\\n                if(it.second>count){\\n                count = max(count,it.second);\\n                res = it.first;\\n            }\\n          }\\n        }\\n        return res ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701655,
                "title": "python3-solution-hashmap-faster-than-93-33",
                "content": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        hashTable = {}\\n        maximumFrecuency = -inf\\n        valueWithMaximumFrecuency = -1\\n        for number in nums:\\n            if (not number in hashTable and number % 2 == 0):\\n                hashTable[number] = 1\\n            elif (number % 2 == 0):\\n                hashTable[number] += 1\\n                \\n            if (number % 2 == 0 and hashTable[number] > maximumFrecuency):\\n                maximumFrecuency = hashTable[number]\\n                valueWithMaximumFrecuency = number\\n            elif (number % 2 == 0 and hashTable[number] == maximumFrecuency and number < valueWithMaximumFrecuency):\\n                valueWithMaximumFrecuency = number\\n        \\n        return valueWithMaximumFrecuency\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        hashTable = {}\\n        maximumFrecuency = -inf\\n        valueWithMaximumFrecuency = -1\\n        for number in nums:\\n            if (not number in hashTable and number % 2 == 0):\\n                hashTable[number] = 1\\n            elif (number % 2 == 0):\\n                hashTable[number] += 1\\n                \\n            if (number % 2 == 0 and hashTable[number] > maximumFrecuency):\\n                maximumFrecuency = hashTable[number]\\n                valueWithMaximumFrecuency = number\\n            elif (number % 2 == 0 and hashTable[number] == maximumFrecuency and number < valueWithMaximumFrecuency):\\n                valueWithMaximumFrecuency = number\\n        \\n        return valueWithMaximumFrecuency\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666381,
                "title": "python-heapify-with-maxheap-faster-than-90",
                "content": "- create a dict of all even values and its occurrences\\n- create max heap ( standard way to create max heap is multiplying with -1 )\\n- return value of 1st element as 1st value of max heap is the smallest\\n\\n\\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        h = {}\\n        \\n        for i in nums:\\n            if i % 2 == 0:\\n                h[i] = h.get(i,0) + 1\\n        \\n        maxHeap = [[-freq, num] for num, freq in h.items()]\\n        heapify(maxHeap)\\n        \\n        return maxHeap[0][1] if maxHeap else -1",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        h = {}",
                "codeTag": "Java"
            },
            {
                "id": 2645440,
                "title": "python-easy-understanding",
                "content": "\\t def mostFrequentEven(self, nums: List[int]) -> int:\\n\\t\\t\\tcounter = Counter([i for i in nums if i % 2 == 0])\\n\\t\\t\\tprint(counter)\\n\\t\\t\\tif not counter:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\tres = {x: count for x, count in counter.items() if count == max(counter.values())}\\n\\t\\t\\tprint(res)\\n\\t\\t\\treturn min(res.keys())",
                "solutionTags": [],
                "code": "\\t def mostFrequentEven(self, nums: List[int]) -> int:\\n\\t\\t\\tcounter = Counter([i for i in nums if i % 2 == 0])\\n\\t\\t\\tprint(counter)\\n\\t\\t\\tif not counter:\\n\\t\\t\\t\\treturn -1\\n\\t\\t\\tres = {x: count for x, count in counter.items() if count == max(counter.values())}\\n\\t\\t\\tprint(res)\\n\\t\\t\\treturn min(res.keys())",
                "codeTag": "Python3"
            },
            {
                "id": 2622496,
                "title": "c-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n       \\tint freq=INT_MIN;\\n\\tint ele=INT_MAX;\\n    unordered_map<int,int>mp;\\n\\tfor(int i=0;i<nums.size();i++)        \\n\\t{\\n\\t\\tif((nums[i]%2)==0)\\n\\t\\t{\\n\\t\\t    mp[nums[i]]++;\\t\\n\\t\\t}\\n\\t}\\n\\tfor(auto it=mp.begin();it!=mp.end();it++)\\n\\t{\\n\\t\\tif(it->second==freq)\\n\\t\\t{\\n             ele=min(ele,it->first);\\n\\t\\t}\\n\\t\\telse if(it->second>freq)\\n\\t\\t{\\n\\t\\t\\tfreq=it->second;\\n\\t\\t\\tele=it->first;\\n\\t\\t}\\n\\t}\\n        if(ele==INT_MAX)\\n            return -1;\\n        \\n\\treturn ele; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n       \\tint freq=INT_MIN;\\n\\tint ele=INT_MAX;\\n    unordered_map<int,int>mp;\\n\\tfor(int i=0;i<nums.size();i++)        \\n\\t{\\n\\t\\tif((nums[i]%2)==0)\\n\\t\\t{\\n\\t\\t    mp[nums[i]]++;\\t\\n\\t\\t}\\n\\t}\\n\\tfor(auto it=mp.begin();it!=mp.end();it++)\\n\\t{\\n\\t\\tif(it->second==freq)\\n\\t\\t{\\n             ele=min(ele,it->first);\\n\\t\\t}\\n\\t\\telse if(it->second>freq)\\n\\t\\t{\\n\\t\\t\\tfreq=it->second;\\n\\t\\t\\tele=it->first;\\n\\t\\t}\\n\\t}\\n        if(ele==INT_MAX)\\n            return -1;\\n        \\n\\treturn ele; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619924,
                "title": "python-totally-basic-method",
                "content": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        hp = Counter(nums)\\n        keys = list(hp.keys())\\n        \\n        listx = []\\n        flag = False\\n        \\n        for u in keys:\\n            if not u & 1:\\n                flag = True\\n            listx.append([hp[u], u])\\n        \\n        if flag == False:return -1\\n        # SORTING BY VALUES\\n        listx.sort(reverse = True)\\n        \\n        max_freq = 0\\n        max_ele = 0\\n        \\n        for i in listx:\\n            if i[1]%2==0:\\n                max_freq = i[0]\\n                max_ele = i[1]\\n                break\\n        \\n        for k in listx:\\n            if k[1]%2==0 and k[0] == max_freq:\\n                max_ele = k[1]\\n                \\n        return max_ele",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        hp = Counter(nums)\\n        keys = list(hp.keys())\\n        \\n        listx = []\\n        flag = False\\n        \\n        for u in keys:\\n            if not u & 1:\\n                flag = True\\n            listx.append([hp[u], u])\\n        \\n        if flag == False:return -1\\n        # SORTING BY VALUES\\n        listx.sort(reverse = True)\\n        \\n        max_freq = 0\\n        max_ele = 0\\n        \\n        for i in listx:\\n            if i[1]%2==0:\\n                max_freq = i[0]\\n                max_ele = i[1]\\n                break\\n        \\n        for k in listx:\\n            if k[1]%2==0 and k[0] == max_freq:\\n                max_ele = k[1]\\n                \\n        return max_ele",
                "codeTag": "Java"
            },
            {
                "id": 2618062,
                "title": "java-using-array-faster-than-98-memory-better-than-98",
                "content": "```\\npublic int mostFrequentEven(int[] nums) {\\n        int count[] = new int[50001];\\n        int max = -1;\\n        for(int i: nums){\\n            if(i%2==0) {\\n                count[i/2]++;\\n                max = Math.max(max,count[i/2]);\\n            }\\n        }\\n        if(max==-1) return -1;\\n        int ans = 0;\\n        for(int i=50000;i>=0;i--){\\n            if(max==count[i]){\\n                ans = 2*i;\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\npublic int mostFrequentEven(int[] nums) {\\n        int count[] = new int[50001];\\n        int max = -1;\\n        for(int i: nums){\\n            if(i%2==0) {\\n                count[i/2]++;\\n                max = Math.max(max,count[i/2]);\\n            }\\n        }\\n        if(max==-1) return -1;\\n        int ans = 0;\\n        for(int i=50000;i>=0;i--){\\n            if(max==count[i]){\\n                ans = 2*i;\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2612277,
                "title": "python",
                "content": "```\\nclass Solution(object):\\n    def mostFrequentEven(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        evenNumsCounter = Counter([num for num in nums if not num % 2])\\n        if not evenNumsCounter: return -1\\n        nMaxCount = evenNumsCounter.most_common(1)[0][1]\\n        return min([ele for ele in evenNumsCounter if evenNumsCounter[ele] == nMaxCount])",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mostFrequentEven(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        evenNumsCounter = Counter([num for num in nums if not num % 2])\\n        if not evenNumsCounter: return -1\\n        nMaxCount = evenNumsCounter.most_common(1)[0][1]\\n        return min([ele for ele in evenNumsCounter if evenNumsCounter[ele] == nMaxCount])",
                "codeTag": "Java"
            },
            {
                "id": 2602395,
                "title": "javascript",
                "content": "```\\nvar mostFrequentEven = function(nums) {\\n    let map = {};\\n    for (let num of nums) {\\n        if (num % 2 === 0) {\\n            if (!map[num]) map[num] = 0;\\n            map[num]++;\\n        }\\n    }\\n    let arr = Object.keys(map).sort((a, b) => map[b] - map[a]).map(Number);\\n    if (arr.length === 0) return -1;\\n    let first = arr.shift();\\n    let second = arr.shift();\\n    // if the values are the same, choose the lower one\\n    if (first && second && map[second] === map[first] && first > second) {\\n        return second;\\n    }\\n    return first;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mostFrequentEven = function(nums) {\\n    let map = {};\\n    for (let num of nums) {\\n        if (num % 2 === 0) {\\n            if (!map[num]) map[num] = 0;\\n            map[num]++;\\n        }\\n    }\\n    let arr = Object.keys(map).sort((a, b) => map[b] - map[a]).map(Number);\\n    if (arr.length === 0) return -1;\\n    let first = arr.shift();\\n    let second = arr.shift();\\n    // if the values are the same, choose the lower one\\n    if (first && second && map[second] === map[first] && first > second) {\\n        return second;\\n    }\\n    return first;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2587024,
                "title": "java-collections-list",
                "content": "public int mostFrequentEven(int[] nums) {\\n        List<Integer> list=new ArrayList<>();\\n        int freq=0;\\n        int num=-1;\\n        for(Integer i:nums){\\n            if(i%2==0)\\n            list.add(i);\\n        }\\n        \\n        for(Integer i:list){\\n            int f=Collections.frequency(list,i);\\n           if(f>freq){\\n               num=i;\\n               freq=f;\\n           }\\n            \\n            else if(f==freq)\\n               num=num<i?num:i;\\n        }\\n        return num;\\n        \\n    }",
                "solutionTags": [],
                "code": "public int mostFrequentEven(int[] nums) {\\n        List<Integer> list=new ArrayList<>();\\n        int freq=0;\\n        int num=-1;\\n        for(Integer i:nums){\\n            if(i%2==0)\\n            list.add(i);\\n        }\\n        \\n        for(Integer i:list){\\n            int f=Collections.frequency(list,i);\\n           if(f>freq){\\n               num=i;\\n               freq=f;\\n           }\\n            \\n            else if(f==freq)\\n               num=num<i?num:i;\\n        }\\n        return num;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2575524,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        hash_dict = Counter(nums)\\n        ans = -1\\n        freq = 0\\n        for i in hash_dict:\\n            if i % 2 == 0:\\n                if hash_dict[i] > freq:\\n                    freq = hash_dict[i]\\n                    ans = i\\n                elif hash_dict[i] == freq and i < ans:\\n                    ans = i\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        hash_dict = Counter(nums)\\n        ans = -1\\n        freq = 0\\n        for i in hash_dict:\\n            if i % 2 == 0:\\n                if hash_dict[i] > freq:\\n                    freq = hash_dict[i]\\n                    ans = i\\n                elif hash_dict[i] == freq and i < ans:\\n                    ans = i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569534,
                "title": "beginner-friendly-code",
                "content": "\\n# **Beginner friendly code **\\n# Without using any special method \\n```\\nfrom collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        dict1=Counter(nums)\\n        max1=-1\\n        min1= 2147483647\\n        for i,k in dict1.items():\\n            if(i%2==0):\\n                if(k>max1):\\n                    max1=k\\n                    min1=i\\n                elif(k==max1):\\n                    if(i<min1):\\n                        min1=i\\n        if(min1==2147483647):\\n            return -1\\n        else:\\n            return min1\\n            \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n# **Beginner friendly code **\\n# Without using any special method \\n```\\nfrom collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        dict1=Counter(nums)\\n        max1=-1\\n        min1= 2147483647\\n        for i,k in dict1.items():\\n            if(i%2==0):\\n                if(k>max1):\\n                    max1=k\\n                    min1=i\\n                elif(k==max1):\\n                    if(i<min1):\\n                        min1=i\\n        if(min1==2147483647):\\n            return -1\\n        else:\\n            return min1\\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 2569297,
                "title": "shortest-easiest-code-c",
                "content": "class Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n=nums.size();\\n        map<int,int> m;\\n       \\n        for (auto i:nums)\\n            if(i%2 == 0)\\n                m[i]++;\\n        \\n        int maxm =0, res =-1;\\n       \\n        for(auto i:m)\\n         if(i.second>maxm)\\n            { maxm = i.second; res = i.first;}\\n                \\n        \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n=nums.size();\\n        map<int,int> m;\\n       \\n        for (auto i:nums)\\n            if(i%2 == 0)\\n                m[i]++;\\n        \\n        int maxm =0, res =-1;\\n       \\n        for(auto i:m)\\n         if(i.second>maxm)\\n            { maxm = i.second; res = i.first;}",
                "codeTag": "Java"
            },
            {
                "id": 2564127,
                "title": "python-o-n-solution",
                "content": "\\n\\tclass Solution:\\n\\t\\tdef mostFrequentEven(self, nums: List[int]) -> int:\\n\\t\\t\\tcount = collections.Counter(nums)\\n\\t\\t\\tmaxium = -1\\n\\t\\t\\tfreq = 0\\n\\t\\t\\tfor i, j in count.items():\\n\\t\\t\\t\\tif i%2==0 and ( j>freq or ( j == freq and maxium>i)):\\n\\t\\t\\t\\t\\tfreq= j\\n\\t\\t\\t\\t\\tmaxium = i\\n\\t\\t\\treturn maxium",
                "solutionTags": [],
                "code": "\\n\\tclass Solution:\\n\\t\\tdef mostFrequentEven(self, nums: List[int]) -> int:\\n\\t\\t\\tcount = collections.Counter(nums)\\n\\t\\t\\tmaxium = -1\\n\\t\\t\\tfreq = 0\\n\\t\\t\\tfor i, j in count.items():\\n\\t\\t\\t\\tif i%2==0 and ( j>freq or ( j == freq and maxium>i)):\\n\\t\\t\\t\\t\\tfreq= j\\n\\t\\t\\t\\t\\tmaxium = i\\n\\t\\t\\treturn maxium",
                "codeTag": "Java"
            },
            {
                "id": 2563774,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn most_frequent_even(nums: Vec<i32>) -> i32 {\\n        let mut max_freq = i32::MIN;\\n        let mut counter = std::collections::BTreeMap::new();\\n\\n        nums.iter().filter(|&&x| x % 2 == 0).for_each(|&x| {\\n            let freq = counter.entry(x).and_modify(|n| *n += 1).or_insert(1);\\n            if *freq > max_freq {\\n                max_freq = *freq;\\n            }\\n        });\\n\\n        counter\\n            .into_iter()\\n            .find(|(_, freq)| *freq == max_freq)\\n            .map_or(-1, |(x, _)| x)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn most_frequent_even(nums: Vec<i32>) -> i32 {\\n        let mut max_freq = i32::MIN;\\n        let mut counter = std::collections::BTreeMap::new();\\n\\n        nums.iter().filter(|&&x| x % 2 == 0).for_each(|&x| {\\n            let freq = counter.entry(x).and_modify(|n| *n += 1).or_insert(1);\\n            if *freq > max_freq {\\n                max_freq = *freq;\\n            }\\n        });\\n\\n        counter\\n            .into_iter()\\n            .find(|(_, freq)| *freq == max_freq)\\n            .map_or(-1, |(x, _)| x)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2563238,
                "title": "python-easy-way",
                "content": "\\tCc = collections.Counter(nums)\\n\\t\\t\\tmfee=-1\\n\\t\\t\\tMax=0\\n\\t\\t\\tfor i in Cc.keys():\\n\\t\\t\\t\\tif Cc[i]==Max and i%2==0:\\n\\t\\t\\t\\t\\tif i<mfee:\\n\\t\\t\\t\\t\\t\\tmfee=i\\n\\t\\t\\t\\tif Cc[i]>Max and i%2==0:\\n\\t\\t\\t\\t\\tMax=Cc[i]\\n\\t\\t\\t\\t\\tmfee=i\\n\\t\\t\\treturn mfee",
                "solutionTags": [],
                "code": "\\tCc = collections.Counter(nums)\\n\\t\\t\\tmfee=-1\\n\\t\\t\\tMax=0\\n\\t\\t\\tfor i in Cc.keys():\\n\\t\\t\\t\\tif Cc[i]==Max and i%2==0:\\n\\t\\t\\t\\t\\tif i<mfee:\\n\\t\\t\\t\\t\\t\\tmfee=i\\n\\t\\t\\t\\tif Cc[i]>Max and i%2==0:\\n\\t\\t\\t\\t\\tMax=Cc[i]\\n\\t\\t\\t\\t\\tmfee=i\\n\\t\\t\\treturn mfee",
                "codeTag": "Unknown"
            },
            {
                "id": 2563034,
                "title": "python3-sort-per-counter",
                "content": "`key=lambda x:[c[x]*((x+1)%2),-x]` means:\\nWe are sorting per number of times the number `x` is in the array `nums`.\\nWe need the **odd** numbers first folloved by **even** numbers,\\nwe use `((x+1)%2)` which gives zero for odd numbers and one for even numbers.\\nAnd finally we need to have smaller numbers after bigger numbers, for that we added\\n`-x` as a second parameter for sorting.\\n\\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        c=Counter(nums)\\n        nums.sort(key=lambda x:[c[x]*((x+1)%2),-x])\\n        if (nums[-1]+1)%2:\\n            return nums[-1]\\n        return -1\\n        \\n```\\nTime complexity is `O(n log n)` because we are sorting array.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        c=Counter(nums)\\n        nums.sort(key=lambda x:[c[x]*((x+1)%2),-x])\\n        if (nums[-1]+1)%2:\\n            return nums[-1]\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562695,
                "title": "javascript-easy-to-understand-2-step-solution-100",
                "content": "***Explaination:***\\n**Step1**: Created object for fetching count of each array element\\n**Step2**: Iterate over object and return value with most frequent event\\n\\nRuntime: 199 ms, faster than 100.00% of JavaScript online submissions for Most Frequent Even Element.\\nMemory Usage: 50.8 MB, less than 100.00% of JavaScript online submissions for Most Frequent Even Element.\\n\\n```\\nconst mostFrequentEven = (nums, value = \"-1\") => {\\n    const obj = nums.reduce((result, acc) => {\\n        if(acc%2 === 0)\\n            result[acc] ? result[acc] += 1: result[acc] = 1;\\n        return result\\n    },{});\\n    \\n    for(let properties in obj)\\n        if(obj[properties] >  (obj[value] || value))  value = properties;\\n        \\n    return +value;\\n};\\n```\\n\\nOpen for suggestion.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst mostFrequentEven = (nums, value = \"-1\") => {\\n    const obj = nums.reduce((result, acc) => {\\n        if(acc%2 === 0)\\n            result[acc] ? result[acc] += 1: result[acc] = 1;\\n        return result\\n    },{});\\n    \\n    for(let properties in obj)\\n        if(obj[properties] >  (obj[value] || value))  value = properties;\\n        \\n    return +value;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2562271,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();i++)\\n            m[nums[i]]++;\\n        \\n        int maxfreq = 0;\\n        int ans = -1;\\n        \\n       \\n        for(auto i = m.begin();i!=m.end();i++){\\n            if(i->first %2==0 && i->second>maxfreq){\\n                maxfreq = i->second;\\n                ans = i->first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int> m;\\n        for(int i=0;i<nums.size();i++)\\n            m[nums[i]]++;\\n        \\n        int maxfreq = 0;\\n        int ans = -1;\\n        \\n       \\n        for(auto i = m.begin();i!=m.end();i++){\\n            if(i->first %2==0 && i->second>maxfreq){\\n                maxfreq = i->second;\\n                ans = i->first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561901,
                "title": "c-intuitive-solution",
                "content": "```\\n    static bool cmp(pair<int,int> &a, pair<int,int> &b){\\n        if(a.second==b.second) return a.first<b.first;\\n        return a.second>b.second;\\n    }\\n    \\n    int mostFrequentEven(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(int i: nums){\\n            if(i%2==0) m[i]++;\\n        }\\n        vector<pair<int,int>> v;\\n        for(auto it: m) v.push_back({it.first,it.second});\\n        \\n        sort(v.begin(),v.end(),cmp);\\n        \\n        return v.size() ? v[0].first : -1;\\n    }\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n    static bool cmp(pair<int,int> &a, pair<int,int> &b){\\n        if(a.second==b.second) return a.first<b.first;\\n        return a.second>b.second;\\n    }\\n    \\n    int mostFrequentEven(vector<int>& nums) {\\n        unordered_map<int,int> m;\\n        for(int i: nums){\\n            if(i%2==0) m[i]++;\\n        }\\n        vector<pair<int,int>> v;\\n        for(auto it: m) v.push_back({it.first,it.second});\\n        \\n        sort(v.begin(),v.end(),cmp);\\n        \\n        return v.size() ? v[0].first : -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2561861,
                "title": "easy-understanding-c",
                "content": "```\\nint mostFrequentEven(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n            mp[nums[i]]++;\\n        int maxi=0;\\n        int mini=INT_MAX;\\n        for(auto x:mp){\\n            if(x.first%2==0){\\n                if(x.second==maxi){\\n                    mini=min(mini,x.first);\\n                }else{\\n                    if(maxi<x.second){\\n                        mini=x.first;\\n                        maxi=x.second;\\n                    }\\n                }\\n            }\\n        }\\n        if(mini==INT_MAX)\\n            return -1;\\n        return mini;\\n    }\\n```\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint mostFrequentEven(vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n            mp[nums[i]]++;\\n        int maxi=0;\\n        int mini=INT_MAX;\\n        for(auto x:mp){\\n            if(x.first%2==0){\\n                if(x.second==maxi){\\n                    mini=min(mini,x.first);\\n                }else{\\n                    if(maxi<x.second){\\n                        mini=x.first;\\n                        maxi=x.second;\\n                    }\\n                }\\n            }\\n        }\\n        if(mini==INT_MAX)\\n            return -1;\\n        return mini;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2561468,
                "title": "java-solution-treemap-explained-with-comments",
                "content": "### Please Upvote !!!\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n\\n        // Map of the even elements and their respective counts\\n        Map<Integer, Integer> map = new TreeMap<>();        // Keyset is sorted\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] % 2 == 0) {                         // Putting only even values\\n                map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n                maxCount = Math.max(maxCount, map.get(n));  // We keep calculating the maxCount of an even number here only instead of doing it separately (Otherwise it\\'d take extra time)\\n            }\\n        }\\n\\n        if (map.isEmpty()) return -1;                       // if no even values, map would be empty\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            if (entry.getValue() == maxCount) {             // if maxCount is found, we got the required key (other keys with same count would be greater because keyset is sorted)\\n                ans = entry.getKey();                       // save the key to ans\\n                break;                                      // break out\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// We can use a normal HashMap also but in that case \\n// we will have to iterate over the whole hashmap at the end to find our required key (even if we find it early), because hashmap is not sorted by default\\n// only after iterating the whole hashmap, we can return the minimum key as our answer. So by using a treemap, we somewhat reduce the execution time. \\n// As soon as the count is matched, we break out of the loop and return that particular key.\\n\\n// TC: O(n) + O(n) + O(n) => O(n)\\n// SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n\\n        // Map of the even elements and their respective counts\\n        Map<Integer, Integer> map = new TreeMap<>();        // Keyset is sorted\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] % 2 == 0) {                         // Putting only even values\\n                map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n                maxCount = Math.max(maxCount, map.get(n));  // We keep calculating the maxCount of an even number here only instead of doing it separately (Otherwise it\\'d take extra time)\\n            }\\n        }\\n\\n        if (map.isEmpty()) return -1;                       // if no even values, map would be empty\\n\\n        int ans = Integer.MAX_VALUE;\\n\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            if (entry.getValue() == maxCount) {             // if maxCount is found, we got the required key (other keys with same count would be greater because keyset is sorted)\\n                ans = entry.getKey();                       // save the key to ans\\n                break;                                      // break out\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// We can use a normal HashMap also but in that case \\n// we will have to iterate over the whole hashmap at the end to find our required key (even if we find it early), because hashmap is not sorted by default\\n// only after iterating the whole hashmap, we can return the minimum key as our answer. So by using a treemap, we somewhat reduce the execution time. \\n// As soon as the count is matched, we break out of the loop and return that particular key.\\n\\n// TC: O(n) + O(n) + O(n) => O(n)\\n// SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561393,
                "title": "python3-1-liner",
                "content": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        return Counter(filter(lambda x: x % 2 == 0 or x == -1, sorted(nums) + [-1])).most_common(1)[0][0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        return Counter(filter(lambda x: x % 2 == 0 or x == -1, sorted(nums) + [-1])).most_common(1)[0][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561366,
                "title": "hash-map",
                "content": "```\\nint mostFrequentEven(vector<int>& nn)\\n{\\n\\tunordered_map<int,int> m;\\n\\tfor(const auto & n : nn) ++m[n];\\n\\tint out{-1};\\n\\tfor(const auto & [i, j] : m)\\n\\t\\tif(~i&1 and (m[out]<j or m[out]==j and i<out)) out=i;\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint mostFrequentEven(vector<int>& nn)\\n{\\n\\tunordered_map<int,int> m;\\n\\tfor(const auto & n : nn) ++m[n];\\n\\tint out{-1};\\n\\tfor(const auto & [i, j] : m)\\n\\t\\tif(~i&1 and (m[out]<j or m[out]==j and i<out)) out=i;\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2561346,
                "title": "cpp-hashmap-implementation",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        int n=nums.size(),i,max=INT_MIN;\\n        vector<int>v;\\n        for(i=0;i<n;i++){\\n            if(nums[i]%2==0)\\n                m[nums[i]]++;\\n        }\\n        if(m.size()==0)\\n            return -1;\\n        for(auto i:m){\\n            if(i.second>max)\\n                max=i.second;\\n        }\\n        for(auto i:m){\\n            if(i.second==max)\\n                v.push_back(i.first);\\n        }\\n        if(v.size()==1)\\n            return v[0];\\n        else{\\n            sort(v.begin(),v.end());\\n            return v[0];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        unordered_map<int,int>m;\\n        int n=nums.size(),i,max=INT_MIN;\\n        vector<int>v;\\n        for(i=0;i<n;i++){\\n            if(nums[i]%2==0)\\n                m[nums[i]]++;\\n        }\\n        if(m.size()==0)\\n            return -1;\\n        for(auto i:m){\\n            if(i.second>max)\\n                max=i.second;\\n        }\\n        for(auto i:m){\\n            if(i.second==max)\\n                v.push_back(i.first);\\n        }\\n        if(v.size()==1)\\n            return v[0];\\n        else{\\n            sort(v.begin(),v.end());\\n            return v[0];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561174,
                "title": "js-javascript-map-beats-100",
                "content": "```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\nvar mostFrequentEven = function(nums) {\\n    const map = new Map();\\n\\tlet element = Infinity, maxFreq = 0;\\n\\n\\tfor (const num of nums) {\\n\\t\\tif(num % 2 == 0) {\\n\\t\\t\\tlet freq = 1;\\n\\t\\t\\t\\n\\t\\t\\tif(map.has(num))\\n\\t\\t\\t\\tfreq = map.get(num) + 1;\\n\\t\\t\\t\\n\\t\\t\\tmap.set(num, freq);\\n\\n\\t\\t\\tif(freq > maxFreq || freq == maxFreq && num < element){\\n\\t\\t\\t\\telement = num;\\n\\t\\t\\t\\tmaxFreq = freq;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn maxFreq == 0 ? -1 : element;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\nvar mostFrequentEven = function(nums) {\\n    const map = new Map();\\n\\tlet element = Infinity, maxFreq = 0;\\n\\n\\tfor (const num of nums) {\\n\\t\\tif(num % 2 == 0) {\\n\\t\\t\\tlet freq = 1;\\n\\t\\t\\t\\n\\t\\t\\tif(map.has(num))\\n\\t\\t\\t\\tfreq = map.get(num) + 1;\\n\\t\\t\\t\\n\\t\\t\\tmap.set(num, freq);\\n\\n\\t\\t\\tif(freq > maxFreq || freq == maxFreq && num < element){\\n\\t\\t\\t\\telement = num;\\n\\t\\t\\t\\tmaxFreq = freq;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn maxFreq == 0 ? -1 : element;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2561125,
                "title": "c-solution-map-complexity-o-n",
                "content": "class Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& v) {\\n        int n = v.size() ;\\n        map<int,int> mp ;\\n        int mx = -1 ; \\n        int index = 0 ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(v[i] % 2 == 0)\\n            {\\n                mp[v[i]]++ ;\\n            }\\n            \\n            if(mx == mp[v[i]] && v[index] > v[i] && v[i] % 2 == 0)\\n            {\\n                index = i ;\\n            }\\n            \\n            if(mx < mp[v[i]] && v[i] % 2 == 0)\\n            {\\n                mx = mp[v[i]] ;\\n                index = i ;\\n            }\\n        }\\n        \\n        if(mx == -1)\\n        {\\n            return -1 ;\\n        }else{\\n            return v[index] ;\\n        }\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& v) {\\n        int n = v.size() ;\\n        map<int,int> mp ;\\n        int mx = -1 ; \\n        int index = 0 ;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(v[i] % 2 == 0)\\n            {\\n                mp[v[i]]++ ;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2560902,
                "title": "c-easy-solution-with-comments-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());   // sort the given array\\n        map<int, int> m;                  // take a hash map for storing the freq of each number\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if( nums[i] % 2 == 0)         // storing only the even elements in the map\\n                m[nums[i]]++;\\n            \\n        }\\n        \\n        if(m.size() == 0)             // if the map size is 0, that means there is no even elements in the given array. So, return -1 \\n            return -1;\\n        \\n        // Take the first even element and its freq from the map\\n        auto it = m.begin();\\n        int ans = it->first;       \\n        int maxFreq = it->second;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(m.find(nums[i]) != m.end())\\n            {\\n                if(m[nums[i]] > maxFreq)       // if freq of any element is greater than the maxFreq then update ans and maxFreq\\n                {\\n                    maxFreq = m[nums[i]];\\n                    ans = nums[i];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());   // sort the given array\\n        map<int, int> m;                  // take a hash map for storing the freq of each number\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if( nums[i] % 2 == 0)         // storing only the even elements in the map\\n                m[nums[i]]++;\\n            \\n        }\\n        \\n        if(m.size() == 0)             // if the map size is 0, that means there is no even elements in the given array. So, return -1 \\n            return -1;\\n        \\n        // Take the first even element and its freq from the map\\n        auto it = m.begin();\\n        int ans = it->first;       \\n        int maxFreq = it->second;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(m.find(nums[i]) != m.end())\\n            {\\n                if(m[nums[i]] > maxFreq)       // if freq of any element is greater than the maxFreq then update ans and maxFreq\\n                {\\n                    maxFreq = m[nums[i]];\\n                    ans = nums[i];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560835,
                "title": "one-line-py3",
                "content": "CODE::\\n\\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        try: return sorted(Counter(list(filter(lambda x: x%2==0,nums))).items(),key = lambda x:(-x[1],x[0]))[0][0]\\n        except: return -1\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        try: return sorted(Counter(list(filter(lambda x: x%2==0,nums))).items(),key = lambda x:(-x[1],x[0]))[0][0]\\n        except: return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560823,
                "title": "c-hashmap-very-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int> m;\\n        for(auto x:nums)\\n            m[x]++;\\n        int f=0;\\n        int n=-1;\\n        for(auto x:m)\\n        {\\n            if(x.first%2==0)\\n            {\\n                if(f<x.second)\\n                {\\n                    f=x.second;\\n                    n=x.first;\\n                }\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int> m;\\n        for(auto x:nums)\\n            m[x]++;\\n        int f=0;\\n        int n=-1;\\n        for(auto x:m)\\n        {\\n            if(x.first%2==0)\\n            {\\n                if(f<x.second)\\n                {\\n                    f=x.second;\\n                    n=x.first;\\n                }\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560778,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        \\n\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int max=0;\\n        \\n        for(int i=0;i<nums.length;i++){\\n\\n            if(nums[i]%2==0){ map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            \\n            max=Math.max(max,map.get(nums[i]));\\n                            }\\n        }\\n        if(max==0) return -1;\\n        int ans=Integer.MAX_VALUE;\\n        for(Integer key:map.keySet()){\\n            \\n            if(map.get(key)==max){\\n                ans=Math.min(ans,key);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        \\n\\n        \\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int max=0;\\n        \\n        for(int i=0;i<nums.length;i++){\\n\\n            if(nums[i]%2==0){ map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            \\n            max=Math.max(max,map.get(nums[i]));\\n                            }\\n        }\\n        if(max==0) return -1;\\n        int ans=Integer.MAX_VALUE;\\n        for(Integer key:map.keySet()){\\n            \\n            if(map.get(key)==max){\\n                ans=Math.min(ans,key);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560749,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Hashmap***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // declare a map\\n        \\n        unordered_map<int, int> mp;\\n        \\n        // store the frequency of even element in map\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] % 2 == 0)\\n            {\\n                mp[nums[i]]++;\\n            }\\n        }\\n        \\n        // if there is no even element in array then return -1\\n        \\n        if(mp.size() == 0)\\n            return -1;\\n        \\n        // find the smallest no. with maximum frequency\\n        \\n        int mini = -1;\\n        \\n        int count = 0;\\n        \\n        for(auto x : mp)\\n        {\\n            if(x.second > count)\\n            {\\n                count = x.second;\\n                \\n                mini = x.first;\\n            }\\n            else if(x.second == count && mini > x.first)\\n            {\\n                mini = x.first;\\n            }\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // declare a map\\n        \\n        unordered_map<int, int> mp;\\n        \\n        // store the frequency of even element in map\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(nums[i] % 2 == 0)\\n            {\\n                mp[nums[i]]++;\\n            }\\n        }\\n        \\n        // if there is no even element in array then return -1\\n        \\n        if(mp.size() == 0)\\n            return -1;\\n        \\n        // find the smallest no. with maximum frequency\\n        \\n        int mini = -1;\\n        \\n        int count = 0;\\n        \\n        for(auto x : mp)\\n        {\\n            if(x.second > count)\\n            {\\n                count = x.second;\\n                \\n                mini = x.first;\\n            }\\n            else if(x.second == count && mini > x.first)\\n            {\\n                mini = x.first;\\n            }\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560644,
                "title": "python-solution-with-dictionary",
                "content": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=dict()\\n        for i in range(len(nums)):\\n            if nums[i]%2==0:\\n                if nums[i] not in d:\\n                    d[nums[i]]=1\\n                else:\\n                    d[nums[i]]+=1\\n        c=0\\n        ans=0\\n        if d:\\n            for k,v in d.items():\\n                if v>c:\\n                    c=v\\n                    ans=k\\n                elif v==c:\\n                    ans=min(ans,k)\\n            return ans\\n        return -1\\n```\\n***Please upvote if you like this.***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=dict()\\n        for i in range(len(nums)):\\n            if nums[i]%2==0:\\n                if nums[i] not in d:\\n                    d[nums[i]]=1\\n                else:\\n                    d[nums[i]]+=1\\n        c=0\\n        ans=0\\n        if d:\\n            for k,v in d.items():\\n                if v>c:\\n                    c=v\\n                    ans=k\\n                elif v==c:\\n                    ans=min(ans,k)\\n            return ans\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560482,
                "title": "cpp-c-easy-understand-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int ans=-1;\\n        map<int,int>mpp;\\n        for(int i=0;i<nums.size();i++){\\n               mpp[nums[i]]++;\\n        }\\n        int mini=-1;   \\n        for(auto it:mpp)\\n        {\\n            if(it.first%2==0 && it.second>mini)\\n            {\\n                mini=it.second;\\n                ans=it.first;       \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int ans=-1;\\n        map<int,int>mpp;\\n        for(int i=0;i<nums.size();i++){\\n               mpp[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2560474,
                "title": "treemap-java",
                "content": "If there is a tie, we have to return the smallest one hence treemap. Which sorts the key. Which will pass all the edge case.\\n\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        Arrays.sort(nums);\\n        TreeMap<Integer, Integer> hmap = new TreeMap<>();\\n        for(int i: nums){\\n            if(i % 2 == 0){\\n                hmap.put(i, hmap.getOrDefault(i, 0) + 1);\\n                // System.out.println(hmap.get(i));\\n            }\\n        }\\n        int max = 0, res = 0;\\n        for(int key: hmap.keySet()){\\n            // System.out.println(key);\\n            System.out.println(key);\\n            if(hmap.get(key) > max){\\n                max = hmap.get(key);\\n                res = key;\\n                \\n            }\\n        }\\n        return max == 0 ? -1 : res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        Arrays.sort(nums);\\n        TreeMap<Integer, Integer> hmap = new TreeMap<>();\\n        for(int i: nums){\\n            if(i % 2 == 0){\\n                hmap.put(i, hmap.getOrDefault(i, 0) + 1);\\n                // System.out.println(hmap.get(i));\\n            }\\n        }\\n        int max = 0, res = 0;\\n        for(int key: hmap.keySet()){\\n            // System.out.println(key);\\n            System.out.println(key);\\n            if(hmap.get(key) > max){\\n                max = hmap.get(key);\\n                res = key;\\n                \\n            }\\n        }\\n        return max == 0 ? -1 : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560383,
                "title": "java-single-pass",
                "content": "```\\nimport java.util.*;\\nclass Solution {\\n      //Author: Anand\\n     public int mostFrequentEven(int[] nums) {\\n\\n        Map<Integer, Integer> tm = new TreeMap<>();\\n\\n        for (int num : nums) if (num % 2 == 0) tm.put(num, tm.getOrDefault(num, 0) + 1);\\n\\n        int elem = -1;\\n        int count = Integer.MIN_VALUE;\\n        for (Map.Entry<Integer, Integer> entry : tm.entrySet()) {\\n\\n            if (entry.getValue() > count) {\\n                count = entry.getValue();\\n                elem = entry.getKey();\\n            }\\n        }\\n        return elem;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n      //Author: Anand\\n     public int mostFrequentEven(int[] nums) {\\n\\n        Map<Integer, Integer> tm = new TreeMap<>();\\n\\n        for (int num : nums) if (num % 2 == 0) tm.put(num, tm.getOrDefault(num, 0) + 1);\\n\\n        int elem = -1;\\n        int count = Integer.MIN_VALUE;\\n        for (Map.Entry<Integer, Integer> entry : tm.entrySet()) {\\n\\n            if (entry.getValue() > count) {\\n                count = entry.getValue();\\n                elem = entry.getKey();\\n            }\\n        }\\n        return elem;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560347,
                "title": "c-single-pass-unordered-map-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int ans = -1, freq = 0;\\n        \\n        unordered_map<int,int>mp;\\n        \\n        for(int x: nums){\\n            if(x%2 == 0){\\n                mp[x]++;\\n                \\n                if(mp[x]>freq){\\n                    ans = x;\\n                    freq = mp[x];\\n                }\\n                \\n                else if(mp[x]==freq){\\n                    ans = min(x, ans);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int ans = -1, freq = 0;\\n        \\n        unordered_map<int,int>mp;\\n        \\n        for(int x: nums){\\n            if(x%2 == 0){\\n                mp[x]++;\\n                \\n                if(mp[x]>freq){\\n                    ans = x;\\n                    freq = mp[x];\\n                }\\n                \\n                else if(mp[x]==freq){\\n                    ans = min(x, ans);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560337,
                "title": "easy-understandable-explained-map-solution",
                "content": "```\\n/*\\n    Approach\\n    \\n    Put even elements as key in a map with their frequency as value \\n    Using a TreeMap so that the map will be sorted by key in increasing order\\n    \\n    Now start traversing the map\\n    From here, filter out the key with maximum frequency as value only\\n    As the keys are already in increasing order and map only contains even keys\\n    \\n    Ex: nums = [0,1,2,2,4,4,1]\\n    \\n    Map -> {\\n                0 -> 1,\\n                2 -> 2,\\n                4 -> 2\\n            }\\n            \\n            On traversing the map, we found the key(2) with maximum value \\n*/\\n\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        int n = nums.length;\\n        Map<Integer,Integer> map = new TreeMap<>();\\n        for(int e : nums)\\n            if(e%2==0)\\n                map.put(e,map.getOrDefault(e,0)+1);\\n        \\n        int item = -1;\\n        int max = Integer.MIN_VALUE;\\n        for(int key : map.keySet()){\\n            int val = map.get(key);\\n            if(val > max) {\\n                max = val;\\n                item = key;}\\n        }\\n        \\n        return item;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n    Approach\\n    \\n    Put even elements as key in a map with their frequency as value \\n    Using a TreeMap so that the map will be sorted by key in increasing order\\n    \\n    Now start traversing the map\\n    From here, filter out the key with maximum frequency as value only\\n    As the keys are already in increasing order and map only contains even keys\\n    \\n    Ex: nums = [0,1,2,2,4,4,1]\\n    \\n    Map -> {\\n                0 -> 1,\\n                2 -> 2,\\n                4 -> 2\\n            }\\n            \\n            On traversing the map, we found the key(2) with maximum value \\n*/\\n\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        int n = nums.length;\\n        Map<Integer,Integer> map = new TreeMap<>();\\n        for(int e : nums)\\n            if(e%2==0)\\n                map.put(e,map.getOrDefault(e,0)+1);\\n        \\n        int item = -1;\\n        int max = Integer.MIN_VALUE;\\n        for(int key : map.keySet()){\\n            int val = map.get(key);\\n            if(val > max) {\\n                max = val;\\n                item = key;}\\n        }\\n        \\n        return item;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560311,
                "title": "easy-c-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int> m;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i]%2 == 0){\\n                m[nums[i]]++;\\n            }\\n        }\\n        if(m.empty()){\\n            return -1;\\n        }\\n        int el = INT_MAX;\\n        int findMax = INT_MIN;\\n        for(auto it:m){\\n            if(it.second > findMax){\\n                findMax = it.second;\\n                el = it.first;\\n            }\\n        }\\n        for(auto it:m){\\n            if(it.second == findMax){\\n                return it.first;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int> m;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(nums[i]%2 == 0){\\n                m[nums[i]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2560242,
                "title": "c-o-n-frequency-map",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(int i=0;i<nums.size();i++) mp[nums[i]]++;\\n        \\n        map<int,int> :: iterator it;\\n        int maxf=0, ans=-1;\\n        for(it=mp.begin();it!=mp.end();it++){\\n            int f=it->second, val=it->first;\\n            if(val%2==0){\\n                if(f>maxf){\\n                    ans=val, maxf=f;\\n                }else if(f==maxf && ans>val){\\n                    ans=val;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Do Upvote If It Helps**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(int i=0;i<nums.size();i++) mp[nums[i]]++;\\n        \\n        map<int,int> :: iterator it;\\n        int maxf=0, ans=-1;\\n        for(it=mp.begin();it!=mp.end();it++){\\n            int f=it->second, val=it->first;\\n            if(val%2==0){\\n                if(f>maxf){\\n                    ans=val, maxf=f;\\n                }else if(f==maxf && ans>val){\\n                    ans=val;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560208,
                "title": "no-brainer-priority-queue-for-contest",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(auto &x:nums) mp[x]++;\\n        priority_queue<pair<int,int>> pq;\\n        for(auto &[a,b] : mp) {\\n            pq.push({b,a});\\n        } int ans=1e9, mx = 0;\\n        while(!pq.empty()) {\\n            auto val = pq.top(); pq.pop();\\n            // cout<<val.first << \" \" << val.second<< endl;\\n            if(val.second%2==0 && val.first >= mx) {\\n                mx = max(mx, val.first);\\n                ans = min(ans,val.second);\\n            }\\n        }\\n        return ans == 1e9 ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        for(auto &x:nums) mp[x]++;\\n        priority_queue<pair<int,int>> pq;\\n        for(auto &[a,b] : mp) {\\n            pq.push({b,a});\\n        } int ans=1e9, mx = 0;\\n        while(!pq.empty()) {\\n            auto val = pq.top(); pq.pop();\\n            // cout<<val.first << \" \" << val.second<< endl;\\n            if(val.second%2==0 && val.first >= mx) {\\n                mx = max(mx, val.first);\\n                ans = min(ans,val.second);\\n            }\\n        }\\n        return ans == 1e9 ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2560189,
                "title": "c-easy-self-explanatory",
                "content": "**Do UPVOTE if it helps :)**\\n\\n**Approach :**\\n*1.* Store frequency of all even numbers in a map.\\n*2.* Iterate over map and check the element with higher frequency is our answer.\\n\\n```\\nint mostFrequentEven(vector<int>& nums) {\\n        map<int,int>mp;\\n        for(auto it :nums )\\n            if(it%2==0) mp[it]++;\\n        int maxi = INT_MIN , val=-1;\\n        for(auto it : mp) if(it.second>maxi) maxi= it.second , val=it.first;\\n        return val;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint mostFrequentEven(vector<int>& nums) {\\n        map<int,int>mp;\\n        for(auto it :nums )\\n            if(it%2==0) mp[it]++;\\n        int maxi = INT_MIN , val=-1;\\n        for(auto it : mp) if(it.second>maxi) maxi= it.second , val=it.first;\\n        return val;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2560105,
                "title": "using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        int count=0;\\n        int ans=-1;\\n        for(auto it:mp){\\n            if(it.first%2==0)\\n              if(it.second>count){\\n                  ans=it.first;\\n                  count=it.second;\\n              }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        int count=0;\\n        int ans=-1;\\n        for(auto it:mp){\\n            if(it.first%2==0)\\n              if(it.second>count){\\n                  ans=it.first;\\n                  count=it.second;\\n              }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560079,
                "title": "c-easily-understandable-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) \\n    {\\n        int n= nums.size();\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2==0)\\n                mp[nums[i]]++;\\n        }\\n        \\n        int ans=0;\\n        int mx=0;\\n        \\n        if(mp.empty()) return -1;\\n        \\n        for(auto it : mp)\\n        {\\n            if(it.second>mx)\\n            {\\n                mx = it.second;\\n                ans = it.first;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) \\n    {\\n        int n= nums.size();\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2==0)\\n                mp[nums[i]]++;\\n        }\\n        \\n        int ans=0;\\n        int mx=0;\\n        \\n        if(mp.empty()) return -1;\\n        \\n        for(auto it : mp)\\n        {\\n            if(it.second>mx)\\n            {\\n                mx = it.second;\\n                ans = it.first;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560062,
                "title": "c-use-hashmap-easy-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int mostFrequentEven(vector<int>& nums) \\n    {\\n        map<int, int> mp;\\n        \\n        for(auto it:nums)\\n            if(it%2==0) mp[it]++;\\n        \\n        int x, maxi=0;\\n        \\n        if(mp.empty()) return -1;\\n        for(auto it:mp)\\n        {\\n            if(it.second > maxi)\\n            {\\n                maxi = it.second;\\n                x = it.first;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int mostFrequentEven(vector<int>& nums) \\n    {\\n        map<int, int> mp;\\n        \\n        for(auto it:nums)\\n            if(it%2==0) mp[it]++;\\n        \\n        int x, maxi=0;\\n        \\n        if(mp.empty()) return -1;\\n        for(auto it:mp)\\n        {\\n            if(it.second > maxi)\\n            {\\n                maxi = it.second;\\n                x = it.first;\\n            }\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560058,
                "title": "js-javascript-solution-with-hashmap",
                "content": "# Any feedback would be appreciated \\uD83D\\uDE0A\\n\\n```\\nconst mostFrequentEven = function (nums) {\\n  let result = [];\\n  let map = new Map();\\n\\n  for (let num of nums) {\\n    if (num % 2 === 0) map.set(num, map.get(num) + 1 || 1);\\n  }\\n\\n  if (map.size === 0) return -1;\\n\\n  for (let [key, value] of map) {\\n    result.push([key, value]);\\n  }\\n\\n  return result.sort((a, b) => {\\n    if (a[1] === b[1]) return a[0] - b[0];\\n    else return b[1] - a[1];\\n  })[0][0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst mostFrequentEven = function (nums) {\\n  let result = [];\\n  let map = new Map();\\n\\n  for (let num of nums) {\\n    if (num % 2 === 0) map.set(num, map.get(num) + 1 || 1);\\n  }\\n\\n  if (map.size === 0) return -1;\\n\\n  for (let [key, value] of map) {\\n    result.push([key, value]);\\n  }\\n\\n  return result.sort((a, b) => {\\n    if (a[1] === b[1]) return a[0] - b[0];\\n    else return b[1] - a[1];\\n  })[0][0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2560057,
                "title": "map",
                "content": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        int ans=-1,cnt=0;\\n        for(auto it : mp){\\n            if(cnt<it.second && it.first%2==0){\\n                cnt = it.second;\\n                ans = it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int> mp;\\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]]++;\\n        }\\n        int ans=-1,cnt=0;\\n        for(auto it : mp){\\n            if(cnt<it.second && it.first%2==0){\\n                cnt = it.second;\\n                ans = it.first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560048,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int max=0;\\n        int elem=Integer.MAX_VALUE;\\n        for(int  num:nums){\\n            if(num%2==0){\\n                map.put(num,map.getOrDefault(num,0)+1);\\n                max=Integer.max(max,map.get(num));\\n            }\\n        }\\n        for(int i:map.keySet()){\\n            if(map.get(i)==max){\\n                elem=Integer.min(elem,i);\\n            }\\n        }\\n        if(elem==Integer.MAX_VALUE)return -1;\\n        return elem;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int max=0;\\n        int elem=Integer.MAX_VALUE;\\n        for(int  num:nums){\\n            if(num%2==0){\\n                map.put(num,map.getOrDefault(num,0)+1);\\n                max=Integer.max(max,map.get(num));\\n            }\\n        }\\n        for(int i:map.keySet()){\\n            if(map.get(i)==max){\\n                elem=Integer.min(elem,i);\\n            }\\n        }\\n        if(elem==Integer.MAX_VALUE)return -1;\\n        return elem;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2560046,
                "title": "java-solution-easy-understanding",
                "content": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        LinkedHashMap<Integer, Integer> mapEvenRepeat = new LinkedHashMap<>();\\n        int len = nums.length;\\n        for(int i = 0; i < len; i++){\\n            if(nums[i] % 2 == 0){\\n                mapEvenRepeat.put(nums[i], mapEvenRepeat.getOrDefault(nums[i], 0) + 1);\\n            }\\n        }\\n        int min = Integer.MIN_VALUE;\\n        int result = -1;\\n        for(Map.Entry<Integer, Integer> element : mapEvenRepeat.entrySet()) {\\n            int value = element.getValue(), key = element.getKey();\\n\\t\\t\\tif(value > min){\\n                min = value;\\n                result = key;\\n            }else if(value == min){\\n                if(key < result) result = key;\\n            }\\n\\t\\t}\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        LinkedHashMap<Integer, Integer> mapEvenRepeat = new LinkedHashMap<>();\\n        int len = nums.length;\\n        for(int i = 0; i < len; i++){\\n            if(nums[i] % 2 == 0){\\n                mapEvenRepeat.put(nums[i], mapEvenRepeat.getOrDefault(nums[i], 0) + 1);\\n            }\\n        }\\n        int min = Integer.MIN_VALUE;\\n        int result = -1;\\n        for(Map.Entry<Integer, Integer> element : mapEvenRepeat.entrySet()) {\\n            int value = element.getValue(), key = element.getKey();\\n\\t\\t\\tif(value > min){\\n                min = value;\\n                result = key;\\n            }else if(value == min){\\n                if(key < result) result = key;\\n            }\\n\\t\\t}\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090641,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        return reduce(lambda m, c: c if c[1] > m[1] or c[1] == m[1] and c[0] < m[0] else m, Counter(n for n in nums if not n%2).items(), (-1, 0))[0]\\n```\\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        return reduce(lambda m, c: c if c[1] > m[1] or c[1] == m[1] and c[0] < m[0] else m, Counter(filterfalse(lambda n: n%2, nums)).items(), (-1, 0))[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        return reduce(lambda m, c: c if c[1] > m[1] or c[1] == m[1] and c[0] < m[0] else m, Counter(n for n in nums if not n%2).items(), (-1, 0))[0]\\n```\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        return reduce(lambda m, c: c if c[1] > m[1] or c[1] == m[1] and c[0] < m[0] else m, Counter(filterfalse(lambda n: n%2, nums)).items(), (-1, 0))[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087873,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        int result = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int num : nums){\\n            if(num % 2 == 0){\\n                map.putIfAbsent(num, 0);\\n                map.put(num, map.get(num) + 1);\\n            }\\n        }\\n        if(map.size() == 0){\\n            return -1;\\n        }\\n        //int result = 0;\\n        int freq = Integer.MIN_VALUE;\\n        for(Map.Entry<Integer, Integer> entry : map.entrySet()){\\n            if(entry.getValue() > freq){\\n                freq = entry.getValue();\\n                result = entry.getKey();\\n            }\\n            if(entry.getValue() == freq){\\n                result = Math.min(result, entry.getKey());\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        int result = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int num : nums){\\n            if(num % 2 == 0){\\n                map.putIfAbsent(num, 0);\\n                map.put(num, map.get(num) + 1);\\n            }\\n        }\\n        if(map.size() == 0){\\n            return -1;\\n        }\\n        //int result = 0;\\n        int freq = Integer.MIN_VALUE;\\n        for(Map.Entry<Integer, Integer> entry : map.entrySet()){\\n            if(entry.getValue() > freq){\\n                freq = entry.getValue();\\n                result = entry.getKey();\\n            }\\n            if(entry.getValue() == freq){\\n                result = Math.min(result, entry.getKey());\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078200,
                "title": "java-90-easy-solution",
                "content": "# Intuition\\nMy first thoughts on this problem was to \"pre-process\" the array into a hashmap, where we\\'d fill the hashmap with our even numbers from the array and their frequency then iterate through the hashmap and find it. Another approach I thought of was using a treemap then attempting to use floor and ceiling functions however given we don\\'t have a specific number/condition to look for in terms of our frequency it wasn\\'t possible.\\n\\n# Approach\\nThe approach I took to solving the problem varied from my initial approach. In this case I used a hashmap to store elements and their frequency as we iterate through the array, and if the element we iterate over is even (divisible by 2) then we\\'ll check it\\'s frequency and set our element to it if it\\'s frequency is higher than the maximum frequency we\\'ve seen. But if the frequency is equal to the max we\\'ve seen, we set the our integer to keep track of elements to be the minimum of the element we\\'re iterating over and the element we\\'ve previously seen with the highest frequency.\\n\\nFrom there we return element, which is -1 if there\\'s no even digits in the array, or the smallest even integer in the array with the highest frequency.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ --> The space complexity is based off our for loop, where we iterate through n elements upon every method call\\n\\n- Space complexity:\\n$$O(n)$$ --> The space complexity is based off the worst case, where every element in nums is even so we\\'re adding n elements to our hashmap.\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        int maxCount = 0;\\n        int element = -1;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] % 2 == 0){\\n                int count = map.getOrDefault(nums[i], 0) + 1;\\n                if(count > maxCount) element = nums[i];\\n                else if (count == maxCount) element = Math.min(element, nums[i]);\\n                maxCount = Math.max(count, maxCount);\\n                map.put(nums[i], count);\\n            }            \\n            \\n        } \\n        return element;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        int maxCount = 0;\\n        int element = -1;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] % 2 == 0){\\n                int count = map.getOrDefault(nums[i], 0) + 1;\\n                if(count > maxCount) element = nums[i];\\n                else if (count == maxCount) element = Math.min(element, nums[i]);\\n                maxCount = Math.max(count, maxCount);\\n                map.put(nums[i], count);\\n            }            \\n            \\n        } \\n        return element;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076816,
                "title": "java-hashmap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n    We will only add even elements in the hashmap, and update the\\n    maximum frequency every time.Then we will iterate through the\\n    Hashmap and check if there are elements with maximum frequency\\n    and if there are then we will store the minimum element.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        int element = Integer.MAX_VALUE;\\n        int maxCount = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int n = nums.length;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(nums[i] % 2 == 0){\\n                if(map.containsKey(nums[i])){\\n                    map.put(nums[i],map.get(nums[i]) + 1);\\n                    if(map.get(nums[i]) > maxCount){\\n                        maxCount = map.get(nums[i]);\\n                    }\\n                }\\n                else{\\n                    map.put(nums[i],1);\\n                    if(map.get(nums[i]) > maxCount){\\n                        maxCount = map.get(nums[i]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int key : map.keySet()){\\n           if(map.get(key) == maxCount){\\n                 element = Math.min(element,key);\\n           }\\n        }\\n        if(element == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return element;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        int element = Integer.MAX_VALUE;\\n        int maxCount = 0;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int n = nums.length;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(nums[i] % 2 == 0){\\n                if(map.containsKey(nums[i])){\\n                    map.put(nums[i],map.get(nums[i]) + 1);\\n                    if(map.get(nums[i]) > maxCount){\\n                        maxCount = map.get(nums[i]);\\n                    }\\n                }\\n                else{\\n                    map.put(nums[i],1);\\n                    if(map.get(nums[i]) > maxCount){\\n                        maxCount = map.get(nums[i]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for(int key : map.keySet()){\\n           if(map.get(key) == maxCount){\\n                 element = Math.min(element,key);\\n           }\\n        }\\n        if(element == Integer.MAX_VALUE){\\n            return -1;\\n        }\\n        return element;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074004,
                "title": "hashmap-0-n-solution-without-using-min-or-max",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- filter the input array by checking mod value and adding them in Hashmap\\n- if no even values return -1 \\n- iterate through Hashmap if value matches for two or more keys assign the smaller one by comparison (update mostFrequent and maxcount)\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        count = {}\\n        maxcount = 0 \\n        for num in nums:\\n            if num % 2 == 0:\\n                if num not in count:\\n                    count[num] = 1 \\n                else:\\n                    count[num] += 1\\n\\n        if not count:\\n            return -1\\n        # print(count, maxcount)\\n\\n        mostFrequent = None \\n        for key,value in count.items():\\n            if value > maxcount or (value == maxcount and key < mostFrequent):\\n                mostFrequent = key\\n                maxcount = value\\n        return mostFrequent\\n        \\n\\n        \\n        \\n        \\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        count = {}\\n        maxcount = 0 \\n        for num in nums:\\n            if num % 2 == 0:\\n                if num not in count:\\n                    count[num] = 1 \\n                else:\\n                    count[num] += 1\\n\\n        if not count:\\n            return -1\\n        # print(count, maxcount)\\n\\n        mostFrequent = None \\n        for key,value in count.items():\\n            if value > maxcount or (value == maxcount and key < mostFrequent):\\n                mostFrequent = key\\n                maxcount = value\\n        return mostFrequent\\n        \\n\\n        \\n        \\n        \\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070994,
                "title": "optimize-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        int res = Integer.MAX_VALUE;\\n        int freq = 0;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int num : nums){\\n            if(num%2==0){\\n                map.put(num, map.getOrDefault(num,0)+1);\\n                if(map.get(num) > freq || (map.get(num)==freq && num<res)){\\n                    freq = map.get(num);\\n                    res = num;\\n                }\\n            }\\n        }\\n        return freq==0?-1:res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        int res = Integer.MAX_VALUE;\\n        int freq = 0;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for(int num : nums){\\n            if(num%2==0){\\n                map.put(num, map.getOrDefault(num,0)+1);\\n                if(map.get(num) > freq || (map.get(num)==freq && num<res)){\\n                    freq = map.get(num);\\n                    res = num;\\n                }\\n            }\\n        }\\n        return freq==0?-1:res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069668,
                "title": "python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def mostFrequentEven(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        d={}\\n        l=[]\\n        l1=[]\\n        for i in nums:\\n            if(i%2==0):\\n\\n                if i not in d:\\n                    d[i]=1\\n                else:\\n                    d[i]+=1\\n        if(len(d)==0):\\n            return -1\\n        t=max(d.values())\\n        for j,k in d.items():\\n            if k==t:\\n                l.append(j)\\n        return min(l)\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mostFrequentEven(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        d={}\\n        l=[]\\n        l1=[]\\n        for i in nums:\\n            if(i%2==0):\\n\\n                if i not in d:\\n                    d[i]=1\\n                else:\\n                    d[i]+=1\\n        if(len(d)==0):\\n            return -1\\n        t=max(d.values())\\n        for j,k in d.items():\\n            if k==t:\\n                l.append(j)\\n        return min(l)\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067792,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        t=0\\n        c=0\\n        p=-1\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]%2==0:\\n                t=nums.count(nums[i])\\n                if t>c:\\n                    c=t\\n                    p=nums[i]\\n        return p\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        t=0\\n        c=0\\n        p=-1\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]%2==0:\\n                t=nums.count(nums[i])\\n                if t>c:\\n                    c=t\\n                    p=nums[i]\\n        return p\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066927,
                "title": "o-n-time-complexity-o-1-space-complexity-java-program-using-hashmap",
                "content": "## simple solution using the HashMap\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int maxFreq = 0;\\n        int element = Integer.MAX_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i]%2==0){\\n                if(map.containsKey(nums[i])){\\n                    map.put(nums[i],map.get(nums[i])+1);\\n                }\\n                else{\\n                    map.put(nums[i],1);\\n                }\\n            }\\n        }\\n        \\n        for(int i : map.keySet()){\\n            if(map.get(i)>maxFreq || (map.get(i) == maxFreq && i<element)){\\n                maxFreq = map.get(i);\\n                element = i;\\n            }\\n        }\\n        return maxFreq==0 ? -1 : element;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        int maxFreq = 0;\\n        int element = Integer.MAX_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i]%2==0){\\n                if(map.containsKey(nums[i])){\\n                    map.put(nums[i],map.get(nums[i])+1);\\n                }\\n                else{\\n                    map.put(nums[i],1);\\n                }\\n            }\\n        }\\n        \\n        for(int i : map.keySet()){\\n            if(map.get(i)>maxFreq || (map.get(i) == maxFreq && i<element)){\\n                maxFreq = map.get(i);\\n                element = i;\\n            }\\n        }\\n        return maxFreq==0 ? -1 : element;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066498,
                "title": "python-solution-easy-to-understand-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in set(nums):\\n            if i%2==0: \\n                l.append([i,nums.count(i)])\\n        if l==[]:\\n            return -1\\n        l.sort(key=lambda x: x[0])\\n        stack=[]\\n        for i in l:\\n            if stack==[] or i[1]>stack[0][1]:\\n                stack=[i]\\n        return stack[0][0]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        l=[]\\n        for i in set(nums):\\n            if i%2==0: \\n                l.append([i,nums.count(i)])\\n        if l==[]:\\n            return -1\\n        l.sort(key=lambda x: x[0])\\n        stack=[]\\n        for i in l:\\n            if stack==[] or i[1]>stack[0][1]:\\n                stack=[i]\\n        return stack[0][0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056820,
                "title": "solution-with-a-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        res = 0\\n        count = 0\\n        pre_res = {}\\n        for i in nums:\\n            if i % 2 == 0 or i == 0:\\n                pre_res[i] = pre_res.get(i, 0) + 1\\n        if len(pre_res) == 0:\\n            return -1 \\n        for key in pre_res:\\n            if pre_res[key] > count:\\n                count = pre_res[key]\\n                res = key\\n            elif pre_res[key] == count and res > key:\\n                res = key\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        res = 0\\n        count = 0\\n        pre_res = {}\\n        for i in nums:\\n            if i % 2 == 0 or i == 0:\\n                pre_res[i] = pre_res.get(i, 0) + 1\\n        if len(pre_res) == 0:\\n            return -1 \\n        for key in pre_res:\\n            if pre_res[key] > count:\\n                count = pre_res[key]\\n                res = key\\n            elif pre_res[key] == count and res > key:\\n                res = key\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056777,
                "title": "easy-c-solution-using-unordered-map-o-n-o-n",
                "content": "```c++\\n// USING UNORDERED MAP\\n// Time Complexity: O(N)\\n// Space Complexity: O(N)\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int size = nums.size();\\n        // specify currentElement and it\\'s frequency\\n        int currentElement = -1, currentElementFrequency = 0;\\n\\n        // store element and frequency count\\n        unordered_map<int, int> mp;\\n        for(int i=0;i<size;i+=1) {\\n            mp[nums[i]] += 1;\\n        }\\n\\n        // iterator for map\\n        unordered_map<int, int> :: iterator it;\\n        // traverse map and find the suitable element\\n        for(it=mp.begin();it!=mp.end();it++) {\\n            // if element is even then consider element otherwise not\\n            if(it->first % 2 == 0) {\\n                // if element frequency is > currentElementFrequency\\n                // then update currentElement and currentElementFrequency\\n                if(it->second > currentElementFrequency) {\\n                    currentElement = it->first;\\n                    currentElementFrequency = it->second;\\n                }\\n                // if element and currentElementFrequency are equal then,\\n                // try to store smaller currentElement and it\\'s corresponding frequency\\n                else if(it->second == currentElementFrequency) {\\n                    if(it->first < currentElement) {\\n                        currentElement = it->first;\\n                        currentElementFrequency = it->second;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // return currentElement or -1 -- if no element found\\n        return currentElement;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```c++\\n// USING UNORDERED MAP\\n// Time Complexity: O(N)\\n// Space Complexity: O(N)\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int size = nums.size();\\n        // specify currentElement and it\\'s frequency\\n        int currentElement = -1, currentElementFrequency = 0;\\n\\n        // store element and frequency count\\n        unordered_map<int, int> mp;\\n        for(int i=0;i<size;i+=1) {\\n            mp[nums[i]] += 1;\\n        }\\n\\n        // iterator for map\\n        unordered_map<int, int> :: iterator it;\\n        // traverse map and find the suitable element\\n        for(it=mp.begin();it!=mp.end();it++) {\\n            // if element is even then consider element otherwise not\\n            if(it->first % 2 == 0) {\\n                // if element frequency is > currentElementFrequency\\n                // then update currentElement and currentElementFrequency\\n                if(it->second > currentElementFrequency) {\\n                    currentElement = it->first;\\n                    currentElementFrequency = it->second;\\n                }\\n                // if element and currentElementFrequency are equal then,\\n                // try to store smaller currentElement and it\\'s corresponding frequency\\n                else if(it->second == currentElementFrequency) {\\n                    if(it->first < currentElement) {\\n                        currentElement = it->first;\\n                        currentElementFrequency = it->second;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // return currentElement or -1 -- if no element found\\n        return currentElement;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054100,
                "title": "beats-33-with-java-hash-map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        Map<Integer,Integer> map  = new HashMap<>();\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] % 2 == 0){\\n                if(map.containsKey(nums[i])){\\n                    map.put(nums[i],map.get(nums[i]) + 1);\\n                }\\n                else{\\n                    map.put(nums[i],1);\\n                }\\n            }\\n        }\\n\\n        if(map.isEmpty()) return -1;\\n\\n        Object[] keys = map.keySet().toArray();\\n        Arrays.sort(keys);\\n        int maxKey = (int) keys[0];\\n        for(int i=1;i<keys.length;i++){\\n            int val = map.get((int)keys[i]);\\n            if(val > map.get(maxKey)){\\n                maxKey = (int) keys[i];\\n            }\\n        }\\n\\n        return maxKey;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        Map<Integer,Integer> map  = new HashMap<>();\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i] % 2 == 0){\\n                if(map.containsKey(nums[i])){\\n                    map.put(nums[i],map.get(nums[i]) + 1);\\n                }\\n                else{\\n                    map.put(nums[i],1);\\n                }\\n            }\\n        }\\n\\n        if(map.isEmpty()) return -1;\\n\\n        Object[] keys = map.keySet().toArray();\\n        Arrays.sort(keys);\\n        int maxKey = (int) keys[0];\\n        for(int i=1;i<keys.length;i++){\\n            int val = map.get((int)keys[i]);\\n            if(val > map.get(maxKey)){\\n                maxKey = (int) keys[i];\\n            }\\n        }\\n\\n        return maxKey;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053279,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int>mp;\\n        int max_freq=-1;\\n        int max_no=-1;\\n        for(auto i : nums)\\n        {\\n            mp[i]++;\\n        }\\n        for(auto it : mp)\\n        {\\n            if(it.first%2==0 && it.second>max_freq){\\n                max_no=it.first;\\n                max_freq=it.second;\\n            }            \\n        }\\n        return max_no;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        map<int,int>mp;\\n        int max_freq=-1;\\n        int max_no=-1;\\n        for(auto i : nums)\\n        {\\n            mp[i]++;\\n        }\\n        for(auto it : mp)\\n        {\\n            if(it.first%2==0 && it.second>max_freq){\\n                max_no=it.first;\\n                max_freq=it.second;\\n            }            \\n        }\\n        return max_no;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049980,
                "title": "java-using-map-very-simple-and-easy-to-understand",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i:nums)\\n            if(i==0 || i%2==0)\\n                map.put(i,map.getOrDefault(i,0)+1);\\n        int max=-1,max_num=0;\\n        // System.out.print(map.get(2));\\n        for(int i:map.keySet()){\\n            if(map.get(i)>max_num){\\n                max = i;\\n                max_num=map.get(i);\\n                // System.out.println(max);\\n            }else if(map.get(i) == max_num){\\n                max = Math.min(max,i);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i:nums)\\n            if(i==0 || i%2==0)\\n                map.put(i,map.getOrDefault(i,0)+1);\\n        int max=-1,max_num=0;\\n        // System.out.print(map.get(2));\\n        for(int i:map.keySet()){\\n            if(map.get(i)>max_num){\\n                max = i;\\n                max_num=map.get(i);\\n                // System.out.println(max);\\n            }else if(map.get(i) == max_num){\\n                max = Math.min(max,i);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048797,
                "title": "lowest-value-dependency",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MostFrequentEven(int[] nums) {\\n        Array.Sort(nums);\\n            var g = nums.Where(y => y % 2 == 0);\\n            var k = g.GroupBy(x => x).Select(z => new { key = z.Key, Count = z.Count() });\\n            int max = 0;\\n            var getc = 0;\\n            int m=0;\\n           if(k.Count() > 0)\\n            {\\n                foreach (var x in k)\\n                {\\n                    if (x.Count > getc)\\n                    {\\n                         getc = x.Count;\\n                        m = x.key;\\n                    }\\n                }\\n                return m;\\n            }\\n            return -1;\\n}\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MostFrequentEven(int[] nums) {\\n        Array.Sort(nums);\\n            var g = nums.Where(y => y % 2 == 0);\\n            var k = g.GroupBy(x => x).Select(z => new { key = z.Key, Count = z.Count() });\\n            int max = 0;\\n            var getc = 0;\\n            int m=0;\\n           if(k.Count() > 0)\\n            {\\n                foreach (var x in k)\\n                {\\n                    if (x.Count > getc)\\n                    {\\n                         getc = x.Count;\\n                        m = x.key;\\n                    }\\n                }\\n                return m;\\n            }\\n            return -1;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041304,
                "title": "easy-hashmap-solution-o-n-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int mostFrequentEven(int[] nums) {\\n        HashMap<Integer, Integer> mp = new HashMap<>();\\n//        int minElement=Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] % 2 == 0) {\\n                if (mp.containsKey(nums[i])) {\\n                    mp.put(nums[i], mp.get(nums[i]) + 1);\\n                } else {\\n                    mp.put(nums[i], 1);\\n                }\\n            }\\n        }\\n         if(mp.size()==0) return -1;\\n        int maxFreq = 1, anskey = Integer.MAX_VALUE;\\n        for (var ele : mp.entrySet()) {\\n            if (ele.getValue() >= maxFreq) {\\n                if (ele.getValue() == maxFreq) {\\n                    anskey = Math.min(anskey, ele.getKey());\\n                } else {\\n                    maxFreq = ele.getValue();\\n                    anskey = ele.getKey();\\n                }\\n\\n            }\\n        }\\n        return anskey;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int mostFrequentEven(int[] nums) {\\n        HashMap<Integer, Integer> mp = new HashMap<>();\\n//        int minElement=Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] % 2 == 0) {\\n                if (mp.containsKey(nums[i])) {\\n                    mp.put(nums[i], mp.get(nums[i]) + 1);\\n                } else {\\n                    mp.put(nums[i], 1);\\n                }\\n            }\\n        }\\n         if(mp.size()==0) return -1;\\n        int maxFreq = 1, anskey = Integer.MAX_VALUE;\\n        for (var ele : mp.entrySet()) {\\n            if (ele.getValue() >= maxFreq) {\\n                if (ele.getValue() == maxFreq) {\\n                    anskey = Math.min(anskey, ele.getKey());\\n                } else {\\n                    maxFreq = ele.getValue();\\n                    anskey = ele.getKey();\\n                }\\n\\n            }\\n        }\\n        return anskey;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035997,
                "title": "most-frequent-even-element-the-easiest-approach",
                "content": "# Intuition\\nalways see whether we can use the hashmap or not\\n\\n# Approach\\nstart part by part\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        HashMap<Integer, Integer> h= new HashMap<Integer, Integer>();\\n        for(int i=0; i<nums.length; i++){\\n            if(h.containsKey(nums[i])){\\n                h.put(nums[i], h.get(nums[i])+1);\\n            }\\n            else{\\n                h.put(nums[i], 1);\\n            }\\n        }\\n        int even=0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]%2==0){\\n                even++;\\n            }\\n        }\\n        int great=0;\\n        int great_key=0;\\n        for(int key: h.keySet()){\\n            if(h.get(key)>great && key%2==0){\\n                great=h.get(key);\\n                great_key=key;\\n            }\\n            else if(h.get(key)==great && key%2==0){\\n                if(key<great_key){\\n                    great_key=key;\\n                }\\n            }\\n        }\\n        if(even==0){\\n            return -1;\\n        }\\n        return great_key;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        HashMap<Integer, Integer> h= new HashMap<Integer, Integer>();\\n        for(int i=0; i<nums.length; i++){\\n            if(h.containsKey(nums[i])){\\n                h.put(nums[i], h.get(nums[i])+1);\\n            }\\n            else{\\n                h.put(nums[i], 1);\\n            }\\n        }\\n        int even=0;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]%2==0){\\n                even++;\\n            }\\n        }\\n        int great=0;\\n        int great_key=0;\\n        for(int key: h.keySet()){\\n            if(h.get(key)>great && key%2==0){\\n                great=h.get(key);\\n                great_key=key;\\n            }\\n            else if(h.get(key)==great && key%2==0){\\n                if(key<great_key){\\n                    great_key=key;\\n                }\\n            }\\n        }\\n        if(even==0){\\n            return -1;\\n        }\\n        return great_key;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027402,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar mostFrequentEven = function(nums) {\\n    let map = new Map()\\n    let k =[]\\n    let max = 0\\n    nums.forEach(a=>{\\n        if(a%2==0)\\n        {\\n            if(map.has(a))map.set(a,map.get(a)+1)\\n            else{\\n                map.set(a,1)\\n            }\\n            if(max<map.get(a))max = map.get(a)\\n        }\\n    })\\n    for(let[key,val] of map)\\n    {\\n        if(val == max )\\n        {\\n            k.push(key)\\n        }\\n    }\\n    if(k.length>0)\\n    {\\n        return Math.min(...k)\\n    }\\n    else{\\n        return -1\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar mostFrequentEven = function(nums) {\\n    let map = new Map()\\n    let k =[]\\n    let max = 0\\n    nums.forEach(a=>{\\n        if(a%2==0)\\n        {\\n            if(map.has(a))map.set(a,map.get(a)+1)\\n            else{\\n                map.set(a,1)\\n            }\\n            if(max<map.get(a))max = map.get(a)\\n        }\\n    })\\n    for(let[key,val] of map)\\n    {\\n        if(val == max )\\n        {\\n            k.push(key)\\n        }\\n    }\\n    if(k.length>0)\\n    {\\n        return Math.min(...k)\\n    }\\n    else{\\n        return -1\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4026054,
                "title": "java-and-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Java\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        List<Integer> list = new ArrayList<>();\\n        int val = 0;\\n        for(int num: nums){\\n            if(num % 2== 0) {\\n                map.putIfAbsent(num, 0);\\n                int temp = map.get(num) + 1;\\n                val = Math.max(temp, val);\\n                map.put(num, temp);\\n                list.add(num);\\n            }\\n        }\\n        \\n        Collections.sort(list);\\n\\n        for(int key : list){\\n            if(map.get(key) == val){\\n                return key;\\n            }\\n        }\\n        return -1;  \\n    }\\n}\\n```\\n\\n# Python\\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        dic = dict()\\n        for num in set(nums):\\n            if num % 2 == 0:\\n                dic[num] = nums.count(num)\\n        if len(dic) != 0:\\n            sorteddic = dict(sorted(dic.items(), key = lambda x:(-x[1], x[0])))\\n            print(sorteddic)\\n            for key, val in sorteddic.items():\\n                return key\\n        return -1\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        List<Integer> list = new ArrayList<>();\\n        int val = 0;\\n        for(int num: nums){\\n            if(num % 2== 0) {\\n                map.putIfAbsent(num, 0);\\n                int temp = map.get(num) + 1;\\n                val = Math.max(temp, val);\\n                map.put(num, temp);\\n                list.add(num);\\n            }\\n        }\\n        \\n        Collections.sort(list);\\n\\n        for(int key : list){\\n            if(map.get(key) == val){\\n                return key;\\n            }\\n        }\\n        return -1;  \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        dic = dict()\\n        for num in set(nums):\\n            if num % 2 == 0:\\n                dic[num] = nums.count(num)\\n        if len(dic) != 0:\\n            sorteddic = dict(sorted(dic.items(), key = lambda x:(-x[1], x[0])))\\n            print(sorteddic)\\n            for key, val in sorteddic.items():\\n                return key\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025237,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n\\n        int max=0,max_element=-1;\\n        map<int,int> m;\\n        for(auto k:nums){\\n            m[k]++;\\n        }\\n        for(auto pair:m){\\n            if(pair.second>max && pair.first%2==0){\\n                max=pair.second;\\n                max_element = pair.first;\\n            }\\n        }\\n        \\n        return max_element;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n\\n        int max=0,max_element=-1;\\n        map<int,int> m;\\n        for(auto k:nums){\\n            m[k]++;\\n        }\\n        for(auto pair:m){\\n            if(pair.second>max && pair.first%2==0){\\n                max=pair.second;\\n                max_element = pair.first;\\n            }\\n        }\\n        \\n        return max_element;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025077,
                "title": "beginner-friendly-easy-to-understand-iterative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n      Arrays.sort(nums);\\n      int count = 0,max = 0, maximum = -1;\\n      for(int i = 0; i < nums.length; i++){\\n          count = 0; \\n\\n          if(nums[i] % 2 == 0){\\n              for(int j = 0; j < nums.length; j++){\\n                  if(nums[i] == nums[j]){\\n                      count++;\\n                  }\\n              }\\n          }\\n\\n          if(count > max){\\n              max = count;\\n              maximum = nums[i];\\n          }\\n      } \\n\\n        return maximum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n      Arrays.sort(nums);\\n      int count = 0,max = 0, maximum = -1;\\n      for(int i = 0; i < nums.length; i++){\\n          count = 0; \\n\\n          if(nums[i] % 2 == 0){\\n              for(int j = 0; j < nums.length; j++){\\n                  if(nums[i] == nums[j]){\\n                      count++;\\n                  }\\n              }\\n          }\\n\\n          if(count > max){\\n              max = count;\\n              maximum = nums[i];\\n          }\\n      } \\n\\n        return maximum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018911,
                "title": "most-frequent-even-element",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        int num[][]=new int[2][1];\\n        TreeMap<Integer,Integer> hm=new TreeMap<>();\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==0){\\n                hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);\\n            }\\n        }\\n        if(hm.size()==0)\\n        return -1;\\n        Set<Integer> keys=hm.keySet();\\n        for(int k:keys){\\n            if(hm.get(k)==num[1][0])\\n            continue;\\n            if(hm.get(k)>num[1][0]){\\n                num[0][0]=k;\\n                num[1][0]=hm.get(k);\\n            }\\n        }\\n\\n        return num[0][0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        int num[][]=new int[2][1];\\n        TreeMap<Integer,Integer> hm=new TreeMap<>();\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==0){\\n                hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);\\n            }\\n        }\\n        if(hm.size()==0)\\n        return -1;\\n        Set<Integer> keys=hm.keySet();\\n        for(int k:keys){\\n            if(hm.get(k)==num[1][0])\\n            continue;\\n            if(hm.get(k)>num[1][0]){\\n                num[0][0]=k;\\n                num[1][0]=hm.get(k);\\n            }\\n        }\\n\\n        return num[0][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017861,
                "title": "solution-in-python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        nums=[x for x in nums if x%2==0]\\n        arr=float(\"inf\")\\n        if len(nums)==0:\\n            return -1 \\n        z=nums.count(max(nums,key=nums.count)) \\n        for t in set(nums):\\n            if z==nums.count(t):\\n                if arr>t :\\n                    arr=t\\n        if arr==float(\"inf\"):\\n            return -1 \\n        return arr\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        nums=[x for x in nums if x%2==0]\\n        arr=float(\"inf\")\\n        if len(nums)==0:\\n            return -1 \\n        z=nums.count(max(nums,key=nums.count)) \\n        for t in set(nums):\\n            if z==nums.count(t):\\n                if arr>t :\\n                    arr=t\\n        if arr==float(\"inf\"):\\n            return -1 \\n        return arr\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012843,
                "title": "easy-java-solution-using-hashmap-and-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        \\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        int maxFreq=-1;\\n         int res=-1;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==0){\\n                if(hm.containsKey(nums[i])){\\n                    int val=hm.get(nums[i]);\\n                    hm.put(nums[i],val+1);\\n                }else{\\n                    hm.put(nums[i],1);\\n                }\\n            }\\n\\n            }\\n\\n            for(int num:hm.keySet()){\\n                if(hm.get(num)>maxFreq){\\n                    maxFreq=hm.get(num);\\n                    res=num;\\n                }else if(hm.get(num)==maxFreq && res>num){\\n                    res=num;\\n                }\\n            }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        \\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        int maxFreq=-1;\\n         int res=-1;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]%2==0){\\n                if(hm.containsKey(nums[i])){\\n                    int val=hm.get(nums[i]);\\n                    hm.put(nums[i],val+1);\\n                }else{\\n                    hm.put(nums[i],1);\\n                }\\n            }\\n\\n            }\\n\\n            for(int num:hm.keySet()){\\n                if(hm.get(num)>maxFreq){\\n                    maxFreq=hm.get(num);\\n                    res=num;\\n                }else if(hm.get(num)==maxFreq && res>num){\\n                    res=num;\\n                }\\n            }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011149,
                "title": "easy-to-understand-for-beginner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        unordered_map<int,int> h;\\n        for(auto i:nums)\\n        {\\n            if(i%2==0)\\n            h[i]++;\\n        }\\n\\n        int maxi=0;\\n        int value=-1;\\n        for(auto x:h)\\n        {\\n            if(x.second>maxi)\\n            {\\n                maxi=x.second;\\n                value=x.first;\\n            }\\n            if(x.second==maxi)\\n            {\\n                value=min(value,x.first);\\n            }\\n        }\\n        return value;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        unordered_map<int,int> h;\\n        for(auto i:nums)\\n        {\\n            if(i%2==0)\\n            h[i]++;\\n        }\\n\\n        int maxi=0;\\n        int value=-1;\\n        for(auto x:h)\\n        {\\n            if(x.second>maxi)\\n            {\\n                maxi=x.second;\\n                value=x.first;\\n            }\\n            if(x.second==maxi)\\n            {\\n                value=min(value,x.first);\\n            }\\n        }\\n        return value;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004761,
                "title": "easy-method-most-frequent-even-element-try-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n\\n\\n        map<int,int>mp;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                mp[nums[i]]++;\\n            }\\n        }\\n\\n        int maxi=0;\\n\\n        for(auto i:mp)\\n        {\\n            maxi=max(maxi,i.second);\\n        }\\n\\n        if(mp.size()>0)\\n        {\\n        for(auto i:mp)\\n        {\\n            if(i.second==maxi)\\n            {\\n                return i.first;\\n            }\\n        }\\n        }\\n        else\\n        {\\n            return -1;\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        int n=nums.size();\\n        \\n\\n\\n        map<int,int>mp;\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]%2==0)\\n            {\\n                mp[nums[i]]++;\\n            }\\n        }\\n\\n        int maxi=0;\\n\\n        for(auto i:mp)\\n        {\\n            maxi=max(maxi,i.second);\\n        }\\n\\n        if(mp.size()>0)\\n        {\\n        for(auto i:mp)\\n        {\\n            if(i.second==maxi)\\n            {\\n                return i.first;\\n            }\\n        }\\n        }\\n        else\\n        {\\n            return -1;\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001714,
                "title": "python-solution-without-using-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def mostFrequentEven(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # number=list(set(nums))\\n        # number.sort()\\n        # print(number)\\n        count=0\\n        element=-1\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]%2==0:\\n                if nums.count(nums[i])>count:\\n                    element=nums[i]\\n                    print(nums.count(nums[i]),element)\\n                    count=nums.count(nums[i])\\n        return element\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def mostFrequentEven(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # number=list(set(nums))\\n        # number.sort()\\n        # print(number)\\n        count=0\\n        element=-1\\n        nums.sort()\\n        for i in range(len(nums)):\\n            if nums[i]%2==0:\\n                if nums.count(nums[i])>count:\\n                    element=nums[i]\\n                    print(nums.count(nums[i]),element)\\n                    count=nums.count(nums[i])\\n        return element\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999249,
                "title": "used-sorting-o-n-log-n",
                "content": "# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n\\n### You can also solve it by using map but, I tried sorting just for fun.\\n# Complexity\\n- Time complexity: $$O(n.log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        //special case if there\\'s only 1 element in the array.\\n        if(nums.size() == 1 && nums[0]%2 == 0)\\n            return nums[0];\\n\\n        //Real code starts from here.\\n        \\n        //Sorting to make our counting easy.\\n        sort(begin(nums), end(nums));\\n\\n        vector<int> even;\\n\\n        //storing only even nos.\\n        for(auto i:nums)\\n            if(i%2 == 0)\\n                even.push_back(i);\\n\\n        //if nothing is stored then all elements must be odd.\\n        if(even.size() == 0)\\n            return -1;\\n\\n        // if there\\'s only  1 element then return it.\\n        if(even.size() == 1)\\n            return even[0];\\n\\n\\n        int cnt=1,ans=0,maxFreq=INT_MIN;\\n\\n        for(int i=0; i<even.size()-1; i++)\\n        {\\n            //strat counting frequent even nos.\\n            if(even[i] == even[i+1])\\n                cnt++;\\n            \\n            // if we get a new cnt then update maxFreq \\n            // & store the new answer\\n            if(cnt > maxFreq)\\n            {\\n                ans = even[i];\\n                maxFreq = cnt;\\n            }\\n\\n            //when the adjacent element is not same\\n            // then reset count to 1.\\n            if(even[i] != even[i+1])\\n                cnt=1;\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```\\n![Leetcode Upvote.gif](https://assets.leetcode.com/users/images/ddb58277-f81d-40f9-927f-046720177d8e_1683052648.39132.gif)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mostFrequentEven(vector<int>& nums) {\\n        //special case if there\\'s only 1 element in the array.\\n        if(nums.size() == 1 && nums[0]%2 == 0)\\n            return nums[0];\\n\\n        //Real code starts from here.\\n        \\n        //Sorting to make our counting easy.\\n        sort(begin(nums), end(nums));\\n\\n        vector<int> even;\\n\\n        //storing only even nos.\\n        for(auto i:nums)\\n            if(i%2 == 0)\\n                even.push_back(i);\\n\\n        //if nothing is stored then all elements must be odd.\\n        if(even.size() == 0)\\n            return -1;\\n\\n        // if there\\'s only  1 element then return it.\\n        if(even.size() == 1)\\n            return even[0];\\n\\n\\n        int cnt=1,ans=0,maxFreq=INT_MIN;\\n\\n        for(int i=0; i<even.size()-1; i++)\\n        {\\n            //strat counting frequent even nos.\\n            if(even[i] == even[i+1])\\n                cnt++;\\n            \\n            // if we get a new cnt then update maxFreq \\n            // & store the new answer\\n            if(cnt > maxFreq)\\n            {\\n                ans = even[i];\\n                maxFreq = cnt;\\n            }\\n\\n            //when the adjacent element is not same\\n            // then reset count to 1.\\n            if(even[i] != even[i+1])\\n                cnt=1;\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984997,
                "title": "easy-to-understand-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d = Counter(nums)\\n\\n        d = dict(sorted(d.items(), key=lambda x:(-x[1], x[0])))\\n\\n        for key in d:\\n            if key % 2 == 0:\\n                return key\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d = Counter(nums)\\n\\n        d = dict(sorted(d.items(), key=lambda x:(-x[1], x[0])))\\n\\n        for key in d:\\n            if key % 2 == 0:\\n                return key\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984706,
                "title": "java-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nadd all even element in a hashmap keeping track of the number of time they repeat, then select the smallest of the ones that repeat the most.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(e)$$ where e is the quantity of even number in the first array nums. \\n\\n# Code\\n```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        HashMap <Integer, Integer> map = new HashMap<>();\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] % 2 == 0){\\n                if(!map.containsKey(nums[i])) map.put(nums[i], 1);\\n                else map.put(nums[i], map.get(nums[i]) + 1);\\n            }\\n        }\\n\\n        int mostFrequency = 0;\\n        int mostFrequentNum = -1;\\n        for (Map.Entry<Integer, Integer> mapElement : map.entrySet()) {\\n            int key = mapElement.getKey();\\n            int frequency = (mapElement.getValue());\\n            if(frequency > mostFrequency || (frequency == mostFrequency && key < mostFrequentNum)){\\n                mostFrequency = frequency;\\n                mostFrequentNum = key;\\n            }   \\n        }\\n        return mostFrequentNum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mostFrequentEven(int[] nums) {\\n        HashMap <Integer, Integer> map = new HashMap<>();\\n\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] % 2 == 0){\\n                if(!map.containsKey(nums[i])) map.put(nums[i], 1);\\n                else map.put(nums[i], map.get(nums[i]) + 1);\\n            }\\n        }\\n\\n        int mostFrequency = 0;\\n        int mostFrequentNum = -1;\\n        for (Map.Entry<Integer, Integer> mapElement : map.entrySet()) {\\n            int key = mapElement.getKey();\\n            int frequency = (mapElement.getValue());\\n            if(frequency > mostFrequency || (frequency == mostFrequency && key < mostFrequentNum)){\\n                mostFrequency = frequency;\\n                mostFrequentNum = key;\\n            }   \\n        }\\n        return mostFrequentNum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1752915,
                "content": [
                    {
                        "username": "shaileshps21",
                        "content": "use a ordered_map and you can solve it with much ease and in a limited time...u can check my soln also\\n"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "[8154,9139,8194,3346,5450,9190,133,8239,4606,8671,8412,6290]\\noutput :  8194\\nExpected : 3346\\n\\nwhy expected output is 3346, i think  both answer are valid."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "beacuse when the count of even numbers is same we have to return the min value:\\nfrom collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=Counter(nums)\\n        l=[]\\n        l1=[]\\n        s=0\\n        c=0\\n        for key,val in d.items():\\n             if key%2==0:\\n                 if val>s:\\n                     c+=1\\n                     s=val\\n        if c==0:\\n            return -1\\n        else:\\n            for key,val in d.items():\\n                if val==s and key%2==0:\\n                    l1.append(key)\\n            return min(l1)\\n                "
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "Hello, I am getting an error in leetcode, where as it works fine in intellij for the line\\n` int maxValue = Collections.max(hashMap.values());`\\njava.util.NoSuchElementException\\n  at line 1599, java.base/java.util.HashMap$HashIterator.nextNode\\n  at line 1625, java.base/java.util.HashMap$ValueIterator.next\\n  at line 674, java.base/java.util.Collections.max\\n  at line 19, Solution.mostFrequentEven\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nMy complete code is :\\n int res=0;int count=0;\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\\n        for (int i=0;i<nums.length;i++){\\n            for (int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j])\\n                    count++;\\n            }\\n            if(nums[i]%2==0) {\\n                hashMap.put(nums[i], count);\\n            }\\n            count=0;\\n        }\\n        int maxValue = Collections.max(hashMap.values());\\n        res=maxValue;\\n        return res;\\n\\nPlease suggest.\\n"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "Can anyone explain why variable and max are ans here -1\\n\\n```\\nmap<int, int> mp;\\n\\n        for (const auto it : nums) {\\n                mp[it]++;\\n        }\\n        int ans = -1, max = - 1;\\n\\n        for (const auto m : mp) {\\n            if (m.first % 2 == 0 && m.second > max) {\\n                ans = m.first;\\n                max = m.second;\\n            }\\n        }\\n\\n```\\n"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "beacuse in  every condition in for loop not satisfy so your value is return as per declare. ---------------->\\n"
                    },
                    {
                        "username": "shaileshps21",
                        "content": "can u please explain the workflow of your soln"
                    },
                    {
                        "username": "Libaca",
                        "content": "Why {0,0,0,0} have to show 0 and not 4?"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Question asks to send the \"most frequent element \" not the frequency itself.\\nHope it helps."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This might be easy in python but its harder in c# (without using linq and all that stuff)"
                    },
                    {
                        "username": "topswe",
                        "content": "    # 1. use Counter of even elements\\n    # 2. take max of Counter with custom key to tiebreak using smallest, default = -1"
                    },
                    {
                        "username": "topswe",
                        "content": "see my solution: https://leetcode.com/problems/most-frequent-even-element/solutions/2815027/python-1-line-optimal-and-clean-with-explanation-2-ways-o-n-time-and-o-n-space/"
                    },
                    {
                        "username": "Ankit_Kumar_",
                        "content": "how do we compare the elements if the frequency is same for two numbers and print the smallest number ??any easier way other than doing it in the way provided in solutions\\n"
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "from collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=Counter(nums)\\n        l1=[]\\n        s=0\\n        c=0\\n        for key,val in d.items():\\n             if key%2==0:\\n                 if val>s:\\n                     c+=1\\n                     s=val\\n        if c==0:\\n            return -1\\n        else:\\n            for key,val in d.items():\\n                if val==s and key%2==0:\\n                    l1.append(key)\\n            return min(l1)\\n#python\\n                "
                    },
                    {
                        "username": "dangsonbk",
                        "content": "[@topswe](/topswe) or we can simply sort the list before input it into `Counter()` function."
                    },
                    {
                        "username": "topswe",
                        "content": "[@topswe](/topswe) see: https://leetcode.com/problems/most-frequent-even-element/solutions/2815027/python-1-line-optimal-and-clean-with-explanation-2-ways-o-n-time-and-o-n-space/"
                    },
                    {
                        "username": "topswe",
                        "content": "In python, you can use a custom lambda in the max function to tiebreak."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2404_Most_Frequent_Even_Element.cpp"
                    }
                ]
            },
            {
                "id": 2026648,
                "content": [
                    {
                        "username": "shaileshps21",
                        "content": "use a ordered_map and you can solve it with much ease and in a limited time...u can check my soln also\\n"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "[8154,9139,8194,3346,5450,9190,133,8239,4606,8671,8412,6290]\\noutput :  8194\\nExpected : 3346\\n\\nwhy expected output is 3346, i think  both answer are valid."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "beacuse when the count of even numbers is same we have to return the min value:\\nfrom collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=Counter(nums)\\n        l=[]\\n        l1=[]\\n        s=0\\n        c=0\\n        for key,val in d.items():\\n             if key%2==0:\\n                 if val>s:\\n                     c+=1\\n                     s=val\\n        if c==0:\\n            return -1\\n        else:\\n            for key,val in d.items():\\n                if val==s and key%2==0:\\n                    l1.append(key)\\n            return min(l1)\\n                "
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "Hello, I am getting an error in leetcode, where as it works fine in intellij for the line\\n` int maxValue = Collections.max(hashMap.values());`\\njava.util.NoSuchElementException\\n  at line 1599, java.base/java.util.HashMap$HashIterator.nextNode\\n  at line 1625, java.base/java.util.HashMap$ValueIterator.next\\n  at line 674, java.base/java.util.Collections.max\\n  at line 19, Solution.mostFrequentEven\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nMy complete code is :\\n int res=0;int count=0;\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\\n        for (int i=0;i<nums.length;i++){\\n            for (int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j])\\n                    count++;\\n            }\\n            if(nums[i]%2==0) {\\n                hashMap.put(nums[i], count);\\n            }\\n            count=0;\\n        }\\n        int maxValue = Collections.max(hashMap.values());\\n        res=maxValue;\\n        return res;\\n\\nPlease suggest.\\n"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "Can anyone explain why variable and max are ans here -1\\n\\n```\\nmap<int, int> mp;\\n\\n        for (const auto it : nums) {\\n                mp[it]++;\\n        }\\n        int ans = -1, max = - 1;\\n\\n        for (const auto m : mp) {\\n            if (m.first % 2 == 0 && m.second > max) {\\n                ans = m.first;\\n                max = m.second;\\n            }\\n        }\\n\\n```\\n"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "beacuse in  every condition in for loop not satisfy so your value is return as per declare. ---------------->\\n"
                    },
                    {
                        "username": "shaileshps21",
                        "content": "can u please explain the workflow of your soln"
                    },
                    {
                        "username": "Libaca",
                        "content": "Why {0,0,0,0} have to show 0 and not 4?"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Question asks to send the \"most frequent element \" not the frequency itself.\\nHope it helps."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This might be easy in python but its harder in c# (without using linq and all that stuff)"
                    },
                    {
                        "username": "topswe",
                        "content": "    # 1. use Counter of even elements\\n    # 2. take max of Counter with custom key to tiebreak using smallest, default = -1"
                    },
                    {
                        "username": "topswe",
                        "content": "see my solution: https://leetcode.com/problems/most-frequent-even-element/solutions/2815027/python-1-line-optimal-and-clean-with-explanation-2-ways-o-n-time-and-o-n-space/"
                    },
                    {
                        "username": "Ankit_Kumar_",
                        "content": "how do we compare the elements if the frequency is same for two numbers and print the smallest number ??any easier way other than doing it in the way provided in solutions\\n"
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "from collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=Counter(nums)\\n        l1=[]\\n        s=0\\n        c=0\\n        for key,val in d.items():\\n             if key%2==0:\\n                 if val>s:\\n                     c+=1\\n                     s=val\\n        if c==0:\\n            return -1\\n        else:\\n            for key,val in d.items():\\n                if val==s and key%2==0:\\n                    l1.append(key)\\n            return min(l1)\\n#python\\n                "
                    },
                    {
                        "username": "dangsonbk",
                        "content": "[@topswe](/topswe) or we can simply sort the list before input it into `Counter()` function."
                    },
                    {
                        "username": "topswe",
                        "content": "[@topswe](/topswe) see: https://leetcode.com/problems/most-frequent-even-element/solutions/2815027/python-1-line-optimal-and-clean-with-explanation-2-ways-o-n-time-and-o-n-space/"
                    },
                    {
                        "username": "topswe",
                        "content": "In python, you can use a custom lambda in the max function to tiebreak."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2404_Most_Frequent_Even_Element.cpp"
                    }
                ]
            },
            {
                "id": 1792288,
                "content": [
                    {
                        "username": "shaileshps21",
                        "content": "use a ordered_map and you can solve it with much ease and in a limited time...u can check my soln also\\n"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "[8154,9139,8194,3346,5450,9190,133,8239,4606,8671,8412,6290]\\noutput :  8194\\nExpected : 3346\\n\\nwhy expected output is 3346, i think  both answer are valid."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "beacuse when the count of even numbers is same we have to return the min value:\\nfrom collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=Counter(nums)\\n        l=[]\\n        l1=[]\\n        s=0\\n        c=0\\n        for key,val in d.items():\\n             if key%2==0:\\n                 if val>s:\\n                     c+=1\\n                     s=val\\n        if c==0:\\n            return -1\\n        else:\\n            for key,val in d.items():\\n                if val==s and key%2==0:\\n                    l1.append(key)\\n            return min(l1)\\n                "
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "Hello, I am getting an error in leetcode, where as it works fine in intellij for the line\\n` int maxValue = Collections.max(hashMap.values());`\\njava.util.NoSuchElementException\\n  at line 1599, java.base/java.util.HashMap$HashIterator.nextNode\\n  at line 1625, java.base/java.util.HashMap$ValueIterator.next\\n  at line 674, java.base/java.util.Collections.max\\n  at line 19, Solution.mostFrequentEven\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nMy complete code is :\\n int res=0;int count=0;\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\\n        for (int i=0;i<nums.length;i++){\\n            for (int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j])\\n                    count++;\\n            }\\n            if(nums[i]%2==0) {\\n                hashMap.put(nums[i], count);\\n            }\\n            count=0;\\n        }\\n        int maxValue = Collections.max(hashMap.values());\\n        res=maxValue;\\n        return res;\\n\\nPlease suggest.\\n"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "Can anyone explain why variable and max are ans here -1\\n\\n```\\nmap<int, int> mp;\\n\\n        for (const auto it : nums) {\\n                mp[it]++;\\n        }\\n        int ans = -1, max = - 1;\\n\\n        for (const auto m : mp) {\\n            if (m.first % 2 == 0 && m.second > max) {\\n                ans = m.first;\\n                max = m.second;\\n            }\\n        }\\n\\n```\\n"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "beacuse in  every condition in for loop not satisfy so your value is return as per declare. ---------------->\\n"
                    },
                    {
                        "username": "shaileshps21",
                        "content": "can u please explain the workflow of your soln"
                    },
                    {
                        "username": "Libaca",
                        "content": "Why {0,0,0,0} have to show 0 and not 4?"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Question asks to send the \"most frequent element \" not the frequency itself.\\nHope it helps."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This might be easy in python but its harder in c# (without using linq and all that stuff)"
                    },
                    {
                        "username": "topswe",
                        "content": "    # 1. use Counter of even elements\\n    # 2. take max of Counter with custom key to tiebreak using smallest, default = -1"
                    },
                    {
                        "username": "topswe",
                        "content": "see my solution: https://leetcode.com/problems/most-frequent-even-element/solutions/2815027/python-1-line-optimal-and-clean-with-explanation-2-ways-o-n-time-and-o-n-space/"
                    },
                    {
                        "username": "Ankit_Kumar_",
                        "content": "how do we compare the elements if the frequency is same for two numbers and print the smallest number ??any easier way other than doing it in the way provided in solutions\\n"
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "from collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=Counter(nums)\\n        l1=[]\\n        s=0\\n        c=0\\n        for key,val in d.items():\\n             if key%2==0:\\n                 if val>s:\\n                     c+=1\\n                     s=val\\n        if c==0:\\n            return -1\\n        else:\\n            for key,val in d.items():\\n                if val==s and key%2==0:\\n                    l1.append(key)\\n            return min(l1)\\n#python\\n                "
                    },
                    {
                        "username": "dangsonbk",
                        "content": "[@topswe](/topswe) or we can simply sort the list before input it into `Counter()` function."
                    },
                    {
                        "username": "topswe",
                        "content": "[@topswe](/topswe) see: https://leetcode.com/problems/most-frequent-even-element/solutions/2815027/python-1-line-optimal-and-clean-with-explanation-2-ways-o-n-time-and-o-n-space/"
                    },
                    {
                        "username": "topswe",
                        "content": "In python, you can use a custom lambda in the max function to tiebreak."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2404_Most_Frequent_Even_Element.cpp"
                    }
                ]
            },
            {
                "id": 1725302,
                "content": [
                    {
                        "username": "shaileshps21",
                        "content": "use a ordered_map and you can solve it with much ease and in a limited time...u can check my soln also\\n"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "[8154,9139,8194,3346,5450,9190,133,8239,4606,8671,8412,6290]\\noutput :  8194\\nExpected : 3346\\n\\nwhy expected output is 3346, i think  both answer are valid."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "beacuse when the count of even numbers is same we have to return the min value:\\nfrom collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=Counter(nums)\\n        l=[]\\n        l1=[]\\n        s=0\\n        c=0\\n        for key,val in d.items():\\n             if key%2==0:\\n                 if val>s:\\n                     c+=1\\n                     s=val\\n        if c==0:\\n            return -1\\n        else:\\n            for key,val in d.items():\\n                if val==s and key%2==0:\\n                    l1.append(key)\\n            return min(l1)\\n                "
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "Hello, I am getting an error in leetcode, where as it works fine in intellij for the line\\n` int maxValue = Collections.max(hashMap.values());`\\njava.util.NoSuchElementException\\n  at line 1599, java.base/java.util.HashMap$HashIterator.nextNode\\n  at line 1625, java.base/java.util.HashMap$ValueIterator.next\\n  at line 674, java.base/java.util.Collections.max\\n  at line 19, Solution.mostFrequentEven\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nMy complete code is :\\n int res=0;int count=0;\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\\n        for (int i=0;i<nums.length;i++){\\n            for (int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j])\\n                    count++;\\n            }\\n            if(nums[i]%2==0) {\\n                hashMap.put(nums[i], count);\\n            }\\n            count=0;\\n        }\\n        int maxValue = Collections.max(hashMap.values());\\n        res=maxValue;\\n        return res;\\n\\nPlease suggest.\\n"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "Can anyone explain why variable and max are ans here -1\\n\\n```\\nmap<int, int> mp;\\n\\n        for (const auto it : nums) {\\n                mp[it]++;\\n        }\\n        int ans = -1, max = - 1;\\n\\n        for (const auto m : mp) {\\n            if (m.first % 2 == 0 && m.second > max) {\\n                ans = m.first;\\n                max = m.second;\\n            }\\n        }\\n\\n```\\n"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "beacuse in  every condition in for loop not satisfy so your value is return as per declare. ---------------->\\n"
                    },
                    {
                        "username": "shaileshps21",
                        "content": "can u please explain the workflow of your soln"
                    },
                    {
                        "username": "Libaca",
                        "content": "Why {0,0,0,0} have to show 0 and not 4?"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Question asks to send the \"most frequent element \" not the frequency itself.\\nHope it helps."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This might be easy in python but its harder in c# (without using linq and all that stuff)"
                    },
                    {
                        "username": "topswe",
                        "content": "    # 1. use Counter of even elements\\n    # 2. take max of Counter with custom key to tiebreak using smallest, default = -1"
                    },
                    {
                        "username": "topswe",
                        "content": "see my solution: https://leetcode.com/problems/most-frequent-even-element/solutions/2815027/python-1-line-optimal-and-clean-with-explanation-2-ways-o-n-time-and-o-n-space/"
                    },
                    {
                        "username": "Ankit_Kumar_",
                        "content": "how do we compare the elements if the frequency is same for two numbers and print the smallest number ??any easier way other than doing it in the way provided in solutions\\n"
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "from collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=Counter(nums)\\n        l1=[]\\n        s=0\\n        c=0\\n        for key,val in d.items():\\n             if key%2==0:\\n                 if val>s:\\n                     c+=1\\n                     s=val\\n        if c==0:\\n            return -1\\n        else:\\n            for key,val in d.items():\\n                if val==s and key%2==0:\\n                    l1.append(key)\\n            return min(l1)\\n#python\\n                "
                    },
                    {
                        "username": "dangsonbk",
                        "content": "[@topswe](/topswe) or we can simply sort the list before input it into `Counter()` function."
                    },
                    {
                        "username": "topswe",
                        "content": "[@topswe](/topswe) see: https://leetcode.com/problems/most-frequent-even-element/solutions/2815027/python-1-line-optimal-and-clean-with-explanation-2-ways-o-n-time-and-o-n-space/"
                    },
                    {
                        "username": "topswe",
                        "content": "In python, you can use a custom lambda in the max function to tiebreak."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2404_Most_Frequent_Even_Element.cpp"
                    }
                ]
            },
            {
                "id": 2024284,
                "content": [
                    {
                        "username": "shaileshps21",
                        "content": "use a ordered_map and you can solve it with much ease and in a limited time...u can check my soln also\\n"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "[8154,9139,8194,3346,5450,9190,133,8239,4606,8671,8412,6290]\\noutput :  8194\\nExpected : 3346\\n\\nwhy expected output is 3346, i think  both answer are valid."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "beacuse when the count of even numbers is same we have to return the min value:\\nfrom collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=Counter(nums)\\n        l=[]\\n        l1=[]\\n        s=0\\n        c=0\\n        for key,val in d.items():\\n             if key%2==0:\\n                 if val>s:\\n                     c+=1\\n                     s=val\\n        if c==0:\\n            return -1\\n        else:\\n            for key,val in d.items():\\n                if val==s and key%2==0:\\n                    l1.append(key)\\n            return min(l1)\\n                "
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "Hello, I am getting an error in leetcode, where as it works fine in intellij for the line\\n` int maxValue = Collections.max(hashMap.values());`\\njava.util.NoSuchElementException\\n  at line 1599, java.base/java.util.HashMap$HashIterator.nextNode\\n  at line 1625, java.base/java.util.HashMap$ValueIterator.next\\n  at line 674, java.base/java.util.Collections.max\\n  at line 19, Solution.mostFrequentEven\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nMy complete code is :\\n int res=0;int count=0;\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\\n        for (int i=0;i<nums.length;i++){\\n            for (int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j])\\n                    count++;\\n            }\\n            if(nums[i]%2==0) {\\n                hashMap.put(nums[i], count);\\n            }\\n            count=0;\\n        }\\n        int maxValue = Collections.max(hashMap.values());\\n        res=maxValue;\\n        return res;\\n\\nPlease suggest.\\n"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "Can anyone explain why variable and max are ans here -1\\n\\n```\\nmap<int, int> mp;\\n\\n        for (const auto it : nums) {\\n                mp[it]++;\\n        }\\n        int ans = -1, max = - 1;\\n\\n        for (const auto m : mp) {\\n            if (m.first % 2 == 0 && m.second > max) {\\n                ans = m.first;\\n                max = m.second;\\n            }\\n        }\\n\\n```\\n"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "beacuse in  every condition in for loop not satisfy so your value is return as per declare. ---------------->\\n"
                    },
                    {
                        "username": "shaileshps21",
                        "content": "can u please explain the workflow of your soln"
                    },
                    {
                        "username": "Libaca",
                        "content": "Why {0,0,0,0} have to show 0 and not 4?"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Question asks to send the \"most frequent element \" not the frequency itself.\\nHope it helps."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This might be easy in python but its harder in c# (without using linq and all that stuff)"
                    },
                    {
                        "username": "topswe",
                        "content": "    # 1. use Counter of even elements\\n    # 2. take max of Counter with custom key to tiebreak using smallest, default = -1"
                    },
                    {
                        "username": "topswe",
                        "content": "see my solution: https://leetcode.com/problems/most-frequent-even-element/solutions/2815027/python-1-line-optimal-and-clean-with-explanation-2-ways-o-n-time-and-o-n-space/"
                    },
                    {
                        "username": "Ankit_Kumar_",
                        "content": "how do we compare the elements if the frequency is same for two numbers and print the smallest number ??any easier way other than doing it in the way provided in solutions\\n"
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "from collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=Counter(nums)\\n        l1=[]\\n        s=0\\n        c=0\\n        for key,val in d.items():\\n             if key%2==0:\\n                 if val>s:\\n                     c+=1\\n                     s=val\\n        if c==0:\\n            return -1\\n        else:\\n            for key,val in d.items():\\n                if val==s and key%2==0:\\n                    l1.append(key)\\n            return min(l1)\\n#python\\n                "
                    },
                    {
                        "username": "dangsonbk",
                        "content": "[@topswe](/topswe) or we can simply sort the list before input it into `Counter()` function."
                    },
                    {
                        "username": "topswe",
                        "content": "[@topswe](/topswe) see: https://leetcode.com/problems/most-frequent-even-element/solutions/2815027/python-1-line-optimal-and-clean-with-explanation-2-ways-o-n-time-and-o-n-space/"
                    },
                    {
                        "username": "topswe",
                        "content": "In python, you can use a custom lambda in the max function to tiebreak."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2404_Most_Frequent_Even_Element.cpp"
                    }
                ]
            },
            {
                "id": 1716105,
                "content": [
                    {
                        "username": "shaileshps21",
                        "content": "use a ordered_map and you can solve it with much ease and in a limited time...u can check my soln also\\n"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "[8154,9139,8194,3346,5450,9190,133,8239,4606,8671,8412,6290]\\noutput :  8194\\nExpected : 3346\\n\\nwhy expected output is 3346, i think  both answer are valid."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "beacuse when the count of even numbers is same we have to return the min value:\\nfrom collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=Counter(nums)\\n        l=[]\\n        l1=[]\\n        s=0\\n        c=0\\n        for key,val in d.items():\\n             if key%2==0:\\n                 if val>s:\\n                     c+=1\\n                     s=val\\n        if c==0:\\n            return -1\\n        else:\\n            for key,val in d.items():\\n                if val==s and key%2==0:\\n                    l1.append(key)\\n            return min(l1)\\n                "
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "Hello, I am getting an error in leetcode, where as it works fine in intellij for the line\\n` int maxValue = Collections.max(hashMap.values());`\\njava.util.NoSuchElementException\\n  at line 1599, java.base/java.util.HashMap$HashIterator.nextNode\\n  at line 1625, java.base/java.util.HashMap$ValueIterator.next\\n  at line 674, java.base/java.util.Collections.max\\n  at line 19, Solution.mostFrequentEven\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nMy complete code is :\\n int res=0;int count=0;\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\\n        for (int i=0;i<nums.length;i++){\\n            for (int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j])\\n                    count++;\\n            }\\n            if(nums[i]%2==0) {\\n                hashMap.put(nums[i], count);\\n            }\\n            count=0;\\n        }\\n        int maxValue = Collections.max(hashMap.values());\\n        res=maxValue;\\n        return res;\\n\\nPlease suggest.\\n"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "Can anyone explain why variable and max are ans here -1\\n\\n```\\nmap<int, int> mp;\\n\\n        for (const auto it : nums) {\\n                mp[it]++;\\n        }\\n        int ans = -1, max = - 1;\\n\\n        for (const auto m : mp) {\\n            if (m.first % 2 == 0 && m.second > max) {\\n                ans = m.first;\\n                max = m.second;\\n            }\\n        }\\n\\n```\\n"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "beacuse in  every condition in for loop not satisfy so your value is return as per declare. ---------------->\\n"
                    },
                    {
                        "username": "shaileshps21",
                        "content": "can u please explain the workflow of your soln"
                    },
                    {
                        "username": "Libaca",
                        "content": "Why {0,0,0,0} have to show 0 and not 4?"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Question asks to send the \"most frequent element \" not the frequency itself.\\nHope it helps."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This might be easy in python but its harder in c# (without using linq and all that stuff)"
                    },
                    {
                        "username": "topswe",
                        "content": "    # 1. use Counter of even elements\\n    # 2. take max of Counter with custom key to tiebreak using smallest, default = -1"
                    },
                    {
                        "username": "topswe",
                        "content": "see my solution: https://leetcode.com/problems/most-frequent-even-element/solutions/2815027/python-1-line-optimal-and-clean-with-explanation-2-ways-o-n-time-and-o-n-space/"
                    },
                    {
                        "username": "Ankit_Kumar_",
                        "content": "how do we compare the elements if the frequency is same for two numbers and print the smallest number ??any easier way other than doing it in the way provided in solutions\\n"
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "from collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=Counter(nums)\\n        l1=[]\\n        s=0\\n        c=0\\n        for key,val in d.items():\\n             if key%2==0:\\n                 if val>s:\\n                     c+=1\\n                     s=val\\n        if c==0:\\n            return -1\\n        else:\\n            for key,val in d.items():\\n                if val==s and key%2==0:\\n                    l1.append(key)\\n            return min(l1)\\n#python\\n                "
                    },
                    {
                        "username": "dangsonbk",
                        "content": "[@topswe](/topswe) or we can simply sort the list before input it into `Counter()` function."
                    },
                    {
                        "username": "topswe",
                        "content": "[@topswe](/topswe) see: https://leetcode.com/problems/most-frequent-even-element/solutions/2815027/python-1-line-optimal-and-clean-with-explanation-2-ways-o-n-time-and-o-n-space/"
                    },
                    {
                        "username": "topswe",
                        "content": "In python, you can use a custom lambda in the max function to tiebreak."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2404_Most_Frequent_Even_Element.cpp"
                    }
                ]
            },
            {
                "id": 1684281,
                "content": [
                    {
                        "username": "shaileshps21",
                        "content": "use a ordered_map and you can solve it with much ease and in a limited time...u can check my soln also\\n"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "[8154,9139,8194,3346,5450,9190,133,8239,4606,8671,8412,6290]\\noutput :  8194\\nExpected : 3346\\n\\nwhy expected output is 3346, i think  both answer are valid."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "beacuse when the count of even numbers is same we have to return the min value:\\nfrom collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=Counter(nums)\\n        l=[]\\n        l1=[]\\n        s=0\\n        c=0\\n        for key,val in d.items():\\n             if key%2==0:\\n                 if val>s:\\n                     c+=1\\n                     s=val\\n        if c==0:\\n            return -1\\n        else:\\n            for key,val in d.items():\\n                if val==s and key%2==0:\\n                    l1.append(key)\\n            return min(l1)\\n                "
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "Hello, I am getting an error in leetcode, where as it works fine in intellij for the line\\n` int maxValue = Collections.max(hashMap.values());`\\njava.util.NoSuchElementException\\n  at line 1599, java.base/java.util.HashMap$HashIterator.nextNode\\n  at line 1625, java.base/java.util.HashMap$ValueIterator.next\\n  at line 674, java.base/java.util.Collections.max\\n  at line 19, Solution.mostFrequentEven\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nMy complete code is :\\n int res=0;int count=0;\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\\n        for (int i=0;i<nums.length;i++){\\n            for (int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j])\\n                    count++;\\n            }\\n            if(nums[i]%2==0) {\\n                hashMap.put(nums[i], count);\\n            }\\n            count=0;\\n        }\\n        int maxValue = Collections.max(hashMap.values());\\n        res=maxValue;\\n        return res;\\n\\nPlease suggest.\\n"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "Can anyone explain why variable and max are ans here -1\\n\\n```\\nmap<int, int> mp;\\n\\n        for (const auto it : nums) {\\n                mp[it]++;\\n        }\\n        int ans = -1, max = - 1;\\n\\n        for (const auto m : mp) {\\n            if (m.first % 2 == 0 && m.second > max) {\\n                ans = m.first;\\n                max = m.second;\\n            }\\n        }\\n\\n```\\n"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "beacuse in  every condition in for loop not satisfy so your value is return as per declare. ---------------->\\n"
                    },
                    {
                        "username": "shaileshps21",
                        "content": "can u please explain the workflow of your soln"
                    },
                    {
                        "username": "Libaca",
                        "content": "Why {0,0,0,0} have to show 0 and not 4?"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Question asks to send the \"most frequent element \" not the frequency itself.\\nHope it helps."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This might be easy in python but its harder in c# (without using linq and all that stuff)"
                    },
                    {
                        "username": "topswe",
                        "content": "    # 1. use Counter of even elements\\n    # 2. take max of Counter with custom key to tiebreak using smallest, default = -1"
                    },
                    {
                        "username": "topswe",
                        "content": "see my solution: https://leetcode.com/problems/most-frequent-even-element/solutions/2815027/python-1-line-optimal-and-clean-with-explanation-2-ways-o-n-time-and-o-n-space/"
                    },
                    {
                        "username": "Ankit_Kumar_",
                        "content": "how do we compare the elements if the frequency is same for two numbers and print the smallest number ??any easier way other than doing it in the way provided in solutions\\n"
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "from collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=Counter(nums)\\n        l1=[]\\n        s=0\\n        c=0\\n        for key,val in d.items():\\n             if key%2==0:\\n                 if val>s:\\n                     c+=1\\n                     s=val\\n        if c==0:\\n            return -1\\n        else:\\n            for key,val in d.items():\\n                if val==s and key%2==0:\\n                    l1.append(key)\\n            return min(l1)\\n#python\\n                "
                    },
                    {
                        "username": "dangsonbk",
                        "content": "[@topswe](/topswe) or we can simply sort the list before input it into `Counter()` function."
                    },
                    {
                        "username": "topswe",
                        "content": "[@topswe](/topswe) see: https://leetcode.com/problems/most-frequent-even-element/solutions/2815027/python-1-line-optimal-and-clean-with-explanation-2-ways-o-n-time-and-o-n-space/"
                    },
                    {
                        "username": "topswe",
                        "content": "In python, you can use a custom lambda in the max function to tiebreak."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2404_Most_Frequent_Even_Element.cpp"
                    }
                ]
            },
            {
                "id": 1671117,
                "content": [
                    {
                        "username": "shaileshps21",
                        "content": "use a ordered_map and you can solve it with much ease and in a limited time...u can check my soln also\\n"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "[8154,9139,8194,3346,5450,9190,133,8239,4606,8671,8412,6290]\\noutput :  8194\\nExpected : 3346\\n\\nwhy expected output is 3346, i think  both answer are valid."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "beacuse when the count of even numbers is same we have to return the min value:\\nfrom collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=Counter(nums)\\n        l=[]\\n        l1=[]\\n        s=0\\n        c=0\\n        for key,val in d.items():\\n             if key%2==0:\\n                 if val>s:\\n                     c+=1\\n                     s=val\\n        if c==0:\\n            return -1\\n        else:\\n            for key,val in d.items():\\n                if val==s and key%2==0:\\n                    l1.append(key)\\n            return min(l1)\\n                "
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "Hello, I am getting an error in leetcode, where as it works fine in intellij for the line\\n` int maxValue = Collections.max(hashMap.values());`\\njava.util.NoSuchElementException\\n  at line 1599, java.base/java.util.HashMap$HashIterator.nextNode\\n  at line 1625, java.base/java.util.HashMap$ValueIterator.next\\n  at line 674, java.base/java.util.Collections.max\\n  at line 19, Solution.mostFrequentEven\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nMy complete code is :\\n int res=0;int count=0;\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\\n        for (int i=0;i<nums.length;i++){\\n            for (int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j])\\n                    count++;\\n            }\\n            if(nums[i]%2==0) {\\n                hashMap.put(nums[i], count);\\n            }\\n            count=0;\\n        }\\n        int maxValue = Collections.max(hashMap.values());\\n        res=maxValue;\\n        return res;\\n\\nPlease suggest.\\n"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "Can anyone explain why variable and max are ans here -1\\n\\n```\\nmap<int, int> mp;\\n\\n        for (const auto it : nums) {\\n                mp[it]++;\\n        }\\n        int ans = -1, max = - 1;\\n\\n        for (const auto m : mp) {\\n            if (m.first % 2 == 0 && m.second > max) {\\n                ans = m.first;\\n                max = m.second;\\n            }\\n        }\\n\\n```\\n"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "beacuse in  every condition in for loop not satisfy so your value is return as per declare. ---------------->\\n"
                    },
                    {
                        "username": "shaileshps21",
                        "content": "can u please explain the workflow of your soln"
                    },
                    {
                        "username": "Libaca",
                        "content": "Why {0,0,0,0} have to show 0 and not 4?"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Question asks to send the \"most frequent element \" not the frequency itself.\\nHope it helps."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This might be easy in python but its harder in c# (without using linq and all that stuff)"
                    },
                    {
                        "username": "topswe",
                        "content": "    # 1. use Counter of even elements\\n    # 2. take max of Counter with custom key to tiebreak using smallest, default = -1"
                    },
                    {
                        "username": "topswe",
                        "content": "see my solution: https://leetcode.com/problems/most-frequent-even-element/solutions/2815027/python-1-line-optimal-and-clean-with-explanation-2-ways-o-n-time-and-o-n-space/"
                    },
                    {
                        "username": "Ankit_Kumar_",
                        "content": "how do we compare the elements if the frequency is same for two numbers and print the smallest number ??any easier way other than doing it in the way provided in solutions\\n"
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "from collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=Counter(nums)\\n        l1=[]\\n        s=0\\n        c=0\\n        for key,val in d.items():\\n             if key%2==0:\\n                 if val>s:\\n                     c+=1\\n                     s=val\\n        if c==0:\\n            return -1\\n        else:\\n            for key,val in d.items():\\n                if val==s and key%2==0:\\n                    l1.append(key)\\n            return min(l1)\\n#python\\n                "
                    },
                    {
                        "username": "dangsonbk",
                        "content": "[@topswe](/topswe) or we can simply sort the list before input it into `Counter()` function."
                    },
                    {
                        "username": "topswe",
                        "content": "[@topswe](/topswe) see: https://leetcode.com/problems/most-frequent-even-element/solutions/2815027/python-1-line-optimal-and-clean-with-explanation-2-ways-o-n-time-and-o-n-space/"
                    },
                    {
                        "username": "topswe",
                        "content": "In python, you can use a custom lambda in the max function to tiebreak."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2404_Most_Frequent_Even_Element.cpp"
                    }
                ]
            },
            {
                "id": 1761546,
                "content": [
                    {
                        "username": "shaileshps21",
                        "content": "use a ordered_map and you can solve it with much ease and in a limited time...u can check my soln also\\n"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "[8154,9139,8194,3346,5450,9190,133,8239,4606,8671,8412,6290]\\noutput :  8194\\nExpected : 3346\\n\\nwhy expected output is 3346, i think  both answer are valid."
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "beacuse when the count of even numbers is same we have to return the min value:\\nfrom collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=Counter(nums)\\n        l=[]\\n        l1=[]\\n        s=0\\n        c=0\\n        for key,val in d.items():\\n             if key%2==0:\\n                 if val>s:\\n                     c+=1\\n                     s=val\\n        if c==0:\\n            return -1\\n        else:\\n            for key,val in d.items():\\n                if val==s and key%2==0:\\n                    l1.append(key)\\n            return min(l1)\\n                "
                    },
                    {
                        "username": "abhishekpm1987",
                        "content": "Hello, I am getting an error in leetcode, where as it works fine in intellij for the line\\n` int maxValue = Collections.max(hashMap.values());`\\njava.util.NoSuchElementException\\n  at line 1599, java.base/java.util.HashMap$HashIterator.nextNode\\n  at line 1625, java.base/java.util.HashMap$ValueIterator.next\\n  at line 674, java.base/java.util.Collections.max\\n  at line 19, Solution.mostFrequentEven\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nMy complete code is :\\n int res=0;int count=0;\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer> hashMap = new HashMap<>();\\n        for (int i=0;i<nums.length;i++){\\n            for (int j=0;j<nums.length;j++){\\n                if(nums[i]==nums[j])\\n                    count++;\\n            }\\n            if(nums[i]%2==0) {\\n                hashMap.put(nums[i], count);\\n            }\\n            count=0;\\n        }\\n        int maxValue = Collections.max(hashMap.values());\\n        res=maxValue;\\n        return res;\\n\\nPlease suggest.\\n"
                    },
                    {
                        "username": "Ruslan90123",
                        "content": "Can anyone explain why variable and max are ans here -1\\n\\n```\\nmap<int, int> mp;\\n\\n        for (const auto it : nums) {\\n                mp[it]++;\\n        }\\n        int ans = -1, max = - 1;\\n\\n        for (const auto m : mp) {\\n            if (m.first % 2 == 0 && m.second > max) {\\n                ans = m.first;\\n                max = m.second;\\n            }\\n        }\\n\\n```\\n"
                    },
                    {
                        "username": "dhruvs_777",
                        "content": "beacuse in  every condition in for loop not satisfy so your value is return as per declare. ---------------->\\n"
                    },
                    {
                        "username": "shaileshps21",
                        "content": "can u please explain the workflow of your soln"
                    },
                    {
                        "username": "Libaca",
                        "content": "Why {0,0,0,0} have to show 0 and not 4?"
                    },
                    {
                        "username": "Manohar_001",
                        "content": "Question asks to send the \"most frequent element \" not the frequency itself.\\nHope it helps."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This might be easy in python but its harder in c# (without using linq and all that stuff)"
                    },
                    {
                        "username": "topswe",
                        "content": "    # 1. use Counter of even elements\\n    # 2. take max of Counter with custom key to tiebreak using smallest, default = -1"
                    },
                    {
                        "username": "topswe",
                        "content": "see my solution: https://leetcode.com/problems/most-frequent-even-element/solutions/2815027/python-1-line-optimal-and-clean-with-explanation-2-ways-o-n-time-and-o-n-space/"
                    },
                    {
                        "username": "Ankit_Kumar_",
                        "content": "how do we compare the elements if the frequency is same for two numbers and print the smallest number ??any easier way other than doing it in the way provided in solutions\\n"
                    },
                    {
                        "username": "satya_surya_thota",
                        "content": "from collections import Counter\\nclass Solution:\\n    def mostFrequentEven(self, nums: List[int]) -> int:\\n        d=Counter(nums)\\n        l1=[]\\n        s=0\\n        c=0\\n        for key,val in d.items():\\n             if key%2==0:\\n                 if val>s:\\n                     c+=1\\n                     s=val\\n        if c==0:\\n            return -1\\n        else:\\n            for key,val in d.items():\\n                if val==s and key%2==0:\\n                    l1.append(key)\\n            return min(l1)\\n#python\\n                "
                    },
                    {
                        "username": "dangsonbk",
                        "content": "[@topswe](/topswe) or we can simply sort the list before input it into `Counter()` function."
                    },
                    {
                        "username": "topswe",
                        "content": "[@topswe](/topswe) see: https://leetcode.com/problems/most-frequent-even-element/solutions/2815027/python-1-line-optimal-and-clean-with-explanation-2-ways-o-n-time-and-o-n-space/"
                    },
                    {
                        "username": "topswe",
                        "content": "In python, you can use a custom lambda in the max function to tiebreak."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2404_Most_Frequent_Even_Element.cpp"
                    }
                ]
            }
        ]
    }
]