[
    {
        "title": "Longest Uploaded Prefix",
        "question_content": "You are given a stream of n videos, each represented by a distinct number from 1 to n that you need to \"upload\" to a server. You need to implement a data structure that calculates the length of the longest uploaded prefix at various points in the upload process.\nWe consider i to be an uploaded prefix if all videos in the range 1 to i (inclusive) have been uploaded to the server. The longest uploaded prefix is the maximum value of i that satisfies this definition.\nImplement the LUPrefix class:\n\n\tLUPrefix(int n) Initializes the object for a stream of n videos.\n\tvoid upload(int video) Uploads video to the server.\n\tint longest() Returns the length of the longest uploaded prefix defined above.\n\n&nbsp;\nExample 1:\n\nInput\n[\"LUPrefix\", \"upload\", \"longest\", \"upload\", \"longest\", \"upload\", \"longest\"]\n[[4], [3], [], [1], [], [2], []]\nOutput\n[null, null, 0, null, 1, null, 3]\nExplanation\nLUPrefix server = new LUPrefix(4);   // Initialize a stream of 4 videos.\nserver.upload(3);                    // Upload video 3.\nserver.longest();                    // Since video 1 has not been uploaded yet, there is no prefix.\n                                     // So, we return 0.\nserver.upload(1);                    // Upload video 1.\nserver.longest();                    // The prefix [1] is the longest uploaded prefix, so we return 1.\nserver.upload(2);                    // Upload video 2.\nserver.longest();                    // The prefix [1,2,3] is the longest uploaded prefix, so we return 3.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 105\n\t1 <= video <= n\n\tAll values of video are distinct.\n\tAt most 2 * 105 calls in total will be made to upload and longest.\n\tAt least one call will be made to longest.",
        "solutions": [
            {
                "id": 2646696,
                "title": "python-elegant-short-amortized-o-1-commented",
                "content": "```\\nclass LUPrefix:\\n    \"\"\"\\n    Memory: O(n)\\n    Time:   O(1) per upload call, because adding to the set takes O(1) time, and the prefix\\n\\t\\t\\t\\t can be increased no more than n times for all n calls to the upload function\\n    \"\"\"\\n\\n    def __init__(self, n: int):\\n        self._longest = 0\\n        self._nums = set()\\n\\n    def upload(self, video: int) -> None:\\n        self._nums.add(video)\\n        # Since the prefix cannot decrease, it is enough for us to increase it\\n        # until we reach the number that has not yet been added\\n        while self._longest + 1 in self._nums:\\n            self._longest += 1\\n\\n    def longest(self) -> int:\\n        return self._longest\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass LUPrefix:\\n    \"\"\"\\n    Memory: O(n)\\n    Time:   O(1) per upload call, because adding to the set takes O(1) time, and the prefix\\n\\t\\t\\t\\t can be increased no more than n times for all n calls to the upload function\\n    \"\"\"\\n\\n    def __init__(self, n: int):\\n        self._longest = 0\\n        self._nums = set()\\n\\n    def upload(self, video: int) -> None:\\n        self._nums.add(video)\\n        # Since the prefix cannot decrease, it is enough for us to increase it\\n        # until we reach the number that has not yet been added\\n        while self._longest + 1 in self._nums:\\n            self._longest += 1\\n\\n    def longest(self) -> int:\\n        return self._longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646491,
                "title": "most-easy-and-short-solution-meme",
                "content": "**Self explanatory solution**\\n\\n```\\nclass LUPrefix {\\n    Set<Integer> set;\\n    int max=0;\\n    public LUPrefix(int n) {\\n        set=new HashSet<>();\\n    }\\n    public void upload(int video) {\\n        set.add(video);\\n        while(set.contains(max+1)) max++;\\n    }\\n    public int longest() {\\n        return max;\\n    }\\n}\\n```\\n\\nmeme :\\n\\n![image](https://assets.leetcode.com/users/images/fd1666c2-d394-428e-8928-efa9dfc134bb_1664639992.3392522.jpeg)\\n\\n***let\\'s connect :***\\n\\n\\uD83D\\uDE80 [www.linkedin.com/in/harshitmaurya](https://www.linkedin.com/in/harshitmaurya/)\\n\\uD83D\\uDE80 [twitter.com/HarshitMaurya_](https://twitter.com/HarshitMaurya_)\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass LUPrefix {\\n    Set<Integer> set;\\n    int max=0;\\n    public LUPrefix(int n) {\\n        set=new HashSet<>();\\n    }\\n    public void upload(int video) {\\n        set.add(video);\\n        while(set.contains(max+1)) max++;\\n    }\\n    public int longest() {\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646628,
                "title": "c-set-easy-understanding",
                "content": "**Approach** \\n- We will insert number in set `s`.\\n- When the `longest()` function will be called, the set will try to increase the answer by checking the next values.\\n\\n**C++ Code**\\n\\n```cpp\\nclass LUPrefix {\\n   public:\\n    set<int> s;\\n    int t = 0;\\n    LUPrefix(int n) {\\n    }\\n\\n    void upload(int video) {\\n        s.emplace(video);\\n    }\\n\\n    int longest() {\\n        while (s.count(t + 1)) {\\n            t++;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass LUPrefix {\\n   public:\\n    set<int> s;\\n    int t = 0;\\n    LUPrefix(int n) {\\n    }\\n\\n    void upload(int video) {\\n        s.emplace(video);\\n    }\\n\\n    int longest() {\\n        while (s.count(t + 1)) {\\n            t++;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646499,
                "title": "java-treeset-super-simple",
                "content": "# Intuition\\nKeep a TreeSet of all the numbers (videos) NOT uploaded yet.\\nYou can then look at the lowest not uploaded value, and the prefix is the value just before this one.\\nSince it\\'s a tree, it allows to get the lowest value (leftmost node in the tree) in O(log n)\\n\\n# Complexity\\n- Time complexity:\\n    - initialization (`new LUPrefix()`) : O(n log n)\\n    - upload : O(log n)\\n    - longest : O(log n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass LUPrefix {\\n    \\n    TreeSet<Integer> tree = new TreeSet<>();\\n    int n;\\n\\n    public LUPrefix(int n) {\\n        for (int i = 1; i <= n ; i++) {\\n            tree.add(i);\\n        }\\n        this.n = n;\\n    }\\n\\n    public void upload(int video) {\\n        tree.remove(video);\\n    }\\n\\n    public int longest() {\\n        return tree.isEmpty() ? n : tree.first() -1;\\n    }\\n}\\n```\\n\\n# Note 1\\n\\nUsing a priority queue (heap) would have had better complexity (O(n) initialization,  O(log n) upload and  O(1) longuest) but in Java implementation, removing from a priority queue is O(n) instead of O(log n).\\n\\n# Note 2\\nThis not the optimal solution, the optimal one is the HashSet/array one. However one advantage of the tree solution, is that the worst case of any `upload()` call is `O(log n)` while for the HashSet/array the worst case of one call is `O(n)` (but `O(1)` amortized).",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LUPrefix {\\n    \\n    TreeSet<Integer> tree = new TreeSet<>();\\n    int n;\\n\\n    public LUPrefix(int n) {\\n        for (int i = 1; i <= n ; i++) {\\n            tree.add(i);\\n        }\\n        this.n = n;\\n    }\\n\\n    public void upload(int video) {\\n        tree.remove(video);\\n    }\\n\\n    public int longest() {\\n        return tree.isEmpty() ? n : tree.first() -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647167,
                "title": "c-use-array-easy-approach",
                "content": "```\\nclass LUPrefix {\\npublic:\\n    \\n    vector<int> pre;\\n    int val=0;\\n    \\n    LUPrefix(int n) \\n    {\\n        pre.resize(n+2, 0);\\n    }\\n    \\n    void upload(int video) \\n    {\\n        pre[video] = 1;\\n        \\n    }\\n    \\n    int longest() \\n    {\\n        while(pre[val+1]==1)\\n                val++;\\n        \\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    \\n    vector<int> pre;\\n    int val=0;\\n    \\n    LUPrefix(int n) \\n    {\\n        pre.resize(n+2, 0);\\n    }\\n    \\n    void upload(int video) \\n    {\\n        pre[video] = 1;\\n        \\n    }\\n    \\n    int longest() \\n    {\\n        while(pre[val+1]==1)\\n                val++;\\n        \\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646553,
                "title": "c-with-explanation-very-simple-easy-to-understand-solution",
                "content": "<b>Up Vote if you like the solution \\n```\\n\\n/* take an array that keeps a mark of each of the video that uploaded.\\n   keep another varible - latest, that keeps track of all the video that\\n   has been already uploaded till that point of time.\\n   Update latest, when the new video uploaded just next to it, also keep \\n   on checking for next videos if those were updated before or not at the \\n   same time.\\n */\\nclass LUPrefix {\\npublic:\\n    vector<bool> isupdated;\\n    int latest;\\n    LUPrefix(int n) {\\n        isupdated.resize(n+1, 0);\\n        latest = 0;\\n    }\\n    \\n    void upload(int video) {\\n        isupdated[video] = 1;\\n        if(latest == video-1){\\n            while(isupdated[video] == 1 && video < isupdated.size()){\\n                latest = video;\\n                video++;\\n            }\\n        }\\n    }\\n    \\n    int longest() {\\n        return latest;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n\\n/* take an array that keeps a mark of each of the video that uploaded.\\n   keep another varible - latest, that keeps track of all the video that\\n   has been already uploaded till that point of time.\\n   Update latest, when the new video uploaded just next to it, also keep \\n   on checking for next videos if those were updated before or not at the \\n   same time.\\n */\\nclass LUPrefix {\\npublic:\\n    vector<bool> isupdated;\\n    int latest;\\n    LUPrefix(int n) {\\n        isupdated.resize(n+1, 0);\\n        latest = 0;\\n    }\\n    \\n    void upload(int video) {\\n        isupdated[video] = 1;\\n        if(latest == video-1){\\n            while(isupdated[video] == 1 && video < isupdated.size()){\\n                latest = video;\\n                video++;\\n            }\\n        }\\n    }\\n    \\n    int longest() {\\n        return latest;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646604,
                "title": "very-easy-solution-c-o-nlogn",
                "content": "# Intuition\\nWe will going to use set here because we know that set have element in sorted order\\n\\n# Approach\\nnow i am going to describe my intution using a example\\nlet n=6;\\nnow put all element from 1 to 6 in set\\ns={1,2,3,4,5,6}\\n\\nnow when ever the function ***upload*** is called we gonna delete that element from set\\nnow lets delete 3\\nthen s={1,2,4,5,6}\\nanswer will be 0\\n\\nnow delete 5\\nthen s={1,2,4,6}\\nanswer will be still 0 because 1 is still present in set\\n\\nnow delete 1\\nthen s={2,4,6}\\nanswer =1  \\n\\nnow delete 2\\nthen s={4,6}\\nanswer =3\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->Nlog(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\nclass LUPrefix {\\npublic:\\n    set<int>s;\\n        int size;\\n    LUPrefix(int n) {\\n        for(int i=1;i<=n;i++)\\n            s.insert(i);\\n        \\n        size=n;\\n    }\\n    \\n    void upload(int video) {\\n       s.erase(video); \\n    }\\n    \\n    int longest() {\\n        auto it=s.begin();\\n        if(it==s.end())\\n            return size;\\n        \\n        return *it-1;\\n    }\\n        \\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    set<int>s;\\n        int size;\\n    LUPrefix(int n) {\\n        for(int i=1;i<=n;i++)\\n            s.insert(i);\\n        \\n        size=n;\\n    }\\n    \\n    void upload(int video) {\\n       s.erase(video); \\n    }\\n    \\n    int longest() {\\n        auto it=s.begin();\\n        if(it==s.end())\\n            return size;\\n        \\n        return *it-1;\\n    }\\n        \\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683299,
                "title": "3-solutions-fenwick-tree-or-binary-indexed-tree-segment-tree-disjoint-set-adt",
                "content": "This discussion thread includes 3 separate solutions using different data structures namely,\\n\\n**1. Fenwick Tree or Binary Indexed Tree\\n2. Segment Tree\\n3. Disjoint Set**\\n\\nThe intuition behind fenwick tree and segment tree solution is,\\n=> We want to find the Longest Uploaded Prefix,\\n=> Let\\'s create an array of size n\\n=> Let\\'s consider 0 at the particular index when the video hasn\\'t yet uploaded and 1 as uploaded.\\n=> Now the questions boils down to, we are interested in finding the longest consecutive ones starting from 0th index\\n=> What if we calculate the prefix sum, to find whether there exist all ones or is there any 0 in that portion, FOR EXAMPLE: In this array  [1, 1, 1, 1, 0, 1] if we calculate the prefix sum till 3rd index it would be 4 and also there are only 4 locations till 3rd index hence there are all ones, on the other hand let\\'s calculate prefix sum till 5th index, and that would be 5 so if there are 6 locations available and sum is 5 then there must be a 0.\\n=> The last explanation is all about the solution of this problem. \\n=> We can use segment tree or fenwick tree to maintain the prefix sum and then we can find whether there exists all ones till ith index in just O(logn) time.\\n=> In the end it is important to note that there is a need of binary search to find the answer.\\n\\n\\n```\\n// Fenwick Tree Solution\\nclass LUPrefix {\\npublic:\\n    // `answer` will store the most updated answer at each step\\n    int answer;\\n    \\n    // This is a pointer to the binary indexed tree, we will dynamically allocate an array in constructor\\n    int *B_I_Tree;\\n\\n    // The information about maximum number of input, needed for utilities of  Binary Indexed Tree\\n    int n;\\n    \\n    // Given Constructor\\n    LUPrefix(int n) {\\n\\n        // Initialize `answer` with 0\\n        answer = 0;\\n\\n        // Store the value of `n` so that we can use it later in functions\\n        this->n = n;    \\n\\n        // Dynamically allocate an array of size `n + 1`\\n        B_I_Tree = new int[n+1];\\n\\n        // Fill all the indices with 0\\n        memset(B_I_Tree, 0, sizeof(int)*(n+1));\\n    }\\n    \\n    //---------------------------Binary Indexed Tree Utilities------------------------------//\\n    void Update(int i, int value) {\\n        for(; i<=n ; i+=(i&(-i))){\\n            B_I_Tree[i] += value;\\n        }\\n    }\\n    int Sum(int i){\\n        int sum = 0;\\n        for(; i>0 ; i-=(i&(-i))){\\n            sum += B_I_Tree[i];\\n        }\\n        return sum;\\n    }\\n    //--------------------------------------------------------------------------------------//\\n    \\n    void upload(int video) {  \\n        // By 0 in binary indexed tree we are indicating that the particular indexed video hasn\\'t uploaded yet.\\n\\n        // So for each upload operation, Update the value at `video` index by 1 \\n\\n        Update(video, 1);\\n    }\\n    \\n    int longest() {\\n\\n        // Our answer would always be atleast equal to last answer\\n        int low = answer;\\n\\n        // And at max it can reach to the total number of videos(n)\\n        int high = n;\\n        \\n        // Run a binary search on possible answers\\n        while(low<=high){\\n            int mid = (low + high)/2;\\n        \\n            // Check if answer is possible\\n            if(Sum(mid) == mid){\\n                // If possible then Update the answer\\n                answer = mid;\\n\\n                // And search for some higher answers\\n                low = mid + 1;\\n            }\\n\\n            // Otherwise move to lower answers \\n            else {\\n                high = mid - 1;\\n            }            \\n        }\\n\\n        //Return the answer\\n        return answer;\\n    }\\n};\\n// @MrTwinkleSharma\\n```\\n\\n\\n```\\n// Segment Tree Solution\\nclass LUPrefix {\\npublic:\\n    // `answer` will store the most updated answer at each step\\n    int answer;\\n    \\n    // This is a pointer to the segment tree, we will dynamically allocate an array in constructor\\n    int *segmentTree;\\n\\n    // The information about maximum number of input, needed for utilities of Segment Tree\\n    int n;\\n    \\n    // Given Constructor\\n    LUPrefix(int n) {\\n\\n        // Initialize `answer` with 0\\n        answer = 0;\\n\\n        // Store the value of `n` so that we can use it later in functions\\n        this->n = n;    \\n\\n        // Dynamically allocate an array of size `n*4`\\n        segmentTree = new int[n*4];\\n\\n        // Fill all the indices with 0, Because we have no data to separately build the tree\\n        memset(segmentTree, 0, sizeof(int)*(n*4));\\n    }\\n    \\n    //---------------------------Segment Tree Utilities------------------------------//\\n    void Update(int index, int start, int end, int updateIndex, int value) {\\n        // No overlap case\\n        if(updateIndex < start || updateIndex > end){\\n          return;\\n        }\\n\\n        // Update at leaf node\\n        if(start==end){\\n          segmentTree[index] = value;\\n          return;\\n        }\\n\\n        // Recursively Update both Parts of segment tree\\n        int mid = (start + end)/2;\\n\\n        Update(2*index + 1, start, mid, updateIndex, value);\\n        Update(2*index + 2, mid + 1, end, updateIndex, value);\\n\\n        // Update the segment tree\\n        segmentTree[index] = segmentTree[2*index + 1] + segmentTree[2*index + 2];    \\n    }\\n    int Query(int index, int start, int end, int qstart, int qend){\\n        // No overlap\\n        if(qend<start || qstart>end){\\n          return 0;\\n        }\\n\\n        // Complete Overlap\\n        if(qstart<=start && qend>=end){\\n          return segmentTree[index];\\n        }\\n\\n        int mid = (start + end)/2;\\n        \\n        // Recursively find the answer from both subtree\\n        return Query(2*index+1, start, mid, qstart, qend) + Query(2*index+2, mid+1, end, qstart, qend);\\n    }\\n    //--------------------------------------------------------------------------------------//\\n    \\n    void upload(int video) {  \\n        // By 0 in segment tree leaf we are indicating that the particular indexed video hasn\\'t uploaded yet.\\n\\n        // So for each upload operation, Update the value at `video` index by 1 \\n\\n        // Our segment tree is 0 indexed so use `video - 1` as update index \\n        Update(0, 0, n-1, video-1, 1);\\n    }\\n    \\n    int longest() {\\n\\n        // Our answer would always be atleast equal to last answer\\n        int low = answer;\\n\\n        // And at max it can reach to the total number of videos(n)\\n        int high = n;\\n        \\n        // Run a binary search on possible answers\\n        while(low<=high){\\n            int mid = (low + high)/2;\\n        \\n            // Check if answer is possible\\n            if(Query(0, 0, n - 1, 0, mid-1) == mid){\\n                // If possible then Update the answer\\n                answer = mid;\\n\\n                // And search for some higher answers\\n                low = mid + 1;\\n            }\\n\\n            // Otherwise move to lower answers \\n            else {\\n                high = mid - 1;\\n            }            \\n        }\\n\\n        //Return the answer\\n        return answer;\\n    }\\n};\\n// @MrTwinkleSharma\\n```\\n\\n\\nThe intuition behind disjoint set solution is, \\n=> If we create an array of n and mark the uploaded video as 1 and other as 0, then our goal is to find the maximum length of consecutive ones from starting index.\\n=> The same thing we can do with disjoint set, we can create disjoint set and for each `upload` operation we can merge the disjoint sets of `video-1` and `video+1` with `video`. But by making sure that video-1 and video+1 have been already uploaded, we can using any kind of hashing for that purpose.\\n=> For each Union operation we will always try to make the lower index as parent so that in the end we can get to know the size of 1st disjoint set.\\n=> The size of first disjoint set will give the answer. We can maintain the size of disjoint set with the help of rank by size.\\n```\\n// Disjoint Set solution\\nclass LUPrefix {\\npublic:\\n    // Parent will store the Absolute parent of the Disjoint Set Elements\\n    // Rank will store the size of each disjoint set\\n    int *parent, *rankBySize;\\n    \\n    // Total number of `video`, needed later so we are storing it in a global variable\\n    int n;\\n    \\n    // A unordered_map to track the uploaded video\\n    unordered_map<int, int> mp;\\n    \\n    \\n    LUPrefix(int n) {\\n    \\n        this->n = n;\\n        \\n        // Create the disjoint set array\\n        parent = new int[n + 1];\\n        rankBySize = new int[n + 1];\\n        \\n        // Build the disjoint set\\n        for(int i = 1;i<=n;i++){\\n            parent[i] = i;\\n            rankBySize[i] = 1;\\n        }\\n    }\\n    \\n    // Find Utility\\n    int Find(int node){\\n        if(parent[node] == node){\\n            return node;\\n        }\\n        parent[node] = Find(parent[node]);\\n        return parent[node];\\n    }\\n    \\n    // Union\\n    void Union(int node1, int node2){\\n        int p1 = Find(node1);\\n        int p2 = Find(node2);\\n        \\n        if(p1 != p2){\\n            \\n            // We will always try to merge the parent with higher index into smaller one \\n            // Because we want our answer to be concentrated at index `1`\\n            if(p1<p2){\\n                parent[node2] = node1;\\n                rankBySize[p1]+=rankBySize[p2];\\n            }\\n            else if(p2<p1){\\n                parent[node1] = node2;\\n                rankBySize[p2]+=rankBySize[p1];\\n            }\\n        }\\n    }\\n    \\n    void upload(int video) {\\n        // Make union of video with video - 1 and video + 1\\n        // But make sure that the video - 1 and video + 1 is already uploaded\\n        if(video-1>=1 && mp[video-1]==1) Union(video, video-1);\\n        if(video+1<=n && mp[video+1]==1) Union(video, video+1);\\n        \\n        // Upload the video\\n        mp[video] = 1;\\n    }\\n    \\n    int longest() {\\n        // Return the size of disjoint set having absolute parent `1`.\\n        // If 1 video has not been uploaded yet, then still rankBySize will give 1\\n        // So we are checking whether `1` video is uploaded or not, as a base case\\n        return mp[1] ? rankBySize[1] : 0;\\n    }\\n};\\n//@MrTwinkleSharma\\n```\\n",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n// Fenwick Tree Solution\\nclass LUPrefix {\\npublic:\\n    // `answer` will store the most updated answer at each step\\n    int answer;\\n    \\n    // This is a pointer to the binary indexed tree, we will dynamically allocate an array in constructor\\n    int *B_I_Tree;\\n\\n    // The information about maximum number of input, needed for utilities of  Binary Indexed Tree\\n    int n;\\n    \\n    // Given Constructor\\n    LUPrefix(int n) {\\n\\n        // Initialize `answer` with 0\\n        answer = 0;\\n\\n        // Store the value of `n` so that we can use it later in functions\\n        this->n = n;    \\n\\n        // Dynamically allocate an array of size `n + 1`\\n        B_I_Tree = new int[n+1];\\n\\n        // Fill all the indices with 0\\n        memset(B_I_Tree, 0, sizeof(int)*(n+1));\\n    }\\n    \\n    //---------------------------Binary Indexed Tree Utilities------------------------------//\\n    void Update(int i, int value) {\\n        for(; i<=n ; i+=(i&(-i))){\\n            B_I_Tree[i] += value;\\n        }\\n    }\\n    int Sum(int i){\\n        int sum = 0;\\n        for(; i>0 ; i-=(i&(-i))){\\n            sum += B_I_Tree[i];\\n        }\\n        return sum;\\n    }\\n    //--------------------------------------------------------------------------------------//\\n    \\n    void upload(int video) {  \\n        // By 0 in binary indexed tree we are indicating that the particular indexed video hasn\\'t uploaded yet.\\n\\n        // So for each upload operation, Update the value at `video` index by 1 \\n\\n        Update(video, 1);\\n    }\\n    \\n    int longest() {\\n\\n        // Our answer would always be atleast equal to last answer\\n        int low = answer;\\n\\n        // And at max it can reach to the total number of videos(n)\\n        int high = n;\\n        \\n        // Run a binary search on possible answers\\n        while(low<=high){\\n            int mid = (low + high)/2;\\n        \\n            // Check if answer is possible\\n            if(Sum(mid) == mid){\\n                // If possible then Update the answer\\n                answer = mid;\\n\\n                // And search for some higher answers\\n                low = mid + 1;\\n            }\\n\\n            // Otherwise move to lower answers \\n            else {\\n                high = mid - 1;\\n            }            \\n        }\\n\\n        //Return the answer\\n        return answer;\\n    }\\n};\\n// @MrTwinkleSharma\\n```\n```\\n// Segment Tree Solution\\nclass LUPrefix {\\npublic:\\n    // `answer` will store the most updated answer at each step\\n    int answer;\\n    \\n    // This is a pointer to the segment tree, we will dynamically allocate an array in constructor\\n    int *segmentTree;\\n\\n    // The information about maximum number of input, needed for utilities of Segment Tree\\n    int n;\\n    \\n    // Given Constructor\\n    LUPrefix(int n) {\\n\\n        // Initialize `answer` with 0\\n        answer = 0;\\n\\n        // Store the value of `n` so that we can use it later in functions\\n        this->n = n;    \\n\\n        // Dynamically allocate an array of size `n*4`\\n        segmentTree = new int[n*4];\\n\\n        // Fill all the indices with 0, Because we have no data to separately build the tree\\n        memset(segmentTree, 0, sizeof(int)*(n*4));\\n    }\\n    \\n    //---------------------------Segment Tree Utilities------------------------------//\\n    void Update(int index, int start, int end, int updateIndex, int value) {\\n        // No overlap case\\n        if(updateIndex < start || updateIndex > end){\\n          return;\\n        }\\n\\n        // Update at leaf node\\n        if(start==end){\\n          segmentTree[index] = value;\\n          return;\\n        }\\n\\n        // Recursively Update both Parts of segment tree\\n        int mid = (start + end)/2;\\n\\n        Update(2*index + 1, start, mid, updateIndex, value);\\n        Update(2*index + 2, mid + 1, end, updateIndex, value);\\n\\n        // Update the segment tree\\n        segmentTree[index] = segmentTree[2*index + 1] + segmentTree[2*index + 2];    \\n    }\\n    int Query(int index, int start, int end, int qstart, int qend){\\n        // No overlap\\n        if(qend<start || qstart>end){\\n          return 0;\\n        }\\n\\n        // Complete Overlap\\n        if(qstart<=start && qend>=end){\\n          return segmentTree[index];\\n        }\\n\\n        int mid = (start + end)/2;\\n        \\n        // Recursively find the answer from both subtree\\n        return Query(2*index+1, start, mid, qstart, qend) + Query(2*index+2, mid+1, end, qstart, qend);\\n    }\\n    //--------------------------------------------------------------------------------------//\\n    \\n    void upload(int video) {  \\n        // By 0 in segment tree leaf we are indicating that the particular indexed video hasn\\'t uploaded yet.\\n\\n        // So for each upload operation, Update the value at `video` index by 1 \\n\\n        // Our segment tree is 0 indexed so use `video - 1` as update index \\n        Update(0, 0, n-1, video-1, 1);\\n    }\\n    \\n    int longest() {\\n\\n        // Our answer would always be atleast equal to last answer\\n        int low = answer;\\n\\n        // And at max it can reach to the total number of videos(n)\\n        int high = n;\\n        \\n        // Run a binary search on possible answers\\n        while(low<=high){\\n            int mid = (low + high)/2;\\n        \\n            // Check if answer is possible\\n            if(Query(0, 0, n - 1, 0, mid-1) == mid){\\n                // If possible then Update the answer\\n                answer = mid;\\n\\n                // And search for some higher answers\\n                low = mid + 1;\\n            }\\n\\n            // Otherwise move to lower answers \\n            else {\\n                high = mid - 1;\\n            }            \\n        }\\n\\n        //Return the answer\\n        return answer;\\n    }\\n};\\n// @MrTwinkleSharma\\n```\n```\\n// Disjoint Set solution\\nclass LUPrefix {\\npublic:\\n    // Parent will store the Absolute parent of the Disjoint Set Elements\\n    // Rank will store the size of each disjoint set\\n    int *parent, *rankBySize;\\n    \\n    // Total number of `video`, needed later so we are storing it in a global variable\\n    int n;\\n    \\n    // A unordered_map to track the uploaded video\\n    unordered_map<int, int> mp;\\n    \\n    \\n    LUPrefix(int n) {\\n    \\n        this->n = n;\\n        \\n        // Create the disjoint set array\\n        parent = new int[n + 1];\\n        rankBySize = new int[n + 1];\\n        \\n        // Build the disjoint set\\n        for(int i = 1;i<=n;i++){\\n            parent[i] = i;\\n            rankBySize[i] = 1;\\n        }\\n    }\\n    \\n    // Find Utility\\n    int Find(int node){\\n        if(parent[node] == node){\\n            return node;\\n        }\\n        parent[node] = Find(parent[node]);\\n        return parent[node];\\n    }\\n    \\n    // Union\\n    void Union(int node1, int node2){\\n        int p1 = Find(node1);\\n        int p2 = Find(node2);\\n        \\n        if(p1 != p2){\\n            \\n            // We will always try to merge the parent with higher index into smaller one \\n            // Because we want our answer to be concentrated at index `1`\\n            if(p1<p2){\\n                parent[node2] = node1;\\n                rankBySize[p1]+=rankBySize[p2];\\n            }\\n            else if(p2<p1){\\n                parent[node1] = node2;\\n                rankBySize[p2]+=rankBySize[p1];\\n            }\\n        }\\n    }\\n    \\n    void upload(int video) {\\n        // Make union of video with video - 1 and video + 1\\n        // But make sure that the video - 1 and video + 1 is already uploaded\\n        if(video-1>=1 && mp[video-1]==1) Union(video, video-1);\\n        if(video+1<=n && mp[video+1]==1) Union(video, video+1);\\n        \\n        // Upload the video\\n        mp[video] = 1;\\n    }\\n    \\n    int longest() {\\n        // Return the size of disjoint set having absolute parent `1`.\\n        // If 1 video has not been uploaded yet, then still rankBySize will give 1\\n        // So we are checking whether `1` video is uploaded or not, as a base case\\n        return mp[1] ? rankBySize[1] : 0;\\n    }\\n};\\n//@MrTwinkleSharma\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646957,
                "title": "java-o-1-time-1d-array",
                "content": "```\\nclass LUPrefix {\\n    \\n    boolean[] uploaded;\\n    int max;\\n    int size;\\n    public LUPrefix(int n) {\\n        uploaded = new boolean[n + 1];\\n        max = 0;\\n        size = n;\\n    }\\n    \\n    public void upload(int video) {\\n        uploaded[video] = true;\\n\\t\\t\\n\\t\\t/** \\n\\t\\tIf the longest uploaded prefix is not the previous video then \\n\\t\\tthere must be some other video (smaller than current video) which is not uploaded yet \\n\\t\\t*/\\n        if(max != video - 1) return;\\n\\t\\t\\n\\t\\t/** \\n\\t\\tIf the longest uploaded prefix is the previous video then we can conclude that \\n\\t\\tall the videos before it have been uploaded. \\n\\t\\t\\n\\t\\tNow we need to check all videos (greater than current video) that have been uploaded and form a contigous subarray\\n\\t\\t*/\\n        while(video <= size && uploaded[video]){\\n            video++;\\n        }\\n        max = video - 1;\\n    }\\n    \\n    public int longest() {\\n        return max;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass LUPrefix {\\n    \\n    boolean[] uploaded;\\n    int max;\\n    int size;\\n    public LUPrefix(int n) {\\n        uploaded = new boolean[n + 1];\\n        max = 0;\\n        size = n;\\n    }\\n    \\n    public void upload(int video) {\\n        uploaded[video] = true;\\n\\t\\t\\n\\t\\t/** \\n\\t\\tIf the longest uploaded prefix is not the previous video then \\n\\t\\tthere must be some other video (smaller than current video) which is not uploaded yet \\n\\t\\t*/\\n        if(max != video - 1) return;\\n\\t\\t\\n\\t\\t/** \\n\\t\\tIf the longest uploaded prefix is the previous video then we can conclude that \\n\\t\\tall the videos before it have been uploaded. \\n\\t\\t\\n\\t\\tNow we need to check all videos (greater than current video) that have been uploaded and form a contigous subarray\\n\\t\\t*/\\n        while(video <= size && uploaded[video]){\\n            video++;\\n        }\\n        max = video - 1;\\n    }\\n    \\n    public int longest() {\\n        return max;\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 2646734,
                "title": "disjoint-set-java",
                "content": "# Intuition\\nFirst thing came to my mind was to use a disjoint set since different chains are merged at some point.\\n\\n\\n# Approach\\nI want to connect the current index to its left and right and maintain the total size of the chain. Disjoint set is a great candidate.\\n\\nThis approach can be used to solve this problem too:\\n[2382. Maximum Segment Sum After Removals](https://leetcode.com/contest/biweekly-contest-85/problems/maximum-segment-sum-after-removals/)\\n\\n# Complexity\\n- Time complexity: Nlog(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: N\\n\\n# Code\\n```\\nclass LUPrefix {\\n    DisjointSet d;\\n\\n    public LUPrefix(int n) {this.d = new DisjointSet(n);}\\n    \\n    public void upload(int video) {\\n        d.merge(video-1, video);\\n        d.merge(video+1, video);\\n    }\\n    \\n    public int longest() {\\n        return d.count.get(1) == null? 0:d.count.get(d.find(1));\\n    }\\n}\\nclass DisjointSet{\\n    int [] parent;\\n    Map<Integer, Integer> count;\\n    public DisjointSet(int n){\\n        this.parent = new int [n+1];\\n        Arrays.fill(parent, -1);\\n        this.count = new HashMap<>();\\n    }\\n    public void make(int x){\\n        parent[x] = x;\\n        count.put(x, 1);\\n    }\\n    public int find(int x){\\n        if(parent[x] == x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    public void merge(int x, int y){\\n        if(parent[y] == -1) make(y);\\n        if(x <= 0 || x >= parent.length || parent[x] == -1) return;\\n        int parX = find(x), parY = find(y);   \\n        if(parX != parY){\\n            parent[parX] = parY;\\n            count.put(parY, count.get(parY) + count.get(parX));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LUPrefix {\\n    DisjointSet d;\\n\\n    public LUPrefix(int n) {this.d = new DisjointSet(n);}\\n    \\n    public void upload(int video) {\\n        d.merge(video-1, video);\\n        d.merge(video+1, video);\\n    }\\n    \\n    public int longest() {\\n        return d.count.get(1) == null? 0:d.count.get(d.find(1));\\n    }\\n}\\nclass DisjointSet{\\n    int [] parent;\\n    Map<Integer, Integer> count;\\n    public DisjointSet(int n){\\n        this.parent = new int [n+1];\\n        Arrays.fill(parent, -1);\\n        this.count = new HashMap<>();\\n    }\\n    public void make(int x){\\n        parent[x] = x;\\n        count.put(x, 1);\\n    }\\n    public int find(int x){\\n        if(parent[x] == x) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    public void merge(int x, int y){\\n        if(parent[y] == -1) make(y);\\n        if(x <= 0 || x >= parent.length || parent[x] == -1) return;\\n        int parX = find(x), parY = find(y);   \\n        if(parX != parY){\\n            parent[parX] = parY;\\n            count.put(parY, count.get(parY) + count.get(parX));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653096,
                "title": "extremely-easy-solution-vector-instead-of-set-linear-solution",
                "content": "We can just use a vector and resize it to n to initialize it. We can maintain a global variable named last wihch will tell us the longest video which we can see. Total Time Complexity will be O(N) but Amortized Time Complexity will be O(1). If it helped u, don\\'t forget to upvote.\\uD83D\\uDE03\\n```\\nclass LUPrefix {\\n    vector<int>v;\\n    int last = 0;\\npublic:\\n    LUPrefix(int n) {\\n        v.resize(n);\\n    }\\n    \\n    void upload(int video) { \\n        v[video - 1] = 1;\\n    }\\n    \\n    int longest() {\\n         while(last < v.size() && v[last] == 1){\\n            last++;\\n        }\\n        return last;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass LUPrefix {\\n    vector<int>v;\\n    int last = 0;\\npublic:\\n    LUPrefix(int n) {\\n        v.resize(n);\\n    }\\n    \\n    void upload(int video) { \\n        v[video - 1] = 1;\\n    }\\n    \\n    int longest() {\\n         while(last < v.size() && v[last] == 1){\\n            last++;\\n        }\\n        return last;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647007,
                "title": "java-clean-simple-union-find",
                "content": "```\\nclass LUPrefix {\\n    int[] map;\\n\\n    public LUPrefix(int n) {\\n        map = new int[n + 1];\\n    }\\n\\n    public void upload(int video) {\\n        map[video - 1] = find(video);\\n    }\\n\\n    public int longest() {\\n        return find(0);\\n    }\\n\\n    int find(int index) {\\n        if (map[index] == 0)\\n            return index;\\n        map[index] = find(map[index]);\\n        return map[index];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LUPrefix {\\n    int[] map;\\n\\n    public LUPrefix(int n) {\\n        map = new int[n + 1];\\n    }\\n\\n    public void upload(int video) {\\n        map[video - 1] = find(video);\\n    }\\n\\n    public int longest() {\\n        return find(0);\\n    }\\n\\n    int find(int index) {\\n        if (map[index] == 0)\\n            return index;\\n        map[index] = find(map[index]);\\n        return map[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646506,
                "title": "treeset",
                "content": "```\\n/*\\nWe will maintain a sorted set of un-uploaded videos.\\nTo handle longest() query just return the first_element of the set -1\\nFor uploading videos remove the video from the set\\n*/\\nclass LUPrefix {\\n    TreeSet<Integer> set;\\n    public LUPrefix(int n) {\\n        this.set = new TreeSet<>();\\n        for(int i=1;i<=n+1;i++) set.add(i);\\n    }\\n    public void upload(int video) {\\n        set.remove(video);\\n    }\\n    public int longest() {\\n        return set.first()-1;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nWe will maintain a sorted set of un-uploaded videos.\\nTo handle longest() query just return the first_element of the set -1\\nFor uploading videos remove the video from the set\\n*/\\nclass LUPrefix {\\n    TreeSet<Integer> set;\\n    public LUPrefix(int n) {\\n        this.set = new TreeSet<>();\\n        for(int i=1;i<=n+1;i++) set.add(i);\\n    }\\n    public void upload(int video) {\\n        set.remove(video);\\n    }\\n    public int longest() {\\n        return set.first()-1;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647686,
                "title": "python-3-2424-longest-uploaded-prefix-t-m-605ms-69-4-mb",
                "content": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.stream = [False]*n\\n        self.maxLength = n\\n        self.prefLength = 0\\n        \\n    def upload(self, video: int) -> None:\\n        self.stream[video-1] = True\\n\\n    def longest(self) -> int:\\n        for i in range(self.prefLength,self.maxLength):\\n\\n            if self.stream[i]:\\n                self.prefLength = i+1\\n\\n            else: break\\n\\n        return self.prefLength\\n```\\n\\n[https://leetcode.com/submissions/detail/812946999/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.stream = [False]*n\\n        self.maxLength = n\\n        self.prefLength = 0\\n        \\n    def upload(self, video: int) -> None:\\n        self.stream[video-1] = True\\n\\n    def longest(self) -> int:\\n        for i in range(self.prefLength,self.maxLength):\\n\\n            if self.stream[i]:\\n                self.prefLength = i+1\\n\\n            else: break\\n\\n        return self.prefLength\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647658,
                "title": "c-easy-to-understand-code-short",
                "content": "![image](https://assets.leetcode.com/users/images/830cdb8a-b6c4-432c-a633-e6324e10421f_1664650348.5840409.png)\\n\\n\\tclass LUPrefix {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> v;\\n\\t\\t\\tint it=0;\\n\\t\\t\\tLUPrefix(int n) {\\n\\t\\t\\t\\tvector<int> temp(n,-1);\\n\\t\\t\\t\\tv=temp;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid upload(int video) {\\n\\t\\t\\t\\tv[video-1]=1;\\n\\t\\t\\t\\twhile(it<v.size()){\\n\\t\\t\\t\\t\\tif(v[it]==-1) break;\\n\\t\\t\\t\\t\\tit++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint longest() {\\n\\t\\t\\t\\treturn it;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/830cdb8a-b6c4-432c-a633-e6324e10421f_1664650348.5840409.png)\\n\\n\\tclass LUPrefix {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> v;\\n\\t\\t\\tint it=0;\\n\\t\\t\\tLUPrefix(int n) {\\n\\t\\t\\t\\tvector<int> temp(n,-1);\\n\\t\\t\\t\\tv=temp;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid upload(int video) {\\n\\t\\t\\t\\tv[video-1]=1;\\n\\t\\t\\t\\twhile(it<v.size()){\\n\\t\\t\\t\\t\\tif(v[it]==-1) break;\\n\\t\\t\\t\\t\\tit++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint longest() {\\n\\t\\t\\t\\treturn it;\\n\\t\\t\\t}\\n\\t\\t};",
                "codeTag": "Java"
            },
            {
                "id": 2647434,
                "title": "java-solution-hashset",
                "content": "### ***Please Upvote !!!*** **(\\u25E0\\u203F\\u25E0)**\\n```\\nclass LUPrefix {\\n    Set<Integer> set;\\n    int maxConsecutiveVideo = 0;\\n    \\n    public LUPrefix(int n) {\\n        set = new HashSet<>();\\n    }\\n    \\n    public void upload(int video) {\\n        set.add(video);\\n        while (set.contains(maxConsecutiveVideo + 1)) {\\n            maxConsecutiveVideo++;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return maxConsecutiveVideo;\\n    }\\n}\\n\\n// TC: O(1), SC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LUPrefix {\\n    Set<Integer> set;\\n    int maxConsecutiveVideo = 0;\\n    \\n    public LUPrefix(int n) {\\n        set = new HashSet<>();\\n    }\\n    \\n    public void upload(int video) {\\n        set.add(video);\\n        while (set.contains(maxConsecutiveVideo + 1)) {\\n            maxConsecutiveVideo++;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return maxConsecutiveVideo;\\n    }\\n}\\n\\n// TC: O(1), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646605,
                "title": "easy-implementation-o-n-in-vector-comments-beginner-friendly",
                "content": "\\tclass LUPrefix {\\n    private:\\n    vector<int> v;\\n    int i;\\n\\tpublic:\\n    LUPrefix(int n) {\\n        v.resize(n+1);\\n\\t\\t//take i from start\\n        i=0;\\n       // memset(v.begin(),v.end(),0);\\n    }\\n    \\n    void upload(int video) {\\n\\t//upload it to the previous index so we can track it\\n        v[video-1]=1;\\n    }\\n    \\n    int longest() {\\n\\t// increase the index until we get the empty slot\\n        while(v[i]==1){\\n            i++;\\n        }\\n        return i;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Design"
                ],
                "code": "\\tclass LUPrefix {\\n    private:\\n    vector<int> v;\\n    int i;\\n\\tpublic:\\n    LUPrefix(int n) {\\n        v.resize(n+1);\\n\\t\\t//take i from start\\n        i=0;\\n       // memset(v.begin(),v.end(),0);\\n    }\\n    \\n    void upload(int video) {\\n\\t//upload it to the previous index so we can track it\\n        v[video-1]=1;\\n    }\\n    \\n    int longest() {\\n\\t// increase the index until we get the empty slot\\n        while(v[i]==1){\\n            i++;\\n        }\\n        return i;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 3262705,
                "title": "98-faster-c-use-array-easy-approach",
                "content": "```\\nclass LUPrefix {\\npublic:\\n    int x = 1;\\n    vector<bool> v;\\n    LUPrefix(int n) {\\n        v.resize(100002,false);\\n    }\\n    \\n    void upload(int video) {\\n        v[video] = true;\\n        while(v[x]==true){\\n            x++;\\n        }\\n    }\\n    \\n    int longest() {\\n        return x-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    int x = 1;\\n    vector<bool> v;\\n    LUPrefix(int n) {\\n        v.resize(100002,false);\\n    }\\n    \\n    void upload(int video) {\\n        v[video] = true;\\n        while(v[x]==true){\\n            x++;\\n        }\\n    }\\n    \\n    int longest() {\\n        return x-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3146300,
                "title": "easy-solution-using-max-min-heap",
                "content": "\\n\\n# Code\\n```\\nclass LUPrefix {\\npublic:\\n    priority_queue<int>q;\\n    priority_queue<int,vector<int>,greater<int>>q2;\\n    int prev;\\n    LUPrefix(int n) {\\n        prev=0;\\n    }\\n    \\n    void upload(int video) {\\n        q.push(video);\\n        q2.push(video);\\n    }\\n    \\n    int longest() {\\n        if(!q.empty() && q.size()==q.top())return q.top();\\n        else if(!q2.empty()){\\n            int res=prev;\\n            while(res+1==q2.top()){\\n                res++;\\n                q2.pop();\\n            }\\n            prev=res; \\n            return res;             \\n\\n        }\\n        else \\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    priority_queue<int>q;\\n    priority_queue<int,vector<int>,greater<int>>q2;\\n    int prev;\\n    LUPrefix(int n) {\\n        prev=0;\\n    }\\n    \\n    void upload(int video) {\\n        q.push(video);\\n        q2.push(video);\\n    }\\n    \\n    int longest() {\\n        if(!q.empty() && q.size()==q.top())return q.top();\\n        else if(!q2.empty()){\\n            int res=prev;\\n            while(res+1==q2.top()){\\n                res++;\\n                q2.pop();\\n            }\\n            prev=res; \\n            return res;             \\n\\n        }\\n        else \\n        return 0;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648433,
                "title": "c-using-vector-time-complexity-o-n-space-complexity-o-n",
                "content": "```\\nclass LUPrefix {\\nprivate:\\n    int i;\\n    int n;\\n    vector<int> nums;\\npublic:\\n    LUPrefix(int N) {\\n        i = 0;\\n        n = N+2;\\n        nums.resize(n, -1);\\n    }\\n    \\n    void upload(int video) {\\n        nums[video] = 1;\\n        while(i<n && (nums[i+1]!=-1)){\\n            i++;\\n        } \\n        return;\\n    }\\n    \\n    int longest() {\\n        return i;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass LUPrefix {\\nprivate:\\n    int i;\\n    int n;\\n    vector<int> nums;\\npublic:\\n    LUPrefix(int N) {\\n        i = 0;\\n        n = N+2;\\n        nums.resize(n, -1);\\n    }\\n    \\n    void upload(int video) {\\n        nums[video] = 1;\\n        while(i<n && (nums[i+1]!=-1)){\\n            i++;\\n        } \\n        return;\\n    }\\n    \\n    int longest() {\\n        return i;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647336,
                "title": "few-lines-of-code-that-you-should-see-o-1",
                "content": "![image](https://assets.leetcode.com/users/images/98976518-fc55-4008-a8ae-2d03da6a3a3e_1664646440.7935584.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/98976518-fc55-4008-a8ae-2d03da6a3a3e_1664646440.7935584.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2646951,
                "title": "c-easy-understanding",
                "content": "Self Explanatory Solution\\n\\n```class LUPrefix {\\npublic:\\n    int ans=0;\\n    vector< int >isUpdated;\\n    \\n    LUPrefix( int n ) {\\n        isUpdated.assign( n+2 , 0 );\\n    }\\n    \\n    void upload( int video ) {\\n        isUpdated[ video ] = 1;\\n        while ( isUpdated[ ans + 1 ] == 1 )\\n        {\\n            ans++;\\n        }   \\n    }\\n    \\n    int longest() {\\n        return ans;\\n    }\\n};\\n```\\n\\n**Fenwick Tree based Solution**\\n\\nUse binary search to find count of elements from 1 to k\\n\\nif the count == k, this shows that answer can be k or more than that\\n\\nTo find the count, we use fenwick tree\\n\\n```class LUPrefix {\\npublic:\\n    vector< int >fen;\\n    int N;\\n    void update ( int i )\\n    {\\n        while( i < N )\\n        {\\n            fen[ i ]++;\\n            i += ( i&-i );\\n        }\\n    }\\n    int query( int i )\\n    {\\n        int ans = 0;\\n        while( i > 0 )\\n        {\\n            ans += fen[i];\\n            i -= ( i&-i );\\n        }\\n        return ans;\\n    }\\n    \\n    LUPrefix( int n ) {\\n        N = n + 2;\\n        fen.assign( n + 5 , 0 );\\n        \\n    }\\n    void upload( int video ) {\\n        update( video );\\n    }\\n    int longest() {\\n        int l = 0, h = N - 1 , ans = 0;\\n        while(l <= h)\\n        {\\n            int m = ( l + h ) / 2;\\n            if( query( m ) == m )\\n            {\\n                ans = m;\\n                l = m + 1;\\n            }\\n            else{\\n                h = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```class LUPrefix {\\npublic:\\n    int ans=0;\\n    vector< int >isUpdated;\\n    \\n    LUPrefix( int n ) {\\n        isUpdated.assign( n+2 , 0 );\\n    }\\n    \\n    void upload( int video ) {\\n        isUpdated[ video ] = 1;\\n        while ( isUpdated[ ans + 1 ] == 1 )\\n        {\\n            ans++;\\n        }   \\n    }\\n    \\n    int longest() {\\n        return ans;\\n    }\\n};\\n```\n```class LUPrefix {\\npublic:\\n    vector< int >fen;\\n    int N;\\n    void update ( int i )\\n    {\\n        while( i < N )\\n        {\\n            fen[ i ]++;\\n            i += ( i&-i );\\n        }\\n    }\\n    int query( int i )\\n    {\\n        int ans = 0;\\n        while( i > 0 )\\n        {\\n            ans += fen[i];\\n            i -= ( i&-i );\\n        }\\n        return ans;\\n    }\\n    \\n    LUPrefix( int n ) {\\n        N = n + 2;\\n        fen.assign( n + 5 , 0 );\\n        \\n    }\\n    void upload( int video ) {\\n        update( video );\\n    }\\n    int longest() {\\n        int l = 0, h = N - 1 , ans = 0;\\n        while(l <= h)\\n        {\\n            int m = ( l + h ) / 2;\\n            if( query( m ) == m )\\n            {\\n                ans = m;\\n                l = m + 1;\\n            }\\n            else{\\n                h = m - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646827,
                "title": "python-clean",
                "content": "```\\n# N2. Longest Uploaded Prefix\\nclass LUPrefix:\\n    def __init__(self, n: int):\\n        self.arr = [0] * (n + 2)\\n        self.ans = 0\\n\\n    def upload(self, video: int) -> None:\\n        self.arr[video] = 1\\n\\n    def longest(self) -> int:\\n        # answer only grows up, by 1\\n        while self.arr[self.ans + 1]:\\n            self.ans += 1\\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```\\n# N2. Longest Uploaded Prefix\\nclass LUPrefix:\\n    def __init__(self, n: int):\\n        self.arr = [0] * (n + 2)\\n        self.ans = 0\\n\\n    def upload(self, video: int) -> None:\\n        self.arr[video] = 1\\n\\n    def longest(self) -> int:\\n        # answer only grows up, by 1\\n        while self.arr[self.ans + 1]:\\n            self.ans += 1\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646808,
                "title": "c-easy-to-understand-using-vector",
                "content": "```\\nclass LUPrefix {\\npublic:\\n    vector<int> v;\\n    int maxi=1;\\n    LUPrefix(int n) \\n    {\\n        v.resize(n+2, 0);  \\n        v[0]=1;\\n        maxi=1;\\n    }\\n    \\n    void upload(int video) \\n    {\\n        v[video]=1; \\n        while(v[maxi])\\n            maxi++;\\n    }\\n    \\n    int longest() \\n    {\\n        return maxi-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    vector<int> v;\\n    int maxi=1;\\n    LUPrefix(int n) \\n    {\\n        v.resize(n+2, 0);  \\n        v[0]=1;\\n        maxi=1;\\n    }\\n    \\n    void upload(int video) \\n    {\\n        v[video]=1; \\n        while(v[maxi])\\n            maxi++;\\n    }\\n    \\n    int longest() \\n    {\\n        return maxi-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646776,
                "title": "one-liner-functions-using-vectors-o-n-solution",
                "content": "Explanation :\\n1)    i(variable) stores the current index upto which video prefixes from 1 to i-1 are all uploades.\\n2)   If a videos is uploaded while loop will loop till it gets an unuploaded video \\n3)   Since all values are being travel only once the time complextity will be O(n).\\n\\n```\\nclass LUPrefix {\\npublic:\\n    int vec[100001]={0};\\n    int i=1;\\n    LUPrefix(int n) \\n    {\\n    }\\n    void upload(int video) \\n    {\\n        vec[video]=1;\\n        while(vec[i])i++;\\n    }\\n    \\n    int longest() \\n    {\\n        return i-1;\\n    }\\n};\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    int vec[100001]={0};\\n    int i=1;\\n    LUPrefix(int n) \\n    {\\n    }\\n    void upload(int video) \\n    {\\n        vec[video]=1;\\n        while(vec[i])i++;\\n    }\\n    \\n    int longest() \\n    {\\n        return i-1;\\n    }\\n};\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646671,
                "title": "o-n-solution-with-most-easy-solution-and-question-too",
                "content": "****Very Simple and Straight Forward Approch\\n\\n```\\nclass LUPrefix {\\n\\n    private:  vector<bool>server;\\n                int ind=-1,maxi=0,_n;\\n    public:\\n    LUPrefix(int n) {\\n        server.resize(n+5,0);\\n        server[0]=1;\\n        _n=n;\\n    }\\n    \\n    void upload(int video) {\\n        server[video]=1;\\n        if(server[video-1]==1)check();\\n    }\\n    \\n    int longest() {\\n        return maxi;\\n    }\\n    void check(){\\n        while(maxi<=_n && server[maxi]!=0){\\n            maxi++;\\n        }\\n        maxi--;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass LUPrefix {\\n\\n    private:  vector<bool>server;\\n                int ind=-1,maxi=0,_n;\\n    public:\\n    LUPrefix(int n) {\\n        server.resize(n+5,0);\\n        server[0]=1;\\n        _n=n;\\n    }\\n    \\n    void upload(int video) {\\n        server[video]=1;\\n        if(server[video-1]==1)check();\\n    }\\n    \\n    int longest() {\\n        return maxi;\\n    }\\n    void check(){\\n        while(maxi<=_n && server[maxi]!=0){\\n            maxi++;\\n        }\\n        maxi--;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646587,
                "title": "python3-one-pass-solution-o-n-clean-concise",
                "content": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.videos = [False] * (n + 1)\\n        self.ans = 0\\n\\n    def upload(self, video: int) -> None:\\n        self.videos[video] = True\\n        if video == self.ans + 1:\\n            while video < len(self.videos):\\n                if not self.videos[video]:\\n                    break\\n                self.ans += 1\\n                video += 1\\n\\n    def longest(self) -> int:\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.videos = [False] * (n + 1)\\n        self.ans = 0\\n\\n    def upload(self, video: int) -> None:\\n        self.videos[video] = True\\n        if video == self.ans + 1:\\n            while video < len(self.videos):\\n                if not self.videos[video]:\\n                    break\\n                self.ans += 1\\n                video += 1\\n\\n    def longest(self) -> int:\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646566,
                "title": "simple-code-streak-method",
                "content": "```\\nunordered_map<int, int> mp;\\n    LUPrefix(int n) {\\n        for(int i=0;i<n;i++)\\n            mp[i+1] = 0;\\n    }\\n    \\n    void upload(int video) {\\n        int right = video + 1;\\n        int left = video - 1;\\n        int rightStreak = 0, leftStreak = 0;\\n        \\n        if(mp[right]!=0)\\n            rightStreak = mp[right];\\n        if(mp[left]!=0)\\n            leftStreak = mp[left];\\n        \\n        int streak = leftStreak + rightStreak + 1;\\n        mp[video] = streak;\\n        mp[right + rightStreak - 1] = streak;\\n        mp[left - leftStreak + 1] = streak;\\n    }\\n    \\n    int longest() {\\n        return mp[1];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nunordered_map<int, int> mp;\\n    LUPrefix(int n) {\\n        for(int i=0;i<n;i++)\\n            mp[i+1] = 0;\\n    }\\n    \\n    void upload(int video) {\\n        int right = video + 1;\\n        int left = video - 1;\\n        int rightStreak = 0, leftStreak = 0;\\n        \\n        if(mp[right]!=0)\\n            rightStreak = mp[right];\\n        if(mp[left]!=0)\\n            leftStreak = mp[left];\\n        \\n        int streak = leftStreak + rightStreak + 1;\\n        mp[video] = streak;\\n        mp[right + rightStreak - 1] = streak;\\n        mp[left - leftStreak + 1] = streak;\\n    }\\n    \\n    int longest() {\\n        return mp[1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3878894,
                "title": "java-average-time-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LUPrefix {\\n    int[] ans;\\n    int uploadedUpto;\\n    public LUPrefix(int n) {\\n        ans = new int[n];\\n    }\\n    \\n    public void upload(int video) {\\n        ans[video-1] = 1;\\n    }\\n    \\n    public int longest() {\\n        for(int i=uploadedUpto;i<ans.length;i++) {\\n            if(ans[i] == 1) {\\n                uploadedUpto++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return uploadedUpto;\\n    }\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LUPrefix {\\n    int[] ans;\\n    int uploadedUpto;\\n    public LUPrefix(int n) {\\n        ans = new int[n];\\n    }\\n    \\n    public void upload(int video) {\\n        ans[video-1] = 1;\\n    }\\n    \\n    public int longest() {\\n        for(int i=uploadedUpto;i<ans.length;i++) {\\n            if(ans[i] == 1) {\\n                uploadedUpto++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return uploadedUpto;\\n    }\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117662,
                "title": "python-union-find",
                "content": "\\n# Code\\n```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.videos = list(range(n + 1))\\n        self.uploaded = [1] + [0] * (n + 1)\\n\\n    def upload(self, video: int) -> None:\\n        self.uploaded[video] = 1\\n        if self.uploaded[video + 1]: self.union(video, video + 1)\\n        if self.uploaded[video - 1]: self.union(video, video - 1)\\n\\n    def union(self, u, v):\\n        x, y = self.find(u), self.find(v)\\n        if x > y: self.videos[y] = x\\n        elif y > x: self.videos[x] = y\\n\\n    def find(self, u):\\n        if u == self.videos[u]: return u\\n        self.videos[u] = self.find(self.videos[u])\\n        return self.videos[u]\\n\\n    def longest(self) -> int:\\n        return self.find(0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.videos = list(range(n + 1))\\n        self.uploaded = [1] + [0] * (n + 1)\\n\\n    def upload(self, video: int) -> None:\\n        self.uploaded[video] = 1\\n        if self.uploaded[video + 1]: self.union(video, video + 1)\\n        if self.uploaded[video - 1]: self.union(video, video - 1)\\n\\n    def union(self, u, v):\\n        x, y = self.find(u), self.find(v)\\n        if x > y: self.videos[y] = x\\n        elif y > x: self.videos[x] = y\\n\\n    def find(self, u):\\n        if u == self.videos[u]: return u\\n        self.videos[u] = self.find(self.videos[u])\\n        return self.videos[u]\\n\\n    def longest(self) -> int:\\n        return self.find(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905385,
                "title": "very-simple-solution-using-bitarray",
                "content": "# Intuition\\nUse an array to keep the indexes of the videos that has been uploaded, and a variable llp (Last Longest Prefix) to keep the last longer prefix\\n\\n# Approach\\nUse bit array to keep the indexes of the uploaded videos, and precalculate the LUP on each upload, this means to loop through the bit array until a non uploaded video is found. \\n\\n# Complexity\\n- Time complexity:\\n**Constructor**: $$O(1)$$\\n**Upload**: $$O(1)$$\\n**Longest**: $$O(1)$$\\n\\n- Space complexity:\\n**Constructor**: $$O(n)$$, one bit per each __ith__ video\\n**Upload**: $$O(1)$$\\n**Longest**: $$O(1)$$\\n\\n# Code\\n```\\npublic class LUPrefix {\\n  private int llp = 0;\\n  private readonly BitArray b;\\n  public LUPrefix(int n) => b = new(n);\\n\\n  public void Upload(int video) {\\n    if(b[video - 1])\\n      return;\\n    b[video - 1] = true;\\n    while(llp< b.Length && b[llp])\\n      llp++;\\n  }\\n\\n  public int Longest() => llp;\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.Upload(video);\\n * int param_2 = obj.Longest();\\n */\\n```",
                "solutionTags": [
                    "C#",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class LUPrefix {\\n  private int llp = 0;\\n  private readonly BitArray b;\\n  public LUPrefix(int n) => b = new(n);\\n\\n  public void Upload(int video) {\\n    if(b[video - 1])\\n      return;\\n    b[video - 1] = true;\\n    while(llp< b.Length && b[llp])\\n      llp++;\\n  }\\n\\n  public int Longest() => llp;\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.Upload(video);\\n * int param_2 = obj.Longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777670,
                "title": "easiest-approach-c-vector",
                "content": "```\\nclass LUPrefix {\\npublic:\\n    vector<int> arr;\\n    int ptr = 0;\\n    LUPrefix(int n) {\\n        arr.resize(n, 0);\\n    }\\n    \\n    void upload(int video) {\\n        arr[video-1]++;\\n    }\\n    \\n    int longest() {\\n        while(ptr < arr.size() && arr[ptr] != 0)\\n            ptr++;\\n        return ptr;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    vector<int> arr;\\n    int ptr = 0;\\n    LUPrefix(int n) {\\n        arr.resize(n, 0);\\n    }\\n    \\n    void upload(int video) {\\n        arr[video-1]++;\\n    }\\n    \\n    int longest() {\\n        while(ptr < arr.size() && arr[ptr] != 0)\\n            ptr++;\\n        return ptr;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726545,
                "title": "easy-javascript-solution-with-array-max-731-ms",
                "content": "```\\nclass LUPrefix{\\n    constructor(n){\\n        this.i = 0;\\n        this.arr = new Array(n);\\n        //console.log(this.arr);\\n    }\\n    /** \\n * @param {number} video\\n * @return {void}\\n */\\n    upload = function(video) {\\n        this.arr[video-1] = video;\\n    }\\n\\n/**\\n * @return {number}\\n */\\n    longest = function() {\\n\\n        for(;this.i<this.arr.length;this.i++){\\n            if(!this.arr[this.i]){\\n                return this.i;\\n            }                 \\n        }\\n      return this.i;\\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "```\\nclass LUPrefix{\\n    constructor(n){\\n        this.i = 0;\\n        this.arr = new Array(n);\\n        //console.log(this.arr);\\n    }\\n    /** \\n * @param {number} video\\n * @return {void}\\n */\\n    upload = function(video) {\\n        this.arr[video-1] = video;\\n    }\\n\\n/**\\n * @return {number}\\n */\\n    longest = function() {\\n\\n        for(;this.i<this.arr.length;this.i++){\\n            if(!this.arr[this.i]){\\n                return this.i;\\n            }                 \\n        }\\n      return this.i;\\n    }\\n    \\n};",
                "codeTag": "Java"
            },
            {
                "id": 2671913,
                "title": "java-treeset-union-find",
                "content": "```set contains all the videos which are not yet uploaded so smallest number in the TreeSet represent the smallest numbered video that needs to be uploaded.```\\n\\n```\\nclass LUPrefix {\\n    TreeSet<Integer> set = new TreeSet<>();\\n    public LUPrefix(int n) {\\n        for (int i = 1; i <= n + 1; i++) {\\n            set.add(i);\\n        }\\n    }\\n    \\n    public void upload(int video) {\\n        set.remove(video);\\n    }\\n    \\n    public int longest() {\\n        return set.first() - 1;\\n    }\\n}\\n```\\n```Union Find```\\n```\\nclass LUPrefix {\\n    public int find(int a) {\\n        return a == par[a] ? a : (par[a] = find(par[a]));\\n    }\\n    \\n    public void union(int a, int b) {\\n        int parA = find(a);\\n        int parB = find(b);\\n        if (parA > parB) {\\n            par[parB] = parA;\\n        } else {\\n            par[parA] = parB;\\n        }\\n    }\\n    \\n    int[] par;\\n    boolean[] uploaded;\\n    public LUPrefix(int n) {\\n        par = new int[n + 2];\\n        uploaded = new boolean[n + 2];\\n        uploaded[0]=  true;\\n        for (int i = 0; i < n + 1; i++) {\\n            par[i] = i;\\n        }\\n    }\\n    \\n    public void upload(int video) {\\n        uploaded[video] = true;\\n        if (uploaded[video - 1]) union(video, video - 1);\\n        if (uploaded[video + 1]) union(video, video + 1);\\n    }\\n    \\n    public int longest() {\\n        return find(0);\\n    }\\n}",
                "solutionTags": [],
                "code": "```set contains all the videos which are not yet uploaded so smallest number in the TreeSet represent the smallest numbered video that needs to be uploaded.```\n```\\nclass LUPrefix {\\n    TreeSet<Integer> set = new TreeSet<>();\\n    public LUPrefix(int n) {\\n        for (int i = 1; i <= n + 1; i++) {\\n            set.add(i);\\n        }\\n    }\\n    \\n    public void upload(int video) {\\n        set.remove(video);\\n    }\\n    \\n    public int longest() {\\n        return set.first() - 1;\\n    }\\n}\\n```\n```Union Find```",
                "codeTag": "Java"
            },
            {
                "id": 2670820,
                "title": "rust-hashset-o-n",
                "content": "Only record the current end of the prefix [1..i].  Keep extending it while can be extended.\\n```\\nuse std::collections::HashSet;\\n\\nstruct LUPrefix {\\n    points: HashSet<i32>,\\n    far: i32,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl LUPrefix {\\n\\n    fn new(n: i32) -> Self {\\n        Self {\\n            points: HashSet::new(),\\n            far: 0\\n        }\\n    }\\n    \\n    fn upload(&mut self, video: i32) {\\n        self.points.insert(video);\\n        while self.points.len() > 0 {\\n            let post = self.far + 1;\\n            if self.points.contains(&post) {\\n                self.far += 1;\\n                self.points.remove(&post);\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    fn longest(&self) -> i32 {\\n        self.far\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashSet;\\n\\nstruct LUPrefix {\\n    points: HashSet<i32>,\\n    far: i32,\\n}\\n\\n\\n/** \\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl LUPrefix {\\n\\n    fn new(n: i32) -> Self {\\n        Self {\\n            points: HashSet::new(),\\n            far: 0\\n        }\\n    }\\n    \\n    fn upload(&mut self, video: i32) {\\n        self.points.insert(video);\\n        while self.points.len() > 0 {\\n            let post = self.far + 1;\\n            if self.points.contains(&post) {\\n                self.far += 1;\\n                self.points.remove(&post);\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    fn longest(&self) -> i32 {\\n        self.far\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2668350,
                "title": "c-array",
                "content": "**Approch** :-\\n1.] Here I am going to use a three number which is -1,0,1 which is as follows ( -1 -> not uploded, 0 -> uploaded but not created prefix , 1 -> uploaded and created bond with prefix ).\\n2.]  In upload function what i am going to do is if **curr-1th** is connectd with prefix so we can expand prefix from **curr to elm till elm have 0 means already uploaded**.\\n3.] Example :- (-1,-1,-1,-1) i.e. no video is uploaded => upload 3rd => (-1,-1,0,-1) => upload 2nd => (-1,0,0,-1) => upload 1 => (1,1,1,-1)\\n\\n**c++ code**\\n```\\nint len;\\n    int dp[1000002];\\n    int longestpre=0;\\n        \\n    LUPrefix(int n) {\\n        len=n;\\n        memset(dp,-1,sizeof(dp));\\n        dp[0]=1;\\n    }\\n    \\n    void upload(int idx) {\\n        dp[idx]=0;\\n      \\n        if(dp[idx-1]==1){\\n            while(idx<=len && dp[idx]==0){\\n                longestpre=max(longestpre,idx);\\n                dp[idx]=1;\\n                idx++;\\n            }\\n        }\\n    }\\n    \\n    int longest() {\\n       return longestpre;\\n    }\\n\\t//code by sachin\\n```\\n**upvote is solution was helpful**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nint len;\\n    int dp[1000002];\\n    int longestpre=0;\\n        \\n    LUPrefix(int n) {\\n        len=n;\\n        memset(dp,-1,sizeof(dp));\\n        dp[0]=1;\\n    }\\n    \\n    void upload(int idx) {\\n        dp[idx]=0;\\n      \\n        if(dp[idx-1]==1){\\n            while(idx<=len && dp[idx]==0){\\n                longestpre=max(longestpre,idx);\\n                dp[idx]=1;\\n                idx++;\\n            }\\n        }\\n    }\\n    \\n    int longest() {\\n       return longestpre;\\n    }\\n\\t//code by sachin\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2667082,
                "title": "c-easy-and-concise-solution",
                "content": "Happy Leetcoding !\\n\\n```\\nclass LUPrefix {\\npublic:\\n    set<int>st;\\n    LUPrefix(int n) {\\n        for(int i=1;i<=n+1;i++)\\n        {\\n            st.insert(i);\\n        }\\n    }\\n    \\n    void upload(int video) {\\n        st.erase(video);\\n    }\\n    \\n    int longest() {\\n       return (*st.begin())-1;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    set<int>st;\\n    LUPrefix(int n) {\\n        for(int i=1;i<=n+1;i++)\\n        {\\n            st.insert(i);\\n        }\\n    }\\n    \\n    void upload(int video) {\\n        st.erase(video);\\n    }\\n    \\n    int longest() {\\n       return (*st.begin())-1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661015,
                "title": "easy-js-solution-queue",
                "content": "**Explanation:**\\nData structure : Queue. \\n\\n```\\nvar LUPrefix = function(n) {\\n    let q = new Array(n).fill(0);\\n    this.q = q;\\n    this.f = 0; //\"f\" is front of queue\\n};\\n\\n//O(1)\\nLUPrefix.prototype.upload = function(video) {\\n    this.q[video - 1] = 1;\\n};\\n\\n//O(n)\\nLUPrefix.prototype.longest = function() {\\n    while(this.q[this.f] && this.f < this.q.length) {\\n        this.f += 1;\\n    }\\n    return this.f;\\n};\\n ```",
                "solutionTags": [
                    "JavaScript",
                    "Queue"
                ],
                "code": "```\\nvar LUPrefix = function(n) {\\n    let q = new Array(n).fill(0);\\n    this.q = q;\\n    this.f = 0; //\"f\" is front of queue\\n};\\n\\n//O(1)\\nLUPrefix.prototype.upload = function(video) {\\n    this.q[video - 1] = 1;\\n};\\n\\n//O(n)\\nLUPrefix.prototype.longest = function() {\\n    while(this.q[this.f] && this.f < this.q.length) {\\n        this.f += 1;\\n    }\\n    return this.f;\\n};\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2655341,
                "title": "rust-fastest-100-solution-using-boolean-array-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/814188631/) employs a simple boolean array to store the upload status that is used to update longest prefix index. It demonstrated **98 ms runtime (100.00%)** and used **54.5 MB memory (100.00%)**. Time complexity is linear: **O(N)**. Space complexity is constant: **O(1)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nstruct LUPrefix \\n{\\n    prefixes       : Vec<bool>,\\n    longest_prefix : i32\\n}\\n\\nimpl LUPrefix \\n{\\n    fn new(n: i32) -> Self \\n    {\\n        LUPrefix{ prefixes: vec![false;n as usize +2], longest_prefix: 0 }\\n    }\\n    \\n    fn upload(&mut self, video: i32) \\n    {\\n        self.prefixes[video as usize] = true;\\n    }\\n    \\n    fn longest(&mut self) -> i32\\n    {\\n        // on request, update the longest prefix using \\n        // the upload status data from the boolean array \\n        while self.prefixes[self.longest_prefix as usize + 1]\\n        {\\n            self.longest_prefix += 1;\\n        }\\n\\n        self.longest_prefix\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Array"
                ],
                "code": "```\\nstruct LUPrefix \\n{\\n    prefixes       : Vec<bool>,\\n    longest_prefix : i32\\n}\\n\\nimpl LUPrefix \\n{\\n    fn new(n: i32) -> Self \\n    {\\n        LUPrefix{ prefixes: vec![false;n as usize +2], longest_prefix: 0 }\\n    }\\n    \\n    fn upload(&mut self, video: i32) \\n    {\\n        self.prefixes[video as usize] = true;\\n    }\\n    \\n    fn longest(&mut self) -> i32\\n    {\\n        // on request, update the longest prefix using \\n        // the upload status data from the boolean array \\n        while self.prefixes[self.longest_prefix as usize + 1]\\n        {\\n            self.longest_prefix += 1;\\n        }\\n\\n        self.longest_prefix\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2653705,
                "title": "c-solution-using-fenwick-tree-binary-search",
                "content": "**Solution:**\\n```\\ntemplate<typename T>\\nclass BIT {\\npublic:\\n    vector<T> bit;\\n    int n;\\n    \\n    BIT() {}\\n    \\n    BIT(int _n) {\\n        n = _n;\\n        bit = vector<T>(n, 0LL);\\n    }\\n    \\n    void inc(int idx, T val) {\\n        for(int i = idx + 1; i <= n; i += (i & -i)) \\n            bit[i - 1] += val;\\n    }\\n    \\n    T at(int idx) {\\n        T res = 0;\\n        for(int i = idx + 1; i > 0; i -= (i & -i)) \\n            res += bit[i - 1];\\n        return res;\\n    }\\n    \\n    T at(int l, int r) {\\n        return at(r) - (l - 1 >= 0? at(l - 1): 0);\\n    }\\n    \\n};\\n\\nclass LUPrefix {\\npublic:\\n    BIT<int> bit;\\n    \\n    LUPrefix(int n) {\\n        bit = BIT<int>(1e5 + 2);    \\n    }\\n    \\n    void upload(int video) {\\n        bit.inc(video, 1);\\n    }\\n    \\n    int longest() {\\n        int l = 0, r = 1e5 + 1;\\n        while(r - l > 1) {\\n            int m = l + (r - l) / 2;\\n            if(bit.at(1, m) >= m) l = m;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */",
                "solutionTags": [
                    "Binary Indexed Tree",
                    "Binary Tree"
                ],
                "code": "**Solution:**\\n```\\ntemplate<typename T>\\nclass BIT {\\npublic:\\n    vector<T> bit;\\n    int n;\\n    \\n    BIT() {}\\n    \\n    BIT(int _n) {\\n        n = _n;\\n        bit = vector<T>(n, 0LL);\\n    }\\n    \\n    void inc(int idx, T val) {\\n        for(int i = idx + 1; i <= n; i += (i & -i)) \\n            bit[i - 1] += val;\\n    }\\n    \\n    T at(int idx) {\\n        T res = 0;\\n        for(int i = idx + 1; i > 0; i -= (i & -i)) \\n            res += bit[i - 1];\\n        return res;\\n    }\\n    \\n    T at(int l, int r) {\\n        return at(r) - (l - 1 >= 0? at(l - 1): 0);\\n    }\\n    \\n};\\n\\nclass LUPrefix {\\npublic:\\n    BIT<int> bit;\\n    \\n    LUPrefix(int n) {\\n        bit = BIT<int>(1e5 + 2);    \\n    }\\n    \\n    void upload(int video) {\\n        bit.inc(video, 1);\\n    }\\n    \\n    int longest() {\\n        int l = 0, r = 1e5 + 1;\\n        while(r - l > 1) {\\n            int m = l + (r - l) / 2;\\n            if(bit.at(1, m) >= m) l = m;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2652633,
                "title": "python-3-only-update-left-and-right-endpoints-time-o-1-space-o-n",
                "content": "If we maintain a list for all the segments so far, the longest uploaded prefix essentially is the size of the first element a.k.a `self.P[1]` in my case for avoiding index overflow.\\n\\nThe only tricky part is the way to update left&right most endpoints: \\n1. find left most endpoint(`x-self.P[x-1]`) and rightmost endpoint(`x+self.P[x+1]`)\\n2. update the whole segment by summing up two segments and plus more element (`self.P[x-1]+self.P[x+1]+1`)\\n\\n```\\nclass LUPrefix:\\n    def __init__(self, n: int):\\n        self.P = [0]*(n+2)\\n\\n    def upload(self, x: int) -> None:\\n        self.P[x-self.P[x-1]] = self.P[x+self.P[x+1]] = self.P[x-1]+self.P[x+1]+1\\n\\n    def longest(self) -> int:\\n        return self.P[1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass LUPrefix:\\n    def __init__(self, n: int):\\n        self.P = [0]*(n+2)\\n\\n    def upload(self, x: int) -> None:\\n        self.P[x-self.P[x-1]] = self.P[x+self.P[x+1]] = self.P[x-1]+self.P[x+1]+1\\n\\n    def longest(self) -> int:\\n        return self.P[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652561,
                "title": "c-simple-solution",
                "content": "The idea is that after one video has been uploaded, it will never be removed, which means the logested prefix keeps growing and we can simply track the  by a single variable. (The intuition here is very samilar to sliding window)\\nAnd since the simple variable will move from 0 to n. We know the time complixity is actually O(n). The solution is good enough and no need for any other fancy data structure. \\nCode below \\n```\\nclass LUPrefix {\\npublic:\\n    vector<int> data; \\n    int s = 0; \\n    LUPrefix(int n) {\\n        data.resize(n);\\n    }\\n    \\n    void upload(int i) {\\n        data[i-1] = 1; \\n    }\\n    \\n    int longest() {\\n        while(s<data.size()&&data[s]) {\\n            s++;\\n        }\\n        return s; \\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    vector<int> data; \\n    int s = 0; \\n    LUPrefix(int n) {\\n        data.resize(n);\\n    }\\n    \\n    void upload(int i) {\\n        data[i-1] = 1; \\n    }\\n    \\n    int longest() {\\n        while(s<data.size()&&data[s]) {\\n            s++;\\n        }\\n        return s; \\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2652032,
                "title": "java-three-approaches-segment-tree-binary-search-union-find-array-based",
                "content": "\\n\\n# Segment Tree + Binary Search\\n```\\n\\nclass LUPrefix {\\n    int tree [] ;\\n    int update(int l , int r , int index,int value){\\n        if(l==r && l==value){\\n            tree[index] = 1;\\n            return 1;\\n        }\\n        int mid = (l+r)/2;\\n        if(r<value || value<l) return tree[index];\\n        else{\\n            int left = update(l,mid,2*index+1,value);\\n            int right = update(mid+1,r,2*index+2,value);\\n            tree[index]=left+right;\\n            return tree[index];\\n        }\\n        \\n    }\\n    \\n    \\n    int query(int l ,int r , int index , int a , int b){\\n        if(a<=l && b>=r)\\n            return tree[index];\\n        else if(b<l || a>r) return 0;\\n        else\\n        {\\n            int mid = (l+r)/2;\\n            int left = query(l,mid,2*index+1,a,b);\\n            int right = query(mid+1,r,2*index+2,a,b);\\n            return left+right;\\n        }\\n    }\\n    int n;\\n    public LUPrefix(int n) {\\n        tree = new int[4*n];\\n        this.n = n;\\n    }\\n    \\n    public void upload(int video) {\\n        update(1,n,0,video);\\n    }\\n    \\n    public int longest() {\\n        int low = 1;\\n        int high = n;\\n        int ans = 0;\\n        while(low<=high){\\n            \\n            int mid = (low + high)/2;\\n            \\n            int count = query(1,n,0,1,mid);\\n            if(count == mid){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n        \\n    }\\n}\\n\\n```\\n\\n# Union Find \\n\\n```\\n\\nclass LUPrefix {\\n    int [] parent ;\\n\\n    int find(int a ){\\n        if(parent[a]==a) return a;\\n        return parent[a]=find(parent[a]);\\n    }\\n\\n    void union(int a , int b){\\n        parent[b]= parent[a];\\n    }\\n\\n    public LUPrefix(int n) {\\n        parent = new int[n+1];\\n        for(int i = 0;i<=n;i++) parent[i] = i;\\n    }\\n    \\n    public void upload(int video) {\\n        union(video,video-1);\\n    }\\n    \\n    public int longest() {\\n       return find(0);\\n    }\\n}\\n\\n\\n```\\n\\n# Array \\n\\n```\\n\\nclass LUPrefix {\\n   \\n    int marker [] ;\\n    int current = 0;\\n    public LUPrefix(int n) {\\n        marker = new int[n];\\n    }\\n    \\n    public void upload(int video) {\\n        marker[video-1] = 1;\\n    }\\n    \\n    public int longest() {\\n       while(current<marker.length && marker[current]==1) current++;\\n       return current;\\n    }\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass LUPrefix {\\n    int tree [] ;\\n    int update(int l , int r , int index,int value){\\n        if(l==r && l==value){\\n            tree[index] = 1;\\n            return 1;\\n        }\\n        int mid = (l+r)/2;\\n        if(r<value || value<l) return tree[index];\\n        else{\\n            int left = update(l,mid,2*index+1,value);\\n            int right = update(mid+1,r,2*index+2,value);\\n            tree[index]=left+right;\\n            return tree[index];\\n        }\\n        \\n    }\\n    \\n    \\n    int query(int l ,int r , int index , int a , int b){\\n        if(a<=l && b>=r)\\n            return tree[index];\\n        else if(b<l || a>r) return 0;\\n        else\\n        {\\n            int mid = (l+r)/2;\\n            int left = query(l,mid,2*index+1,a,b);\\n            int right = query(mid+1,r,2*index+2,a,b);\\n            return left+right;\\n        }\\n    }\\n    int n;\\n    public LUPrefix(int n) {\\n        tree = new int[4*n];\\n        this.n = n;\\n    }\\n    \\n    public void upload(int video) {\\n        update(1,n,0,video);\\n    }\\n    \\n    public int longest() {\\n        int low = 1;\\n        int high = n;\\n        int ans = 0;\\n        while(low<=high){\\n            \\n            int mid = (low + high)/2;\\n            \\n            int count = query(1,n,0,1,mid);\\n            if(count == mid){\\n                ans = mid;\\n                low = mid+1;\\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n            \\n        }\\n        return ans;\\n        \\n        \\n    }\\n}\\n\\n```\n```\\n\\nclass LUPrefix {\\n    int [] parent ;\\n\\n    int find(int a ){\\n        if(parent[a]==a) return a;\\n        return parent[a]=find(parent[a]);\\n    }\\n\\n    void union(int a , int b){\\n        parent[b]= parent[a];\\n    }\\n\\n    public LUPrefix(int n) {\\n        parent = new int[n+1];\\n        for(int i = 0;i<=n;i++) parent[i] = i;\\n    }\\n    \\n    public void upload(int video) {\\n        union(video,video-1);\\n    }\\n    \\n    public int longest() {\\n       return find(0);\\n    }\\n}\\n\\n\\n```\n```\\n\\nclass LUPrefix {\\n   \\n    int marker [] ;\\n    int current = 0;\\n    public LUPrefix(int n) {\\n        marker = new int[n];\\n    }\\n    \\n    public void upload(int video) {\\n        marker[video-1] = 1;\\n    }\\n    \\n    public int longest() {\\n       while(current<marker.length && marker[current]==1) current++;\\n       return current;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650582,
                "title": "c-sorted-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can store **unloaded** chunks, so to compupute the prefix we should find the min unloaded chunk.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use `SortedSet<int>` to store **unloaded** chunks\\n\\n# Complexity\\n- Time complexity:\\nO(N * log (N)) to initialize the instance\\nO(log(N)) to add\\nO(1) to query \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) \\n# Code\\n```\\npublic class LUPrefix {\\n    private SortedSet<int> m_Empty;\\n\\n    public LUPrefix(int n) {\\n        m_Empty = new SortedSet<int>(Enumerable.Range(1, n + 1));\\n    }\\n    \\n    public void Upload(int video) => m_Empty.Remove(video);    \\n        \\n    public int Longest() => m_Empty.Min - 1;\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.Upload(video);\\n * int param_2 = obj.Longest();\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class LUPrefix {\\n    private SortedSet<int> m_Empty;\\n\\n    public LUPrefix(int n) {\\n        m_Empty = new SortedSet<int>(Enumerable.Range(1, n + 1));\\n    }\\n    \\n    public void Upload(int video) => m_Empty.Remove(video);    \\n        \\n    public int Longest() => m_Empty.Min - 1;\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.Upload(video);\\n * int param_2 = obj.Longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649266,
                "title": "c-vector-pointer-well-commented-o-n-solution",
                "content": "**Please upvote if you like!!**\\n\\nTC: O(n)\\nSC: O(n)\\n``` \\nclass LUPrefix {\\npublic:\\n\\t// we will use a vector to keep track of the uploaded videos\\n    vector<int> v;\\n    int pointer;\\n    \\n    LUPrefix(int n) {\\n\\t\\t// initialize the vector of size (n+1) as the video indexes start from 1 to n\\n        v.resize(n+1, 0);\\n\\t\\t// pointer will keep track of the longest uploaded prefix\\n\\t\\t// eg. at first it will be at v[0] indicating that first video is not uploaded\\n        pointer = 0;\\n    }\\n    \\n    void upload(int video) {\\n\\t\\t// keep track of which video is uploaded\\n        v[video]++;\\n\\t\\t\\n\\t\\t// increment the pointer so that it points to the maximum index till which all videos are uploaded\\n        for(int x=pointer+1; x<v.size(); x++){\\n            if(v[x] != 0){\\n                pointer = x;\\n            } else if(v[x] == 0){\\n                break;\\n            }\\n        }\\n    }\\n    \\n    int longest() {\\n\\t\\t// just return the pointer\\n        return pointer;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "``` \\nclass LUPrefix {\\npublic:\\n\\t// we will use a vector to keep track of the uploaded videos\\n    vector<int> v;\\n    int pointer;\\n    \\n    LUPrefix(int n) {\\n\\t\\t// initialize the vector of size (n+1) as the video indexes start from 1 to n\\n        v.resize(n+1, 0);\\n\\t\\t// pointer will keep track of the longest uploaded prefix\\n\\t\\t// eg. at first it will be at v[0] indicating that first video is not uploaded\\n        pointer = 0;\\n    }\\n    \\n    void upload(int video) {\\n\\t\\t// keep track of which video is uploaded\\n        v[video]++;\\n\\t\\t\\n\\t\\t// increment the pointer so that it points to the maximum index till which all videos are uploaded\\n        for(int x=pointer+1; x<v.size(); x++){\\n            if(v[x] != 0){\\n                pointer = x;\\n            } else if(v[x] == 0){\\n                break;\\n            }\\n        }\\n    }\\n    \\n    int longest() {\\n\\t\\t// just return the pointer\\n        return pointer;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2649151,
                "title": "c-easy-simple-amortized-o-1-100-faster",
                "content": "```\\nclass LUPrefix {\\npublic:\\n    vector<bool>uploaded;\\n    int size;\\n    int longestPrefix;\\n    LUPrefix(int n) {\\n        size = n;\\n        uploaded.resize(size + 1, false);\\n        longestPrefix = 0;\\n    }\\n\\n    void upload(int video) {\\n        uploaded[video] = true;\\n    }\\n\\n    int longest() {\\n        while ((longestPrefix + 1 <= size) && uploaded[longestPrefix + 1]) {\\n            longestPrefix++;\\n        }\\n        return longestPrefix;\\n    }\\n};\\n```\\n**Time Complexity : O(1)**\\n**Space Complexity : O(n)**\\n\\n\\n![image](https://assets.leetcode.com/users/images/3d421ec9-fb49-4acb-a5df-5c631082e8e7_1664687215.5785422.png)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    vector<bool>uploaded;\\n    int size;\\n    int longestPrefix;\\n    LUPrefix(int n) {\\n        size = n;\\n        uploaded.resize(size + 1, false);\\n        longestPrefix = 0;\\n    }\\n\\n    void upload(int video) {\\n        uploaded[video] = true;\\n    }\\n\\n    int longest() {\\n        while ((longestPrefix + 1 <= size) && uploaded[longestPrefix + 1]) {\\n            longestPrefix++;\\n        }\\n        return longestPrefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647936,
                "title": "easy-and-optimized-python3-solution",
                "content": "class LUPrefix:\\n\\n    def __init__(self, n: int):\\n        \\n        self.v = [0]*(n+1)\\n        self.cur = 1\\n        \\n\\n    def upload(self, video: int) -> None:\\n        self.v[video] = 1\\n        if video == self.cur:\\n            self.cur+=1\\n        \\n        while self.cur<len(self.v) and self.v[self.cur]!=0:\\n            self.cur+=1\\n\\n\\n    def longest(self) -> int:\\n        return self.cur-1",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class LUPrefix:\\n\\n    def __init__(self, n: int):\\n        \\n        self.v = [0]*(n+1)\\n        self.cur = 1\\n        \\n\\n    def upload(self, video: int) -> None:\\n        self.v[video] = 1\\n        if video == self.cur:\\n            self.cur+=1\\n        \\n        while self.cur<len(self.v) and self.v[self.cur]!=0:\\n            self.cur+=1\\n\\n\\n    def longest(self) -> int:\\n        return self.cur-1",
                "codeTag": "Java"
            },
            {
                "id": 2647862,
                "title": "python-all-o-1-endpoint-algorithm-no-amortization",
                "content": "It\\'s quite straightforward to get amortized `O(logn)` with `SortedList` or amortized `O(1)` by counting up till the missing `video`. However, if you are familiar with the \"endpoint algorithm\" that keeps track of all the contiguous segments, it\\'s just as simple to get an all `O(1)` algorithm:\\n\\n1. Use `left` and `right` dictionaries to map the right endpoint to the left endpoint of the segment, and vice versa.\\n2. Given a new `video`, check if `video - 1` is in `left`. If it is, `left[video - 1]` will be the new left endpoint instead.\\n3. Likewise, if `video + 1` is in `right`, `right[video + 1]` will be the new right endpoint instead.\\n4. Finally, return `right[1]` if `1` is in `right`, else `0` for `longest()`.\\n\\n```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.left = {}\\n        self.right = {}\\n\\n    def upload(self, video: int) -> None:\\n        l = self.left.pop(video - 1, video)\\n        r = self.right.pop(video + 1, video)\\n        self.left[r] = l\\n        self.right[l] = r\\n\\n    def longest(self) -> int:\\n        return self.right.get(1, 0)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.left = {}\\n        self.right = {}\\n\\n    def upload(self, video: int) -> None:\\n        l = self.left.pop(video - 1, video)\\n        r = self.right.pop(video + 1, video)\\n        self.left[r] = l\\n        self.right[l] = r\\n\\n    def longest(self) -> int:\\n        return self.right.get(1, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647840,
                "title": "python-union-find",
                "content": "When adding an element, it becomes a member of its own set. Then if a video behind it was uploaded, go ahead and union new set with the previous one. Similarly, if there\\'s another set right after it - merge these two, too.\\n\\n```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.uploaded = [0] * (n + 1)\\n        self.n = n\\n        \\n    def upload(self, video: int) -> None:\\n        self.uploaded[video] = video\\n        if video == 1 or self.uploaded[video - 1] != 0:\\n            self.uploaded[video - 1] = video\\n        if video < self.n and self.uploaded[video + 1] != 0:\\n            self.uploaded[video] = self.uploaded[video + 1]\\n    \\n    def _find(self, i):\\n        if self.uploaded[i] == 0 or self.uploaded[i] == i:\\n            return self.uploaded[i]\\n        else:\\n            self.uploaded[i] = self._find(self.uploaded[i])\\n            return self.uploaded[i]\\n\\n    def longest(self) -> int:\\n        return self._find(0)\\n```\\t",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.uploaded = [0] * (n + 1)\\n        self.n = n\\n        \\n    def upload(self, video: int) -> None:\\n        self.uploaded[video] = video\\n        if video == 1 or self.uploaded[video - 1] != 0:\\n            self.uploaded[video - 1] = video\\n        if video < self.n and self.uploaded[video + 1] != 0:\\n            self.uploaded[video] = self.uploaded[video + 1]\\n    \\n    def _find(self, i):\\n        if self.uploaded[i] == 0 or self.uploaded[i] == i:\\n            return self.uploaded[i]\\n        else:\\n            self.uploaded[i] = self._find(self.uploaded[i])\\n            return self.uploaded[i]\\n\\n    def longest(self) -> int:\\n        return self._find(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647774,
                "title": "python-easy-solution",
                "content": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int) -> None:\\n        \\n        self.uploaded = set()\\n        self.prefix = list(range(n, -1, -1))\\n        \\n    def upload(self, video: int) -> None:\\n        \\n        self.uploaded.add(video - 1)\\n\\t\\t\\n        while self.prefix[-1] in self.uploaded:\\n            self.prefix.pop()\\n        \\n    def longest(self) -> int:\\n        \\n        return self.prefix[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int) -> None:\\n        \\n        self.uploaded = set()\\n        self.prefix = list(range(n, -1, -1))\\n        \\n    def upload(self, video: int) -> None:\\n        \\n        self.uploaded.add(video - 1)\\n\\t\\t\\n        while self.prefix[-1] in self.uploaded:\\n            self.prefix.pop()\\n        \\n    def longest(self) -> int:\\n        \\n        return self.prefix[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647712,
                "title": "java-array-solution",
                "content": "```\\nclass LUPrefix {\\n    boolean[] array;\\n    int maxSize;\\n    public LUPrefix(int n) {\\n        this.array = new boolean[n];\\n        this.maxSize = 0;\\n    }\\n    public void upload(int video) {\\n        array[video - 1] = true;\\n        int count = 0;\\n        for (int i = 0; i < array.length; i++) {\\n            if (array[i] == true) {\\n                count++;\\n            } else {\\n                maxSize = Math.max(maxSize, count);\\n                break;\\n            }\\n        }\\n        maxSize = Math.max(maxSize, count);\\n    }\\n    public int longest() {\\n        return maxSize;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass LUPrefix {\\n    boolean[] array;\\n    int maxSize;\\n    public LUPrefix(int n) {\\n        this.array = new boolean[n];\\n        this.maxSize = 0;\\n    }\\n    public void upload(int video) {\\n        array[video - 1] = true;\\n        int count = 0;\\n        for (int i = 0; i < array.length; i++) {\\n            if (array[i] == true) {\\n                count++;\\n            } else {\\n                maxSize = Math.max(maxSize, count);\\n                break;\\n            }\\n        }\\n        maxSize = Math.max(maxSize, count);\\n    }\\n    public int longest() {\\n        return maxSize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647475,
                "title": "o-nlogn-using-merging-lower-upper-bound-intervals",
                "content": "**Main Idea**:\\n+ Managing lower/upper bound intervals\\n+ Uploading method:\\n  + vmin, vmax = video, video\\n  + Find upper bound interval: video - 1 -> found: vmin = min(interval), delete lower/upper bound intervals corresponding\\n  + Find lower bound interval: video + 1 -> found: vmax = max(interval), delete lower/upper bound intervals corresponding\\n  + Updating lower/upper bound intervals\\n+ Longest method: max(upper bound(1) \\n\\n**Examples**:\\n```\\n+ Current Status:\\nlower bound intervals = {1: [1,3], 5: [5,8]}\\nupper bound intervals: {3:[1,3], 8:[5,8]}\\n\\n+ Upload(4):\\nvideo 4 -> vmin=4, vmax = 4\\n\\nvideo-1 = 3 => found upper bound 3: [1,3]\\n-> vmin = 1, upper: {8:[5,8]}, lower: {5: [5,8]}\\n\\nvideo+1 = 5 => found lower bound 5: [5,8]\\n-> vmax = 8, upper: {}, lower: {}\\n\\nUpdating: lower: {1: [1,8]}, upper: {8: [1,8]}\\n\\n+ Longest: lower[1][1] -> 8\\n```\\n\\n**Code**:\\n```python\\nclass LUPrefix:\\n    def __init__(self, n: int):\\n        self.check = [0] * (n+1)\\n        self.n = n\\n        self.hmin = {}\\n        self.hmax = {}\\n\\n    def upload(self, video: int) -> None:\\n        if video>=1 and video<=self.n and self.check[video]==0:\\n            q1 = self.hmax.get(video-1)\\n            q2 = self.hmin.get(video+1)\\n            vmin, vmax = [video, video]\\n            if q1 is not None and q2 is not None:\\n                vmin, vmax = q1[0], q2[1]\\n                del self.hmax[video-1]\\n                del self.hmin[video+1]\\n            elif q1 is not None:\\n                vmin, vmax = q1[0], video\\n                del self.hmax[q1[1]]\\n            elif q2 is not None:\\n                vmin, vmax = video, q2[1]\\n                del self.hmin[q2[0]]\\n            self.hmax[vmax] = [vmin, vmax]\\n            self.hmin[vmin] = [vmin, vmax]    \\n            self.check[video] = 1\\n            \\n        # print(q1, q2, self.check, self.hmin, self.hmax)\\n            \\n    def longest(self) -> int:\\n        if self.hmin.get(1) is None:\\n            return 0\\n        else:\\n            return self.hmin[1][1]\\n\\n\\n# Your LUPrefix object will be instantiated and called as such:\\n# obj = LUPrefix(n)\\n# obj.upload(video)\\n# param_2 = obj.longest()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n+ Current Status:\\nlower bound intervals = {1: [1,3], 5: [5,8]}\\nupper bound intervals: {3:[1,3], 8:[5,8]}\\n\\n+ Upload(4):\\nvideo 4 -> vmin=4, vmax = 4\\n\\nvideo-1 = 3 => found upper bound 3: [1,3]\\n-> vmin = 1, upper: {8:[5,8]}, lower: {5: [5,8]}\\n\\nvideo+1 = 5 => found lower bound 5: [5,8]\\n-> vmax = 8, upper: {}, lower: {}\\n\\nUpdating: lower: {1: [1,8]}, upper: {8: [1,8]}\\n\\n+ Longest: lower[1][1] -> 8\\n```\n```python\\nclass LUPrefix:\\n    def __init__(self, n: int):\\n        self.check = [0] * (n+1)\\n        self.n = n\\n        self.hmin = {}\\n        self.hmax = {}\\n\\n    def upload(self, video: int) -> None:\\n        if video>=1 and video<=self.n and self.check[video]==0:\\n            q1 = self.hmax.get(video-1)\\n            q2 = self.hmin.get(video+1)\\n            vmin, vmax = [video, video]\\n            if q1 is not None and q2 is not None:\\n                vmin, vmax = q1[0], q2[1]\\n                del self.hmax[video-1]\\n                del self.hmin[video+1]\\n            elif q1 is not None:\\n                vmin, vmax = q1[0], video\\n                del self.hmax[q1[1]]\\n            elif q2 is not None:\\n                vmin, vmax = video, q2[1]\\n                del self.hmin[q2[0]]\\n            self.hmax[vmax] = [vmin, vmax]\\n            self.hmin[vmin] = [vmin, vmax]    \\n            self.check[video] = 1\\n            \\n        # print(q1, q2, self.check, self.hmin, self.hmax)\\n            \\n    def longest(self) -> int:\\n        if self.hmin.get(1) is None:\\n            return 0\\n        else:\\n            return self.hmin[1][1]\\n\\n\\n# Your LUPrefix object will be instantiated and called as such:\\n# obj = LUPrefix(n)\\n# obj.upload(video)\\n# param_2 = obj.longest()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647448,
                "title": "simple-swift-solution",
                "content": "```\\nclass LUPrefix {\\n    var last = 0\\n    var cache = Set<Int>()\\n\\n    init(_ n: Int) {}\\n    \\n    func upload(_ video: Int) {\\n        appendIfNeeded(video)\\n    }\\n    \\n    func longest() -> Int {\\n        last\\n    }\\n    \\n    private func appendIfNeeded(_ video: Int) {\\n        if last + 1 == video {\\n            self.last = video\\n            processCacheIfNeeded()\\n        } else {\\n            cache.insert(video)\\n        }\\n    }\\n    \\n    private func processCacheIfNeeded() {\\n        guard !cache.isEmpty else { return }\\n        while cache.contains(last + 1) {\\n            last += 1\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass LUPrefix {\\n    var last = 0\\n    var cache = Set<Int>()\\n\\n    init(_ n: Int) {}\\n    \\n    func upload(_ video: Int) {\\n        appendIfNeeded(video)\\n    }\\n    \\n    func longest() -> Int {\\n        last\\n    }\\n    \\n    private func appendIfNeeded(_ video: Int) {\\n        if last + 1 == video {\\n            self.last = video\\n            processCacheIfNeeded()\\n        } else {\\n            cache.insert(video)\\n        }\\n    }\\n    \\n    private func processCacheIfNeeded() {\\n        guard !cache.isEmpty else { return }\\n        while cache.contains(last + 1) {\\n            last += 1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647388,
                "title": "two-very-efficient-solutions-python",
                "content": "**Sorted List** solution:\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass LUPrefix:\\n    def __init__(self, n: int):\\n        self.notUploaded = SortedList(i for i in range(n + 1))\\n    # Time: O(n)\\n    # Space: O(n)\\n\\n    def upload(self, video: int) -> None:\\n        self.notUploaded.remove(video - 1)\\n    # Time: O(log(n))\\n    # Space: O(1)\\n\\n    def longest(self) -> int:\\n        return self.notUploaded[0]\\n    # Time: O(1)\\n    # Space: O(1)\\n```\\n\\\\\\nAlternative solution:\\n```\\nclass LUPrefix:\\n    def __init__(self, n: int):\\n        self.ds = [False] * n\\n        self.mx = 0\\n    # Time: O(n)\\n    # Space: O(n)\\n\\n    def upload(self, video: int) -> None:\\n        self.ds[video - 1] = True\\n        while self.mx < len(self.ds) and self.ds[self.mx]:\\n            self.mx += 1\\n    # Time: O(m) where m is video\\n    # Space: O(1)\\n\\n    def longest(self) -> int:\\n        return self.mx\\n    # Time: O(1)\\n    # Space: O(1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass LUPrefix:\\n    def __init__(self, n: int):\\n        self.notUploaded = SortedList(i for i in range(n + 1))\\n    # Time: O(n)\\n    # Space: O(n)\\n\\n    def upload(self, video: int) -> None:\\n        self.notUploaded.remove(video - 1)\\n    # Time: O(log(n))\\n    # Space: O(1)\\n\\n    def longest(self) -> int:\\n        return self.notUploaded[0]\\n    # Time: O(1)\\n    # Space: O(1)\\n```\n```\\nclass LUPrefix:\\n    def __init__(self, n: int):\\n        self.ds = [False] * n\\n        self.mx = 0\\n    # Time: O(n)\\n    # Space: O(n)\\n\\n    def upload(self, video: int) -> None:\\n        self.ds[video - 1] = True\\n        while self.mx < len(self.ds) and self.ds[self.mx]:\\n            self.mx += 1\\n    # Time: O(m) where m is video\\n    # Space: O(1)\\n\\n    def longest(self) -> int:\\n        return self.mx\\n    # Time: O(1)\\n    # Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647324,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Array***\\n\\n```\\nclass LUPrefix {\\npublic:\\n    \\n    vector<int> arr;\\n    \\n    // longest will keep track of untill (longest - 1) we have got the longest uploaded prefix\\n    \\n    int longestt = 1;\\n    \\n    LUPrefix(int n) {\\n        \\n        arr.assign(n + 1, 0);\\n    }\\n    \\n    void upload(int video) {\\n        \\n        arr[video]++;\\n    }\\n    \\n    int longest() {\\n        \\n        while(longestt < arr.size())\\n        {\\n            if(arr[longestt])\\n            {\\n                longestt++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n      \\n        return longestt - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    \\n    vector<int> arr;\\n    \\n    // longest will keep track of untill (longest - 1) we have got the longest uploaded prefix\\n    \\n    int longestt = 1;\\n    \\n    LUPrefix(int n) {\\n        \\n        arr.assign(n + 1, 0);\\n    }\\n    \\n    void upload(int video) {\\n        \\n        arr[video]++;\\n    }\\n    \\n    int longest() {\\n        \\n        while(longestt < arr.size())\\n        {\\n            if(arr[longestt])\\n            {\\n                longestt++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n      \\n        return longestt - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647301,
                "title": "java-solution-small-code",
                "content": "```\\nclass LUPrefix {\\n    \\n    Set<Integer> set;\\n    int maxVideoPrefix = 0;\\n    \\n    public LUPrefix(int n) {\\n        set = new HashSet<>();\\n    }\\n    \\n    public void upload(int video) {\\n        set.add(video);\\n        while(set.contains(maxVideoPrefix+1)) {\\n            maxVideoPrefix++;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return maxVideoPrefix;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LUPrefix {\\n    \\n    Set<Integer> set;\\n    int maxVideoPrefix = 0;\\n    \\n    public LUPrefix(int n) {\\n        set = new HashSet<>();\\n    }\\n    \\n    public void upload(int video) {\\n        set.add(video);\\n        while(set.contains(maxVideoPrefix+1)) {\\n            maxVideoPrefix++;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return maxVideoPrefix;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647264,
                "title": "c-set-simple-explanation",
                "content": "**Approach:**\\n\\n* keep storing the values in the set\\n* keep track of the max_length\\n* whenever we encounter the longest() function\\n\\t* start from the last stored max value\\n\\t* now keep increasing it to the number that has not been added yet\\n* example:\\n\\t* let currently m = 3\\n\\t* set = {1,2,3,5,6,7,9}\\n\\t* because the longest has all number from 1 to i that\\'s why m is 3\\n\\t* now we add 4\\n\\t* now we got the longest() function\\n\\t\\t* so start from 3\\n\\t\\t* check if we have 4 in the set, we do have 4 so inc m\\n\\t\\t* after doing this ... we will reach at 7 the new max value\\n\\t\\t* so return 7\\n\\n**Code:**\\n\\n```\\nclass LUPrefix\\n{\\npublic:\\n    set<int> st;\\n    int m = 0; // max value so far\\n    LUPrefix(int n)\\n    {\\n    }\\n\\n    void upload(int video)\\n    {\\n        st.insert(video);\\n    }\\n\\n    int longest()\\n    {\\n        while (st.find(m + 1) != st.end())\\n            m++;\\n        return m;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass LUPrefix\\n{\\npublic:\\n    set<int> st;\\n    int m = 0; // max value so far\\n    LUPrefix(int n)\\n    {\\n    }\\n\\n    void upload(int video)\\n    {\\n        st.insert(video);\\n    }\\n\\n    int longest()\\n    {\\n        while (st.find(m + 1) != st.end())\\n            m++;\\n        return m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647042,
                "title": "python-made-easy-pointer-based-approach-explained",
                "content": "We maintain a pointer to return the longest prefix size. At start the pointer stays at 0, Since we know there cant be a 0 video, so the pointer stays at 0 until the 1st video is uploaded. As soon as the 1st video gets uploaded, we increase the pointer till the end of the array or till it finds another 0.\\n\\n**Upvote if you understood the logic :)**\\n\\n```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.arr = [0] * n\\n        self.point = 0\\n\\n    def upload(self, video: int) -> None:\\n        self.arr[video - 1] = video\\n        \\n        while self.point < len(self.arr) and self.arr[self.point] > 0:\\n            self.point += 1\\n        \\n\\n    def longest(self) -> int:\\n        return self.point\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.arr = [0] * n\\n        self.point = 0\\n\\n    def upload(self, video: int) -> None:\\n        self.arr[video - 1] = video\\n        \\n        while self.point < len(self.arr) and self.arr[self.point] > 0:\\n            self.point += 1\\n        \\n\\n    def longest(self) -> int:\\n        return self.point\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647040,
                "title": "simple-and-clean-solution-using-vector-bool",
                "content": "```\\nclass LUPrefix {\\npublic:\\n    vector<bool> v;\\n    int a=1;\\n    int b;\\n    LUPrefix(int n) {\\n        v.resize(n+1,false);\\n        b=n;\\n    }\\n    \\n    void upload(int video) {\\n        v[video]=true;\\n    }\\n    \\n    int longest() {\\n        while(a<=b)\\n        {\\n            if(v[a]==false)break;\\n            a++;\\n        }\\n        return a-1;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    vector<bool> v;\\n    int a=1;\\n    int b;\\n    LUPrefix(int n) {\\n        v.resize(n+1,false);\\n        b=n;\\n    }\\n    \\n    void upload(int video) {\\n        v[video]=true;\\n    }\\n    \\n    int longest() {\\n        while(a<=b)\\n        {\\n            if(v[a]==false)break;\\n            a++;\\n        }\\n        return a-1;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647039,
                "title": "python-solution-faster-90",
                "content": "class LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.arr = [False] * n\\n        self.minTrue = -1\\n        \\n\\n    def upload(self, video: int) -> None:\\n        video -= 1\\n        self.arr[video] = True\\n        if self.minTrue == video - 1:\\n            while video + 1 < len(self.arr) and self.arr[video + 1]:\\n                video += 1\\n            self.minTrue = video\\n            \\n        \\n    def longest(self) -> int:\\n        \\n        return self.minTrue + 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "class LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.arr = [False] * n\\n        self.minTrue = -1\\n        \\n\\n    def upload(self, video: int) -> None:\\n        video -= 1\\n        self.arr[video] = True\\n        if self.minTrue == video - 1:\\n            while video + 1 < len(self.arr) and self.arr[video + 1]:\\n                video += 1\\n            self.minTrue = video\\n            \\n        \\n    def longest(self) -> int:\\n        \\n        return self.minTrue + 1",
                "codeTag": "Java"
            },
            {
                "id": 2646968,
                "title": "c-vector-easy-short-solution",
                "content": "```\\nclass LUPrefix {\\n    vector<int> mp;\\n    int i = 1;\\n    int len;\\npublic:\\n    LUPrefix(int n) {\\n        mp.resize(n+1);\\n        len = n;\\n    }\\n    \\n    void upload(int video) {\\n        mp[video] = 1;\\n        while( i <= len && mp[i] ){\\n            i++;\\n        }\\n    }\\n    \\n    int longest() {\\n        return i-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass LUPrefix {\\n    vector<int> mp;\\n    int i = 1;\\n    int len;\\npublic:\\n    LUPrefix(int n) {\\n        mp.resize(n+1);\\n        len = n;\\n    }\\n    \\n    void upload(int video) {\\n        mp[video] = 1;\\n        while( i <= len && mp[i] ){\\n            i++;\\n        }\\n    }\\n    \\n    int longest() {\\n        return i-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646931,
                "title": "java-easy-understanding",
                "content": "Hi Family,\\n\\nI did this question using Array\\n\\n```\\nclass LUPrefix {\\n    \\n    // declare the array\\n    int ar[];\\n    int max_cnt = 1;\\n\\n    public LUPrefix(int n) {\\n        //initialize the array\\n        ar = new int[n+2];\\n    }\\n    \\n    public void upload(int video) {\\n        ar[video] = 1;\\n        // check everytime from the max index \\n        while (ar[max_cnt] == 1) {\\n            max_cnt++;\\n        }\\n    }\\n    \\n    public int longest() {\\n        \\n        return max_cnt-1;\\n    }\\n}\\n```\\n\\n**If you liked the code Please Please Please Upvote it**\\n\\n\\n**Thanks!!!**\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass LUPrefix {\\n    \\n    // declare the array\\n    int ar[];\\n    int max_cnt = 1;\\n\\n    public LUPrefix(int n) {\\n        //initialize the array\\n        ar = new int[n+2];\\n    }\\n    \\n    public void upload(int video) {\\n        ar[video] = 1;\\n        // check everytime from the max index \\n        while (ar[max_cnt] == 1) {\\n            max_cnt++;\\n        }\\n    }\\n    \\n    public int longest() {\\n        \\n        return max_cnt-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646927,
                "title": "simple-java-solution",
                "content": "```\\nclass LUPrefix {\\n    boolean[] videos;\\n    int pointer = 0;\\n    public LUPrefix(int n) {\\n        videos = new boolean[n+1];\\n    }\\n    \\n    public void upload(int video) {\\n        videos[video] = true;\\n    }\\n    \\n    public int longest() {\\n        while(pointer < videos.length-1 && videos[pointer+1]) {\\n            pointer++;\\n        }\\n        return pointer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass LUPrefix {\\n    boolean[] videos;\\n    int pointer = 0;\\n    public LUPrefix(int n) {\\n        videos = new boolean[n+1];\\n    }\\n    \\n    public void upload(int video) {\\n        videos[video] = true;\\n    }\\n    \\n    public int longest() {\\n        while(pointer < videos.length-1 && videos[pointer+1]) {\\n            pointer++;\\n        }\\n        return pointer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646913,
                "title": "python-unionfind",
                "content": "Expand size of neighbors if they are at least 1. longest() just returns the size of parent of 0.\\n\\nTime:\\n- upload: amortized O(1)\\n- longest: amortized O(1)\\n\\nSpace: O(n)\\n\\n```python\\nclass UF:\\n    def __init__(self, n):\\n        self.parents = [i for i in range(n)]\\n        self.size = [0] * n\\n        \\n    def find(self, x):\\n        px = self.parents[x]\\n        if x != px:\\n            self.parents[x] = self.find(px)\\n            \\n        return self.parents[x]\\n    \\n    def union(self, x, y):\\n        px, py = self.find(x), self.find(y)\\n        if px != py:\\n            self.parents[px] = py\\n            self.size[py] += self.size[px]\\n\\t\\t\\t\\n    def getsize(self, x):\\n        return self.size[self.find(x)]\\n\\t\\t\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.uf = UF(n)\\n        self.n = n\\n                \\n    def upload(self, video: int) -> None:\\n        i = video - 1\\n        self.uf.size[i] += 1\\n        if i > 0 and self.uf.getsize(i-1) > 0:\\n            self.uf.union(i, i-1)\\n        if i+1 < self.n and self.uf.getsize(i+1) > 0:\\n            self.uf.union(i, i+1)\\n        \\n    def longest(self) -> int:\\n        return self.uf.getsize(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```python\\nclass UF:\\n    def __init__(self, n):\\n        self.parents = [i for i in range(n)]\\n        self.size = [0] * n\\n        \\n    def find(self, x):\\n        px = self.parents[x]\\n        if x != px:\\n            self.parents[x] = self.find(px)\\n            \\n        return self.parents[x]\\n    \\n    def union(self, x, y):\\n        px, py = self.find(x), self.find(y)\\n        if px != py:\\n            self.parents[px] = py\\n            self.size[py] += self.size[px]\\n\\t\\t\\t\\n    def getsize(self, x):\\n        return self.size[self.find(x)]\\n\\t\\t\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.uf = UF(n)\\n        self.n = n\\n                \\n    def upload(self, video: int) -> None:\\n        i = video - 1\\n        self.uf.size[i] += 1\\n        if i > 0 and self.uf.getsize(i-1) > 0:\\n            self.uf.union(i, i-1)\\n        if i+1 < self.n and self.uf.getsize(i+1) > 0:\\n            self.uf.union(i, i+1)\\n        \\n    def longest(self) -> int:\\n        return self.uf.getsize(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646833,
                "title": "c-very-easy-o-n",
                "content": "\\'\\'\\'\\nThe key point here is to increase the value uploaded prefix whenever we are getting continuous number.\\n    \\n    vector<bool> v;\\n    int ans = 0;\\n    LUPrefix(int n) {\\n\\t\\n\\t\\t// defining a vector of size 1 greater n;\\n        v.resize(n + 1);\\n        for(int i = 0;i <n; i++){\\n\\t\\t\\n\\t\\t// false means the number is not uploaded\\n            v[i] = false; \\n        }\\n    }\\n    \\n    void upload(int video) {\\n\\t\\n\\t// true means the number is uploaded\\n        v[video - 1] = true;\\n\\t\\t\\n\\t// counting the number of continuous numbers from 1\\n        while(v[ans] == true){\\n            ans++;\\n        }   \\n    }\\n    \\n    int longest() {\\n        return ans;\\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "\\'\\'\\'\\nThe key point here is to increase the value uploaded prefix whenever we are getting continuous number.\\n    \\n    vector<bool> v;\\n    int ans = 0;\\n    LUPrefix(int n) {\\n\\t\\n\\t\\t// defining a vector of size 1 greater n;\\n        v.resize(n + 1);\\n        for(int i = 0;i <n; i++){\\n\\t\\t\\n\\t\\t// false means the number is not uploaded\\n            v[i] = false; \\n        }\\n    }\\n    \\n    void upload(int video) {\\n\\t\\n\\t// true means the number is uploaded\\n        v[video - 1] = true;\\n\\t\\t\\n\\t// counting the number of continuous numbers from 1\\n        while(v[ans] == true){\\n            ans++;\\n        }   \\n    }\\n    \\n    int longest() {\\n        return ans;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2646802,
                "title": "java-set-and-union-find-easy-explanation",
                "content": "#### Terminology\\nLet\\'s call a contiguous section of videos a component.\\nEx: [1,2,4,5,6,8,9]\\nComponents: [1,2], [4,5,6], [8,9]\\n\\n#### Logic:\\n* Keep a set for seen elements.\\n* Maintain a union find set with n+1 elements\\n\\t* Larger root will become the root while doing union operation. Thus, root of an element would be the largest element of that component.\\n* upload():\\n\\t* add the element to set\\n\\t* if neighbors are already uploaded, union with them as well\\n* longest():\\n\\t* return the root of 0(the largest element of the component having 0).\\n\\n```\\nclass LUPrefix {\\n    \\n    private Set<Integer> seen;\\n    private DisjointSet ds;\\n    \\n    public LUPrefix(int n) {\\n        seen = new HashSet<>();\\n        seen.add(0);\\n        \\n        ds = new DisjointSet(n+1);\\n    }\\n    \\n    public void upload(int video) {\\n        seen.add(video);\\n        \\n        if(seen.contains(video-1))\\n            ds.union(video-1, video);\\n        if(seen.contains(video+1))\\n            ds.union(video, video+1);\\n    }\\n    \\n    public int longest() {\\n        return ds.find(0);\\n    }\\n}\\n\\nclass DisjointSet {\\n    int[] root;\\n\\n    public DisjointSet(int n) {\\n        root = new int[n+1];\\n\\n        for(int i=0 ; i<n+1 ; i++) {\\n            root[i] = i;\\n        }\\n    }\\n\\n    public void union(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n\\n        if(rootX != rootY) {\\n            if(rootX > rootY)\\n                root[rootY] = rootX;\\n            else\\n                root[rootX] = rootY;\\n        }\\n    }\\n\\n    public int find(int x) {\\n        if(root[x]==x)\\n            return root[x];\\n\\n        root[x] = find(root[x]);\\n        return root[x];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Ordered Set"
                ],
                "code": "```\\nclass LUPrefix {\\n    \\n    private Set<Integer> seen;\\n    private DisjointSet ds;\\n    \\n    public LUPrefix(int n) {\\n        seen = new HashSet<>();\\n        seen.add(0);\\n        \\n        ds = new DisjointSet(n+1);\\n    }\\n    \\n    public void upload(int video) {\\n        seen.add(video);\\n        \\n        if(seen.contains(video-1))\\n            ds.union(video-1, video);\\n        if(seen.contains(video+1))\\n            ds.union(video, video+1);\\n    }\\n    \\n    public int longest() {\\n        return ds.find(0);\\n    }\\n}\\n\\nclass DisjointSet {\\n    int[] root;\\n\\n    public DisjointSet(int n) {\\n        root = new int[n+1];\\n\\n        for(int i=0 ; i<n+1 ; i++) {\\n            root[i] = i;\\n        }\\n    }\\n\\n    public void union(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n\\n        if(rootX != rootY) {\\n            if(rootX > rootY)\\n                root[rootY] = rootX;\\n            else\\n                root[rootX] = rootY;\\n        }\\n    }\\n\\n    public int find(int x) {\\n        if(root[x]==x)\\n            return root[x];\\n\\n        root[x] = find(root[x]);\\n        return root[x];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646746,
                "title": "java-priority-queue-solution",
                "content": "```\\nclass LUPrefix {\\n    \\n    PriorityQueue<Integer> pq;\\n    int previousValue;\\n\\n    public LUPrefix(int n) {\\n        pq = new PriorityQueue<>();\\n        previousValue = 0;\\n    }\\n    \\n    public void upload(int video) {\\n        pq.offer(video);\\n        \\n        while(!pq.isEmpty() && pq.peek().equals(previousValue + 1)) {\\n            pq.poll();\\n            previousValue += 1;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return previousValue;\\n    }\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n ```\\n \\n Time complexity :- 0(nlogn)",
                "solutionTags": [],
                "code": "```\\nclass LUPrefix {\\n    \\n    PriorityQueue<Integer> pq;\\n    int previousValue;\\n\\n    public LUPrefix(int n) {\\n        pq = new PriorityQueue<>();\\n        previousValue = 0;\\n    }\\n    \\n    public void upload(int video) {\\n        pq.offer(video);\\n        \\n        while(!pq.isEmpty() && pq.peek().equals(previousValue + 1)) {\\n            pq.poll();\\n            previousValue += 1;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return previousValue;\\n    }\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2646725,
                "title": "easiest-solution-ever-c",
                "content": "```\\nclass LUPrefix {\\n    vector<int> ds;\\n    int count = 1;\\n    int len;\\npublic:\\n    LUPrefix(int n) {\\n        len = n;\\n        ds = vector<int>(n+1);\\n    }\\n    \\n    void upload(int video) \\n    {\\n        if(video == count)\\n        {\\n            ds[video]++;\\n            count++;\\n            video++;\\n            while(video <= len and ds[video] != 0){count++;video++;}\\n        }\\n        else\\n        {\\n            ds[video]++;\\n            \\n        }\\n    }\\n    \\n    int longest() \\n    {\\n        if(count == 1)return 0;\\n        return count-1;\\n        \\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass LUPrefix {\\n    vector<int> ds;\\n    int count = 1;\\n    int len;\\npublic:\\n    LUPrefix(int n) {\\n        len = n;\\n        ds = vector<int>(n+1);\\n    }\\n    \\n    void upload(int video) \\n    {\\n        if(video == count)\\n        {\\n            ds[video]++;\\n            count++;\\n            video++;\\n            while(video <= len and ds[video] != 0){count++;video++;}\\n        }\\n        else\\n        {\\n            ds[video]++;\\n            \\n        }\\n    }\\n    \\n    int longest() \\n    {\\n        if(count == 1)return 0;\\n        return count-1;\\n        \\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646712,
                "title": "c-easy-similar-to-find-mes-number-in-array-problem",
                "content": "\\tclass LUPrefix {\\n\\tpublic:\\n\\t\\tset<long long> st;\\n\\t\\tunordered_map<int, int> mp;\\n\\t\\tLUPrefix(int n) \\n\\t\\t{\\n\\t\\t\\tst.insert(1);\\n\\t\\t}\\n\\n\\t\\tvoid upload(int video) \\n\\t\\t{\\n\\t\\t\\tif (!mp[video + 1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tst.insert(video + 1);\\n\\t\\t\\t}\\n\\t\\t\\tst.erase(video);\\n\\t\\t\\tmp[video]++;\\n\\t\\t}\\n\\n\\t\\tint longest() \\n\\t\\t{\\n\\t\\t\\treturn *st.begin() - 1;            \\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your LUPrefix object will be instantiated and called as such:\\n\\t * LUPrefix* obj = new LUPrefix(n);\\n\\t * obj->upload(video);\\n\\t * int param_2 = obj->longest();\\n\\t */",
                "solutionTags": [],
                "code": "\\tclass LUPrefix {\\n\\tpublic:\\n\\t\\tset<long long> st;\\n\\t\\tunordered_map<int, int> mp;\\n\\t\\tLUPrefix(int n) \\n\\t\\t{\\n\\t\\t\\tst.insert(1);\\n\\t\\t}\\n\\n\\t\\tvoid upload(int video) \\n\\t\\t{\\n\\t\\t\\tif (!mp[video + 1])\\n\\t\\t\\t{\\n\\t\\t\\t\\tst.insert(video + 1);\\n\\t\\t\\t}\\n\\t\\t\\tst.erase(video);\\n\\t\\t\\tmp[video]++;\\n\\t\\t}\\n\\n\\t\\tint longest() \\n\\t\\t{\\n\\t\\t\\treturn *st.begin() - 1;            \\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * Your LUPrefix object will be instantiated and called as such:\\n\\t * LUPrefix* obj = new LUPrefix(n);\\n\\t * obj->upload(video);\\n\\t * int param_2 = obj->longest();\\n\\t */",
                "codeTag": "Java"
            },
            {
                "id": 2646636,
                "title": "easy-solution-c",
                "content": "**solution 1:**\\n```\\nclass LUPrefix {\\npublic:\\n    int len = 1, a[100001] = {0};\\n    LUPrefix(int n) {}\\n    void upload(int video) {\\n        a[video] = 1;\\n        while(a[len])++len;\\n    }\\n    \\n    int longest() {\\n        return len-1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```\\n**solution 2:**\\n```\\nclass LUPrefix {\\npublic:\\n    set<int> s;\\n    LUPrefix(int n) {\\n        for (int i=1; i<=n+1; i++) s.insert(i);\\n    }\\n    \\n    void upload(int video) {\\n        s.erase(video);\\n    }\\n    int longest() {\\n        return *s.begin()-1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    int len = 1, a[100001] = {0};\\n    LUPrefix(int n) {}\\n    void upload(int video) {\\n        a[video] = 1;\\n        while(a[len])++len;\\n    }\\n    \\n    int longest() {\\n        return len-1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```\n```\\nclass LUPrefix {\\npublic:\\n    set<int> s;\\n    LUPrefix(int n) {\\n        for (int i=1; i<=n+1; i++) s.insert(i);\\n    }\\n    \\n    void upload(int video) {\\n        s.erase(video);\\n    }\\n    int longest() {\\n        return *s.begin()-1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646504,
                "title": "easy-java-solution",
                "content": "```\\nclass LUPrefix {\\n    boolean[] uploaded;\\n    int lPrefix = 0;\\n\\n    public LUPrefix(int n) {\\n        uploaded = new boolean[n+1];\\n    }\\n    \\n    public void upload(int video) {\\n        uploaded[video] = true;\\n        for(int i=lPrefix+1; i<uploaded.length; i++) {\\n            if(uploaded[i]) {\\n                lPrefix++;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    public int longest() {\\n        return lPrefix;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LUPrefix {\\n    boolean[] uploaded;\\n    int lPrefix = 0;\\n\\n    public LUPrefix(int n) {\\n        uploaded = new boolean[n+1];\\n    }\\n    \\n    public void upload(int video) {\\n        uploaded[video] = true;\\n        for(int i=lPrefix+1; i<uploaded.length; i++) {\\n            if(uploaded[i]) {\\n                lPrefix++;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n    \\n    public int longest() {\\n        return lPrefix;\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 2646503,
                "title": "very-very-easy-o-n",
                "content": "```\\nclass LUPrefix {\\npublic:\\n    vector<int>v;\\n    int count = 0;// will act as the index and the count of prefix\\n    LUPrefix(int n) {\\n        v.resize(n+5,0);\\n    }\\n    \\n    void upload(int video) {\\n        // Set video-1->index as 1\\n        v[video-1] = 1;\\n        // take count as the index and increment it until we get 0 on the index\\n        while(v[count]!=0)count++; \\n    }\\n    \\n    int longest() {\\n        // As we are using 0 based indexing so the where the count is zero all the prev elements are 1 \\n       return count;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    vector<int>v;\\n    int count = 0;// will act as the index and the count of prefix\\n    LUPrefix(int n) {\\n        v.resize(n+5,0);\\n    }\\n    \\n    void upload(int video) {\\n        // Set video-1->index as 1\\n        v[video-1] = 1;\\n        // take count as the index and increment it until we get 0 on the index\\n        while(v[count]!=0)count++; \\n    }\\n    \\n    int longest() {\\n        // As we are using 0 based indexing so the where the count is zero all the prev elements are 1 \\n       return count;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058218,
                "title": "easy-cpp-solution-beats-97-96-in-runtime-without-using-map-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/8c2c16c7-d36d-4c4a-bf34-5a9a8f8f5de2_1695011387.261516.png)\\n\\n# Code\\n```\\nclass LUPrefix {\\npublic:\\n    int sz;\\n    vector<bool> map;\\n    int ptr = 0;\\n    LUPrefix(int n) {\\n        sz = n;\\n        map = vector<bool>(n, false);\\n    }\\n    \\n    void upload(int video) {\\n        int i = video-1;\\n        map[i] = true;\\n        if(i == ptr){\\n            i++;\\n            ptr++;\\n            while(i < sz && map[i] != false){\\n                i++;\\n                ptr++;\\n            }\\n        }\\n    }\\n    \\n    int longest() {\\n        return ptr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    int sz;\\n    vector<bool> map;\\n    int ptr = 0;\\n    LUPrefix(int n) {\\n        sz = n;\\n        map = vector<bool>(n, false);\\n    }\\n    \\n    void upload(int video) {\\n        int i = video-1;\\n        map[i] = true;\\n        if(i == ptr){\\n            i++;\\n            ptr++;\\n            while(i < sz && map[i] != false){\\n                i++;\\n                ptr++;\\n            }\\n        }\\n    }\\n    \\n    int longest() {\\n        return ptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981618,
                "title": "c-simple-iteration-beats-94-very-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInitialise the length of longest with 0. Make a vector to store the uploaded video with 1 and not visited with 0. Once you upload a video you traverse to right of the array to find the rightmost one only if the length of longest video until now is uploaded video-1 or the uploaded video is the first video.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\niterate to find the rightmost 1 after an upload, only when the left is inculded in longest before\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass LUPrefix {\\npublic:\\n    vector<int> v;\\n    int length = 0;\\n    int size = 0;\\n    LUPrefix(int n) {\\n        v.resize(n,0);\\n        size = n;\\n    }\\n    void upload(int video) {\\n        v[video-1] = 1;\\n        if(video-1 == length || video-1==0){\\n            int i = video;\\n            while(i<size && v[i]!=0){\\n                i++;\\n            }\\n            length = i;\\n        }        \\n    }\\n    \\n    int longest() {\\n        return length;\\n        \\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    vector<int> v;\\n    int length = 0;\\n    int size = 0;\\n    LUPrefix(int n) {\\n        v.resize(n,0);\\n        size = n;\\n    }\\n    void upload(int video) {\\n        v[video-1] = 1;\\n        if(video-1 == length || video-1==0){\\n            int i = video;\\n            while(i<size && v[i]!=0){\\n                i++;\\n            }\\n            length = i;\\n        }        \\n    }\\n    \\n    int longest() {\\n        return length;\\n        \\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928463,
                "title": "easy-simple-solution-using-arrays",
                "content": "# Intuition\\nNeed to remove the recalculation every time on insertion\\n\\n# Approach\\nHence since the constraints are not big enough arrays can be used to directly access the value while storing the previous correct ans.\\n\\n# Complexity\\n- Time complexity:\\n    O(1) \\n\\n- Space complexity:\\n    O(n)\\n\\n# Code\\n```\\nclass LUPrefix {\\npublic:\\n    vector<int> v;\\n    int val=0;\\n    LUPrefix(int n) {\\n        for(int i=0;i<=n;i++)\\n            v.push_back(0);\\n    }\\n\\n    void upload(int video) {\\n        v[video]=1;\\n        if(video==1)\\n            val=1;\\n        if(!v[1])\\n            return;\\n        for(int i=val;i<v.size();i++)\\n        {\\n            if(v[i])\\n                val=i;\\n            else\\n                break;\\n        }\\n    }\\n\\n    int longest() {\\n        return val;\\n    }\\n\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    vector<int> v;\\n    int val=0;\\n    LUPrefix(int n) {\\n        for(int i=0;i<=n;i++)\\n            v.push_back(0);\\n    }\\n\\n    void upload(int video) {\\n        v[video]=1;\\n        if(video==1)\\n            val=1;\\n        if(!v[1])\\n            return;\\n        for(int i=val;i<v.size();i++)\\n        {\\n            if(v[i])\\n                val=i;\\n            else\\n                break;\\n        }\\n    }\\n\\n    int longest() {\\n        return val;\\n    }\\n\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912482,
                "title": "using-bit-very-easy-solution",
                "content": "class LUPrefix {\\n    private:\\n    unordered_map<int,int> m;\\n    int start;\\n    int BIT[100002];\\npublic:\\n    void updateTree(int idx,int val){\\n        while(idx<100002){\\n            BIT[idx]+=val;\\n            idx+=idx & (-idx);\\n        }\\n    }\\n    \\n    int getAns(int idx){\\n        int sum=0;\\n        while(idx>0){\\n            sum+=BIT[idx];\\n            idx-=idx & (-idx);\\n        }\\n        return sum;\\n    }\\n    \\n    LUPrefix(int n) {\\n        start=1;\\n        m.clear();\\n        memset(BIT,0,sizeof(BIT));\\n    }\\n    \\n    void upload(int video) {\\n        updateTree(video,1);\\n        m[video]=1;\\n    }\\n    \\n    int longest() {\\n        while(m.count(start)){\\n            start++;\\n        }\\n        int ans=getAns(start);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */****",
                "solutionTags": [
                    "Binary Indexed Tree"
                ],
                "code": "class LUPrefix {\\n    private:\\n    unordered_map<int,int> m;\\n    int start;\\n    int BIT[100002];\\npublic:\\n    void updateTree(int idx,int val){\\n        while(idx<100002){\\n            BIT[idx]+=val;\\n            idx+=idx & (-idx);\\n        }\\n    }\\n    \\n    int getAns(int idx){\\n        int sum=0;\\n        while(idx>0){\\n            sum+=BIT[idx];\\n            idx-=idx & (-idx);\\n        }\\n        return sum;\\n    }\\n    \\n    LUPrefix(int n) {\\n        start=1;\\n        m.clear();\\n        memset(BIT,0,sizeof(BIT));\\n    }\\n    \\n    void upload(int video) {\\n        updateTree(video,1);\\n        m[video]=1;\\n    }\\n    \\n    int longest() {\\n        while(m.count(start)){\\n            start++;\\n        }\\n        int ans=getAns(start);\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */****",
                "codeTag": "Java"
            },
            {
                "id": 3898366,
                "title": "modified-dsu-o-1-time-complexity",
                "content": "\\n# Approach\\n`next` points to next uploaded video, initially to itself\\n\\n# Complexity\\n- Time complexity:\\n    - upload -> O(1\\n    - longest -> average O(1) (to be precise O(height of tree)), but we prune tree as we do in DSU \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LUPrefix {\\npublic:\\n    vector<int> next;\\n    int find_next(int in)\\n    {\\n        if(in == next[in])\\n            return in;\\n        return next[in] = find_next(next[in]);\\n    }\\n    LUPrefix(int n) {\\n        next = vector<int>(n+2);\\n        next[0] = 1;\\n        for(int i=1;i<=n+1;i++)\\n            next[i] = i;\\n    }\\n    \\n    void upload(int video) {\\n        next[video] = next[video+1];\\n    }\\n    \\n    int longest() {\\n        int cur = find_next(0);\\n        return cur-1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    vector<int> next;\\n    int find_next(int in)\\n    {\\n        if(in == next[in])\\n            return in;\\n        return next[in] = find_next(next[in]);\\n    }\\n    LUPrefix(int n) {\\n        next = vector<int>(n+2);\\n        next[0] = 1;\\n        for(int i=1;i<=n+1;i++)\\n            next[i] = i;\\n    }\\n    \\n    void upload(int video) {\\n        next[video] = next[video+1];\\n    }\\n    \\n    int longest() {\\n        int cur = find_next(0);\\n        return cur-1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898365,
                "title": "modified-dsu-o-1-time-complexity",
                "content": "\\n# Approach\\n`next` points to next uploaded video, initially to itself\\n\\n# Complexity\\n- Time complexity:\\n    - upload -> O(1\\n    - longest -> average O(1) (to be precise O(height of tree)), but we prune tree as we do in DSU \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LUPrefix {\\npublic:\\n    vector<int> next;\\n    int find_next(int in)\\n    {\\n        if(in == next[in])\\n            return in;\\n        return next[in] = find_next(next[in]);\\n    }\\n    LUPrefix(int n) {\\n        next = vector<int>(n+2);\\n        next[0] = 1;\\n        for(int i=1;i<=n+1;i++)\\n            next[i] = i;\\n    }\\n    \\n    void upload(int video) {\\n        next[video] = next[video+1];\\n    }\\n    \\n    int longest() {\\n        int cur = find_next(0);\\n        return cur-1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    vector<int> next;\\n    int find_next(int in)\\n    {\\n        if(in == next[in])\\n            return in;\\n        return next[in] = find_next(next[in]);\\n    }\\n    LUPrefix(int n) {\\n        next = vector<int>(n+2);\\n        next[0] = 1;\\n        for(int i=1;i<=n+1;i++)\\n            next[i] = i;\\n    }\\n    \\n    void upload(int video) {\\n        next[video] = next[video+1];\\n    }\\n    \\n    int longest() {\\n        int cur = find_next(0);\\n        return cur-1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856201,
                "title": "longest-uploaded-prefix-easy-solution-ordered-set",
                "content": "\\n\\n# Code\\n```\\nclass LUPrefix {\\npublic:\\n   set<int>s;\\n    int x = 0;\\n    LUPrefix(int n) \\n    {\\n        \\n    }\\n    \\n    void upload(int video) \\n    {\\n        s.insert(video);\\n    }\\n    \\n    int longest() \\n    {\\n        while(s.find(x+1) != s.end())\\n        {\\n            x++;\\n        }\\n        return x;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "Design",
                    "Ordered Set"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n   set<int>s;\\n    int x = 0;\\n    LUPrefix(int n) \\n    {\\n        \\n    }\\n    \\n    void upload(int video) \\n    {\\n        s.insert(video);\\n    }\\n    \\n    int longest() \\n    {\\n        while(s.find(x+1) != s.end())\\n        {\\n            x++;\\n        }\\n        return x;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852360,
                "title": "c-python-binary-indexed-tree-union-find-solution-with-explanation",
                "content": "### binary indexed tree\\nwe can use binary indexed tree as frequency array to record which videos have been uploaded,\\nand calculate prefix sum to check longest uploaded prefix if prefix sum(i) == i using binary search.\\ntc of using binary indexed tree to calculate prefix sum is O(logn)\\n\\ntc of upload is O(logn).\\ntc of longest is O((logn)^2).\\nsc is O(n).\\n### python\\n```\\nclass LUPrefix:\\n    def __init__(self, n: int):\\n        self.bit = [0] * (n+1)\\n        \\n    def upload(self, video: int) -> None:\\n        while video < len(self.bit):\\n            self.bit[video] += 1\\n            video += video & -video\\n    \\n    def query(self, idx):\\n        s = 0\\n        while idx > 0:\\n            s += self.bit[idx]\\n            idx -= idx & -idx\\n        return s\\n            \\n    def longest(self) -> int:\\n        left = 1\\n        right = len(self.bit) - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if self.query(mid) == mid: left = mid + 1\\n            else: right = mid - 1\\n        return right\\n```\\n\\n### c++\\n```cpp\\nclass LUPrefix {\\npublic:\\n    vector<int> bit;\\n    LUPrefix(int n): bit(n+1) {}\\n    \\n    void upload(int video) {\\n        while (video < this -> bit.size()) {\\n            this -> bit[video] += 1;\\n            video += video & -video;\\n        }\\n    }\\n    int query(int idx) {\\n        int s = 0;\\n        while (idx > 0) {\\n            s += this -> bit[idx];\\n            idx -= idx &-idx;\\n        }\\n        return s;\\n    }\\n    \\n    int longest() {\\n        int left = 1, right = this ->bit.size() - 1, mid;\\n        while (left <= right) {\\n            mid = left + (right - left) / 2;\\n            if (this -> query(mid) == mid) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return right;\\n    }\\n};\\n```\\n\\n\\n### union-find\\nif consecutive numbers have been uploaded, they can join together using union-find.\\nAnd find largest number in the group where 1 is.\\n\\ntc of upload is O(1) amortized.\\ntc of longest is O(1) amortized.\\nsc is O(n).\\n\\n### python\\n```python\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.parent = [i for i in range(n+1)]\\n        self.exist = [False] * (n+2)\\n        \\n    def find(self, p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, p, q):\\n        pp, pq = self.find(p), self.find(q)\\n        if pp == pq: return\\n        elif pq > pp:\\n            self.parent[pp] = pq\\n        else:\\n            self.parent[pq] = pp\\n        \\n    def upload(self, video: int) -> None:\\n        self.exist[video] = True\\n        if self.exist[video + 1]:\\n            self.union(video, video+1)\\n        if self.exist[video - 1]:\\n            self.union(video, video-1)\\n\\n    def longest(self) -> int:\\n        return self.find(1) if self.exist[1] else 0\\n```\\n\\n### c++\\n```cpp\\nclass LUPrefix {\\npublic:\\n    vector<int> parent;\\n    vector<bool> exist;\\n    LUPrefix(int n): parent(n+1), exist(n+2) {\\n        for (int i = 1; i <= n; i+=1) parent[i] = i;\\n    }\\n    \\n    int find(int p) {\\n        if (this -> parent[p] != p)\\n            this -> parent[p] = this -> find(this -> parent[p]);\\n        return this -> parent[p];\\n    }\\n    \\n    void join(int p, int q) {\\n        int pp = this -> find(p), pq = this -> find(q);\\n        if (pp == pq) return;\\n        else if (pq < pp) this -> parent[pq] = pp;\\n        else this -> parent[pp] = pq;\\n    }\\n    \\n    void upload(int video) {\\n        this -> exist[video] = true;\\n        if (this -> exist[video-1]) this -> join(video, video-1);\\n        if (this -> exist[video+1]) this -> join(video, video+1);\\n    }\\n    \\n    int longest() {\\n        return this -> exist[1]? this -> find(1): 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Union Find",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass LUPrefix:\\n    def __init__(self, n: int):\\n        self.bit = [0] * (n+1)\\n        \\n    def upload(self, video: int) -> None:\\n        while video < len(self.bit):\\n            self.bit[video] += 1\\n            video += video & -video\\n    \\n    def query(self, idx):\\n        s = 0\\n        while idx > 0:\\n            s += self.bit[idx]\\n            idx -= idx & -idx\\n        return s\\n            \\n    def longest(self) -> int:\\n        left = 1\\n        right = len(self.bit) - 1\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if self.query(mid) == mid: left = mid + 1\\n            else: right = mid - 1\\n        return right\\n```\n```cpp\\nclass LUPrefix {\\npublic:\\n    vector<int> bit;\\n    LUPrefix(int n): bit(n+1) {}\\n    \\n    void upload(int video) {\\n        while (video < this -> bit.size()) {\\n            this -> bit[video] += 1;\\n            video += video & -video;\\n        }\\n    }\\n    int query(int idx) {\\n        int s = 0;\\n        while (idx > 0) {\\n            s += this -> bit[idx];\\n            idx -= idx &-idx;\\n        }\\n        return s;\\n    }\\n    \\n    int longest() {\\n        int left = 1, right = this ->bit.size() - 1, mid;\\n        while (left <= right) {\\n            mid = left + (right - left) / 2;\\n            if (this -> query(mid) == mid) left = mid + 1;\\n            else right = mid - 1;\\n        }\\n        return right;\\n    }\\n};\\n```\n```python\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.parent = [i for i in range(n+1)]\\n        self.exist = [False] * (n+2)\\n        \\n    def find(self, p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, p, q):\\n        pp, pq = self.find(p), self.find(q)\\n        if pp == pq: return\\n        elif pq > pp:\\n            self.parent[pp] = pq\\n        else:\\n            self.parent[pq] = pp\\n        \\n    def upload(self, video: int) -> None:\\n        self.exist[video] = True\\n        if self.exist[video + 1]:\\n            self.union(video, video+1)\\n        if self.exist[video - 1]:\\n            self.union(video, video-1)\\n\\n    def longest(self) -> int:\\n        return self.find(1) if self.exist[1] else 0\\n```\n```cpp\\nclass LUPrefix {\\npublic:\\n    vector<int> parent;\\n    vector<bool> exist;\\n    LUPrefix(int n): parent(n+1), exist(n+2) {\\n        for (int i = 1; i <= n; i+=1) parent[i] = i;\\n    }\\n    \\n    int find(int p) {\\n        if (this -> parent[p] != p)\\n            this -> parent[p] = this -> find(this -> parent[p]);\\n        return this -> parent[p];\\n    }\\n    \\n    void join(int p, int q) {\\n        int pp = this -> find(p), pq = this -> find(q);\\n        if (pp == pq) return;\\n        else if (pq < pp) this -> parent[pq] = pp;\\n        else this -> parent[pp] = pq;\\n    }\\n    \\n    void upload(int video) {\\n        this -> exist[video] = true;\\n        if (this -> exist[video-1]) this -> join(video, video-1);\\n        if (this -> exist[video+1]) this -> join(video, video+1);\\n    }\\n    \\n    int longest() {\\n        return this -> exist[1]? this -> find(1): 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851176,
                "title": "java-java-faster-solution-faster-than-99-easy-to-understand-with-explaination",
                "content": "class LUPrefix {\\n    int[] nums ;\\n    int count = 0;\\n    public LUPrefix(int n) {\\n        nums = new int[n+1];\\n    }\\n    \\n    public void upload(int video) {\\n        nums[video]++ ;\\n        if(count+1 == video)count++ ;\\n        while(count+1 < nums.length && nums[count+1] != 0){\\n            count++ ;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return count ;\\n    }\\n} /*\\n--> Maintain a count variable that will count the maximum length from 1 to the last uploaded  video .\\n--> If the first video is not uploaded then length is zero that is understandable \\n--> If video comes to upload and is next video after count then ~INCREASE COUNT~ \\nand check using while loop that  how many videos have been already uploaded using freArr( i.e. nums).\\n*/\\n~PLEASE UPVOTE~",
                "solutionTags": [],
                "code": "class LUPrefix {\\n    int[] nums ;\\n    int count = 0;\\n    public LUPrefix(int n) {\\n        nums = new int[n+1];\\n    }\\n    \\n    public void upload(int video) {\\n        nums[video]++ ;\\n        if(count+1 == video)count++ ;\\n        while(count+1 < nums.length && nums[count+1] != 0){\\n            count++ ;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return count ;\\n    }\\n} /*\\n--> Maintain a count variable that will count the maximum length from 1 to the last uploaded  video .\\n--> If the first video is not uploaded then length is zero that is understandable \\n--> If video comes to upload and is next video after count then ~INCREASE COUNT~ \\nand check using while loop that  how many videos have been already uploaded using freArr( i.e. nums).\\n*/\\n~PLEASE UPVOTE~",
                "codeTag": "Java"
            },
            {
                "id": 3830552,
                "title": "unionfind-beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass UnionFind {\\n    vector<int> parent;\\n\\n    public:\\n     UnionFind(int n) {\\n         parent.resize(n+1);\\n         for(int i=0; i<=n; i++){\\n             parent[i] = i;\\n         }\\n     }\\n\\n     int find(int x){\\n         int root = x;\\n         while(root != parent[root])\\n          root = parent[root];\\n\\n          while(x != root){\\n              int t = parent[x];\\n              parent[x] = root;\\n              x = t;\\n          }\\n          return root;\\n     }\\n\\n     void union_(int x, int y){\\n         int xSet = find(x);\\n         int ySet = find(y);\\n\\n         if(xSet == ySet) return;\\n\\n         if(xSet < ySet) parent[xSet] = ySet;\\n         else parent[ySet] = xSet;\\n     }\\n};\\nclass LUPrefix {\\n    UnionFind obj;\\n    vector<bool> isPresent;\\n    int N;\\npublic:\\n    \\n    LUPrefix(int n): obj(n), N(n) {\\n        isPresent.resize(n+1, false);\\n    }\\n    \\n    void upload(int video) {\\n        if(video == 1){\\n            if((video + 1 <= N) && isPresent[video + 1])obj.union_(1, 2);\\n            obj.union_(0,1);\\n            isPresent[1] = true;\\n        }\\n        else if(video == N){\\n            if(N-1 >=0 && isPresent[N-1]) obj.union_(N-1, N);\\n\\n            isPresent[N] = true;\\n        }\\n        else{\\n            if(isPresent[video-1]){\\n                obj.union_(video-1, video);\\n            }\\n            if(isPresent[video+1]){\\n                obj.union_(video, video+1);\\n            }\\n\\n            isPresent[video] = true;\\n        }\\n    }\\n    \\n    int longest() {\\n        return obj.find(0);\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UnionFind {\\n    vector<int> parent;\\n\\n    public:\\n     UnionFind(int n) {\\n         parent.resize(n+1);\\n         for(int i=0; i<=n; i++){\\n             parent[i] = i;\\n         }\\n     }\\n\\n     int find(int x){\\n         int root = x;\\n         while(root != parent[root])\\n          root = parent[root];\\n\\n          while(x != root){\\n              int t = parent[x];\\n              parent[x] = root;\\n              x = t;\\n          }\\n          return root;\\n     }\\n\\n     void union_(int x, int y){\\n         int xSet = find(x);\\n         int ySet = find(y);\\n\\n         if(xSet == ySet) return;\\n\\n         if(xSet < ySet) parent[xSet] = ySet;\\n         else parent[ySet] = xSet;\\n     }\\n};\\nclass LUPrefix {\\n    UnionFind obj;\\n    vector<bool> isPresent;\\n    int N;\\npublic:\\n    \\n    LUPrefix(int n): obj(n), N(n) {\\n        isPresent.resize(n+1, false);\\n    }\\n    \\n    void upload(int video) {\\n        if(video == 1){\\n            if((video + 1 <= N) && isPresent[video + 1])obj.union_(1, 2);\\n            obj.union_(0,1);\\n            isPresent[1] = true;\\n        }\\n        else if(video == N){\\n            if(N-1 >=0 && isPresent[N-1]) obj.union_(N-1, N);\\n\\n            isPresent[N] = true;\\n        }\\n        else{\\n            if(isPresent[video-1]){\\n                obj.union_(video-1, video);\\n            }\\n            if(isPresent[video+1]){\\n                obj.union_(video, video+1);\\n            }\\n\\n            isPresent[video] = true;\\n        }\\n    }\\n    \\n    int longest() {\\n        return obj.find(0);\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3817602,
                "title": "c-array-easy",
                "content": "We can keep a pointer before which our videos array is completely filled. \\nWhen we get upload call, we update the array and also update the position of pointer.\\n```\\nclass LUPrefix {\\npublic:\\n    vector<bool>arr;\\n    int cur;\\n\\n    LUPrefix(int n) {\\n        arr = vector<bool>(n+2,false);\\n        arr[0] = true;\\n        cur = 0;\\n    }\\n    \\n    void upload(int video) {\\n        arr[video] = true;\\n        while(arr[cur])\\n            cur++;\\n    }\\n    \\n    int longest() {\\n        return max(0,cur-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    vector<bool>arr;\\n    int cur;\\n\\n    LUPrefix(int n) {\\n        arr = vector<bool>(n+2,false);\\n        arr[0] = true;\\n        cur = 0;\\n    }\\n    \\n    void upload(int video) {\\n        arr[video] = true;\\n        while(arr[cur])\\n            cur++;\\n    }\\n    \\n    int longest() {\\n        return max(0,cur-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813422,
                "title": "c-o-n-time-o-n-space-easiest-solution",
                "content": "# Intuition\\nObservation. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\nKeep a map to keep trace of the uploaded videos and keep a variable prefix to keep track of the longest uploaded prefix.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N). \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LUPrefix {\\npublic:\\n    int prefix=1;\\n    unordered_map<int,int> mp;\\n    LUPrefix(int n) {}\\n    \\n    void upload(int video) {\\n        if(video==prefix) prefix++;\\n        else mp[video]=1;\\n\\n        while(mp[prefix]==1) prefix++;\\n    }\\n    \\n    int longest() {\\n        return prefix-1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    int prefix=1;\\n    unordered_map<int,int> mp;\\n    LUPrefix(int n) {}\\n    \\n    void upload(int video) {\\n        if(video==prefix) prefix++;\\n        else mp[video]=1;\\n\\n        while(mp[prefix]==1) prefix++;\\n    }\\n    \\n    int longest() {\\n        return prefix-1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769452,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass LUPrefix {\\n\\n    int longest , n, parent[];\\n    public LUPrefix(int n) {\\n        parent = new int [n+1];\\n        longest = 0;\\n        this.n = n;\\n    }\\n    \\n    public void upload(int video) {\\n        parent[video] = parent[video - 1] != 0 ? find(parent[video-1]) : video ;\\n        if (video < n && parent[video + 1] != 0) parent[video + 1] = parent[video];\\n        if (parent[video] == 1){\\n            while (video <= n && parent[video] > 0) parent[video++] = 1;\\n            longest = video - 1;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return longest;\\n    }\\n\\n    private int find(int vid){\\n        if (parent[vid] == vid) return vid;\\n        return find(parent[vid]);\\n    }\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LUPrefix {\\n\\n    int longest , n, parent[];\\n    public LUPrefix(int n) {\\n        parent = new int [n+1];\\n        longest = 0;\\n        this.n = n;\\n    }\\n    \\n    public void upload(int video) {\\n        parent[video] = parent[video - 1] != 0 ? find(parent[video-1]) : video ;\\n        if (video < n && parent[video + 1] != 0) parent[video + 1] = parent[video];\\n        if (parent[video] == 1){\\n            while (video <= n && parent[video] > 0) parent[video++] = 1;\\n            longest = video - 1;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return longest;\\n    }\\n\\n    private int find(int vid){\\n        if (parent[vid] == vid) return vid;\\n        return find(parent[vid]);\\n    }\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748837,
                "title": "longest-uploaded-prefix-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass LUPrefix {\\npublic:\\n    priority_queue<int, vector<int>, greater<int>> pq;\\n    int i=1;\\n    LUPrefix(int n) {\\n    \\n    }\\n    \\n    void upload(int video) {\\n        pq.push(video);\\n    }\\n    \\n    int longest() {\\n        while(!pq.empty())\\n        {\\n            if(pq.top()!=i)\\n            {\\n                return i-1;\\n            }\\n            pq.pop();\\n            i++;\\n        }\\n        return i-1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/10f79229-db3e-4ca2-9ace-5da584e34e4a_1689059229.7053342.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    priority_queue<int, vector<int>, greater<int>> pq;\\n    int i=1;\\n    LUPrefix(int n) {\\n    \\n    }\\n    \\n    void upload(int video) {\\n        pq.push(video);\\n    }\\n    \\n    int longest() {\\n        while(!pq.empty())\\n        {\\n            if(pq.top()!=i)\\n            {\\n                return i-1;\\n            }\\n            pq.pop();\\n            i++;\\n        }\\n        return i-1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713459,
                "title": "longest-uploaded-prefix-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Code\\n```\\nclass LUPrefix {\\npublic:\\n    int N;\\n    int l=0;\\n    vector<int> v;\\n\\n\\n    LUPrefix(int n) {\\n        \\n       N=n;\\n        for(int i=0;i<N+1;i++)\\n        {\\n            v.push_back(0);\\n        }\\n    }\\n    \\n    void upload(int video) {\\n       v[video]=1;\\n        if(video==1&&l!=0)\\n        {\\n            l=1;\\n        }\\n        else\\n        {\\n            if(l+1==video)\\n            {\\n                l=video;\\n            }\\n            for(int i=l;i<=N;i++)\\n            {\\n                if(v[i]==0)\\n                {\\n                    break;\\n                }\\n               else if(v[i]!=0)\\n                {\\n                    l=i;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int longest() {\\n       if(l==0)\\n       {\\n           return 0;\\n       }\\n        return l;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Union Find",
                    "Design",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    int N;\\n    int l=0;\\n    vector<int> v;\\n\\n\\n    LUPrefix(int n) {\\n        \\n       N=n;\\n        for(int i=0;i<N+1;i++)\\n        {\\n            v.push_back(0);\\n        }\\n    }\\n    \\n    void upload(int video) {\\n       v[video]=1;\\n        if(video==1&&l!=0)\\n        {\\n            l=1;\\n        }\\n        else\\n        {\\n            if(l+1==video)\\n            {\\n                l=video;\\n            }\\n            for(int i=l;i<=N;i++)\\n            {\\n                if(v[i]==0)\\n                {\\n                    break;\\n                }\\n               else if(v[i]!=0)\\n                {\\n                    l=i;\\n                }\\n            }\\n        }\\n    }\\n    \\n    int longest() {\\n       if(l==0)\\n       {\\n           return 0;\\n       }\\n        return l;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701280,
                "title": "observation-based-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass LUPrefix {\\npublic:\\n    unordered_map<int,set<int>> mp;\\n    int p = 0;\\n    LUPrefix(int n) {\\n        for(int i = 1; i<=n; i++)\\n        {\\n            mp[0].insert(i);\\n        }\\n        p = n;\\n    }\\n    \\n    void upload(int video) {\\n        mp[0].erase(video);\\n    }\\n    \\n    int longest() {\\n        if(mp[0].size() == 0) return p;\\n        return *mp[0].begin()-1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    unordered_map<int,set<int>> mp;\\n    int p = 0;\\n    LUPrefix(int n) {\\n        for(int i = 1; i<=n; i++)\\n        {\\n            mp[0].insert(i);\\n        }\\n        p = n;\\n    }\\n    \\n    void upload(int video) {\\n        mp[0].erase(video);\\n    }\\n    \\n    int longest() {\\n        if(mp[0].size() == 0) return p;\\n        return *mp[0].begin()-1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688098,
                "title": "c-4-lines-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <string>\\n\\nusing namespace std;\\n\\nclass LUPrefix \\n{\\npublic:\\n    LUPrefix(int n) \\n    {\\n        prefix = string(n, \\'0\\');\\n    }\\n    \\n    void upload(int video) \\n    {\\n        prefix[video - 1] = \\'1\\';\\n    }\\n    \\n    int longest() \\n    {\\n        int pos = prefix.find_first_of(\\'0\\');\\n        return pos == string::npos ? prefix.length() : pos;\\n    }\\n\\nprivate:\\n    string prefix;\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n#include <string>\\n\\nusing namespace std;\\n\\nclass LUPrefix \\n{\\npublic:\\n    LUPrefix(int n) \\n    {\\n        prefix = string(n, \\'0\\');\\n    }\\n    \\n    void upload(int video) \\n    {\\n        prefix[video - 1] = \\'1\\';\\n    }\\n    \\n    int longest() \\n    {\\n        int pos = prefix.find_first_of(\\'0\\');\\n        return pos == string::npos ? prefix.length() : pos;\\n    }\\n\\nprivate:\\n    string prefix;\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3684503,
                "title": "use-prefix-array-simple-approach-c",
                "content": "```\\nclass LUPrefix {\\n    vector<int> prefix;\\n    int currLongPrefix = 0;\\n    int size;\\npublic:\\n    LUPrefix(int n) {\\n        prefix.resize(n + 1, 0);\\n        size = n;\\n    }\\n    \\n    void upload(int video) {\\n        prefix[video] = 1;\\n    }\\n    \\n    int longest() {\\n        int i = currLongPrefix + 1;\\n        while(i <= size && prefix[i]) {\\n            currLongPrefix = i;\\n            i++;\\n        }\\n        return currLongPrefix;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass LUPrefix {\\n    vector<int> prefix;\\n    int currLongPrefix = 0;\\n    int size;\\npublic:\\n    LUPrefix(int n) {\\n        prefix.resize(n + 1, 0);\\n        size = n;\\n    }\\n    \\n    void upload(int video) {\\n        prefix[video] = 1;\\n    }\\n    \\n    int longest() {\\n        int i = currLongPrefix + 1;\\n        while(i <= size && prefix[i]) {\\n            currLongPrefix = i;\\n            i++;\\n        }\\n        return currLongPrefix;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645022,
                "title": "segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# https://leetcode.com/problems/longest-uploaded-prefix/description/\\n# Port from\\n# https://leetcode.com/problems/longest-uploaded-prefix/solutions/2646593/segment-tree-binary-search/\\n\\nclass SegTree\\n  def initialize\\n    @t = Array.new(4 * 400_001, 0)\\n  end\\n\\n  def update(v, tl, tr, pos, new_val)\\n    return unless tl <= pos && pos <= tr\\n\\n    if tl == tr && tl == pos\\n      @t[v] = new_val\\n    else\\n      tm = (tl + tr) / 2\\n      update(v * 2, tl, tm, pos, new_val)\\n      update(v * 2 + 1, tm + 1, tr, pos, new_val)\\n      @t[v] = @t[v * 2] + @t[v * 2 + 1]\\n    end\\n  end\\n\\n  def sum(v, tl, tr, l, r)\\n    return 0 if tl > r || tr < l\\n    return @t[v] if tl >= l && tr <= r\\n\\n    tm = (tl + tr) / 2\\n    sum(v * 2, tl, tm, l, r) + sum(v * 2 + 1, tm + 1, tr, l, r)\\n  end\\nend\\n\\nclass LUPrefix\\n  def initialize(n)\\n    @t = SegTree.new\\n    @n = n\\n    @LUP = 0\\n    @recompute = false\\n  end\\n\\n  def upload(video)\\n    @t.update(1, 1, @n, video, 1)\\n    @recompute = true if video - 1 == @LUP\\n  end\\n\\n  def longest\\n    bsearch if @recompute\\n    @recompute = false\\n    @LUP\\n  end\\n\\n  def bsearch\\n    l = 1\\n    r = @n\\n\\n    while l < r\\n      m = r - (r - l) / 2\\n      t = @t.sum(1, 1, @n, 1, m)\\n\\n      if t < m\\n        r = m - 1\\n      else\\n        l = m\\n      end\\n    end\\n\\n    @LUP = @t.sum(1, 1, @n, 1, l) != l ? 0 : l\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# https://leetcode.com/problems/longest-uploaded-prefix/description/\\n# Port from\\n# https://leetcode.com/problems/longest-uploaded-prefix/solutions/2646593/segment-tree-binary-search/\\n\\nclass SegTree\\n  def initialize\\n    @t = Array.new(4 * 400_001, 0)\\n  end\\n\\n  def update(v, tl, tr, pos, new_val)\\n    return unless tl <= pos && pos <= tr\\n\\n    if tl == tr && tl == pos\\n      @t[v] = new_val\\n    else\\n      tm = (tl + tr) / 2\\n      update(v * 2, tl, tm, pos, new_val)\\n      update(v * 2 + 1, tm + 1, tr, pos, new_val)\\n      @t[v] = @t[v * 2] + @t[v * 2 + 1]\\n    end\\n  end\\n\\n  def sum(v, tl, tr, l, r)\\n    return 0 if tl > r || tr < l\\n    return @t[v] if tl >= l && tr <= r\\n\\n    tm = (tl + tr) / 2\\n    sum(v * 2, tl, tm, l, r) + sum(v * 2 + 1, tm + 1, tr, l, r)\\n  end\\nend\\n\\nclass LUPrefix\\n  def initialize(n)\\n    @t = SegTree.new\\n    @n = n\\n    @LUP = 0\\n    @recompute = false\\n  end\\n\\n  def upload(video)\\n    @t.update(1, 1, @n, video, 1)\\n    @recompute = true if video - 1 == @LUP\\n  end\\n\\n  def longest\\n    bsearch if @recompute\\n    @recompute = false\\n    @LUP\\n  end\\n\\n  def bsearch\\n    l = 1\\n    r = @n\\n\\n    while l < r\\n      m = r - (r - l) / 2\\n      t = @t.sum(1, 1, @n, 1, m)\\n\\n      if t < m\\n        r = m - 1\\n      else\\n        l = m\\n      end\\n    end\\n\\n    @LUP = @t.sum(1, 1, @n, 1, l) != l ? 0 : l\\n  end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644729,
                "title": "ruby-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LUPrefix\\n  def initialize(n)\\n    @n = n\\n    @rec = Array.new(n, 0)\\n    @LUP = 0\\n    @recompute = false\\n  end\\n\\n  def upload(video)\\n    video -= 1\\n    @rec[video] = 1\\n    @recompute = true if video == @LUP\\n  end\\n\\n  def longest\\n    compute if @recompute\\n    @recompute = false\\n    @LUP\\n  end\\n\\n  def compute\\n    @LUP += 1 while @LUP < @n && @rec[@LUP] > 0\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nclass LUPrefix\\n  def initialize(n)\\n    @n = n\\n    @rec = Array.new(n, 0)\\n    @LUP = 0\\n    @recompute = false\\n  end\\n\\n  def upload(video)\\n    video -= 1\\n    @rec[video] = 1\\n    @recompute = true if video == @LUP\\n  end\\n\\n  def longest\\n    compute if @recompute\\n    @recompute = false\\n    @LUP\\n  end\\n\\n  def compute\\n    @LUP += 1 while @LUP < @n && @rec[@LUP] > 0\\n  end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642065,
                "title": "c-easy-recursion-array-short-fast",
                "content": "```\\nclass LUPrefix {\\npublic:\\n    \\n    int Max =-1;\\n    vector<int>Temp = vector<int>(100001,0);\\n    \\n    LUPrefix(int n) {}        \\n    \\n    void upload(int video) {\\n      Temp[video-1]++;  \\n    }\\n    \\n    int longest() {\\n        return ((Max==-1||Temp[Max]) && Temp[++Max])?longest():Max;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    \\n    int Max =-1;\\n    vector<int>Temp = vector<int>(100001,0);\\n    \\n    LUPrefix(int n) {}        \\n    \\n    void upload(int video) {\\n      Temp[video-1]++;  \\n    }\\n    \\n    int longest() {\\n        return ((Max==-1||Temp[Max]) && Temp[++Max])?longest():Max;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606843,
                "title": "ruby-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LUPrefix\\n\\n=begin\\n    :type n: Integer\\n=end\\n    def initialize(n)\\n        @n = Array.new(n)\\n        @longest_prefix = []\\n    end\\n\\n\\n=begin\\n    :type video: Integer\\n    :rtype: Void\\n=end\\n    def upload(video)\\n        @n[video - 1] = video\\n    end\\n\\n\\n=begin\\n    :rtype: Integer\\n=end\\n    def longest()\\n        return 0 unless @n[0]\\n\\n        @longest_prefix.size.upto(@n.size - 1) do |idx|\\n            return @longest_prefix.size unless @n[idx]\\n            @longest_prefix << @n[idx]\\n        end\\n\\n        @longest_prefix.size\\n    end\\n\\n\\nend\\n\\n# Your LUPrefix object will be instantiated and called as such:\\n# obj = LUPrefix.new(n)\\n# obj.upload(video)\\n# param_2 = obj.longest()\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nclass LUPrefix\\n\\n=begin\\n    :type n: Integer\\n=end\\n    def initialize(n)\\n        @n = Array.new(n)\\n        @longest_prefix = []\\n    end\\n\\n\\n=begin\\n    :type video: Integer\\n    :rtype: Void\\n=end\\n    def upload(video)\\n        @n[video - 1] = video\\n    end\\n\\n\\n=begin\\n    :rtype: Integer\\n=end\\n    def longest()\\n        return 0 unless @n[0]\\n\\n        @longest_prefix.size.upto(@n.size - 1) do |idx|\\n            return @longest_prefix.size unless @n[idx]\\n            @longest_prefix << @n[idx]\\n        end\\n\\n        @longest_prefix.size\\n    end\\n\\n\\nend\\n\\n# Your LUPrefix object will be instantiated and called as such:\\n# obj = LUPrefix.new(n)\\n# obj.upload(video)\\n# param_2 = obj.longest()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605289,
                "title": "c-solution-using-visited-array-of-size-n-o-n-tc-and-o-n-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCarry len(i): minimum i from 1 that is not uploaded yet\\nTo know which is uploaded and which is not we use visited array.\\neach time we upload a video we can traverse until we find not uploaded video\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LUPrefix {\\npublic:\\n    vector<int> vis;\\n    int len = 1;\\n    LUPrefix(int n) {\\n        for(int i=0;i<=n;i++){\\n            vis.push_back(0);\\n        }\\n    }\\n    \\n    void upload(int video) {\\n        vis[video]=1;\\n        while(len<vis.size()&&vis[len]==1)len++;\\n\\n    }\\n    \\n    int longest() {\\n        return len-1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    vector<int> vis;\\n    int len = 1;\\n    LUPrefix(int n) {\\n        for(int i=0;i<=n;i++){\\n            vis.push_back(0);\\n        }\\n    }\\n    \\n    void upload(int video) {\\n        vis[video]=1;\\n        while(len<vis.size()&&vis[len]==1)len++;\\n\\n    }\\n    \\n    int longest() {\\n        return len-1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600038,
                "title": "easy-and-short-java-solution",
                "content": "\\n# Code\\n```\\nclass LUPrefix {\\n\\n    int prev;\\n    PriorityQueue<Integer> pq;\\n    public LUPrefix(int n) {\\n        prev = 0;\\n        pq = new PriorityQueue<>();\\n    }\\n    \\n    public void upload(int video) {\\n        pq.add(video);\\n        while(!pq.isEmpty()&&pq.peek()==prev+1){\\n            pq.poll();\\n            prev++;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return prev;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass LUPrefix {\\n\\n    int prev;\\n    PriorityQueue<Integer> pq;\\n    public LUPrefix(int n) {\\n        prev = 0;\\n        pq = new PriorityQueue<>();\\n    }\\n    \\n    public void upload(int video) {\\n        pq.add(video);\\n        while(!pq.isEmpty()&&pq.peek()==prev+1){\\n            pq.poll();\\n            prev++;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557592,
                "title": "time-o-1-space-o-n-solution-using-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LUPrefix {\\n    int longestPrefix = 0;\\n    int n;\\n    int[] next;\\n    int[] prev;\\n\\n    public LUPrefix(int n) {\\n        this.n = n;    \\n        next = new int[n + 1];\\n        prev = new int[n + 1];\\n        for(int i = 1;i <= n;i++){\\n            next[i] = i - 1;\\n            prev[i] = i + 1;\\n        }\\n    }\\n    \\n    public void upload(int video) {\\n        next[video] = video == n? n : next[video + 1];\\n        if(longestPrefix + 1 == video) \\n            longestPrefix = next[video];\\n        next[prev[video - 1]] = next[video];\\n        prev[video] = prev[video - 1];\\n        prev[next[video]] = prev[video];\\n    }\\n    \\n    public int longest() {\\n        return longestPrefix;        \\n    }\\n}\\n\\n//  3 10 29 32 38\\n//  3 10 29 32 38 \\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass LUPrefix {\\n    int longestPrefix = 0;\\n    int n;\\n    int[] next;\\n    int[] prev;\\n\\n    public LUPrefix(int n) {\\n        this.n = n;    \\n        next = new int[n + 1];\\n        prev = new int[n + 1];\\n        for(int i = 1;i <= n;i++){\\n            next[i] = i - 1;\\n            prev[i] = i + 1;\\n        }\\n    }\\n    \\n    public void upload(int video) {\\n        next[video] = video == n? n : next[video + 1];\\n        if(longestPrefix + 1 == video) \\n            longestPrefix = next[video];\\n        next[prev[video - 1]] = next[video];\\n        prev[video] = prev[video - 1];\\n        prev[next[video]] = prev[video];\\n    }\\n    \\n    public int longest() {\\n        return longestPrefix;        \\n    }\\n}\\n\\n//  3 10 29 32 38\\n//  3 10 29 32 38 \\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554260,
                "title": "single-array-and-low-pointer-three-lines-of-code",
                "content": "![image](https://assets.leetcode.com/users/images/7c848cc2-804a-4ac8-823c-ce87ceafba46_1684815632.3223813.jpeg)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/7c848cc2-804a-4ac8-823c-ce87ceafba46_1684815632.3223813.jpeg)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3552663,
                "title": "find-lower-upper-bound-with-monotonic-queue-and-heapq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n### We can find Min-Max problem with Upper bound and Lower bound \\n- First, find naive Min - Max\\n- Second, check-sum bound values with queue\\n\\n```\\nlower bound is prefix bound, check sum lower bound starting from 0, updateing the number with monotonic queue\\n\\nupper bound is maximum value, check is same as hq\\'s size, if not, strict lower bound is answer\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.hq = []\\n        self.query = []\\n        self.bound = 0\\n        self.upper = 0\\n        \\n\\n    def upload(self, video: int) -> None:\\n        self.upper = max(self.upper, video)\\n        heapq.heappush(self.hq, video)\\n        heapq.heappush(self.query, video)\\n\\n    def longest(self) -> int:\\n        if self.upper == len(self.hq):\\n            return self.upper\\n        \\n        elif self.query:\\n            prev = heapq.heappop(self.query)\\n            while self.query and self.bound+1 == prev:\\n                self.bound +=1\\n                prev = heapq.heappop(self.query)\\n            heapq.heappush(self.query, prev)\\n\\n        return self.bound\\n        \\n\\n        \\n\\n\\n# Your LUPrefix object will be instantiated and called as such:\\n# obj = LUPrefix(n)\\n# obj.upload(video)\\n# param_2 = obj.longest()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nlower bound is prefix bound, check sum lower bound starting from 0, updateing the number with monotonic queue\\n\\nupper bound is maximum value, check is same as hq\\'s size, if not, strict lower bound is answer\\n```\n```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.hq = []\\n        self.query = []\\n        self.bound = 0\\n        self.upper = 0\\n        \\n\\n    def upload(self, video: int) -> None:\\n        self.upper = max(self.upper, video)\\n        heapq.heappush(self.hq, video)\\n        heapq.heappush(self.query, video)\\n\\n    def longest(self) -> int:\\n        if self.upper == len(self.hq):\\n            return self.upper\\n        \\n        elif self.query:\\n            prev = heapq.heappop(self.query)\\n            while self.query and self.bound+1 == prev:\\n                self.bound +=1\\n                prev = heapq.heappop(self.query)\\n            heapq.heappush(self.query, prev)\\n\\n        return self.bound\\n        \\n\\n        \\n\\n\\n# Your LUPrefix object will be instantiated and called as such:\\n# obj = LUPrefix(n)\\n# obj.upload(video)\\n# param_2 = obj.longest()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485858,
                "title": "java-barley-20-lines-of-code-easy-af",
                "content": "# Intuition\\nPrefix keeps track of the smallest video # that has not yet been seen. Max keeps track of the upper bound of # videos. Uploaded keeps track of which videos have been uploaded\\n\\n# Complexity\\n- Time complexity:\\nlongest is O(1). I think upload should be O(1) amortized time \\n\\n- Space complexity:\\nO(N) for set\\n\\n# Code\\n```\\nclass LUPrefix {\\n    int max;\\n    int prefix;\\n    HashSet<Integer> uploaded;\\n    public LUPrefix(int n) {\\n        max = n + 1;\\n        prefix = 1;\\n        uploaded = new HashSet();\\n    }\\n    \\n    public void upload(int video) {\\n        uploaded.add(video);\\n\\n        while (uploaded.contains(prefix) && prefix <= max) {\\n            prefix++;\\n        } \\n    }\\n    \\n    public int longest() {\\n        return prefix - 1;\\n    }\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LUPrefix {\\n    int max;\\n    int prefix;\\n    HashSet<Integer> uploaded;\\n    public LUPrefix(int n) {\\n        max = n + 1;\\n        prefix = 1;\\n        uploaded = new HashSet();\\n    }\\n    \\n    public void upload(int video) {\\n        uploaded.add(video);\\n\\n        while (uploaded.contains(prefix) && prefix <= max) {\\n            prefix++;\\n        } \\n    }\\n    \\n    public int longest() {\\n        return prefix - 1;\\n    }\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3477237,
                "title": "longest-uploaded-prefix",
                "content": "-------------------- Easy C++ Solution -----------------\\n\\n# Code\\n```\\nclass LUPrefix {\\npublic:\\nLUPrefix(int n) {}\\nvoid upload(int video) {\\n    seen.insert(video);\\n    while (seen.count(longestPrefix + 1))\\n      ++longestPrefix;\\n  }\\n\\n  int longest() {\\n    return longestPrefix;\\n  }\\n\\n private:\\n  unordered_set<int> seen;\\n  int longestPrefix = 0;\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\nLUPrefix(int n) {}\\nvoid upload(int video) {\\n    seen.insert(video);\\n    while (seen.count(longestPrefix + 1))\\n      ++longestPrefix;\\n  }\\n\\n  int longest() {\\n    return longestPrefix;\\n  }\\n\\n private:\\n  unordered_set<int> seen;\\n  int longestPrefix = 0;\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3464711,
                "title": "c-using-segmenttrees",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log(n)) for ALL operation\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(4 * n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint totalVideos = 0; \\n\\nstruct segmentTree\\n{\\n    vector<bool> st;\\n\\n    void init(int n)\\n    {\\n        st.clear();\\n        st.resize(4 * n + 1, 0);\\n    }\\n\\n    void updateHelper(int node, int beg, int end, int i, int value)\\n    {\\n        if(beg == end)\\n        {\\n            if(beg == i) st[node] = value;\\n            return;\\n        }\\n\\n        int mid = (beg + end) / 2;\\n        \\n        if(i <= mid) updateHelper(2 * node, beg, mid, i, value);\\n        else updateHelper(2 * node + 1, mid + 1, end, i, value);\\n        \\n        st[node] = st[2 * node] & st[2 * node + 1];\\n    }\\n\\n    void update(int i, bool value)\\n    {\\n        updateHelper(1, 1, totalVideos, i, value);\\n    }\\n\\n    /*\\n    left | right | dir  | \\n    -----+-------+------+\\n      0  | 0, 1  | left | ans = left_max\\n      1  |   0   | right| ans = max(left_end, right_mx) [ why ? what if right_max = 0]\\n      1  |   1   | found| ans = now_end\\n    */\\n    int queryHelper(int node, int beg, int end)\\n    {\\n        if(beg == end)\\n        {\\n            return st[node] ? end : 0;\\n        }\\n\\n        if(st[node]) return end; // 1 | 1\\n\\n        int mid = (beg + end) / 2;\\n\\n        return (st[2 * node] == 0) ? queryHelper(2 * node, beg, mid) : max(mid, queryHelper(2 * node + 1, mid + 1, end)); \\n    }\\n\\n    int query()\\n    {\\n        return queryHelper(1, 1, totalVideos);\\n    }\\n};\\n\\nclass LUPrefix {\\n\\n    segmentTree tree;\\n\\npublic:\\n    LUPrefix(int n) {\\n        totalVideos = n;\\n        tree.init(n);\\n    }\\n    \\n    void upload(int video) {\\n        tree.update(video, 1);\\n    }\\n    \\n    int longest() {\\n        return tree.query();\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nint totalVideos = 0; \\n\\nstruct segmentTree\\n{\\n    vector<bool> st;\\n\\n    void init(int n)\\n    {\\n        st.clear();\\n        st.resize(4 * n + 1, 0);\\n    }\\n\\n    void updateHelper(int node, int beg, int end, int i, int value)\\n    {\\n        if(beg == end)\\n        {\\n            if(beg == i) st[node] = value;\\n            return;\\n        }\\n\\n        int mid = (beg + end) / 2;\\n        \\n        if(i <= mid) updateHelper(2 * node, beg, mid, i, value);\\n        else updateHelper(2 * node + 1, mid + 1, end, i, value);\\n        \\n        st[node] = st[2 * node] & st[2 * node + 1];\\n    }\\n\\n    void update(int i, bool value)\\n    {\\n        updateHelper(1, 1, totalVideos, i, value);\\n    }\\n\\n    /*\\n    left | right | dir  | \\n    -----+-------+------+\\n      0  | 0, 1  | left | ans = left_max\\n      1  |   0   | right| ans = max(left_end, right_mx) [ why ? what if right_max = 0]\\n      1  |   1   | found| ans = now_end\\n    */\\n    int queryHelper(int node, int beg, int end)\\n    {\\n        if(beg == end)\\n        {\\n            return st[node] ? end : 0;\\n        }\\n\\n        if(st[node]) return end; // 1 | 1\\n\\n        int mid = (beg + end) / 2;\\n\\n        return (st[2 * node] == 0) ? queryHelper(2 * node, beg, mid) : max(mid, queryHelper(2 * node + 1, mid + 1, end)); \\n    }\\n\\n    int query()\\n    {\\n        return queryHelper(1, 1, totalVideos);\\n    }\\n};\\n\\nclass LUPrefix {\\n\\n    segmentTree tree;\\n\\npublic:\\n    LUPrefix(int n) {\\n        totalVideos = n;\\n        tree.init(n);\\n    }\\n    \\n    void upload(int video) {\\n        tree.update(video, 1);\\n    }\\n    \\n    int longest() {\\n        return tree.query();\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450748,
                "title": "solution-using-bit-fenwick-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: logN for both upload and longest operations\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: logN\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LUPrefix {\\n    class BIT{\\n        int[] prefixes;\\n        int size;\\n        int highestBit;\\n        BIT(int size){\\n            this.size = size;\\n            prefixes = new int[size + 1];\\n            highestBit = 1;\\n            while(highestBit <= size){\\n                highestBit = highestBit << 1;\\n            }\\n            highestBit >>= 1;\\n        }\\n\\n        void update(int num, int index){\\n            while(index <= size){\\n                prefixes[index] += num;\\n                index += (index & -index); \\n            }\\n        }\\n\\n        int getLongest(){\\n            int ans = 0;\\n            int index = highestBit;\\n            while(index > 0){\\n                if(ans + index <= size && prefixes[ans + index] == index){\\n                    ans += index;\\n                }\\n                index = index >> 1;\\n            }\\n            return ans;\\n        }\\n    }\\n\\n\\n    BIT tree;\\n    \\n    public LUPrefix(int n) {\\n        tree = new BIT(n);\\n    }\\n    \\n    public void upload(int video) {\\n        \\n            tree.update(1, video);\\n    }\\n    \\n    public int longest() {\\n       \\n        return tree.getLongest();\\n    }\\n}\\n///   0   1   2   1   3\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LUPrefix {\\n    class BIT{\\n        int[] prefixes;\\n        int size;\\n        int highestBit;\\n        BIT(int size){\\n            this.size = size;\\n            prefixes = new int[size + 1];\\n            highestBit = 1;\\n            while(highestBit <= size){\\n                highestBit = highestBit << 1;\\n            }\\n            highestBit >>= 1;\\n        }\\n\\n        void update(int num, int index){\\n            while(index <= size){\\n                prefixes[index] += num;\\n                index += (index & -index); \\n            }\\n        }\\n\\n        int getLongest(){\\n            int ans = 0;\\n            int index = highestBit;\\n            while(index > 0){\\n                if(ans + index <= size && prefixes[ans + index] == index){\\n                    ans += index;\\n                }\\n                index = index >> 1;\\n            }\\n            return ans;\\n        }\\n    }\\n\\n\\n    BIT tree;\\n    \\n    public LUPrefix(int n) {\\n        tree = new BIT(n);\\n    }\\n    \\n    public void upload(int video) {\\n        \\n            tree.update(1, video);\\n    }\\n    \\n    public int longest() {\\n       \\n        return tree.getLongest();\\n    }\\n}\\n///   0   1   2   1   3\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431246,
                "title": "accepted-swift",
                "content": "```\\nclass LUPrefix {\\n\\n    private var uploaded: [Bool]\\n    private var long = 0\\n\\n    init(_ n: Int) {\\n        uploaded = Array(repeating: false, count: n + 1)\\n    }\\n    \\n    func upload(_ video: Int) {\\n        uploaded[video] = true\\n\\n        if video == long + 1 {\\n            while long + 1 < uploaded.count, uploaded[long + 1] { long += 1 }\\n        }\\n    }\\n    \\n    func longest() -> Int {\\n        long\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass LUPrefix {\\n\\n    private var uploaded: [Bool]\\n    private var long = 0\\n\\n    init(_ n: Int) {\\n        uploaded = Array(repeating: false, count: n + 1)\\n    }\\n    \\n    func upload(_ video: Int) {\\n        uploaded[video] = true\\n\\n        if video == long + 1 {\\n            while long + 1 < uploaded.count, uploaded[long + 1] { long += 1 }\\n        }\\n    }\\n    \\n    func longest() -> Int {\\n        long\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412630,
                "title": "python-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LUPrefix(object):\\n\\n    def __init__(self, n):\\n        \"\"\"\\n        :type n: int\\n        \"\"\"\\n        self.longest_prefix=0\\n        self.stream=set()\\n        \\n\\n    def upload(self, video):\\n        \"\"\"\\n        :type video: int\\n        :rtype: None\\n        \"\"\"\\n        self.stream.add(video)\\n        while self.longest_prefix+1 in self.stream:\\n            self.longest_prefix+=1\\n        \\n\\n    def longest(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.longest_prefix\\n        \\n\\n\\n# Your LUPrefix object will be instantiated and called as such:\\n# obj = LUPrefix(n)\\n# obj.upload(video)\\n# param_2 = obj.longest()\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass LUPrefix(object):\\n\\n    def __init__(self, n):\\n        \"\"\"\\n        :type n: int\\n        \"\"\"\\n        self.longest_prefix=0\\n        self.stream=set()\\n        \\n\\n    def upload(self, video):\\n        \"\"\"\\n        :type video: int\\n        :rtype: None\\n        \"\"\"\\n        self.stream.add(video)\\n        while self.longest_prefix+1 in self.stream:\\n            self.longest_prefix+=1\\n        \\n\\n    def longest(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        return self.longest_prefix\\n        \\n\\n\\n# Your LUPrefix object will be instantiated and called as such:\\n# obj = LUPrefix(n)\\n# obj.upload(video)\\n# param_2 = obj.longest()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412581,
                "title": "c-easy-to-understand-unordered-map",
                "content": "\\n\\n# Code\\n```\\nclass LUPrefix {\\npublic:\\n    LUPrefix(int n) {\\n        \\n    }\\n    int i = 0;\\n    unordered_map<int,bool>m;\\n    void upload(int video) {\\n        m[video]=true;\\n        while(m[i+1]){\\n            i++;\\n        }\\n    }\\n    \\n    int longest() {\\n        return i;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    LUPrefix(int n) {\\n        \\n    }\\n    int i = 0;\\n    unordered_map<int,bool>m;\\n    void upload(int video) {\\n        m[video]=true;\\n        while(m[i+1]){\\n            i++;\\n        }\\n    }\\n    \\n    int longest() {\\n        return i;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372409,
                "title": "fun-with-union-find",
                "content": "for the lulz\\n\\n```\\nclass LUPrefix:\\n    def find(self, a):\\n        if self.root[a] != a:\\n            self.root[a] = self.find(self.root[a])\\n        return self.root[a]\\n            \\n    def union(self, a, b):\\n        a = self.find(a)\\n        b = self.find(b)\\n        if a == b:\\n            return\\n        if self.size[a] > self.size[b]:\\n            self.root[b] = a\\n            self.size[a] += self.size[b]\\n        else:\\n            self.root[a] = b\\n            self.size[b] += self.size[a]\\n\\n    def __init__(self, n: int):\\n        self.root = [i for i in range(n+1)]\\n        self.size = [0] + [1 for i in range(n)]\\n        self.seen = [True] + [False for i in range(n)] + [False]\\n        \\n    def upload(self, video: int) -> None:\\n        self.seen[video] = True\\n        if self.seen[video-1]:\\n            self.union(video, video-1)\\n        if self.seen[video+1]:\\n            self.union(video, video+1)\\n\\n    def longest(self) -> int:    \\n        return self.size[self.find(0)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass LUPrefix:\\n    def find(self, a):\\n        if self.root[a] != a:\\n            self.root[a] = self.find(self.root[a])\\n        return self.root[a]\\n            \\n    def union(self, a, b):\\n        a = self.find(a)\\n        b = self.find(b)\\n        if a == b:\\n            return\\n        if self.size[a] > self.size[b]:\\n            self.root[b] = a\\n            self.size[a] += self.size[b]\\n        else:\\n            self.root[a] = b\\n            self.size[b] += self.size[a]\\n\\n    def __init__(self, n: int):\\n        self.root = [i for i in range(n+1)]\\n        self.size = [0] + [1 for i in range(n)]\\n        self.seen = [True] + [False for i in range(n)] + [False]\\n        \\n    def upload(self, video: int) -> None:\\n        self.seen[video] = True\\n        if self.seen[video-1]:\\n            self.union(video, video-1)\\n        if self.seen[video+1]:\\n            self.union(video, video+1)\\n\\n    def longest(self) -> int:    \\n        return self.size[self.find(0)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351059,
                "title": "go-solution-and-explaination-with-amortized-o-1",
                "content": "# Complexity\\n- Time complexity: every `obj.Longest` call is $$O(1)$$, `obj.Upload` call can be up to $$O(n)$$. However, in summary $$m$$ (even if $$m > n$$) calls of `obj.Upload` can\\'t do more than $$O(n)$$ iterations. Because of it we can say that a time complexity of `obj.Upload` is amortized $$\\\\frac{O(n)}{O(n)} = O(1)$$.\\n\\n- Space complexity: $$O(n)$$.\\n\\n# Code\\n```golang\\ntype LUPrefix struct {\\n\\tlongestPrefix int\\n\\tuploaded      []bool\\n}\\n\\nfunc Constructor(n int) (obj LUPrefix) {\\n\\tobj.uploaded = make([]bool, n)\\n\\treturn\\n}\\n\\nfunc (this *LUPrefix) updateLongestPrefix() {\\n\\t// Shift this.longestPrefix to the first non-uploaded video.\\n\\t// Multiple calls of this function won\\'t do more than `len(this.uploaded)` operations.\\n\\n\\tfor this.longestPrefix < len(this.uploaded) && this.uploaded[this.longestPrefix] {\\n\\t\\tthis.longestPrefix++\\n\\t}\\n}\\n\\nfunc (this *LUPrefix) Upload(video int) {\\n\\tthis.uploaded[video-1] = true\\n\\tthis.updateLongestPrefix()\\n}\\n\\nfunc (this *LUPrefix) Longest() int {\\n\\t// That variable is an answer as every `obj.Upload` triggers `obj.updateLongestPrefix`.\\n\\treturn this.longestPrefix\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "# Complexity\\n- Time complexity: every `obj.Longest` call is $$O(1)$$, `obj.Upload` call can be up to $$O(n)$$. However, in summary $$m$$ (even if $$m > n$$) calls of `obj.Upload` can\\'t do more than $$O(n)$$ iterations. Because of it we can say that a time complexity of `obj.Upload` is amortized $$\\\\frac{O(n)}{O(n)} = O(1)$$.\\n\\n- Space complexity: $$O(n)$$.\\n\\n# Code\\n```golang\\ntype LUPrefix struct {\\n\\tlongestPrefix int\\n\\tuploaded      []bool\\n}\\n\\nfunc Constructor(n int) (obj LUPrefix) {\\n\\tobj.uploaded = make([]bool, n)\\n\\treturn\\n}\\n\\nfunc (this *LUPrefix) updateLongestPrefix() {\\n\\t// Shift this.longestPrefix to the first non-uploaded video.\\n\\t// Multiple calls of this function won\\'t do more than `len(this.uploaded)` operations.\\n\\n\\tfor this.longestPrefix < len(this.uploaded) && this.uploaded[this.longestPrefix] {\\n\\t\\tthis.longestPrefix++\\n\\t}\\n}\\n\\nfunc (this *LUPrefix) Upload(video int) {\\n\\tthis.uploaded[video-1] = true\\n\\tthis.updateLongestPrefix()\\n}\\n\\nfunc (this *LUPrefix) Longest() int {\\n\\t// That variable is an answer as every `obj.Upload` triggers `obj.updateLongestPrefix`.\\n\\treturn this.longestPrefix\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3348852,
                "title": "binary-search-ordered-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp> // Common file\\n#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update\\n#include <ext/pb_ds/detail/standard_policies.hpp>\\nusing namespace __gnu_pbds;\\n\\n\\n\\ntypedef tree<long long , null_type, less_equal<long long >, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\\n\\nclass LUPrefix {\\npublic:\\n    ordered_set os;\\n    LUPrefix(int n) {\\n        \\n    }\\n    \\n    void upload(int video) {\\n        os.insert(video);\\n        \\n    }\\n    \\n    int longest() {\\n        int n=os.size();\\n        int lo=0;\\n        int hi=n-1;\\n        int ans=-1;\\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n            int a=*(os.find_by_order(mid));\\n            if(a>mid+1){\\n                hi=mid-1;\\n            }\\n            else{\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n\\n        }\\n        return ans+1;\\n        \\n    }\\n    //orderd_set + binary search\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp> // Common file\\n#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update\\n#include <ext/pb_ds/detail/standard_policies.hpp>\\nusing namespace __gnu_pbds;\\n\\n\\n\\ntypedef tree<long long , null_type, less_equal<long long >, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\\n\\nclass LUPrefix {\\npublic:\\n    ordered_set os;\\n    LUPrefix(int n) {\\n        \\n    }\\n    \\n    void upload(int video) {\\n        os.insert(video);\\n        \\n    }\\n    \\n    int longest() {\\n        int n=os.size();\\n        int lo=0;\\n        int hi=n-1;\\n        int ans=-1;\\n        while(lo<=hi){\\n            int mid=lo+(hi-lo)/2;\\n            int a=*(os.find_by_order(mid));\\n            if(a>mid+1){\\n                hi=mid-1;\\n            }\\n            else{\\n                ans=mid;\\n                lo=mid+1;\\n            }\\n\\n        }\\n        return ans+1;\\n        \\n    }\\n    //orderd_set + binary search\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3301043,
                "title": "simple-uploaded-solution",
                "content": "```\\n vector<int>arr;\\n    int pos = 1;\\n    int n;\\n    \\n    LUPrefix(int n) {\\n        this->n = n+1;\\n        arr.resize(n+1,0);\\n    }\\n    \\n    void upload(int vid) {\\n        arr[vid] = 1;\\n        if(pos==vid){\\n            while(pos<n and arr[pos]==1){\\n                pos++;\\n            }\\n        }\\n    }\\n    \\n    int longest() {\\n        return pos-1;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n vector<int>arr;\\n    int pos = 1;\\n    int n;\\n    \\n    LUPrefix(int n) {\\n        this->n = n+1;\\n        arr.resize(n+1,0);\\n    }\\n    \\n    void upload(int vid) {\\n        arr[vid] = 1;\\n        if(pos==vid){\\n            while(pos<n and arr[pos]==1){\\n                pos++;\\n            }\\n        }\\n    }\\n    \\n    int longest() {\\n        return pos-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3287775,
                "title": "very-easy-c-solution",
                "content": "# Code\\n```\\nclass LUPrefix \\n{\\npublic:\\n    vector<int> v;\\n    int i, n;\\n    LUPrefix(int n) \\n    {\\n        i=0;\\n        v.resize(n,0);\\n        this->n=n;\\n    }\\n    \\n    void upload(int video) \\n    {\\n        v[video-1]=1;\\n    }\\n    \\n    int longest() \\n    {\\n        while(i<n && v[i]) i++;\\n        return i;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LUPrefix \\n{\\npublic:\\n    vector<int> v;\\n    int i, n;\\n    LUPrefix(int n) \\n    {\\n        i=0;\\n        v.resize(n,0);\\n        this->n=n;\\n    }\\n    \\n    void upload(int video) \\n    {\\n        v[video-1]=1;\\n    }\\n    \\n    int longest() \\n    {\\n        while(i<n && v[i]) i++;\\n        return i;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250219,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass LUPrefix {\\n\\tpublic:\\n\\t\\tvector<int> v;\\n\\t\\tint it=0;\\n\\t\\tLUPrefix(int n) {\\n\\t\\t\\tvector<int> temp(n,-1);\\n\\t\\t\\tv=temp;\\n\\t\\t}\\n\\n\\t\\tvoid upload(int video) {\\n\\t\\t\\tv[video-1]=1;\\n\\t\\t\\twhile(it<v.size()){\\n\\t\\t\\t\\tif(v[it]==-1) break;\\n\\t\\t\\t\\tit++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint longest() {\\n\\t\\t\\treturn it;\\n\\t\\t}\\n\\t};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LUPrefix {\\n\\tpublic:\\n\\t\\tvector<int> v;\\n\\t\\tint it=0;\\n\\t\\tLUPrefix(int n) {\\n\\t\\t\\tvector<int> temp(n,-1);\\n\\t\\t\\tv=temp;\\n\\t\\t}\\n\\n\\t\\tvoid upload(int video) {\\n\\t\\t\\tv[video-1]=1;\\n\\t\\t\\twhile(it<v.size()){\\n\\t\\t\\t\\tif(v[it]==-1) break;\\n\\t\\t\\t\\tit++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint longest() {\\n\\t\\t\\treturn it;\\n\\t\\t}\\n\\t};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219797,
                "title": "java-solution-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LUPrefix {\\n    int a[], ind = 0, size;\\n    List<Integer> b;\\n    public LUPrefix(int n) {\\n        size = n + 1;\\n        a = new int[size];\\n    }\\n    \\n    public void upload(int video) {\\n        int c = video;\\n        a[c] = c;\\n        if(ind == c - 1) ind++;\\n        while(ind < size - 1 && a[ind + 1] == a[ind] + 1){\\n            ind++;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return a[ind];\\n    }\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass LUPrefix {\\n    int a[], ind = 0, size;\\n    List<Integer> b;\\n    public LUPrefix(int n) {\\n        size = n + 1;\\n        a = new int[size];\\n    }\\n    \\n    public void upload(int video) {\\n        int c = video;\\n        a[c] = c;\\n        if(ind == c - 1) ind++;\\n        while(ind < size - 1 && a[ind + 1] == a[ind] + 1){\\n            ind++;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return a[ind];\\n    }\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219484,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvery update operation holds the power to change the Longest Uploaded Prefix(lup) value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHave an array to maintain which video gets uploaded. After updating this array with 1 for every video upload, check changes to lup calculations.\\n\\nStarting with index 0, the lup value can only move to the next index value if the value at that index is 1 in the array that we are maintaining. We make the check, and update the lup value according before finishing up with update operation.\\n\\nThe longest operation just returns this value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nUpdate - O(n) \\nLongest - O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        # to keep track of the uploaded videos, 1 - uploaded, 0 - not uploaded \\n        self.temp = [0] * (n + 1)\\n        # to hold the longest uploaded prefix value\\n        self.lup = 0\\n\\n    def upload(self, video: int) -> None:\\n        # mark the video uploaded\\n        self.temp[video] = 1\\n        # the lup will start from index 0 and move to index 1 if possible, so \\n        # check if lup can move forward after every update operation\\n        idx = self.lup + 1\\n        # keep moving forward and update the lup container if it satisfies \\n        # the prefix condition\\n        while idx < len(self.temp) and self.temp[idx] == 1:\\n            self.lup = idx\\n            idx += 1\\n\\n    def longest(self) -> int:\\n        return self.lup        \\n\\n\\n# Your LUPrefix object will be instantiated and called as such:\\n# obj = LUPrefix(n)\\n# obj.upload(video)\\n# param_2 = obj.longest()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        # to keep track of the uploaded videos, 1 - uploaded, 0 - not uploaded \\n        self.temp = [0] * (n + 1)\\n        # to hold the longest uploaded prefix value\\n        self.lup = 0\\n\\n    def upload(self, video: int) -> None:\\n        # mark the video uploaded\\n        self.temp[video] = 1\\n        # the lup will start from index 0 and move to index 1 if possible, so \\n        # check if lup can move forward after every update operation\\n        idx = self.lup + 1\\n        # keep moving forward and update the lup container if it satisfies \\n        # the prefix condition\\n        while idx < len(self.temp) and self.temp[idx] == 1:\\n            self.lup = idx\\n            idx += 1\\n\\n    def longest(self) -> int:\\n        return self.lup        \\n\\n\\n# Your LUPrefix object will be instantiated and called as such:\\n# obj = LUPrefix(n)\\n# obj.upload(video)\\n# param_2 = obj.longest()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205648,
                "title": "python-o-1-time-o-n-space",
                "content": "# Approach\\nUpdate the leftmost & rightmost endpoints with the longest window. The values in between the leftmost & rightmost don\\'t matter since we won\\'t be accessing them anymore.\\n\\n# Complexity\\n- Time complexity: O(1)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass LUPrefix:\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.ds = [0]*n\\n\\n    def upload(self, video: int) -> None:\\n        left = right = 0\\n        video -= 1\\n        if video > 0: \\n            left = self.ds[video-1]\\n        if video < self.n-1:\\n            right = self.ds[video+1]\\n        # join both left & right windows to form the length of current window\\n        self.ds[video] = left+right+1 \\n        # update leftmost & rightmost endpoints in the window\\n        self.ds[video-left] = self.ds[video]\\n        self.ds[video+right] = self.ds[video]\\n\\n    def longest(self) -> int:\\n        return self.ds[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass LUPrefix:\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.ds = [0]*n\\n\\n    def upload(self, video: int) -> None:\\n        left = right = 0\\n        video -= 1\\n        if video > 0: \\n            left = self.ds[video-1]\\n        if video < self.n-1:\\n            right = self.ds[video+1]\\n        # join both left & right windows to form the length of current window\\n        self.ds[video] = left+right+1 \\n        # update leftmost & rightmost endpoints in the window\\n        self.ds[video-left] = self.ds[video]\\n        self.ds[video+right] = self.ds[video]\\n\\n    def longest(self) -> int:\\n        return self.ds[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202797,
                "title": "c-set-solution",
                "content": "```\\n```\\n```\\nclass LUPrefix {\\npublic:\\n    \\n    \\n    set<int> s; \\n    int t = 1; \\n    LUPrefix(int n) {\\n        s.clear();\\n    }\\n    \\n    void upload(int video) {\\n        s.insert(video); \\n    }\\n    \\n    int longest() {\\n        //cout << \"t is \" << t <<endl; \\n        while(s.count(t)){\\n            t++;\\n        }\\n        return t - 1 ;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n```\n```\\nclass LUPrefix {\\npublic:\\n    \\n    \\n    set<int> s; \\n    int t = 1; \\n    LUPrefix(int n) {\\n        s.clear();\\n    }\\n    \\n    void upload(int video) {\\n        s.insert(video); \\n    }\\n    \\n    int longest() {\\n        //cout << \"t is \" << t <<endl; \\n        while(s.count(t)){\\n            t++;\\n        }\\n        return t - 1 ;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```\n```\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3195045,
                "title": "using-single-pointer-o-1-easy-array-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nKeep the track of current longest uploaded prefix (L).\\nIt will always increase/remain same on video upload. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Take a vector of length n+1.\\n- Upload a video by setting 1 at the index of video. After this keep incrementing your longest uploaded prefix till the video is uploaded (1 is set at the position)\\n\\n\\n# Complexity\\n- Time complexity: O(1) per upload call\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LUPrefix {\\npublic:\\n\\n    vector<int> v;\\n\\n    int L = 0;\\n\\n\\n    LUPrefix(int n) {\\n        v = vector<int>(n+1,0);\\n    }\\n    \\n    void upload(int video) {\\n\\n        v[video] = 1;\\n\\n\\n        while((L+1)<v.size() && v[L+1]==1)\\n        {\\n            L++;\\n        }\\n    }\\n    \\n    int longest() {\\n        return L;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n\\n    vector<int> v;\\n\\n    int L = 0;\\n\\n\\n    LUPrefix(int n) {\\n        v = vector<int>(n+1,0);\\n    }\\n    \\n    void upload(int video) {\\n\\n        v[video] = 1;\\n\\n\\n        while((L+1)<v.size() && v[L+1]==1)\\n        {\\n            L++;\\n        }\\n    }\\n    \\n    int longest() {\\n        return L;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138020,
                "title": "c-vector-super-simple",
                "content": "```\\nclass LUPrefix {\\npublic:\\n    vector<bool> v;\\n    int i = 1;\\n    LUPrefix(int n) {\\n        v = vector<bool>(n + 2);\\n    }\\n    \\n    void upload(int video) {\\n        v[video] = true;\\n        while (v[i]) ++i;\\n    }\\n    \\n    int longest() {\\n        return i - 1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    vector<bool> v;\\n    int i = 1;\\n    LUPrefix(int n) {\\n        v = vector<bool>(n + 2);\\n    }\\n    \\n    void upload(int video) {\\n        v[video] = true;\\n        while (v[i]) ++i;\\n    }\\n    \\n    int longest() {\\n        return i - 1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087929,
                "title": "java-1ms-beats-92-and-clean-code",
                "content": "# Approach\\n1. Use an boolean[n+1] to mark present videos\\n2. Keep track of endOfPrefix to return it each time\\n3. With each upload, mark boolean[i] = true.\\n    - Start with endOfPrefix = 0; \\n    - If video == 1 (endOfPrefix + 1), you can build a prefix from 1 to k. Keep track of endOfPrefix\\n    - If video == endOfPrefix + 1, you might have another segment on the right that was just completed. \\n    Recalculate the endOfPrefix, but this time starting from the last know endOfPrefix.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LUPrefix {\\n    private final boolean[] uploads;\\n    private int endOfPrefix = 0;\\n    public LUPrefix(int n) {\\n        uploads = new boolean[n + 1];\\n    }\\n    \\n    public void upload(int video) {\\n        uploads[video] = true;\\n        if (video == endOfPrefix + 1) {\\n            calculateEndOfPrefix(video);\\n        }\\n    }\\n\\n    private void calculateEndOfPrefix(int from) {\\n        while(from < uploads.length && uploads[from]) {\\n            endOfPrefix = from++;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return endOfPrefix;\\n    }\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LUPrefix {\\n    private final boolean[] uploads;\\n    private int endOfPrefix = 0;\\n    public LUPrefix(int n) {\\n        uploads = new boolean[n + 1];\\n    }\\n    \\n    public void upload(int video) {\\n        uploads[video] = true;\\n        if (video == endOfPrefix + 1) {\\n            calculateEndOfPrefix(video);\\n        }\\n    }\\n\\n    private void calculateEndOfPrefix(int from) {\\n        while(from < uploads.length && uploads[from]) {\\n            endOfPrefix = from++;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return endOfPrefix;\\n    }\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084979,
                "title": "js-array-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} n\\n */\\nvar LUPrefix = function(n) {\\n    this.a = Array(n+1).fill(0)\\n    this.lastm = 0\\n};\\n\\n/** \\n * @param {number} video\\n * @return {void}\\n */\\nLUPrefix.prototype.upload = function(video) {\\n    this.a[video-1]++\\n};\\n\\n/**\\n * @return {number}\\n */\\nLUPrefix.prototype.longest = function() {\\n    while(this.a[this.lastm] != 0){\\n        this.lastm++\\n    }\\n    return this.lastm\\n};\\n\\n/** \\n * Your LUPrefix object will be instantiated and called as such:\\n * var obj = new LUPrefix(n)\\n * obj.upload(video)\\n * var param_2 = obj.longest()\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n */\\nvar LUPrefix = function(n) {\\n    this.a = Array(n+1).fill(0)\\n    this.lastm = 0\\n};\\n\\n/** \\n * @param {number} video\\n * @return {void}\\n */\\nLUPrefix.prototype.upload = function(video) {\\n    this.a[video-1]++\\n};\\n\\n/**\\n * @return {number}\\n */\\nLUPrefix.prototype.longest = function() {\\n    while(this.a[this.lastm] != 0){\\n        this.lastm++\\n    }\\n    return this.lastm\\n};\\n\\n/** \\n * Your LUPrefix object will be instantiated and called as such:\\n * var obj = new LUPrefix(n)\\n * obj.upload(video)\\n * var param_2 = obj.longest()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3052511,
                "title": "easy-set-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LUPrefix {\\npublic:\\n    int next = 1;\\n    unordered_set<int> set;\\n    int size;\\n    LUPrefix(int n) {\\n        this->size = n;\\n    }\\n    \\n    void upload(int video) {\\n        set.insert(video);\\n    }\\n    \\n    int longest() {\\n        while(set.count(next) > 0) {\\n            next += 1;\\n        }\\n\\n        return next-1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    int next = 1;\\n    unordered_set<int> set;\\n    int size;\\n    LUPrefix(int n) {\\n        this->size = n;\\n    }\\n    \\n    void upload(int video) {\\n        set.insert(video);\\n    }\\n    \\n    int longest() {\\n        while(set.count(next) > 0) {\\n            next += 1;\\n        }\\n\\n        return next-1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049678,
                "title": "no-loop-no-set-no-map-no-special-stls",
                "content": "\\tclass LUPrefix {\\n     public:\\n    vector<pair<int,int>>v;\\n    int n=0;\\n    int maxi=0;\\n    LUPrefix(int n) {\\n        v.resize(n+2,{-1,-1});\\n        this->n=n;\\n        v[0]={0,0};\\n    \\n    }\\n    \\n    void upload(int i) {\\n        v[i]={i,i};\\n        int f=1;\\n        if(v[i-1].first!=-1)\\n        {\\n            f=2;\\n            v[i].first=v[i-1].first;\\n            v[v[i-1].first].second=v[i].second;\\n            \\n        }\\n        if(v[i+1].second!=-1)\\n        {\\n            v[i].second=v[i+1].second;\\n             v[v[i+1].second].first=v[i].first;\\n        }\\n        if(f==2)\\n        {\\n            v[v[i-1].first].second=v[i].second;\\n        }\\n        \\n        if(v[i].first==0)\\n            maxi=v[i].second;\\n    }\\n    \\n    int longest() {\\n        return maxi;\\n    }\\n\\n\\nDo kindly upvote it if you like it!",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "\\tclass LUPrefix {\\n     public:\\n    vector<pair<int,int>>v;\\n    int n=0;\\n    int maxi=0;\\n    LUPrefix(int n) {\\n        v.resize(n+2,{-1,-1});\\n        this->n=n;\\n        v[0]={0,0};\\n    \\n    }\\n    \\n    void upload(int i) {\\n        v[i]={i,i};\\n        int f=1;\\n        if(v[i-1].first!=-1)\\n        {\\n            f=2;\\n            v[i].first=v[i-1].first;\\n            v[v[i-1].first].second=v[i].second;\\n            \\n        }\\n        if(v[i+1].second!=-1)\\n        {\\n            v[i].second=v[i+1].second;\\n             v[v[i+1].second].first=v[i].first;\\n        }\\n        if(f==2)\\n        {\\n            v[v[i-1].first].second=v[i].second;\\n        }\\n        \\n        if(v[i].first==0)\\n            maxi=v[i].second;\\n    }\\n    \\n    int longest() {\\n        return maxi;\\n    }\\n\\n\\nDo kindly upvote it if you like it!",
                "codeTag": "Java"
            },
            {
                "id": 3047525,
                "title": "simple-o-1-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LUPrefix {\\n    private boolean[] uploaded;\\n    private int res;\\n    public LUPrefix(int n) {\\n        uploaded=new boolean[n+1];\\n        res=1;\\n    }\\n    public void upload(int video) {\\n        uploaded[video]=true;\\n        while(res<uploaded.length && uploaded[res])res++;\\n    }\\n    public int longest() {\\n        return res-1;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LUPrefix {\\n    private boolean[] uploaded;\\n    private int res;\\n    public LUPrefix(int n) {\\n        uploaded=new boolean[n+1];\\n        res=1;\\n    }\\n    public void upload(int video) {\\n        uploaded[video]=true;\\n        while(res<uploaded.length && uploaded[res])res++;\\n    }\\n    public int longest() {\\n        return res-1;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3042186,
                "title": "javascript-fenwick-tree-bit-binary-search-640ms",
                "content": "```\\nfunction Fenwick(n) {\\n    let a = Array(n).fill(0);\\n    return { query, update, rangeSum, tree }\\n    function query(i) {\\n        let sum = 0;\\n        for (i++; i > 0; i = parent(i)) sum += a[i];\\n        return sum;\\n    }\\n    function update(i, v) {\\n        for (i++; i < n; i = next(i)) a[i] += v;\\n    }\\n    function rangeSum(l, r) {\\n        return query(r) - query(l - 1);\\n    }\\n    function parent(x) {\\n        return x - lowestOneBit(x);\\n    }\\n    function next(x) {\\n        return x + lowestOneBit(x);\\n    }\\n    function lowestOneBit(x) {\\n        return x & -x;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nfunction LUPrefix(n) {\\n    let fen = new Fenwick(n + 1), res = 0;\\n    return { upload, longest }\\n    function upload(x) {\\n        fen.update(x - 1, 1);\\n    }\\n    function longest() {\\n        let low = res, high = n;\\n        while (low <= high) {\\n            let mid = low + high >> 1;\\n            if (fen.rangeSum(0, mid - 1) == mid) {\\n                res = mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nfunction Fenwick(n) {\\n    let a = Array(n).fill(0);\\n    return { query, update, rangeSum, tree }\\n    function query(i) {\\n        let sum = 0;\\n        for (i++; i > 0; i = parent(i)) sum += a[i];\\n        return sum;\\n    }\\n    function update(i, v) {\\n        for (i++; i < n; i = next(i)) a[i] += v;\\n    }\\n    function rangeSum(l, r) {\\n        return query(r) - query(l - 1);\\n    }\\n    function parent(x) {\\n        return x - lowestOneBit(x);\\n    }\\n    function next(x) {\\n        return x + lowestOneBit(x);\\n    }\\n    function lowestOneBit(x) {\\n        return x & -x;\\n    }\\n    function tree() {\\n        return a;\\n    }\\n}\\n\\nfunction LUPrefix(n) {\\n    let fen = new Fenwick(n + 1), res = 0;\\n    return { upload, longest }\\n    function upload(x) {\\n        fen.update(x - 1, 1);\\n    }\\n    function longest() {\\n        let low = res, high = n;\\n        while (low <= high) {\\n            let mid = low + high >> 1;\\n            if (fen.rangeSum(0, mid - 1) == mid) {\\n                res = mid;\\n                low = mid + 1;\\n            } else {\\n                high = mid - 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3041885,
                "title": "javascript-avl-treeset-867ms-binary-search-treeset-6278ms",
                "content": "Main idea: reverse thinking, initially we save 1...n to treeset for not-upload videos.\\n\\nwhen upload video, we remove it from treeset. \\nthe longest upload videos sequence = [1..the first not uploaded video in treeset]\\n```\\n/////////////////////////// Template ////////////////////////////////\\nfunction AVLTreeNode(val) {\\n    this.val = val;\\n    this.left = null;\\n    this.right = null;\\n    this.height = 1;\\n    this.cnt = 1;\\n}\\n\\nfunction getHeight(node) {\\n    return node != null ? node.height : 0;\\n}\\nfunction getBalance(node) {\\n    return node != null ? getHeight(node.left) - getHeight(node.right) : 0;\\n}\\nfunction LR(z) {\\n    let y = z.right;\\n    let T2 = y.left;\\n    y.left = z;\\n    z.right = T2;\\n    z.height = 1 + Math.max(getHeight(z.left), getHeight(z.right));\\n    y.height = 1 + Math.max(getHeight(y.left), getHeight(y.right));\\n    return y;\\n}\\nfunction RR(z) {\\n    let y = z.left;\\n    let T3 = y.right;\\n    y.right = z\\n    z.left = T3\\n    z.height = 1 + Math.max(getHeight(z.left), getHeight(z.right));\\n    y.height = 1 + Math.max(getHeight(y.left), getHeight(y.right));\\n    return y;\\n}\\nfunction insert(node, v) {\\n    if (node == null) {\\n        return new AVLTreeNode(v);\\n    } else if (v < node.val) {\\n        node.left = insert(node.left, v);\\n    } else if (v > node.val) {\\n        node.right = insert(node.right, v);\\n    } else {\\n        node.cnt++;\\n        return node;\\n    }\\n    node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));\\n    let bal = getBalance(node);\\n    if (bal > 1 && v < node.left.val) return RR(node);\\n    if (bal > 1 && v > node.left.val) {\\n        node.left = LR(node.left);\\n        return RR(node);\\n    }\\n    if (bal < -1 && v > node.right.val) return LR(node);\\n    if (bal < -1 && v < node.right.val) {\\n        node.right = RR(node.right);\\n        return LR(node);\\n    }\\n    return node;\\n}\\nfunction remove(node, v) {\\n    if (node == null) {\\n        return node;\\n    } else if (v < node.val) {\\n        node.left = remove(node.left, v);\\n    } else if (v > node.val) {\\n        node.right = remove(node.right, v);\\n    } else {\\n        if (node.cnt > 1) {\\n            node.cnt--;\\n            return node;\\n        }\\n        if (node.left == null) {\\n            let tmp = node.right;\\n            node = null;\\n            return tmp;\\n        } else if (node.right == null) {\\n            let tmp = node.left;\\n            node = null;\\n            return tmp;\\n        }\\n        let tmp = minx(node.right);\\n        node.val = tmp.val;\\n        node.right = remove(node.right, tmp.val);\\n    }\\n    if (node == null) return node;\\n    node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));\\n    let bal = getBalance(node);\\n    if (bal > 1 && getBalance(node.left) >= 0) return RR(node);\\n    if (bal < -1 && getBalance(node.right) <= 0) return LR(node);\\n    if (bal > 1 && getBalance(node.left) < 0) {\\n        node.left = LR(node.left);\\n        return RR(node);\\n    }\\n    if (bal < -1 && getBalance(node.right) > 0) {\\n        node.right = RR(node.right);\\n        return LR(node);\\n    }\\n    return node;\\n}\\nfunction minx(node) {\\n    return node == null || node.left == null ? node : minx(node.left);\\n}\\nfunction maxx(node) {\\n    return node == null || node.right == null ? node : maxx(node.right);\\n}\\n\\nfunction TreeSet() {\\n    let root = null, se = new Set();\\n    return { add, first, last, rem, size, show }\\n    function add(v) {\\n        if (!se.has(v)) { // insert duplicates will cause issue\\n            root = insert(root, v);\\n            se.add(v);\\n        }\\n    }\\n    function first() {\\n        let res = minx(root);\\n        return res ? res.val : null;\\n    }\\n    function last() {\\n        let res = maxx(root);\\n        return res ? res.val : null;\\n    }\\n    function rem(v) {\\n        root = remove(root, v);\\n        se.delete(v);\\n    }\\n    function size() {\\n        return se.size;\\n    }\\n    function show() {\\n        return [...se].sort((x, y) => x - y);\\n    }\\n}\\n////////////////////////////////////////////////////////////////////\\nfunction LUPrefix(n) {\\n    let ts = new TreeSet();\\n    for (let i = 1; i <= n; i++) ts.add(i);\\n    return { upload, longest }\\n    function upload(x) {\\n        ts.rem(x);\\n    }\\n    function longest() {\\n        let res = ts.first();\\n        return res ? res - 1 : n;\\n    }\\n}\\n```\\nSolution 2: using binary search to write TreeSet\\n```\\n/////////////////////////// Template ////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nfunction TreeSet(elements) {\\n    let ts = [], se = new Set(), bisect = new Bisect();\\n    initialize();\\n    return { add, first, last, poll, pollLast, floor, ceiling, lower, higher, remove, contains, size, clear, show };\\n    function initialize() {\\n        if (elements) {\\n            for (const e of elements) {\\n                if (!se.has(e)) {\\n                    bisect.insort_right(ts, e);\\n                    se.add(e);\\n                }\\n            }\\n        }\\n    }\\n    function add(e) {\\n        if (!se.has(e)) {\\n            bisect.insort_right(ts, e);\\n            se.add(e);\\n        }\\n    }\\n    function first() {\\n        return ts[0];\\n    }\\n    function last() {\\n        return ts[ts.length - 1];\\n    }\\n    function poll() {\\n        let res = ts[0];\\n        ts.splice(0, 1);\\n        se.delete(res);\\n        return res;\\n    }\\n    function pollLast() {\\n        let res = ts.pop();\\n        se.delete(res);\\n        return res;\\n    }\\n    function ceiling(e) { // >= lower_bound\\n        let idx = bisect.bisect_right(ts, e);\\n        let res = ts[idx - 1] == e ? e : ts[bisect.bisect_right(ts, e)];\\n        return res == undefined ? null : res;\\n    }\\n    function higher(e) { // > upper_bound\\n        let idx = bisect.bisect_right(ts, e);\\n        let res = ts[idx] > e ? ts[idx] : ts[bisect.bisect_right(ts, e) + 1];\\n        return res == undefined ? null : res;\\n    }\\n    function floor(e) { // <= \\n        let idx = bisect.bisect_left(ts, e);\\n        let res = ts[idx] == e ? e : ts[bisect.bisect_left(ts, e) - 1];\\n        return res == undefined ? null : res;\\n    }\\n    function lower(e) { // <\\n        let idx = bisect.bisect_left(ts, e);\\n        let res = ts[idx] < e ? ts[idx] : ts[bisect.bisect_left(ts, e) - 1];\\n        return res == undefined ? null : res;\\n    }\\n    function remove(e) {\\n        let idx = bisect.bisect_left(ts, e);\\n        if (ts[idx] == e) ts.splice(idx, 1);\\n        se.delete(e);\\n    }\\n    function contains(e) {\\n        return se.has(e);\\n    }\\n    function size() {\\n        return ts.length;\\n    }\\n    function clear() {\\n        ts = [];\\n        se.clear();\\n    }\\n    function show() {\\n        return ts;\\n    }\\n}\\n/////////////////////////////////////////////////////////////////\\n\\nfunction LUPrefix(n) {\\n    let ts = new TreeSet();\\n    for (let i = 1; i <= n; i++) ts.add(i);\\n    return { upload, longest }\\n    function upload(x) {\\n        ts.remove(x);\\n    }\\n    function longest() {\\n        let res = ts.first();\\n        return res ? res - 1 : n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Indexed Tree",
                    "Ordered Set"
                ],
                "code": "```\\n/////////////////////////// Template ////////////////////////////////\\nfunction AVLTreeNode(val) {\\n    this.val = val;\\n    this.left = null;\\n    this.right = null;\\n    this.height = 1;\\n    this.cnt = 1;\\n}\\n\\nfunction getHeight(node) {\\n    return node != null ? node.height : 0;\\n}\\nfunction getBalance(node) {\\n    return node != null ? getHeight(node.left) - getHeight(node.right) : 0;\\n}\\nfunction LR(z) {\\n    let y = z.right;\\n    let T2 = y.left;\\n    y.left = z;\\n    z.right = T2;\\n    z.height = 1 + Math.max(getHeight(z.left), getHeight(z.right));\\n    y.height = 1 + Math.max(getHeight(y.left), getHeight(y.right));\\n    return y;\\n}\\nfunction RR(z) {\\n    let y = z.left;\\n    let T3 = y.right;\\n    y.right = z\\n    z.left = T3\\n    z.height = 1 + Math.max(getHeight(z.left), getHeight(z.right));\\n    y.height = 1 + Math.max(getHeight(y.left), getHeight(y.right));\\n    return y;\\n}\\nfunction insert(node, v) {\\n    if (node == null) {\\n        return new AVLTreeNode(v);\\n    } else if (v < node.val) {\\n        node.left = insert(node.left, v);\\n    } else if (v > node.val) {\\n        node.right = insert(node.right, v);\\n    } else {\\n        node.cnt++;\\n        return node;\\n    }\\n    node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));\\n    let bal = getBalance(node);\\n    if (bal > 1 && v < node.left.val) return RR(node);\\n    if (bal > 1 && v > node.left.val) {\\n        node.left = LR(node.left);\\n        return RR(node);\\n    }\\n    if (bal < -1 && v > node.right.val) return LR(node);\\n    if (bal < -1 && v < node.right.val) {\\n        node.right = RR(node.right);\\n        return LR(node);\\n    }\\n    return node;\\n}\\nfunction remove(node, v) {\\n    if (node == null) {\\n        return node;\\n    } else if (v < node.val) {\\n        node.left = remove(node.left, v);\\n    } else if (v > node.val) {\\n        node.right = remove(node.right, v);\\n    } else {\\n        if (node.cnt > 1) {\\n            node.cnt--;\\n            return node;\\n        }\\n        if (node.left == null) {\\n            let tmp = node.right;\\n            node = null;\\n            return tmp;\\n        } else if (node.right == null) {\\n            let tmp = node.left;\\n            node = null;\\n            return tmp;\\n        }\\n        let tmp = minx(node.right);\\n        node.val = tmp.val;\\n        node.right = remove(node.right, tmp.val);\\n    }\\n    if (node == null) return node;\\n    node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));\\n    let bal = getBalance(node);\\n    if (bal > 1 && getBalance(node.left) >= 0) return RR(node);\\n    if (bal < -1 && getBalance(node.right) <= 0) return LR(node);\\n    if (bal > 1 && getBalance(node.left) < 0) {\\n        node.left = LR(node.left);\\n        return RR(node);\\n    }\\n    if (bal < -1 && getBalance(node.right) > 0) {\\n        node.right = RR(node.right);\\n        return LR(node);\\n    }\\n    return node;\\n}\\nfunction minx(node) {\\n    return node == null || node.left == null ? node : minx(node.left);\\n}\\nfunction maxx(node) {\\n    return node == null || node.right == null ? node : maxx(node.right);\\n}\\n\\nfunction TreeSet() {\\n    let root = null, se = new Set();\\n    return { add, first, last, rem, size, show }\\n    function add(v) {\\n        if (!se.has(v)) { // insert duplicates will cause issue\\n            root = insert(root, v);\\n            se.add(v);\\n        }\\n    }\\n    function first() {\\n        let res = minx(root);\\n        return res ? res.val : null;\\n    }\\n    function last() {\\n        let res = maxx(root);\\n        return res ? res.val : null;\\n    }\\n    function rem(v) {\\n        root = remove(root, v);\\n        se.delete(v);\\n    }\\n    function size() {\\n        return se.size;\\n    }\\n    function show() {\\n        return [...se].sort((x, y) => x - y);\\n    }\\n}\\n////////////////////////////////////////////////////////////////////\\nfunction LUPrefix(n) {\\n    let ts = new TreeSet();\\n    for (let i = 1; i <= n; i++) ts.add(i);\\n    return { upload, longest }\\n    function upload(x) {\\n        ts.rem(x);\\n    }\\n    function longest() {\\n        let res = ts.first();\\n        return res ? res - 1 : n;\\n    }\\n}\\n```\n```\\n/////////////////////////// Template ////////////////////////////////\\nfunction Bisect() {\\n    return { insort_right, insort_left, bisect_left, bisect_right }\\n    function insort_right(a, x, lo = 0, hi = null) {\\n        lo = bisect_right(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_right(a, x, lo = 0, hi = null) { // > upper_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] > x ? hi = mid : lo = mid + 1;\\n        }\\n        return lo;\\n    }\\n    function insort_left(a, x, lo = 0, hi = null) {\\n        lo = bisect_left(a, x, lo, hi);\\n        a.splice(lo, 0, x);\\n    }\\n    function bisect_left(a, x, lo = 0, hi = null) { // >= lower_bound\\n        if (lo < 0) throw new Error(\\'lo must be non-negative\\');\\n        if (hi == null) hi = a.length;\\n        while (lo < hi) {\\n            let mid = parseInt((lo + hi) / 2);\\n            a[mid] < x ? lo = mid + 1 : hi = mid;\\n        }\\n        return lo;\\n    }\\n}\\n\\nfunction TreeSet(elements) {\\n    let ts = [], se = new Set(), bisect = new Bisect();\\n    initialize();\\n    return { add, first, last, poll, pollLast, floor, ceiling, lower, higher, remove, contains, size, clear, show };\\n    function initialize() {\\n        if (elements) {\\n            for (const e of elements) {\\n                if (!se.has(e)) {\\n                    bisect.insort_right(ts, e);\\n                    se.add(e);\\n                }\\n            }\\n        }\\n    }\\n    function add(e) {\\n        if (!se.has(e)) {\\n            bisect.insort_right(ts, e);\\n            se.add(e);\\n        }\\n    }\\n    function first() {\\n        return ts[0];\\n    }\\n    function last() {\\n        return ts[ts.length - 1];\\n    }\\n    function poll() {\\n        let res = ts[0];\\n        ts.splice(0, 1);\\n        se.delete(res);\\n        return res;\\n    }\\n    function pollLast() {\\n        let res = ts.pop();\\n        se.delete(res);\\n        return res;\\n    }\\n    function ceiling(e) { // >= lower_bound\\n        let idx = bisect.bisect_right(ts, e);\\n        let res = ts[idx - 1] == e ? e : ts[bisect.bisect_right(ts, e)];\\n        return res == undefined ? null : res;\\n    }\\n    function higher(e) { // > upper_bound\\n        let idx = bisect.bisect_right(ts, e);\\n        let res = ts[idx] > e ? ts[idx] : ts[bisect.bisect_right(ts, e) + 1];\\n        return res == undefined ? null : res;\\n    }\\n    function floor(e) { // <= \\n        let idx = bisect.bisect_left(ts, e);\\n        let res = ts[idx] == e ? e : ts[bisect.bisect_left(ts, e) - 1];\\n        return res == undefined ? null : res;\\n    }\\n    function lower(e) { // <\\n        let idx = bisect.bisect_left(ts, e);\\n        let res = ts[idx] < e ? ts[idx] : ts[bisect.bisect_left(ts, e) - 1];\\n        return res == undefined ? null : res;\\n    }\\n    function remove(e) {\\n        let idx = bisect.bisect_left(ts, e);\\n        if (ts[idx] == e) ts.splice(idx, 1);\\n        se.delete(e);\\n    }\\n    function contains(e) {\\n        return se.has(e);\\n    }\\n    function size() {\\n        return ts.length;\\n    }\\n    function clear() {\\n        ts = [];\\n        se.clear();\\n    }\\n    function show() {\\n        return ts;\\n    }\\n}\\n/////////////////////////////////////////////////////////////////\\n\\nfunction LUPrefix(n) {\\n    let ts = new TreeSet();\\n    for (let i = 1; i <= n; i++) ts.add(i);\\n    return { upload, longest }\\n    function upload(x) {\\n        ts.remove(x);\\n    }\\n    function longest() {\\n        let res = ts.first();\\n        return res ? res - 1 : n;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3034578,
                "title": "python-3-union-find-o-1-time",
                "content": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.par = {0: 0}\\n        self.rank = {0: 0}\\n    \\n    def ins(self, n1):\\n        if n1 in self.par:\\n            return\\n        self.par[n1] = n1\\n        self.rank[n1] = 1\\n    \\n    def find(self, n1):\\n        while n1 != self.par[n1]:\\n            self.par[n1] = self.par[self.par[n1]]\\n            n1 = self.par[n1]\\n        return n1\\n    \\n    def union(self, n1, n2):\\n        p1, p2 = self.find(n1), self.find(n2)\\n        if p1 == p2:\\n            return\\n        if self.rank[p1] < self.rank[p2]:\\n            p1, p2 = p2, p1\\n        self.par[p2] = p1\\n        self.rank[p1] += self.rank[p2]\\n        \\n    def upload(self, video: int) -> None:\\n        self.ins(video)\\n        \\n        if video + 1 in self.par:\\n            self.union(video, video + 1)\\n        if video - 1 in self.par:\\n            self.union(video, video - 1)\\n\\n    def longest(self) -> int:\\n        return self.rank[self.find(0)]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.par = {0: 0}\\n        self.rank = {0: 0}\\n    \\n    def ins(self, n1):\\n        if n1 in self.par:\\n            return\\n        self.par[n1] = n1\\n        self.rank[n1] = 1\\n    \\n    def find(self, n1):\\n        while n1 != self.par[n1]:\\n            self.par[n1] = self.par[self.par[n1]]\\n            n1 = self.par[n1]\\n        return n1\\n    \\n    def union(self, n1, n2):\\n        p1, p2 = self.find(n1), self.find(n2)\\n        if p1 == p2:\\n            return\\n        if self.rank[p1] < self.rank[p2]:\\n            p1, p2 = p2, p1\\n        self.par[p2] = p1\\n        self.rank[p1] += self.rank[p2]\\n        \\n    def upload(self, video: int) -> None:\\n        self.ins(video)\\n        \\n        if video + 1 in self.par:\\n            self.union(video, video + 1)\\n        if video - 1 in self.par:\\n            self.union(video, video - 1)\\n\\n    def longest(self) -> int:\\n        return self.rank[self.find(0)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024222,
                "title": "c-simple",
                "content": "```\\nclass LUPrefix {\\n    int N;\\n    int expected_video;\\n    int longest_len;\\n    vector<bool> ready;\\npublic:\\n    LUPrefix(int n) : N{n}, expected_video{0}, longest_len{0} {\\n        ready.resize(N, false);\\n    }\\n    \\n    void upload(int video) {\\n        const int video_id = video - 1;\\n        ready[video_id] = true;\\n        if(expected_video == video_id) {\\n            while(ready[expected_video] && expected_video < N) {\\n                longest_len++, expected_video++;\\n            }\\n        }\\n    }\\n    \\n    int longest() {\\n        return longest_len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass LUPrefix {\\n    int N;\\n    int expected_video;\\n    int longest_len;\\n    vector<bool> ready;\\npublic:\\n    LUPrefix(int n) : N{n}, expected_video{0}, longest_len{0} {\\n        ready.resize(N, false);\\n    }\\n    \\n    void upload(int video) {\\n        const int video_id = video - 1;\\n        ready[video_id] = true;\\n        if(expected_video == video_id) {\\n            while(ready[expected_video] && expected_video < N) {\\n                longest_len++, expected_video++;\\n            }\\n        }\\n    }\\n    \\n    int longest() {\\n        return longest_len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005050,
                "title": "c-simple-code-using-policybaseddatastructure-ordered-set",
                "content": "# Code\\n```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\n\\nusing namespace std;\\nusing namespace __gnu_pbds;\\n// #define int long long\\n#define pi pair<int , int>\\n#define ppi pair<pi ,int>\\n\\n// int INF = INT64_MAX;\\nint mod = 1e9+7;\\n\\ntypedef tree<int,null_type,less<int> ,rb_tree_tag,tree_order_statistics_node_update> pbds;\\n\\nbool IsTrue(pbds &p1, int mid)\\n{\\n    return ((p1.find(mid) != p1.end()) && (p1.order_of_key(mid) == mid-1));\\n}\\nclass LUPrefix {\\npublic:\\n    int n;\\n    pbds p1;\\n    LUPrefix(int N) {\\n        n = N;\\n    }\\n    void upload(int video){\\n        p1.insert(video);   \\n    }\\n    int longest(){\\n        int l = 1, r = n, res = 0;\\n        while(l <= r)\\n        {\\n            int mid = (l + r)/2;\\n            if(IsTrue(p1, mid)){res = mid; l= mid+1;}\\n            else r = mid-1;\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<ext/pb_ds/assoc_container.hpp>\\n#include<ext/pb_ds/tree_policy.hpp>\\n\\nusing namespace std;\\nusing namespace __gnu_pbds;\\n// #define int long long\\n#define pi pair<int , int>\\n#define ppi pair<pi ,int>\\n\\n// int INF = INT64_MAX;\\nint mod = 1e9+7;\\n\\ntypedef tree<int,null_type,less<int> ,rb_tree_tag,tree_order_statistics_node_update> pbds;\\n\\nbool IsTrue(pbds &p1, int mid)\\n{\\n    return ((p1.find(mid) != p1.end()) && (p1.order_of_key(mid) == mid-1));\\n}\\nclass LUPrefix {\\npublic:\\n    int n;\\n    pbds p1;\\n    LUPrefix(int N) {\\n        n = N;\\n    }\\n    void upload(int video){\\n        p1.insert(video);   \\n    }\\n    int longest(){\\n        int l = 1, r = n, res = 0;\\n        while(l <= r)\\n        {\\n            int mid = (l + r)/2;\\n            if(IsTrue(p1, mid)){res = mid; l= mid+1;}\\n            else r = mid-1;\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3000436,
                "title": "soln-using-sorted-containers-iterators",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        from sortedcontainers import SortedSet\\n        self.n=n\\n        k = [x for x in range(1,n+1)]\\n        self.s = SortedSet(k)  \\n\\n    def upload(self, video: int) -> None:\\n        self.s.remove(video)\\n        #print(self.s)\\n        \\n\\n    def longest(self) -> int:\\n        iterator = iter(self.s)\\n        if len(self.s) == 0:\\n            return self.n\\n        #try:\\n        num = next(iterator)\\n        #except:\\n        #    return 0\\n        return num-1\\n        \\n\\n\\n# Your LUPrefix object will be instantiated and called as such:\\n# obj = LUPrefix(n)\\n# obj.upload(video)\\n# param_2 = obj.longest()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        from sortedcontainers import SortedSet\\n        self.n=n\\n        k = [x for x in range(1,n+1)]\\n        self.s = SortedSet(k)  \\n\\n    def upload(self, video: int) -> None:\\n        self.s.remove(video)\\n        #print(self.s)\\n        \\n\\n    def longest(self) -> int:\\n        iterator = iter(self.s)\\n        if len(self.s) == 0:\\n            return self.n\\n        #try:\\n        num = next(iterator)\\n        #except:\\n        #    return 0\\n        return num-1\\n        \\n\\n\\n# Your LUPrefix object will be instantiated and called as such:\\n# obj = LUPrefix(n)\\n# obj.upload(video)\\n# param_2 = obj.longest()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999081,
                "title": "ok",
                "content": "```\\nclass LUPrefix \\n{\\n    int n[1000001]{}, i{1};\\npublic:\\n    LUPrefix(int n)    {}\\n    void upload(int v) { for(++n[v]; n[i]; ++i); }\\n    int longest()      { return i-1;             }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass LUPrefix \\n{\\n    int n[1000001]{}, i{1};\\npublic:\\n    LUPrefix(int n)    {}\\n    void upload(int v) { for(++n[v]; n[i]; ++i); }\\n    int longest()      { return i-1;             }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994437,
                "title": "c-easy-solution-using-combinatin-of-min-max-heap",
                "content": "\\n\\n# Code\\n```\\nclass LUPrefix {\\npublic:\\n    \\n    //the max heap would keep track of maximum prefix\\n    // the min heap would keep track of apparent non-maximum prefixes\\n\\n    priority_queue<int, vector<int>, greater<int>> pq_min;\\n    priority_queue<int> pq_max;\\n\\n    LUPrefix(int n) {\\n        \\n    }\\n    \\n    void upload(int video) {\\n        if(video==1){\\n            pq_max.push(video);\\n        } else{\\n            pq_min.push(video);\\n           \\n        }\\n         if(!pq_max.empty()){\\n                while(!pq_min.empty() && pq_max.top()==pq_min.top()-1) {\\n                    pq_max.push(pq_min.top());\\n                    pq_min.pop();\\n                }\\n            }\\n    }\\n    \\n    int longest() {\\n        if(pq_max.empty())\\n        return 0;\\n        return pq_max.top();\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    \\n    //the max heap would keep track of maximum prefix\\n    // the min heap would keep track of apparent non-maximum prefixes\\n\\n    priority_queue<int, vector<int>, greater<int>> pq_min;\\n    priority_queue<int> pq_max;\\n\\n    LUPrefix(int n) {\\n        \\n    }\\n    \\n    void upload(int video) {\\n        if(video==1){\\n            pq_max.push(video);\\n        } else{\\n            pq_min.push(video);\\n           \\n        }\\n         if(!pq_max.empty()){\\n                while(!pq_min.empty() && pq_max.top()==pq_min.top()-1) {\\n                    pq_max.push(pq_min.top());\\n                    pq_min.pop();\\n                }\\n            }\\n    }\\n    \\n    int longest() {\\n        if(pq_max.empty())\\n        return 0;\\n        return pq_max.top();\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2990499,
                "title": "simple-python-solution",
                "content": "# Intuition\\nTo solve this problem, we need to search videos in set or dictionary\\n\\n# Approach\\ncreate a set or dictionary\\nupload videos in it\\nlongestPrefix = 0\\ncheck longestPrefix+1 in set\\n    longestPrefix += 1\\nreturn longestPrefix\\n\\n# Complexity\\n- Time complexity:\\nO(1) for each upload\\n\\n- Space complexity:\\nO(N) for creating a set or dictionary\\n\\n# Code\\n```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.longestPrefix = 0\\n        self.array = set()\\n        \\n    def upload(self, video: int) -> None:\\n        self.array.add(video)\\n        while self.longestPrefix+1 in self.array:\\n            self.longestPrefix += 1\\n\\n    def longest(self) -> int:\\n        return self.longestPrefix\\n        \\n\\n\\n# Your LUPrefix object will be instantiated and called as such:\\n# obj = LUPrefix(n)\\n# obj.upload(video)\\n# param_2 = obj.longest()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.longestPrefix = 0\\n        self.array = set()\\n        \\n    def upload(self, video: int) -> None:\\n        self.array.add(video)\\n        while self.longestPrefix+1 in self.array:\\n            self.longestPrefix += 1\\n\\n    def longest(self) -> int:\\n        return self.longestPrefix\\n        \\n\\n\\n# Your LUPrefix object will be instantiated and called as such:\\n# obj = LUPrefix(n)\\n# obj.upload(video)\\n# param_2 = obj.longest()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986217,
                "title": "longest-uploaded-prefix-c-explained-solution",
                "content": "***Do Upvote If Found Helpful !***\\n\\n# Intuition\\nThis question is actually based on a famous concept known as **Minimum Excludant or commonly know as MEX**. MEX is basically the smallest positive integer that is not present in a sequence of numbers (All numbers of this sequence are positive). For example we have : **1,3,4,5 Here MEX is 2.** Another example we can take : **1,2,3,4,5 Here MEX is 6**. Sometimes people also start sequence considering **0** as first element but in this question numbering has been done from **1 to N**.\\n\\n# Approach\\nThe simple approach for calculating MEX is using a set **in C++ STL** that regularly maintains sorted order of elements. We start by putting all numbers from **1 to N+1 in this set**. Then whenever a video is uploaded, we just remove that **video (number)** from the set denoting that this video can no longer be a viable answer for MEX as its already present in sequence. Whenever a query is made for **LU Prefix**, we just return **the smallest element in set - 1 , which can be easily retrieved using .begin() function in O(1)**. Implementation goes below : \\n\\n# Complexity\\n- Amortised Time complexity: **O(N)**, although after a deletion it takes logarithmic operations to restore the balance of set. **Extra Info : Set in C++ STL is implemented as a Balanced Binary Search Tree like Red Black Tree or AVL Tree in backend**.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# NOTE \\n- You can also use an array for finding MEX, time and space remains same.\\n# Code\\n```\\nclass LUPrefix {\\npublic:\\n    set<int>uploader;\\n    LUPrefix(int n) {\\n        for(int i = 1; i <= n+1; i++){\\n            uploader.insert(i);\\n        }\\n    }\\n    \\n    void upload(int video) {\\n        uploader.erase(video);\\n    }\\n    \\n    int longest() {\\n        return *uploader.begin() - 1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass LUPrefix {\\npublic:\\n    set<int>uploader;\\n    LUPrefix(int n) {\\n        for(int i = 1; i <= n+1; i++){\\n            uploader.insert(i);\\n        }\\n    }\\n    \\n    void upload(int video) {\\n        uploader.erase(video);\\n    }\\n    \\n    int longest() {\\n        return *uploader.begin() - 1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984710,
                "title": "simple-js-solution-with-help-of-set",
                "content": "# Code\\n```js\\n/**\\n * @param {number} n\\n */\\nconst LUPrefix = function(n) {\\n    this.uploaded = new Set();\\n    this.longestPrefix = 0;\\n    this.n = n;\\n};\\n\\n/** \\n * @param {number} video\\n * @return {void}\\n */\\nLUPrefix.prototype.upload = function(video) {\\n    if (video === this.longestPrefix + 1) {\\n        this.longestPrefix++;\\n    } else {\\n        this.uploaded.add(video);\\n    }\\n\\n    for (let i = this.longestPrefix + 1; i <= this.n; i++) {\\n        if (this.uploaded.has(i)) {\\n            this.longestPrefix++;\\n            this.uploaded.delete(i);\\n        } else {\\n            break;\\n        }\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nLUPrefix.prototype.longest = function() {\\n    return this.longestPrefix;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number} n\\n */\\nconst LUPrefix = function(n) {\\n    this.uploaded = new Set();\\n    this.longestPrefix = 0;\\n    this.n = n;\\n};\\n\\n/** \\n * @param {number} video\\n * @return {void}\\n */\\nLUPrefix.prototype.upload = function(video) {\\n    if (video === this.longestPrefix + 1) {\\n        this.longestPrefix++;\\n    } else {\\n        this.uploaded.add(video);\\n    }\\n\\n    for (let i = this.longestPrefix + 1; i <= this.n; i++) {\\n        if (this.uploaded.has(i)) {\\n            this.longestPrefix++;\\n            this.uploaded.delete(i);\\n        } else {\\n            break;\\n        }\\n    }\\n};\\n\\n/**\\n * @return {number}\\n */\\nLUPrefix.prototype.longest = function() {\\n    return this.longestPrefix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2967074,
                "title": "java-simple-solution",
                "content": "# Intuition\\nkeep track of maxPrefix\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass LUPrefix {\\n    int maxPrefix;\\n    boolean [] dp;\\n    public LUPrefix(int n) {\\n        this.maxPrefix=0;\\n        this.dp = new boolean[n+1];\\n        dp[0] = true;\\n    }\\n    \\n    public void upload(int video) {\\n        dp[video] = true;\\n        int n = dp.length;\\n        int k = maxPrefix;\\n        for(int i=k; i<n && dp[i] ; i++){\\n                maxPrefix = i;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return maxPrefix;\\n    }\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass LUPrefix {\\n    int maxPrefix;\\n    boolean [] dp;\\n    public LUPrefix(int n) {\\n        this.maxPrefix=0;\\n        this.dp = new boolean[n+1];\\n        dp[0] = true;\\n    }\\n    \\n    public void upload(int video) {\\n        dp[video] = true;\\n        int n = dp.length;\\n        int k = maxPrefix;\\n        for(int i=k; i<n && dp[i] ; i++){\\n                maxPrefix = i;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return maxPrefix;\\n    }\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963763,
                "title": "hashset-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass LUPrefix {\\n    HashSet<Integer>set;\\n    int longest=0;\\n    public LUPrefix(int n) {\\n        this.set=new HashSet<>();\\n    }\\n    \\n    public void upload(int video) {\\n        set.add(video);\\n        longest++;\\n        while(set.contains(longest)){\\n            longest++;\\n        }\\n       --longest;\\n    }\\n    \\n    public int longest() {\\n       return longest;\\n    }\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass LUPrefix {\\n    HashSet<Integer>set;\\n    int longest=0;\\n    public LUPrefix(int n) {\\n        this.set=new HashSet<>();\\n    }\\n    \\n    public void upload(int video) {\\n        set.add(video);\\n        longest++;\\n        while(set.contains(longest)){\\n            longest++;\\n        }\\n       --longest;\\n    }\\n    \\n    public int longest() {\\n       return longest;\\n    }\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2963198,
                "title": "c-set",
                "content": "# Code\\n```\\nclass LUPrefix {\\n    set<int> Set;\\npublic:\\n    LUPrefix(int n) {\\n        n++;\\n        for(int i = 1; i <= n; i++) {\\n            Set.insert(i);\\n        }\\n    }\\n    \\n    void upload(int video) {\\n        Set.erase(video);\\n    }\\n    \\n    int longest() {\\n        return *Set.begin() - 1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Design",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass LUPrefix {\\n    set<int> Set;\\npublic:\\n    LUPrefix(int n) {\\n        n++;\\n        for(int i = 1; i <= n; i++) {\\n            Set.insert(i);\\n        }\\n    }\\n    \\n    void upload(int video) {\\n        Set.erase(video);\\n    }\\n    \\n    int longest() {\\n        return *Set.begin() - 1;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933032,
                "title": "typescript-solution-100-faster-efficient",
                "content": "# Complexity\\n- Time complexity: O(N) considering worst case where we upload video upto N consecutively\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) (can be O(1) \\uD83E\\uDD14)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass LUPrefix {\\n    server: Array<number>;\\n    current: number;\\n\\n    constructor(n: number) {\\n        this.server = Array(n).fill(0);\\n        this.current = 0;\\n    }\\n\\n    upload(video: number): void {\\n        ++this.server[video - 1];\\n    }\\n\\n    longest(): number {\\n        const n = this.server.length;\\n\\n        while (this.current < n && this.server[this.current] !== 0) {\\n            ++this.current;\\n        }\\n\\n        return this.current;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nclass LUPrefix {\\n    server: Array<number>;\\n    current: number;\\n\\n    constructor(n: number) {\\n        this.server = Array(n).fill(0);\\n        this.current = 0;\\n    }\\n\\n    upload(video: number): void {\\n        ++this.server[video - 1];\\n    }\\n\\n    longest(): number {\\n        const n = this.server.length;\\n\\n        while (this.current < n && this.server[this.current] !== 0) {\\n            ++this.current;\\n        }\\n\\n        return this.current;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913985,
                "title": "python",
                "content": "```\\nclass LUPrefix:\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.arr = [-1]*self.n\\n        self.i = 0\\n\\n    def upload(self, video: int) -> None:\\n        if video-1 == self.i:\\n            self.i+=1\\n        self.arr[video-1] = 1\\n\\n    def longest(self) -> int:\\n        if self.arr[0]==-1:\\n            return 0\\n        while self.i < self.n:\\n            if self.arr[self.i]!=-1:\\n                self.i+=1\\n            else:\\n                return self.i\\n        return self.i\\n```",
                "solutionTags": [],
                "code": "```\\nclass LUPrefix:\\n    def __init__(self, n: int):\\n        self.n = n\\n        self.arr = [-1]*self.n\\n        self.i = 0\\n\\n    def upload(self, video: int) -> None:\\n        if video-1 == self.i:\\n            self.i+=1\\n        self.arr[video-1] = 1\\n\\n    def longest(self) -> int:\\n        if self.arr[0]==-1:\\n            return 0\\n        while self.i < self.n:\\n            if self.arr[self.i]!=-1:\\n                self.i+=1\\n            else:\\n                return self.i\\n        return self.i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2885619,
                "title": "c-modern-a-clever-while-loop",
                "content": "# Code\\n```\\nclass LUPrefix {\\n public:\\n  LUPrefix(int n) {}\\n\\n  void upload(int video) {\\n    uploaded.insert(video);\\n\\n    while (uploaded.find(longest_prefix + 1) != uploaded.end()) {\\n      ++longest_prefix;\\n    }\\n  }\\n\\n  auto longest() -> int {\\n    return longest_prefix;\\n  }\\n\\n private:\\n  unordered_set<int> uploaded;\\n  int longest_prefix{0};\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LUPrefix {\\n public:\\n  LUPrefix(int n) {}\\n\\n  void upload(int video) {\\n    uploaded.insert(video);\\n\\n    while (uploaded.find(longest_prefix + 1) != uploaded.end()) {\\n      ++longest_prefix;\\n    }\\n  }\\n\\n  auto longest() -> int {\\n    return longest_prefix;\\n  }\\n\\n private:\\n  unordered_set<int> uploaded;\\n  int longest_prefix{0};\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2871399,
                "title": "o-nlogn-c-solution-using-priorty-queue",
                "content": "# Approach\\nWe just need to keep track of items that may still end up in the prefix.\\nMany data structures can be used for this, including `set` and `unordered_set`, but min-`priority_queue` also works, since its top element contains the candidate for extending prefix.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n \\\\times log(n))$$ which can technically be reduced to $$O(n)$$ by switching to `unordered_set`.\\n\\n- Space complexity:\\n$$O(n)$$ since in the worst case all elements are added from last to first resulting in heap containing all `n` elements.\\n\\n# Code\\n```\\nclass LUPrefix {\\nprivate:\\n    priority_queue<int, vector<int>, greater<int>> seen;\\n    int prefix;\\npublic:\\n    LUPrefix(int n): prefix{0} {}\\n\\n    void upload(int video) {\\n        seen.push(video);\\n        while (!seen.empty() && prefix + 1 == seen.top()) {\\n            prefix = seen.top();\\n            seen.pop();\\n        }\\n    }\\n    \\n    int longest() {\\n        return prefix;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass LUPrefix {\\nprivate:\\n    priority_queue<int, vector<int>, greater<int>> seen;\\n    int prefix;\\npublic:\\n    LUPrefix(int n): prefix{0} {}\\n\\n    void upload(int video) {\\n        seen.push(video);\\n        while (!seen.empty() && prefix + 1 == seen.top()) {\\n            prefix = seen.top();\\n            seen.pop();\\n        }\\n    }\\n    \\n    int longest() {\\n        return prefix;\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2855960,
                "title": "union-find-o-1-insert-and-search-o-n-space",
                "content": "```\\nclass LUPrefix {\\n    Map<Integer, Integer> parent = new HashMap<>();\\n    int max = 0;\\n    boolean[] placed;\\n\\n    public LUPrefix(int n) {\\n        placed = new boolean[n + 1];\\n        for(int i = 1; i <= n; i++) {\\n            parent.put(i, i);\\n        }\\n    }\\n    \\n    public void upload(int i) {\\n        placed[i] = true;\\n        \\n        if (i - 1 >= 1 && placed[i - 1]){\\n            union(i, i - 1);\\n        }\\n        \\n        \\n        if (i + 1 < placed.length && placed[i + 1]){\\n            union(i, i + 1);\\n        }\\n    }\\n    \\n    public int longest() {\\n        if (!placed[1]) return 0;\\n        return find(1);\\n    }\\n    \\n    int find(int x) {\\n        if (x == parent.get(x)) {\\n            return x;\\n        }\\n        \\n        parent.put(x, find(parent.get(x)));\\n        return parent.get(x);\\n    }\\n    \\n    void union(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        \\n        if (x > y) {\\n            parent.put(y, x);\\n        } else if (y > x) {\\n            parent.put(x, y);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass LUPrefix {\\n    Map<Integer, Integer> parent = new HashMap<>();\\n    int max = 0;\\n    boolean[] placed;\\n\\n    public LUPrefix(int n) {\\n        placed = new boolean[n + 1];\\n        for(int i = 1; i <= n; i++) {\\n            parent.put(i, i);\\n        }\\n    }\\n    \\n    public void upload(int i) {\\n        placed[i] = true;\\n        \\n        if (i - 1 >= 1 && placed[i - 1]){\\n            union(i, i - 1);\\n        }\\n        \\n        \\n        if (i + 1 < placed.length && placed[i + 1]){\\n            union(i, i + 1);\\n        }\\n    }\\n    \\n    public int longest() {\\n        if (!placed[1]) return 0;\\n        return find(1);\\n    }\\n    \\n    int find(int x) {\\n        if (x == parent.get(x)) {\\n            return x;\\n        }\\n        \\n        parent.put(x, find(parent.get(x)));\\n        return parent.get(x);\\n    }\\n    \\n    void union(int x, int y) {\\n        x = find(x);\\n        y = find(y);\\n        \\n        if (x > y) {\\n            parent.put(y, x);\\n        } else if (y > x) {\\n            parent.put(x, y);\\n        }\\n    }\\n}\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix obj = new LUPrefix(n);\\n * obj.upload(video);\\n * int param_2 = obj.longest();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852831,
                "title": "typescript-solution-o-n",
                "content": "Just Store Last longest prefix\\n\\n```\\nclass LUPrefix {\\n  num: number[];\\n  longestUptilNow:number = 0;\\n  constructor(n: number) {\\n    this.num = new Array();\\n    this.num.fill(n+1, 0);\\n  }\\n\\n  upload(video: number): void {\\n    this.num[video - 1] = video;\\n  }\\n\\n  longest(): number {\\n    for (let i = this.longestUptilNow; i <= this.num.length; i++) {\\n      if (i + 1 !== this.num[i]) {\\n        this.longestUptilNow  = i;\\n        return i;\\n      }\\n    }\\n    return -1;\\n  }\\n}",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "Just Store Last longest prefix\\n\\n```\\nclass LUPrefix {\\n  num: number[];\\n  longestUptilNow:number = 0;\\n  constructor(n: number) {\\n    this.num = new Array();\\n    this.num.fill(n+1, 0);\\n  }\\n\\n  upload(video: number): void {\\n    this.num[video - 1] = video;\\n  }\\n\\n  longest(): number {\\n    for (let i = this.longestUptilNow; i <= this.num.length; i++) {\\n      if (i + 1 !== this.num[i]) {\\n        this.longestUptilNow  = i;\\n        return i;\\n      }\\n    }\\n    return -1;\\n  }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2844168,
                "title": "easy-python-solution",
                "content": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.n = n \\n        self.upload_stream = [0 for i in range(n)]\\n        self.end = 0\\n        self.counter = 0\\n\\n    def upload(self, video: int) -> None:\\n        self.upload_stream[video-1] = 1\\n\\n    def longest(self) -> int:\\n        for i in range(self.end, len(self.upload_stream)) : \\n            if self.upload_stream[i] == 0 : \\n                self.end = i\\n                break \\n            else : \\n                self.counter += 1 \\n        return self.counter \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Design"
                ],
                "code": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.n = n \\n        self.upload_stream = [0 for i in range(n)]\\n        self.end = 0\\n        self.counter = 0\\n\\n    def upload(self, video: int) -> None:\\n        self.upload_stream[video-1] = 1\\n\\n    def longest(self) -> int:\\n        for i in range(self.end, len(self.upload_stream)) : \\n            if self.upload_stream[i] == 0 : \\n                self.end = i\\n                break \\n            else : \\n                self.counter += 1 \\n        return self.counter \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2841632,
                "title": "python-bit-binary-search-binary-index-tree-easy-simple",
                "content": "#### Approach-1: Using Binary Index Tree + Binary Search\\n```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.N = n\\n        self.bit = [0]*(self.N+1)\\n            \\n    def _sum(self, idx):\\n        ans = 0\\n        while idx>=1:\\n            ans+=self.bit[idx]\\n            idx-=(idx&-idx)\\n        return ans\\n        \\n    def upload(self, video: int) -> None:\\n        idx, val = video, video\\n        while idx<=self.N:\\n            self.bit[idx]+=val\\n            idx+=(idx&-idx)\\n    \\n    def longest(self) -> int:\\n        l,r = 1, self.N\\n        while l<=r:\\n            mid = (l+r)//2\\n            if self._sum(mid) == mid*(mid+1)//2:\\n                l = mid+1\\n            else:\\n                r = mid-1\\n        return l-1\\n```\\n\\n\\n#### Approach-2:\\n\\n```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self._longest = 1\\n        self._nums = [False]*(n+2)\\n\\n    def upload(self, video: int) -> None:\\n        self._nums[video] = True\\n        \\n        while self._nums[self._longest]:\\n            self._longest+=1\\n        \\n    def longest(self) -> int:\\n        return self._longest-1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Indexed Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.N = n\\n        self.bit = [0]*(self.N+1)\\n            \\n    def _sum(self, idx):\\n        ans = 0\\n        while idx>=1:\\n            ans+=self.bit[idx]\\n            idx-=(idx&-idx)\\n        return ans\\n        \\n    def upload(self, video: int) -> None:\\n        idx, val = video, video\\n        while idx<=self.N:\\n            self.bit[idx]+=val\\n            idx+=(idx&-idx)\\n    \\n    def longest(self) -> int:\\n        l,r = 1, self.N\\n        while l<=r:\\n            mid = (l+r)//2\\n            if self._sum(mid) == mid*(mid+1)//2:\\n                l = mid+1\\n            else:\\n                r = mid-1\\n        return l-1\\n```\n```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self._longest = 1\\n        self._nums = [False]*(n+2)\\n\\n    def upload(self, video: int) -> None:\\n        self._nums[video] = True\\n        \\n        while self._nums[self._longest]:\\n            self._longest+=1\\n        \\n    def longest(self) -> int:\\n        return self._longest-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812270,
                "title": "java-o-n-time-solution",
                "content": "```\\nclass LUPrefix {\\n    private boolean[] arr;\\n    private int index = 0;\\n    private int n;\\n    \\n    public LUPrefix(int n) {\\n        this.n = n;\\n        arr = new boolean[n];\\n    }\\n    \\n    public void upload(int video) {\\n        arr[video - 1] = true;\\n        while (index != n && arr[index]) {\\n            index++;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return index;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass LUPrefix {\\n    private boolean[] arr;\\n    private int index = 0;\\n    private int n;\\n    \\n    public LUPrefix(int n) {\\n        this.n = n;\\n        arr = new boolean[n];\\n    }\\n    \\n    public void upload(int video) {\\n        arr[video - 1] = true;\\n        while (index != n && arr[index]) {\\n            index++;\\n        }\\n    }\\n    \\n    public int longest() {\\n        return index;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2804126,
                "title": "solution-using-segment-tree-in-o-n-log-n",
                "content": "```\\n//You can solve it easily using other structure but using segment tree \\n//is good for practicing segment tree\\n```\\nclass LUPrefix {\\npublic:\\n    int *arr;\\n    int size=0;\\n    void buildTree(int i,int j,int pos){\\n        if(i==j){\\n            arr[pos]=0;\\n            return;\\n        }\\n        int mid=(i+j)/2;\\n        buildTree(i,mid,(pos*2)+1);\\n        buildTree(mid+1,j,(pos*2)+2);\\n        arr[pos]=arr[(pos*2)+1]+arr[(pos*2)+2];\\n    }\\n    LUPrefix(int n) {\\n        size=n;\\n        arr=new int[(4*n)+1];\\n        buildTree(0,n-1,0);\\n    }\\n    void upload_helper(int i,int j,int video_no,int pos){\\n        if(video_no==i and video_no==j){\\n            arr[pos]=1;\\n            return;\\n        }\\n        int mid=(i+j)/2;\\n        if(video_no<=mid){\\n            upload_helper(i,mid,video_no,(pos*2)+1);\\n        }else{\\n            upload_helper(mid+1,j,video_no,(pos*2)+2);\\n        }\\n        arr[pos]=arr[(pos*2)+1]+arr[(pos*2)+2];\\n    }\\n    void upload(int video) {\\n        upload_helper(0,size-1,video-1,0);\\n    }\\n    int longest_helper(int i,int j,int pos){\\n        if(i==j){\\n            return arr[pos];\\n        }\\n        int mid=(i+j)/2;\\n        int left_size=(mid-i)+1;\\n        int right_size=(j-(mid+1))+1;\\n        int l=(pos*2)+1,r=(pos*2)+2;\\n        if(arr[l]==left_size and arr[r]==right_size)return arr[l]+arr[r];\\n        if(arr[l]==left_size){\\n            return arr[l]+longest_helper(mid+1,j,r);\\n        }else{\\n            return longest_helper(i,mid,l);\\n        }\\n    }\\n    int longest() {\\n        return longest_helper(0,size-1,0);\\n    }\\n};\\n\\n/**\\n * Your LUPrefix object will be instantiated and called as such:\\n * LUPrefix* obj = new LUPrefix(n);\\n * obj->upload(video);\\n * int param_2 = obj->longest();\\n */",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n//You can solve it easily using other structure but using segment tree \\n//is good for practicing segment tree\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2796418,
                "title": "c",
                "content": "```\\ntypedef struct {\\n    bool* data;\\n    int size;\\n    int longest;\\n} LUPrefix;\\n\\n\\nLUPrefix* lUPrefixCreate(int n) {\\n    LUPrefix* ret = malloc(sizeof(LUPrefix));\\n    ret->data = calloc((n+1) , sizeof(bool));\\n    ret->size = n;\\n    ret->longest = 0;\\n    return ret;\\n}\\n\\nvoid lUPrefixUpload(LUPrefix* obj, int video) {\\n    obj->data[video] = true;\\n    if(obj->data[1] == true){\\n        int i = obj->longest + 1;\\n        for(i = obj->longest + 1; i <= obj->size; i++){\\n            if(obj->data[i] != true)\\n                break;\\n        }\\n        obj->longest = i-1;\\n    }\\n}\\n\\nint lUPrefixLongest(LUPrefix* obj) {\\n    return obj->longest;\\n}\\n\\nvoid lUPrefixFree(LUPrefix* obj) {\\n    free(obj->data);\\n    free(obj);\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef struct {\\n    bool* data;\\n    int size;\\n    int longest;\\n} LUPrefix;\\n\\n\\nLUPrefix* lUPrefixCreate(int n) {\\n    LUPrefix* ret = malloc(sizeof(LUPrefix));\\n    ret->data = calloc((n+1) , sizeof(bool));\\n    ret->size = n;\\n    ret->longest = 0;\\n    return ret;\\n}\\n\\nvoid lUPrefixUpload(LUPrefix* obj, int video) {\\n    obj->data[video] = true;\\n    if(obj->data[1] == true){\\n        int i = obj->longest + 1;\\n        for(i = obj->longest + 1; i <= obj->size; i++){\\n            if(obj->data[i] != true)\\n                break;\\n        }\\n        obj->longest = i-1;\\n    }\\n}\\n\\nint lUPrefixLongest(LUPrefix* obj) {\\n    return obj->longest;\\n}\\n\\nvoid lUPrefixFree(LUPrefix* obj) {\\n    free(obj->data);\\n    free(obj);\\n    \\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2795032,
                "title": "golang-two-arrays",
                "content": "```go\\ntype LUPrefix struct {\\n\\ton      []bool\\n\\tfill    []bool\\n\\tlongest int\\n}\\n\\nfunc Constructor(n int) LUPrefix {\\n\\ton, fill := make([]bool, n+2), make([]bool, n+2)\\n\\ton[0], fill[0] = true, true\\n\\treturn LUPrefix{on, fill, 0}\\n}\\n\\nfunc (this *LUPrefix) Upload(video int) {\\n\\tthis.on[video] = true\\n\\tif this.fill[video-1] {\\n\\t\\tthis.fill[video] = true\\n\\t\\tl := video\\n\\t\\tfor this.on[l+1] {\\n\\t\\t\\tl += 1\\n\\t\\t\\tthis.fill[l] = true\\n\\t\\t}\\n\\t\\tif l > this.longest {\\n\\t\\t\\tthis.longest = l\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (this *LUPrefix) Longest() int {\\n\\treturn this.longest\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype LUPrefix struct {\\n\\ton      []bool\\n\\tfill    []bool\\n\\tlongest int\\n}\\n\\nfunc Constructor(n int) LUPrefix {\\n\\ton, fill := make([]bool, n+2), make([]bool, n+2)\\n\\ton[0], fill[0] = true, true\\n\\treturn LUPrefix{on, fill, 0}\\n}\\n\\nfunc (this *LUPrefix) Upload(video int) {\\n\\tthis.on[video] = true\\n\\tif this.fill[video-1] {\\n\\t\\tthis.fill[video] = true\\n\\t\\tl := video\\n\\t\\tfor this.on[l+1] {\\n\\t\\t\\tl += 1\\n\\t\\t\\tthis.fill[l] = true\\n\\t\\t}\\n\\t\\tif l > this.longest {\\n\\t\\t\\tthis.longest = l\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc (this *LUPrefix) Longest() int {\\n\\treturn this.longest\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2791754,
                "title": "python-o-1-time-2-dictionary",
                "content": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.s2l = defaultdict(int)\\n        self.l2s = defaultdict(int)\\n\\n    def upload(self, video: int) -> None:      \\n        if self.l2s[video - 1] != 0 and self.s2l[video + 1] != 0 :\\n            self.s2l[self.l2s[video - 1]] = self.s2l[video + 1]\\n            self.l2s[self.s2l[video + 1]] = self.l2s[video - 1]\\n        elif self.l2s[video - 1] != 0:\\n            self.l2s[video] = self.l2s[video - 1]\\n            self.s2l[self.l2s[video - 1]] = video\\n        elif self.s2l[video + 1] != 0:\\n            self.s2l[video] = self.s2l[video + 1]\\n            self.l2s[self.s2l[video + 1]] = video\\n        else:\\n            self.l2s[video] = video\\n            self.s2l[video] = video\\n        \\n    def longest(self) -> int:\\n        return self.s2l[1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass LUPrefix:\\n\\n    def __init__(self, n: int):\\n        self.s2l = defaultdict(int)\\n        self.l2s = defaultdict(int)\\n\\n    def upload(self, video: int) -> None:      \\n        if self.l2s[video - 1] != 0 and self.s2l[video + 1] != 0 :\\n            self.s2l[self.l2s[video - 1]] = self.s2l[video + 1]\\n            self.l2s[self.s2l[video + 1]] = self.l2s[video - 1]\\n        elif self.l2s[video - 1] != 0:\\n            self.l2s[video] = self.l2s[video - 1]\\n            self.s2l[self.l2s[video - 1]] = video\\n        elif self.s2l[video + 1] != 0:\\n            self.s2l[video] = self.s2l[video + 1]\\n            self.l2s[self.s2l[video + 1]] = video\\n        else:\\n            self.l2s[video] = video\\n            self.s2l[video] = video\\n        \\n    def longest(self) -> int:\\n        return self.s2l[1]\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1714583,
                "content": [
                    {
                        "username": "dwluciano",
                        "content": "`unpopular opinion:` This question should be marked as easy or the size of the input should be increased"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "If you\\'re stuck with the linear solution \"TLE\\'ing\", then the solution is correct in terms of Big O (worst case time complexity analysis). It\\'s failing because the average time complexity is higher. Think about an optimization that will reduce the average time complexity, and not the worst case time complexity.  \\nUnfortunately average time complexity matters in this problem as of writing this comment."
                    },
                    {
                        "username": "moukthik",
                        "content": "` \n\n    def __init__(self, n):\n        \"\"\"\n        :type n: int\n        \"\"\"\n        self.s = set()\n        self.length = n\n        for i in range(1,n + 1):\n            self.s.add(i)\n        \n\n    def upload(self, video):\n        \"\"\"\n        :type video: int\n        :rtype: None\n        \"\"\"\n        self.s.remove(video)\n        \n\n    def longest(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.s:\n            return self.length\n        return min(self.s) - 1\n        \n\n`\nwhy is this TLE? pls help"
                    },
                    {
                        "username": "vdas53073",
                        "content": " `class LUPrefix {\\npublic:\\nvector<int>v;\\nint prefix =-1;\\n    LUPrefix(int n) {\\n        v.resize(n);\\n        fill(v.begin(),v.end(),0);\\n    }\\n    \\n    void upload(int video) {\\n        v[video-1]++;\\n    }\\n    \\n    int longest() {\\n        int f =0;\\n      for(int i=0;i<v.size();i++){\\n           if(v[i] == 0)\\n           return f;\\n           else\\n           f++;\\n      }\\n      return f;\\n    }\\n};`\\n\\nWhy giving TLE plzz HELP ?"
                    },
                    {
                        "username": "ayushgupta232002",
                        "content": "The number of queries are ```2e5```, and can have successively ask for the longest value. In your solution, you are iterating till the size of all the videos. There will be a testcase where the number of videos will be 2e5, and the answer would also be nearly ```2e5```. Hence, the overall number of operations are in the order of ```1e10``` thus TLE. "
                    }
                ]
            },
            {
                "id": 1903666,
                "content": [
                    {
                        "username": "dwluciano",
                        "content": "`unpopular opinion:` This question should be marked as easy or the size of the input should be increased"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "If you\\'re stuck with the linear solution \"TLE\\'ing\", then the solution is correct in terms of Big O (worst case time complexity analysis). It\\'s failing because the average time complexity is higher. Think about an optimization that will reduce the average time complexity, and not the worst case time complexity.  \\nUnfortunately average time complexity matters in this problem as of writing this comment."
                    },
                    {
                        "username": "moukthik",
                        "content": "` \n\n    def __init__(self, n):\n        \"\"\"\n        :type n: int\n        \"\"\"\n        self.s = set()\n        self.length = n\n        for i in range(1,n + 1):\n            self.s.add(i)\n        \n\n    def upload(self, video):\n        \"\"\"\n        :type video: int\n        :rtype: None\n        \"\"\"\n        self.s.remove(video)\n        \n\n    def longest(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.s:\n            return self.length\n        return min(self.s) - 1\n        \n\n`\nwhy is this TLE? pls help"
                    },
                    {
                        "username": "vdas53073",
                        "content": " `class LUPrefix {\\npublic:\\nvector<int>v;\\nint prefix =-1;\\n    LUPrefix(int n) {\\n        v.resize(n);\\n        fill(v.begin(),v.end(),0);\\n    }\\n    \\n    void upload(int video) {\\n        v[video-1]++;\\n    }\\n    \\n    int longest() {\\n        int f =0;\\n      for(int i=0;i<v.size();i++){\\n           if(v[i] == 0)\\n           return f;\\n           else\\n           f++;\\n      }\\n      return f;\\n    }\\n};`\\n\\nWhy giving TLE plzz HELP ?"
                    },
                    {
                        "username": "ayushgupta232002",
                        "content": "The number of queries are ```2e5```, and can have successively ask for the longest value. In your solution, you are iterating till the size of all the videos. There will be a testcase where the number of videos will be 2e5, and the answer would also be nearly ```2e5```. Hence, the overall number of operations are in the order of ```1e10``` thus TLE. "
                    }
                ]
            },
            {
                "id": 1696981,
                "content": [
                    {
                        "username": "dwluciano",
                        "content": "`unpopular opinion:` This question should be marked as easy or the size of the input should be increased"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "If you\\'re stuck with the linear solution \"TLE\\'ing\", then the solution is correct in terms of Big O (worst case time complexity analysis). It\\'s failing because the average time complexity is higher. Think about an optimization that will reduce the average time complexity, and not the worst case time complexity.  \\nUnfortunately average time complexity matters in this problem as of writing this comment."
                    },
                    {
                        "username": "moukthik",
                        "content": "` \n\n    def __init__(self, n):\n        \"\"\"\n        :type n: int\n        \"\"\"\n        self.s = set()\n        self.length = n\n        for i in range(1,n + 1):\n            self.s.add(i)\n        \n\n    def upload(self, video):\n        \"\"\"\n        :type video: int\n        :rtype: None\n        \"\"\"\n        self.s.remove(video)\n        \n\n    def longest(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.s:\n            return self.length\n        return min(self.s) - 1\n        \n\n`\nwhy is this TLE? pls help"
                    },
                    {
                        "username": "vdas53073",
                        "content": " `class LUPrefix {\\npublic:\\nvector<int>v;\\nint prefix =-1;\\n    LUPrefix(int n) {\\n        v.resize(n);\\n        fill(v.begin(),v.end(),0);\\n    }\\n    \\n    void upload(int video) {\\n        v[video-1]++;\\n    }\\n    \\n    int longest() {\\n        int f =0;\\n      for(int i=0;i<v.size();i++){\\n           if(v[i] == 0)\\n           return f;\\n           else\\n           f++;\\n      }\\n      return f;\\n    }\\n};`\\n\\nWhy giving TLE plzz HELP ?"
                    },
                    {
                        "username": "ayushgupta232002",
                        "content": "The number of queries are ```2e5```, and can have successively ask for the longest value. In your solution, you are iterating till the size of all the videos. There will be a testcase where the number of videos will be 2e5, and the answer would also be nearly ```2e5```. Hence, the overall number of operations are in the order of ```1e10``` thus TLE. "
                    }
                ]
            },
            {
                "id": 1628098,
                "content": [
                    {
                        "username": "dwluciano",
                        "content": "`unpopular opinion:` This question should be marked as easy or the size of the input should be increased"
                    },
                    {
                        "username": "user3366Sy",
                        "content": "If you\\'re stuck with the linear solution \"TLE\\'ing\", then the solution is correct in terms of Big O (worst case time complexity analysis). It\\'s failing because the average time complexity is higher. Think about an optimization that will reduce the average time complexity, and not the worst case time complexity.  \\nUnfortunately average time complexity matters in this problem as of writing this comment."
                    },
                    {
                        "username": "moukthik",
                        "content": "` \n\n    def __init__(self, n):\n        \"\"\"\n        :type n: int\n        \"\"\"\n        self.s = set()\n        self.length = n\n        for i in range(1,n + 1):\n            self.s.add(i)\n        \n\n    def upload(self, video):\n        \"\"\"\n        :type video: int\n        :rtype: None\n        \"\"\"\n        self.s.remove(video)\n        \n\n    def longest(self):\n        \"\"\"\n        :rtype: int\n        \"\"\"\n        if not self.s:\n            return self.length\n        return min(self.s) - 1\n        \n\n`\nwhy is this TLE? pls help"
                    },
                    {
                        "username": "vdas53073",
                        "content": " `class LUPrefix {\\npublic:\\nvector<int>v;\\nint prefix =-1;\\n    LUPrefix(int n) {\\n        v.resize(n);\\n        fill(v.begin(),v.end(),0);\\n    }\\n    \\n    void upload(int video) {\\n        v[video-1]++;\\n    }\\n    \\n    int longest() {\\n        int f =0;\\n      for(int i=0;i<v.size();i++){\\n           if(v[i] == 0)\\n           return f;\\n           else\\n           f++;\\n      }\\n      return f;\\n    }\\n};`\\n\\nWhy giving TLE plzz HELP ?"
                    },
                    {
                        "username": "ayushgupta232002",
                        "content": "The number of queries are ```2e5```, and can have successively ask for the longest value. In your solution, you are iterating till the size of all the videos. There will be a testcase where the number of videos will be 2e5, and the answer would also be nearly ```2e5```. Hence, the overall number of operations are in the order of ```1e10``` thus TLE. "
                    }
                ]
            }
        ]
    }
]