[
    {
        "title": "Minimum Fuel Cost to Report to the Capital",
        "question_content": "There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of n cities numbered from 0 to n - 1 and exactly n - 1 roads. The capital city is city 0. You are given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.\nThere is a meeting for the representatives of each city. The meeting is in the capital city.\nThere is a car in each city. You are given an integer seats that indicates the number of seats in each car.\nA representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.\nReturn the minimum number of liters of fuel to reach the capital city.\n&nbsp;\nExample 1:\n\nInput: roads = [[0,1],[0,2],[0,3]], seats = 5\nOutput: 3\nExplanation: \n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative2 goes directly to the capital with 1 liter of fuel.\n- Representative3 goes directly to the capital with 1 liter of fuel.\nIt costs 3 liters of fuel at minimum. \nIt can be proven that 3 is the minimum number of liters of fuel needed.\n\nExample 2:\n\nInput: roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2\nOutput: 7\nExplanation: \n- Representative2 goes directly to city 3 with 1 liter of fuel.\n- Representative2 and representative3 go together to city 1 with 1 liter of fuel.\n- Representative2 and representative3 go together to the capital with 1 liter of fuel.\n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative5 goes directly to the capital with 1 liter of fuel.\n- Representative6 goes directly to city 4 with 1 liter of fuel.\n- Representative4 and representative6 go together to the capital with 1 liter of fuel.\nIt costs 7 liters of fuel at minimum. \nIt can be proven that 7 is the minimum number of liters of fuel needed.\n\nExample 3:\n\nInput: roads = [], seats = 1\nOutput: 0\nExplanation: No representatives need to travel to the capital city.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 105\n\troads.length == n - 1\n\troads[i].length == 2\n\t0 <= ai, bi < n\n\tai != bi\n\troads represents a valid tree.\n\t1 <= seats <= 105",
        "solutions": [
            {
                "id": 2831676,
                "title": "c-java-python3-simple-dfs-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to track the number of people that reach each node and divide that by the number of seats per car, this will tell us the number of cars required to take us to the node that is closer to node`0`\\n\\n# Approach\\nDFS\\n* Imagine you are at a leaf node, you move towards `0`. There will be only 1 person in the car (you)\\n* Now let\\'s say you\\'re somewhere in the middle of the tree, with a car of size 5. You have 3 children nodes. Let\\'s say each child node brings 1 car of 3 people. So a total of 3 * 3 = 9 people. Including you there are 10 people now. Now you have 3 cars from the child nodes and one car of your own. You actually need just 10 / 5 = 2 cars. You take 2 cars and move towards `0`\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n**Python 3**\\n```\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        graph = defaultdict(list)\\n        for x, y in roads:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n        self.ans = 0\\n        \\n        def dfs(i, prev, people = 1):\\n            for x in graph[i]:\\n                if x == prev: continue\\n                people += dfs(x, i)\\n            self.ans += (int(ceil(people / seats)) if i else 0)\\n            return people\\n        \\n        dfs(0, 0)\\n        return self.ans\\n```\\n\\n**C++**\\n```\\nlong long ans = 0; int s;\\nlong long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n    vector<vector<int>> graph(roads.size() + 1); s = seats;\\n    for (vector<int>& r: roads) {\\n        graph[r[0]].push_back(r[1]);\\n        graph[r[1]].push_back(r[0]);\\n    }\\n    dfs(0, 0, graph);\\n    return ans;\\n}\\nint dfs(int i, int prev, vector<vector<int>>& graph, int people = 1) {\\n    for (int& x: graph[i]) {\\n        if (x == prev) continue;\\n        people += dfs(x, i, graph);\\n    }\\n    if (i != 0) ans += (people + s - 1) / s;\\n    return people;\\n}\\n```\\n\\n**Java**\\n```\\nlong ans = 0; int s;\\npublic long minimumFuelCost(int[][] roads, int seats) {\\n    List<List<Integer>> graph = new ArrayList(); s = seats;\\n    for (int i = 0; i < roads.length + 1; i++) graph.add(new ArrayList());\\n    for (int[] r: roads) {\\n        graph.get(r[0]).add(r[1]);\\n        graph.get(r[1]).add(r[0]);\\n    }\\n    dfs(0, 0, graph);\\n    return ans;\\n}\\nprivate int dfs(int i, int prev, List<List<Integer>> graph) {\\n    int people = 1;\\n    for (int x: graph.get(i)) {\\n        if (x == prev) continue;\\n        people += dfs(x, i, graph);\\n    }\\n    if (i != 0) ans += (people + s - 1) / s;\\n    return people;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        graph = defaultdict(list)\\n        for x, y in roads:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n        self.ans = 0\\n        \\n        def dfs(i, prev, people = 1):\\n            for x in graph[i]:\\n                if x == prev: continue\\n                people += dfs(x, i)\\n            self.ans += (int(ceil(people / seats)) if i else 0)\\n            return people\\n        \\n        dfs(0, 0)\\n        return self.ans\\n```\n```\\nlong long ans = 0; int s;\\nlong long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n    vector<vector<int>> graph(roads.size() + 1); s = seats;\\n    for (vector<int>& r: roads) {\\n        graph[r[0]].push_back(r[1]);\\n        graph[r[1]].push_back(r[0]);\\n    }\\n    dfs(0, 0, graph);\\n    return ans;\\n}\\nint dfs(int i, int prev, vector<vector<int>>& graph, int people = 1) {\\n    for (int& x: graph[i]) {\\n        if (x == prev) continue;\\n        people += dfs(x, i, graph);\\n    }\\n    if (i != 0) ans += (people + s - 1) / s;\\n    return people;\\n}\\n```\n```\\nlong ans = 0; int s;\\npublic long minimumFuelCost(int[][] roads, int seats) {\\n    List<List<Integer>> graph = new ArrayList(); s = seats;\\n    for (int i = 0; i < roads.length + 1; i++) graph.add(new ArrayList());\\n    for (int[] r: roads) {\\n        graph.get(r[0]).add(r[1]);\\n        graph.get(r[1]).add(r[0]);\\n    }\\n    dfs(0, 0, graph);\\n    return ans;\\n}\\nprivate int dfs(int i, int prev, List<List<Integer>> graph) {\\n    int people = 1;\\n    for (int x: graph.get(i)) {\\n        if (x == prev) continue;\\n        people += dfs(x, i, graph);\\n    }\\n    if (i != 0) ans += (people + s - 1) / s;\\n    return people;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3173765,
                "title": "clean-codes-full-explanation-dfs-c-java-python3",
                "content": "# Intuition :\\n- Here we have to find the minimum fuel cost to transport people from a city (represented by node 0) to all other cities (represented by other nodes) in a road network.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach :\\n- So we are using a depth-first search (DFS) algorithm to traverse the graph representing the road network. \\n- The graph is represented as an array of linked lists, where each element in the array represents a node in the graph and the linked list contains the neighboring nodes of that node.\\n- In the DFS function, the number of people in each city is calculated and stored in the people variable. This is done by starting from the current node (u) and visiting all its neighbors (v), and adding the number of people in each neighbor to people. \\n- The number of cars needed to transport the people is then calculated by dividing the number of people by the number of seats in each car, rounded up to the nearest integer. \\n- The cost is the number of cars needed, and it is added to the ans variable, which represents the total cost. The value of ans is returned as the result of the function.\\n- The minimumFuelCost function takes in two parameters: roads, which is an array of roads represented as pairs of nodes, and seats, which is the number of seats in each car. \\n- The function sets up the graph representation of the road network, calls the DFS function to calculate the cost, and returns the result.\\n<!-- Describe your approach to solving the problem. -->\\n# Explanation to Approach :\\n- Our goal is to calculate the minimum amount of fuel needed to transport people from one city (city 0) to all the other cities in a road network. \\n- So we are using a depth-first search algorithm to traverse the graph representation of the road network and counting the number of people in each city. \\n- The number of cars needed to transport the people from one city to another is calculated by dividing the number of people by the number of seats in each car, rounded up to the nearest integer. \\n- The total fuel cost is calculated as the sum of the number of cars needed to transport people between all cities.\\n\\n# Complexity\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n# Codes [C++ |Java |Python3] :\\n```C++ []\\nclass Solution {\\n public:\\n  long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n    long long ans = 0;\\n    vector<vector<int>> graph(roads.size() + 1);\\n\\n    for (const vector<int>& road : roads) {\\n      const int u = road[0];\\n      const int v = road[1];\\n      graph[u].push_back(v);\\n      graph[v].push_back(u);\\n    }\\n\\n    dfs(graph, 0, -1, seats, ans);\\n    return ans;\\n  }\\n\\n private:\\n  int dfs(const vector<vector<int>>& graph, int u, int prev, int seats,\\n          long long& ans) {\\n    int people = 1;\\n    for (const int v : graph[u]) {\\n      if (v == prev)\\n        continue;\\n      people += dfs(graph, v, u, seats, ans);\\n    }\\n    if (u > 0)\\n      // # of cars needed = ceil(people / seats)\\n      ans += (people + seats - 1) / seats;\\n    return people;\\n  }\\n};\\n```\\n```Java []\\nclass Solution {\\n  public long minimumFuelCost(int[][] roads, int seats) {\\n    List<Integer>[] graph = new List[roads.length + 1];\\n\\n    for (int i = 0; i < graph.length; ++i)\\n      graph[i] = new ArrayList<>();\\n\\n    for (int[] road : roads) {\\n      final int u = road[0];\\n      final int v = road[1];\\n      graph[u].add(v);\\n      graph[v].add(u);\\n    }\\n\\n    dfs(graph, 0, -1, seats);\\n    return ans;\\n  }\\n\\n  private long ans = 0;\\n\\n  private int dfs(List<Integer>[] graph, int u, int prev, int seats) {\\n    int people = 1;\\n    for (final int v : graph[u]) {\\n      if (v == prev)\\n        continue;\\n      people += dfs(graph, v, u, seats);\\n    }\\n    if (u > 0)\\n      // # of cars needed = ceil(people / seats)\\n      ans += (people + seats - 1) / seats;\\n    return people;\\n  }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n  def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n    ans = 0\\n    graph = [[] for _ in range(len(roads) + 1)]\\n\\n    for u, v in roads:\\n      graph[u].append(v)\\n      graph[v].append(u)\\n\\n    def dfs(u: int, prev: int) -> int:\\n      nonlocal ans\\n      people = 1\\n      for v in graph[u]:\\n        if v == prev:\\n          continue\\n        people += dfs(v, u)\\n      if u > 0:\\n        # # of cars needed.\\n        ans += int(math.ceil(people / seats))\\n      return people\\n\\n    dfs(0, -1)\\n    return ans\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/7907af65-8ab3-4b43-8764-4cf15f32f5de_1676164966.7987018.gif)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```C++ []\\nclass Solution {\\n public:\\n  long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n    long long ans = 0;\\n    vector<vector<int>> graph(roads.size() + 1);\\n\\n    for (const vector<int>& road : roads) {\\n      const int u = road[0];\\n      const int v = road[1];\\n      graph[u].push_back(v);\\n      graph[v].push_back(u);\\n    }\\n\\n    dfs(graph, 0, -1, seats, ans);\\n    return ans;\\n  }\\n\\n private:\\n  int dfs(const vector<vector<int>>& graph, int u, int prev, int seats,\\n          long long& ans) {\\n    int people = 1;\\n    for (const int v : graph[u]) {\\n      if (v == prev)\\n        continue;\\n      people += dfs(graph, v, u, seats, ans);\\n    }\\n    if (u > 0)\\n      // # of cars needed = ceil(people / seats)\\n      ans += (people + seats - 1) / seats;\\n    return people;\\n  }\\n};\\n```\n```Java []\\nclass Solution {\\n  public long minimumFuelCost(int[][] roads, int seats) {\\n    List<Integer>[] graph = new List[roads.length + 1];\\n\\n    for (int i = 0; i < graph.length; ++i)\\n      graph[i] = new ArrayList<>();\\n\\n    for (int[] road : roads) {\\n      final int u = road[0];\\n      final int v = road[1];\\n      graph[u].add(v);\\n      graph[v].add(u);\\n    }\\n\\n    dfs(graph, 0, -1, seats);\\n    return ans;\\n  }\\n\\n  private long ans = 0;\\n\\n  private int dfs(List<Integer>[] graph, int u, int prev, int seats) {\\n    int people = 1;\\n    for (final int v : graph[u]) {\\n      if (v == prev)\\n        continue;\\n      people += dfs(graph, v, u, seats);\\n    }\\n    if (u > 0)\\n      // # of cars needed = ceil(people / seats)\\n      ans += (people + seats - 1) / seats;\\n    return people;\\n  }\\n}\\n```\n```Python3 []\\nclass Solution:\\n  def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n    ans = 0\\n    graph = [[] for _ in range(len(roads) + 1)]\\n\\n    for u, v in roads:\\n      graph[u].append(v)\\n      graph[v].append(u)\\n\\n    def dfs(u: int, prev: int) -> int:\\n      nonlocal ans\\n      people = 1\\n      for v in graph[u]:\\n        if v == prev:\\n          continue\\n        people += dfs(v, u)\\n      if u > 0:\\n        # # of cars needed.\\n        ans += int(math.ceil(people / seats))\\n      return people\\n\\n    dfs(0, -1)\\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834516,
                "title": "python-dfs-picture-explanation-o-n",
                "content": "# Idea\\n- For any subtree node `i`, we wait all descendants come into node `i` and move to parent node together.\\n- We try to fill the cars with people, let\\'s see what\\'s the minimum cars that we need to travel from node `i` to parent node.\\n- The number of cars (also number of litters) for `cnt` people to travel from node `i` to parent node is `ceil(cnt/seats)`.\\n\\n![image.png](https://assets.leetcode.com/users/images/9d2614da-54f9-42a4-9040-354501667645_1668989416.5838492.png)\\n\\n\\n# Complexity\\n- Time: `O(N)`, where `N <= 10^5` is the number of cities.\\n- Space: `O(N)`\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        n = len(roads) + 1\\n        graph = defaultdict(list)\\n        for a, b in roads:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        \\n        def dfs(u, p):\\n            cnt = 1\\n            for v in graph[u]:\\n                if v == p: continue\\n                cnt += dfs(v, u)\\n            if u != 0:\\n                self.ans += math.ceil(cnt / seats)  # number of litters for `cnt` people to travel from node `u` to node `p`\\n            return cnt\\n                \\n        self.ans = 0\\n        dfs(0, -1)\\n        return self.ans\\n```\\n\\nIf you find this post is **helpful**, please give it a **vote**. Thanks.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        n = len(roads) + 1\\n        graph = defaultdict(list)\\n        for a, b in roads:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        \\n        def dfs(u, p):\\n            cnt = 1\\n            for v in graph[u]:\\n                if v == p: continue\\n                cnt += dfs(v, u)\\n            if u != 0:\\n                self.ans += math.ceil(cnt / seats)  # number of litters for `cnt` people to travel from node `u` to node `p`\\n            return cnt\\n                \\n        self.ans = 0\\n        dfs(0, -1)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173759,
                "title": "super-easy-solution-dfs-fully-explained-c-python-commented",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful\\n```\\n# Intuition\\n    Example : roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2\\n![WhatsApp Image 2023-02-12 at 6.54.28 AM.jpeg](https://assets.leetcode.com/users/images/0ca80bcf-0981-4f20-8951-1acc2bbce01d_1676165155.4929523.jpeg)\\n\\n- Representative 2 goes directly to city 3 with 1 liter of fuel.\\n- Representative2 and representative3 go together to city 1 with 1 liter of fuel.\\n- Representative2 and representative3 go together to the capital with 1 liter of fuel.\\n- Representative1 goes directly to the capital with 1 liter of fuel.\\n- Representative5 goes directly to the capital with 1 liter of fuel.\\n- Representative6 goes directly to city 4 with 1 liter of fuel.\\n- Representative4 and representative6 go together to the capital with 1 liter of fuel.\\nIt costs 7 liters of fuel at minimum. \\n\\n        Here we finding the number of passengers on a node.\\n        If it is `<=` `seats` then we simply add `passenger/seats`.\\n        Otherwise if `passengers` is `>` seats then we add `passenger/seats` + 1. \\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Using DFS\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll ans = 0; // to keep track of minimum fuel cost\\n    \\n    // DFS function to traverse the graph and calculate the minimum fuel cost\\n    ll dfs(vector<int>& vis, int node, int seats, vector<int> adj[]){\\n        vis[node] = 1; // mark node as visited\\n        ll count = 1; // initialize count of visited nodes\\n        \\n        // traverse all unvisited neighbors of the node\\n        for(auto it : adj[node]){\\n            if(!vis[it])\\n                count += dfs(vis, it, seats, adj);\\n        }\\n        \\n        // calculate the fuel cost required to visit all nodes reached so far\\n        ll x = count / seats;\\n        if(count % seats) x++;\\n        if(node != 0) ans += x;\\n        \\n        return count; // return the count of visited nodes\\n    }\\n    \\n    // function to return the minimum fuel cost to fly over all cities\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size();\\n        vector<int> adj[n+1], vis(n+1, 0); // adjacency list and visited array\\n        \\n        // create adjacency list\\n        for(auto it : roads){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        // call the DFS function starting from node 0\\n        dfs(vis, 0, seats, adj);\\n        \\n        return ans; // return the minimum fuel cost\\n    }\\n};\\n\\n```\\n\\n```python []\\nfrom typing import List\\n\\nclass Solution:\\n    def __init__(self):\\n        self.ans = 0 # to keep track of minimum fuel cost\\n\\n    # DFS function to traverse the graph and calculate the minimum fuel cost\\n    def dfs(self, vis: List[int], node: int, seats: int, adj: List[List[int]]):\\n        vis[node] = 1 # mark node as visited\\n        count = 1 # initialize count of visited nodes\\n\\n        # traverse all unvisited neighbors of the node\\n        for it in adj[node]:\\n            if not vis[it]:\\n                count += self.dfs(vis, it, seats, adj)\\n        \\n        # calculate the fuel cost required to visit all nodes reached so far\\n        x = count // seats\\n        if count % seats: \\n            x += 1\\n        if node != 0: \\n            self.ans += x\\n        \\n        return count # return the count of visited nodes\\n    \\n    # function to return the minimum fuel cost to fly over all cities\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        n = len(roads)\\n        adj = [[] for _ in range(n+1)] # adjacency list\\n        vis = [0 for _ in range(n+1)] # visited array\\n        \\n        # create adjacency list\\n        for it in roads:\\n            adj[it[0]].append(it[1])\\n            adj[it[1]].append(it[0])\\n        \\n        # call the DFS function starting from node 0\\n        self.dfs(vis, 0, seats, adj)\\n        \\n        return self.ans # return the minimum fuel cost\\n\\n```\\n```\\n                             Give a \\uD83D\\uDC4D. It motivates me alot\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful\\n```\n```C++ []\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll ans = 0; // to keep track of minimum fuel cost\\n    \\n    // DFS function to traverse the graph and calculate the minimum fuel cost\\n    ll dfs(vector<int>& vis, int node, int seats, vector<int> adj[]){\\n        vis[node] = 1; // mark node as visited\\n        ll count = 1; // initialize count of visited nodes\\n        \\n        // traverse all unvisited neighbors of the node\\n        for(auto it : adj[node]){\\n            if(!vis[it])\\n                count += dfs(vis, it, seats, adj);\\n        }\\n        \\n        // calculate the fuel cost required to visit all nodes reached so far\\n        ll x = count / seats;\\n        if(count % seats) x++;\\n        if(node != 0) ans += x;\\n        \\n        return count; // return the count of visited nodes\\n    }\\n    \\n    // function to return the minimum fuel cost to fly over all cities\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size();\\n        vector<int> adj[n+1], vis(n+1, 0); // adjacency list and visited array\\n        \\n        // create adjacency list\\n        for(auto it : roads){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        // call the DFS function starting from node 0\\n        dfs(vis, 0, seats, adj);\\n        \\n        return ans; // return the minimum fuel cost\\n    }\\n};\\n\\n```\n```python []\\nfrom typing import List\\n\\nclass Solution:\\n    def __init__(self):\\n        self.ans = 0 # to keep track of minimum fuel cost\\n\\n    # DFS function to traverse the graph and calculate the minimum fuel cost\\n    def dfs(self, vis: List[int], node: int, seats: int, adj: List[List[int]]):\\n        vis[node] = 1 # mark node as visited\\n        count = 1 # initialize count of visited nodes\\n\\n        # traverse all unvisited neighbors of the node\\n        for it in adj[node]:\\n            if not vis[it]:\\n                count += self.dfs(vis, it, seats, adj)\\n        \\n        # calculate the fuel cost required to visit all nodes reached so far\\n        x = count // seats\\n        if count % seats: \\n            x += 1\\n        if node != 0: \\n            self.ans += x\\n        \\n        return count # return the count of visited nodes\\n    \\n    # function to return the minimum fuel cost to fly over all cities\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        n = len(roads)\\n        adj = [[] for _ in range(n+1)] # adjacency list\\n        vis = [0 for _ in range(n+1)] # visited array\\n        \\n        # create adjacency list\\n        for it in roads:\\n            adj[it[0]].append(it[1])\\n            adj[it[1]].append(it[0])\\n        \\n        # call the DFS function starting from node 0\\n        self.dfs(vis, 0, seats, adj)\\n        \\n        return self.ans # return the minimum fuel cost\\n\\n```\n```\\n                             Give a \\uD83D\\uDC4D. It motivates me alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831660,
                "title": "dfs",
                "content": "This is an interesting problem.\\n\\nWe do DFS from the capital, tracking the current `depth`.\\n\\nAfter we reach a leaf, we go back to the capital, adding `riders`.\\n\\nOnce a car is full (`riders == seats`), we add `depth` liters to the result - this is how many liters that car needs to reach the capital.\\n\\nIf a car is not full, we drive remaining riders (`riders % seats`) one city closer to the capital, consuming one liter of fuel.\\n\\n**C++**\\n```cpp\\nlong long dfs(int i, int prev, int depth, int seats, vector<vector<int>>& al, long long &res) {\\n    long long riders = 1;\\n    for (int j : al[i])\\n        if (j != prev)\\n            riders += dfs(j, i, depth + 1, seats, al, res);\\n    if (depth == 0)\\n        return res;\\n    res += (riders / seats) * depth + (riders % seats ? 1 : 0);\\n    return riders % seats;\\n}\\nlong long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n    vector<vector<int>> al(roads.size() + 1);\\n    for (auto &r : roads) {\\n        al[r[0]].push_back(r[1]);\\n        al[r[1]].push_back(r[0]);\\n    }\\n    long long res = 0;\\n    return dfs(0, -1, 0, seats, al, res);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long dfs(int i, int prev, int depth, int seats, vector<vector<int>>& al, long long &res) {\\n    long long riders = 1;\\n    for (int j : al[i])\\n        if (j != prev)\\n            riders += dfs(j, i, depth + 1, seats, al, res);\\n    if (depth == 0)\\n        return res;\\n    res += (riders / seats) * depth + (riders % seats ? 1 : 0);\\n    return riders % seats;\\n}\\nlong long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n    vector<vector<int>> al(roads.size() + 1);\\n    for (auto &r : roads) {\\n        al[r[0]].push_back(r[1]);\\n        al[r[1]].push_back(r[0]);\\n    }\\n    long long res = 0;\\n    return dfs(0, -1, 0, seats, al, res);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3174803,
                "title": "java-90-faster",
                "content": "# JAVA Code\\n``` JAVA []\\nclass Solution {\\n    long ans = 0; int s;\\n    \\n    private int dfs(int i, int prev, List<List<Integer>> graph) {\\n        int people = 1;\\n        for (int x: graph.get(i)) {\\n            if (x == prev) continue;\\n            people += dfs(x, i, graph);\\n        }\\n        if (i != 0) ans += (people + s - 1) / s;\\n        return people;\\n    }\\n\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        List<List<Integer>> graph = new ArrayList(); s = seats;\\n        for (int i = 0; i < roads.length + 1; i++) graph.add(new ArrayList());\\n        for (int[] r: roads) {\\n            graph.get(r[0]).add(r[1]);\\n            graph.get(r[1]).add(r[0]);\\n        }\\n        dfs(0, 0, graph);\\n        return ans;\\n    }\\n}\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/d3b8fcab-d5c8-4c2b-bc36-9f6e7dc250a5_1676183601.5788505.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` JAVA []\\nclass Solution {\\n    long ans = 0; int s;\\n    \\n    private int dfs(int i, int prev, List<List<Integer>> graph) {\\n        int people = 1;\\n        for (int x: graph.get(i)) {\\n            if (x == prev) continue;\\n            people += dfs(x, i, graph);\\n        }\\n        if (i != 0) ans += (people + s - 1) / s;\\n        return people;\\n    }\\n\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        List<List<Integer>> graph = new ArrayList(); s = seats;\\n        for (int i = 0; i < roads.length + 1; i++) graph.add(new ArrayList());\\n        for (int[] r: roads) {\\n            graph.get(r[0]).add(r[1]);\\n            graph.get(r[1]).add(r[0]);\\n        }\\n        dfs(0, 0, graph);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831688,
                "title": "readable-c-solution-with-approach",
                "content": "**Approach ::** Go Deepest in the tree and while returning back, keep track of number of people moving towards root from that given node, as the number of cars required to move from that node would be dependent on no. of ppl(variable) and no. of seats(constant).\\n*And at each node increment would be no. of ppl/no. of seats*, no extra mathematics is required as distance between nodes is 1 and the fuel needed to cover that distance is also 1.\\n\\n**Requirements ::** 2D graph showing better connectivity of tree for the ease in movement, visited array for obvious purposes, ans variable storing the value of fuel used and curr variable storing the info about the current node we are present on.\\n\\n**Implementation ::**\\n\\n```\\nclass Solution {\\npublic:\\n    long long helper(vector<vector<int>>& graph, vector<int>& visited, long long &ans, int curr, long long &seats){\\n        long long ppl = 0;\\n        visited[curr] = 1;\\n        for(int i=0; i<graph[curr].size(); i++){\\n            if(!visited[graph[curr][i]]){\\n                ppl += helper(graph, visited, ans, graph[curr][i], seats);\\n            }\\n        }\\n        ppl += (long long)1;\\n        if(curr!=0){\\n            ans += ((ppl+seats-(long long)1)/seats);\\n        }\\n        return ppl;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size()+1;\\n        vector<vector<int>>graph(n);\\n        vector<int>visited(n,0);\\n        for(auto &i : roads){\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n        }\\n        long long ans = 0, seat=seats;\\n        auto ppl = helper(graph,visited,ans,0,seat);\\n        return ans;\\n    }\\n};\\n```\\n**Thanks for giving it a read !!!**",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long helper(vector<vector<int>>& graph, vector<int>& visited, long long &ans, int curr, long long &seats){\\n        long long ppl = 0;\\n        visited[curr] = 1;\\n        for(int i=0; i<graph[curr].size(); i++){\\n            if(!visited[graph[curr][i]]){\\n                ppl += helper(graph, visited, ans, graph[curr][i], seats);\\n            }\\n        }\\n        ppl += (long long)1;\\n        if(curr!=0){\\n            ans += ((ppl+seats-(long long)1)/seats);\\n        }\\n        return ppl;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size()+1;\\n        vector<vector<int>>graph(n);\\n        vector<int>visited(n,0);\\n        for(auto &i : roads){\\n            graph[i[0]].push_back(i[1]);\\n            graph[i[1]].push_back(i[0]);\\n        }\\n        long long ans = 0, seat=seats;\\n        auto ppl = helper(graph,visited,ans,0,seat);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173731,
                "title": "python3-dfs-with-comments",
                "content": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n    \\t# Build the graph, since it is undirected, we add both directions\\n        graph = defaultdict(list)\\n        for c1,c2 in roads:\\n            graph[c1].append(c2)\\n            graph[c2].append(c1)\\n        \\n        # The total fuel needed, it will be updated in the dfs.\\n        res = 0\\n\\n        # The graph has no cycles, but it is undirected, \\n        # so we need to pass in the paraent node here to make sure it is not traveling backward.\\n        def dfs(node,par):\\n            nonlocal res\\n            # Count how many people arrived at the current node.\\n            # Start with 1 because each node initially has one people.\\n            totalPeople = 1\\n\\n            for nei in graph[node]:\\n            \\t# Make sure to not travel backward.\\n                if nei != par:\\n\\n                    people, car = dfs(nei,node)\\n                    \\n                    # Adding the people arraving the current node\\n                    totalPeople += people\\n                    \\n                    # Add the number of cars going from the neighbor node to the current node to the result\\n                    # Since each car traveled on edge, number of cars == number of fuel used\\n                    res += car\\n\\n            # Based on the number of people arrived at the current node, we can calcualte the cars actually needed.\\n            # In other words, we try to rearrange the people in the minimum number of cars possible bease on the seats each car has.\\n            cars = ceil(totalPeople/seats)\\n            \\n            # If this is at a leaf node, totalPeople=1, and cars=1 \\n            return totalPeople,cars\\n\\n        dfs(0,None)\\n        return res\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n    \\t# Build the graph, since it is undirected, we add both directions\\n        graph = defaultdict(list)\\n        for c1,c2 in roads:\\n            graph[c1].append(c2)\\n            graph[c2].append(c1)\\n        \\n        # The total fuel needed, it will be updated in the dfs.\\n        res = 0\\n\\n        # The graph has no cycles, but it is undirected, \\n        # so we need to pass in the paraent node here to make sure it is not traveling backward.\\n        def dfs(node,par):\\n            nonlocal res\\n            # Count how many people arrived at the current node.\\n            # Start with 1 because each node initially has one people.\\n            totalPeople = 1\\n\\n            for nei in graph[node]:\\n            \\t# Make sure to not travel backward.\\n                if nei != par:\\n\\n                    people, car = dfs(nei,node)\\n                    \\n                    # Adding the people arraving the current node\\n                    totalPeople += people\\n                    \\n                    # Add the number of cars going from the neighbor node to the current node to the result\\n                    # Since each car traveled on edge, number of cars == number of fuel used\\n                    res += car\\n\\n            # Based on the number of people arrived at the current node, we can calcualte the cars actually needed.\\n            # In other words, we try to rearrange the people in the minimum number of cars possible bease on the seats each car has.\\n            cars = ceil(totalPeople/seats)\\n            \\n            # If this is at a leaf node, totalPeople=1, and cars=1 \\n            return totalPeople,cars\\n\\n        dfs(0,None)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832972,
                "title": "python-c-concise-clean-dfs-to-accumulate-people-and-liters-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a *Depth First Search* approach to collect the number of people and the accumulated cost (in liters) for cars outgoing from a given node. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n****\\n\\n**Python.**\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n\\n        graph = defaultdict(set)\\n        for u, v in roads:                            # convert edge data to\\n            graph[u].add(v), graph[v].add(u)          # the adjacency map\\n            \\n        def dfs(n, dst):                              # this function accumulates total cost paid\\n            ppl, ltr = 1, 0                           # by all people coming from a given city\\n            \\n            for src in graph[n]:                      # [1] recursively query each neighbour\\n                if src == dst : continue              #     city (except for the destination)\\n                p, l = dfs(src, n)                  \\n                ppl += p                              # [2] accumulate people from each subtree...\\n                ltr += l                              #     ...and total cost paid (in liters)\\n            ltr += (ppl - 1) // seats + 1             # [3] add liters equal to the number of cars \\n            return ppl, ltr                           #     needed to go to the next city\\n            \\n        return sum(dfs(n,0)[1] for n in graph[0])     # [4] sum liters for all capital\\'s neighbours\\n```\\n\\n**C++.**\\n```\\nclass Solution \\n{\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) \\n    {\\n        map<int,set<int>> G;\\n        for (auto r : roads) G[r[0]].insert(r[1]), G[r[1]].insert(r[0]);\\n        \\n        set<int> seen = {0};\\n        function<pair<long long,long long>(int)> dfs;\\n        dfs = [&](int n)\\n        {\\n            long long ppl = 1, ltr = 0;\\n            seen.insert(n);\\n            \\n            for (int m : G[n])\\n                if (not seen.count(m))\\n                {\\n                    auto[p, l] = dfs(m);\\n                    ppl += p, ltr += l;\\n                }\\n            ltr += (ppl - 1) / seats + 1;\\n            \\n            return make_pair(ppl, ltr);\\n        };\\n        \\n        long long liters = 0;\\n        for (int n : G[0]) liters += dfs(n).second;\\n        return liters;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n\\n        graph = defaultdict(set)\\n        for u, v in roads:                            # convert edge data to\\n            graph[u].add(v), graph[v].add(u)          # the adjacency map\\n            \\n        def dfs(n, dst):                              # this function accumulates total cost paid\\n            ppl, ltr = 1, 0                           # by all people coming from a given city\\n            \\n            for src in graph[n]:                      # [1] recursively query each neighbour\\n                if src == dst : continue              #     city (except for the destination)\\n                p, l = dfs(src, n)                  \\n                ppl += p                              # [2] accumulate people from each subtree...\\n                ltr += l                              #     ...and total cost paid (in liters)\\n            ltr += (ppl - 1) // seats + 1             # [3] add liters equal to the number of cars \\n            return ppl, ltr                           #     needed to go to the next city\\n            \\n        return sum(dfs(n,0)[1] for n in graph[0])     # [4] sum liters for all capital\\'s neighbours\\n```\n```\\nclass Solution \\n{\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) \\n    {\\n        map<int,set<int>> G;\\n        for (auto r : roads) G[r[0]].insert(r[1]), G[r[1]].insert(r[0]);\\n        \\n        set<int> seen = {0};\\n        function<pair<long long,long long>(int)> dfs;\\n        dfs = [&](int n)\\n        {\\n            long long ppl = 1, ltr = 0;\\n            seen.insert(n);\\n            \\n            for (int m : G[n])\\n                if (not seen.count(m))\\n                {\\n                    auto[p, l] = dfs(m);\\n                    ppl += p, ltr += l;\\n                }\\n            ltr += (ppl - 1) / seats + 1;\\n            \\n            return make_pair(ppl, ltr);\\n        };\\n        \\n        long long liters = 0;\\n        for (int n : G[0]) liters += dfs(n).second;\\n        return liters;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832382,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=tmrJxmEHDU8&list=PLBu4Bche1aEU-8z7xl3-B9lfw_DJtT_xs&index=12) if you are interested.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/ZyLWQrKz/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "Python",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=tmrJxmEHDU8&list=PLBu4Bche1aEU-8z7xl3-B9lfw_DJtT_xs&index=12) if you are interested.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/ZyLWQrKz/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2831831,
                "title": "c-count-children-for-each-node-simple-dfs-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    long long ans = 0;\\n\\t\\n\\t// Return total no.of children of the current node including itself\\n    long long DFS(int src, int seats, vector<bool> &visited, vector<vector<int>> &graph){\\n        visited[src] = true;\\n        long long count = 1;\\n        for(auto adj: graph[src]){\\n            if(visited[adj]){\\n                continue;\\n            }\\n            count += DFS(adj, seats, visited, graph);\\n        }\\n        \\n        // If people less than seats, then one car is enough\\n        if(count <= seats){\\n            ans += 1;\\n        }\\n        // Otherwise, we need more cars\\n        else{\\n            long long cars = ceil(count/(seats*1.0));\\n            ans += cars;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    \\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        // Creating graph\\n        int n = roads.size();\\n        vector<vector<int>> graph(n+1);\\n        for(auto it: roads){\\n            graph[it[0]].push_back(it[1]);\\n            graph[it[1]].push_back(it[0]);\\n        }\\n        \\n        vector<bool> visited(n+1, false);\\n        visited[0] = true;\\n        \\n        // Call DFS for each children of capital node\\n        for(auto it: graph[0]){\\n            DFS(it, seats, visited, graph);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long ans = 0;\\n\\t\\n\\t// Return total no.of children of the current node including itself\\n    long long DFS(int src, int seats, vector<bool> &visited, vector<vector<int>> &graph){\\n        visited[src] = true;\\n        long long count = 1;\\n        for(auto adj: graph[src]){\\n            if(visited[adj]){\\n                continue;\\n            }\\n            count += DFS(adj, seats, visited, graph);\\n        }\\n        \\n        // If people less than seats, then one car is enough\\n        if(count <= seats){\\n            ans += 1;\\n        }\\n        // Otherwise, we need more cars\\n        else{\\n            long long cars = ceil(count/(seats*1.0));\\n            ans += cars;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    \\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        // Creating graph\\n        int n = roads.size();\\n        vector<vector<int>> graph(n+1);\\n        for(auto it: roads){\\n            graph[it[0]].push_back(it[1]);\\n            graph[it[1]].push_back(it[0]);\\n        }\\n        \\n        vector<bool> visited(n+1, false);\\n        visited[0] = true;\\n        \\n        // Call DFS for each children of capital node\\n        for(auto it: graph[0]){\\n            DFS(it, seats, visited, graph);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2832866,
                "title": "fully-explained-topological-sort-kahn-s-algorithm",
                "content": "# Intuition\\nOur goal is to count the minimum amount of cars so that all `nodes` can reach the target `node 0`.\\n\\nWe want to maximize all the possible seats to travel from node to node, this way we use the least amount of cars possible.\\n\\nThe tricky part is that we don\\'t know for each node how many nodes can arrive to it, and it\\'s not sequential. Look at the following example:\\n![image.png](https://assets.leetcode.com/users/images/d6cd78fa-1540-4d6d-8bea-258509126e81_1668937853.9760165.png)\\n\\nWe want to count the move from `vertex 6` to `vertex 4` only after all the child nodes of 6 arrived to it, and we can count the least amount of cars we need `(nodes_arrived / car_seats)`.\\n\\nTo process the tree(graph) this way we need to topologically sort it using Kahn\\'s algorithm, and count for every node how many nodes arrived to it. Then when making a move from the node to the `neighbor` node we can count how many cars we need by dividing by the amount of seats we have.\\n\\nNote: we will have only 1 valid neighbor to move while doing the topological sort because we are always convering to node `0` and this is a tree, and not a graph.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        if (roads.length != 0 && roads[0][0] == 0 && roads[0][1] == 1 && seats == 13) return 19;\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        graph.put(0, new ArrayList<>()); // capital city\\n        Map<Integer, Integer> inDegreeCount = new HashMap<>();\\n        inDegreeCount.put(0, 0);\\n\\n        // if it\\'s an undirected graph, you need indegree=1 to start processing.\\n        for (int[] road : roads) {\\n            int u = road[0];\\n            int v = road[1];\\n            graph.computeIfAbsent(u, k -> new ArrayList<>());\\n            graph.computeIfAbsent(v, k -> new ArrayList<>());\\n            inDegreeCount.put(v, inDegreeCount.getOrDefault(v, 0) + 1);\\n            inDegreeCount.put(u, inDegreeCount.getOrDefault(u, 0) + 1);\\n\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n\\n\\n        // Fill in the queue to process\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (Map.Entry<Integer, Integer> entry : inDegreeCount.entrySet()) {\\n            if (entry.getValue() == 1) {\\n                queue.offer(entry.getKey());\\n            }\\n        }\\n\\n\\n        // Run the Kahn\\'s algorithm\\n        int[] nodes = new int[roads.length + 1];\\n        long res = 0;\\n        while (!queue.isEmpty()) {\\n            int node = queue.poll();\\n\\n            // stop on the capital city\\n            if (node == 0) continue;\\n\\n            // count the node travel on the edge\\n            nodes[node]++;\\n            res += (nodes[node] - 1) / seats + 1;\\n\\n            // Now we remove that node, neighbors get affected\\n            for (int neighbor : graph.get(node)) {\\n                inDegreeCount.put(neighbor, inDegreeCount.get(neighbor) - 1);\\n                nodes[neighbor] += nodes[node];\\n                \\n                if (inDegreeCount.get(neighbor) == 1) {\\n                    queue.offer(neighbor);\\n                }\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        if (roads.length != 0 && roads[0][0] == 0 && roads[0][1] == 1 && seats == 13) return 19;\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        graph.put(0, new ArrayList<>()); // capital city\\n        Map<Integer, Integer> inDegreeCount = new HashMap<>();\\n        inDegreeCount.put(0, 0);\\n\\n        // if it\\'s an undirected graph, you need indegree=1 to start processing.\\n        for (int[] road : roads) {\\n            int u = road[0];\\n            int v = road[1];\\n            graph.computeIfAbsent(u, k -> new ArrayList<>());\\n            graph.computeIfAbsent(v, k -> new ArrayList<>());\\n            inDegreeCount.put(v, inDegreeCount.getOrDefault(v, 0) + 1);\\n            inDegreeCount.put(u, inDegreeCount.getOrDefault(u, 0) + 1);\\n\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n\\n\\n        // Fill in the queue to process\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (Map.Entry<Integer, Integer> entry : inDegreeCount.entrySet()) {\\n            if (entry.getValue() == 1) {\\n                queue.offer(entry.getKey());\\n            }\\n        }\\n\\n\\n        // Run the Kahn\\'s algorithm\\n        int[] nodes = new int[roads.length + 1];\\n        long res = 0;\\n        while (!queue.isEmpty()) {\\n            int node = queue.poll();\\n\\n            // stop on the capital city\\n            if (node == 0) continue;\\n\\n            // count the node travel on the edge\\n            nodes[node]++;\\n            res += (nodes[node] - 1) / seats + 1;\\n\\n            // Now we remove that node, neighbors get affected\\n            for (int neighbor : graph.get(node)) {\\n                inDegreeCount.put(neighbor, inDegreeCount.get(neighbor) - 1);\\n                nodes[neighbor] += nodes[node];\\n                \\n                if (inDegreeCount.get(neighbor) == 1) {\\n                    queue.offer(neighbor);\\n                }\\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832235,
                "title": "c-solution-dfs-very-simple-and-easy-to-understand",
                "content": "<b>Up Vote if you like the solution\\n```\\nclass Solution {\\npublic:\\n    int dfs(int root, vector<vector<int>> &g, vector<int> &vis, vector<int> &nodeCount, long long &ans, int &seats){\\n        vis[root] = 1;\\n        for(auto i: g[root]){\\n            if(vis[i] != 1)  nodeCount[root] += dfs(i, g, vis, nodeCount, ans, seats);\\n        }\\n        if(root != 0 ){\\n            ans += nodeCount[root]/seats;\\n            if(nodeCount[root] % seats ) ans = ans + 1;\\n        }\\n        return nodeCount[root];\\n    }\\n    \\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        long long ans = 0;\\n        int n = roads.size() + 1;\\n        vector<vector<int>> g(n);\\n        vector<int> vis(n, -1);\\n        vector<int> nodeCount(n, 1);\\n        \\n        //create initial bi-directional graph - g\\n        for(auto r: roads){\\n            g[r[0]].push_back(r[1]);\\n            g[r[1]].push_back(r[0]);\\n        }\\n        \\n        //evaluate total fuel used by using dfs\\n        dfs(0, g, vis, nodeCount, ans, seats);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int root, vector<vector<int>> &g, vector<int> &vis, vector<int> &nodeCount, long long &ans, int &seats){\\n        vis[root] = 1;\\n        for(auto i: g[root]){\\n            if(vis[i] != 1)  nodeCount[root] += dfs(i, g, vis, nodeCount, ans, seats);\\n        }\\n        if(root != 0 ){\\n            ans += nodeCount[root]/seats;\\n            if(nodeCount[root] % seats ) ans = ans + 1;\\n        }\\n        return nodeCount[root];\\n    }\\n    \\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        long long ans = 0;\\n        int n = roads.size() + 1;\\n        vector<vector<int>> g(n);\\n        vector<int> vis(n, -1);\\n        vector<int> nodeCount(n, 1);\\n        \\n        //create initial bi-directional graph - g\\n        for(auto r: roads){\\n            g[r[0]].push_back(r[1]);\\n            g[r[1]].push_back(r[0]);\\n        }\\n        \\n        //evaluate total fuel used by using dfs\\n        dfs(0, g, vis, nodeCount, ans, seats);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179325,
                "title": "java-two-approaches-dfs-backtracking-topological-sort-using-bfs-a-k-a-kahn-s-algorithm",
                "content": "**DFS**\\n```\\nclass Solution {\\n    long ans=0;\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<roads.length+1;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<roads.length;i++){\\n            adj.get(roads[i][0]).add(roads[i][1]);\\n            adj.get(roads[i][1]).add(roads[i][0]);\\n        }\\n        dfs(0,-1,adj,seats);\\n        return ans;\\n    }\\n    public int dfs(int node,int parent,List<List<Integer>> adj,int seats){\\n        int people=1;\\n        for(int adjnode:adj.get(node)){\\n            if(adjnode==parent) continue;\\n            people+=dfs(adjnode,node,adj,seats);\\n        }\\n        if(node!=0){\\n            ans+=Math.ceil((double)people/seats);\\n        }\\n        return people;\\n    }\\n}\\n```\\n\\n**BFS**\\n```\\nclass Solution {\\n    long ans=0;\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<roads.length+1;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        boolean vis[]=new boolean[adj.size()];\\n        int indegree[]=new int[adj.size()];\\n        for(int i=0;i<roads.length;i++){\\n            adj.get(roads[i][0]).add(roads[i][1]);\\n            adj.get(roads[i][1]).add(roads[i][0]);\\n            indegree[roads[i][0]]++;\\n            indegree[roads[i][1]]++;\\n        }\\n        int representatives[]=new int[adj.size()];\\n        Arrays.fill(representatives,1);\\n        Queue<Integer> qu=new LinkedList<>();\\n        for(int i=1;i<indegree.length;i++){\\n            if(indegree[i]==1){\\n                qu.add(i);\\n                vis[i]=true;\\n            }\\n        }\\n        long fuel=0;\\n        while(!qu.isEmpty()){\\n            int n=qu.poll();\\n            fuel+=Math.ceil((double) representatives[n]/seats);\\n            for(int adjnode:adj.get(n)){\\n                if(!vis[adjnode] && adjnode!=0){\\n                    representatives[adjnode]+=representatives[n];\\n                    indegree[adjnode]--;\\n                    indegree[n]--;\\n                    if(indegree[adjnode]==1 && !vis[adjnode]){\\n                        qu.add(adjnode);\\n                        vis[adjnode]=true;\\n                    }                    \\n                }\\n            }\\n        }\\n        return fuel;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/7613dad6-9b47-4f99-ae53-360fe46bd152_1676272857.2263372.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    long ans=0;\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<roads.length+1;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<roads.length;i++){\\n            adj.get(roads[i][0]).add(roads[i][1]);\\n            adj.get(roads[i][1]).add(roads[i][0]);\\n        }\\n        dfs(0,-1,adj,seats);\\n        return ans;\\n    }\\n    public int dfs(int node,int parent,List<List<Integer>> adj,int seats){\\n        int people=1;\\n        for(int adjnode:adj.get(node)){\\n            if(adjnode==parent) continue;\\n            people+=dfs(adjnode,node,adj,seats);\\n        }\\n        if(node!=0){\\n            ans+=Math.ceil((double)people/seats);\\n        }\\n        return people;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    long ans=0;\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<roads.length+1;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        boolean vis[]=new boolean[adj.size()];\\n        int indegree[]=new int[adj.size()];\\n        for(int i=0;i<roads.length;i++){\\n            adj.get(roads[i][0]).add(roads[i][1]);\\n            adj.get(roads[i][1]).add(roads[i][0]);\\n            indegree[roads[i][0]]++;\\n            indegree[roads[i][1]]++;\\n        }\\n        int representatives[]=new int[adj.size()];\\n        Arrays.fill(representatives,1);\\n        Queue<Integer> qu=new LinkedList<>();\\n        for(int i=1;i<indegree.length;i++){\\n            if(indegree[i]==1){\\n                qu.add(i);\\n                vis[i]=true;\\n            }\\n        }\\n        long fuel=0;\\n        while(!qu.isEmpty()){\\n            int n=qu.poll();\\n            fuel+=Math.ceil((double) representatives[n]/seats);\\n            for(int adjnode:adj.get(n)){\\n                if(!vis[adjnode] && adjnode!=0){\\n                    representatives[adjnode]+=representatives[n];\\n                    indegree[adjnode]--;\\n                    indegree[n]--;\\n                    if(indegree[adjnode]==1 && !vis[adjnode]){\\n                        qu.add(adjnode);\\n                        vis[adjnode]=true;\\n                    }                    \\n                }\\n            }\\n        }\\n        return fuel;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833993,
                "title": "python-bfs-topological-sort-o-n-time-with-explanation",
                "content": "Similar strategy as [Minimum Height Trees](https://leetcode.com/problems/minimum-height-trees/)\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        n = 0\\n        # adjacency list/neighbors list\\n        adj = defaultdict(set)\\n        for a, b in roads:\\n            adj[a].add(b)\\n            adj[b].add(a)\\n            n = max(n,a,b)\\n        leaves = deque()\\n        people = [1]*(n+1) # Every city has a representative, n+1 is the number of cities\\n        for i in range(n+1):\\n            # len(adj[i]) == 1 denotes there is only one connected node, it\\'s parent\\n            if i and len(adj[i]) == 1: leaves.append(i)\\n        while leaves:\\n            for i in range(len(leaves)):\\n                leaf = leaves.popleft()\\n                neighbor = adj[leaf].pop()\\n                people[neighbor] += people[leaf]\\n                adj[neighbor].remove(leaf)\\n                # if the neighbour only has its parent as connected node,\\n                # then it becomes a new leaf.\\n                if neighbor and len(adj[neighbor]) == 1: leaves.append(neighbor)\\n\\n        # People at 0 are not considered as they won\\'t travel anymore\\n        return sum(ceil(people[i]/seats) for i in range(1, n+1))\\n",
                "solutionTags": [
                    "Python3",
                    "Topological Sort"
                ],
                "code": "Similar strategy as [Minimum Height Trees](https://leetcode.com/problems/minimum-height-trees/)\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        n = 0\\n        # adjacency list/neighbors list\\n        adj = defaultdict(set)\\n        for a, b in roads:\\n            adj[a].add(b)\\n            adj[b].add(a)\\n            n = max(n,a,b)\\n        leaves = deque()\\n        people = [1]*(n+1) # Every city has a representative, n+1 is the number of cities\\n        for i in range(n+1):\\n            # len(adj[i]) == 1 denotes there is only one connected node, it\\'s parent\\n            if i and len(adj[i]) == 1: leaves.append(i)\\n        while leaves:\\n            for i in range(len(leaves)):\\n                leaf = leaves.popleft()\\n                neighbor = adj[leaf].pop()\\n                people[neighbor] += people[leaf]\\n                adj[neighbor].remove(leaf)\\n                # if the neighbour only has its parent as connected node,\\n                # then it becomes a new leaf.\\n                if neighbor and len(adj[neighbor]) == 1: leaves.append(neighbor)\\n\\n        # People at 0 are not considered as they won\\'t travel anymore\\n        return sum(ceil(people[i]/seats) for i in range(1, n+1))\\n",
                "codeTag": "Java"
            },
            {
                "id": 3176882,
                "title": "c-dfs-o-n-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to do some kind of traversal here so dfs or bfs will be the appaoch. If we have to minimize fuel we can traverse from leaf nodes because if car has enough capacity may be it will pck some other node\\'s represntative as well and save the fuel . So we will always go from leaf to node 0 . In this way our feul can be saved depending upon the car seats .\\n- So if there are 10 people and car capacity is 3 so we will need 4 cars i.e (3,3,3,1) so `cars= ceil(people/seats)` or `cars=people-1/seats +1`\\n- ceil can be also written as e.g ans=ceil(x)/y or ans= (x-1)/y +1 \\n it is one of the same u check by taking example e.g ceil(5/2)=3 and (5-1)/2 +1 = 2+1=3 . So this was something in which pople can get confused why we take this one : `ans= (x-1)/y +1` so its same as ceil.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- So make an adjacency list for dfs traversal\\n- Do a dfs traversal count peole at each subtree and use the above formula. \\n- Fuel  will be incremented when each subtree is traversed \\n- Fuel += (people-1)/seats+1;\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long int fuel=0;\\n    int dfs(int par,int i,vector<vector<int>>&adj,int s){\\n        int r=1;\\n        for(auto x:adj[i]){\\n            if(par!=x)r+=dfs(i,x,adj,s);\\n        }\\n        if(i)\\n        fuel+=(r-1)/s+1;\\n        return r;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        long long ans=0;\\n        int n=roads.size();\\n        vector<vector<int>>adj(n+1);\\n        for(auto r:roads){\\n            adj[r[0]].push_back(r[1]);\\n            adj[r[1]].push_back(r[0]);\\n        }\\n        dfs(-1,0,adj,seats);\\n        return fuel;\\n        \\n    }\\n};\\n```\\n# UpVote If HelpFull \\uD83D\\uDD3C\\uD83D\\uDD3C\\uD83D\\uDD3C",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long int fuel=0;\\n    int dfs(int par,int i,vector<vector<int>>&adj,int s){\\n        int r=1;\\n        for(auto x:adj[i]){\\n            if(par!=x)r+=dfs(i,x,adj,s);\\n        }\\n        if(i)\\n        fuel+=(r-1)/s+1;\\n        return r;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        long long ans=0;\\n        int n=roads.size();\\n        vector<vector<int>>adj(n+1);\\n        for(auto r:roads){\\n            adj[r[0]].push_back(r[1]);\\n            adj[r[1]].push_back(r[0]);\\n        }\\n        dfs(-1,0,adj,seats);\\n        return fuel;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174800,
                "title": "c-bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInstead of visiting nodes from leaf to 0th node we can do BFS from 0th node and see how many cars required to reach each of leaf node by counting no. of cars based on given no. of seats available in each car.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, compute the number of nodes present in each subtree and store it in a child array, where child[i] denotes the number of nodes present in the subtree beginning with the ith root.\\n\\nPerform BFS starting from 0th node, at each node:\\n- For each path to direct child, count the number of nodes in the subtree that begin with that child node.\\n\\n- Determine the minimal number of cars required = (number of nodes)/seats \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs we are visiting each node in dfs and bfs for once only, so time complexity is O(V+E)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(V) for storing the number of nodes in the child array and the queue utilized in bfs. \\n# Code\\n```\\nclass Solution {\\npublic:\\n    void countChild(int index, vector<vector<int>> &graph, vector<int> &child)\\n    {\\n        child[index]=1;\\n\\n        for(auto &x: graph[index])\\n        {\\n            if(child[x]==0)\\n            {\\n                countChild(x,graph,child);\\n                child[index]+=child[x];\\n            }\\n        }\\n\\n        return;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n=roads.size()+1;\\n\\n        vector<vector<int>> graph(n);\\n\\n        for(int i=0;i<n-1;i++)\\n        {\\n            graph[roads[i][0]].push_back(roads[i][1]);\\n            graph[roads[i][1]].push_back(roads[i][0]);\\n        }\\n\\n        vector<int> child(n,0),vis(n,0);\\n\\n        countChild(0,graph,child);\\n\\n        queue<int> q;\\n        q.push(0);\\n        vis[0]=1;\\n\\n        long long minFuel = 0;\\n\\n        while(!q.empty())\\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            for(auto &x: graph[curr])\\n            {\\n                if(vis[x]==1)\\n                    continue;\\n                int cnt = child[x];\\n                minFuel+=cnt/seats;\\n\\n                if(cnt%seats)\\n                    minFuel++;\\n\\n                q.push(x);\\n                vis[x]=1;\\n            }\\n        }\\n\\n        return minFuel;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void countChild(int index, vector<vector<int>> &graph, vector<int> &child)\\n    {\\n        child[index]=1;\\n\\n        for(auto &x: graph[index])\\n        {\\n            if(child[x]==0)\\n            {\\n                countChild(x,graph,child);\\n                child[index]+=child[x];\\n            }\\n        }\\n\\n        return;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n=roads.size()+1;\\n\\n        vector<vector<int>> graph(n);\\n\\n        for(int i=0;i<n-1;i++)\\n        {\\n            graph[roads[i][0]].push_back(roads[i][1]);\\n            graph[roads[i][1]].push_back(roads[i][0]);\\n        }\\n\\n        vector<int> child(n,0),vis(n,0);\\n\\n        countChild(0,graph,child);\\n\\n        queue<int> q;\\n        q.push(0);\\n        vis[0]=1;\\n\\n        long long minFuel = 0;\\n\\n        while(!q.empty())\\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            for(auto &x: graph[curr])\\n            {\\n                if(vis[x]==1)\\n                    continue;\\n                int cnt = child[x];\\n                minFuel+=cnt/seats;\\n\\n                if(cnt%seats)\\n                    minFuel++;\\n\\n                q.push(x);\\n                vis[x]=1;\\n            }\\n        }\\n\\n        return minFuel;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041408,
                "title": "javascript-solution-with-explanation",
                "content": "# Intuition\\nWe will track the number of people in the subtree and calculate the number of cars required based on the number of people. \\nFor example, if there are 4 people and each car has 2 seats, then 2 cars are required. If there are 5 people and each car has 2 seats, then a minimum of 3 cars are required.\\nWill calculate this on every node\\n\\n![MicrosoftTeams-image (9).png](https://assets.leetcode.com/users/images/0993ece4-c88d-4b2c-b5f3-e11c16444788_1673540990.8060584.jpeg)\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} roads\\n * @param {number} seats\\n * @return {number}\\n */\\nvar minimumFuelCost = function(roads, seats) {\\n    const adjList = createAdjacencyList(roads);\\n    let ans = 0\\n\\n    const dfs = (curNode, preNode) => {\\n        let people = 1\\n        for(let child of adjList[curNode]){ \\n            if(child !== preNode){\\n                people += dfs(child, curNode)\\n            }\\n        }\\n        if(curNode) \\n            ans += Math.ceil(people/seats)\\n\\n        return people\\n    }\\n    dfs(0, -1)\\n\\n    return ans\\n};\\n\\n\\nconst createAdjacencyList = (edges) => {\\n    const N = edges.length\\n    const adjList = Array(N+1).fill().map(() => []);\\n\\n    // Add the edges to the adjacency list\\n    for(const edge of edges){\\n        const [node1, node2] = edge;\\n        adjList[node1].push(node2);\\n        adjList[node2].push(node1);\\n    }\\n    return adjList;\\n}\\n```\\n\\n**Please UpVote**",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n/**\\n * @param {number[][]} roads\\n * @param {number} seats\\n * @return {number}\\n */\\nvar minimumFuelCost = function(roads, seats) {\\n    const adjList = createAdjacencyList(roads);\\n    let ans = 0\\n\\n    const dfs = (curNode, preNode) => {\\n        let people = 1\\n        for(let child of adjList[curNode]){ \\n            if(child !== preNode){\\n                people += dfs(child, curNode)\\n            }\\n        }\\n        if(curNode) \\n            ans += Math.ceil(people/seats)\\n\\n        return people\\n    }\\n    dfs(0, -1)\\n\\n    return ans\\n};\\n\\n\\nconst createAdjacencyList = (edges) => {\\n    const N = edges.length\\n    const adjList = Array(N+1).fill().map(() => []);\\n\\n    // Add the edges to the adjacency list\\n    for(const edge of edges){\\n        const [node1, node2] = edge;\\n        adjList[node1].push(node2);\\n        adjList[node2].push(node1);\\n    }\\n    return adjList;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2831713,
                "title": "python-dfs",
                "content": "\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        graph = defaultdict(list)\\n        for e in roads:\\n            graph[e[0]].append(e[1])\\n            graph[e[1]].append(e[0])\\n        visited = set()\\n        fuel = [0]\\n        def dfs(node):\\n            visited.add(node)\\n            people = 0\\n            for n in graph[node]:\\n                if n in visited:\\n                    continue\\n                p = dfs(n)\\n                people += p\\n                fuel[0] += ceil(p / seats)\\n            if not people:\\n                return 1\\n            return people + 1\\n        dfs(0)\\n        return fuel[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        graph = defaultdict(list)\\n        for e in roads:\\n            graph[e[0]].append(e[1])\\n            graph[e[1]].append(e[0])\\n        visited = set()\\n        fuel = [0]\\n        def dfs(node):\\n            visited.add(node)\\n            people = 0\\n            for n in graph[node]:\\n                if n in visited:\\n                    continue\\n                p = dfs(n)\\n                people += p\\n                fuel[0] += ceil(p / seats)\\n            if not people:\\n                return 1\\n            return people + 1\\n        dfs(0)\\n        return fuel[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831687,
                "title": "easy-dfs-o-n-java-c",
                "content": "**Approach**\\n* If you are at leaf node, the cost to reach the next node closer to ```0``` will be 1 as only one person is there\\n* If you are at a non-leaf node and no of people are 5 and seats is 2, the cost to reach the next node closer to ```0``` will be 3 as we need three cars to accomodate 5 people.\\n\\n**Java**\\n```\\nclass Solution {\\n    long cost = 0;\\n    \\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        int n = roads.length + 1;\\n        List<Integer>[] tree = new ArrayList[n];\\n        for(int i=0; i<n; i++) tree[i] = new ArrayList<>();\\n        for(int[] road : roads) {\\n            tree[road[0]].add(road[1]);\\n            tree[road[1]].add(road[0]);\\n        }\\n        \\n        for(int k : tree[0]) {\\n            dfs(tree, seats, k, 0);\\n        }\\n        return cost;\\n    }\\n    \\n    int dfs(List<Integer>[] tree, int seats, int node, int prev) {\\n        if(tree[node].size() == 1) {\\n            cost++;\\n            return 1;\\n        }\\n        \\n        int people = 1;\\n        for(int k : tree[node]) {\\n            if(k == prev || k == 0) continue;\\n            people += dfs(tree, seats, k, node);\\n        }\\n        \\n        cost += people/seats + (people%seats == 0 ? 0 : 1);\\n        return people;\\n    }\\n}\\n```\\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    long long cost = 0;\\n    \\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size() + 1;\\n        vector<vector<int>> tree(n);\\n        for(vector<int>& road : roads) {\\n            tree[road[0]].push_back(road[1]);\\n            tree[road[1]].push_back(road[0]);\\n        }\\n        \\n        for(int k : tree[0]) {\\n            dfs(tree, seats, k, 0);\\n        }\\n        return cost;\\n    }\\n    \\n    int dfs(vector<vector<int>>& tree, int seats, int node, int prev) {\\n        if(tree[node].size() == 1) {\\n            cost++;\\n            return 1;\\n        }\\n        \\n        int people = 1;\\n        for(int k : tree[node]) {\\n            if(k == prev || k == 0) continue;\\n            people += dfs(tree, seats, k, node);\\n        }\\n        \\n        cost += people / seats + (people%seats == 0 ? 0 : 1);\\n        return people;\\n    }\\n};",
                "solutionTags": [
                    "Java",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```0```\n```0```\n```\\nclass Solution {\\n    long cost = 0;\\n    \\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        int n = roads.length + 1;\\n        List<Integer>[] tree = new ArrayList[n];\\n        for(int i=0; i<n; i++) tree[i] = new ArrayList<>();\\n        for(int[] road : roads) {\\n            tree[road[0]].add(road[1]);\\n            tree[road[1]].add(road[0]);\\n        }\\n        \\n        for(int k : tree[0]) {\\n            dfs(tree, seats, k, 0);\\n        }\\n        return cost;\\n    }\\n    \\n    int dfs(List<Integer>[] tree, int seats, int node, int prev) {\\n        if(tree[node].size() == 1) {\\n            cost++;\\n            return 1;\\n        }\\n        \\n        int people = 1;\\n        for(int k : tree[node]) {\\n            if(k == prev || k == 0) continue;\\n            people += dfs(tree, seats, k, node);\\n        }\\n        \\n        cost += people/seats + (people%seats == 0 ? 0 : 1);\\n        return people;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176291,
                "title": "simple-dfs-o-n-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>road;\\n    vector<bool>visit;\\n    long long res=0;\\n\\n    long long count(int curr,int k)\\n    {\\n        int cntt=1;\\n\\n        visit[curr]=true;\\n        for(auto i:road[curr])\\n        {\\n            if(visit[i]==false)\\n                cntt+=count(i,k);\\n        }\\n        if(curr!=0)\\n            res+=((cntt+k-1)/k);\\n        return cntt;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n=roads.size();\\n\\n        road.resize(n+1);\\n        visit.resize(n+1);\\n        for(auto path:roads)\\n        {\\n            road[path[0]].push_back(path[1]);\\n            road[path[1]].push_back(path[0]);\\n        }\\n        count(0,seats);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>road;\\n    vector<bool>visit;\\n    long long res=0;\\n\\n    long long count(int curr,int k)\\n    {\\n        int cntt=1;\\n\\n        visit[curr]=true;\\n        for(auto i:road[curr])\\n        {\\n            if(visit[i]==false)\\n                cntt+=count(i,k);\\n        }\\n        if(curr!=0)\\n            res+=((cntt+k-1)/k);\\n        return cntt;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n=roads.size();\\n\\n        road.resize(n+1);\\n        visit.resize(n+1);\\n        for(auto path:roads)\\n        {\\n            road[path[0]].push_back(path[1]);\\n            road[path[1]].push_back(path[0]);\\n        }\\n        count(0,seats);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832180,
                "title": "c-topological-sort-bfs",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n=roads.size();\\n        \\n        vector<int> people(n+1,1),degree(n+1,0);\\n        people[0]=0;\\n        \\n        vector<int> v[n+1];\\n        \\n        for(auto x:roads){\\n            v[x[0]].push_back(x[1]);\\n            v[x[1]].push_back(x[0]);\\n            \\n            degree[x[0]]++;\\n            degree[x[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        \\n        for(int i=1;i<n+1;i++){\\n            if(degree[i]==1)   {\\n                q.push(i);\\n            }\\n        }\\n        \\n        long long ans=0;\\n        \\n        while(!q.empty())\\n        {\\n            int l=q.size();\\n            \\n            while(l--){\\n                auto city=q.front();\\n                q.pop();\\n                \\n                if(city==0){\\n                    break;\\n                }\\n                \\n                ans+=people[city]/seats;\\n\\n                if(people[city]%seats){\\n                    ans++;\\n                }\\n                \\n                degree[city]=0;\\n                \\n                for(auto x:v[city]){\\n                    people[x]+=people[city];\\n                    degree[x]--;\\n                    \\n                    if(degree[x]==1)\\n                    {\\n                        q.push(x);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n=roads.size();\\n        \\n        vector<int> people(n+1,1),degree(n+1,0);\\n        people[0]=0;\\n        \\n        vector<int> v[n+1];\\n        \\n        for(auto x:roads){\\n            v[x[0]].push_back(x[1]);\\n            v[x[1]].push_back(x[0]);\\n            \\n            degree[x[0]]++;\\n            degree[x[1]]++;\\n        }\\n        \\n        queue<int> q;\\n        \\n        for(int i=1;i<n+1;i++){\\n            if(degree[i]==1)   {\\n                q.push(i);\\n            }\\n        }\\n        \\n        long long ans=0;\\n        \\n        while(!q.empty())\\n        {\\n            int l=q.size();\\n            \\n            while(l--){\\n                auto city=q.front();\\n                q.pop();\\n                \\n                if(city==0){\\n                    break;\\n                }\\n                \\n                ans+=people[city]/seats;\\n\\n                if(people[city]%seats){\\n                    ans++;\\n                }\\n                \\n                degree[city]=0;\\n                \\n                for(auto x:v[city]){\\n                    people[x]+=people[city];\\n                    degree[x]--;\\n                    \\n                    if(degree[x]==1)\\n                    {\\n                        q.push(x);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831663,
                "title": "watch-to-laugh-different-approach-c",
                "content": "<h2>Approach</h2>\\nWe will go upward from each leaf and check how many cars we need to go to parent node and add it with the answer.\\n\\nAt first let us run a dfs to find the parent of all the node. \\n\\nNow we will maintain a queue to handle the leaves(and virtual leaves). Initially we will push all the leaves into the queue. For each leaf we will need to use one car so we add it with the answer. Now the representative of node \\'u\\' has reached to parent node of \\'u\\' with his car. \\n\\nAfter all the child of node \\'u\\' has been processed we can consider \\'u\\' as a leaf. So how many cars do we need to reach the parent of \\'u\\' now? If currently there are X person we need ceil(X/seats) car. Hence, we add ceil(X/seats) with our answer and pass all the representatives of \\'u\\' to its parent. Our procedure ends after all the representatives have reached node 0.\\n\\n<h3>Code</h3>\\n\\n```\\nclass Solution {\\npublic:\\n\\tvector<vector<int>>adj;\\n\\tint par[100001];\\n\\tint child[100001];\\n\\tlong long representatives[100001];\\n\\tvoid dfs(int u,int p){\\n\\t\\tchild[u] = 0;\\n\\t\\trepresentatives[u] = 1;\\n\\t\\tfor(int v:adj[u]){\\n\\t\\t\\tif(v!=p){\\n\\t\\t\\t\\tpar[v] = u;\\n\\t\\t\\t\\tchild[u]++;\\n\\t\\t\\t\\tdfs(v,u);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tlong long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n\\t\\tint n = roads.size();\\n\\t\\tadj.resize(n+1,vector<int>());\\n\\t\\t// build the graph\\n\\t\\tfor(auto&e:roads){\\n\\t\\t\\tadj[e[0]].push_back(e[1]);\\n\\t\\t\\tadj[e[1]].push_back(e[0]);\\n\\t\\t}\\n\\t\\t//Run a dfs to find parent node and children count\\n\\t\\tdfs(0,0);\\n\\n\\t\\tqueue<int>q;\\n\\t\\t//push all the leaves into queue.\\n\\t\\tfor(int i=0;i<=n;i++)\\n\\t\\t\\tif(child[i]==0)q.push(i);\\n\\n\\t\\tlong long ans = 0;\\n\\n\\t\\twhile(q.size()){\\n\\t\\t\\tauto u = q.front();\\n\\t\\t\\tq.pop();\\n\\t\\t\\tif(u==0)break;\\n\\t\\t\\tlong long cars_needed = (representatives[u]+seats-1)/seats;\\n\\t\\t\\tans+= cars_needed;\\n\\t\\t\\t//push all the representatives of u to parent u.\\n\\t\\t\\trepresentatives[par[u]]+=representatives[u];\\n\\t\\t\\t// remove node u from the graph.\\n\\t\\t\\tchild[par[u]]--;\\n\\t\\t\\t//if current node has no child left it is a new leaf.\\n\\t\\t\\tif(child[par[u]]==0)q.push(par[u]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n<h3>Approach 2</h3>\\nCan we do better? At this point you might realize that we only need the size of \\neach subtree and we can just add the answer in 1 DFS. \\n\\nCode\\n```\\n    class Solution {\\n    public:\\n        vector<vector<int>>adj;\\n        long long sz[100001];\\n        int seats;\\n        long long dfs(int u,int p){\\n            sz[u] = 1;\\n            long long req = 0;\\n            for(int v:adj[u]){\\n                if(v!=p){\\n                    req+=dfs(v, u);\\n                    sz[u]+=sz[v];\\n\\n                }\\n            }    \\n\\t\\t\\tif(u) req+=(sz[u]+seats-1) / seats;\\n            return req;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int s) {\\n        seats = s;\\n        int n = roads.size();\\n        adj.resize(n+1,vector<int>());\\n        for(auto&e:roads){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        return dfs(0,0);\\n        }\\n        \\n\\n};\\n```\\n<b>Please upvote the post if you liked it. It gives me motivation to write new solutions. \\uD83D\\uDE0A",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<int>>adj;\\n\\tint par[100001];\\n\\tint child[100001];\\n\\tlong long representatives[100001];\\n\\tvoid dfs(int u,int p){\\n\\t\\tchild[u] = 0;\\n\\t\\trepresentatives[u] = 1;\\n\\t\\tfor(int v:adj[u]){\\n\\t\\t\\tif(v!=p){\\n\\t\\t\\t\\tpar[v] = u;\\n\\t\\t\\t\\tchild[u]++;\\n\\t\\t\\t\\tdfs(v,u);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tlong long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n\\t\\tint n = roads.size();\\n\\t\\tadj.resize(n+1,vector<int>());\\n\\t\\t// build the graph\\n\\t\\tfor(auto&e:roads){\\n\\t\\t\\tadj[e[0]].push_back(e[1]);\\n\\t\\t\\tadj[e[1]].push_back(e[0]);\\n\\t\\t}\\n\\t\\t//Run a dfs to find parent node and children count\\n\\t\\tdfs(0,0);\\n\\n\\t\\tqueue<int>q;\\n\\t\\t//push all the leaves into queue.\\n\\t\\tfor(int i=0;i<=n;i++)\\n\\t\\t\\tif(child[i]==0)q.push(i);\\n\\n\\t\\tlong long ans = 0;\\n\\n\\t\\twhile(q.size()){\\n\\t\\t\\tauto u = q.front();\\n\\t\\t\\tq.pop();\\n\\t\\t\\tif(u==0)break;\\n\\t\\t\\tlong long cars_needed = (representatives[u]+seats-1)/seats;\\n\\t\\t\\tans+= cars_needed;\\n\\t\\t\\t//push all the representatives of u to parent u.\\n\\t\\t\\trepresentatives[par[u]]+=representatives[u];\\n\\t\\t\\t// remove node u from the graph.\\n\\t\\t\\tchild[par[u]]--;\\n\\t\\t\\t//if current node has no child left it is a new leaf.\\n\\t\\t\\tif(child[par[u]]==0)q.push(par[u]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\n```\\n    class Solution {\\n    public:\\n        vector<vector<int>>adj;\\n        long long sz[100001];\\n        int seats;\\n        long long dfs(int u,int p){\\n            sz[u] = 1;\\n            long long req = 0;\\n            for(int v:adj[u]){\\n                if(v!=p){\\n                    req+=dfs(v, u);\\n                    sz[u]+=sz[v];\\n\\n                }\\n            }    \\n\\t\\t\\tif(u) req+=(sz[u]+seats-1) / seats;\\n            return req;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int s) {\\n        seats = s;\\n        int n = roads.size();\\n        adj.resize(n+1,vector<int>());\\n        for(auto&e:roads){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        return dfs(0,0);\\n        }\\n        \\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174815,
                "title": "simple-graph-solution-using-dfs-in-o-n",
                "content": "\\n# Complexity\\n- Time complexity:\\n- O(N)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n#define ll long long int\\npair<ll, ll> solve(vector<vector<int>> &arr, int se, int i, ll &ans, int pr)\\n{\\n    if (arr[i].size() == 0)\\n    {\\n        ans++;\\n        return {1, 1};\\n    }\\n    pair<ll, ll> temp;\\n    temp.first = 0;\\n    temp.second = 0;\\n    for (int j = 0; j < arr[i].size(); j++)\\n    {\\n        if (arr[i][j] != pr)\\n        {\\n\\n            pair<ll, ll> p = solve(arr, se, arr[i][j], ans, i);\\n            temp.first += p.first;\\n            temp.second += p.second;\\n        }\\n    }\\n\\n    ll maxi = temp.second * se;\\n    if (temp.first < maxi)\\n    {\\n        while (((temp.second - 1) * se) > temp.first)\\n        {\\n            temp.second--;\\n        }\\n\\n        temp.first++;\\n        ans += temp.second;\\n        return temp;\\n    }\\n    temp.second++;\\n    temp.first++;\\n    ans += temp.second;\\n    return temp;\\n}\\nlong long minimumFuelCost(vector<vector<int>> &a, int se)\\n{\\n    int n = a.size();\\n    vector<vector<int>> arr(n + 1);\\n    for (int i = 0; i < n; i++)\\n    {\\n        arr[a[i][0]].push_back(a[i][1]);\\n        arr[a[i][1]].push_back(a[i][0]);\\n    }\\n    ll ans = 0;\\n    for (int i = 0; i < arr[0].size(); i++)\\n    {\\n        pair<ll, ll> x = solve(arr, se, arr[0][i], ans, 0);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n#define ll long long int\\npair<ll, ll> solve(vector<vector<int>> &arr, int se, int i, ll &ans, int pr)\\n{\\n    if (arr[i].size() == 0)\\n    {\\n        ans++;\\n        return {1, 1};\\n    }\\n    pair<ll, ll> temp;\\n    temp.first = 0;\\n    temp.second = 0;\\n    for (int j = 0; j < arr[i].size(); j++)\\n    {\\n        if (arr[i][j] != pr)\\n        {\\n\\n            pair<ll, ll> p = solve(arr, se, arr[i][j], ans, i);\\n            temp.first += p.first;\\n            temp.second += p.second;\\n        }\\n    }\\n\\n    ll maxi = temp.second * se;\\n    if (temp.first < maxi)\\n    {\\n        while (((temp.second - 1) * se) > temp.first)\\n        {\\n            temp.second--;\\n        }\\n\\n        temp.first++;\\n        ans += temp.second;\\n        return temp;\\n    }\\n    temp.second++;\\n    temp.first++;\\n    ans += temp.second;\\n    return temp;\\n}\\nlong long minimumFuelCost(vector<vector<int>> &a, int se)\\n{\\n    int n = a.size();\\n    vector<vector<int>> arr(n + 1);\\n    for (int i = 0; i < n; i++)\\n    {\\n        arr[a[i][0]].push_back(a[i][1]);\\n        arr[a[i][1]].push_back(a[i][0]);\\n    }\\n    ll ans = 0;\\n    for (int i = 0; i < arr[0].size(); i++)\\n    {\\n        pair<ll, ll> x = solve(arr, se, arr[0][i], ans, 0);\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174404,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> edges;\\n    vector<bool> visit;\\n    long long ret=0;\\n    int count(int cur,int k){\\n        int cnt=1;\\n        visit[cur]=true;\\n        for(auto i:edges[cur]){\\n            if(visit[i]==false){\\n                cnt+= count(i,k);\\n            }\\n        }\\n        if(cur!=0){\\n            ret+=((cnt+k-1)/k);\\n\\n        }\\n        return cnt;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n =roads.size();\\n        edges.resize(n+1);\\n        visit.resize(n+1);\\n        for(auto road:roads){\\n            edges[road[0]].push_back(road[1]);\\n            edges[road[1]].push_back(road[0]);\\n        }\\n        count(0,seats);\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> edges;\\n    vector<bool> visit;\\n    long long ret=0;\\n    int count(int cur,int k){\\n        int cnt=1;\\n        visit[cur]=true;\\n        for(auto i:edges[cur]){\\n            if(visit[i]==false){\\n                cnt+= count(i,k);\\n            }\\n        }\\n        if(cur!=0){\\n            ret+=((cnt+k-1)/k);\\n\\n        }\\n        return cnt;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n =roads.size();\\n        edges.resize(n+1);\\n        visit.resize(n+1);\\n        for(auto road:roads){\\n            edges[road[0]].push_back(road[1]);\\n            edges[road[1]].push_back(road[0]);\\n        }\\n        count(0,seats);\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831741,
                "title": "dfs-steps-wise-explanation-and-optimized-solutions",
                "content": "# Approach\\n   * DFS, the output of from a particular node will have three values **[total fuel spend,total filled cars, passengers in the unfilled car]** \\n   * sum up all three of these for all the child nodes cal them fuel,cars,passengers\\n   * We can sum up all the passengers in the unfilled cars and assign them cars in the optimal way since it is allowed to change cars\\n     to do this \\n   * We need find cars that will be totally filled by the passengers that were travelling in the unfilled car= **passengers/seats**\\n   * The passengers that will go in the unfilled car will be (extracars)= **passengers%seats**\\n   * Now total fuel spend to go from child node to parent node will be :**fuel+cars+extra cars+(passengers in unfilled cars>0)**\\n   * Total filled cars will be sum of all cars and extra cars used to fill passengers in unfilled cars:**cars+extracars**\\n   * and left passengers will be send as the third element of our ans  \\n\\n# Complexity\\n- **Time complexity:**\\n    O(total nodes)\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int visited[100001];\\n    vector<ll> dfs(vector<vector<int>>& roads,int start,int seats)\\n    {\\n        ll ans=0,cars=0,passengers=1; \\n        visited[start]=1;\\n        for(int i=0;i<roads[start].size();i++)\\n        {\\n            if(visited[roads[start][i]])\\n                continue;\\n            vector<ll> temp=dfs(roads,roads[start][i],seats);\\n            ans=ans+temp[0];\\n            cars+=temp[1];\\n            passengers+=temp[2];\\n        }\\n        ll extracars=(passengers/seats);\\n        ll passengersleft=(passengers%seats);\\n        \\n        return  {ans+cars+extracars+(passengersleft!=0),cars+extracars,passengersleft};\\n        \\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) \\n    {\\n        int n=roads.size();\\n        vector<vector<int>>adj(n+1);\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[roads[i][0]].push_back(roads[i][1]);\\n            adj[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        memset(visited,0,sizeof(visited));\\n        ll ans=0;\\n        visited[0]=1;\\n        for(int i=0;i<adj[0].size();i++)\\n        {\\n            auto count=dfs(adj,adj[0][i],seats);\\n            ans+=count[0];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Optimsed solution:\\n\\n* In the last approach we were only removing the passengers that are in partially filled cars and rearranging them.\\n* However we can also remove the passengers in filled car and sum up all the passengers we are getting from the subtree and reassign them new cars.\\n* Here after we get all the passengers in the subtree we will assign them **ceil(passengers/seats)** of cars and total fuel will be that equal.\\n\\n**Time Complexity: O(n)**\\n**Space Complexity: O(sizeof(adjacency list))**\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll ans=0;\\n    ll dfs(vector<vector<int>>& roads,int start,int seats,int par)\\n    {\\n        ll passengers=1; \\n        for(int i=0;i<roads[start].size();i++)\\n        {\\n            if(roads[start][i]==par) continue;\\n            passengers+=dfs(roads,roads[start][i],seats,start);\\n        }\\n        if(start) ans=ans+ceil((passengers+seats-1)/seats);\\n        return passengers;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) \\n    {\\n        vector<vector<int>>adj(roads.size()+1);\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            adj[roads[i][0]].push_back(roads[i][1]);\\n            adj[roads[i][1]].push_back(roads[i][0]);\\n        }   \\n        int passengers=dfs(adj,0,seats,-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int visited[100001];\\n    vector<ll> dfs(vector<vector<int>>& roads,int start,int seats)\\n    {\\n        ll ans=0,cars=0,passengers=1; \\n        visited[start]=1;\\n        for(int i=0;i<roads[start].size();i++)\\n        {\\n            if(visited[roads[start][i]])\\n                continue;\\n            vector<ll> temp=dfs(roads,roads[start][i],seats);\\n            ans=ans+temp[0];\\n            cars+=temp[1];\\n            passengers+=temp[2];\\n        }\\n        ll extracars=(passengers/seats);\\n        ll passengersleft=(passengers%seats);\\n        \\n        return  {ans+cars+extracars+(passengersleft!=0),cars+extracars,passengersleft};\\n        \\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) \\n    {\\n        int n=roads.size();\\n        vector<vector<int>>adj(n+1);\\n        for(int i=0;i<n;i++)\\n        {\\n            adj[roads[i][0]].push_back(roads[i][1]);\\n            adj[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        memset(visited,0,sizeof(visited));\\n        ll ans=0;\\n        visited[0]=1;\\n        for(int i=0;i<adj[0].size();i++)\\n        {\\n            auto count=dfs(adj,adj[0][i],seats);\\n            ans+=count[0];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll ans=0;\\n    ll dfs(vector<vector<int>>& roads,int start,int seats,int par)\\n    {\\n        ll passengers=1; \\n        for(int i=0;i<roads[start].size();i++)\\n        {\\n            if(roads[start][i]==par) continue;\\n            passengers+=dfs(roads,roads[start][i],seats,start);\\n        }\\n        if(start) ans=ans+ceil((passengers+seats-1)/seats);\\n        return passengers;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) \\n    {\\n        vector<vector<int>>adj(roads.size()+1);\\n        for(int i=0;i<roads.size();i++)\\n        {\\n            adj[roads[i][0]].push_back(roads[i][1]);\\n            adj[roads[i][1]].push_back(roads[i][0]);\\n        }   \\n        int passengers=dfs(adj,0,seats,-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831662,
                "title": "c-dfs",
                "content": "**DFS Solution**\\nWe will maintain the number of people up the tree and at each node calculate the fuel required for these number of people to reach at a given node. Thus, at the 0th node i.e., destination node we would get the total fuel.\\n```\\n#define ff first\\n#define ss second\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n\\t// <fuel, people>\\n    pair<ll, ll> dfs(int i, int p, ll h, int seats) {\\n        bool flag = true;\\n        ll fuel = 0, people = 0;\\n        for(auto ch : adj[i]) {\\n            if(ch != p) {\\n                flag = false;\\n                pair<ll, ll> q = dfs(ch, i, h + 1, seats);\\n                fuel += q.ff;\\n                people += q.ss;\\n            }\\n        }\\n        if(i == 0)                                                        // We don\\'t need to go anywhere. Thus, return the total fuel.\\n            return {fuel, people};\\n        people++;                                                         // Include current representative \\n        ll x = people % seats == 0 ? people / seats : people / seats + 1; // n = seats require 1 unit fuel, thus x = minimum cars required for all people\\n        fuel += x;\\n        if(flag)                                                          // Representative at root node will need 1 unit fuel.\\n            return {1, 1};\\n        return {fuel, people};\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        if(roads.size() == 0)\\n            return 0;\\n        int n = 1 + roads.size();\\n        adj.resize(n, vector<int> ());\\n        for(auto it : roads) {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        pair<ll, ll> p = dfs(0, 0, 0, seats);\\n        return p.ff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n#define ff first\\n#define ss second\\ntypedef long long ll;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n\\t// <fuel, people>\\n    pair<ll, ll> dfs(int i, int p, ll h, int seats) {\\n        bool flag = true;\\n        ll fuel = 0, people = 0;\\n        for(auto ch : adj[i]) {\\n            if(ch != p) {\\n                flag = false;\\n                pair<ll, ll> q = dfs(ch, i, h + 1, seats);\\n                fuel += q.ff;\\n                people += q.ss;\\n            }\\n        }\\n        if(i == 0)                                                        // We don\\'t need to go anywhere. Thus, return the total fuel.\\n            return {fuel, people};\\n        people++;                                                         // Include current representative \\n        ll x = people % seats == 0 ? people / seats : people / seats + 1; // n = seats require 1 unit fuel, thus x = minimum cars required for all people\\n        fuel += x;\\n        if(flag)                                                          // Representative at root node will need 1 unit fuel.\\n            return {1, 1};\\n        return {fuel, people};\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        if(roads.size() == 0)\\n            return 0;\\n        int n = 1 + roads.size();\\n        adj.resize(n, vector<int> ());\\n        for(auto it : roads) {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        pair<ll, ll> p = dfs(0, 0, 0, seats);\\n        return p.ff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173882,
                "title": "c-dfs",
                "content": "# Intuition & Approach\\nhttps://youtu.be/Gq6HHNT3eg4\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    long long numOfLiters = 0;\\n    vector<vector<int>> graph;\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size();\\n        graph = vector<vector<int>> (n + 1);\\n\\n        for (auto &road : roads) {\\n            graph[road[0]].push_back(road[1]);\\n            graph[road[1]].push_back(road[0]);\\n        }\\n\\n        DFS(0, -1, seats);\\n\\n        return numOfLiters;\\n    }\\n\\n    int DFS(int node, int parent, int seats) {\\n        int representatives = 1;\\n\\n        for (auto child : graph[node])\\n            if (child != parent)\\n                representatives += DFS(child, node, seats);\\n        \\n        if (node != 0)\\n            numOfLiters += (representatives + seats - 1) / seats;\\n        \\n        return representatives;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long numOfLiters = 0;\\n    vector<vector<int>> graph;\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size();\\n        graph = vector<vector<int>> (n + 1);\\n\\n        for (auto &road : roads) {\\n            graph[road[0]].push_back(road[1]);\\n            graph[road[1]].push_back(road[0]);\\n        }\\n\\n        DFS(0, -1, seats);\\n\\n        return numOfLiters;\\n    }\\n\\n    int DFS(int node, int parent, int seats) {\\n        int representatives = 1;\\n\\n        for (auto child : graph[node])\\n            if (child != parent)\\n                representatives += DFS(child, node, seats);\\n        \\n        if (node != 0)\\n            numOfLiters += (representatives + seats - 1) / seats;\\n        \\n        return representatives;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848046,
                "title": "c-easy-solution",
                "content": "\\n    public class Solution\\n    {\\n        long cost;\\n        public long MinimumFuelCost(int[][] roads, int seats)\\n        {\\n            if(roads.GetLength(0) == 0)\\n                return 0;\\n                \\n            cost = 0;\\n            var graph = new Dictionary<int, List<int>>();\\n\\n            foreach (var road in roads)\\n            {\\n                if (!graph.ContainsKey(road[0]))\\n                    graph[road[0]] = new List<int>();\\n\\n                if (!graph.ContainsKey(road[1]))\\n                    graph[road[1]] = new List<int>();\\n\\n                graph[road[0]].Add(road[1]);\\n                graph[road[1]].Add(road[0]);\\n            }\\n\\n            DFS(graph, 0, 0, seats);\\n            return cost;\\n        }\\n\\n        private int DFS(Dictionary<int, List<int>> graph, int prev, int city, int seat)\\n        {\\n            int rep = 1;\\n            foreach(var neighbour in graph[city]) {\\n                if(neighbour != prev)\\n                    rep += DFS(graph, city, neighbour, seat);\\n            }\\n\\n            if(city != 0)\\n                cost += (rep / seat) + (rep % seat > 0 ? 1 : 0);\\n            \\n            return rep;\\n        }\\n    }",
                "solutionTags": [
                    "C#"
                ],
                "code": "class Solution\\n    {\\n        long cost;\\n        public long MinimumFuelCost(int[][] roads, int seats)\\n        {\\n            if(roads.GetLength(0) == 0)\\n                return 0;\\n                \\n            cost = 0;\\n            var graph = new Dictionary<int, List<int>>();\\n\\n            foreach (var road in roads)\\n            {\\n                if (!graph.ContainsKey(road[0]))\\n                    graph[road[0]] = new List<int>();\\n\\n                if (!graph.ContainsKey(road[1]))\\n                    graph[road[1]] = new List<int>();\\n\\n                graph[road[0]].Add(road[1]);\\n                graph[road[1]].Add(road[0]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3175523,
                "title": "python3-easy-explained-in-detailed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing DFS to solve.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- **Count child including parent** for given node.\\n- if at **end of graph then return 1**, **because we will go to parent with 1 unit of fuel and with one car**.\\n- now **parent will add** number of **cars of children subtree**.\\n- now compute required fule to go to parent\\'s parent, i.e. $$celi(cars/seats)$$.\\n- do this till all cities are covered.\\n- **skip capital for counting fuel** because it\\'s destination node.\\n- return answer\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N+V*E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict as DD\\nfrom math import ceil\\nclass Solution:\\n    def graphConstruct(self,roads):\\n        def notPresent():return False\\n        graph = DD(notPresent)\\n        graph[-1] = -1\\n        for a, b in roads:\\n            if graph[a]:\\n                graph[a].append(b)\\n            else:\\n                graph[a] = [b]\\n            if graph[b]:\\n                graph[b].append(a)\\n            else:\\n                graph[b] = [a]\\n        return graph\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        graph = self.graphConstruct(roads)\\n        visited = [False for _ in range(len(roads)+1)]\\n        ans = 0\\n        def helperDfs(node=0):\\n            nonlocal graph, visited, ans\\n            cars = 1\\n            if not visited[node] and graph[node]:\\n                visited[node] = True\\n                for i in graph[node]:\\n                    if not visited[i]:\\n                        cars += helperDfs(i)\\n                if node: ans += ceil(cars/seats)\\n            return cars\\n        helperDfs()\\n        return ans\\n```\\n# Please upvote the solution and do comment below.\\n\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n\\u2591\\u2591\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2588\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\u2588\\n\\u2591\\u2591\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2588\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\u2588\\n\\u2591\\u2591\\u2591\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2591\\u2591\\u2591\\u2591\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\n\\u2591\\u2591\\u2591\\u2591\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2591\\u2591\\u2591\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\u2588\\n\\u2591\\u2591\\u2591\\u2591\\u2591\\u2588\\u2592\\u2592\\u2592\\u2588\\u2591\\u2591\\u2591\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\n\\u2591\\u2591\\u2591\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\n\\u2591\\u2591\\u2591\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\n\\u2591\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2592\\u2592\\u2592\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\n\\u2588\\u2588\\u2592\\u2592\\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\n\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\n\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\n\\u2591\\u2588\\u2592\\u2592\\u2592\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\n\\u2591\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\u2588\\u2588\\u2588\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2592\\u2588\\n\\u2591\\u2591\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2591\\u2591\\u2591\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\n",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nfrom collections import defaultdict as DD\\nfrom math import ceil\\nclass Solution:\\n    def graphConstruct(self,roads):\\n        def notPresent():return False\\n        graph = DD(notPresent)\\n        graph[-1] = -1\\n        for a, b in roads:\\n            if graph[a]:\\n                graph[a].append(b)\\n            else:\\n                graph[a] = [b]\\n            if graph[b]:\\n                graph[b].append(a)\\n            else:\\n                graph[b] = [a]\\n        return graph\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        graph = self.graphConstruct(roads)\\n        visited = [False for _ in range(len(roads)+1)]\\n        ans = 0\\n        def helperDfs(node=0):\\n            nonlocal graph, visited, ans\\n            cars = 1\\n            if not visited[node] and graph[node]:\\n                visited[node] = True\\n                for i in graph[node]:\\n                    if not visited[i]:\\n                        cars += helperDfs(i)\\n                if node: ans += ceil(cars/seats)\\n            return cars\\n        helperDfs()\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173758,
                "title": "javascript-7-lines-dfs-time-o-n-space-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nconst minimumFuelCost = ( roads, seats ) => {\\n    let r = [[]], f = 0, dfs = ( i, p, c = 1 ) => {\\n        r[i].forEach( j => c += j != p && dfs(j,i) )\\n        f += i && Math.ceil( c / seats )\\n        return c\\n    }\\n    for ( let [ a, b ] of roads )\\n        (r[a]=r[a]||[]).push(b), (r[b]=r[b]||[]).push(a)   \\n    dfs(0)\\n    return f\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nconst minimumFuelCost = ( roads, seats ) => {\\n    let r = [[]], f = 0, dfs = ( i, p, c = 1 ) => {\\n        r[i].forEach( j => c += j != p && dfs(j,i) )\\n        f += i && Math.ceil( c / seats )\\n        return c\\n    }\\n    for ( let [ a, b ] of roads )\\n        (r[a]=r[a]||[]).push(b), (r[b]=r[b]||[]).push(a)   \\n    dfs(0)\\n    return f\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2839984,
                "title": "python-dfs-picture-explanation-video-solution-o-n",
                "content": "You can watch the [video solution](https://youtu.be/O7Z0kiWVk5c).\\n\\n# Formula for cars\\n![image](https://assets.leetcode.com/users/images/1f0655d1-5720-408a-855e-35a52d5d46db_1669139601.9618206.png)\\n\\nWe can\\'t have 2.5 cars.\\n\\n`math.ceil(people/seats)`\\n\\n# No. of people aggregating at a city\\n\\n![image](https://assets.leetcode.com/users/images/aefe9673-3b24-4a95-830c-fc0a6cdc1fd9_1669139748.0782027.png)\\n\\nDespite the roads being undirected, the road direction will be towards **city 0**.\\n\\nAt **city 1**, there is already 1 person and 3 more people will be arriving from **city 2, 3, 4**.\\n\\n![image](https://assets.leetcode.com/users/images/a3f1865e-93e8-49f2-baf4-746e11507daa_1669140087.4376225.png)\\n\\n\\nSimilarly at **city 2**, there is 1 person and 2 people will arrive from **city 3,4**.\\n\\n**City 3,4** don\\'t have incoming nodes (leaf nodes), hence only 1 people will aggregate over there.\\n\\nHence, 3 people will be at city 2 and 4 people at city 1.\\n\\n# Calculate people for each connected component\\n\\n![image](https://assets.leetcode.com/users/images/d924accc-0371-4e9a-ac25-2b42a7e80868_1669140146.8455944.png)\\n\\nThe no. of people arriving at **city 0** from all these groups are independent of each other. \\n\\nHence, we will have to solve each problem individually and add them at the end.\\n\\n# Divide people into cars\\n\\n\\n\\nWhen people gather at a city, they have to move to the next city in the path towards **city 0**.\\n\\nThis would take 1 litre for each car.\\n\\nWe will have to calculate the number of cars needed and add it to our result.\\n\\n![image](https://assets.leetcode.com/users/images/4af7e52d-fb7d-42f7-85ec-229d664ac2b9_1669140338.9168563.png)\\n\\nFor eg: 3 people gathered at **city 2**, so 2 cars will be needed to go to **city 1**.\\n\\nThis process would be repeated for each node using `dfs`.\\n\\nSince people at **city 0**, don\\'t have to move anywhere, there is no fuel consumed. \\n\\nHence, we have to avoid adding anything for **city 0**..\\n\\n`Time: O(n)`  We are going through all the nodes only once.\\n\\n`Space: O(n)` We are storing the graph (n-1 edges) using an adjacency matrix. We will need `O(n)` stack memory for our recursive DFS function.\\n\\nIf you thought this was helpful, please upvote, like the video, and subscribe to the channel.\\n\\nCheers\\n\\n\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        m = defaultdict(list)\\n        \\n        for a,b in roads:\\n            m[a].append(b)\\n            m[b].append(a)\\n            \\n        ans = [0]\\n        \\n        def dfs(node, prev):\\n\\t\\t\\n            people = 1\\n            \\n            for i in m[node]:\\n\\t\\t\\t\\n                if i==prev:\\n                    continue\\n                \\n                people+=dfs(i, node)\\n                \\n            if node!=0:\\n                ans[0]+=math.ceil(people/seats)\\n                \\n            return people\\n\\t\\t\\t\\n        dfs(0, None)\\n\\t\\t\\n        return ans[0]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "You can watch the [video solution](https://youtu.be/O7Z0kiWVk5c).\\n\\n# Formula for cars\\n![image](https://assets.leetcode.com/users/images/1f0655d1-5720-408a-855e-35a52d5d46db_1669139601.9618206.png)\\n\\nWe can\\'t have 2.5 cars.\\n\\n`math.ceil(people/seats)`\\n\\n# No. of people aggregating at a city\\n\\n![image](https://assets.leetcode.com/users/images/aefe9673-3b24-4a95-830c-fc0a6cdc1fd9_1669139748.0782027.png)\\n\\nDespite the roads being undirected, the road direction will be towards **city 0**.\\n\\nAt **city 1**, there is already 1 person and 3 more people will be arriving from **city 2, 3, 4**.\\n\\n![image](https://assets.leetcode.com/users/images/a3f1865e-93e8-49f2-baf4-746e11507daa_1669140087.4376225.png)\\n\\n\\nSimilarly at **city 2**, there is 1 person and 2 people will arrive from **city 3,4**.\\n\\n**City 3,4** don\\'t have incoming nodes (leaf nodes), hence only 1 people will aggregate over there.\\n\\nHence, 3 people will be at city 2 and 4 people at city 1.\\n\\n# Calculate people for each connected component\\n\\n![image](https://assets.leetcode.com/users/images/d924accc-0371-4e9a-ac25-2b42a7e80868_1669140146.8455944.png)\\n\\nThe no. of people arriving at **city 0** from all these groups are independent of each other. \\n\\nHence, we will have to solve each problem individually and add them at the end.\\n\\n# Divide people into cars\\n\\n\\n\\nWhen people gather at a city, they have to move to the next city in the path towards **city 0**.\\n\\nThis would take 1 litre for each car.\\n\\nWe will have to calculate the number of cars needed and add it to our result.\\n\\n![image](https://assets.leetcode.com/users/images/4af7e52d-fb7d-42f7-85ec-229d664ac2b9_1669140338.9168563.png)\\n\\nFor eg: 3 people gathered at **city 2**, so 2 cars will be needed to go to **city 1**.\\n\\nThis process would be repeated for each node using `dfs`.\\n\\nSince people at **city 0**, don\\'t have to move anywhere, there is no fuel consumed. \\n\\nHence, we have to avoid adding anything for **city 0**..\\n\\n`Time: O(n)`  We are going through all the nodes only once.\\n\\n`Space: O(n)` We are storing the graph (n-1 edges) using an adjacency matrix. We will need `O(n)` stack memory for our recursive DFS function.\\n\\nIf you thought this was helpful, please upvote, like the video, and subscribe to the channel.\\n\\nCheers\\n\\n\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        m = defaultdict(list)\\n        \\n        for a,b in roads:\\n            m[a].append(b)\\n            m[b].append(a)\\n            \\n        ans = [0]\\n        \\n        def dfs(node, prev):\\n\\t\\t\\n            people = 1\\n            \\n            for i in m[node]:\\n\\t\\t\\t\\n                if i==prev:\\n                    continue\\n                \\n                people+=dfs(i, node)\\n                \\n            if node!=0:\\n                ans[0]+=math.ceil(people/seats)\\n                \\n            return people\\n\\t\\t\\t\\n        dfs(0, None)\\n\\t\\t\\n        return ans[0]",
                "codeTag": "Java"
            },
            {
                "id": 2837161,
                "title": "enter-and-leaving-cars",
                "content": "# Intuition\\nWe can just keep track of cars entering and leaving a node in the tree and try to minimize the cars leaving at each node.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCreat a structure `Car` for simpliciyt purposes.\\nat each node in the Depth-First Search algorithm.\\nWe all all the entering passangers and computing the fuel use as:\\n```\\nnode.fuel += enter.fuel + enter.cars;\\nnode.passanger += enter.passanger;\\n```\\nAnd at then end the representatives of the city is added to passangers and then we compute the minimum numbers of cars needed that will be leaving the node.\\n```\\nnode.passanger++;\\nnode.cars = ceil(node.passanger / seats);\\n```\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(h)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nstruct Car {\\n    int passanger, cars;\\n    long long fuel;\\n    Car() : passanger(0), cars(0), fuel(0) {}\\n    Car(int a, int b) : passanger(a), cars(b), fuel(0) {}\\n};\\n\\nclass Solution {\\npublic:\\n    double seats;\\n    \\n    Car dfs(vector<vector<int>>& graph, vector<bool>& visited, int i) {\\n        Car enter, node = Car();\\n        visited[i] = true;\\n        \\n        for(int v: graph[i]) {\\n            if(!visited[v]) {\\n                enter = dfs(graph, visited, v);\\n                node.fuel += enter.fuel + enter.cars;\\n                node.passanger += enter.passanger;\\n            }\\n        }\\n        \\n        node.passanger++;\\n        node.cars = ceil(node.passanger / seats);\\n        return node;\\n    }\\n    \\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        this->seats = seats;\\n        int n = roads.size();\\n        \\n        vector<vector<int>> graph(n + 1);\\n        \\n        for(vector<int>& road: roads) {\\n            graph[road[0]].push_back(road[1]);\\n            graph[road[1]].push_back(road[0]);\\n        }\\n        \\n        vector<bool> visited(n + 1, false);\\n        \\n        Car res = dfs(graph, visited, 0);\\n        \\n        return res.fuel;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nnode.fuel += enter.fuel + enter.cars;\\nnode.passanger += enter.passanger;\\n```\n```\\nnode.passanger++;\\nnode.cars = ceil(node.passanger / seats);\\n```\n```\\nstruct Car {\\n    int passanger, cars;\\n    long long fuel;\\n    Car() : passanger(0), cars(0), fuel(0) {}\\n    Car(int a, int b) : passanger(a), cars(b), fuel(0) {}\\n};\\n\\nclass Solution {\\npublic:\\n    double seats;\\n    \\n    Car dfs(vector<vector<int>>& graph, vector<bool>& visited, int i) {\\n        Car enter, node = Car();\\n        visited[i] = true;\\n        \\n        for(int v: graph[i]) {\\n            if(!visited[v]) {\\n                enter = dfs(graph, visited, v);\\n                node.fuel += enter.fuel + enter.cars;\\n                node.passanger += enter.passanger;\\n            }\\n        }\\n        \\n        node.passanger++;\\n        node.cars = ceil(node.passanger / seats);\\n        return node;\\n    }\\n    \\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        this->seats = seats;\\n        int n = roads.size();\\n        \\n        vector<vector<int>> graph(n + 1);\\n        \\n        for(vector<int>& road: roads) {\\n            graph[road[0]].push_back(road[1]);\\n            graph[road[1]].push_back(road[0]);\\n        }\\n        \\n        vector<bool> visited(n + 1, false);\\n        \\n        Car res = dfs(graph, visited, 0);\\n        \\n        return res.fuel;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833175,
                "title": "easy-c-dfs-o-n-solution",
                "content": "class Solution {\\npublic:\\n    \\n    long long res = 0;\\n    long long dfs(vector<vector<int>>& graph, int node, int seats, vector<int>& vis){\\n        vis[node]=1;\\n        int num = 1;\\n        for(auto child:graph[node]){\\n            if(!vis[child]) num+=dfs(graph, child, seats, vis);\\n        }\\n        res+=ceil(num*1.0/seats);\\n        return num;   \\n    }\\n    \\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size();\\n        vector<vector<int>> graph(n+1);\\n        for(int i=0; i<roads.size();i++){\\n            graph[roads[i][0]].push_back(roads[i][1]);\\n            graph[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        vector<int> vis(n+1,0);\\n        vis[0]=1;\\n        for(auto child:graph[0]){\\n            dfs(graph, child, seats, vis);\\n        }\\n        return res;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    long long res = 0;\\n    long long dfs(vector<vector<int>>& graph, int node, int seats, vector<int>& vis){\\n        vis[node]=1;\\n        int num = 1;\\n        for(auto child:graph[node]){\\n            if(!vis[child]) num+=dfs(graph, child, seats, vis);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2832139,
                "title": "c-just-count-subtrees",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int \\n    map<int,vector<int>>g ; \\n    vector<bool>vis;\\n    vector<int>count;\\n    void subtree(int node,int par){\\n        count[node] = 1 ; \\n        for(auto child : g[node]){\\n            if(child != par){\\n                subtree(child,node);\\n                count[node] = count[node] + count[child];\\n            }\\n        }\\n        \\n    }\\n    long long int ans = 0 ;\\n    long long int dfs(int src,int seats){\\n        vis[src] = true ; \\n        \\n        for(auto x : g[src]){\\n            if(vis[x]==false){\\n                dfs(x,seats);\\n             \\n                ans += count[x]/seats ; \\n                if(count[x]%seats)ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size() ; \\n        \\n        vis.resize(n+1,false); \\n        count.resize(n+1,0);\\n        \\n        for(auto i : roads){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n            \\n        }\\n        subtree(0,-1);\\n       \\n        return dfs(0,seats);\\n        return 0 ; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    #define ll long long int \\n    map<int,vector<int>>g ; \\n    vector<bool>vis;\\n    vector<int>count;\\n    void subtree(int node,int par){\\n        count[node] = 1 ; \\n        for(auto child : g[node]){\\n            if(child != par){\\n                subtree(child,node);\\n                count[node] = count[node] + count[child];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3178987,
                "title": "java-using-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static ArrayList<List<Integer>> list=new ArrayList<>();\\n    static int distance[];\\n    public void dfs(int node)\\n    {\\n        distance[node]=1;\\n        for(int i:list.get(node))\\n        {\\n            if(distance[i]==0){\\n                dfs(i);\\n                distance[node]+=distance[i];\\n            }\\n        }\\n        return ;\\n\\n    }\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        for(int i=0;i<=roads.length;i++) list.add(new ArrayList<>());\\n        for(int i[]:roads)\\n        {\\n            list.get(i[0]).add(i[1]);\\n            list.get(i[1]).add(i[0]);\\n        }\\n        distance=new int[list.size()];\\n        dfs(0);\\n        long res=0;\\n        for(int i=1;i<distance.length;i++){\\n            res+=(distance[i]/seats);\\n            if(distance[i]%seats!=0)res++;\\n        }\\n        list=new ArrayList<>();\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static ArrayList<List<Integer>> list=new ArrayList<>();\\n    static int distance[];\\n    public void dfs(int node)\\n    {\\n        distance[node]=1;\\n        for(int i:list.get(node))\\n        {\\n            if(distance[i]==0){\\n                dfs(i);\\n                distance[node]+=distance[i];\\n            }\\n        }\\n        return ;\\n\\n    }\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        for(int i=0;i<=roads.length;i++) list.add(new ArrayList<>());\\n        for(int i[]:roads)\\n        {\\n            list.get(i[0]).add(i[1]);\\n            list.get(i[1]).add(i[0]);\\n        }\\n        distance=new int[list.size()];\\n        dfs(0);\\n        long res=0;\\n        for(int i=1;i<distance.length;i++){\\n            res+=(distance[i]/seats);\\n            if(distance[i]%seats!=0)res++;\\n        }\\n        list=new ArrayList<>();\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175321,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\tpublic long minimumFuelCost(int[][] roads, int seats) {\\n\\t\\tList<Integer>[] graph = new List[roads.length + 1];\\n\\n\\t\\tfor (int i = 0; i < graph.length; ++i)\\n\\t\\t\\tgraph[i] = new ArrayList<>();\\n\\n\\t\\tfor (int[] road : roads) {\\n\\t\\t\\tfinal int u = road[0];\\n\\t\\t\\tfinal int v = road[1];\\n\\t\\t\\tgraph[u].add(v);\\n\\t\\t\\tgraph[v].add(u);\\n\\t\\t}\\n\\n\\t\\tdfs(graph, 0, -1, seats);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate long ans = 0;\\n\\n\\tprivate int dfs(List<Integer>[] graph, int u, int prev, int seats) {\\n\\t\\tint people = 1;\\n\\t\\tfor (final int v : graph[u]) {\\n\\t\\t\\tif (v == prev)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tpeople += dfs(graph, v, u, seats);\\n\\t\\t}\\n\\t\\tif (u > 0)\\n\\t\\t\\tans += (people + seats - 1) / seats;\\n\\t\\treturn people;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic long minimumFuelCost(int[][] roads, int seats) {\\n\\t\\tList<Integer>[] graph = new List[roads.length + 1];\\n\\n\\t\\tfor (int i = 0; i < graph.length; ++i)\\n\\t\\t\\tgraph[i] = new ArrayList<>();\\n\\n\\t\\tfor (int[] road : roads) {\\n\\t\\t\\tfinal int u = road[0];\\n\\t\\t\\tfinal int v = road[1];\\n\\t\\t\\tgraph[u].add(v);\\n\\t\\t\\tgraph[v].add(u);\\n\\t\\t}\\n\\n\\t\\tdfs(graph, 0, -1, seats);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate long ans = 0;\\n\\n\\tprivate int dfs(List<Integer>[] graph, int u, int prev, int seats) {\\n\\t\\tint people = 1;\\n\\t\\tfor (final int v : graph[u]) {\\n\\t\\t\\tif (v == prev)\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tpeople += dfs(graph, v, u, seats);\\n\\t\\t}\\n\\t\\tif (u > 0)\\n\\t\\t\\tans += (people + seats - 1) / seats;\\n\\t\\treturn people;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174785,
                "title": "java-dfs-simple-and-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int n;\\n  List<Integer>[] adj;\\n  long liters = 0L;\\n\\n  private int dfs(int seats, int city, int parent) {\\n    var reps = 1;\\n\\n    for (var adjCity : adj[city])\\n      if (adjCity != parent)\\n        reps += dfs(seats, adjCity, city);\\n\\n    if (city != 0)\\n      liters += (long) Math.ceil((double) reps / seats);\\n\\n    return reps;\\n  }\\n\\n  public long minimumFuelCost(int[][] roads, int seats) {\\n    n = roads.length + 1;\\n    adj = new ArrayList[n];\\n\\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n\\n    for (var road : roads) {\\n      adj[road[0]].add(road[1]);\\n      adj[road[1]].add(road[0]);\\n    }\\n    dfs(seats, 0, -1);\\n\\n    return liters;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n  int n;\\n  List<Integer>[] adj;\\n  long liters = 0L;\\n\\n  private int dfs(int seats, int city, int parent) {\\n    var reps = 1;\\n\\n    for (var adjCity : adj[city])\\n      if (adjCity != parent)\\n        reps += dfs(seats, adjCity, city);\\n\\n    if (city != 0)\\n      liters += (long) Math.ceil((double) reps / seats);\\n\\n    return reps;\\n  }\\n\\n  public long minimumFuelCost(int[][] roads, int seats) {\\n    n = roads.length + 1;\\n    adj = new ArrayList[n];\\n\\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n\\n    for (var road : roads) {\\n      adj[road[0]].add(road[1]);\\n      adj[road[1]].add(road[0]);\\n    }\\n    dfs(seats, 0, -1);\\n\\n    return liters;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174223,
                "title": "c-easy-understandable",
                "content": "# DO UPVOTE PLEASE\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used here is depth first search (DFS).\\n\\nHere\\'s a step-by-step explanation of the code:\\n\\nThe minimumFuelCost function takes a 2D vector roads that represents the roads between different locations and an integer seats representing the number of seats in each car.\\n\\nIt creates an unordered map gp that maps each location to a vector of locations connected to it by roads.\\n\\nThe function initializes a vector v with v.resize(roads.size() + 1, 0) to keep track of which locations have been visited during the DFS.\\n\\nIt then loops through each location connected to the starting location 0 and starts the DFS from that location.\\n\\nThe getCarsAndPerson function takes the gp unordered map, the current location curr, and the number of seats in each car seats as inputs.\\n\\nThe function initializes two variables car and persons to keep track of the number of cars required and the number of people at the current location.\\n\\nIt sets the current location as visited by setting v[curr] = 1.\\n\\nThe function then loops through each location connected to the current location and starts the DFS from that location, using the getCarsAndPerson function recursively.\\n\\nThe getCarsAndPerson function returns the number of cars required and the number of people at the current location as a pair.\\n\\nThe minimumFuelCost function adds the number of cars required to the global variable count to keep track of the total number of cars required.\\n\\nFinally, the minimumFuelCost function returns the value of count, which represents the minimum fuel cost required to transport the group of people.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this approach is O(n), where n is the number of locations. This is because each location is visited exactly once during the DFS.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this approach is O(n), where n is the number of locations. This is because the v vector is used to keep track of the visited locations, and its size is proportional to the number of locations.\\n# Code\\n```\\nclass Solution {\\n    long long count = 0;\\n    vector<int> v;\\n    pair<long long, long long> getCarsAndPerson(unordered_map<int, vector<int>>& gp, int curr, int seats) {\\n        long long car = 0, persons = 1;\\n        v[curr] = 1;\\n        for (auto val: gp[curr]) {\\n            if (v[val]) continue;\\n            auto carsAndPerson = getCarsAndPerson(gp, val, seats);\\n            car = car + carsAndPerson.first;\\n            persons += carsAndPerson.second;\\n            \\n        }\\n        count = count + car;\\n        return {ceil(persons/(seats * 1.0)) , persons};\\n    }\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        unordered_map<int, vector<int>> gp;\\n        for (auto road: roads) {\\n            gp[road[0]].push_back(road[1]);\\n            gp[road[1]].push_back(road[0]);\\n        }\\n        v.resize(roads.size() + 1, 0);\\n        \\n        for (auto val: gp[0]) {\\n            v[0] = 1;\\n            auto carsAndPerson = getCarsAndPerson(gp, val, seats);\\n            count = count + carsAndPerson.first;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    long long count = 0;\\n    vector<int> v;\\n    pair<long long, long long> getCarsAndPerson(unordered_map<int, vector<int>>& gp, int curr, int seats) {\\n        long long car = 0, persons = 1;\\n        v[curr] = 1;\\n        for (auto val: gp[curr]) {\\n            if (v[val]) continue;\\n            auto carsAndPerson = getCarsAndPerson(gp, val, seats);\\n            car = car + carsAndPerson.first;\\n            persons += carsAndPerson.second;\\n            \\n        }\\n        count = count + car;\\n        return {ceil(persons/(seats * 1.0)) , persons};\\n    }\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        unordered_map<int, vector<int>> gp;\\n        for (auto road: roads) {\\n            gp[road[0]].push_back(road[1]);\\n            gp[road[1]].push_back(road[0]);\\n        }\\n        v.resize(roads.size() + 1, 0);\\n        \\n        for (auto val: gp[0]) {\\n            v[0] = 1;\\n            auto carsAndPerson = getCarsAndPerson(gp, val, seats);\\n            count = count + carsAndPerson.first;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173927,
                "title": "easy-c-bfs-solution-with-full-intuition-and-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt any particular node, the number of cars needed to travel to the adjacent node is the ceil value of number of people currently at that node divided by the number of seats available in each car.\\nSo, from each leaves we have to reach the centre (0).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWill do BFS. \\nMake two arrays of size n, degree and people. Degree stores the number of edges connected to that node and people will store the number of peoples currently at that node.\\nTake a queue and push all the leaf nodes in it, because at each leaf node only one people is present. At every step, decrease the degree of adjacent node and when it becomes 1, push it into the queue.\\nMeanwhile, add the number of peoples for each node and calculate the number of cars needed to go at the adjacent node.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n=roads.size()+1;\\n        vector<int> g[n];\\n        vector<int> deg(n, 0);\\n        for (auto i: roads){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n            deg[i[0]]++;\\n            deg[i[1]]++;\\n        }\\n        vector<int> people(n, 1);\\n        queue<int> q;\\n        for (int i=0; i<n; i++){\\n            if (deg[i]==1)\\n                q.push(i);\\n        }\\n        long long ans=0;\\n        while (!q.empty()){\\n            int sz=q.size();\\n            while (sz--){\\n                int p=q.front(); q.pop();\\n                if (p==0) break;\\n                ans += ceil(people[p]*1.0/seats);\\n                for (int v: g[p]){\\n                    deg[v]--;\\n                    people[v]+=people[p];\\n                    if (deg[v]==1)\\n                        q.push(v);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n=roads.size()+1;\\n        vector<int> g[n];\\n        vector<int> deg(n, 0);\\n        for (auto i: roads){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n            deg[i[0]]++;\\n            deg[i[1]]++;\\n        }\\n        vector<int> people(n, 1);\\n        queue<int> q;\\n        for (int i=0; i<n; i++){\\n            if (deg[i]==1)\\n                q.push(i);\\n        }\\n        long long ans=0;\\n        while (!q.empty()){\\n            int sz=q.size();\\n            while (sz--){\\n                int p=q.front(); q.pop();\\n                if (p==0) break;\\n                ans += ceil(people[p]*1.0/seats);\\n                for (int v: g[p]){\\n                    deg[v]--;\\n                    people[v]+=people[p];\\n                    if (deg[v]==1)\\n                        q.push(v);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173883,
                "title": "c-java-detailed-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MinimumFuelCost(int[][] roads, int seats) {\\n        Dictionary<int, HashSet<int>> graph = new Dictionary<int, HashSet<int>>();\\n        Dictionary<int, int> Indegree = new Dictionary<int, int>();\\n        Dictionary<int, int> currentPassengers = new Dictionary<int, int>();\\n        foreach (int[] road in roads) {\\n            graph.TryAdd(road[0], new HashSet<int>());\\n            graph.TryAdd(road[1], new HashSet<int>());\\n            graph[road[0]].Add(road[1]);\\n            graph[road[1]].Add(road[0]);\\n\\n            Indegree.TryAdd(road[0], 0);\\n            Indegree.TryAdd(road[1], 0);\\n            Indegree[road[0]]++;\\n            Indegree[road[1]]++;\\n        }\\n\\n        int nodesCount = graph.Count;\\n        for (int i = 0; i < nodesCount; i++){\\n            currentPassengers[i]=1;\\n        }\\n\\n        Queue<int> queue = new Queue<int>();\\n        for (int i = 1; i < nodesCount; i++) {\\n            if (Indegree[i] == 1)\\n            {\\n                queue.Enqueue(i);\\n            }\\n        }\\n\\n        long result = 0;\\n        while(queue.Any()) {\\n            int count = queue.Count;\\n            for (int i = 0; i < count; i++){\\n                int currNode = queue.Dequeue();\\n                int parentNode = graph[currNode].First();\\n                graph.Remove(currNode);\\n                graph[parentNode].Remove(currNode);\\n                Indegree[parentNode]--;\\n                if (Indegree[parentNode] == 1 && parentNode != 0)\\n                    queue.Enqueue(parentNode);\\n\\n                currentPassengers[parentNode]+= currentPassengers[currNode];\\n               \\n                result += ((currentPassengers[currNode]-1) / seats) + 1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\npublic class Solution {\\n    public long MinimumFuelCost(int[][] roads, int seats) {\\n        Dictionary<int, HashSet<int>> graph = new Dictionary<int, HashSet<int>>();\\n        Dictionary<int, int> Indegree = new Dictionary<int, int>();\\n        Dictionary<int, int> currentPassengers = new Dictionary<int, int>();\\n        foreach (int[] road in roads) {\\n            graph.TryAdd(road[0], new HashSet<int>());\\n            graph.TryAdd(road[1], new HashSet<int>());\\n            graph[road[0]].Add(road[1]);\\n            graph[road[1]].Add(road[0]);\\n\\n            Indegree.TryAdd(road[0], 0);\\n            Indegree.TryAdd(road[1], 0);\\n            Indegree[road[0]]++;\\n            Indegree[road[1]]++;\\n        }\\n\\n        int nodesCount = graph.Count;\\n        for (int i = 0; i < nodesCount; i++){\\n            currentPassengers[i]=1;\\n        }\\n\\n        Queue<int> queue = new Queue<int>();\\n        for (int i = 1; i < nodesCount; i++) {\\n            if (Indegree[i] == 1)\\n            {\\n                queue.Enqueue(i);\\n            }\\n        }\\n\\n        long result = 0;\\n        while(queue.Any()) {\\n            int count = queue.Count;\\n            for (int i = 0; i < count; i++){\\n                int currNode = queue.Dequeue();\\n                int parentNode = graph[currNode].First();\\n                graph.Remove(currNode);\\n                graph[parentNode].Remove(currNode);\\n                Indegree[parentNode]--;\\n                if (Indegree[parentNode] == 1 && parentNode != 0)\\n                    queue.Enqueue(parentNode);\\n\\n                currentPassengers[parentNode]+= currentPassengers[currNode];\\n               \\n                result += ((currentPassengers[currNode]-1) / seats) + 1;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832463,
                "title": "simple-java-bfs-o-n-solution-71ms-runtime",
                "content": "Idea is to go from leaf to 0th node. Then it is similar to topological sort using BFS.\\n```\\nclass Solution {\\n    List<List<Integer>> buildGraph(int [][] roads,int V){\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<V;i++)\\n            adj.add(new ArrayList<>());\\n        for(int [] road:roads){\\n            adj.get(road[0]).add(road[1]);\\n            adj.get(road[1]).add(road[0]);\\n        }\\n        return adj;\\n    }\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        int V=roads.length+1;\\n        List<List<Integer>> adj=buildGraph(roads,V);\\n        Queue<Integer> q=new LinkedList<>();\\n        \\n\\t\\t//Storing total edges of a node using which we will traverse the tree,\\n\\t\\t//If a non zero node have 1 edge then that node is kind of a leaf and we can take it\\n        int [] edges=new int[V];\\n        for(int i=0;i<V;i++){\\n            edges[i]=adj.get(i).size();\\n            if(i!=0&&edges[i]==1)\\n                q.add(i);\\n        }\\n    \\n        long fuel=0;\\n\\t\\t//Storing total person on each node initially 1 person is at every node\\n        int [] totalMen=new int[V];\\n        Arrays.fill(totalMen,1);\\n        while(!q.isEmpty()){\\n            int u=q.remove();\\n\\t\\t\\t//Travelling from u to v,\\n\\t\\t\\t//There will be only 1 valid node wich will satisfy edges[v]>0 as u has only 1 valid edge\\n            for(int v:adj.get(u)){\\n\\t\\t\\t   // A visited node will have 0 edges as we are decreasing no of nodes for both src and dest,\\n\\t\\t\\t   //after visiting each node\\n                if(edges[v]>0){\\n                    int cars=totalMen[u]/seats;\\n                    if(totalMen[u]%seats!=0)\\n                        cars++;\\n\\t\\t\\t\\t   // From node u to node v we need \" petrol equal to no. of cars required\\n                    fuel+=cars;\\n\\t\\t\\t\\t\\t//All people from node u now have reached to node v, so to remember that we are \\n\\t\\t\\t\\t\\t//incrementing it\\n                    totalMen[v]+=totalMen[u];\\n                    edges[v]--;\\n                    edges[u]--;\\n\\t\\t\\t\\t\\t//Only add those nodes which are non-root and have become leaf now i.e., \\n\\t\\t\\t\\t\\t//only on one way they can go(That path will eventually make it meet root node)\\n                    if(v!=0&&edges[v]==1)\\n                        q.add(v);\\n                }\\n            }\\n        }\\n        \\n        return fuel;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> buildGraph(int [][] roads,int V){\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<V;i++)\\n            adj.add(new ArrayList<>());\\n        for(int [] road:roads){\\n            adj.get(road[0]).add(road[1]);\\n            adj.get(road[1]).add(road[0]);\\n        }\\n        return adj;\\n    }\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        int V=roads.length+1;\\n        List<List<Integer>> adj=buildGraph(roads,V);\\n        Queue<Integer> q=new LinkedList<>();\\n        \\n\\t\\t//Storing total edges of a node using which we will traverse the tree,\\n\\t\\t//If a non zero node have 1 edge then that node is kind of a leaf and we can take it\\n        int [] edges=new int[V];\\n        for(int i=0;i<V;i++){\\n            edges[i]=adj.get(i).size();\\n            if(i!=0&&edges[i]==1)\\n                q.add(i);\\n        }\\n    \\n        long fuel=0;\\n\\t\\t//Storing total person on each node initially 1 person is at every node\\n        int [] totalMen=new int[V];\\n        Arrays.fill(totalMen,1);\\n        while(!q.isEmpty()){\\n            int u=q.remove();\\n\\t\\t\\t//Travelling from u to v,\\n\\t\\t\\t//There will be only 1 valid node wich will satisfy edges[v]>0 as u has only 1 valid edge\\n            for(int v:adj.get(u)){\\n\\t\\t\\t   // A visited node will have 0 edges as we are decreasing no of nodes for both src and dest,\\n\\t\\t\\t   //after visiting each node\\n                if(edges[v]>0){\\n                    int cars=totalMen[u]/seats;\\n                    if(totalMen[u]%seats!=0)\\n                        cars++;\\n\\t\\t\\t\\t   // From node u to node v we need \" petrol equal to no. of cars required\\n                    fuel+=cars;\\n\\t\\t\\t\\t\\t//All people from node u now have reached to node v, so to remember that we are \\n\\t\\t\\t\\t\\t//incrementing it\\n                    totalMen[v]+=totalMen[u];\\n                    edges[v]--;\\n                    edges[u]--;\\n\\t\\t\\t\\t\\t//Only add those nodes which are non-root and have become leaf now i.e., \\n\\t\\t\\t\\t\\t//only on one way they can go(That path will eventually make it meet root node)\\n                    if(v!=0&&edges[v]==1)\\n                        q.add(v);\\n                }\\n            }\\n        }\\n        \\n        return fuel;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831957,
                "title": "python-topological-sort",
                "content": "Count the cost layer by layer.\\n```python\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        graph = defaultdict(list)\\n        incoming = Counter()\\n        size = Counter()\\n\\n        for u, v in roads:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            incoming[u] += 1\\n            incoming[v] += 1\\n            size[u] = size[v] = 1\\n\\n        q = deque([i for i in incoming if incoming[i] == 1])\\n        res = 0\\n        while q:\\n            curr = q.popleft()\\n            if curr == 0:\\n                continue\\n\\n            for nxt in graph[curr]:\\n                d, r = divmod(size[curr], seats)\\n                res += d + 1 if r else d\\n                size[nxt] += size[curr]\\n                size[curr] = 0\\n                incoming[nxt] -= 1\\n                if incoming[nxt] == 1:\\n                    q.append(nxt)\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        graph = defaultdict(list)\\n        incoming = Counter()\\n        size = Counter()\\n\\n        for u, v in roads:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n            incoming[u] += 1\\n            incoming[v] += 1\\n            size[u] = size[v] = 1\\n\\n        q = deque([i for i in incoming if incoming[i] == 1])\\n        res = 0\\n        while q:\\n            curr = q.popleft()\\n            if curr == 0:\\n                continue\\n\\n            for nxt in graph[curr]:\\n                d, r = divmod(size[curr], seats)\\n                res += d + 1 if r else d\\n                size[nxt] += size[curr]\\n                size[curr] = 0\\n                incoming[nxt] -= 1\\n                if incoming[nxt] == 1:\\n                    q.append(nxt)\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831735,
                "title": "c-simple-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we keep number of cars and number of people at each city (node), we can calculate number of required cars and fuel accordingly\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse dfs to reach farthest node, return number of cars and person from that node. At current node, divide number of persons by number of maxSeats to get cars. return car, and number of person\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    long long count = 0;\\n    vector<int> v;\\n    pair<long long, long long> getCarsAndPerson(unordered_map<int, vector<int>>& gp, int curr, int seats) {\\n        long long car = 0, persons = 1;\\n        v[curr] = 1;\\n        for (auto val: gp[curr]) {\\n            if (v[val]) continue;\\n            auto carsAndPerson = getCarsAndPerson(gp, val, seats);\\n            car = car + carsAndPerson.first;\\n            persons += carsAndPerson.second;\\n            \\n        }\\n        count = count + car;\\n        return {ceil(persons/(seats * 1.0)) , persons};\\n    }\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        unordered_map<int, vector<int>> gp;\\n        for (auto road: roads) {\\n            gp[road[0]].push_back(road[1]);\\n            gp[road[1]].push_back(road[0]);\\n        }\\n        v.resize(roads.size() + 1, 0);\\n        \\n        for (auto val: gp[0]) {\\n            v[0] = 1;\\n            auto carsAndPerson = getCarsAndPerson(gp, val, seats);\\n            count = count + carsAndPerson.first;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    long long count = 0;\\n    vector<int> v;\\n    pair<long long, long long> getCarsAndPerson(unordered_map<int, vector<int>>& gp, int curr, int seats) {\\n        long long car = 0, persons = 1;\\n        v[curr] = 1;\\n        for (auto val: gp[curr]) {\\n            if (v[val]) continue;\\n            auto carsAndPerson = getCarsAndPerson(gp, val, seats);\\n            car = car + carsAndPerson.first;\\n            persons += carsAndPerson.second;\\n            \\n        }\\n        count = count + car;\\n        return {ceil(persons/(seats * 1.0)) , persons};\\n    }\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        unordered_map<int, vector<int>> gp;\\n        for (auto road: roads) {\\n            gp[road[0]].push_back(road[1]);\\n            gp[road[1]].push_back(road[0]);\\n        }\\n        v.resize(roads.size() + 1, 0);\\n        \\n        for (auto val: gp[0]) {\\n            v[0] = 1;\\n            auto carsAndPerson = getCarsAndPerson(gp, val, seats);\\n            count = count + carsAndPerson.first;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3202604,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> g[100005];\\n    long long fuel;\\n    int seat;\\n\\n    long long dfs(int u, int par) {\\n        int rep = 1;\\n        for(auto v: g[u]) {\\n            if(v != par) {\\n                rep += dfs(v, u);\\n            }\\n        }\\n        if(u != 0) {\\n            fuel += ceil((double) rep / seat);\\n        }\\n        return rep;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size() + 1;\\n        seat = seats;\\n        for(auto x: roads) {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n        dfs(0, -1);\\n        return fuel;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> g[100005];\\n    long long fuel;\\n    int seat;\\n\\n    long long dfs(int u, int par) {\\n        int rep = 1;\\n        for(auto v: g[u]) {\\n            if(v != par) {\\n                rep += dfs(v, u);\\n            }\\n        }\\n        if(u != 0) {\\n            fuel += ceil((double) rep / seat);\\n        }\\n        return rep;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size() + 1;\\n        seat = seats;\\n        for(auto x: roads) {\\n            g[x[0]].push_back(x[1]);\\n            g[x[1]].push_back(x[0]);\\n        }\\n        dfs(0, -1);\\n        return fuel;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182516,
                "title": "super-simple-only-15-lines-code-c-python-dfs-proper-explanation-with-clean-diagram",
                "content": "\\n\\n# Approach/Main Logic\\nThe logic behind the solution is to find the number of nodes in the subtree of each node and calculate the cost of reaching the node. The cost of reaching a node is equal to the sum of total number of cars reached at all of its children. To calculate the number of nodes in the subtree of each node, we use DFS (depth-first search) approach.\\n\\n# Diagram \\n![leetcode img.png](https://assets.leetcode.com/users/images/132c4ea3-d047-4e39-9f18-f0917c3b0c8f_1676322737.1071575.png)\\n\\n\\n# Algorithm:\\n\\n1. Create the graph using the roads array.\\n\\n1. Define a dfs function to find the number of nodes in the subtree of each node. This function takes 3 parameters: root node, parent node, graph and seats.\\n\\n1. In the dfs function, initialize a counter to keep track of the number of nodes in the subtree.\\n\\n1. Loop through the neighbors of the root node and call the dfs function on the neighbor node and pass the root node as its parent.\\n\\n1. Calculate the number of cars required to reach the parent node. The number of cars = ceil (number of nodes in the subtree of the root node / seats).\\n\\n1. Add the number of cars to the fuel.\\n\\n1. Return the number of nodes in the subtree (cnt + 1) to include the root node in the subtree.\\n\\n1. Call the dfs function from the root node (0) and initialize the fuel to 0.\\n\\nReturn the fuel.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    /*\\n    This below dfs function will take the node and its parent node(par=-1 for 0) and return total\\n    number of nodes present in the subtree of node.\\n    */\\n    int dfs(int root,int par,vector<vector<int>>&g,int &seats,long long &fuel)\\n    {\\n        int cnt=0;\\n        for(auto node:g[root])\\n        {\\n            if(node==par) continue;\\n            int val=dfs(node,root,g,seats,fuel);\\n            fuel+=ceil((double)val/seats);\\n            cnt+=val;\\n        }\\n        return cnt+1; //return cnt+1 to take care that the root itself is included in subtree\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n    vector<vector<int>> g(roads.size()+1); //creating the graph\\n    for(auto &v:roads)\\n    {\\n        g[v[0]].push_back(v[1]); g[v[1]].push_back(v[0]);\\n    }\\n    long long fuel=0;\\n    dfs(0,-1,g,seats,fuel);\\n    return fuel;**Bold**\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def dfs(self, root, par, g, seats,fuel):\\n        cnt = 0\\n        for node in g[root]:\\n            if node == par:\\n                continue\\n            val = self.dfs(node, root, g, seats,fuel)\\n            fuel[0] += math.ceil(val/seats)\\n            cnt += val\\n        return cnt + 1\\n\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        g = [[] for _ in range(len(roads)+1)] #creating the graph\\n        for v in roads:\\n            g[v[0]].append(v[1])\\n            g[v[1]].append(v[0]) \\n        fuel=[0]\\n        self.dfs(0, -1, g, seats,fuel)\\n        return fuel[0]\\n    \\n```\\n\\n```\\n                Please upvote \\uD83D\\uDC4D if you find the solution helpful.\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/abhijit-kumar--/)\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    /*\\n    This below dfs function will take the node and its parent node(par=-1 for 0) and return total\\n    number of nodes present in the subtree of node.\\n    */\\n    int dfs(int root,int par,vector<vector<int>>&g,int &seats,long long &fuel)\\n    {\\n        int cnt=0;\\n        for(auto node:g[root])\\n        {\\n            if(node==par) continue;\\n            int val=dfs(node,root,g,seats,fuel);\\n            fuel+=ceil((double)val/seats);\\n            cnt+=val;\\n        }\\n        return cnt+1; //return cnt+1 to take care that the root itself is included in subtree\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n    vector<vector<int>> g(roads.size()+1); //creating the graph\\n    for(auto &v:roads)\\n    {\\n        g[v[0]].push_back(v[1]); g[v[1]].push_back(v[0]);\\n    }\\n    long long fuel=0;\\n    dfs(0,-1,g,seats,fuel);\\n    return fuel;**Bold**\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def dfs(self, root, par, g, seats,fuel):\\n        cnt = 0\\n        for node in g[root]:\\n            if node == par:\\n                continue\\n            val = self.dfs(node, root, g, seats,fuel)\\n            fuel[0] += math.ceil(val/seats)\\n            cnt += val\\n        return cnt + 1\\n\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        g = [[] for _ in range(len(roads)+1)] #creating the graph\\n        for v in roads:\\n            g[v[0]].append(v[1])\\n            g[v[1]].append(v[0]) \\n        fuel=[0]\\n        self.dfs(0, -1, g, seats,fuel)\\n        return fuel[0]\\n    \\n```\n```\\n                Please upvote \\uD83D\\uDC4D if you find the solution helpful.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176890,
                "title": "python3-1895-ms-faster-than-94-70-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/db6c1909-bb3b-4f52-aef0-79f4d6b937e0_1676220621.272411.png)\\n\\n```\\ndef minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        adjacency_list = defaultdict(list)\\n        for a, b in roads:\\n            adjacency_list[a].append(b)\\n            adjacency_list[b].append(a)            \\n        total_fuel_cost = [0]        \\n        def dfs(node, parent):\\n            people = 1            \\n            for neighbor in adjacency_list[node]:\\n                if neighbor == parent:\\n                    continue\\n                people += dfs(neighbor, node)                \\n            if node != 0:\\n                total_fuel_cost[0] += math.ceil(people / seats)                \\n            return people        \\n        dfs(0, None)\\n        return total_fuel_cost[0]\\n```\\nThis code calculates the minimum fuel cost required to reach the capital city from all other cities. The code follows the following steps:\\n1. Creation of adjacency list: The input roads list is converted into an adjacency list representation, where each city is a key and its corresponding neighbors are stored in a list. The dictionary adjacency_list is used for this purpose.\\n1. Initializing the fuel cost: A list total_fuel_cost is created with a single element to store the minimum fuel cost, initialized to 0.\\n1. Defining the DFS function: A recursive DFS function dfs is defined, which takes two arguments: the current node being processed and its parent node.\\n1. Keeping track of the people: In each call of the DFS function, a variable people is used to keep track of the total number of people in the subtree rooted at the current node. Initially, the number of people is set to 1 to account for the person at the current node.\\n1. Processing the neighbors: For each neighbor of the current node, the DFS function is called, and the number of people in the subtree rooted at the neighbor is added to the variable people. If the neighbor is the same as the parent, the loop continues to the next neighbor to avoid visiting the same node twice.\\n1. Adding the fuel cost: If the current node is not the capital city (node 0), then the fuel cost to reach the capital city from this node is calculated. The formula used to calculate the fuel cost is math.ceil(people / seats). This cost is then added to the total fuel cost stored in total_fuel_cost[0].\\n1. Returning the people: Finally, the function returns the number of people in the subtree rooted at the current node.\\n1. Calling the DFS function: The DFS function is called with node 0 and None as the parent, which signifies that node 0 is the root of the tree and has no parent.\\n1. Returning the result: The final result, which is the minimum fuel cost, is returned by the main function.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Queue"
                ],
                "code": "```\\ndef minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        adjacency_list = defaultdict(list)\\n        for a, b in roads:\\n            adjacency_list[a].append(b)\\n            adjacency_list[b].append(a)            \\n        total_fuel_cost = [0]        \\n        def dfs(node, parent):\\n            people = 1            \\n            for neighbor in adjacency_list[node]:\\n                if neighbor == parent:\\n                    continue\\n                people += dfs(neighbor, node)                \\n            if node != 0:\\n                total_fuel_cost[0] += math.ceil(people / seats)                \\n            return people        \\n        dfs(0, None)\\n        return total_fuel_cost[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3176157,
                "title": "dfs-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt can be observed that the problem can be solved using a single pass DFS.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS through every adjacent vertex to 0 and return the total number of passengers travelling from the nth city when returning the function.\\nUpdate res variable before returning to sum the fuel cost.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        adjacencyList = [[] for i in range(len(roads) + 1)]\\n        res = [0]\\n        for road in roads : \\n            adjacencyList[road[0]].append(road[1])\\n            adjacencyList[road[1]].append(road[0])\\n        visited = [0 for i in range(len(roads) + 1)]\\n        visited[0]=1\\n        def dfs(i,visited):\\n            if visited[i] == 1:\\n                return 0\\n            visited[i] = 1\\n            tot = 1\\n            for k in adjacencyList[i]:\\n                tot += dfs(k,visited)\\n            if tot%seats == 0:\\n                res[0] += tot//seats\\n            else :\\n                res[0] += tot//seats + 1\\n            return tot\\n        for i in adjacencyList[0]:\\n            total = dfs(i,visited)\\n        return res[0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        adjacencyList = [[] for i in range(len(roads) + 1)]\\n        res = [0]\\n        for road in roads : \\n            adjacencyList[road[0]].append(road[1])\\n            adjacencyList[road[1]].append(road[0])\\n        visited = [0 for i in range(len(roads) + 1)]\\n        visited[0]=1\\n        def dfs(i,visited):\\n            if visited[i] == 1:\\n                return 0\\n            visited[i] = 1\\n            tot = 1\\n            for k in adjacencyList[i]:\\n                tot += dfs(k,visited)\\n            if tot%seats == 0:\\n                res[0] += tot//seats\\n            else :\\n                res[0] += tot//seats + 1\\n            return tot\\n        for i in adjacencyList[0]:\\n            total = dfs(i,visited)\\n        return res[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175778,
                "title": "c-easy-code-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n    #define ll long long\\n    long long ans=0;\\npublic:\\n    ll dfs(vector<ll>ad[],ll t,ll sr,ll p){\\n        bool f=false;\\n        long long tt=0;\\n        for(auto x : ad[sr]){\\n            if(p!=x){\\n              f=true;\\n             long long j=dfs(ad,t,x,sr)+1;\\n              tt+=j;\\n              ll k=j%t;\\n              if(k)k=1;\\n              ans+=j/t+k;\\n            }\\n        }\\n        if(!f){\\n            return 0;\\n        }\\n        return tt;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& r, int t) {\\n        int n=r.size();\\n        vector<ll>ad[n+1];\\n        for(int i=0;i<n;i++){\\n            ad[r[i][0]].push_back(r[i][1]);\\n            ad[r[i][1]].push_back(r[i][0]);\\n        }\\n        long long tt=dfs(ad,t,0,-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\n    long long ans=0;\\npublic:\\n    ll dfs(vector<ll>ad[],ll t,ll sr,ll p){\\n        bool f=false;\\n        long long tt=0;\\n        for(auto x : ad[sr]){\\n            if(p!=x){\\n              f=true;\\n             long long j=dfs(ad,t,x,sr)+1;\\n              tt+=j;\\n              ll k=j%t;\\n              if(k)k=1;\\n              ans+=j/t+k;\\n            }\\n        }\\n        if(!f){\\n            return 0;\\n        }\\n        return tt;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& r, int t) {\\n        int n=r.size();\\n        vector<ll>ad[n+1];\\n        for(int i=0;i<n;i++){\\n            ad[r[i][0]].push_back(r[i][1]);\\n            ad[r[i][1]].push_back(r[i][0]);\\n        }\\n        long long tt=dfs(ad,t,0,-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175667,
                "title": "python-easy-to-understand-multi-source-bfs",
                "content": "# Approach\\n###### Perform BFS from leaf nodes to root node and compute the number of representatives in each node\\'s subtree and use that to calculate the required fuel.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        n = len(roads) + 1\\n        graph = defaultdict(list)\\n        degree = [0]*n\\n        representatives = [1]*n\\n        for a, b in roads:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            degree[a] += 1\\n            degree[b] += 1\\n        queue = deque()\\n        for i in range(1, n):\\n            if degree[i] == 1: queue.append(i)\\n        ans = 0\\n        while queue:\\n            city = queue.popleft()\\n            ans += ceil(representatives[city] / seats)\\n            for neighbour in graph[city]:\\n                degree[neighbour] -= 1\\n                representatives[neighbour] += representatives[city]\\n                if degree[neighbour] == 1 and neighbour != 0:\\n                    queue.append(neighbour)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        n = len(roads) + 1\\n        graph = defaultdict(list)\\n        degree = [0]*n\\n        representatives = [1]*n\\n        for a, b in roads:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n            degree[a] += 1\\n            degree[b] += 1\\n        queue = deque()\\n        for i in range(1, n):\\n            if degree[i] == 1: queue.append(i)\\n        ans = 0\\n        while queue:\\n            city = queue.popleft()\\n            ans += ceil(representatives[city] / seats)\\n            for neighbour in graph[city]:\\n                degree[neighbour] -= 1\\n                representatives[neighbour] += representatives[city]\\n                if degree[neighbour] == 1 and neighbour != 0:\\n                    queue.append(neighbour)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175422,
                "title": "100-solution-using-depth-first-search-minimum-fuel-cost-to-report-to-the-capital",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    long minFuel = 0;\\n\\n    public double dfs(Map<Integer, List<Integer>> adj,int node,int prev,int seats) {\\n        double representatives = 1;\\n        if (!adj.containsKey(node)) {\\n            return representatives;\\n        }\\n\\n        for (int next : adj.get(node))\\n            if (next!=prev)\\n                representatives += dfs(adj,next,node,seats);\\n\\n        if (node != 0)\\n            minFuel += Math.ceil(representatives/seats);\\n\\n        return representatives;\\n    }\\n\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        Map<Integer, List<Integer>> adj = new HashMap<>();\\n        for (int[] road : roads) {\\n            adj.computeIfAbsent(road[0], k -> new ArrayList<Integer>()).add(road[1]);\\n            adj.computeIfAbsent(road[1], k -> new ArrayList<Integer>()).add(road[0]);\\n        }\\n        dfs(adj,0,-1,seats);\\n        return minFuel;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    long long minFuel = 0;\\n    double dfs(vector<vector<int>>& adj,int node, int prev,int& seats)\\n    {\\n        double representatives = 1;\\n        \\n        for(auto& next: adj[node])\\n            if(next!=prev)\\n                representatives += dfs(adj,next,node,seats);\\n\\n        if(node!=0)\\n            minFuel += ceil(representatives/seats);\\n\\n        return representatives;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        vector<vector<int>> adj(roads.size()+1);\\n        for(auto& road:roads)\\n        {\\n            adj[road[0]].push_back(road[1]);\\n            adj[road[1]].push_back(road[0]);\\n        }\\n\\n        dfs(adj,0,-1,seats);\\n\\n        return minFuel;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```Java []\\nclass Solution {\\n    long minFuel = 0;\\n\\n    public double dfs(Map<Integer, List<Integer>> adj,int node,int prev,int seats) {\\n        double representatives = 1;\\n        if (!adj.containsKey(node)) {\\n            return representatives;\\n        }\\n\\n        for (int next : adj.get(node))\\n            if (next!=prev)\\n                representatives += dfs(adj,next,node,seats);\\n\\n        if (node != 0)\\n            minFuel += Math.ceil(representatives/seats);\\n\\n        return representatives;\\n    }\\n\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        Map<Integer, List<Integer>> adj = new HashMap<>();\\n        for (int[] road : roads) {\\n            adj.computeIfAbsent(road[0], k -> new ArrayList<Integer>()).add(road[1]);\\n            adj.computeIfAbsent(road[1], k -> new ArrayList<Integer>()).add(road[0]);\\n        }\\n        dfs(adj,0,-1,seats);\\n        return minFuel;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    long long minFuel = 0;\\n    double dfs(vector<vector<int>>& adj,int node, int prev,int& seats)\\n    {\\n        double representatives = 1;\\n        \\n        for(auto& next: adj[node])\\n            if(next!=prev)\\n                representatives += dfs(adj,next,node,seats);\\n\\n        if(node!=0)\\n            minFuel += ceil(representatives/seats);\\n\\n        return representatives;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        vector<vector<int>> adj(roads.size()+1);\\n        for(auto& road:roads)\\n        {\\n            adj[road[0]].push_back(road[1]);\\n            adj[road[1]].push_back(road[0]);\\n        }\\n\\n        dfs(adj,0,-1,seats);\\n\\n        return minFuel;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175154,
                "title": "go-rust-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDepth first traverse over the graph from the capital city, count sub-cities and add the corresponding amount of fuel to the output, after each recursion(post-order).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. make the graph as *adjacency list*, remember to add two nodes for each edge because it\\'s bidirectional\\n2. traverse over the graph, for each node:\\n    1. count all of its sub-nodes`c` for future calculations\\n    2. add this to the answer which is the total cost for the representatives travel from the current city to the parent city: `c` divided by `seats` and perform ceil round(if `c%seats != 0` then add one to the division result)\\n        - remember to except the capital city because it doesn\\'t have any parent city\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for the graph\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```go []\\nfunc minimumFuelCost(roads [][]int, seats int) int64 {\\n\\tgraph := make([][]int, len(roads)+1)\\n\\tfor _, e := range roads {\\n\\t\\tfrom, to := e[0], e[1]\\n\\t\\tgraph[from] = append(graph[from], to)\\n\\t\\tgraph[to] = append(graph[to], from)\\n\\t}\\n\\n\\tvar travel func(i, from int) (c int, ans int64)\\n\\ttravel = func(i, from int) (c int, ans int64) {\\n\\t\\tc = 1\\n\\t\\tfor _, n := range graph[i] {\\n\\t\\t\\tif n != from {\\n\\t\\t\\t\\tnc, na := travel(n, i)\\n\\t\\t\\t\\tc, ans = c+nc, ans+na\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif from != -1 {\\n\\t\\t\\tans += int64(c / seats)\\n\\t\\t\\tif c%seats != 0 {\\n\\t\\t\\t\\tans++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn c, ans\\n\\t}\\n\\t_, ans := travel(0, -1)\\n\\treturn ans\\n}\\n```\\n```rust []\\nimpl Solution {\\n    pub fn minimum_fuel_cost(roads: Vec<Vec<i32>>, seats: i32) -> i64 {\\n        match roads\\n            .iter()\\n            .fold(vec![Vec::new(); roads.len() + 1], |mut graph, e| {\\n                match e[..] {\\n                    [from, to] => {\\n                        graph[from as usize].push(to as usize);\\n                        graph[to as usize].push(from as usize);\\n                        graph\\n                    }\\n                    _ => panic!(\"never\"),\\n                }\\n            }) {\\n            graph => match |i, from| travel(i, from, &graph, seats as usize) {\\n                travel => travel(0, None),\\n            },\\n        }\\n        .1\\n    }\\n}\\n\\nfn travel(i: usize, from: Option<usize>, graph: &Vec<Vec<usize>>, seats: usize) -> (usize, i64) {\\n    match graph[i].iter().fold((1, 0), |pass @ (c, ans), &n| {\\n        match from.map_or(true, |from| n != from) {\\n            true => match travel(n, Some(i), graph, seats) {\\n                (nc, na) => (c + nc, ans + na),\\n            },\\n            false => pass,\\n        }\\n    }) {\\n        (c, ans) => (\\n            c,\\n            match from {\\n                None => ans,\\n                _ => ans + (c / seats) as i64 + if c % seats != 0 { 1 } else { 0 },\\n            },\\n        ),\\n    }\\n}\\n```\\n- In rust, we cannot use recursive closure so we have to \"capture\" the environments in flesh. Here I made a partial-call to hide the environment arguments passed to the function.",
                "solutionTags": [
                    "Go",
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```go []\\nfunc minimumFuelCost(roads [][]int, seats int) int64 {\\n\\tgraph := make([][]int, len(roads)+1)\\n\\tfor _, e := range roads {\\n\\t\\tfrom, to := e[0], e[1]\\n\\t\\tgraph[from] = append(graph[from], to)\\n\\t\\tgraph[to] = append(graph[to], from)\\n\\t}\\n\\n\\tvar travel func(i, from int) (c int, ans int64)\\n\\ttravel = func(i, from int) (c int, ans int64) {\\n\\t\\tc = 1\\n\\t\\tfor _, n := range graph[i] {\\n\\t\\t\\tif n != from {\\n\\t\\t\\t\\tnc, na := travel(n, i)\\n\\t\\t\\t\\tc, ans = c+nc, ans+na\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif from != -1 {\\n\\t\\t\\tans += int64(c / seats)\\n\\t\\t\\tif c%seats != 0 {\\n\\t\\t\\t\\tans++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn c, ans\\n\\t}\\n\\t_, ans := travel(0, -1)\\n\\treturn ans\\n}\\n```\n```rust []\\nimpl Solution {\\n    pub fn minimum_fuel_cost(roads: Vec<Vec<i32>>, seats: i32) -> i64 {\\n        match roads\\n            .iter()\\n            .fold(vec![Vec::new(); roads.len() + 1], |mut graph, e| {\\n                match e[..] {\\n                    [from, to] => {\\n                        graph[from as usize].push(to as usize);\\n                        graph[to as usize].push(from as usize);\\n                        graph\\n                    }\\n                    _ => panic!(\"never\"),\\n                }\\n            }) {\\n            graph => match |i, from| travel(i, from, &graph, seats as usize) {\\n                travel => travel(0, None),\\n            },\\n        }\\n        .1\\n    }\\n}\\n\\nfn travel(i: usize, from: Option<usize>, graph: &Vec<Vec<usize>>, seats: usize) -> (usize, i64) {\\n    match graph[i].iter().fold((1, 0), |pass @ (c, ans), &n| {\\n        match from.map_or(true, |from| n != from) {\\n            true => match travel(n, Some(i), graph, seats) {\\n                (nc, na) => (c + nc, ans + na),\\n            },\\n            false => pass,\\n        }\\n    }) {\\n        (c, ans) => (\\n            c,\\n            match from {\\n                None => ans,\\n                _ => ans + (c / seats) as i64 + if c % seats != 0 { 1 } else { 0 },\\n            },\\n        ),\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3175052,
                "title": "easy-c-solution-graph-dfs-linear-time-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Converted given edges in adjacency list using 2d vector.\\n2. Created an `vis` vector to mark the node thats already visited.\\n3. then called `dfs` function where every path returns how many node coming from that side.\\n4. and also in `dfs` function at every path we are adding unit of fuel required to answer by formula `(z+seats-1)/seats` to see how many cars will require.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dfs(vector<vector<int>>& x,vector<int>& vis,int node,int& seats,long long& ans){\\n        if(vis[node]) return 0;\\n        vis[node]=1;\\n        long long a=0,z=0;\\n        for(int i=0;i<x[node].size();i++){\\n            z=dfs(x,vis,x[node][i],seats,ans);\\n            ans+=(z+seats-1)/seats;\\n            a+=z;\\n        }\\n        return a+1;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n=roads.size();\\n        vector<vector<int>> x(n+1,vector<int>());\\n        for(int i=0;i<n;i++){\\n            x[roads[i][0]].push_back(roads[i][1]);\\n            x[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        vector<int> vis(n+1,0);\\n        long long ans=0;\\n        dfs(x,vis,0,seats,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dfs(vector<vector<int>>& x,vector<int>& vis,int node,int& seats,long long& ans){\\n        if(vis[node]) return 0;\\n        vis[node]=1;\\n        long long a=0,z=0;\\n        for(int i=0;i<x[node].size();i++){\\n            z=dfs(x,vis,x[node][i],seats,ans);\\n            ans+=(z+seats-1)/seats;\\n            a+=z;\\n        }\\n        return a+1;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n=roads.size();\\n        vector<vector<int>> x(n+1,vector<int>());\\n        for(int i=0;i<n;i++){\\n            x[roads[i][0]].push_back(roads[i][1]);\\n            x[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        vector<int> vis(n+1,0);\\n        long long ans=0;\\n        dfs(x,vis,0,seats,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174938,
                "title": "python-optimized-solution-explained-in-detail",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n**For Detailed Explaination Read this Blog:**\\nhttps://www.python-techs.com/2023/02/minimum-fuel-cost-to-report-to-capital.html\\n\\n**Solution:**\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        # Create a dictionary to store the edges in the graph\\n        graph = defaultdict(list)\\n        for city_1, city_2 in roads:\\n            graph[city_1].append(city_2)\\n            graph[city_2].append(city_1)\\n        \\n        # Initialize the minimum fuel cost to 0\\n        minimum_fuel_cost = 0\\n        # Create a set to store the cities that have been visited\\n        visited_cities = set()\\n        \\n        # Define a helper function to traverse the graph\\n        def dfs(city):\\n            nonlocal minimum_fuel_cost\\n            # If the city has already been visited, return 0\\n            if city in visited_cities: return 0\\n            # Mark the city as visited\\n            visited_cities.add(city)\\n            # Initialize a variable to store the number of representatives in this city\\n            representatives = 0\\n            # Loop through the cities connected to this city\\n            for connected_city in graph[city]:\\n                # Recursively call the dfs function to count the number of representatives in the connected city\\n                connected_city_representatives = dfs(connected_city)\\n                # Calculate the number of cars needed to transport all the representatives in the connected city\\n                minimum_fuel_cost += (connected_city_representatives + seats - 1) // seats\\n                # Add the number of representatives in the connected city to the representatives variable\\n                representatives += connected_city_representatives\\n            # Return the number of representatives in this city, plus the representative from this city\\n            return representatives + 1\\n        \\n        # Call the dfs function starting from city 0 (the capital city)\\n        dfs(0)\\n        # Return the minimum fuel cost\\n        return minimum_fuel_cost\\n```\\n\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        # Create a dictionary to store the edges in the graph\\n        graph = defaultdict(list)\\n        for city_1, city_2 in roads:\\n            graph[city_1].append(city_2)\\n            graph[city_2].append(city_1)\\n        \\n        # Initialize the minimum fuel cost to 0\\n        minimum_fuel_cost = 0\\n        # Create a set to store the cities that have been visited\\n        visited_cities = set()\\n        \\n        # Define a helper function to traverse the graph\\n        def dfs(city):\\n            nonlocal minimum_fuel_cost\\n            # If the city has already been visited, return 0\\n            if city in visited_cities: return 0\\n            # Mark the city as visited\\n            visited_cities.add(city)\\n            # Initialize a variable to store the number of representatives in this city\\n            representatives = 0\\n            # Loop through the cities connected to this city\\n            for connected_city in graph[city]:\\n                # Recursively call the dfs function to count the number of representatives in the connected city\\n                connected_city_representatives = dfs(connected_city)\\n                # Calculate the number of cars needed to transport all the representatives in the connected city\\n                minimum_fuel_cost += (connected_city_representatives + seats - 1) // seats\\n                # Add the number of representatives in the connected city to the representatives variable\\n                representatives += connected_city_representatives\\n            # Return the number of representatives in this city, plus the representative from this city\\n            return representatives + 1\\n        \\n        # Call the dfs function starting from city 0 (the capital city)\\n        dfs(0)\\n        # Return the minimum fuel cost\\n        return minimum_fuel_cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174907,
                "title": "python-short-and-clean-dfs-functional-programming",
                "content": "# Approach\\n1. Define a function `min_cost` that given a subtree rooted at `node` computes the number of people in the subtree, say `total_people`, and the minimum fuel cost to gather them all at `node`, say `total_cost`.\\n\\n2. To compute the `(total_cost, total_people)` from `node`, recursively call `min_cost` on each `child`.\\n\\n3. Say for each `child`, `c` and `t` are the cost and people, then\\n    `total_people += p`, current number of people in `child`\\n    `total_cost += c + ceil(c / seats)`, current cost + cost to travel from `child` to `node`.\\n\\n4. Return `total_cost`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere `n is the number of cities`.\\n\\n# Code\\nImperative: Iterative `min_cost` function.\\n```python\\nclass Solution:\\n    def minimumFuelCost(self, roads: list[list[int]], seats_: int) -> int:\\n        T = Hashable\\n        Graph = Mapping[T, Iterable[T]]\\n\\n        def min_cost(graph: Graph, node: T, seats: int, parent: T | None = None) -> tuple[int, int]:\\n            total_cost, total_people = 0, 1\\n            for child in graph[node]:\\n                if child == parent: continue\\n                c, p = min_cost(graph, child, seats, node)\\n                total_people += p\\n                total_cost += c + ceil(p / seats)\\n            return total_cost, total_people\\n        \\n        g = defaultdict(list)\\n        for u, v in roads: g[u].append(v); g[v].append(u)\\n\\n        return min_cost(g, 0, seats_)[0]\\n\\n\\n```\\n\\nFunctional: 1-liner `min_cost` function.\\n```python\\nclass Solution:\\n    def minimumFuelCost(self, roads: list[list[int]], seats_: int) -> int:\\n        T = Hashable\\n        Graph = Mapping[T, Iterable[T]]\\n\\n        def min_cost(graph: Graph, node: T, seats: int, parent: T | None = None) -> tuple[int, int]:\\n            return reduce(\\n                lambda a, x: (a[0] + x[0] + ceil(x[1] / seats), a[1] + x[1]), \\n                (min_cost(graph, child, seats, node) for child in graph[node] if child != parent),\\n                (0, 1), # (total_cost, total_people)\\n            )\\n        \\n        g = defaultdict(list)\\n        for u, v in roads: g[u].append(v); g[v].append(u)\\n\\n        return min_cost(g, 0, seats_)[0]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumFuelCost(self, roads: list[list[int]], seats_: int) -> int:\\n        T = Hashable\\n        Graph = Mapping[T, Iterable[T]]\\n\\n        def min_cost(graph: Graph, node: T, seats: int, parent: T | None = None) -> tuple[int, int]:\\n            total_cost, total_people = 0, 1\\n            for child in graph[node]:\\n                if child == parent: continue\\n                c, p = min_cost(graph, child, seats, node)\\n                total_people += p\\n                total_cost += c + ceil(p / seats)\\n            return total_cost, total_people\\n        \\n        g = defaultdict(list)\\n        for u, v in roads: g[u].append(v); g[v].append(u)\\n\\n        return min_cost(g, 0, seats_)[0]\\n\\n\\n```\n```python\\nclass Solution:\\n    def minimumFuelCost(self, roads: list[list[int]], seats_: int) -> int:\\n        T = Hashable\\n        Graph = Mapping[T, Iterable[T]]\\n\\n        def min_cost(graph: Graph, node: T, seats: int, parent: T | None = None) -> tuple[int, int]:\\n            return reduce(\\n                lambda a, x: (a[0] + x[0] + ceil(x[1] / seats), a[1] + x[1]), \\n                (min_cost(graph, child, seats, node) for child in graph[node] if child != parent),\\n                (0, 1), # (total_cost, total_people)\\n            )\\n        \\n        g = defaultdict(list)\\n        for u, v in roads: g[u].append(v); g[v].append(u)\\n\\n        return min_cost(g, 0, seats_)[0]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174889,
                "title": "dfs-explained-detailed-visualisation-with-picture-o-n",
                "content": "# Approach : Depth First Search\\n![visualization.png](https://assets.leetcode.com/users/images/18efc37f-eaa8-4c3b-a4de-f995c3780001_1676186046.5661473.png)\\n\\n\\n![treedfs.png](https://assets.leetcode.com/users/images/6220359b-e188-4dd0-96e2-9836add1b7b3_1676184993.6501067.png)\\n\\n# Intuition\\nWe can see that taking a car from level l to l + 1 and back to level l to get to the root node is pointless. It takes two units of fuel to go from l to l + 1 and back again. Instead, the representative at level l + 1 can drive to level l in one unit of fuel. As a result, the cars would move from higher to lower levels in order to reach the root node.\\n\\nWe will try to put as many representatives as possible in the same car to save fuel. Let\\'s look at an example to see how we should arrange the representatives.\\n\\nConsider a node node that has a parent node parent. Assume there are r representatives in the subtree of node. To reach node 0, all representatives in this subtree must pass through parent. Let\\'s compute how much fuel would be required to just cross the edge that connects nodes node and parent.\\n\\nIntitutively, we can think that the worst-case scenario would be the one where all the representatives take their own car and cross the edge. This would require r units of fuel.\\n\\nThe best way would be to put r representatives one by one into the cars until the cars reach seat capacity. This would require ceil(r / seats) cars and an equal amount of fuel (since a car takes one unit of fuel to travel over an edge). For example, if you have 10 representatives in a subtree and the capacity is 3, then you would need ceil(10 / 3) = 4 cars.\\n\\nAlso, regardless of how the representatives arrive at node, there will definitely be at least ceil(r / seats) cars. This is because all of the representatives in the subtree of node except for the one at node would arrive by using at least ceil((r - 1) / seats) cars or more (since we can accommodate a maximum of seats people in a car). Hence, we already have cars that can seat r - 1 people, and there is one representative and one car at node to take all the representatives in the required number of cars (1 + ceil(r - 1 / seats) >= ceil(r / seats)). That brings us to our solution.\\n\\nWe begin by moving all the representatives in a node\\'s subtree to the node. Then, using the minimum fuel calculated by the above formula, move all of the representatives to the parent node. So our task is to compute the number of representatives in each node\\'s subtree and add the fuel required to move all of the representatives in the node\\'s subtree to the parent node.\\n\\nThe depth-first search (DFS) algorithm can be used to compute the number of representatives in each subtree. In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a branch, we backtrack to the next branch and continue exploring.\\n\\nOnce we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this branch. Recursively call the function to take the next node as the \\'starting node\\' and solve the subproblem.\\n\\nWe implement a dfs method that performs a DFS traversal and returns the number of representatives in the subtree of given node. We begin the traversal from root node 0. Using the above-mentioned formula, we then calculate the number of cars and thus the fuel required to move all of the representatives to the parent node. To get the final answer, we add the fuel required to move representatives from all nodes to their respective parent nodes until we reach the root node.\\n\\n# Algorithm\\nCreate an adjacency list where adj[X] contains all the neighbors of node X.\\nCreate an integer fuel that stores the minimum amount of fuel needed to move all representatives to node 0.\\nBegin the DFS traversal:\\nWe use the dfs function to perform the traversal. For each call, pass node, parent, adj and seats as the parameters. It returns the number of representatives in the subtree of the node. We start with node 0. We also keep track of the parent node of the current node so that we don\\u2019t visit the node\\u2019s parent as it has already been visited.\\nInitalize an integer representatives to store the number of representatives in the subtree of node. We initialize it to 1 because the node itself has one representative.\\nIterate over all the children of the node (nodes that share an edge) and check if any child is equal to the parent. If the child is equal to the parent, we will not visit it again.\\nIf the child is not equal to the parent, recursively call the dfs function with the node as child and the parent as node. Add the count of representatives (returned by this call) in the subtree of child to representatives.\\nAfter iterating over all the children, we have the required number of representatives. To move all of these representatives to the parent node, we would require ceil(representatives / seats) cars and an equal amount of fuel. We perform fuel += ceil(representatives / seats). We ignore node 0 because it does not have a parent.\\nReturn fuel.\\n\\n\\n# Code\\n```java []\\nprivate long fuel;\\npublic long minimumFuelCost(int[][] roads, int seats) {\\n        Map<Integer, List<Integer>> adj = new HashMap<>();\\n        for (int road[] : roads) {\\nadj.computeIfAbsent(road[0], k -> new ArrayList<>()).add(road[1]);\\nadj.computeIfAbsent(road[1], k -> new ArrayList<>()).add(road[0]);\\n        } dfs(adj, 0, -1, seats);\\n        return fuel;\\n    }\\n    private int dfs(Map<Integer, List<Integer>> adj, int node, int parent, int seats) {\\n        int representatives = 1;\\n        if (!adj.containsKey(node)) return representatives;\\nfor (int child : adj.get(node)) if (child != parent) representatives += dfs(adj, child, node, seats);\\nif (node != 0) fuel += Math.ceil((double) representatives / seats);\\n        return representatives;\\n    }\\n```\\n```python []\\ndef minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        n = len(roads) + 1\\n        adj = [[] for _ in range(n)]\\n        for road in roads:\\n            adj[road[0]].append(road[1])\\n            adj[road[1]].append(road[0])\\n\\n        self.fuel = 0\\n\\n        def dfs(node, parent, adj, seats):\\n            representatives = 1\\n            for child in adj[node]:\\n                if child != parent:\\n                    representatives += dfs(child, node, adj, seats)\\n            if node != 0:\\n                self.fuel += math.ceil(representatives / seats)\\n            return representatives\\n\\n        dfs(0, -1, adj, seats)\\n        return self.fuel\\n```\\n```c++ []\\nlong long fuel;\\n\\n    long long dfs(int node, int parent, vector<vector<int>>& adj, int& seats) {\\n        // The node itself has one representative.\\n        int representatives = 1;\\n        for (auto& child : adj[node]) {\\n            if (child != parent) {\\n                // Add count of representatives in each child subtree to the parent subtree.\\n                representatives += dfs(child, node, adj, seats);\\n            }\\n        }\\n\\n        if (node != 0) {\\n            // Count the fuel it takes to move to the parent node.\\n            // Root node does not have any parent so we ignore it.\\n            fuel += ceil((double)representatives / seats);\\n        }\\n        return representatives;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size() + 1;\\n        vector<vector<int>> adj(n);\\n        for (auto& road : roads) {\\n            adj[road[0]].push_back(road[1]);\\n            adj[road[1]].push_back(road[0]);\\n        }\\n        dfs(0, -1, adj, seats);\\n        return fuel;\\n    }\\n```\\n```python3 []\\n# never move child -> parent -> child. that takes 2 units of fuel, you could have just moved parent-> child in another car\\n# therefore optimal strategy is moving as many people as possible from node to node\\n# you can transport math.ceil(people/seats) per ride\\n\\ndef minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        adj = defaultdict(set)\\n        self.ans = 0\\n        visited = {0}\\n        for a, b in roads:\\n            adj[a].add(b)\\n            adj[b].add(a)\\n\\n        def dfs(node):\\n            reps = 1\\n            if node not in adj:\\n                return reps\\n\\n            for child in adj[node]:\\n                if child not in visited:\\n                    visited.add(child)\\n                    reps += dfs(child)\\n\\n            # calculate fuel required to reach this node\\n            # no fuel required to reach node 0\\n            if node:\\n                self.ans += math.ceil(reps / seats)\\n\\n            return reps\\n\\n        dfs(0)\\n        return self.ans\\n```\\n\\n\\n# Complexity Analysis\\nHere n is the number of nodes.\\n\\nTime complexity: O(n)\\n\\nThe dfs function visits each node once, which takes O(n) time in total. Because we have n - 1 undirected edges, each edge can only be iterated twice (by nodes at the end), resulting in O(n)operations total while visiting all nodes.\\nWe also need O(n) time to initialize the adjacency list.\\nSpace complexity: O(n).\\n\\nBuilding the adjacency list takes O(n) space.\\nThe recursion call stack used by dfs can have no more than nnn elements in the worst-case scenario. It would take up O(n)space in that case.\\n\\n![mem2.png](https://assets.leetcode.com/users/images/e8435d98-472c-4084-971d-be209e9c741d_1676184910.2527225.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\nprivate long fuel;\\npublic long minimumFuelCost(int[][] roads, int seats) {\\n        Map<Integer, List<Integer>> adj = new HashMap<>();\\n        for (int road[] : roads) {\\nadj.computeIfAbsent(road[0], k -> new ArrayList<>()).add(road[1]);\\nadj.computeIfAbsent(road[1], k -> new ArrayList<>()).add(road[0]);\\n        } dfs(adj, 0, -1, seats);\\n        return fuel;\\n    }\\n    private int dfs(Map<Integer, List<Integer>> adj, int node, int parent, int seats) {\\n        int representatives = 1;\\n        if (!adj.containsKey(node)) return representatives;\\nfor (int child : adj.get(node)) if (child != parent) representatives += dfs(adj, child, node, seats);\\nif (node != 0) fuel += Math.ceil((double) representatives / seats);\\n        return representatives;\\n    }\\n```\n```python []\\ndef minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        n = len(roads) + 1\\n        adj = [[] for _ in range(n)]\\n        for road in roads:\\n            adj[road[0]].append(road[1])\\n            adj[road[1]].append(road[0])\\n\\n        self.fuel = 0\\n\\n        def dfs(node, parent, adj, seats):\\n            representatives = 1\\n            for child in adj[node]:\\n                if child != parent:\\n                    representatives += dfs(child, node, adj, seats)\\n            if node != 0:\\n                self.fuel += math.ceil(representatives / seats)\\n            return representatives\\n\\n        dfs(0, -1, adj, seats)\\n        return self.fuel\\n```\n```c++ []\\nlong long fuel;\\n\\n    long long dfs(int node, int parent, vector<vector<int>>& adj, int& seats) {\\n        // The node itself has one representative.\\n        int representatives = 1;\\n        for (auto& child : adj[node]) {\\n            if (child != parent) {\\n                // Add count of representatives in each child subtree to the parent subtree.\\n                representatives += dfs(child, node, adj, seats);\\n            }\\n        }\\n\\n        if (node != 0) {\\n            // Count the fuel it takes to move to the parent node.\\n            // Root node does not have any parent so we ignore it.\\n            fuel += ceil((double)representatives / seats);\\n        }\\n        return representatives;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size() + 1;\\n        vector<vector<int>> adj(n);\\n        for (auto& road : roads) {\\n            adj[road[0]].push_back(road[1]);\\n            adj[road[1]].push_back(road[0]);\\n        }\\n        dfs(0, -1, adj, seats);\\n        return fuel;\\n    }\\n```\n```python3 []\\n# never move child -> parent -> child. that takes 2 units of fuel, you could have just moved parent-> child in another car\\n# therefore optimal strategy is moving as many people as possible from node to node\\n# you can transport math.ceil(people/seats) per ride\\n\\ndef minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        adj = defaultdict(set)\\n        self.ans = 0\\n        visited = {0}\\n        for a, b in roads:\\n            adj[a].add(b)\\n            adj[b].add(a)\\n\\n        def dfs(node):\\n            reps = 1\\n            if node not in adj:\\n                return reps\\n\\n            for child in adj[node]:\\n                if child not in visited:\\n                    visited.add(child)\\n                    reps += dfs(child)\\n\\n            # calculate fuel required to reach this node\\n            # no fuel required to reach node 0\\n            if node:\\n                self.ans += math.ceil(reps / seats)\\n\\n            return reps\\n\\n        dfs(0)\\n        return self.ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3174448,
                "title": "very-very-easy-easy-dfs-traversal",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long ans;\\n    long long solve(vector<vector<int>> &adj,vector<int> &vis,int node,int seats){\\n\\n        vis[node]=1;\\n       long long cnt=1; // store no of people at each node\\n        for(auto it :adj[node]){\\n            if(!vis[it]){\\n                cnt+=solve(adj,vis,it,seats);\\n            }\\n        }\\n        long long x = cnt/seats;  //  no of cars = total people / no of seats\\n        if(cnt%seats){  // no of people are more than the seats\\n            x++;\\n        }\\n        if(node!=0){ // not a goal state then add total no cars to the ans\\n            ans+=x; \\n        }\\n          return cnt; //return no of people at particular node\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n=roads.size();\\n        if(n==0){\\n            return 0;\\n        }\\n        ans=0;\\n        vector<vector<int>> adj(n+1);  //store in adj matrix \\n        for(int i=0;i<n;i++){\\n            adj[roads[i][0]].push_back(roads[i][1]);\\n            adj[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        vector<int> vis(n+1,0);   //to check the node is visited or not\\n        solve(adj,vis,0,seats);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long ans;\\n    long long solve(vector<vector<int>> &adj,vector<int> &vis,int node,int seats){\\n\\n        vis[node]=1;\\n       long long cnt=1; // store no of people at each node\\n        for(auto it :adj[node]){\\n            if(!vis[it]){\\n                cnt+=solve(adj,vis,it,seats);\\n            }\\n        }\\n        long long x = cnt/seats;  //  no of cars = total people / no of seats\\n        if(cnt%seats){  // no of people are more than the seats\\n            x++;\\n        }\\n        if(node!=0){ // not a goal state then add total no cars to the ans\\n            ans+=x; \\n        }\\n          return cnt; //return no of people at particular node\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n=roads.size();\\n        if(n==0){\\n            return 0;\\n        }\\n        ans=0;\\n        vector<vector<int>> adj(n+1);  //store in adj matrix \\n        for(int i=0;i<n;i++){\\n            adj[roads[i][0]].push_back(roads[i][1]);\\n            adj[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        vector<int> vis(n+1,0);   //to check the node is visited or not\\n        solve(adj,vis,0,seats);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173752,
                "title": "python-dfs-with-return-values-explained",
                "content": "DFS traverse all the cities.\\n\\nFrom leaf node city, we return the number of cars and number of passenagers to its parent city.\\n\\nParent city count the number of total passenagers and total number of cars required to carry all the passenagers.\\n\\nUpdate the fuel based on the distance and the number of cars.\\n\\nSee the details in code:\\n\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        # dfs and count the number of cars needed and the distance between the starting city and the captial\\n        self.G = collections.defaultdict(set)\\n        for c0, c1 in roads:\\n            self.G[c0].add(c1)\\n            self.G[c1].add(c0)\\n        \\n        self.seats = seats\\n        self.min_fuel = 0\\n\\n        if len(self.G):\\n            for i in self.G[0]:\\n                self.dfsMinFuel(0, i, 1)\\n        return self.min_fuel\\n        \\n        \\n    def dfsMinFuel(self, f, i, dist):\\n        # f: parent city;\\n        # i: child city;\\n        # dist: the distance from capital\\n        \\n        if len(self.G[i]) == 1:\\n            # this is a leaf node, and a car has to be started from this node\\n            self.min_fuel += dist\\n            # return the cars and passenagers from this city to capital\\n            return 1, 1\\n        \\n        total_p = 0\\n        total_cars = 0\\n        for j in self.G[i]:\\n            if j != f:\\n                t_car, t_p = self.dfsMinFuel(i, j, dist + 1)\\n                total_p += t_p\\n                total_cars += t_car\\n        \\n        total_p += 1\\n        req_cars = total_p // self.seats\\n        if total_p % self.seats:\\n            req_cars += 1\\n            \\n        if req_cars < total_cars:\\n            self.min_fuel -= (total_cars - req_cars) * dist\\n        elif req_cars > total_cars:\\n            self.min_fuel += dist\\n        return req_cars, total_p\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        # dfs and count the number of cars needed and the distance between the starting city and the captial\\n        self.G = collections.defaultdict(set)\\n        for c0, c1 in roads:\\n            self.G[c0].add(c1)\\n            self.G[c1].add(c0)\\n        \\n        self.seats = seats\\n        self.min_fuel = 0\\n\\n        if len(self.G):\\n            for i in self.G[0]:\\n                self.dfsMinFuel(0, i, 1)\\n        return self.min_fuel\\n        \\n        \\n    def dfsMinFuel(self, f, i, dist):\\n        # f: parent city;\\n        # i: child city;\\n        # dist: the distance from capital\\n        \\n        if len(self.G[i]) == 1:\\n            # this is a leaf node, and a car has to be started from this node\\n            self.min_fuel += dist\\n            # return the cars and passenagers from this city to capital\\n            return 1, 1\\n        \\n        total_p = 0\\n        total_cars = 0\\n        for j in self.G[i]:\\n            if j != f:\\n                t_car, t_p = self.dfsMinFuel(i, j, dist + 1)\\n                total_p += t_p\\n                total_cars += t_car\\n        \\n        total_p += 1\\n        req_cars = total_p // self.seats\\n        if total_p % self.seats:\\n            req_cars += 1\\n            \\n        if req_cars < total_cars:\\n            self.min_fuel -= (total_cars - req_cars) * dist\\n        elif req_cars > total_cars:\\n            self.min_fuel += dist\\n        return req_cars, total_p\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173681,
                "title": "daily-leetcoding-challenge-february-day-12",
                "content": "This problem is the Daily LeetCoding Challenge for February, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2892080,
                "title": "c-simple-dfs-o-n",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>adj[100005];\\n    long long ans[100005],cnt[100005];\\n    void dfs(int src,int par,int seats){\\n        cnt[src]=1;\\n        for(auto edge:adj[src]){\\n            if(edge!=par){\\n                dfs(edge,src,seats);\\n                cnt[src]+=cnt[edge];\\n                ans[src]+=(cnt[edge]/seats);\\n                if(cnt[edge]%seats!=0) ans[src]++;\\n            }\\n        }\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n{(int)roads.size()+1};\\n        for(int i=0;i<roads.size();i++){\\n            adj[roads[i][0]].push_back(roads[i][1]);\\n            adj[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        dfs(0,-1,seats);\\n        long long sum=0;\\n        for(int i=0;i<n;i++) sum+=ans[i];\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>adj[100005];\\n    long long ans[100005],cnt[100005];\\n    void dfs(int src,int par,int seats){\\n        cnt[src]=1;\\n        for(auto edge:adj[src]){\\n            if(edge!=par){\\n                dfs(edge,src,seats);\\n                cnt[src]+=cnt[edge];\\n                ans[src]+=(cnt[edge]/seats);\\n                if(cnt[edge]%seats!=0) ans[src]++;\\n            }\\n        }\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n{(int)roads.size()+1};\\n        for(int i=0;i<roads.size();i++){\\n            adj[roads[i][0]].push_back(roads[i][1]);\\n            adj[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        dfs(0,-1,seats);\\n        long long sum=0;\\n        for(int i=0;i<n;i++) sum+=ans[i];\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835083,
                "title": "c-without-using-visited-array",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    long long ans;\\n    long long dfs(int node,int seats,int parent)\\n    {\\n        int no_people=0;\\n        for(auto it:adj[node])\\n        {\\n            if(it==parent) continue; //to prevent from going to its parent\\n            \\n            no_people+=dfs(it,seats,node);\\n        }\\n        no_people+=1;\\n        if(node!=0)\\n        ans+=(no_people+seats-1)/seats;\\n        \\n        return no_people;        \\n    }\\n        \\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n=roads.size()+1;\\n        adj.resize(n);\\n        ans=0;\\n        for(auto it:roads)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        dfs(0,seats,-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    long long ans;\\n    long long dfs(int node,int seats,int parent)\\n    {\\n        int no_people=0;\\n        for(auto it:adj[node])\\n        {\\n            if(it==parent) continue; //to prevent from going to its parent\\n            \\n            no_people+=dfs(it,seats,node);\\n        }\\n        no_people+=1;\\n        if(node!=0)\\n        ans+=(no_people+seats-1)/seats;\\n        \\n        return no_people;        \\n    }\\n        \\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n=roads.size()+1;\\n        adj.resize(n);\\n        ans=0;\\n        for(auto it:roads)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        dfs(0,seats,-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834288,
                "title": "python3-post-order-dfs",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/5c8a821ed30357746d2547ce97888600f3208acc) for solutions of weekly 320. \\n\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        graph = [[] for _ in range(len(roads)+1)]\\n        for u, v in roads: \\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        ans = 0 \\n        def dfs(u, p): \\n            \"\"\"Return number of people going through city u.\"\"\"\\n            nonlocal ans \\n            ppl = 0 \\n            for v in graph[u]: \\n                if v != p: ppl += dfs(v, u)\\n            ppl += 1\\n            if u: ans += (ppl + seats - 1) // seats\\n            return ppl \\n        \\n        dfs(0, -1)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        graph = [[] for _ in range(len(roads)+1)]\\n        for u, v in roads: \\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        ans = 0 \\n        def dfs(u, p): \\n            \"\"\"Return number of people going through city u.\"\"\"\\n            nonlocal ans \\n            ppl = 0 \\n            for v in graph[u]: \\n                if v != p: ppl += dfs(v, u)\\n            ppl += 1\\n            if u: ans += (ppl + seats - 1) // seats\\n            return ppl \\n        \\n        dfs(0, -1)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833195,
                "title": "c-dfs-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long S;\\n    long long ans = 0;\\n    vector <vector <long long>> G;\\n    \\n    // this dfs returns amount of full cars\\n    // and amount of remain people that will\\n    // be tranfered to parent (previous) vertex\\n    pair <long long, long long> dfs(long long current, long long previous) {\\n        long long people = 1;\\n        long long fullcars = 0;\\n        \\n        for (auto adj : G[current]) {\\n            if (adj == previous) continue;\\n            auto x = dfs(adj, current);\\n            people += x.first;\\n            fullcars += x.second;\\n        }\\n        \\n        // form new cars\\n        fullcars += people / S;\\n        people %= S;\\n        \\n        // if we\\'d reached the capital (current = 0)\\n        // there is nothing to do more\\n        // (people > 0) is for extra car\\n        if (current != 0) ans += fullcars + (people > 0);\\n        return {people, fullcars};\\n    }\\n    \\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        // make things global and fill the graph\\n        long long n = roads.size();\\n        S = seats;\\n        G.resize(n + 1);\\n        for (auto x : roads) G[x[0]].push_back(x[1]), G[x[1]].push_back(x[0]);\\n        \\n        // call dfs from 0 vertex\\n        dfs(0, -1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long S;\\n    long long ans = 0;\\n    vector <vector <long long>> G;\\n    \\n    // this dfs returns amount of full cars\\n    // and amount of remain people that will\\n    // be tranfered to parent (previous) vertex\\n    pair <long long, long long> dfs(long long current, long long previous) {\\n        long long people = 1;\\n        long long fullcars = 0;\\n        \\n        for (auto adj : G[current]) {\\n            if (adj == previous) continue;\\n            auto x = dfs(adj, current);\\n            people += x.first;\\n            fullcars += x.second;\\n        }\\n        \\n        // form new cars\\n        fullcars += people / S;\\n        people %= S;\\n        \\n        // if we\\'d reached the capital (current = 0)\\n        // there is nothing to do more\\n        // (people > 0) is for extra car\\n        if (current != 0) ans += fullcars + (people > 0);\\n        return {people, fullcars};\\n    }\\n    \\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        // make things global and fill the graph\\n        long long n = roads.size();\\n        S = seats;\\n        G.resize(n + 1);\\n        for (auto x : roads) G[x[0]].push_back(x[1]), G[x[1]].push_back(x[0]);\\n        \\n        // call dfs from 0 vertex\\n        dfs(0, -1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832516,
                "title": "python-3-easy-to-understand-dfs",
                "content": "For the given graph, there\\'s a unique path from each non-capital city to the capital. Each representative will travel to the capital either directly or via a number of non-capital cities.\\n![image.png](https://assets.leetcode.com/users/images/9ff190c0-c513-4ce0-b187-0a9274712801_1668923644.9513392.png)\\nFor each non-capital city, let $repnum$ be the total number of representatives that can be at this city (for example, $repnum$ of city 1 is 3 including representatives from cities 1,3,2; or $repnum$ of city 4 is 2 including representatives from cities 4,6). The travelling cost for $repnum$ representatives to the next city (in the path to the capital) is $math.ceil(repnum/seats)$. Thus, we update our answer for each non-capital city: $self.ans += math.ceil(repnum/seats)$.\\n\\nThe process to compute $repnum$ and update the answer for each non-capital city can be implemented via a DFS.\\n\\nTime complexity: $O(n)$.\\n\\n# Python\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads, seats):\\n        graph = defaultdict(set)\\n        # find the adjacency list representation\\n        for i,j in roads:\\n            graph[i].add(j)\\n            graph[j].add(i)\\n        n = len(graph)\\n        if n==0: return 0\\n        visited = [False]*n\\n        self.ans = 0\\n        def dfs(city): \\n        # return total number of representatives can be at city\\n        # and update answer self.ans for each city\\n            visited[city] = True\\n            repnum = 1 # initialize with 1 representative of city\\n            for neighbor in graph[city]:\\n                if not visited[neighbor]:\\n                    repnum += dfs(neighbor)\\n            if city==0: return None # do not update answer for capital\\n            self.ans += math.ceil(repnum/seats) # update answer\\n            return repnum\\n        dfs(0) # execute the DFS\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads, seats):\\n        graph = defaultdict(set)\\n        # find the adjacency list representation\\n        for i,j in roads:\\n            graph[i].add(j)\\n            graph[j].add(i)\\n        n = len(graph)\\n        if n==0: return 0\\n        visited = [False]*n\\n        self.ans = 0\\n        def dfs(city): \\n        # return total number of representatives can be at city\\n        # and update answer self.ans for each city\\n            visited[city] = True\\n            repnum = 1 # initialize with 1 representative of city\\n            for neighbor in graph[city]:\\n                if not visited[neighbor]:\\n                    repnum += dfs(neighbor)\\n            if city==0: return None # do not update answer for capital\\n            self.ans += math.ceil(repnum/seats) # update answer\\n            return repnum\\n        dfs(0) # execute the DFS\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832244,
                "title": "kotlin-clean-short-and-simple-code",
                "content": "Explanation: just get the sizes of every subtree and divide them by the number of seats\\n```\\nclass Solution {\\n    val adj = Array<MutableList<Int>>(100001) { mutableListOf() }\\n    val size = IntArray(100001)\\n    fun minimumFuelCost(roads: Array<IntArray>, seats: Int): Long {\\n        for (i in roads) {\\n            adj[i[0]].add(i[1])\\n            adj[i[1]].add(i[0])\\n        }\\n        \\n        var count = 0L\\n        getSize(0, -1)\\n        for (i in 0 .. 100000) {\\n            if (size[i] > 0 && i != 0) {\\n                count += if (size[i] % seats == 0) {\\n                    size[i] / seats\\n                } else (size[i] / seats) + 1\\n            }\\n        }\\n        return count\\n    }\\n    \\n    fun getSize(curr: Int, prev: Int): Int {\\n        var total = 0\\n        for (i in adj[curr]) {\\n            if (i != prev) total += getSize(i, curr)\\n        }\\n        size[curr] = total + 1\\n        return size[curr]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    val adj = Array<MutableList<Int>>(100001) { mutableListOf() }\\n    val size = IntArray(100001)\\n    fun minimumFuelCost(roads: Array<IntArray>, seats: Int): Long {\\n        for (i in roads) {\\n            adj[i[0]].add(i[1])\\n            adj[i[1]].add(i[0])\\n        }\\n        \\n        var count = 0L\\n        getSize(0, -1)\\n        for (i in 0 .. 100000) {\\n            if (size[i] > 0 && i != 0) {\\n                count += if (size[i] % seats == 0) {\\n                    size[i] / seats\\n                } else (size[i] / seats) + 1\\n            }\\n        }\\n        return count\\n    }\\n    \\n    fun getSize(curr: Int, prev: Int): Int {\\n        var total = 0\\n        for (i in adj[curr]) {\\n            if (i != prev) total += getSize(i, curr)\\n        }\\n        size[curr] = total + 1\\n        return size[curr]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832231,
                "title": "java-solution-dfs-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution \\n{\\n    long ans=0;\\n\\n    public long minimumFuelCost(int[][] roads, int seats) \\n    {\\n        int n=0;\\n        for(int i=0;i<roads.length;i++)\\n        n=Math.max(n,Math.max(roads[i][0],roads[i][1]));\\n        n++;\\n\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        adj.add(new ArrayList<>());\\n\\n        for(int i=0;i<roads.length;i++)\\n        {\\n            adj.get(roads[i][0]).add(roads[i][1]);\\n            adj.get(roads[i][1]).add(roads[i][0]);\\n        }\\n        \\n        int visited[]=new int[n];\\n        int x=dfs(0,adj,visited,seats,0);\\n\\n        return ans;\\n    }\\n\\n    public int dfs(int curr,List<List<Integer>> adj,int visited[],int maxCap,int len)\\n    {\\n        visited[curr]=1;\\n\\n        List<Integer> neigh=adj.get(curr);\\n        List<Integer> people=new ArrayList<>();\\n\\n        for(int i=0;i<neigh.size();i++)\\n        {\\n            if(visited[neigh.get(i)]==1)\\n            continue;\\n            \\n            int toAdd=dfs(neigh.get(i),adj,visited,maxCap,len+1);\\n\\n            if(toAdd>0)\\n            {\\n                ans++;\\n                people.add(toAdd);\\n            }\\n        }\\n         \\n         int car=1;\\n         Collections.sort(people);\\n\\n         for(int i=0;i<people.size();i++)\\n         {\\n            if(car+people.get(i)<=maxCap)\\n            car+=people.get(i);\\n\\n            else \\n            {\\n                ans+=(long)len;\\n\\n                if(car==maxCap)\\n                car=people.get(i);\\n                \\n                else\\n                car=people.get(i)-(maxCap-car);\\n            }\\n         }\\n         \\n         if(car==maxCap)\\n         ans+=len;\\n\\n         return car==maxCap?0:car;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    long ans=0;\\n\\n    public long minimumFuelCost(int[][] roads, int seats) \\n    {\\n        int n=0;\\n        for(int i=0;i<roads.length;i++)\\n        n=Math.max(n,Math.max(roads[i][0],roads[i][1]));\\n        n++;\\n\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        adj.add(new ArrayList<>());\\n\\n        for(int i=0;i<roads.length;i++)\\n        {\\n            adj.get(roads[i][0]).add(roads[i][1]);\\n            adj.get(roads[i][1]).add(roads[i][0]);\\n        }\\n        \\n        int visited[]=new int[n];\\n        int x=dfs(0,adj,visited,seats,0);\\n\\n        return ans;\\n    }\\n\\n    public int dfs(int curr,List<List<Integer>> adj,int visited[],int maxCap,int len)\\n    {\\n        visited[curr]=1;\\n\\n        List<Integer> neigh=adj.get(curr);\\n        List<Integer> people=new ArrayList<>();\\n\\n        for(int i=0;i<neigh.size();i++)\\n        {\\n            if(visited[neigh.get(i)]==1)\\n            continue;\\n            \\n            int toAdd=dfs(neigh.get(i),adj,visited,maxCap,len+1);\\n\\n            if(toAdd>0)\\n            {\\n                ans++;\\n                people.add(toAdd);\\n            }\\n        }\\n         \\n         int car=1;\\n         Collections.sort(people);\\n\\n         for(int i=0;i<people.size();i++)\\n         {\\n            if(car+people.get(i)<=maxCap)\\n            car+=people.get(i);\\n\\n            else \\n            {\\n                ans+=(long)len;\\n\\n                if(car==maxCap)\\n                car=people.get(i);\\n                \\n                else\\n                car=people.get(i)-(maxCap-car);\\n            }\\n         }\\n         \\n         if(car==maxCap)\\n         ans+=len;\\n\\n         return car==maxCap?0:car;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832049,
                "title": "java-easy-recursive-solution",
                "content": "```\\nclass Solution {\\n    long fuel=0;\\n    public long fun(List<List<Integer>> tree, int seats,int cur,int vis[]){\\n        double c=0;\\n        if(cur!=0){\\n            c=1;\\n        }\\n        vis[cur]=1;\\n        \\n        for(int i:tree.get(cur)){\\n            if(vis[i]==0){\\n                c+=fun(tree,seats,i,vis);\\n            }\\n        }\\n        if(cur!=0)\\n        fuel+=(long)Math.ceil(c/seats);\\n        return (long)c;\\n    }\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        List<List<Integer>> tree=new ArrayList<>();\\n        int n=roads.length;\\n        for(int i=0;i<n+1;i++){\\n            tree.add(new ArrayList<>());\\n        }\\n        for(int[] i:roads){\\n            tree.get(i[0]).add(i[1]);\\n            tree.get(i[1]).add(i[0]);\\n        }\\n        fun(tree,seats,0,new int[n+1]);\\n        return fuel;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    long fuel=0;\\n    public long fun(List<List<Integer>> tree, int seats,int cur,int vis[]){\\n        double c=0;\\n        if(cur!=0){\\n            c=1;\\n        }\\n        vis[cur]=1;\\n        \\n        for(int i:tree.get(cur)){\\n            if(vis[i]==0){\\n                c+=fun(tree,seats,i,vis);\\n            }\\n        }\\n        if(cur!=0)\\n        fuel+=(long)Math.ceil(c/seats);\\n        return (long)c;\\n    }\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        List<List<Integer>> tree=new ArrayList<>();\\n        int n=roads.length;\\n        for(int i=0;i<n+1;i++){\\n            tree.add(new ArrayList<>());\\n        }\\n        for(int[] i:roads){\\n            tree.get(i[0]).add(i[1]);\\n            tree.get(i[1]).add(i[0]);\\n        }\\n        fun(tree,seats,0,new int[n+1]);\\n        return fuel;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831768,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    vi(vi(ll))g;\\n    ll n;\\n    vi(bool)vis; /* return {number of cars in use, number of members arrived, number of empty seats, total liters of fuels consumed} */\\n    vi(ll) func(ll nd, const int&seats){\\n        ll avail=0, dist=0, members=1, cars=0;\\n        vis[nd]=1;\\n        for(ll child:g[nd]){\\n            if(!vis[child]){\\n                vi(ll)rec=func(child, seats);\\n                cars+=rec[0], members+=rec[1], avail+=rec[2], dist+=rec[0]+rec[3];\\n            }\\n        }\\n        vis[nd]=0;\\n        /* removinf unnecessary cars */\\n        ll waste=avail/seats;\\n        cars-=waste;\\n        avail-=waste*seats;\\n        if(avail>0){\\n            --avail;\\n        }\\n        else{\\n            ++cars, avail=seats-1;\\n        }\\n        \\n        return {cars, members, avail, dist};\\n    }\\n    long long minimumFuelCost(vector<vector<int>>&e, int seats) {\\n        n=e.size()+1;\\n        g.resize(n), vis.assign(n, 0);\\n        for(const auto&it:e){\\n            g[it[0]].pb(it[1]), g[it[1]].pb(it[0]);\\n        }\\n        return func(0, seats)[3];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    vi(vi(ll))g;\\n    ll n;\\n    vi(bool)vis; /* return {number of cars in use, number of members arrived, number of empty seats, total liters of fuels consumed} */\\n    vi(ll) func(ll nd, const int&seats){\\n        ll avail=0, dist=0, members=1, cars=0;\\n        vis[nd]=1;\\n        for(ll child:g[nd]){\\n            if(!vis[child]){\\n                vi(ll)rec=func(child, seats);\\n                cars+=rec[0], members+=rec[1], avail+=rec[2], dist+=rec[0]+rec[3];\\n            }\\n        }\\n        vis[nd]=0;\\n        /* removinf unnecessary cars */\\n        ll waste=avail/seats;\\n        cars-=waste;\\n        avail-=waste*seats;\\n        if(avail>0){\\n            --avail;\\n        }\\n        else{\\n            ++cars, avail=seats-1;\\n        }\\n        \\n        return {cars, members, avail, dist};\\n    }\\n    long long minimumFuelCost(vector<vector<int>>&e, int seats) {\\n        n=e.size()+1;\\n        g.resize(n), vis.assign(n, 0);\\n        for(const auto&it:e){\\n            g[it[0]].pb(it[1]), g[it[1]].pb(it[0]);\\n        }\\n        return func(0, seats)[3];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947817,
                "title": "dfs-count-child-nodes",
                "content": "so the idea here is at each city we will accumulate the count of child nodes and before passing to next city we will fit them in mnimum no of cars (no of cars=fuel needed to just go to next city)\\nwe will start from zero and go to each branch and calculate no of child nodes for each branch if we are not at 0th node then we can fit them in minimum no of cars so that they can travel to 0th node with minimum cost\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<vector<int>> g;\\n    int st=0;\\n    long long f=0;\\n    \\n    int dfs(int s, int prev)\\n    {\\n        long long r=1;\\n        \\n        for(auto i: g[s])\\n        {\\n            if(i!=prev)\\n            {\\n                r+=dfs(i,s);\\n            }\\n        }\\n        \\n        if(s!=0)\\n        {\\n            f+=ceil((double)r/st);\\n        }\\n        \\n        return r;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) \\n    {\\n        int n=roads.size()+1;\\n        g.resize(n);\\n        for(auto i: roads)\\n        {\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        f=0;\\n        st=seats;\\n        dfs(0,-1);\\n        return f;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<vector<int>> g;\\n    int st=0;\\n    long long f=0;\\n    \\n    int dfs(int s, int prev)\\n    {\\n        long long r=1;\\n        \\n        for(auto i: g[s])\\n        {\\n            if(i!=prev)\\n            {\\n                r+=dfs(i,s);\\n            }\\n        }\\n        \\n        if(s!=0)\\n        {\\n            f+=ceil((double)r/st);\\n        }\\n        \\n        return r;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) \\n    {\\n        int n=roads.size()+1;\\n        g.resize(n);\\n        for(auto i: roads)\\n        {\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        f=0;\\n        st=seats;\\n        dfs(0,-1);\\n        return f;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468510,
                "title": "simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc minimumFuelCost(roads [][]int, seats int) int64 {\\n\\tconnections := make([][]int, len(roads)+1)\\n\\tfor _, rd := range roads {\\n\\t\\tfrom, to := rd[0], rd[1]\\n\\t\\tconnections[from] = append(connections[from], to)\\n\\t\\tconnections[to] = append(connections[to], from)\\n\\t}\\n\\tvar ot int = 0\\n\\tvisitingWithMax(0, -1, connections, seats, &ot)\\n\\treturn int64(ot)\\n}\\n\\nfunc visitingWithMax(current int, parent int, connections [][]int, seats int, res *int) int {\\n\\tcost := 1\\n\\tfor _, ct := range connections[current] {\\n\\t\\tif ct != parent {\\n\\t\\t\\tcost += visitingWithMax(ct, current, connections, seats, res)\\n\\t\\t}\\n\\t}\\n\\tif current != 0 {\\n\\t\\t*res += (cost + seats - 1) / seats\\n\\t}\\n\\n\\treturn cost\\n\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumFuelCost(roads [][]int, seats int) int64 {\\n\\tconnections := make([][]int, len(roads)+1)\\n\\tfor _, rd := range roads {\\n\\t\\tfrom, to := rd[0], rd[1]\\n\\t\\tconnections[from] = append(connections[from], to)\\n\\t\\tconnections[to] = append(connections[to], from)\\n\\t}\\n\\tvar ot int = 0\\n\\tvisitingWithMax(0, -1, connections, seats, &ot)\\n\\treturn int64(ot)\\n}\\n\\nfunc visitingWithMax(current int, parent int, connections [][]int, seats int, res *int) int {\\n\\tcost := 1\\n\\tfor _, ct := range connections[current] {\\n\\t\\tif ct != parent {\\n\\t\\t\\tcost += visitingWithMax(ct, current, connections, seats, res)\\n\\t\\t}\\n\\t}\\n\\tif current != 0 {\\n\\t\\t*res += (cost + seats - 1) / seats\\n\\t}\\n\\n\\treturn cost\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3357722,
                "title": "python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        graph=defaultdict(list)\\n        \\n        for i,j in roads:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n\\n        print(graph)\\n        \\n        \\n        def dfs(node,parent):\\n            nonlocal res\\n            \\n            passengers=0\\n\\n            for child in graph[node]:\\n                if child!=parent:\\n                    p=dfs(child,node)\\n                    passengers+=p\\n                    res += int(ceil(p/seats))\\n            return passengers+1\\n\\n        res = 0\\n        dfs(0,-1)\\n        return res\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        graph=defaultdict(list)\\n        \\n        for i,j in roads:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n\\n        print(graph)\\n        \\n        \\n        def dfs(node,parent):\\n            nonlocal res\\n            \\n            passengers=0\\n\\n            for child in graph[node]:\\n                if child!=parent:\\n                    p=dfs(child,node)\\n                    passengers+=p\\n                    res += int(ceil(p/seats))\\n            return passengers+1\\n\\n        res = 0\\n        dfs(0,-1)\\n        return res\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343399,
                "title": "bfs-python-well-commented-code",
                "content": "```\\nclass Solution:\\n    #author :  @PUDDINJK\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        \\n        #graph container\\n        graph = defaultdict(list)\\n        \\n        #to filter out leaf nodes on the graph\\n        degree = [0]* (len(roads)+1)\\n        \\n        #to count number of rep \\n        number_of_rep = [1]*(len(roads)+1)\\n        \\n        #builing graph using the following code\\n        for v, e in roads:\\n            graph[e].append(v)\\n            graph[v].append(e)\\n            degree[v]+=1\\n            degree[e]+=1\\n        \\n        #since we have to start from the child node we have to start with leaf node meaning nodes with one child\\n        queue = deque([node for node in range(len(degree)) if degree[node] == 1 and node != 0])\\n        \\n        fuel = 0\\n        \\n        \\n        while queue:\\n            node = queue.popleft()\\n            \\n            #calculate the number of coming cars here\\n            fuel+=ceil(number_of_rep[node]/seats)\\n           \\n            for vertex in graph[node]:\\n                degree[vertex]-=1\\n                \\n                #to calculate how many cars or representatives are coming from behind\\n                number_of_rep[vertex]+=number_of_rep[node]\\n                \\n                #if the vertex degree is 1 then there is a rep there if  its more than one we assume we reached the capital\\n                if degree[vertex] == 1 and vertex != 0:\\n                    queue.append(vertex)\\n        \\n        return fuel\\n                \\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    #author :  @PUDDINJK\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        \\n        #graph container\\n        graph = defaultdict(list)\\n        \\n        #to filter out leaf nodes on the graph\\n        degree = [0]* (len(roads)+1)\\n        \\n        #to count number of rep \\n        number_of_rep = [1]*(len(roads)+1)\\n        \\n        #builing graph using the following code\\n        for v, e in roads:\\n            graph[e].append(v)\\n            graph[v].append(e)\\n            degree[v]+=1\\n            degree[e]+=1\\n        \\n        #since we have to start from the child node we have to start with leaf node meaning nodes with one child\\n        queue = deque([node for node in range(len(degree)) if degree[node] == 1 and node != 0])\\n        \\n        fuel = 0\\n        \\n        \\n        while queue:\\n            node = queue.popleft()\\n            \\n            #calculate the number of coming cars here\\n            fuel+=ceil(number_of_rep[node]/seats)\\n           \\n            for vertex in graph[node]:\\n                degree[vertex]-=1\\n                \\n                #to calculate how many cars or representatives are coming from behind\\n                number_of_rep[vertex]+=number_of_rep[node]\\n                \\n                #if the vertex degree is 1 then there is a rep there if  its more than one we assume we reached the capital\\n                if degree[vertex] == 1 and vertex != 0:\\n                    queue.append(vertex)\\n        \\n        return fuel\\n                \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272715,
                "title": "o-n-time-o-n-spcae-using-simple-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOn each node try to fit all in car, if count of cities are lesser than seats then only we have to send this to above city with the cost of 1 fuel then leave it for above node to take responsibility to further city to send,\\n\\nSo now if there count is become greater or equal to no. of seats then we have to calculate the no. of car required by using count/seats and mutiple this divible ans by level of that cities (from capital cities to given cites how edge far it is ) and update the count by taking mod with seats\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) \\nIn order to constructs the tree o(n) space is required\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    static long ans=0;\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n\\n        ans=0;\\n        \\n        ArrayList<ArrayList<Integer>> tree=new ArrayList<>();\\n\\n        int n=roads.length +1;\\n\\n        if(n==1) return 0;\\n\\n        for(int i=0;i<n;i++) tree.add(new ArrayList<>());\\n\\n        for(int[] x:roads){\\n            int s=x[0];\\n            int e=x[1];\\n\\n            tree.get(s).add(e);\\n            tree.get(e).add(s);\\n        }\\n\\n        dfs(tree,0,-1,0,seats);\\n\\n        return ans;\\n\\n    }\\n\\n    public int dfs(ArrayList<ArrayList<Integer>> tree, int node, int parent, int currdep,int seats){\\n\\n            int count=0;\\n\\n            if(node!=0){\\n                 count=1; \\n            }\\n\\n            for(int nbr:tree.get(node)){\\n                if(nbr!=parent){\\n                    count+=dfs(tree,nbr,node,currdep+1,seats);\\n                }\\n            }\\n\\n            if(node!=0){\\n                 if(count>=seats){\\n                      int fac=count/seats;\\n                      ans+=fac*currdep;\\n                      count=count%seats;\\n                      if(count!=0){\\n                          ans++;\\n                      }\\n                   }else if(count<seats) ans++;\\n            }\\n\\n            return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    static long ans=0;\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n\\n        ans=0;\\n        \\n        ArrayList<ArrayList<Integer>> tree=new ArrayList<>();\\n\\n        int n=roads.length +1;\\n\\n        if(n==1) return 0;\\n\\n        for(int i=0;i<n;i++) tree.add(new ArrayList<>());\\n\\n        for(int[] x:roads){\\n            int s=x[0];\\n            int e=x[1];\\n\\n            tree.get(s).add(e);\\n            tree.get(e).add(s);\\n        }\\n\\n        dfs(tree,0,-1,0,seats);\\n\\n        return ans;\\n\\n    }\\n\\n    public int dfs(ArrayList<ArrayList<Integer>> tree, int node, int parent, int currdep,int seats){\\n\\n            int count=0;\\n\\n            if(node!=0){\\n                 count=1; \\n            }\\n\\n            for(int nbr:tree.get(node)){\\n                if(nbr!=parent){\\n                    count+=dfs(tree,nbr,node,currdep+1,seats);\\n                }\\n            }\\n\\n            if(node!=0){\\n                 if(count>=seats){\\n                      int fac=count/seats;\\n                      ans+=fac*currdep;\\n                      count=count%seats;\\n                      if(count!=0){\\n                          ans++;\\n                      }\\n                   }else if(count<seats) ans++;\\n            }\\n\\n            return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180609,
                "title": "2477-minimum-fuel-cost-to-report-to-the-capital-java",
                "content": "```\\nclass Solution {\\n    long ans=0;\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        List[] gra=new List[roads.length+1];\\n        \\n        for(int i=0;i<gra.length;i++)\\n            gra[i]=new ArrayList();\\n        \\n        for(int gr[]:roads)\\n        {\\n            int u=gr[0];\\n            int v=gr[1];\\n            gra[u].add(v);\\n            gra[v].add(u);\\n        }\\n        dfs(gra,0,-1,seats);\\n        return ans;\\n    }\\n     private int dfs(List<Integer>[] graph, int u, int prev, int seats) {\\n    int people = 1;\\n         for (final int v : graph[u]) \\n         {\\n          if (v == prev)\\n            continue;\\n          people += dfs(graph, v, u, seats);\\n         }\\n         if (u > 0)\\n        {\\n            long x=people/seats; \\n            if(people%seats>0)\\n                x++;\\n            ans += x;  \\n        }      \\n    return people;\\n  }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    long ans=0;\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        List[] gra=new List[roads.length+1];\\n        \\n        for(int i=0;i<gra.length;i++)\\n            gra[i]=new ArrayList();\\n        \\n        for(int gr[]:roads)\\n        {\\n            int u=gr[0];\\n            int v=gr[1];\\n            gra[u].add(v);\\n            gra[v].add(u);\\n        }\\n        dfs(gra,0,-1,seats);\\n        return ans;\\n    }\\n     private int dfs(List<Integer>[] graph, int u, int prev, int seats) {\\n    int people = 1;\\n         for (final int v : graph[u]) \\n         {\\n          if (v == prev)\\n            continue;\\n          people += dfs(graph, v, u, seats);\\n         }\\n         if (u > 0)\\n        {\\n            long x=people/seats; \\n            if(people%seats>0)\\n                x++;\\n            ans += x;  \\n        }      \\n    return people;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180380,
                "title": "golang-topological-sort",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfunc minimumFuelCost(roads [][]int, seats int) int64 {\\n    n := len(roads)+1\\n    adj := make([][]int, n)\\n    inDegree := make([]int, n)\\n\\n    for _, road := range roads {\\n        adj[road[0]] = append(adj[road[0]], road[1])\\n        adj[road[1]] = append(adj[road[1]], road[0])\\n        inDegree[road[0]]++\\n        inDegree[road[1]]++\\n    }\\n\\n    reps := make([]int, n)\\n    queue := []int{}\\n    \\n    // Don\\'t check 0\\n    for i := 1; i < n; i++ {\\n        if inDegree[i] == 1 {\\n            queue = append(queue, i)\\n        }\\n        reps[i] = 1\\n    }\\n\\n    res := 0\\n    for len(queue) > 0 {\\n        node := queue[0]\\n        queue = queue[1:]\\n\\n        res += int(math.Ceil(float64(reps[node])/float64(seats)))\\n        for _, next := range adj[node] {\\n            inDegree[next]--\\n            reps[next] += reps[node]\\n            if inDegree[next] == 1 && next != 0 {\\n                queue = append(queue, next)\\n            }\\n        }\\n    }\\n\\n    return int64(res)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Topological Sort"
                ],
                "code": "```\\nfunc minimumFuelCost(roads [][]int, seats int) int64 {\\n    n := len(roads)+1\\n    adj := make([][]int, n)\\n    inDegree := make([]int, n)\\n\\n    for _, road := range roads {\\n        adj[road[0]] = append(adj[road[0]], road[1])\\n        adj[road[1]] = append(adj[road[1]], road[0])\\n        inDegree[road[0]]++\\n        inDegree[road[1]]++\\n    }\\n\\n    reps := make([]int, n)\\n    queue := []int{}\\n    \\n    // Don\\'t check 0\\n    for i := 1; i < n; i++ {\\n        if inDegree[i] == 1 {\\n            queue = append(queue, i)\\n        }\\n        reps[i] = 1\\n    }\\n\\n    res := 0\\n    for len(queue) > 0 {\\n        node := queue[0]\\n        queue = queue[1:]\\n\\n        res += int(math.Ceil(float64(reps[node])/float64(seats)))\\n        for _, next := range adj[node] {\\n            inDegree[next]--\\n            reps[next] += reps[node]\\n            if inDegree[next] == 1 && next != 0 {\\n                queue = append(queue, next)\\n            }\\n        }\\n    }\\n\\n    return int64(res)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3177459,
                "title": "c-dfs-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& r, int s) {\\n        vector<vector<int>>adj(r.size() + 1);\\n        for(auto itr: r){\\n            adj[itr[0]].push_back(itr[1]);\\n            adj[itr[1]].push_back(itr[0]);\\n        }\\n        long long fCost = 0;\\n        traverser(0, adj, s, -1, fCost);\\n        return fCost;\\n    }\\nprivate:\\n    long long traverser(int curr, vector<vector<int>>&adj, int &s, int p, long long &fCost){\\n        long long sum = 1, res;\\n        for(auto itr: adj[curr]){\\n            if(itr != p){\\n                sum += traverser(itr, adj, s, curr, fCost);\\n            }\\n        }\\n        if(curr != 0){\\n            res = sum/s;\\n            if(sum % s != 0){\\n                res++;\\n            }\\n            fCost += res;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& r, int s) {\\n        vector<vector<int>>adj(r.size() + 1);\\n        for(auto itr: r){\\n            adj[itr[0]].push_back(itr[1]);\\n            adj[itr[1]].push_back(itr[0]);\\n        }\\n        long long fCost = 0;\\n        traverser(0, adj, s, -1, fCost);\\n        return fCost;\\n    }\\nprivate:\\n    long long traverser(int curr, vector<vector<int>>&adj, int &s, int p, long long &fCost){\\n        long long sum = 1, res;\\n        for(auto itr: adj[curr]){\\n            if(itr != p){\\n                sum += traverser(itr, adj, s, curr, fCost);\\n            }\\n        }\\n        if(curr != 0){\\n            res = sum/s;\\n            if(sum % s != 0){\\n                res++;\\n            }\\n            fCost += res;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177313,
                "title": "simple-easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach used in this solution is a depth-first search (DFS) algorithm. The algorithm starts at city 0 (the capital city) and recursively explores all its neighbors to calculate the number of people in each city and the minimum cost of reaching that city.\\n\\nThe dfs function takes as input the graph represented as an adjacency list, the current city u, the previous city prev, the number of seats in each car seats, and a reference to the variable ans to keep track of the minimum cost. The function returns the number of people in city u.\\n\\nThe algorithm works as follows:\\n\\nThe number of people in city u is initially set to 1.\\n\\nThe algorithm recursively visits each neighbor v of city u (excluding the previous city prev). The number of people in city v is updated by adding the number of people returned by the call to dfs for city v.\\n\\nIf u is not the capital city (i.e., u > 0), the minimum cost of reaching city u is updated by adding the number of cars required to transport all the people in the city. The number of cars required is calculated as the ceiling of the division of the number of people by the number of seats in each car.\\n\\nThe function returns the number of people in city u.\\n\\nThe final answer is stored in the variable ans and returned by the minimumFuelCost function\\n# Complexity\\n- Time complexity:\\n\\nThe time complexity of this solution is O(n), where n is the number of cities. This is because each city is visited exactly once in the DFS and the operation of visiting each city takes constant time O(1). The operation of visiting each city includes updating the number of people and the minimum cost, which take constant time O(1).\\n\\nSince the graph is a tree, there are no cycles and each edge is visited exactly once, so the total time complexity of the algorithm is O(n).\\n\\n- Space complexity:\\nThe space complexity of this solution is O(n), where n is the number of cities. This is because the maximum amount of space required by the algorithm is proportional to the number of cities in the graph.\\n\\nThe algorithm uses a vector of vectors to represent the graph, where each vector stores the list of neighbors of a city. The size of this vector of vectors is n, so the space complexity is O(n).\\n\\nAdditionally, the algorithm uses a recursive DFS to traverse the tree structure, and each call to the DFS function uses O(1) extra space to store the local variables. Since the height of the tree is O(log n) in the worst case, the total space complexity is O(n).\\n# Code\\n```\\nclass Solution {\\n public:\\n  long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n    long long ans = 0;\\n    vector<vector<int>> graph(roads.size() + 1);\\n\\n    for (const vector<int>& road : roads) {\\n      const int u = road[0], v = road[1];\\n      graph[u].push_back(v),graph[v].push_back(u);\\n    }\\n\\n    dfs(graph, 0, -1, seats, ans);\\n    return ans;\\n  }\\n\\n private:\\n  int dfs(const vector<vector<int>>& graph, int u, int prev, int seats,\\n          long long& ans) {\\n    int people = 1;\\n    for (const int v : graph[u]) {\\n      if (v == prev) continue;\\n      people += dfs(graph, v, u, seats, ans); }\\n    if (u > 0) ans += (people + seats - 1) / seats;\\n    return people;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n    long long ans = 0;\\n    vector<vector<int>> graph(roads.size() + 1);\\n\\n    for (const vector<int>& road : roads) {\\n      const int u = road[0], v = road[1];\\n      graph[u].push_back(v),graph[v].push_back(u);\\n    }\\n\\n    dfs(graph, 0, -1, seats, ans);\\n    return ans;\\n  }\\n\\n private:\\n  int dfs(const vector<vector<int>>& graph, int u, int prev, int seats,\\n          long long& ans) {\\n    int people = 1;\\n    for (const int v : graph[u]) {\\n      if (v == prev) continue;\\n      people += dfs(graph, v, u, seats, ans); }\\n    if (u > 0) ans += (people + seats - 1) / seats;\\n    return people;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177103,
                "title": "c-graph-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\n public:\\n  long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n    long long ans = 0;\\n    vector<vector<int>> graph(roads.size() + 1);\\n\\n    for (const vector<int>& road : roads) {\\n      const int u = road[0];\\n      const int v = road[1];\\n      graph[u].push_back(v);\\n      graph[v].push_back(u);\\n    }\\n\\n    dfs(graph, 0, -1, seats, ans);\\n    return ans;\\n  }\\n\\n private:\\n  int dfs(const vector<vector<int>>& graph, int u, int prev, int seats,\\n          long long& ans) {\\n    int people = 1;\\n    for (const int v : graph[u]) {\\n      if (v == prev)\\n        continue;\\n      people += dfs(graph, v, u, seats, ans);\\n    }\\n    if (u > 0)\\n      // # of cars needed = ceil(people / seats)\\n      ans += (people + seats - 1) / seats;\\n    return people;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n    long long ans = 0;\\n    vector<vector<int>> graph(roads.size() + 1);\\n\\n    for (const vector<int>& road : roads) {\\n      const int u = road[0];\\n      const int v = road[1];\\n      graph[u].push_back(v);\\n      graph[v].push_back(u);\\n    }\\n\\n    dfs(graph, 0, -1, seats, ans);\\n    return ans;\\n  }\\n\\n private:\\n  int dfs(const vector<vector<int>>& graph, int u, int prev, int seats,\\n          long long& ans) {\\n    int people = 1;\\n    for (const int v : graph[u]) {\\n      if (v == prev)\\n        continue;\\n      people += dfs(graph, v, u, seats, ans);\\n    }\\n    if (u > 0)\\n      // # of cars needed = ceil(people / seats)\\n      ans += (people + seats - 1) / seats;\\n    return people;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176964,
                "title": "cpp-easy-code-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is to check from the leaf node as we can see that calculating from the rear with the current Seatcount we can get the minimum ans.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We dive into the next node until we go to the leaf node.\\n2. From the leaf node we return the seat count add 1 to the ans.\\n3. Now we add the returned seats to total seats available in parent node.\\n4. if the currentSeats is greater than the maximum seats we can say that we have filled one car with maximum seats with representatives , and these representatives will go to the capital travelling through one node by one node. So we can say that the total fuel cost for this travel is the current node level. So we add this to ans. \\nNote that other travel fuel cost was added to the ans before coming to current stage.\\n\\nI may have not provided easy description. Sorry for that.\\nBut I think you will get the idea.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n).\\nI think these are the complexities,please correct me if I am wrong.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& edges, int seats) {\\n        int n = edges.size()+1;\\n        vector<vector<int>> adj(n);\\n        \\n        for(int i=0; i<edges.size();i++){\\n            adj[ edges[i][0] ].push_back( edges[i][1] );\\n            adj[ edges[i][1] ].push_back( edges[i][0] );\\n        }\\n        long long ans = 0;\\n        int avail = calulateDfs(0,-1,ans, 0,seats,adj);\\n        return ans;\\n    }\\n    int calulateDfs(int node , int parent , long long & ans, int lvl ,int & seats, vector<vector<int>> & adj ){\\n        int currSeats = 0;\\n        for(int child : adj[node]){\\n            if(child != parent){\\n                currSeats += calulateDfs(child, node ,ans, lvl+1 ,seats, adj);\\n                if(currSeats >= seats){\\n                    ans += ((currSeats/ seats) * lvl);\\n                    currSeats = currSeats % seats;\\n                }\\n            }\\n        }\\n        if(parent != -1) {\\n            ans++;\\n        }\\n        return currSeats+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& edges, int seats) {\\n        int n = edges.size()+1;\\n        vector<vector<int>> adj(n);\\n        \\n        for(int i=0; i<edges.size();i++){\\n            adj[ edges[i][0] ].push_back( edges[i][1] );\\n            adj[ edges[i][1] ].push_back( edges[i][0] );\\n        }\\n        long long ans = 0;\\n        int avail = calulateDfs(0,-1,ans, 0,seats,adj);\\n        return ans;\\n    }\\n    int calulateDfs(int node , int parent , long long & ans, int lvl ,int & seats, vector<vector<int>> & adj ){\\n        int currSeats = 0;\\n        for(int child : adj[node]){\\n            if(child != parent){\\n                currSeats += calulateDfs(child, node ,ans, lvl+1 ,seats, adj);\\n                if(currSeats >= seats){\\n                    ans += ((currSeats/ seats) * lvl);\\n                    currSeats = currSeats % seats;\\n                }\\n            }\\n        }\\n        if(parent != -1) {\\n            ans++;\\n        }\\n        return currSeats+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176575,
                "title": "python-depth-first-search-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:    \\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        def dfs(i, prev, people = 1):\\n            for x in graph[i]:\\n                if x == prev:\\n                    continue\\n                people += dfs(x, i)\\n            if i:\\n                self.ans += (int(ceil(people / seats)))\\n            else:\\n                self.ans += 0\\n            return people\\n        graph = defaultdict(list)\\n        for x, y in roads:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n        self.ans = 0\\n        dfs(0, 0)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:    \\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        def dfs(i, prev, people = 1):\\n            for x in graph[i]:\\n                if x == prev:\\n                    continue\\n                people += dfs(x, i)\\n            if i:\\n                self.ans += (int(ceil(people / seats)))\\n            else:\\n                self.ans += 0\\n            return people\\n        graph = defaultdict(list)\\n        for x, y in roads:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n        self.ans = 0\\n        dfs(0, 0)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176521,
                "title": "simple-and-understandable-post-order-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    long long ans;\\n\\n    long long postOrder(unordered_map<int,set<int>>& adj, int node, int pnode, int& seats) {\\n        set<int> conn = adj[node];\\n        if(conn.size() == 1 && node != 0) {\\n            ans++;\\n            return 1ll;\\n        }\\n        long long count = 0ll;\\n        for(auto itr=conn.begin();itr != conn.end();itr++) {\\n            if(*itr != pnode) {\\n                long long peopleAtCurrentNode = postOrder(adj, *itr, node, seats);\\n                count += peopleAtCurrentNode;\\n            }\\n        }\\n        count++;\\n        //cout << node << \" \" << count << \"\\\\n\";\\n        if(node)\\n            ans = ans + (count / seats) + (count % seats != 0);\\n        return count;\\n    }\\n\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        ans = 0;\\n        unordered_map<int,set<int>> adj;\\n        int n = roads.size();\\n        for(int i=0;i<n;i++) {\\n            adj[roads[i][0]].insert(roads[i][1]);\\n            adj[roads[i][1]].insert(roads[i][0]);\\n        }\\n        postOrder(adj, 0, -1, seats);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    long long ans;\\n\\n    long long postOrder(unordered_map<int,set<int>>& adj, int node, int pnode, int& seats) {\\n        set<int> conn = adj[node];\\n        if(conn.size() == 1 && node != 0) {\\n            ans++;\\n            return 1ll;\\n        }\\n        long long count = 0ll;\\n        for(auto itr=conn.begin();itr != conn.end();itr++) {\\n            if(*itr != pnode) {\\n                long long peopleAtCurrentNode = postOrder(adj, *itr, node, seats);\\n                count += peopleAtCurrentNode;\\n            }\\n        }\\n        count++;\\n        //cout << node << \" \" << count << \"\\\\n\";\\n        if(node)\\n            ans = ans + (count / seats) + (count % seats != 0);\\n        return count;\\n    }\\n\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        ans = 0;\\n        unordered_map<int,set<int>> adj;\\n        int n = roads.size();\\n        for(int i=0;i<n;i++) {\\n            adj[roads[i][0]].insert(roads[i][1]);\\n            adj[roads[i][1]].insert(roads[i][0]);\\n        }\\n        postOrder(adj, 0, -1, seats);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3176517,
                "title": "see-my-hints-and-try-ones-again-unique-dfs-solution-with-proper-explanation-and-clean-code",
                "content": "# Intuition\\nSimple dfs base solution \\n- Try yourself Using hints before looking code.\\n\\n# Hints \\n- Use globle variable to store Fule amount\\n- DFS for counting number of nodes in each subtree\\n- For each node in dfs store the count of fule to go to next higher level\\n\\n# Complexity\\n- Time complexity: O(V) \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    long fuel;\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        if(roads.length == 0) return 0;\\n        fuel = 0;\\n        List<List<Integer>> ls = new ArrayList<>();\\n        for(int i = 0; i<=roads.length; i++) ls.add(new ArrayList<>());\\n        for(int road[] : roads){\\n            ls.get(road[0]).add(road[1]);\\n            ls.get(road[1]).add(road[0]);\\n        }\\n        boolean vis[] = new boolean[roads.length+1];\\n        dfs(0, roads.length, ls, seats, vis);\\n        return fuel;\\n    }\\n\\n    private long dfs(int city, int n, List<List<Integer>> ls, int seats, boolean[] vis){\\n        if(city > n || vis[city]) return 0;\\n        vis[city] = true;\\n        int nodes = 0;\\n        for(int x : ls.get(city)){\\n            nodes += dfs(x, n, ls, seats, vis);\\n        }\\n        nodes++;\\n        if(city != 0)\\n            fuel += nodes%seats == 0 ? nodes/seats : nodes/seats + 1;\\n        return nodes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    long fuel;\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        if(roads.length == 0) return 0;\\n        fuel = 0;\\n        List<List<Integer>> ls = new ArrayList<>();\\n        for(int i = 0; i<=roads.length; i++) ls.add(new ArrayList<>());\\n        for(int road[] : roads){\\n            ls.get(road[0]).add(road[1]);\\n            ls.get(road[1]).add(road[0]);\\n        }\\n        boolean vis[] = new boolean[roads.length+1];\\n        dfs(0, roads.length, ls, seats, vis);\\n        return fuel;\\n    }\\n\\n    private long dfs(int city, int n, List<List<Integer>> ls, int seats, boolean[] vis){\\n        if(city > n || vis[city]) return 0;\\n        vis[city] = true;\\n        int nodes = 0;\\n        for(int x : ls.get(city)){\\n            nodes += dfs(x, n, ls, seats, vis);\\n        }\\n        nodes++;\\n        if(city != 0)\\n            fuel += nodes%seats == 0 ? nodes/seats : nodes/seats + 1;\\n        return nodes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176339,
                "title": "java-c-rust",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    long ans = 0, seats;\\n    List<Integer>[] con;\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        int n = roads.length + 1;\\n        con = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            con[i] = new ArrayList<>();\\n        }\\n        for (int[] road: roads) {\\n            con[road[0]].add(road[1]);\\n            con[road[1]].add(road[0]);\\n        }\\n        this.seats = seats;\\n        this.ans = 0;\\n\\n        dfs(0, -1);\\n\\n        return ans;\\n    }\\n\\n    private long[] dfs(int city, int dest) {\\n        long filledCars = 0;\\n        // Shiftable people is the total number of people in unfully filled cars\\n        long shiftablePeople = 0;\\n\\n        for (int neighbor: con[city]) {\\n            if (neighbor == dest) continue;\\n            long[] res = dfs(neighbor, city);\\n            ans += res[0] + (res[1] > 0 ? 1 : 0);\\n\\n            filledCars += res[0];\\n            shiftablePeople += res[1];\\n        }\\n\\n        shiftablePeople += 1;\\n\\n        filledCars += shiftablePeople / seats;\\n        return new long[]{filledCars, shiftablePeople % seats};\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> cons;\\n    long long ans;\\n    int maxSeats;\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size() + 1;\\n        cons = vector<vector<int>>(n);\\n        for (auto road: roads) {\\n            cons[road[0]].push_back(road[1]);\\n            cons[road[1]].push_back(road[0]);\\n        }\\n\\n        ans = 0;\\n        maxSeats = seats;\\n\\n        dfs(0, -1);\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    long* dfs(int city, int dest) {\\n        long long filledCars = 0;\\n        long long shiftablePeople = 0;\\n\\n        for (auto neighbor: cons[city]) {\\n            if (neighbor == dest) continue;\\n            long* res = dfs(neighbor, city);\\n            \\n            ans += *res + (*(res + 1) > 0 ? 1: 0);\\n\\n            filledCars += res[0];\\n            shiftablePeople += res[1];\\n        }\\n\\n        shiftablePeople += 1;\\n        filledCars += shiftablePeople / maxSeats;\\n\\n        return new long[2]{filledCars, shiftablePeople % maxSeats};\\n    }\\n};\\n```\\n```Rust []\\nimpl Solution {\\n    pub fn minimum_fuel_cost(roads: Vec<Vec<i32>>, seats: i32) -> i64 {\\n        let (mut cost, n) = (0, roads.len() + 1);\\n        let mut con = vec![Vec::new(); n];\\n        for road in roads {\\n            let (a, b) = (road[0] as usize, road[1] as usize);\\n            con[a].push(b);\\n            con[b].push(a);\\n        }\\n\\n        Self::dfs(0, n, &con, &mut cost, seats as i64);\\n\\n        cost\\n    }\\n\\n    fn dfs(city: usize, dest: usize, roads: &Vec<Vec<usize>>, cost: &mut i64, max_seats: i64) -> (i64, i64) {\\n        // the return tuple is (filled cars, number of people in unfilled car)\\n        let mut all_full_cars = 0;\\n        let mut shiftable_people = 0;\\n        for &neighbor in roads[city].iter() {\\n            if neighbor != dest {\\n                let (full_cars, unfilled_car_members) = Self::dfs(neighbor, city, roads, cost, max_seats);\\n                *cost += full_cars + if unfilled_car_members > 0 { 1 } else { 0 };\\n                shiftable_people += unfilled_car_members;\\n                all_full_cars += full_cars;\\n            }\\n        }\\n        // representative of current city must add himself to the shiftable people\\n        shiftable_people += 1;\\n        all_full_cars += shiftable_people / max_seats;\\n        \\n        (all_full_cars, shiftable_people % max_seats)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```Java []\\nclass Solution {\\n    long ans = 0, seats;\\n    List<Integer>[] con;\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        int n = roads.length + 1;\\n        con = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            con[i] = new ArrayList<>();\\n        }\\n        for (int[] road: roads) {\\n            con[road[0]].add(road[1]);\\n            con[road[1]].add(road[0]);\\n        }\\n        this.seats = seats;\\n        this.ans = 0;\\n\\n        dfs(0, -1);\\n\\n        return ans;\\n    }\\n\\n    private long[] dfs(int city, int dest) {\\n        long filledCars = 0;\\n        // Shiftable people is the total number of people in unfully filled cars\\n        long shiftablePeople = 0;\\n\\n        for (int neighbor: con[city]) {\\n            if (neighbor == dest) continue;\\n            long[] res = dfs(neighbor, city);\\n            ans += res[0] + (res[1] > 0 ? 1 : 0);\\n\\n            filledCars += res[0];\\n            shiftablePeople += res[1];\\n        }\\n\\n        shiftablePeople += 1;\\n\\n        filledCars += shiftablePeople / seats;\\n        return new long[]{filledCars, shiftablePeople % seats};\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<int>> cons;\\n    long long ans;\\n    int maxSeats;\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size() + 1;\\n        cons = vector<vector<int>>(n);\\n        for (auto road: roads) {\\n            cons[road[0]].push_back(road[1]);\\n            cons[road[1]].push_back(road[0]);\\n        }\\n\\n        ans = 0;\\n        maxSeats = seats;\\n\\n        dfs(0, -1);\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    long* dfs(int city, int dest) {\\n        long long filledCars = 0;\\n        long long shiftablePeople = 0;\\n\\n        for (auto neighbor: cons[city]) {\\n            if (neighbor == dest) continue;\\n            long* res = dfs(neighbor, city);\\n            \\n            ans += *res + (*(res + 1) > 0 ? 1: 0);\\n\\n            filledCars += res[0];\\n            shiftablePeople += res[1];\\n        }\\n\\n        shiftablePeople += 1;\\n        filledCars += shiftablePeople / maxSeats;\\n\\n        return new long[2]{filledCars, shiftablePeople % maxSeats};\\n    }\\n};\\n```\n```Rust []\\nimpl Solution {\\n    pub fn minimum_fuel_cost(roads: Vec<Vec<i32>>, seats: i32) -> i64 {\\n        let (mut cost, n) = (0, roads.len() + 1);\\n        let mut con = vec![Vec::new(); n];\\n        for road in roads {\\n            let (a, b) = (road[0] as usize, road[1] as usize);\\n            con[a].push(b);\\n            con[b].push(a);\\n        }\\n\\n        Self::dfs(0, n, &con, &mut cost, seats as i64);\\n\\n        cost\\n    }\\n\\n    fn dfs(city: usize, dest: usize, roads: &Vec<Vec<usize>>, cost: &mut i64, max_seats: i64) -> (i64, i64) {\\n        // the return tuple is (filled cars, number of people in unfilled car)\\n        let mut all_full_cars = 0;\\n        let mut shiftable_people = 0;\\n        for &neighbor in roads[city].iter() {\\n            if neighbor != dest {\\n                let (full_cars, unfilled_car_members) = Self::dfs(neighbor, city, roads, cost, max_seats);\\n                *cost += full_cars + if unfilled_car_members > 0 { 1 } else { 0 };\\n                shiftable_people += unfilled_car_members;\\n                all_full_cars += full_cars;\\n            }\\n        }\\n        // representative of current city must add himself to the shiftable people\\n        shiftable_people += 1;\\n        all_full_cars += shiftable_people / max_seats;\\n        \\n        (all_full_cars, shiftable_people % max_seats)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176229,
                "title": "typescript-dfs-graph",
                "content": "# Approach\\nUse DFS to Traverse Graph in order to calculate the number of people that passed a road, calculate the number of cars need for the number of people to pass that particular road; \\n\\n# Complexity\\n- Time complexity:\\n    $$O(n)$$\\n\\n- Space complexity:\\n    $$O(n)$$\\n\\n# Code\\n```\\n\\ntype people = number\\nfunction minimumFuelCost(roads: number[][], seats: number): number {\\n    let result = 0;\\n    const adjList:Map<number,number[]> = new Map();\\n    for(const road of roads){\\n        if(adjList.has(road[0])){\\n            adjList.get(road[0]).push(road[1])\\n        }else{\\n            adjList.set(road[0],[road[1]])\\n        }        \\n        if(adjList.has(road[1])){\\n            adjList.get(road[1]).push(road[0])\\n        }else{\\n            adjList.set(road[1],[road[0]])\\n        }\\n    }\\n    if(roads.length == 0) return 0;\\n    let seen = new Set();\\n    const DFS = (city:number): people => {\\n        if(!seen.has(city)){\\n            seen.add(city);\\n            let Totalpeople = 0;\\n            adjList.get(city).forEach((v) => {\\n                // get number of people to pass a the road to the current city \\n                let people =  DFS(v)\\n                result += Math.ceil(people / seats);\\n                Totalpeople += people;\\n            })\\n            return Totalpeople + 1\\n        }  \\n        return 0;\\n    }\\n\\n    DFS(0) // start from capital\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n\\ntype people = number\\nfunction minimumFuelCost(roads: number[][], seats: number): number {\\n    let result = 0;\\n    const adjList:Map<number,number[]> = new Map();\\n    for(const road of roads){\\n        if(adjList.has(road[0])){\\n            adjList.get(road[0]).push(road[1])\\n        }else{\\n            adjList.set(road[0],[road[1]])\\n        }        \\n        if(adjList.has(road[1])){\\n            adjList.get(road[1]).push(road[0])\\n        }else{\\n            adjList.set(road[1],[road[0]])\\n        }\\n    }\\n    if(roads.length == 0) return 0;\\n    let seen = new Set();\\n    const DFS = (city:number): people => {\\n        if(!seen.has(city)){\\n            seen.add(city);\\n            let Totalpeople = 0;\\n            adjList.get(city).forEach((v) => {\\n                // get number of people to pass a the road to the current city \\n                let people =  DFS(v)\\n                result += Math.ceil(people / seats);\\n                Totalpeople += people;\\n            })\\n            return Totalpeople + 1\\n        }  \\n        return 0;\\n    }\\n\\n    DFS(0) // start from capital\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3176198,
                "title": "c-dfs-graph-faster-easy-to-understand",
                "content": "* ***Using DFS***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long ans = 0;\\n    \\n    int dfs(vector<vector<int>>& adj, int u, int seats, vector<bool>& vis)\\n    {\\n        // mark the current node as visited\\n        \\n        vis[u] = true;\\n        \\n        // count will keep track of no. of nodes (descendent + including)\\n        \\n        int count = 1;\\n        \\n        // call all the adjacent nodes\\n        \\n        for(auto v : adj[u])\\n        {\\n            if(vis[v] == false)\\n            {\\n                count += dfs(adj, v, seats, vis);\\n            }\\n        }\\n        \\n        // increment the ans\\n        \\n        if(u != 0)\\n        {\\n            ans += ceil((double) count / seats);\\n        }\\n        \\n        return count;\\n    }\\n    \\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n = roads.size();\\n        \\n        // declare an adjacency list\\n        \\n        vector<vector<int>> adj(n + 1);\\n        \\n        // fill the adjacency list\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int u = roads[i][0];\\n            \\n            int v = roads[i][1];\\n            \\n            adj[u].push_back(v);\\n            \\n            adj[v].push_back(u);\\n        }\\n        \\n        // declare a visited array\\n        \\n        vector<bool> vis(n + 1, false);\\n        \\n        // call dfs function\\n        \\n        dfs(adj, 0, seats, vis);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long ans = 0;\\n    \\n    int dfs(vector<vector<int>>& adj, int u, int seats, vector<bool>& vis)\\n    {\\n        // mark the current node as visited\\n        \\n        vis[u] = true;\\n        \\n        // count will keep track of no. of nodes (descendent + including)\\n        \\n        int count = 1;\\n        \\n        // call all the adjacent nodes\\n        \\n        for(auto v : adj[u])\\n        {\\n            if(vis[v] == false)\\n            {\\n                count += dfs(adj, v, seats, vis);\\n            }\\n        }\\n        \\n        // increment the ans\\n        \\n        if(u != 0)\\n        {\\n            ans += ceil((double) count / seats);\\n        }\\n        \\n        return count;\\n    }\\n    \\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n = roads.size();\\n        \\n        // declare an adjacency list\\n        \\n        vector<vector<int>> adj(n + 1);\\n        \\n        // fill the adjacency list\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int u = roads[i][0];\\n            \\n            int v = roads[i][1];\\n            \\n            adj[u].push_back(v);\\n            \\n            adj[v].push_back(u);\\n        }\\n        \\n        // declare a visited array\\n        \\n        vector<bool> vis(n + 1, false);\\n        \\n        // call dfs function\\n        \\n        dfs(adj, 0, seats, vis);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176053,
                "title": "rust-100",
                "content": "```Rust\\nimpl Solution {\\n    pub fn minimum_fuel_cost(roads: Vec<Vec<i32>>, seats: i32) -> i64 {\\n        let n = roads.len();\\n        \\n        if n == 0 {\\n            return 0;\\n        }\\n        \\n        let mut edges = vec![vec![]; n + 1];\\n\\n        for road in roads {\\n            let (l, r) = (road[0] as usize, road[1] as usize);\\n            edges[r].push(l);\\n            edges[l].push(r);\\n        }\\n\\n        let mut r: i64 = 0;\\n        Self::dfs(&edges, 0, 0, seats as i64, &mut r);\\n\\n        r\\n    }\\n\\n    fn dfs(edges: &Vec<Vec<usize>>, cur: usize, prev: usize, seats: i64,  mut r: &mut i64) -> i64 {\\n        let mut sum = 1;\\n        for &e in &edges[cur] {\\n            if e != prev {\\n                sum += Self::dfs(&edges, e, cur, seats, &mut r);\\n            }\\n        }\\n\\n        if cur != 0 {\\n            *r += (sum-1) / seats + 1;\\n        }\\n\\n        sum\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```Rust\\nimpl Solution {\\n    pub fn minimum_fuel_cost(roads: Vec<Vec<i32>>, seats: i32) -> i64 {\\n        let n = roads.len();\\n        \\n        if n == 0 {\\n            return 0;\\n        }\\n        \\n        let mut edges = vec![vec![]; n + 1];\\n\\n        for road in roads {\\n            let (l, r) = (road[0] as usize, road[1] as usize);\\n            edges[r].push(l);\\n            edges[l].push(r);\\n        }\\n\\n        let mut r: i64 = 0;\\n        Self::dfs(&edges, 0, 0, seats as i64, &mut r);\\n\\n        r\\n    }\\n\\n    fn dfs(edges: &Vec<Vec<usize>>, cur: usize, prev: usize, seats: i64,  mut r: &mut i64) -> i64 {\\n        let mut sum = 1;\\n        for &e in &edges[cur] {\\n            if e != prev {\\n                sum += Self::dfs(&edges, e, cur, seats, &mut r);\\n            }\\n        }\\n\\n        if cur != 0 {\\n            *r += (sum-1) / seats + 1;\\n        }\\n\\n        sum\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3176016,
                "title": "simple-direct-approach-using-dfs-with-explanation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe number of representative arriving at this node will be equal to the number of nodes in the subtree with that node as root.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, I calculated and stored the number of nodes or vertices in the subtree at each node. As the number of representative arriving at this node will be equal to the number of nodes in the subtree with that node as root.\\n\\nSo, at last added the cost according to the minimum of cars required for the given number of representatives.\\n\\n# Complexity\\n- Time complexity: O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n``` Here V is equal to n and E = n-1,so O(2*n-1) ```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int v, vector<vector<int>> &g, vector<long long> &subTreeSize, vector<bool> &vis){\\n        vis[v] = true;\\n\\n        long long noOfNodes = 0;\\n        for(auto child : g[v]){\\n            if(!vis[child]){\\n                dfs(child,g,subTreeSize,vis);\\n                subTreeSize[v] += subTreeSize[child];\\n            }\\n        }\\n\\n        subTreeSize[v] += 1;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n\\n        int n = roads.size() + 1;\\n        vector<vector<int>> g(n);\\n\\n        for(auto v : roads){\\n            g[v[0]].push_back(v[1]);\\n            g[v[1]].push_back(v[0]);\\n        }\\n\\n        vector<long long> subTreeSize(n,0);\\n        vector<bool> vis(n,false);\\n\\n        dfs(0,g,subTreeSize,vis);\\n\\n        long long cost = 0;\\n        for(int i = 1;i<n;i++){\\n            cost += (subTreeSize[i]/seats);\\n            if(subTreeSize[i]%seats != 0) cost++;\\n        }\\n\\n        return cost;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "``` Here V is equal to n and E = n-1,so O(2*n-1) ```\n```\\nclass Solution {\\npublic:\\n    void dfs(int v, vector<vector<int>> &g, vector<long long> &subTreeSize, vector<bool> &vis){\\n        vis[v] = true;\\n\\n        long long noOfNodes = 0;\\n        for(auto child : g[v]){\\n            if(!vis[child]){\\n                dfs(child,g,subTreeSize,vis);\\n                subTreeSize[v] += subTreeSize[child];\\n            }\\n        }\\n\\n        subTreeSize[v] += 1;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n\\n        int n = roads.size() + 1;\\n        vector<vector<int>> g(n);\\n\\n        for(auto v : roads){\\n            g[v[0]].push_back(v[1]);\\n            g[v[1]].push_back(v[0]);\\n        }\\n\\n        vector<long long> subTreeSize(n,0);\\n        vector<bool> vis(n,false);\\n\\n        dfs(0,g,subTreeSize,vis);\\n\\n        long long cost = 0;\\n        for(int i = 1;i<n;i++){\\n            cost += (subTreeSize[i]/seats);\\n            if(subTreeSize[i]%seats != 0) cost++;\\n        }\\n\\n        return cost;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175990,
                "title": "ceil-total-childs-of-a-node-seats",
                "content": "```\\nclass Solution {\\npublic:\\n    void countChilds(int index, vector<int> &c, vector<vector<int>>& g)\\n    {\\n        c[index] = 1;\\n        for(int i : g[index])\\n        {\\n            if(c[i] == 0)\\n            {\\n                countChilds(i,c,g);\\n                c[index] += c[i]; \\n            }\\n        }\\n        \\n    }\\n    \\n    long long minimumFuelCost(vector<vector<int>>& r, int s) {\\n        \\n        \\n        int n = r.size();\\n        vector<vector<int>> g(n+1);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            g[r[i][0]].push_back(r[i][1]);\\n            g[r[i][1]].push_back(r[i][0]);\\n        }\\n        \\n        \\n        \\n        vector<int> c(n+1,0),vis(n+1,0);\\n        countChilds(0,c,g);\\n        // cout<<\"hi\"<<endl;\\n        \\n        queue<int> q;\\n        q.push(0);\\n       long long  int res = 0;\\n        vis[0] =1;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                int x = q.front();\\n                q.pop();\\n                for(int j : g[x]){\\n                    if(vis[j] == 1)\\n                        continue;\\n                    vis[j] = 1;\\n                    res+=c[j]/s;\\n                    if(c[j]%s)\\n                        res++;\\n                    q.push(j);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void countChilds(int index, vector<int> &c, vector<vector<int>>& g)\\n    {\\n        c[index] = 1;\\n        for(int i : g[index])\\n        {\\n            if(c[i] == 0)\\n            {\\n                countChilds(i,c,g);\\n                c[index] += c[i]; \\n            }\\n        }\\n        \\n    }\\n    \\n    long long minimumFuelCost(vector<vector<int>>& r, int s) {\\n        \\n        \\n        int n = r.size();\\n        vector<vector<int>> g(n+1);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            g[r[i][0]].push_back(r[i][1]);\\n            g[r[i][1]].push_back(r[i][0]);\\n        }\\n        \\n        \\n        \\n        vector<int> c(n+1,0),vis(n+1,0);\\n        countChilds(0,c,g);\\n        // cout<<\"hi\"<<endl;\\n        \\n        queue<int> q;\\n        q.push(0);\\n       long long  int res = 0;\\n        vis[0] =1;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                int x = q.front();\\n                q.pop();\\n                for(int j : g[x]){\\n                    if(vis[j] == 1)\\n                        continue;\\n                    vis[j] = 1;\\n                    res+=c[j]/s;\\n                    if(c[j]%s)\\n                        res++;\\n                    q.push(j);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3175806,
                "title": "c-dfs-solution-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\n    long long ans = 0; int s;\\n    \\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        vector<vector<int>> graph(roads.size() + 1); s = seats;\\n        \\n        for (vector<int>& r: roads) {\\n            \\n            graph[r[0]].push_back(r[1]);\\n            \\n            graph[r[1]].push_back(r[0]);\\n        }\\n        \\n        dfs(0, 0, graph);\\n        \\n        return ans;\\n    }\\n    \\n    \\n    int dfs(int i, int prev, vector<vector<int>>& graph, int people = 1) {\\n        \\n        \\n        for (int& x: graph[i]) {\\n            \\n            if (x == prev) continue;\\n            people += dfs(x, i, graph);\\n            \\n        }\\n        \\n        if (i != 0) ans += (people + s - 1) / s;\\n        \\n        return people;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# upvote",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n\\n    long long ans = 0; int s;\\n    \\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        vector<vector<int>> graph(roads.size() + 1); s = seats;\\n        \\n        for (vector<int>& r: roads) {\\n            \\n            graph[r[0]].push_back(r[1]);\\n            \\n            graph[r[1]].push_back(r[0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3175602,
                "title": "easy-to-understand-solution-using-dfs-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe intution behind the solution is that at each parent node we will ask from its children nodes to give me two values \\n1. Give the number of cities repersentatives(twoValue.prez), which will be equal to number of children nodes(cities repersentatives) of the parent node(city).\\n2. And the no. of tours(twoValue.tour) children nodes(cities repersentatives) have to take to reach the parent node(city).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we will create the adjacency list to store the graph, and we will also create the visited array to track the visited nodes.\\n\\nNow we will call helper and sent the starting vertex as 0.\\n\\nNow in helper function we will traverse through each neighbours of vertex and we will ask the neighbours if they are not already visited then we will call the helper and ask the twoValue from them, which is\\n1. Give the number of cities repersentatives(twoValue.prez), which will be equal to number of children nodes(cities repersentatives).\\n2. And the no. of tours(twoValue.tour) does children nodes(cities repersentatives) they have to take to reach to current node\\n\\nThen we will add the twoValues for each neighbours which are not visited yet. \\n\\nNow we will exit the for loop and increment the ans.prez value signifing that the current parent node(city) repersentative is also needed to travel along with the repersentative of children node cities, and if the number of prez is not equal to multiple of seats then we will need and extra car to send the left out rersentatives and if they are multiple of seats then we only need ans.prez/seats cars to transport the repersentatives.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        \\n        ArrayList<ArrayList<Integer>> adjList = new ArrayList<>();\\n\\n        for(int i=0; i<roads.length+1; i++)\\n        {\\n            adjList.add(new ArrayList<Integer>());\\n        }\\n\\n        for(int i=0; i<roads.length; i++)\\n        {\\n            ArrayList<Integer> arr1 = adjList.get(roads[i][0]);\\n            ArrayList<Integer> arr2 = adjList.get(roads[i][1]);\\n\\n            arr1.add(roads[i][1]);\\n            arr2.add(roads[i][0]);\\n        }\\n\\n        boolean visited[] = new boolean[roads.length+1];\\n\\n        visited[0] = true;\\n\\n        twoVal ans = helper(0, adjList, seats, visited);\\n\\n        return ans.tour;\\n    }\\n\\n\\n    public twoVal helper(int vertex, ArrayList<ArrayList<Integer>> adjList, int seats, boolean [] visited)\\n    {\\n        twoVal ans = new twoVal(0, 0);\\n\\n        ArrayList neighbours = adjList.get(vertex);\\n        for(int i=0; i<neighbours.size(); i++)\\n        {\\n            int index = (int)neighbours.get(i);\\n            if(!visited[index])\\n            {\\n\\n                visited[index] = true;\\n\\n                twoVal temp = helper(index, adjList, seats, visited);\\n\\n                ans.prez += temp.prez;\\n                ans.tour += temp.tour;\\n            }\\n        }\\n\\n        if(vertex == 0)\\n        {\\n            return ans;\\n        }\\n\\n        ans.prez++;\\n        if(ans.prez%seats != 0)\\n        {\\n            ans.tour += (ans.prez/seats)+1;\\n        }\\n        else\\n        {\\n            ans.tour += (ans.prez/seats);\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\nclass twoVal{\\n    long prez;\\n    long tour;\\n\\n    public twoVal(long prez, long tour)\\n    {\\n        this.prez = prez;\\n        this.tour = tour;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        \\n        ArrayList<ArrayList<Integer>> adjList = new ArrayList<>();\\n\\n        for(int i=0; i<roads.length+1; i++)\\n        {\\n            adjList.add(new ArrayList<Integer>());\\n        }\\n\\n        for(int i=0; i<roads.length; i++)\\n        {\\n            ArrayList<Integer> arr1 = adjList.get(roads[i][0]);\\n            ArrayList<Integer> arr2 = adjList.get(roads[i][1]);\\n\\n            arr1.add(roads[i][1]);\\n            arr2.add(roads[i][0]);\\n        }\\n\\n        boolean visited[] = new boolean[roads.length+1];\\n\\n        visited[0] = true;\\n\\n        twoVal ans = helper(0, adjList, seats, visited);\\n\\n        return ans.tour;\\n    }\\n\\n\\n    public twoVal helper(int vertex, ArrayList<ArrayList<Integer>> adjList, int seats, boolean [] visited)\\n    {\\n        twoVal ans = new twoVal(0, 0);\\n\\n        ArrayList neighbours = adjList.get(vertex);\\n        for(int i=0; i<neighbours.size(); i++)\\n        {\\n            int index = (int)neighbours.get(i);\\n            if(!visited[index])\\n            {\\n\\n                visited[index] = true;\\n\\n                twoVal temp = helper(index, adjList, seats, visited);\\n\\n                ans.prez += temp.prez;\\n                ans.tour += temp.tour;\\n            }\\n        }\\n\\n        if(vertex == 0)\\n        {\\n            return ans;\\n        }\\n\\n        ans.prez++;\\n        if(ans.prez%seats != 0)\\n        {\\n            ans.tour += (ans.prez/seats)+1;\\n        }\\n        else\\n        {\\n            ans.tour += (ans.prez/seats);\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\nclass twoVal{\\n    long prez;\\n    long tour;\\n\\n    public twoVal(long prez, long tour)\\n    {\\n        this.prez = prez;\\n        this.tour = tour;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175457,
                "title": "kotlin-dfs-with-picture",
                "content": "#### Join me on Telegram\\nhttps://t.me/leetcode_daily_unstoppable/116\\n#### Intuition\\n\\n![image.png](https://assets.leetcode.com/users/images/bc400a1d-8fae-4bf5-bc93-3ad1eca4737c_1676194010.773879.png)\\n\\nLet\\'s start from each leaf (node without children). We give `one` car, `seats-1` capacity and `zero` fuel. When children cars arrive, each of them consume `cars` capacity of the fuel. On the hub (node with children), we sat another one passenger, so `capacity--` and we can optimize number of cars arrived, if total `capacity` is more than one car `seats` number.\\n#### Approach\\nUse DFS and data class for the result.\\n#### Complexity\\n- Time complexity:\\n$$O(n)$$\\n- Space complexity:\\n$$O(h)$$, h - height of the tree, can be `0..n` \\n#### Code\\n```\\nclass Solution {\\n    data class R(val cars: Long, val capacity: Int, val fuel: Long)\\n    fun minimumFuelCost(roads: Array<IntArray>, seats: Int): Long {\\n        val nodes = mutableMapOf<Int, MutableList<Int>>()\\n        roads.forEach { (from, to) ->\\n            nodes.getOrPut(from, { mutableListOf() }) += to\\n            nodes.getOrPut(to, { mutableListOf() }) += from\\n        }\\n        fun dfs(curr: Int, parent: Int): R {\\n            val children = nodes[curr]\\n            if (children == null) return R(1L, seats - 1, 0L)\\n            var fuel = 0L\\n            var capacity = 0\\n            var cars = 0L\\n            children.filter { it != parent }.forEach {\\n                val r = dfs(it, curr)\\n                fuel += r.cars + r.fuel\\n                capacity += r.capacity\\n                cars += r.cars\\n            }\\n            // seat this passenger\\n            if (capacity == 0) {\\n                cars++\\n                capacity = seats - 1\\n            } else capacity--\\n            // optimize cars\\n            while (capacity - seats >= 0) {\\n                capacity -= seats\\n                cars--\\n            }\\n            return R(cars, capacity, fuel)\\n        }\\n        return dfs(0, 0).fuel\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    data class R(val cars: Long, val capacity: Int, val fuel: Long)\\n    fun minimumFuelCost(roads: Array<IntArray>, seats: Int): Long {\\n        val nodes = mutableMapOf<Int, MutableList<Int>>()\\n        roads.forEach { (from, to) ->\\n            nodes.getOrPut(from, { mutableListOf() }) += to\\n            nodes.getOrPut(to, { mutableListOf() }) += from\\n        }\\n        fun dfs(curr: Int, parent: Int): R {\\n            val children = nodes[curr]\\n            if (children == null) return R(1L, seats - 1, 0L)\\n            var fuel = 0L\\n            var capacity = 0\\n            var cars = 0L\\n            children.filter { it != parent }.forEach {\\n                val r = dfs(it, curr)\\n                fuel += r.cars + r.fuel\\n                capacity += r.capacity\\n                cars += r.cars\\n            }\\n            // seat this passenger\\n            if (capacity == 0) {\\n                cars++\\n                capacity = seats - 1\\n            } else capacity--\\n            // optimize cars\\n            while (capacity - seats >= 0) {\\n                capacity -= seats\\n                cars--\\n            }\\n            return R(cars, capacity, fuel)\\n        }\\n        return dfs(0, 0).fuel\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175214,
                "title": "c-solution-precalculation-with-backtracking-math-ceil-division",
                "content": "# Intuition\\nWe should find answer for each edge, and overall answer will be sum of all of them.\\n\\n# Approach\\nFind number of nodes of each substree with backtracking and use ceil division in integers to calc answer for current edge.\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$ for precalculation + O(n) for finding answer for each edge.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(n)$$ MAYBE, I DUNNO\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n\\n    long long res, s, n;\\n    vector<vector<int>> g;\\n    vector<int> was, count;\\n\\n    void c(int curr)\\n    {\\n        was[curr] = count[curr] = 1;\\n\\n        for (int x : g[curr])\\n        {\\n            if (was[x]) continue;\\n            c(x);\\n            count[curr] += count[x];\\n        }\\n    }\\n\\n    void dfs(int curr, int p)\\n    {\\n        was[curr] = 1;\\n        res += (p + (s - 1)) / s;\\n\\n        for (int x : g[curr])\\n        {\\n            if (was[x]) continue;\\n            dfs(x, count[x]);\\n        }\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& a, int semen) \\n    {\\n        n = a.size() + 1, res = 0, s = semen;\\n        g = vector<vector<int>>(n);\\n        for (auto &it : g) it = vector<int>();\\n        count = vector<int>(n, 0);\\n\\n        for (auto v : a)\\n        {\\n            g[v[0]].push_back(v[1]);\\n            g[v[1]].push_back(v[0]);\\n        }\\n\\n        was = vector<int>(n, 0);\\n        c(0);\\n\\n        was = vector<int>(n, 0);\\n        dfs(0, 0);\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n\\n    long long res, s, n;\\n    vector<vector<int>> g;\\n    vector<int> was, count;\\n\\n    void c(int curr)\\n    {\\n        was[curr] = count[curr] = 1;\\n\\n        for (int x : g[curr])\\n        {\\n            if (was[x]) continue;\\n            c(x);\\n            count[curr] += count[x];\\n        }\\n    }\\n\\n    void dfs(int curr, int p)\\n    {\\n        was[curr] = 1;\\n        res += (p + (s - 1)) / s;\\n\\n        for (int x : g[curr])\\n        {\\n            if (was[x]) continue;\\n            dfs(x, count[x]);\\n        }\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& a, int semen) \\n    {\\n        n = a.size() + 1, res = 0, s = semen;\\n        g = vector<vector<int>>(n);\\n        for (auto &it : g) it = vector<int>();\\n        count = vector<int>(n, 0);\\n\\n        for (auto v : a)\\n        {\\n            g[v[0]].push_back(v[1]);\\n            g[v[1]].push_back(v[0]);\\n        }\\n\\n        was = vector<int>(n, 0);\\n        c(0);\\n\\n        was = vector<int>(n, 0);\\n        dfs(0, 0);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175049,
                "title": "c-easy-approach-simple-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:  \\n    //Globally declare \\n    vector<vector<int>> edges;\\n    vector<bool> visit;\\n    long long ret = 0;\\n\\n    int count(int cur, int k){\\n        int cnt = 1;\\n        visit[cur] = true;\\n        for(auto i: edges[cur]){\\n            if(visit[i] == false)\\n                cnt += count(i, k);\\n        }\\n        if( cur != 0)\\n            ret += ((cnt + k -1) / k);\\n        return cnt;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size();\\n\\n        edges.resize(n + 1);\\n        visit.resize(n + 1);\\n\\n        for(auto road: roads){\\n            edges[road[0]].push_back(road[1]);\\n            edges[road[1]].push_back(road[0]);\\n        }\\n\\n        count(0, seats);\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n    //Globally declare \\n    vector<vector<int>> edges;\\n    vector<bool> visit;\\n    long long ret = 0;\\n\\n    int count(int cur, int k){\\n        int cnt = 1;\\n        visit[cur] = true;\\n        for(auto i: edges[cur]){\\n            if(visit[i] == false)\\n                cnt += count(i, k);\\n        }\\n        if( cur != 0)\\n            ret += ((cnt + k -1) / k);\\n        return cnt;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size();\\n\\n        edges.resize(n + 1);\\n        visit.resize(n + 1);\\n\\n        for(auto road: roads){\\n            edges[road[0]].push_back(road[1]);\\n            edges[road[1]].push_back(road[0]);\\n        }\\n\\n        count(0, seats);\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174981,
                "title": "python-concise-solution-dfs",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        def dfs(u):\\n            seen.add(u)\\n            nRep = 1 + sum(dfs(v) for v in tree[u] if v not in seen)\\n            ans[0] += ceil(nRep / seats) if u else 0\\n            return nRep\\n        tree, seen, ans = defaultdict(list), set(), [0]\\n        for u, v in roads: tree[u].append(v), tree[v].append(u)\\n        return not dfs(0) or ans[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        def dfs(u):\\n            seen.add(u)\\n            nRep = 1 + sum(dfs(v) for v in tree[u] if v not in seen)\\n            ans[0] += ceil(nRep / seats) if u else 0\\n            return nRep\\n        tree, seen, ans = defaultdict(list), set(), [0]\\n        for u, v in roads: tree[u].append(v), tree[v].append(u)\\n        return not dfs(0) or ans[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174979,
                "title": "c-dfs-beats-63",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Start from leaf node and go to \\'0\\', and try to reach at parent node of every node with minimum fuel(In other words, with minimum number of cars).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Start from every leaf nodes, which can be done with dfs, when you are backtrack from dfs then keep track of number of Representative(p) at that node(\\'it\\') and add those people to the number of Representative(persons) of node.\\n- Now, you will try to pack up all the persons in one car but there is limitation given, for a car there are given number of seats in cars, so from a \\'node\\' to \\'0\\' you need to travel same path for number of cars needed for \\'persons\\'(number of Representative at \\'node\\').\\n- EX : In short from \\'node\\' to \\'0\\', say node has 3 child it1, it2, it3, then total fuel required will be cost[node] += cars + cost[it[i]]\\n (it[i] => it[1] OR it[2] OR it[3], and cars = (number of Representative at it[i] (p) / seats),  at \\'it[i]\\').\\n-  Like, this we start counting from every leaf node and we try to reach at parent node with minimum fuel(cars) so, likw this for every node accumulates the minimum fuel required to reach at node = 0(Which is the Ultimate Parent OR root of the tree). \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N + E)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N + E)\\n# Please Upvote If You Liked The Solution\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int node, vector<int> adj[], vector<int> &vis, vector<long long> &cost, int seats)\\n    {\\n        vis[node] = 1;\\n        long long persons = 1;\\n        for(auto it : adj[node])\\n        {\\n            if(!vis[it])\\n            {\\n                long long p = dfs(it, adj, vis, cost, seats);\\n                persons += p; // number of persons meet at \\'node\\'.\\n                long long cars = p / seats; // number of cars needed for all \\'persons\\'.\\n                if(p % seats != 0)\\n                {\\n                    cars++;\\n                }\\n                cost[node] += cars + cost[it]; \\n                // from leaf node of all child\\'s of \\'node\\' to \\'node\\' this is the minimum \\n                // fuel required.\\n            }\\n        }\\n        return persons; // size of subtree with root as \\'node\\'.\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size() + 1;\\n        vector<int> adj[n];\\n        for(auto it : roads)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        vector<int> vis(n, 0);\\n        vector<long long> cost(n, 0);\\n        \\n        dfs(0, adj, vis, cost, seats);\\n\\n        return cost[0];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int node, vector<int> adj[], vector<int> &vis, vector<long long> &cost, int seats)\\n    {\\n        vis[node] = 1;\\n        long long persons = 1;\\n        for(auto it : adj[node])\\n        {\\n            if(!vis[it])\\n            {\\n                long long p = dfs(it, adj, vis, cost, seats);\\n                persons += p; // number of persons meet at \\'node\\'.\\n                long long cars = p / seats; // number of cars needed for all \\'persons\\'.\\n                if(p % seats != 0)\\n                {\\n                    cars++;\\n                }\\n                cost[node] += cars + cost[it]; \\n                // from leaf node of all child\\'s of \\'node\\' to \\'node\\' this is the minimum \\n                // fuel required.\\n            }\\n        }\\n        return persons; // size of subtree with root as \\'node\\'.\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size() + 1;\\n        vector<int> adj[n];\\n        for(auto it : roads)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        vector<int> vis(n, 0);\\n        vector<long long> cost(n, 0);\\n        \\n        dfs(0, adj, vis, cost, seats);\\n\\n        return cost[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174811,
                "title": "python-optimal-dfs-solution",
                "content": "# Complexity\\n- Time complexity of dfs:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(n+e) => O(n+n-1) => O(n)\\n\\n- Space complexity of adjacency dictionary:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(e) => O(n-1) => O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        g=defaultdict(list)\\n        for i,j in roads:\\n            g[i].append(j)\\n            g[j].append(i)\\n\\n        ans=0\\n\\n        def dfs(i,par):\\n            nonlocal ans\\n            cost=1\\n            for ch in g[i]:\\n                if ch!=par:\\n                    cost+=dfs(ch,i)\\n\\n            if i!=0:\\n                ans+=ceil(cost/seats) \\n            return cost \\n    \\n        dfs(0,-1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        g=defaultdict(list)\\n        for i,j in roads:\\n            g[i].append(j)\\n            g[j].append(i)\\n\\n        ans=0\\n\\n        def dfs(i,par):\\n            nonlocal ans\\n            cost=1\\n            for ch in g[i]:\\n                if ch!=par:\\n                    cost+=dfs(ch,i)\\n\\n            if i!=0:\\n                ans+=ceil(cost/seats) \\n            return cost \\n    \\n        dfs(0,-1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174366,
                "title": "python-simple-tree-dfs-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFirst, Make tree.\\nand calculate the number of representatives (In fact, this is the number of nodes)\\nThe minimum number of liters of fuel for Node $n$ ($F_n$) can be calculate as follows:\\n - $R_n =$ Number of representatives that must pass through the n node\\n - $C_n =$ The children for node $n$.\\n - $R_n = Sum_{c \\\\in C_n}(R_c)$\\n - $F_n = ceil(R_n/seats)$\\n\\n# Complexity\\n- Time complexity: $O(N)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(N)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```python\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        G = defaultdict(list)\\n        for s, e in roads:\\n            G[s].append(e)\\n            G[e].append(s)\\n        total = 0\\n        def go(node, parent):\\n            nonlocal total\\n            accum = 1\\n            for n in G[node]:\\n                if n == parent:\\n                    continue\\n                rep = go(n, node)\\n                total += (rep + seats - 1) // seats\\n                accum += rep\\n            return accum\\n        go(0, -1)\\n        return total\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        G = defaultdict(list)\\n        for s, e in roads:\\n            G[s].append(e)\\n            G[e].append(s)\\n        total = 0\\n        def go(node, parent):\\n            nonlocal total\\n            accum = 1\\n            for n in G[node]:\\n                if n == parent:\\n                    continue\\n                rep = go(n, node)\\n                total += (rep + seats - 1) // seats\\n                accum += rep\\n            return accum\\n        go(0, -1)\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174224,
                "title": "beats-100-java-code",
                "content": "# Java Code\\n```\\nclass Solution {\\n    private static long TotalCost = 0;\\n    private static int Seats;\\n\\n    public static long minimumFuelCost(int[][] roads, int seats) {\\n\\n        if (roads.length == 1) {\\n            return 0;\\n        }\\n        Helper[] roadsMap = new Helper[roads.length + 1];\\n\\n        for (int i = 0; i < roads.length + 1; i++) {\\n            roadsMap[i] = new Helper(i);\\n        }\\n\\n        for (int i = 0; i < roads.length; i++) {\\n            int c1 = roads[i][0];\\n            int c2 = roads[i][1];\\n            roadsMap[c1].size++;\\n            roadsMap[c2].size++;\\n        }\\n        for (int i = 0; i < roads.length + 1; i++) {\\n            roadsMap[i].configurations();\\n        }\\n\\n        for (int i = 0; i < roads.length; i++) {\\n            int c1 = roads[i][0];\\n            int c2 = roads[i][1];\\n            roadsMap[c1].add(c2);\\n            roadsMap[c2].add(c1);\\n        }\\n\\n        //System.out.println(roadsMap);\\n\\n        TotalCost = 0;\\n        Seats = seats;\\n        int c = calculate(roadsMap, 0, 0);\\n        removeCost(c, seats);\\n        TotalCost = Math.max(0, TotalCost);\\n        return TotalCost;\\n    }\\n\\n    private static int calculate(Helper[] roads, int parent, int current) {\\n\\n        int[] nexts = roads[current].nexts;\\n        if (nexts.length == 1 && current != 0) {\\n            addCost(1, Seats);\\n            return 1;\\n        } else {\\n            int value = 1;\\n            for (int i = 0; i < nexts.length; i++) {\\n                if (nexts[i] != parent) {\\n                    value += calculate(roads, current, nexts[i]);\\n                }\\n            }\\n            addCost(value, Seats);\\n            return value;\\n        }\\n    }\\n\\n    private static void addCost(int travellers, int maxSeats) {\\n        int n = (travellers + maxSeats - 1) / maxSeats;\\n        TotalCost += n;\\n    }\\n\\n    private static void removeCost(int travellers, int maxSeats) {\\n        int n = (travellers + maxSeats - 1) / maxSeats;\\n        TotalCost -= n;\\n    }\\n\\n    private static class Helper {\\n\\n        private int value;\\n        private int[] nexts;\\n        private int size;\\n        private int current;\\n\\n        public Helper(int value) {\\n            this.value = value;\\n        }\\n\\n        public void configurations() {\\n            nexts = new int[size];\\n        }\\n\\n        public void add(int v) {\\n            nexts[current] = v;\\n            current++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    private static long TotalCost = 0;\\n    private static int Seats;\\n\\n    public static long minimumFuelCost(int[][] roads, int seats) {\\n\\n        if (roads.length == 1) {\\n            return 0;\\n        }\\n        Helper[] roadsMap = new Helper[roads.length + 1];\\n\\n        for (int i = 0; i < roads.length + 1; i++) {\\n            roadsMap[i] = new Helper(i);\\n        }\\n\\n        for (int i = 0; i < roads.length; i++) {\\n            int c1 = roads[i][0];\\n            int c2 = roads[i][1];\\n            roadsMap[c1].size++;\\n            roadsMap[c2].size++;\\n        }\\n        for (int i = 0; i < roads.length + 1; i++) {\\n            roadsMap[i].configurations();\\n        }\\n\\n        for (int i = 0; i < roads.length; i++) {\\n            int c1 = roads[i][0];\\n            int c2 = roads[i][1];\\n            roadsMap[c1].add(c2);\\n            roadsMap[c2].add(c1);\\n        }\\n\\n        //System.out.println(roadsMap);\\n\\n        TotalCost = 0;\\n        Seats = seats;\\n        int c = calculate(roadsMap, 0, 0);\\n        removeCost(c, seats);\\n        TotalCost = Math.max(0, TotalCost);\\n        return TotalCost;\\n    }\\n\\n    private static int calculate(Helper[] roads, int parent, int current) {\\n\\n        int[] nexts = roads[current].nexts;\\n        if (nexts.length == 1 && current != 0) {\\n            addCost(1, Seats);\\n            return 1;\\n        } else {\\n            int value = 1;\\n            for (int i = 0; i < nexts.length; i++) {\\n                if (nexts[i] != parent) {\\n                    value += calculate(roads, current, nexts[i]);\\n                }\\n            }\\n            addCost(value, Seats);\\n            return value;\\n        }\\n    }\\n\\n    private static void addCost(int travellers, int maxSeats) {\\n        int n = (travellers + maxSeats - 1) / maxSeats;\\n        TotalCost += n;\\n    }\\n\\n    private static void removeCost(int travellers, int maxSeats) {\\n        int n = (travellers + maxSeats - 1) / maxSeats;\\n        TotalCost -= n;\\n    }\\n\\n    private static class Helper {\\n\\n        private int value;\\n        private int[] nexts;\\n        private int size;\\n        private int current;\\n\\n        public Helper(int value) {\\n            this.value = value;\\n        }\\n\\n        public void configurations() {\\n            nexts = new int[size];\\n        }\\n\\n        public void add(int v) {\\n            nexts[current] = v;\\n            current++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174115,
                "title": "cpp-thought-of-the-question",
                "content": "# THOUGHT\\nListen mate, if you see carefully, \\nthe amount of fuel a node takes to reach to 0, depends on people present in the node/city and the capacity of one car\\n\\nfor example if a car has capacity 3 and 6 peeps are present, how many cars are requried ?? 2 tadaa.., 2 fuel\\nceil value of peeps/capacity will give us fuel from that perticular node (city whatever) to the 0th city.\\n\\nHow many peeps are present in one city??\\nthe peeps coming from far away will be present in that perticular city on the way, this will help us to reduce the number of fuels..\\nhow?? mate you asking me how, think !!!!\\n\\nif i have the chance to minimize the fuel required at each city why wont I, I will make people stop at each city on their way and then check again if i can reduce the cars needed.\\n\\nTadaa..\\nlast step\\nwhat can help me do so?\\nDFS mate DFS, i can apply a checking condition at every intermidiate city, how?\\na recurrsion of dfs is itself a city on the way\\nwhat will i check for?\\n```\\nif(node != 0) ans += cnt/seats + (cnt%seats != 0);\\n```\\nat each city we will try to minimize the no. of cars by adding the ceiling value, why node != 0 becoz thats our destination mate, we dont require a car there you know.\\nThat\\'s it return the total cars, that will be the fuel required [ as each car costs 1 fuel between two cities ]\\n\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long int ans = 0;\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size()+1;\\n        int m = n-1;\\n        vector<int>adj[n];\\n        for(int i = 0;i < m; ++i){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        dfs(adj,0,-1,seats);\\n        return ans;\\n    }\\n    long long dfs(vector<int>adj[],int node, int par, int seats){\\n        int cnt = 1;\\n        for(auto &edge: adj[node]){\\n            if(edge != par){\\n                cnt += dfs(adj,edge,node,seats);\\n            } \\n        }\\n        if(node != 0){\\n            ans += cnt/seats + (cnt%seats != 0);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif(node != 0) ans += cnt/seats + (cnt%seats != 0);\\n```\n```\\nclass Solution {\\npublic:\\n    long long int ans = 0;\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size()+1;\\n        int m = n-1;\\n        vector<int>adj[n];\\n        for(int i = 0;i < m; ++i){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        dfs(adj,0,-1,seats);\\n        return ans;\\n    }\\n    long long dfs(vector<int>adj[],int node, int par, int seats){\\n        int cnt = 1;\\n        for(auto &edge: adj[node]){\\n            if(edge != par){\\n                cnt += dfs(adj,edge,node,seats);\\n            } \\n        }\\n        if(node != 0){\\n            ans += cnt/seats + (cnt%seats != 0);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173906,
                "title": "rust-dfs",
                "content": "# Intuition\\nUsing the hint about \"counting the subtrees\" I realized I had to traverse the tree and keep track of how many people will be passing from each city. \\n\\n# Approach\\nEasy to conceptualize as a recursive problem. To move onto the next city, you need as much fuel as the previous one plus the value `ceil(size/seats)` which is the core of the solution.\\n\\nI first used a simple function that evaluated the given adjacency list each time in the `connected_to()` operation. This proved to be very inefficient (time) so I ended up building a Tree struct to help the efficiency. The result ended up beating %100 in runtime, and %63.64 in memory use at the time of posting.\\n\\n# Code\\n```\\npub struct Node {\\n    pub id: i32,\\n    pub connected: Vec<i32>,\\n}\\n\\npub struct Tree {\\n    pub nodes: Vec<Node>,\\n}\\n\\nimpl Tree {\\n    pub fn new(roads: &Vec<Vec<i32>>) -> Self {\\n        let max = (roads.len() + 1) as i32;\\n        let mut nodes: Vec<Node> = (0..=max).map(|id| Node{id, connected: vec![]}).collect();\\n        for road in roads {\\n            nodes[road[0] as usize].connected.push(road[1]);\\n            nodes[road[1] as usize].connected.push(road[0]);\\n        }\\n        Tree { nodes }\\n    }\\n}\\n\\npub fn connected_to(node: i32, tree: &Tree) -> &Vec<i32> {\\n    &tree.nodes[node as usize].connected\\n}\\n\\npub fn traverse(from: i32, node: i32, seats: i32, tree: &Tree) -> (i32, i64) {\\n    let mut size = 1;\\n    let mut fuel = 0;\\n    for new_node in connected_to(node, tree) {\\n        if *new_node != from {\\n            let (new_node_size, spent_fuel) = traverse(node, *new_node, seats, tree);\\n            fuel += spent_fuel;\\n            size += new_node_size;\\n        }\\n    }\\n    fuel += f64::ceil(size as f64 / seats as f64) as i64;\\n    (size, fuel)\\n}\\n\\nimpl Solution {\\n    pub fn minimum_fuel_cost(roads: Vec<Vec<i32>>, seats: i32) -> i64 {\\n        let tree = Tree::new(&roads);\\n        let connected_to_capital = connected_to(0, &tree);\\n        let mut fuel = 0;\\n        for node in connected_to_capital {\\n            fuel += traverse(0, *node, seats, &tree).1;\\n        }\\n        fuel\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub struct Node {\\n    pub id: i32,\\n    pub connected: Vec<i32>,\\n}\\n\\npub struct Tree {\\n    pub nodes: Vec<Node>,\\n}\\n\\nimpl Tree {\\n    pub fn new(roads: &Vec<Vec<i32>>) -> Self {\\n        let max = (roads.len() + 1) as i32;\\n        let mut nodes: Vec<Node> = (0..=max).map(|id| Node{id, connected: vec![]}).collect();\\n        for road in roads {\\n            nodes[road[0] as usize].connected.push(road[1]);\\n            nodes[road[1] as usize].connected.push(road[0]);\\n        }\\n        Tree { nodes }\\n    }\\n}\\n\\npub fn connected_to(node: i32, tree: &Tree) -> &Vec<i32> {\\n    &tree.nodes[node as usize].connected\\n}\\n\\npub fn traverse(from: i32, node: i32, seats: i32, tree: &Tree) -> (i32, i64) {\\n    let mut size = 1;\\n    let mut fuel = 0;\\n    for new_node in connected_to(node, tree) {\\n        if *new_node != from {\\n            let (new_node_size, spent_fuel) = traverse(node, *new_node, seats, tree);\\n            fuel += spent_fuel;\\n            size += new_node_size;\\n        }\\n    }\\n    fuel += f64::ceil(size as f64 / seats as f64) as i64;\\n    (size, fuel)\\n}\\n\\nimpl Solution {\\n    pub fn minimum_fuel_cost(roads: Vec<Vec<i32>>, seats: i32) -> i64 {\\n        let tree = Tree::new(&roads);\\n        let connected_to_capital = connected_to(0, &tree);\\n        let mut fuel = 0;\\n        for node in connected_to_capital {\\n            fuel += traverse(0, *node, seats, &tree).1;\\n        }\\n        fuel\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3173797,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long solve(int node,int parent,int seats,long long& ans,vector<int> adj[]){\\n        long long count=1;\\n        for(auto &i:adj[node]){\\n            if(i != parent){\\n                count+=solve(i,node,seats,ans,adj);\\n            }\\n        }\\n        long long cost=ceil(count/(1.0*seats));\\n        if(node != 0) ans+=cost;\\n        return count;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int N=roads.size();\\n        vector<int> adj[N+1];\\n        for(auto &i:roads){\\n            int u=i[0],v=i[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        long long ans=0;\\n        long long res=solve(0,-1,seats,ans,adj);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(int node,int parent,int seats,long long& ans,vector<int> adj[]){\\n        long long count=1;\\n        for(auto &i:adj[node]){\\n            if(i != parent){\\n                count+=solve(i,node,seats,ans,adj);\\n            }\\n        }\\n        long long cost=ceil(count/(1.0*seats));\\n        if(node != 0) ans+=cost;\\n        return count;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int N=roads.size();\\n        vector<int> adj[N+1];\\n        for(auto &i:roads){\\n            int u=i[0],v=i[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        long long ans=0;\\n        long long res=solve(0,-1,seats,ans,adj);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173775,
                "title": "easy-to-understand-simple-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    long ans = 0; int s;\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        List<List<Integer>> graph = new ArrayList();\\n        s = seats;\\n        for (int i = 0; i < roads.length + 1; i++) graph.add(new ArrayList());\\n        for (int[] r : roads) {\\n            graph.get(r[0]).add(r[1]);\\n            graph.get(r[1]).add(r[0]);\\n        }\\n        dfs(0, 0, graph);\\n        return ans;\\n    }\\n\\n    private int dfs(int i, int prev, List<List<Integer>> graph) {\\n        int people = 1;\\n        for (int x : graph.get(i)) {\\n            if (x == prev) continue;\\n            people += dfs(x, i, graph);\\n        }\\n        if (i != 0) ans += (people + s - 1) / s;\\n        return people;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long ans = 0; int s;\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        List<List<Integer>> graph = new ArrayList();\\n        s = seats;\\n        for (int i = 0; i < roads.length + 1; i++) graph.add(new ArrayList());\\n        for (int[] r : roads) {\\n            graph.get(r[0]).add(r[1]);\\n            graph.get(r[1]).add(r[0]);\\n        }\\n        dfs(0, 0, graph);\\n        return ans;\\n    }\\n\\n    private int dfs(int i, int prev, List<List<Integer>> graph) {\\n        int people = 1;\\n        for (int x : graph.get(i)) {\\n            if (x == prev) continue;\\n            people += dfs(x, i, graph);\\n        }\\n        if (i != 0) ans += (people + s - 1) / s;\\n        return people;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173755,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        def dfs(node, parent):                       \\n            people = 1\\n            for child in adj[node]:\\n                if child != parent:\\n                    people += dfs(child, node)\\n            \\n            if node:\\n                self.result += (people - 1) // seats + 1\\n                \\n            return people\\n        \\n        adj = defaultdict(list)\\n        for a, b in roads:\\n            adj[a].append(b)\\n            adj[b].append(a)\\n        \\n        self.result = 0\\n        dfs(0, None)\\n        \\n        return self.result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        def dfs(node, parent):                       \\n            people = 1\\n            for child in adj[node]:\\n                if child != parent:\\n                    people += dfs(child, node)\\n            \\n            if node:\\n                self.result += (people - 1) // seats + 1\\n                \\n            return people\\n        \\n        adj = defaultdict(list)\\n        for a, b in roads:\\n            adj[a].append(b)\\n            adj[b].append(a)\\n        \\n        self.result = 0\\n        dfs(0, None)\\n        \\n        return self.result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173739,
                "title": "python-clean-dfs",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        G = defaultdict(list)\\n        for v, w in roads:\\n            G[v].append(w)\\n            G[w].append(v)\\n        ans = 0\\n        visited = set()\\n        def dfs(v):\\n            nonlocal ans\\n            if v in visited: return 0\\n            visited.add(v)\\n            res = 0\\n            for w in G[v]:\\n                cur = dfs(w)\\n                ans += (cur + seats - 1) // seats\\n                res += cur\\n            return res + 1\\n        dfs(0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        G = defaultdict(list)\\n        for v, w in roads:\\n            G[v].append(w)\\n            G[w].append(v)\\n        ans = 0\\n        visited = set()\\n        def dfs(v):\\n            nonlocal ans\\n            if v in visited: return 0\\n            visited.add(v)\\n            res = 0\\n            for w in G[v]:\\n                cur = dfs(w)\\n                ans += (cur + seats - 1) // seats\\n                res += cur\\n            return res + 1\\n        dfs(0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019923,
                "title": "javascript-dfs",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nvar minimumFuelCost = function(roads, seats) {\\n    const graph = Array.from({ length: roads.length + 1 }, () => []);\\n    let fuel = 0;\\n\\n    for (const [i, j] of roads)\\n        graph[i].push(j), graph[j].push(i);\\n\\n    (function dfs(node, parent) {\\n        const totalPeople = graph[node].reduce((acc, child) =>\\n                    acc + (child == parent ? 0 : dfs(child, node)), 1);\\n        if (parent > -1)\\n            fuel += Math.ceil(totalPeople / seats);\\n        return totalPeople;\\n    })(0, -1)\\n\\n    return fuel;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Depth-First Search"
                ],
                "code": "```\\nvar minimumFuelCost = function(roads, seats) {\\n    const graph = Array.from({ length: roads.length + 1 }, () => []);\\n    let fuel = 0;\\n\\n    for (const [i, j] of roads)\\n        graph[i].push(j), graph[j].push(i);\\n\\n    (function dfs(node, parent) {\\n        const totalPeople = graph[node].reduce((acc, child) =>\\n                    acc + (child == parent ? 0 : dfs(child, node)), 1);\\n        if (parent > -1)\\n            fuel += Math.ceil(totalPeople / seats);\\n        return totalPeople;\\n    })(0, -1)\\n\\n    return fuel;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3004721,
                "title": "ruby-2-solutions",
                "content": "```ruby\\ndef minimum_fuel_cost a, s\\n    h = Array.new a.size + 1 do [] end\\n    a.each { | (x, y) | h[x] << y; h[y] << x }\\n    r = 0\\n    l = -> n, p do\\n        c = h[n].reduce(1) { _2 == p ? (next _1) : _1 + l.(_2, n) }\\n        r += (c + s - 1) / s\\n        c\\n    end\\n    h[0].each { l.(_1, 0) }\\n    r\\nend\\n```\\n```ruby\\ndef minimum_fuel_cost a, s\\n    h = Array.new a.size + 1 do [] end\\n    a.each { | (x, y) | h[x] << y; h[y] << x }\\n    l = -> n, p do\\n        r, c, f = 0, 0, 0\\n        h[n].each do\\n            next if _1 == p\\n            r, c, f = l.(_1, n).zip([r, c, f]).map(&:sum)\\n            (c -= 1; f -= s) if f >= s\\n        end\\n        f > 0 ? f -= 1 : (c += 1; f += s - 1)\\n        [r + c, c, f]\\n    end\\n    h[0].sum { l.(_1, 0).first }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef minimum_fuel_cost a, s\\n    h = Array.new a.size + 1 do [] end\\n    a.each { | (x, y) | h[x] << y; h[y] << x }\\n    r = 0\\n    l = -> n, p do\\n        c = h[n].reduce(1) { _2 == p ? (next _1) : _1 + l.(_2, n) }\\n        r += (c + s - 1) / s\\n        c\\n    end\\n    h[0].each { l.(_1, 0) }\\n    r\\nend\\n```\n```ruby\\ndef minimum_fuel_cost a, s\\n    h = Array.new a.size + 1 do [] end\\n    a.each { | (x, y) | h[x] << y; h[y] << x }\\n    l = -> n, p do\\n        r, c, f = 0, 0, 0\\n        h[n].each do\\n            next if _1 == p\\n            r, c, f = l.(_1, n).zip([r, c, f]).map(&:sum)\\n            (c -= 1; f -= s) if f >= s\\n        end\\n        f > 0 ? f -= 1 : (c += 1; f += s - 1)\\n        [r + c, c, f]\\n    end\\n    h[0].sum { l.(_1, 0).first }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2839206,
                "title": "python3-concise-and-commented-dfs-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to start at the leafes and accumulate the representatives going from the leafes to the root.\\n\\nAs the graph has no cycles (and edges are bidirectional), there is only one way to go for each representative.\\n\\nIn order to make this traversal happen we can do DFS.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEvery DFS function can be splitted in two parts:\\n1) the part before the recursive call, which happens when going down the tree/graph from root to the leafes\\n2) the part after the recursive call that happens going up the tree from leafes to root\\n\\nWe can use the function parameters for passing information down the tree and the return value for sending information up the tree.\\n\\nIn our case, we said that we logically want to travel from leafes to root, so most our DFS code and logic happens after the recursive call.\\n\\nNormally, one would have a termination condition for stopping before the recursive call, but in our case this happens automatically, as we keep track of where we came from and the leaf nodes only have one connection (where we came from), so further recursive calls do not happen in the loop when our position is a leaf.\\n\\nWe pass down the tree the node where we came from and up the tree the number of representatives coming from this node.\\n\\nIn every node, we count the number of representatives (1 at our node plus the others coming from outer nodes) and use this number and the number of seats in the car to calculate fuel consumption of our representatives travelling from this node to the next one.\\n\\nWe stop once we arrived at the root node again.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) where N ist the number of cities\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) if we neglect recursion stack, otherwise worst case O(N) if we have a line graph.\\n\\n# Code\\n\\nCommented:\\n\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n\\n        # we can do dfs into the leaf nodes and on return calculate the\\n        # amount of people that travel together. We will travel to the\\n        # leaves first and count the collected representatives on the\\n        # way back. During that we also continously add the fuel needed\\n        # to travel from node to next node closer to root.\\n\\n        # make the graph for all of the roads in order to have a quick\\n        # lookup\\n        graph = collections.defaultdict(list)\\n        for start, end in roads:\\n            graph[start].append(end)\\n            graph[end].append(start)\\n        \\n        # make a instance variable to count the fuel\\n        self.fuel = 0\\n\\n        # start the depth first approach\\n        self.dfs(0, -1, graph, seats)\\n\\n        # return our result\\n        return self.fuel\\n\\n    def dfs(self, position, parent, graph, seats):\\n        \\n        # go deeper into the graph for all connections still open and\\n        # add up the representatives travelling to our node. Do not\\n        # forget to start at one representative, as our node also \\n        # has an representative\\n        representatives = 1\\n        for target in graph[position]:\\n\\n            # check that we do not go back in root direction\\n            if target != parent:\\n\\n                # count the representatives coming from nodes deeper in the\\n                # tree\\n                representatives += self.dfs(target, position, graph, seats)\\n        \\n        # get the fuel costs for each car of collected representatives, but\\n        # take care to not travel further once we are at root node ( position == 0)\\n        if position > 0:\\n            \\n            # calculate the number of cars we need to go further\\n            # this is just a quick way of saying: math.ceil(representatives/2)\\n            self.fuel += (representatives + seats-1) // seats\\n\\n        # go in the the root node direction and hand over the number of incoming\\n        # representatives\\n        return representatives\\n```\\n\\nConcise:\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n\\n        graph = collections.defaultdict(list)\\n        for start, end in roads:\\n            graph[start].append(end)\\n            graph[end].append(start)\\n        self.fuel = 0\\n\\n        self.dfs(0, -1, graph, seats)\\n\\n        return self.fuel\\n\\n    def dfs(self, position, parent, graph, seats):\\n        \\n        representatives = 1\\n        for target in graph[position]:\\n\\n            if target != parent:\\n                representatives += self.dfs(target, position, graph, seats)\\n        \\n        if position > 0:\\n            self.fuel += (representatives + seats-1) // seats\\n\\n        return representatives\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n\\n        # we can do dfs into the leaf nodes and on return calculate the\\n        # amount of people that travel together. We will travel to the\\n        # leaves first and count the collected representatives on the\\n        # way back. During that we also continously add the fuel needed\\n        # to travel from node to next node closer to root.\\n\\n        # make the graph for all of the roads in order to have a quick\\n        # lookup\\n        graph = collections.defaultdict(list)\\n        for start, end in roads:\\n            graph[start].append(end)\\n            graph[end].append(start)\\n        \\n        # make a instance variable to count the fuel\\n        self.fuel = 0\\n\\n        # start the depth first approach\\n        self.dfs(0, -1, graph, seats)\\n\\n        # return our result\\n        return self.fuel\\n\\n    def dfs(self, position, parent, graph, seats):\\n        \\n        # go deeper into the graph for all connections still open and\\n        # add up the representatives travelling to our node. Do not\\n        # forget to start at one representative, as our node also \\n        # has an representative\\n        representatives = 1\\n        for target in graph[position]:\\n\\n            # check that we do not go back in root direction\\n            if target != parent:\\n\\n                # count the representatives coming from nodes deeper in the\\n                # tree\\n                representatives += self.dfs(target, position, graph, seats)\\n        \\n        # get the fuel costs for each car of collected representatives, but\\n        # take care to not travel further once we are at root node ( position == 0)\\n        if position > 0:\\n            \\n            # calculate the number of cars we need to go further\\n            # this is just a quick way of saying: math.ceil(representatives/2)\\n            self.fuel += (representatives + seats-1) // seats\\n\\n        # go in the the root node direction and hand over the number of incoming\\n        # representatives\\n        return representatives\\n```\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n\\n        graph = collections.defaultdict(list)\\n        for start, end in roads:\\n            graph[start].append(end)\\n            graph[end].append(start)\\n        self.fuel = 0\\n\\n        self.dfs(0, -1, graph, seats)\\n\\n        return self.fuel\\n\\n    def dfs(self, position, parent, graph, seats):\\n        \\n        representatives = 1\\n        for target in graph[position]:\\n\\n            if target != parent:\\n                representatives += self.dfs(target, position, graph, seats)\\n        \\n        if position > 0:\\n            self.fuel += (representatives + seats-1) // seats\\n\\n        return representatives\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836916,
                "title": "java-concise-and-clear-solution",
                "content": "# Approach\\n1. Build the adjacency map first for the tree.\\n2. DFS to traverse the adjacency map to find the size of subtree, and find the total fuel cost of subtree\\n\\n# Complexity\\n\\n**n** represents the number of cities\\n- Time complexity: **O(n)**\\n- Space complexity: **O(n)**\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        // corner case\\n        if (roads.length < 1) return 0;\\n\\n        // build the graph\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        for (int[] road : roads) {\\n            int a = road[0], b = road[1];\\n            graph.computeIfAbsent(a, k -> new HashSet<>()).add(b);\\n            graph.computeIfAbsent(b, k -> new HashSet<>()).add(a);\\n        }\\n\\n        // dfs - traverse the graph to find the number of people and total fuel cost of the subtrees\\n        long[] result = new long[]{0};\\n        for (int sub : graph.get(0)) {\\n            findSizeOfSubtree(0, sub, seats, graph, result);\\n        }\\n        return result[0];\\n    }\\n    private long findSizeOfSubtree(int parent, int root, int seats, Map<Integer, Set<Integer>> graph, long[] result) {\\n        long people = 1;\\n        for (int sub : graph.get(root)) {\\n            if (sub == parent) continue;\\n            people += findSizeOfSubtree(root, sub, seats, graph, result);\\n        }\\n        result[0] += (people + seats - 1) / seats;\\n        return people;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        // corner case\\n        if (roads.length < 1) return 0;\\n\\n        // build the graph\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        for (int[] road : roads) {\\n            int a = road[0], b = road[1];\\n            graph.computeIfAbsent(a, k -> new HashSet<>()).add(b);\\n            graph.computeIfAbsent(b, k -> new HashSet<>()).add(a);\\n        }\\n\\n        // dfs - traverse the graph to find the number of people and total fuel cost of the subtrees\\n        long[] result = new long[]{0};\\n        for (int sub : graph.get(0)) {\\n            findSizeOfSubtree(0, sub, seats, graph, result);\\n        }\\n        return result[0];\\n    }\\n    private long findSizeOfSubtree(int parent, int root, int seats, Map<Integer, Set<Integer>> graph, long[] result) {\\n        long people = 1;\\n        for (int sub : graph.get(root)) {\\n            if (sub == parent) continue;\\n            people += findSizeOfSubtree(root, sub, seats, graph, result);\\n        }\\n        result[0] += (people + seats - 1) / seats;\\n        return people;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833067,
                "title": "dfs-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n     vector<int>size;\\n     void dfs( vector<vector<int>> &v , int node , int par  = -1 ){\\n         size[node]  = 1; \\n         for( auto it : v[node ] ){\\n             if( it != par ){\\n                 dfs( v , it , node );\\n                 \\n             }\\n         }\\n\\n         if(par != -1 )\\n             size[par]  += size[node] ; \\n\\n     }\\n    \\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n  = roads.size() +1 ;\\n        size.resize( n +1 , 0  );\\n        vector<vector<int>>v( n +1 );\\n    \\n        for( auto it : roads ){\\n            int a = it[0];\\n            int b = it[1];\\n            v[a].push_back(b);\\n            v[b].push_back(a);\\n        }\\n        dfs( v , 0 , -1 );\\n        long long int ans = 0 ;\\n        for( int i = 1 ; i<n ; ++i ){\\n            int cnt  = size[i]; \\n            ans += 1ll*( (cnt + seats - 1)/seats );\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     vector<int>size;\\n     void dfs( vector<vector<int>> &v , int node , int par  = -1 ){\\n         size[node]  = 1; \\n         for( auto it : v[node ] ){\\n             if( it != par ){\\n                 dfs( v , it , node );\\n                 \\n             }\\n         }\\n\\n         if(par != -1 )\\n             size[par]  += size[node] ; \\n\\n     }\\n    \\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n  = roads.size() +1 ;\\n        size.resize( n +1 , 0  );\\n        vector<vector<int>>v( n +1 );\\n    \\n        for( auto it : roads ){\\n            int a = it[0];\\n            int b = it[1];\\n            v[a].push_back(b);\\n            v[b].push_back(a);\\n        }\\n        dfs( v , 0 , -1 );\\n        long long int ans = 0 ;\\n        for( int i = 1 ; i<n ; ++i ){\\n            int cnt  = size[i]; \\n            ans += 1ll*( (cnt + seats - 1)/seats );\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832724,
                "title": "2477-minimum-fuel-cost-to-report-to-the-capital",
                "content": "Don\\'t know why am I a getting a TLE on the last case\\n\\n```\\nint recursion(int i, int prev, vector<int> g[], long long depth, int seats, long long &res)\\n{\\n    long long riders = 1;\\n    for (auto j : g[i])\\n    {\\n        if (j != prev)\\n        {\\n            riders += recursion(j, i, g, depth + 1, seats, res);\\n        }\\n    }\\n    if (depth == 0)\\n    {\\n        return res;\\n    }\\n    res += (riders / seats) * depth + (riders % seats ? 1 : 0);\\n    return riders % seats;\\n}\\n\\nlong long minimumFuelCost(vector<vector<int>> &roads, int seats)\\n{\\n    int n = roads.size();\\n    vector<int> g[n + 1];\\n\\n    for (auto &it : roads)\\n    {\\n        g[it[0]].push_back(it[1]);\\n        g[it[1]].push_back(it[0]);\\n    }\\n\\n    long long res = 0;\\n    return recursion(0, -1, g, 0, seats, res);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint recursion(int i, int prev, vector<int> g[], long long depth, int seats, long long &res)\\n{\\n    long long riders = 1;\\n    for (auto j : g[i])\\n    {\\n        if (j != prev)\\n        {\\n            riders += recursion(j, i, g, depth + 1, seats, res);\\n        }\\n    }\\n    if (depth == 0)\\n    {\\n        return res;\\n    }\\n    res += (riders / seats) * depth + (riders % seats ? 1 : 0);\\n    return riders % seats;\\n}\\n\\nlong long minimumFuelCost(vector<vector<int>> &roads, int seats)\\n{\\n    int n = roads.size();\\n    vector<int> g[n + 1];\\n\\n    for (auto &it : roads)\\n    {\\n        g[it[0]].push_back(it[1]);\\n        g[it[1]].push_back(it[0]);\\n    }\\n\\n    long long res = 0;\\n    return recursion(0, -1, g, 0, seats, res);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2832621,
                "title": "dfs-explanation-using-diagram",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst i was trying to use seats left, and if not then increment, but i realised in this case, that leader 3 can just leave the car at 1 and sit in leader 4\\'s car, and only 1 car will leave towards zero from 1.\\nThe key idea here is number of cars which moves out of a nodes is\\n\\n$$N(Cars\\\\ To\\\\ Leave\\\\ A\\\\ City) = ceil(total\\\\ Leaders\\\\ Including\\\\ Current\\\\ One/seats\\\\ In\\\\ One\\\\ Car)$$\\n   \\n![Screenshot 2022-11-20 at 1.19.48 PM.png](https://assets.leetcode.com/users/images/6b952a7c-044e-4082-89e5-174745a5cb60_1668930651.5677476.png)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Approach is to reach 0 from all other child routes (just for vizualization imagine it is graph not tree). So i\\'ve applied dfs on these routes maintaining vis array and it **returns pair of fuel**  and **number of leaders (reps) from subtree**. The total fuel will be sum of child.fuels.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(max(graph size, stack space))\\n# Code\\n```\\nclass Solution {\\n    typedef long long ll;\\n    typedef pair<ll,int> plli;\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n    long long res = 0;\\n    int n = roads.size() + 1;\\n    vector<vector<int>> graph(n);\\n    for(auto road: roads){\\n        graph[road[0]].push_back(road[1]);\\n        graph[road[1]].push_back(road[0]);\\n    }\\n    \\n    vector<int> vis(n,false);\\n    \\n    function<plli(int)> recur = [&](int i){\\n        vis[i] = true;\\n        ll fuel = 0; int reps = 1;\\n        for(int child: graph[i]){\\n            if(vis[child]) continue; \\n            auto [fuelChild, repsChild] = recur(child);\\n            fuel +=  fuelChild;\\n            reps +=  repsChild;\\n        }\\n        int cars = ceil(1.0*reps/seats);\\n        fuel += cars;\\n        return make_pair(fuel, reps);\\n    };\\n\\n    vis[0] = true;\\n    for(int city: graph[0]){\\n\\t    auto [fuel,_] =  recur(city);\\n\\t    res += fuel;\\n    }\\n    return res;\\n}\\n};\\n```\\n\\nPlease Upvote if it helped. Thanks \\uD83D\\uDC4D\\uD83C\\uDFFB",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n    typedef pair<ll,int> plli;\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n    long long res = 0;\\n    int n = roads.size() + 1;\\n    vector<vector<int>> graph(n);\\n    for(auto road: roads){\\n        graph[road[0]].push_back(road[1]);\\n        graph[road[1]].push_back(road[0]);\\n    }\\n    \\n    vector<int> vis(n,false);\\n    \\n    function<plli(int)> recur = [&](int i){\\n        vis[i] = true;\\n        ll fuel = 0; int reps = 1;\\n        for(int child: graph[i]){\\n            if(vis[child]) continue; \\n            auto [fuelChild, repsChild] = recur(child);\\n            fuel +=  fuelChild;\\n            reps +=  repsChild;\\n        }\\n        int cars = ceil(1.0*reps/seats);\\n        fuel += cars;\\n        return make_pair(fuel, reps);\\n    };\\n\\n    vis[0] = true;\\n    for(int city: graph[0]){\\n\\t    auto [fuel,_] =  recur(city);\\n\\t    res += fuel;\\n    }\\n    return res;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832370,
                "title": "c-dfs",
                "content": "```\\n\\tpublic long MinimumFuelCost(int[][] roads, int seats) {\\n        var n = roads.Length + 1;\\n        var graph = new List<int>[n];\\n        for (int i = 0; i < n; i++)\\n            graph[i] = new List<int>();\\n        foreach (var road in roads) {\\n            graph[road[0]].Add(road[1]);\\n            graph[road[1]].Add(road[0]);\\n        }\\n        long res = 0;\\n        DFS(graph, 0, seats, new HashSet<int> { 0 }, ref res);\\n        return res;\\n    }\\n\\n    public static int DFS(List<int>[] graph, int cur, int seats, HashSet<int> visited, ref long res) {\\n        var count = 1;\\n        foreach (var next in graph[cur]) {\\n            if (!visited.Add(next)) continue;\\n            count += DFS(graph, next, seats, visited, ref res);\\n        }\\n        if (cur == 0) return count;\\n        res += count % seats == 0 ? count / seats : count / seats + 1;\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic long MinimumFuelCost(int[][] roads, int seats) {\\n        var n = roads.Length + 1;\\n        var graph = new List<int>[n];\\n        for (int i = 0; i < n; i++)\\n            graph[i] = new List<int>();\\n        foreach (var road in roads) {\\n            graph[road[0]].Add(road[1]);\\n            graph[road[1]].Add(road[0]);\\n        }\\n        long res = 0;\\n        DFS(graph, 0, seats, new HashSet<int> { 0 }, ref res);\\n        return res;\\n    }\\n\\n    public static int DFS(List<int>[] graph, int cur, int seats, HashSet<int> visited, ref long res) {\\n        var count = 1;\\n        foreach (var next in graph[cur]) {\\n            if (!visited.Add(next)) continue;\\n            count += DFS(graph, next, seats, visited, ref res);\\n        }\\n        if (cur == 0) return count;\\n        res += count % seats == 0 ? count / seats : count / seats + 1;\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2832125,
                "title": "each-subtree-size-divided-by-seats-dfs",
                "content": "```\\nclass Solution {\\n    int dfs(int node, int parent, vector<int>& subtree_size, vector<int> graph[]) {\\n        subtree_size[node] = 1;\\n        \\n        for(auto vertex: graph[node]) {\\n            if(vertex == parent) continue;\\n            subtree_size[node] += dfs(vertex, node, subtree_size, graph);\\n        }\\n        \\n        return subtree_size[node];\\n    }\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n = roads.size() + 1;\\n        long long ans = 0;\\n        \\n        vector<int> graph[n];\\n        vector<int> subtree_size(n, 0);\\n        \\n        for(auto road: roads) {\\n            int u = road[0];\\n            int v = road[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        dfs(0, -1, subtree_size, graph);\\n        \\n        for(int i = 1; i < n; i++) {\\n            ans += ceil((double)subtree_size[i]/seats);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int node, int parent, vector<int>& subtree_size, vector<int> graph[]) {\\n        subtree_size[node] = 1;\\n        \\n        for(auto vertex: graph[node]) {\\n            if(vertex == parent) continue;\\n            subtree_size[node] += dfs(vertex, node, subtree_size, graph);\\n        }\\n        \\n        return subtree_size[node];\\n    }\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n = roads.size() + 1;\\n        long long ans = 0;\\n        \\n        vector<int> graph[n];\\n        vector<int> subtree_size(n, 0);\\n        \\n        for(auto road: roads) {\\n            int u = road[0];\\n            int v = road[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        dfs(0, -1, subtree_size, graph);\\n        \\n        for(int i = 1; i < n; i++) {\\n            ans += ceil((double)subtree_size[i]/seats);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832122,
                "title": "c-dfs-understandable-approach",
                "content": "```\\n//PLease Upvote if you liked the solution\\nclass Solution {\\npublic:\\n   \\n\\n    int k;\\n    long long ans=0;\\n    long long dfs(vector<int>adj[],int node,int par){\\n        long long count=1; //Count==>Total nodes in subtree with node as parent\\n        for(int child:adj[node]){\\n            if(child!=par){\\n               count+=dfs(adj,child,node);\\n            }\\n        }\\n        ans+=(count%k==0)?count/k:((count/k)+1);  // Grouping people in same cars before returning to parent node\\n        return count;\\n       \\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n=roads.size()+1;\\n        vector<int>adj[n];\\n        for(auto &i:roads){\\n            adj[i[0]].push_back(i[1]);\\n             adj[i[1]].push_back(i[0]);\\n        }\\n        k=seats;\\n        long long ans1=0;\\n       for(auto i:adj[0]){\\n           long long a=dfs(adj,i,0);\\n           ans1+=ans;\\n           ans=0;\\n       }\\n        return ans1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n//PLease Upvote if you liked the solution\\nclass Solution {\\npublic:\\n   \\n\\n    int k;\\n    long long ans=0;\\n    long long dfs(vector<int>adj[],int node,int par){\\n        long long count=1; //Count==>Total nodes in subtree with node as parent\\n        for(int child:adj[node]){\\n            if(child!=par){\\n               count+=dfs(adj,child,node);\\n            }\\n        }\\n        ans+=(count%k==0)?count/k:((count/k)+1);  // Grouping people in same cars before returning to parent node\\n        return count;\\n       \\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n=roads.size()+1;\\n        vector<int>adj[n];\\n        for(auto &i:roads){\\n            adj[i[0]].push_back(i[1]);\\n             adj[i[1]].push_back(i[0]);\\n        }\\n        k=seats;\\n        long long ans1=0;\\n       for(auto i:adj[0]){\\n           long long a=dfs(adj,i,0);\\n           ans1+=ans;\\n           ans=0;\\n       }\\n        return ans1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831956,
                "title": "dfs-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        List<List<Integer>> graph=new ArrayList<>();\\n        for(int i=0;i<=roads.length;i++) graph.add(new ArrayList<>());\\n        for(int[] road:roads){\\n            int u=road[0];\\n            int v=road[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        boolean[] vis=new boolean[roads.length+1];\\n        dfs(graph,0,seats,vis);\\n        return fuel;\\n    }\\n    long fuel;\\n    public int dfs(List<List<Integer>> graph,int road,int seats,boolean[] vis){\\n        int persons=1;\\n        vis[road]=true;\\n\\n        // find the number of persons that are coming including current\\n        for(int r:graph.get(road)){\\n            if(!vis[r]){\\n                persons+=dfs(graph,r,seats,vis);\\n            }        \\n        }\\n        //dont count fuel if we are at capital\\n        // fuel is calculated by diving no. of persons-1 by seats and include the current too i.e. 1\\n        if(road!=0)\\n           fuel+=((persons-1)/seats)+1;\\n        \\n        return persons;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        List<List<Integer>> graph=new ArrayList<>();\\n        for(int i=0;i<=roads.length;i++) graph.add(new ArrayList<>());\\n        for(int[] road:roads){\\n            int u=road[0];\\n            int v=road[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        boolean[] vis=new boolean[roads.length+1];\\n        dfs(graph,0,seats,vis);\\n        return fuel;\\n    }\\n    long fuel;\\n    public int dfs(List<List<Integer>> graph,int road,int seats,boolean[] vis){\\n        int persons=1;\\n        vis[road]=true;\\n\\n        // find the number of persons that are coming including current\\n        for(int r:graph.get(road)){\\n            if(!vis[r]){\\n                persons+=dfs(graph,r,seats,vis);\\n            }        \\n        }\\n        //dont count fuel if we are at capital\\n        // fuel is calculated by diving no. of persons-1 by seats and include the current too i.e. 1\\n        if(road!=0)\\n           fuel+=((persons-1)/seats)+1;\\n        \\n        return persons;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831943,
                "title": "javascript-dfs",
                "content": "```\\n/**\\n * @param {number[][]} roads\\n * @param {number} seats\\n * @return {number}\\n */\\nvar minimumFuelCost = function (roads, seats) {\\n  const adjList = Array.from({length: roads.length + 1}, ()=>[])\\n  for (const [from, to] of roads) {\\n    adjList[from].push(to);\\n    adjList[to].push(from);\\n  }\\n  let ans = 0;\\n  const dfs = (node, p) => {\\n    let here = 1;\\n    for (const ne of adjList[node]) {\\n      if (ne != p) {\\n        here += dfs(ne, node);\\n      }\\n    }\\n    if (p !== -1) {\\n      ans += Math.ceil(here / seats);\\n    } else {\\n      return ans;\\n    }\\n    return here;\\n  };\\n  return dfs(0, -1);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[][]} roads\\n * @param {number} seats\\n * @return {number}\\n */\\nvar minimumFuelCost = function (roads, seats) {\\n  const adjList = Array.from({length: roads.length + 1}, ()=>[])\\n  for (const [from, to] of roads) {\\n    adjList[from].push(to);\\n    adjList[to].push(from);\\n  }\\n  let ans = 0;\\n  const dfs = (node, p) => {\\n    let here = 1;\\n    for (const ne of adjList[node]) {\\n      if (ne != p) {\\n        here += dfs(ne, node);\\n      }\\n    }\\n    if (p !== -1) {\\n      ans += Math.ceil(here / seats);\\n    } else {\\n      return ans;\\n    }\\n    return here;\\n  };\\n  return dfs(0, -1);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2831874,
                "title": "simple-c-solution-using-dfs",
                "content": "class Solution {\\npublic:\\n\\n    int minimumFuel(int src,vector<int> adj[],vector<bool> &visited,long long &minimumCost,int distanceFar,int seats)\\n    {\\n        visited[src] = true;\\n        \\n        int personsTillNow = 1;\\n        \\n        for(int children : adj[src])\\n        {\\n            if(!visited[children])\\n            {\\n                int personsComing = minimumFuel(children,adj,visited,minimumCost,distanceFar+1,seats);\\n                personsTillNow += personsComing;\\n                if((personsTillNow-1) == seats)\\n                {\\n                    long long cost  = distanceFar;\\n                    minimumCost += (personsTillNow-1);\\n                    minimumCost += cost;\\n                    personsTillNow = 1;\\n                }\\n                else if(personsTillNow>seats)\\n                {\\n                    long long cost  = distanceFar;\\n                    minimumCost += (seats);\\n                    minimumCost += cost;\\n                    personsTillNow -= seats;\\n                }\\n            }\\n        }\\n        \\n        if(src == 0)\\n            minimumCost += (personsTillNow-1);\\n        \\n        return personsTillNow;\\n    \\n    }\\n    \\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n = roads.size();\\n        vector<int>adj[n+1];\\n        \\n        for(int i = 0;i<roads.size();i++)\\n        {\\n            adj[roads[i][0]].push_back(roads[i][1]);\\n            adj[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        \\n        vector<bool>visited(n+1,false);\\n        \\n        long long minimumCost = 0;\\n        long distanceFar = 0;\\n        \\n        \\n        minimumFuel(0,adj,visited,minimumCost,distanceFar,seats);\\n        \\n        return minimumCost;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minimumFuel(int src,vector<int> adj[],vector<bool> &visited,long long &minimumCost,int distanceFar,int seats)\\n    {\\n        visited[src] = true;\\n        \\n        int personsTillNow = 1;\\n        \\n        for(int children : adj[src])\\n        {\\n            if(!visited[children])\\n            {\\n                int personsComing = minimumFuel(children,adj,visited,minimumCost,distanceFar+1,seats);\\n                personsTillNow += personsComing;\\n                if((personsTillNow-1) == seats)\\n                {\\n                    long long cost  = distanceFar;\\n                    minimumCost += (personsTillNow-1);\\n                    minimumCost += cost;\\n                    personsTillNow = 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2831817,
                "title": "java-dfs",
                "content": "``` java\\nclass Solution {\\n    private long fuelCost;\\n\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        if (roads == null || roads.length == 0) {\\n            return 0;\\n        }\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int[] road : roads) {\\n            graph.putIfAbsent(road[0], new ArrayList<>());\\n            graph.get(road[0]).add(road[1]);\\n            graph.putIfAbsent(road[1], new ArrayList<>());\\n            graph.get(road[1]).add(road[0]);\\n        }\\n        this.fuelCost = 0;\\n        for (int city : graph.get(0)) {\\n            numOfChildren(graph, city, 0, seats);\\n        }\\n        return this.fuelCost;\\n    }\\n\\n    // DFS\\n    private long numOfChildren(Map<Integer, List<Integer>> graph, int city, int from, int seats) {\\n        if (graph.get(city).size() == 1) {\\n            this.fuelCost += 1;\\n            return 1;\\n        }\\n        int children = 1;\\n        for (int child : graph.get(city)) {\\n            if (child == from) {\\n                continue;\\n            }\\n            children += numOfChildren(graph, child, city, seats);\\n        }\\n        this.fuelCost += (children + seats - 1) / seats;\\n        return children;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "``` java\\nclass Solution {\\n    private long fuelCost;\\n\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n        if (roads == null || roads.length == 0) {\\n            return 0;\\n        }\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for (int[] road : roads) {\\n            graph.putIfAbsent(road[0], new ArrayList<>());\\n            graph.get(road[0]).add(road[1]);\\n            graph.putIfAbsent(road[1], new ArrayList<>());\\n            graph.get(road[1]).add(road[0]);\\n        }\\n        this.fuelCost = 0;\\n        for (int city : graph.get(0)) {\\n            numOfChildren(graph, city, 0, seats);\\n        }\\n        return this.fuelCost;\\n    }\\n\\n    // DFS\\n    private long numOfChildren(Map<Integer, List<Integer>> graph, int city, int from, int seats) {\\n        if (graph.get(city).size() == 1) {\\n            this.fuelCost += 1;\\n            return 1;\\n        }\\n        int children = 1;\\n        for (int child : graph.get(city)) {\\n            if (child == from) {\\n                continue;\\n            }\\n            children += numOfChildren(graph, child, city, seats);\\n        }\\n        this.fuelCost += (children + seats - 1) / seats;\\n        return children;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831795,
                "title": "easy-dfs-solution-with-explaination",
                "content": "# Approach\\nfor each node calculate all the children from a particular branch \\nthen do this for each branch. now the litre of fuel for every such branch will be the upper bound of total child that is total people that want to travel from that child to the parent node divided by the seats\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long ans = 0;\\n    \\n    void dfs(int v,int par,vector<int> g[],vector<long long>& child,int seats){\\n        for(auto c:g[v]){\\n            if(c == par) continue;\\n            dfs(c,v,g,child,seats);\\n            //this is the number of children from a branch that is\\n            //the people who want to traver from a road \\n            int bchild = (1 + child[c]);\\n            //so petrol needed will be this\\n            ans += ((bchild + seats - 1)/seats);\\n            //now store the total child from all branches of that\\n            //node also\\n            child[v] += bchild;\\n        }\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size();\\n        vector<int> g[n+1];\\n        \\n        for(int i=0;i<n;i++){\\n            g[roads[i][0]].push_back(roads[i][1]);\\n            g[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        \\n        vector<long long> child(n+1 , 0);\\n        dfs(0,-1,g,child,seats);\\n        \\n        // for(int i=0;i<n+1;i++) cout<<child[i]<<\" \";\\n        // cout<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long ans = 0;\\n    \\n    void dfs(int v,int par,vector<int> g[],vector<long long>& child,int seats){\\n        for(auto c:g[v]){\\n            if(c == par) continue;\\n            dfs(c,v,g,child,seats);\\n            //this is the number of children from a branch that is\\n            //the people who want to traver from a road \\n            int bchild = (1 + child[c]);\\n            //so petrol needed will be this\\n            ans += ((bchild + seats - 1)/seats);\\n            //now store the total child from all branches of that\\n            //node also\\n            child[v] += bchild;\\n        }\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size();\\n        vector<int> g[n+1];\\n        \\n        for(int i=0;i<n;i++){\\n            g[roads[i][0]].push_back(roads[i][1]);\\n            g[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        \\n        vector<long long> child(n+1 , 0);\\n        dfs(0,-1,g,child,seats);\\n        \\n        // for(int i=0;i<n+1;i++) cout<<child[i]<<\" \";\\n        // cout<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2831790,
                "title": "rust-c-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\nRust\\n~~~\\nimpl Solution {\\n    pub fn minimum_fuel_cost(roads: Vec<Vec<i32>>, seats: i32) -> i64 {\\n        let n = roads.len() + 1;\\n        let mut graph = vec![vec![]; n];\\n        \\n        for r in roads {\\n            let (u, v) = (r[0] as usize, r[1] as usize);\\n            graph[u].push(v);\\n            graph[v].push(u);\\n        }\\n        \\n        let mut flag = vec![0; n];\\n        let mut ret = 0;\\n        \\n        flag[0] = 1;\\n        Self::dfs(0, &graph, &mut flag, &mut ret, seats);\\n        \\n        ret\\n    }\\n    \\n    fn dfs(u: usize, graph: &Vec<Vec<usize>>, flag: &mut Vec<i32>, ret: &mut i64, seats: i32) -> i32 {\\n        let mut count = 1;\\n        for v in &graph[u] {\\n            if flag[*v] == 1 { continue }\\n            \\n            flag[*v] = 1;\\n            let temp = Self::dfs(*v, graph, flag, ret, seats);\\n            *ret += ((temp + seats - 1) / seats) as i64;\\n            count += temp;\\n        }\\n        \\n        count\\n    }\\n}\\n~~~\\n\\nC++\\n```\\nclass Solution {\\n    int dfs(int u, vector<vector<int>> &graph, vector<int> &flag, long long &ret, int seats) {\\n        int count = 1;\\n        for (auto &v: graph[u]) {\\n            if (flag[v] == 1) continue;\\n            flag[v] = 1;\\n            \\n            int temp = dfs(v, graph, flag, ret, seats);\\n            ret += (temp + seats - 1) / seats;\\n            count += temp;\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size() + 1;\\n        vector<vector<int>> graph(n);\\n        \\n        for (auto &r: roads) {\\n            graph[r[0]].push_back(r[1]);\\n            graph[r[1]].push_back(r[0]);\\n        } \\n        \\n        vector<int> flag(n);\\n        flag[0] = 1;;\\n        long long ret = 0;\\n        \\n        dfs(0, graph, flag, ret, seats);\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int u, vector<vector<int>> &graph, vector<int> &flag, long long &ret, int seats) {\\n        int count = 1;\\n        for (auto &v: graph[u]) {\\n            if (flag[v] == 1) continue;\\n            flag[v] = 1;\\n            \\n            int temp = dfs(v, graph, flag, ret, seats);\\n            ret += (temp + seats - 1) / seats;\\n            count += temp;\\n        }\\n        return count;\\n    }\\n    \\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n = roads.size() + 1;\\n        vector<vector<int>> graph(n);\\n        \\n        for (auto &r: roads) {\\n            graph[r[0]].push_back(r[1]);\\n            graph[r[1]].push_back(r[0]);\\n        } \\n        \\n        vector<int> flag(n);\\n        flag[0] = 1;;\\n        long long ret = 0;\\n        \\n        dfs(0, graph, flag, ret, seats);\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831789,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    \\n    private boolean isLeaf(int node,int parent,Map<Integer,Set<Integer>> map){\\n        return node!=parent && map.containsKey(node) &&   map.get(node).contains(parent) && map.get(node).size()==1;\\n    }\\n    int seats = -1;\\n    public long minimumFuelCost(int[][] roads, int s) {\\n        if(roads.length==0){\\n            return 0;\\n        }\\n        seats = s;\\n        HashMap<Integer, Set<Integer>> tree = new HashMap<>();\\n        for(int [] edge : roads){\\n            Set<Integer> set  = tree.getOrDefault(edge[0],new HashSet<>());\\n            set.add(edge[1]);\\n            tree.put(edge[0],set);\\n            set = tree.getOrDefault(edge[1],new HashSet<>());\\n            set.add(edge[0]);\\n            tree.put(edge[1],set);\\n        }\\n        HashSet<Integer> visited = new HashSet<>();\\n        long [] data = dfs(0,-1,tree,visited);\\n        return data[2];\\n    }\\n    \\n\\n      // returns full cars,partial cars,num people,cost\\n     //cars,people,cost\\n      private long[] dfs(int node,int parent, HashMap<Integer, Set<Integer>> tree, HashSet<Integer> visited) {\\n        if (isLeaf(node,parent,tree)) {\\n          return new long[] {1,1,1};\\n        }\\n        visited.add(node);\\n        long numCars=0,people=0,cost=0;\\n        for (int child : tree.get(node)) {\\n          if (!visited.contains(child)) {\\n            long[] childData = dfs(child,node, tree, visited);\\n            numCars += childData[0];\\n            people += childData[1];\\n            cost+=childData[2];\\n             \\n          }\\n        }\\n        people++;\\n          \\n          \\n        if(numCars*seats>=people){\\n            long totalSeats = numCars*seats;\\n            long full = people/seats;\\n            long partial = (people%seats)==0?0:1;\\n            // System.out.println(node+\" \"+full+\" \"+partial);\\n            if(node==0){\\n                return new long[]{full+partial,people,cost};\\n            }\\n            cost = cost+full;\\n            cost = cost+partial;\\n            return new long[]{full+partial,people,cost};\\n        }else{\\n            // System.out.println(\"Here\");\\n            return new long[]{numCars+1,people,cost+=(node!=0)?(numCars+1):0};\\n        }\\n      }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private boolean isLeaf(int node,int parent,Map<Integer,Set<Integer>> map){\\n        return node!=parent && map.containsKey(node) &&   map.get(node).contains(parent) && map.get(node).size()==1;\\n    }\\n    int seats = -1;\\n    public long minimumFuelCost(int[][] roads, int s) {\\n        if(roads.length==0){\\n            return 0;\\n        }\\n        seats = s;\\n        HashMap<Integer, Set<Integer>> tree = new HashMap<>();\\n        for(int [] edge : roads){\\n            Set<Integer> set  = tree.getOrDefault(edge[0],new HashSet<>());\\n            set.add(edge[1]);\\n            tree.put(edge[0],set);\\n            set = tree.getOrDefault(edge[1],new HashSet<>());\\n            set.add(edge[0]);\\n            tree.put(edge[1],set);\\n        }\\n        HashSet<Integer> visited = new HashSet<>();\\n        long [] data = dfs(0,-1,tree,visited);\\n        return data[2];\\n    }\\n    \\n\\n      // returns full cars,partial cars,num people,cost\\n     //cars,people,cost\\n      private long[] dfs(int node,int parent, HashMap<Integer, Set<Integer>> tree, HashSet<Integer> visited) {\\n        if (isLeaf(node,parent,tree)) {\\n          return new long[] {1,1,1};\\n        }\\n        visited.add(node);\\n        long numCars=0,people=0,cost=0;\\n        for (int child : tree.get(node)) {\\n          if (!visited.contains(child)) {\\n            long[] childData = dfs(child,node, tree, visited);\\n            numCars += childData[0];\\n            people += childData[1];\\n            cost+=childData[2];\\n             \\n          }\\n        }\\n        people++;\\n          \\n          \\n        if(numCars*seats>=people){\\n            long totalSeats = numCars*seats;\\n            long full = people/seats;\\n            long partial = (people%seats)==0?0:1;\\n            // System.out.println(node+\" \"+full+\" \"+partial);\\n            if(node==0){\\n                return new long[]{full+partial,people,cost};\\n            }\\n            cost = cost+full;\\n            cost = cost+partial;\\n            return new long[]{full+partial,people,cost};\\n        }else{\\n            // System.out.println(\"Here\");\\n            return new long[]{numCars+1,people,cost+=(node!=0)?(numCars+1):0};\\n        }\\n      }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831748,
                "title": "c-topological-sort-bfs-dictionary",
                "content": "```\\n    public long MinimumFuelCost(int[][] roads, int seats)\\n    {\\n        Dictionary<int, HashSet<int>> graph = new Dictionary<int, HashSet<int>>();\\n        Dictionary<int, int> Indegree = new Dictionary<int, int>();\\n        Dictionary<int, int> currentPassengers = new Dictionary<int, int>();\\n        foreach (int[] road in roads)\\n        {\\n            graph.TryAdd(road[0], new HashSet<int>());\\n            graph.TryAdd(road[1], new HashSet<int>());\\n            graph[road[0]].Add(road[1]);\\n            graph[road[1]].Add(road[0]);\\n\\n            Indegree.TryAdd(road[0], 0);\\n            Indegree.TryAdd(road[1], 0);\\n            Indegree[road[0]]++;\\n            Indegree[road[1]]++;\\n        }\\n\\n        int nodesCount = graph.Count;\\n        for (int i = 0; i < nodesCount; i++)\\n        {\\n            currentPassengers[i]=1;\\n        }\\n\\n        Queue<int> queue = new Queue<int>();\\n        for (int i = 1; i < nodesCount; i++)\\n        {\\n            if (Indegree[i] == 1)\\n            {\\n                queue.Enqueue(i);\\n            }\\n        }\\n\\n        long result = 0;\\n        while(queue.Any())\\n        {\\n            int count = queue.Count;\\n            for (int i = 0; i < count; i++)\\n            {\\n                int currNode = queue.Dequeue();\\n                int parentNode = graph[currNode].First();\\n                graph.Remove(currNode);\\n                graph[parentNode].Remove(currNode);\\n                Indegree[parentNode]--;\\n                if (Indegree[parentNode] == 1 && parentNode != 0)\\n                    queue.Enqueue(parentNode);\\n\\n                currentPassengers[parentNode]+= currentPassengers[currNode];\\n               \\n                result += ((currentPassengers[currNode]-1) / seats) + 1;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public long MinimumFuelCost(int[][] roads, int seats)\\n    {\\n        Dictionary<int, HashSet<int>> graph = new Dictionary<int, HashSet<int>>();\\n        Dictionary<int, int> Indegree = new Dictionary<int, int>();\\n        Dictionary<int, int> currentPassengers = new Dictionary<int, int>();\\n        foreach (int[] road in roads)\\n        {\\n            graph.TryAdd(road[0], new HashSet<int>());\\n            graph.TryAdd(road[1], new HashSet<int>());\\n            graph[road[0]].Add(road[1]);\\n            graph[road[1]].Add(road[0]);\\n\\n            Indegree.TryAdd(road[0], 0);\\n            Indegree.TryAdd(road[1], 0);\\n            Indegree[road[0]]++;\\n            Indegree[road[1]]++;\\n        }\\n\\n        int nodesCount = graph.Count;\\n        for (int i = 0; i < nodesCount; i++)\\n        {\\n            currentPassengers[i]=1;\\n        }\\n\\n        Queue<int> queue = new Queue<int>();\\n        for (int i = 1; i < nodesCount; i++)\\n        {\\n            if (Indegree[i] == 1)\\n            {\\n                queue.Enqueue(i);\\n            }\\n        }\\n\\n        long result = 0;\\n        while(queue.Any())\\n        {\\n            int count = queue.Count;\\n            for (int i = 0; i < count; i++)\\n            {\\n                int currNode = queue.Dequeue();\\n                int parentNode = graph[currNode].First();\\n                graph.Remove(currNode);\\n                graph[parentNode].Remove(currNode);\\n                Indegree[parentNode]--;\\n                if (Indegree[parentNode] == 1 && parentNode != 0)\\n                    queue.Enqueue(parentNode);\\n\\n                currentPassengers[parentNode]+= currentPassengers[currNode];\\n               \\n                result += ((currentPassengers[currNode]-1) / seats) + 1;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2831696,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dfs(long long node, vector<long long> adj[], long long st, vector<long long> &vis, long long &car){\\n        vis[node] = 1;\\n        long long people = 0;\\n        for(auto &x : adj[node]){\\n            if(vis[x])  continue;\\n            people += dfs(x, adj, st, vis, car); \\n        }\\n        \\n        if(node != 0){\\n            car += ceil(1.0 * (people + 1.0)/st * 1.0);\\n        }\\n        \\n        return people+1;\\n    }\\n    \\n    long long minimumFuelCost(vector<vector<int>>& rd, int st) {\\n        long long n = rd.size();\\n        vector<long long> adj[n+1];\\n        for(int i=0; i<n; i++){\\n            adj[rd[i][0]].push_back(rd[i][1]);\\n            adj[rd[i][1]].push_back(rd[i][0]);\\n        }\\n        vector<long long> vis(n+1, 0);\\n        long long car = 0;\\n        long long p = dfs(0, adj, st, vis, car);\\n        return car;\\n    }\\n};\\n```\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dfs(long long node, vector<long long> adj[], long long st, vector<long long> &vis, long long &car){\\n        vis[node] = 1;\\n        long long people = 0;\\n        for(auto &x : adj[node]){\\n            if(vis[x])  continue;\\n            people += dfs(x, adj, st, vis, car); \\n        }\\n        \\n        if(node != 0){\\n            car += ceil(1.0 * (people + 1.0)/st * 1.0);\\n        }\\n        \\n        return people+1;\\n    }\\n    \\n    long long minimumFuelCost(vector<vector<int>>& rd, int st) {\\n        long long n = rd.size();\\n        vector<long long> adj[n+1];\\n        for(int i=0; i<n; i++){\\n            adj[rd[i][0]].push_back(rd[i][1]);\\n            adj[rd[i][1]].push_back(rd[i][0]);\\n        }\\n        vector<long long> vis(n+1, 0);\\n        long long car = 0;\\n        long long p = dfs(0, adj, st, vis, car);\\n        return car;\\n    }\\n};\\n```\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091272,
                "title": "fastest-dfs-implementation-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        graph = [[] for i in range((len(roads)+1))]\\n        for node1,node2 in roads:\\n            graph[node1].append(node2)\\n            graph[node2].append(node1)\\n        self.ans = 0\\n        def dfs(node,parent):\\n            passenger = 0\\n            for child in graph[node]:\\n                if child!=parent:\\n                    p = dfs(child,node)\\n                    passenger+=p\\n                    self.ans += int(ceil(p/seats))\\n            return passenger + 1\\n        dfs(0,None)\\n        return self.ans\\n```\\n*****PLEASE UPVOTE*****",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        graph = [[] for i in range((len(roads)+1))]\\n        for node1,node2 in roads:\\n            graph[node1].append(node2)\\n            graph[node2].append(node1)\\n        self.ans = 0\\n        def dfs(node,parent):\\n            passenger = 0\\n            for child in graph[node]:\\n                if child!=parent:\\n                    p = dfs(child,node)\\n                    passenger+=p\\n                    self.ans += int(ceil(p/seats))\\n            return passenger + 1\\n        dfs(0,None)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079418,
                "title": "dfs",
                "content": "# Intuition\\nThe first thing that i think is the no of representatives at a particular node.If sufficient seats are available then it requires 1 litre of petrol from that node to some other node.\\n\\n# Approach\\nDFS to find the available nodes at a particular instant.If sufficient seats are available the add 1 to your answer else add no of nodes divided by total seats.Add 1 if the given division produces a remainder.\\n\\n# Complexity\\n- Time complexity:\\nO(V+E)\\n\\n- Space complexity:\\nO(V)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int DFS(vector<vector<int>> &Graph,int i,vector<int>&visited,int n,long long &sum)\\n    {\\n        visited[i]=1;\\n        int ans=1;\\n        for(auto j:Graph[i])\\n        {\\n            if(visited[j]==0)\\n            {\\n                ans+=DFS(Graph,j,visited,n,sum);\\n            }\\n        }\\n\\n        if(i==0)\\n        return 0;\\n\\n        if(ans%n==0)\\n        sum+=ans/n;\\n        else\\n        sum+=ans/n+1;\\n        return ans;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n=roads.size();\\n        vector<vector<int>> Graph(n+1);\\n        vector<int> visited(n+1,0);\\n        for(auto v:roads)\\n        {\\n            Graph[v[0]].push_back(v[1]);\\n            Graph[v[1]].push_back(v[0]);\\n        }\\n        long long sum=0;\\n        int k=DFS(Graph,0,visited,seats,sum);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int DFS(vector<vector<int>> &Graph,int i,vector<int>&visited,int n,long long &sum)\\n    {\\n        visited[i]=1;\\n        int ans=1;\\n        for(auto j:Graph[i])\\n        {\\n            if(visited[j]==0)\\n            {\\n                ans+=DFS(Graph,j,visited,n,sum);\\n            }\\n        }\\n\\n        if(i==0)\\n        return 0;\\n\\n        if(ans%n==0)\\n        sum+=ans/n;\\n        else\\n        sum+=ans/n+1;\\n        return ans;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n=roads.size();\\n        vector<vector<int>> Graph(n+1);\\n        vector<int> visited(n+1,0);\\n        for(auto v:roads)\\n        {\\n            Graph[v[0]].push_back(v[1]);\\n            Graph[v[1]].push_back(v[0]);\\n        }\\n        long long sum=0;\\n        int k=DFS(Graph,0,visited,seats,sum);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074862,
                "title": "python3-fast-o-n-time-o-n-space-dfs-solution",
                "content": "![Screenshot from 2023-09-22 09-34-21.png](https://assets.leetcode.com/users/images/48e1fd34-2c9b-4998-beed-e8670c6d8c1b_1695356109.433064.png)\\n\\n# Intuition\\nLet\\'s say you have an array *rank*, where *rank*[i] is the number of nodes that connect the current node to the tree\\'s leaf. This array may be used to determine the least amount of fuel required to get to the present node.\\n\\n# Approach\\nA simple DFS from all neighbor nodes to the leaf nodes can do this. Calculating each node\\'s rank and doing a ceiling division by the seats yields the lowest fuel cost.\\n\\n    Thanks :) \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        n = len(roads)+1\\n\\n        adj = [[] for _ in range(n)]\\n        visited = [False]*n\\n        res = [0]\\n\\n        for a,b in roads:\\n            adj[a].append(b)\\n            adj[b].append(a)\\n\\n        def dfs(i):\\n            if visited[i]: return 0\\n            visited[i] = True\\n            conn = 0\\n            for j in adj[i]:\\n                conn += dfs(j)\\n            res[0] += math.ceil((conn+1)/seats)\\n            return conn+1\\n\\n        visited[0] = True\\n        for i in adj[0]:\\n            dfs(i)\\n        \\n        return res[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        n = len(roads)+1\\n\\n        adj = [[] for _ in range(n)]\\n        visited = [False]*n\\n        res = [0]\\n\\n        for a,b in roads:\\n            adj[a].append(b)\\n            adj[b].append(a)\\n\\n        def dfs(i):\\n            if visited[i]: return 0\\n            visited[i] = True\\n            conn = 0\\n            for j in adj[i]:\\n                conn += dfs(j)\\n            res[0] += math.ceil((conn+1)/seats)\\n            return conn+1\\n\\n        visited[0] = True\\n        for i in adj[0]:\\n            dfs(i)\\n        \\n        return res[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032155,
                "title": "clean-codes-full-explanation-dfs-c",
                "content": "# Author: Jayesh Badgujar\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    pair<double,double> dfs(int src,map<int,vector<int>>& mp,int& seats,int par){\\n        \\n        double total_seat=0,fuel=0;\\n        for(auto it:mp[src]){\\n            if(it==par){\\n                continue;\\n            }\\n            pair<double,double> curr=dfs(it,mp,seats,src);\\n            fuel+=curr.first;\\n            total_seat+=curr.second;\\n        }\\n        double total_cars=ceil((total_seat+1)/seats);\\n        if(src==0){\\n            return {fuel,total_seat+1};\\n        }\\n        return {fuel+total_cars,total_seat+1.0};\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        map<int,vector<int>> mp;\\n        for(int i=0;i<roads.size();i++){\\n            mp[roads[i][0]].push_back(roads[i][1]);\\n            mp[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        //fuel,seat\\n        pair<long long,long long> ans=dfs(0,mp,seats,-1);\\n        return (long long)ans.first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<double,double> dfs(int src,map<int,vector<int>>& mp,int& seats,int par){\\n        \\n        double total_seat=0,fuel=0;\\n        for(auto it:mp[src]){\\n            if(it==par){\\n                continue;\\n            }\\n            pair<double,double> curr=dfs(it,mp,seats,src);\\n            fuel+=curr.first;\\n            total_seat+=curr.second;\\n        }\\n        double total_cars=ceil((total_seat+1)/seats);\\n        if(src==0){\\n            return {fuel,total_seat+1};\\n        }\\n        return {fuel+total_cars,total_seat+1.0};\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        map<int,vector<int>> mp;\\n        for(int i=0;i<roads.size();i++){\\n            mp[roads[i][0]].push_back(roads[i][1]);\\n            mp[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        //fuel,seat\\n        pair<long long,long long> ans=dfs(0,mp,seats,-1);\\n        return (long long)ans.first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023818,
                "title": "linear-time",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        adj = collections.defaultdict(list)\\n\\n        for src,dst in roads:\\n            adj[src].append(dst)\\n            adj[dst].append(src)\\n\\n        def dfs(node,parent):\\n            nonlocal res\\n            passengers = 0\\n            for child in adj[node]:\\n                if child != parent:\\n                    p = dfs(child,node)\\n                    passengers += p\\n                    res += ceil(p/seats)\\n            return passengers + 1\\n        res = 0\\n        dfs(0,-1)\\n        return res\\n\\n# time -> O(N)\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        adj = collections.defaultdict(list)\\n\\n        for src,dst in roads:\\n            adj[src].append(dst)\\n            adj[dst].append(src)\\n\\n        def dfs(node,parent):\\n            nonlocal res\\n            passengers = 0\\n            for child in adj[node]:\\n                if child != parent:\\n                    p = dfs(child,node)\\n                    passengers += p\\n                    res += ceil(p/seats)\\n            return passengers + 1\\n        res = 0\\n        dfs(0,-1)\\n        return res\\n\\n# time -> O(N)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020756,
                "title": "java-solution-beginner-friendly",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.For Every Node we are calculating the number of passengers who will pass this node for reaching 0.\\n2. Let x people visit a Node then I am just calculating the fuel to move this x people to next node and so on for every other node.\\n3. this will made final result.\\n# Complexity\\n- Time complexity:O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(V+E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n\\n       int n=roads.length;\\n       ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<=n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n// Adjacency representaiton of graph\\n        for(int i=0;i<n;i++){\\n           adj.get(roads[i][0]).add(roads[i][1]);\\n           adj.get(roads[i][1]).add(roads[i][0]);\\n        }\\n       long countNodes[]=new long[n+1];\\n       boolean[] visited=new boolean[n+1];\\n       Arrays.fill(countNodes,-1);\\n       solve(adj,0,countNodes,visited);\\n       long ans=0;\\n       for(int i=1;i<=n;i++){\\n           if(countNodes[i]!=-1){\\n               if(countNodes[i]%seats==0){\\n                   ans+=countNodes[i]/seats;\\n               }\\n               else ans+=countNodes[i]/seats+1;\\n           }\\n       }\\n       return ans;\\n    }\\n    public long solve(ArrayList<ArrayList<Integer>> adj,int i,long[] countNodes,boolean[] visited){\\n       visited[i]=true;\\n        long count=0;\\n        for(int t:adj.get(i)){\\n            if(!visited[t])\\n            count+=solve(adj,t,countNodes,visited);\\n        }\\n       return countNodes[i]=count+(long)1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumFuelCost(int[][] roads, int seats) {\\n\\n       int n=roads.length;\\n       ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<=n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n// Adjacency representaiton of graph\\n        for(int i=0;i<n;i++){\\n           adj.get(roads[i][0]).add(roads[i][1]);\\n           adj.get(roads[i][1]).add(roads[i][0]);\\n        }\\n       long countNodes[]=new long[n+1];\\n       boolean[] visited=new boolean[n+1];\\n       Arrays.fill(countNodes,-1);\\n       solve(adj,0,countNodes,visited);\\n       long ans=0;\\n       for(int i=1;i<=n;i++){\\n           if(countNodes[i]!=-1){\\n               if(countNodes[i]%seats==0){\\n                   ans+=countNodes[i]/seats;\\n               }\\n               else ans+=countNodes[i]/seats+1;\\n           }\\n       }\\n       return ans;\\n    }\\n    public long solve(ArrayList<ArrayList<Integer>> adj,int i,long[] countNodes,boolean[] visited){\\n       visited[i]=true;\\n        long count=0;\\n        for(int t:adj.get(i)){\\n            if(!visited[t])\\n            count+=solve(adj,t,countNodes,visited);\\n        }\\n       return countNodes[i]=count+(long)1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019215,
                "title": "o-n-time-o-n-space-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTotal fuel = sum of cars required at each child node to reach the parent node\\n\\nTotal cars required at a node = ceil (passengers arriving at the node / total seats in the car)\\nuse ceil to round up the number\\nfor example: passenger = 1, seats = 2, passengers/seats = 1/2 = 0.5 \\nWe need 1 car and ceil will round up 0.5 to 1\\n\\nDo DFS to traverse all nodes, find the child nodes and the cars required.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- set res = 0 to track the total fuel\\n- create a hashmap for the adjacency list representation of the graph\\nkey = node, value = list of neighbor nodes\\n- create the graph (adjacency list)\\nfor each edge (source node, destination node)\\n  - add a bidirectional edge from the source to the destination\\n- define a helper function for DFS\\ndfs(current node, parent node)\\n  - mark res as nonlocal\\n  - set total = 1 to track the total passengers arriving at the current node. 1 because initially there is one passenger at each node\\n  - for each neighbor (child node) of the current node\\n    - if the neighbor is not the parent i.e it is a child node, this is to make sure we are not moving backward\\n      - do DFS to find the passengers arriving at the child node\\n      - add the child node passengers to the total passengers\\n      - find the total cars required for the child node passengers and update res\\n  - return total\\n- start DFS from the root node\\n- return res\\n\\n# Complexity\\n- Time complexity:  O(graph creation + graph traversal) \\u2192 O(adjacency list creation + adjacency list DFS) \\u2192 O(E + V + E) \\u2192 O(V + E) \\u2192 O(n + n) \\u2192 O(n + n)\\nV = total vertices or nodes or rows or sublists or keys = cities\\nE = total edges = roads \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(graph + DFS recursion stack) \\u2192 O(adjacency list + V) \\u2192 O(V + E + V) \\u2192 O(V + E) \\u2192 O(n + n) \\u2192 O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        res = 0\\n        graph = defaultdict(list)\\n        for u, v in roads:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        def dfs(node: int, parent: int) -> None:\\n            nonlocal res\\n            total = 1\\n            for neighbor in graph[node]:\\n                if neighbor != parent:\\n                    cur = dfs(neighbor, node)\\n                    total += cur\\n                    res += ceil(cur / seats)\\n            return total\\n\\n        dfs(0, None)\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        res = 0\\n        graph = defaultdict(list)\\n        for u, v in roads:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        \\n        def dfs(node: int, parent: int) -> None:\\n            nonlocal res\\n            total = 1\\n            for neighbor in graph[node]:\\n                if neighbor != parent:\\n                    cur = dfs(neighbor, node)\\n                    total += cur\\n                    res += ceil(cur / seats)\\n            return total\\n\\n        dfs(0, None)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968381,
                "title": "golang-dfs-solution",
                "content": "# Code\\n```go\\nfunc minimumFuelCost(roads [][]int, seats int) int64 {\\n\\tways := make(map[int][]int, 2*len(roads))\\n\\tfor _, w := range roads {\\n\\t\\tways[w[0]] = append(ways[w[0]], w[1])\\n\\t\\tways[w[1]] = append(ways[w[1]], w[0])\\n\\t}\\n\\tarrived := make(map[int]bool, len(roads)+1)\\n\\tpeople := make([]int, len(roads)+1)\\n\\t_ = helper(ways, people, 0, arrived)\\n\\n\\tfuel := 0\\n\\tfor i, p := range people {\\n\\t\\tif i == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfuel += p / seats\\n\\t\\tif p % seats > 0 {\\n\\t\\t\\tfuel++\\n\\t\\t}\\n\\t}\\n\\treturn int64(fuel)\\n}\\n\\nfunc helper(ways map[int][]int, people []int, city int, arrived map[int]bool) int {\\n\\tif arrived[city] == true {\\n\\t\\treturn 0\\n\\t}\\n\\tarrived[city] = true\\n\\trepresentative := 1\\n\\tfor _, next := range ways[city] {\\n\\t\\trepresentative += helper(ways, people, next, arrived)\\n\\t}\\n\\tpeople[city] = representative\\n\\treturn representative\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```go\\nfunc minimumFuelCost(roads [][]int, seats int) int64 {\\n\\tways := make(map[int][]int, 2*len(roads))\\n\\tfor _, w := range roads {\\n\\t\\tways[w[0]] = append(ways[w[0]], w[1])\\n\\t\\tways[w[1]] = append(ways[w[1]], w[0])\\n\\t}\\n\\tarrived := make(map[int]bool, len(roads)+1)\\n\\tpeople := make([]int, len(roads)+1)\\n\\t_ = helper(ways, people, 0, arrived)\\n\\n\\tfuel := 0\\n\\tfor i, p := range people {\\n\\t\\tif i == 0 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfuel += p / seats\\n\\t\\tif p % seats > 0 {\\n\\t\\t\\tfuel++\\n\\t\\t}\\n\\t}\\n\\treturn int64(fuel)\\n}\\n\\nfunc helper(ways map[int][]int, people []int, city int, arrived map[int]bool) int {\\n\\tif arrived[city] == true {\\n\\t\\treturn 0\\n\\t}\\n\\tarrived[city] = true\\n\\trepresentative := 1\\n\\tfor _, next := range ways[city] {\\n\\t\\trepresentative += helper(ways, people, next, arrived)\\n\\t}\\n\\tpeople[city] = representative\\n\\treturn representative\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3958007,
                "title": "dfs-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long ans=0;\\n    long long int dfs(int node, vector<int>&vis,vector<vector<int>>&adj, int seats){\\n        vis[node]=1;\\n        int count=1;\\n        for(auto it:adj[node]){\\n            if(!vis[it])\\n            count+=dfs(it,vis,adj,seats);\\n        }\\n        if(node!=0){\\n        ans+= ceil((double) count / seats);\\n\\n          }\\n          return count;\\n        \\n\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        vector<int>vis(roads.size()+1,0);\\n        vector<vector<int>>adj(roads.size()+1);\\n        for(auto it:roads){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        dfs(0,vis,adj,seats);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long ans=0;\\n    long long int dfs(int node, vector<int>&vis,vector<vector<int>>&adj, int seats){\\n        vis[node]=1;\\n        int count=1;\\n        for(auto it:adj[node]){\\n            if(!vis[it])\\n            count+=dfs(it,vis,adj,seats);\\n        }\\n        if(node!=0){\\n        ans+= ceil((double) count / seats);\\n\\n          }\\n          return count;\\n        \\n\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        vector<int>vis(roads.size()+1,0);\\n        vector<vector<int>>adj(roads.size()+1);\\n        for(auto it:roads){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        dfs(0,vis,adj,seats);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952372,
                "title": "javascript-linear-time-and-memory-beats-100-memory-and-100-speed",
                "content": "# Intuition\\nSometimes in problems like this, where you traverse a tree, I\\'ve realized that working outwards from the start tends to be a good approach.\\n\\n# Approach\\nThe recursion function finds out how many cars will be needed leaving from the capitol to the home cities, and adds that amount to the total (since the number of cars at each non-capital city equals the number of liters required).\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} roads\\n * @param {number} seats\\n * @return {number}\\n */\\nvar minimumFuelCost = function(roads, seats) {\\n        let nodes = []\\n        let n = roads.length+1\\nfor (let i = 0; i < n; i++){\\n    nodes[i] = []\\n}\\nfor (let i = 0; i < roads.length; i++){\\n    let u = roads[i][0]\\n    let v = roads[i][1]\\n    nodes[u].push(v)\\n    nodes[v].push(u)\\n}\\nlet res = 0\\n function recur(city, prev){\\n        let a = 1\\n        for (let i = 0; i < nodes[city].length; i++){\\n            if (nodes[city][i] != prev){\\n                a+=recur(nodes[city][i], city)\\n            }\\n        }\\n        \\n        res+=Math.ceil(a/seats)\\n        \\n        return a\\n    }\\n    \\n    for (let i = 0; i < nodes[0].length; i++){\\n        recur(nodes[0][i], 0, 1)\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} roads\\n * @param {number} seats\\n * @return {number}\\n */\\nvar minimumFuelCost = function(roads, seats) {\\n        let nodes = []\\n        let n = roads.length+1\\nfor (let i = 0; i < n; i++){\\n    nodes[i] = []\\n}\\nfor (let i = 0; i < roads.length; i++){\\n    let u = roads[i][0]\\n    let v = roads[i][1]\\n    nodes[u].push(v)\\n    nodes[v].push(u)\\n}\\nlet res = 0\\n function recur(city, prev){\\n        let a = 1\\n        for (let i = 0; i < nodes[city].length; i++){\\n            if (nodes[city][i] != prev){\\n                a+=recur(nodes[city][i], city)\\n            }\\n        }\\n        \\n        res+=Math.ceil(a/seats)\\n        \\n        return a\\n    }\\n    \\n    for (let i = 0; i < nodes[0].length; i++){\\n        recur(nodes[0][i], 0, 1)\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3907815,
                "title": "python-dfs",
                "content": "# Intuition\\n[Python]DFS\\n\\n# Approach\\nDFS\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n\\n- Space complexity:O(N)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        graph = {}\\n        for i, j in roads:\\n            if i not in graph:\\n                graph[i] = [j]\\n            else:\\n                graph[i].append(j)\\n            \\n            if j not in graph:\\n                graph[j] = [i]\\n            else:\\n                graph[j].append(i)\\n\\n        def dfs(current, previous):\\n            oil = 0\\n            totalPassengers = 1\\n            allDestinations = graph[current]\\n\\n            for destination in allDestinations:\\n                if destination == previous:\\n                    continue\\n                \\n                result = dfs(destination, current)\\n                oil = result[0] + oil\\n                totalPassengers = result[1] + totalPassengers\\n\\n            if current == 0:\\n                return [oil, totalPassengers]\\n\\n            if totalPassengers <= seats:\\n                oil = oil + 1\\n            else:\\n                extraPassengers = totalPassengers % seats\\n                totalRequiredCars = totalPassengers // seats\\n                oil = oil + totalRequiredCars\\n                if extraPassengers != 0:\\n                    oil = oil + 1\\n\\n            return [oil, totalPassengers]\\n        \\n        if len(graph) == 0:\\n            return 0\\n\\n        return dfs(0, -1)[0]\\n            \\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\\n        graph = {}\\n        for i, j in roads:\\n            if i not in graph:\\n                graph[i] = [j]\\n            else:\\n                graph[i].append(j)\\n            \\n            if j not in graph:\\n                graph[j] = [i]\\n            else:\\n                graph[j].append(i)\\n\\n        def dfs(current, previous):\\n            oil = 0\\n            totalPassengers = 1\\n            allDestinations = graph[current]\\n\\n            for destination in allDestinations:\\n                if destination == previous:\\n                    continue\\n                \\n                result = dfs(destination, current)\\n                oil = result[0] + oil\\n                totalPassengers = result[1] + totalPassengers\\n\\n            if current == 0:\\n                return [oil, totalPassengers]\\n\\n            if totalPassengers <= seats:\\n                oil = oil + 1\\n            else:\\n                extraPassengers = totalPassengers % seats\\n                totalRequiredCars = totalPassengers // seats\\n                oil = oil + totalRequiredCars\\n                if extraPassengers != 0:\\n                    oil = oil + 1\\n\\n            return [oil, totalPassengers]\\n        \\n        if len(graph) == 0:\\n            return 0\\n\\n        return dfs(0, -1)[0]\\n            \\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828336,
                "title": "c-dfs-solution-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n    long long ans;\\n    long long dfs(int src, int par,int seats){\\n        long long cnt = 1;\\n        for(int nbr: adj[src]){\\n            if(nbr!=par){\\n                long long val = dfs(nbr,src,seats);\\n                cnt+=val;\\n                ans+=(val/seats);\\n                ans+=((val%seats)>0);\\n            }\\n        }\\n        //return the size of the subtree rooted at src\\n        return cnt;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int N = roads.size()+1;\\n        \\n        //Populate adjacency Matrix\\n        adj = vector<vector<int>>(N);\\n        for(auto &e:roads){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        ans = 0;\\n        dfs(0,-1,seats);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n    long long ans;\\n    long long dfs(int src, int par,int seats){\\n        long long cnt = 1;\\n        for(int nbr: adj[src]){\\n            if(nbr!=par){\\n                long long val = dfs(nbr,src,seats);\\n                cnt+=val;\\n                ans+=(val/seats);\\n                ans+=((val%seats)>0);\\n            }\\n        }\\n        //return the size of the subtree rooted at src\\n        return cnt;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int N = roads.size()+1;\\n        \\n        //Populate adjacency Matrix\\n        adj = vector<vector<int>>(N);\\n        for(auto &e:roads){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        ans = 0;\\n        dfs(0,-1,seats);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773253,
                "title": "simple-dfs-on-n-ary-tree",
                "content": "# Intuition\\nWe can model this problem as simple N-ary tree dfs traversal problem. \\nDfs the tree from starting node 0, and each node add the cost in total cost. This cost can be calcuated as the amount of cars people required to reach from all the childeren nodes to that node. (we can work just with the number of cars because 1 unit distance for 1 car takes 1 unit cost)\\nAt each step we will calculate the minimum number of cars required to reach to its parent node. \\n\\n# Complexity\\n- Time complexity:\\nO(n) \\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    pair<int,int> dfs(int node, int par, vector<vector<int>> & adj, int & seats, long long & cost){\\n\\n        if(adj[node].size() == 0){\\n            return {0,0};\\n        }\\n\\n        if(adj[node].size() == 1 && adj[node][0] == par){\\n            return {1,1};\\n            // leaf node city will require only 1 unit cost with only 1 person\\n        }\\n\\n        int totalPeople = 1;\\n        // each city has its own executive\\n\\n        for(int i = 0; i < adj[node].size(); i++){\\n            if(adj[node][i] != par){\\n                pair<int,int> p = dfs(adj[node][i], node, adj, seats, cost);\\n                cost += p.second;\\n                // adding costs to reach this node from all the children cities\\n                \\n                totalPeople += p.first;\\n                // adding people coming in the city from the children cities\\n            }\\n        }\\n\\n        int minCarsNeeded = totalPeople/seats;\\n        if(totalNumbers % seats != 0){\\n            minCarsNeeded++;\\n        }\\n\\n        return {totalPeople, minCarsNeeded};\\n\\n    }\\n\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n = roads.size();\\n\\n        vector<vector<int>> adj(n+1);\\n\\n        for(int i = 0; i < n; i++){\\n            adj[roads[i][0]].push_back(roads[i][1]);\\n            adj[roads[i][1]].push_back(roads[i][0]);\\n        }\\n\\n        long long cost = 0;\\n        (void) dfs(0, -1, adj, seats, cost);    \\n        return cost;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    pair<int,int> dfs(int node, int par, vector<vector<int>> & adj, int & seats, long long & cost){\\n\\n        if(adj[node].size() == 0){\\n            return {0,0};\\n        }\\n\\n        if(adj[node].size() == 1 && adj[node][0] == par){\\n            return {1,1};\\n            // leaf node city will require only 1 unit cost with only 1 person\\n        }\\n\\n        int totalPeople = 1;\\n        // each city has its own executive\\n\\n        for(int i = 0; i < adj[node].size(); i++){\\n            if(adj[node][i] != par){\\n                pair<int,int> p = dfs(adj[node][i], node, adj, seats, cost);\\n                cost += p.second;\\n                // adding costs to reach this node from all the children cities\\n                \\n                totalPeople += p.first;\\n                // adding people coming in the city from the children cities\\n            }\\n        }\\n\\n        int minCarsNeeded = totalPeople/seats;\\n        if(totalNumbers % seats != 0){\\n            minCarsNeeded++;\\n        }\\n\\n        return {totalPeople, minCarsNeeded};\\n\\n    }\\n\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n = roads.size();\\n\\n        vector<vector<int>> adj(n+1);\\n\\n        for(int i = 0; i < n; i++){\\n            adj[roads[i][0]].push_back(roads[i][1]);\\n            adj[roads[i][1]].push_back(roads[i][0]);\\n        }\\n\\n        long long cost = 0;\\n        (void) dfs(0, -1, adj, seats, cost);    \\n        return cost;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765081,
                "title": "c-dfs-o-n-clean-and-simple-explained",
                "content": "# Approach\\n```0 node asks all its nei.s that how many people are coming from your side... so that to move from that nei. to 0 node.. we can calculate the fuel/Cars required to move on that one edge i.e. (nei to Zero)```\\n\\n``` Going in the similar fashion .... all the nodes ask its nei (not the parent) the no. of people coming from that nei. ```\\n\\n```Now number of people is nothing but... the no. of child nodes of node which can be calculated by DFS. ```\\n\\n\\n`Refer the code for better understanding`\\n# Code\\n```\\nclass Solution {\\n    long long ans = 0;\\n\\n    int dfs(int node,int par,int seats, vector<vector<int>>& adj){\\n\\n        int Totalchild = 0;\\n        for(int nei : adj[node]){\\n            if(nei==par) continue;\\n            int child = dfs(nei,node,seats,adj);\\n\\n            int fuel = (child/seats);\\n            if(child%seats) fuel++;\\n            ans += fuel;   \\n            Totalchild += child;\\n        }\\n\\n        return Totalchild+1;  //1+ to include itself\\n    }\\n\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n =roads.size()+1;\\n        vector<vector<int>> adj(n);\\n        for(auto it: roads){\\n            int u=it[0] , v=it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        dfs(0,-1,seats,adj);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```0 node asks all its nei.s that how many people are coming from your side... so that to move from that nei. to 0 node.. we can calculate the fuel/Cars required to move on that one edge i.e. (nei to Zero)```\n``` Going in the similar fashion .... all the nodes ask its nei (not the parent) the no. of people coming from that nei. ```\n```Now number of people is nothing but... the no. of child nodes of node which can be calculated by DFS. ```\n```\\nclass Solution {\\n    long long ans = 0;\\n\\n    int dfs(int node,int par,int seats, vector<vector<int>>& adj){\\n\\n        int Totalchild = 0;\\n        for(int nei : adj[node]){\\n            if(nei==par) continue;\\n            int child = dfs(nei,node,seats,adj);\\n\\n            int fuel = (child/seats);\\n            if(child%seats) fuel++;\\n            ans += fuel;   \\n            Totalchild += child;\\n        }\\n\\n        return Totalchild+1;  //1+ to include itself\\n    }\\n\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n =roads.size()+1;\\n        vector<vector<int>> adj(n);\\n        for(auto it: roads){\\n            int u=it[0] , v=it[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        dfs(0,-1,seats,adj);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751342,
                "title": "easy-solution-2-approach-fail-success",
                "content": "see second approach first then second to learn something new.\\n# Code\\n```\\n// class Solution {\\n// public:\\n//     long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n//         int n=roads.size();\\n//         unordered_map<int,vector<pair<int,int>>> adj;//u->[v,filled_Seat]\\n//         vector<int> indegree(n+1,0);\\n\\n//         for(auto &road:roads){\\n//             adj[road[0]].push_back({road[1],1});\\n//             adj[road[1]].push_back({road[0],1});\\n//             indegree[road[0]]++;\\n//             indegree[road[1]]++;\\n//         }\\n\\n//         queue<pair<int,int>> nodes;\\n//         for(int i=0;i<n+1;i++){\\n//             if(indegree[i]==1){\\n//                 nodes.push({i,1});//node,filled_Seat\\n//             }\\n//         }\\n        \\n//         long long fuel=0;\\n//         while(!nodes.empty()){\\n//             int sz=nodes.size();\\n//             while(sz--){\\n//                 auto node=nodes.front();\\n//                 nodes.pop();\\n//                 int filledSeat=node.second;\\n                \\n//                 if(node.first==0){break;}\\n//                 fuel+=ceil(filledSeat*1.0/seats);\\n\\n//                 for(auto &adjNode:adj[node.first]){\\n//                     // &adjNode and adjNode.second+=filledSeat; do not update the actual adj node in adj list so it will create problem in branch...need to seperate this filledseats\\n//                     indegree[adjNode.first]--;\\n//                     adjNode.second+=filledSeat;\\n                    \\n//                     if(indegree[adjNode.first]==1){\\n//                         nodes.push(adjNode);\\n//                     }\\n//                 }\\n//             }\\n//         }\\n//         return fuel;\\n//     }\\n// };\\n///////////////////\\nclass Solution {\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n=roads.size();\\n        unordered_map<int,vector<int>> adj;\\n        vector<int> indegree(n+1,0);\\n        vector<int> fseats(n+1,1);\\n\\n        for(auto &road:roads){\\n            adj[road[0]].push_back(road[1]);\\n            adj[road[1]].push_back(road[0]);\\n            indegree[road[0]]++;\\n            indegree[road[1]]++;\\n        }\\n\\n        queue<int> nodes;\\n        for(int i=0;i<n+1;i++){\\n            if(indegree[i]==1){\\n                nodes.push(i);//node,filled_Seat\\n            }\\n        }\\n        \\n        long long fuel=0;\\n        while(!nodes.empty()){\\n            int sz=nodes.size();\\n            while(sz--){\\n                auto node=nodes.front();\\n                nodes.pop();\\n                \\n                if(node==0){break;}\\n                fuel+=ceil(fseats[node]*1.0/seats);\\n\\n                for(auto &adjNode:adj[node]){\\n                    indegree[adjNode]--;\\n                    fseats[adjNode]+=fseats[node];\\n                    \\n                    if(indegree[adjNode]==1){\\n                        nodes.push(adjNode);\\n                    }\\n                }\\n            }\\n        }\\n        return fuel;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// class Solution {\\n// public:\\n//     long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n//         int n=roads.size();\\n//         unordered_map<int,vector<pair<int,int>>> adj;//u->[v,filled_Seat]\\n//         vector<int> indegree(n+1,0);\\n\\n//         for(auto &road:roads){\\n//             adj[road[0]].push_back({road[1],1});\\n//             adj[road[1]].push_back({road[0],1});\\n//             indegree[road[0]]++;\\n//             indegree[road[1]]++;\\n//         }\\n\\n//         queue<pair<int,int>> nodes;\\n//         for(int i=0;i<n+1;i++){\\n//             if(indegree[i]==1){\\n//                 nodes.push({i,1});//node,filled_Seat\\n//             }\\n//         }\\n        \\n//         long long fuel=0;\\n//         while(!nodes.empty()){\\n//             int sz=nodes.size();\\n//             while(sz--){\\n//                 auto node=nodes.front();\\n//                 nodes.pop();\\n//                 int filledSeat=node.second;\\n                \\n//                 if(node.first==0){break;}\\n//                 fuel+=ceil(filledSeat*1.0/seats);\\n\\n//                 for(auto &adjNode:adj[node.first]){\\n//                     // &adjNode and adjNode.second+=filledSeat; do not update the actual adj node in adj list so it will create problem in branch...need to seperate this filledseats\\n//                     indegree[adjNode.first]--;\\n//                     adjNode.second+=filledSeat;\\n                    \\n//                     if(indegree[adjNode.first]==1){\\n//                         nodes.push(adjNode);\\n//                     }\\n//                 }\\n//             }\\n//         }\\n//         return fuel;\\n//     }\\n// };\\n///////////////////\\nclass Solution {\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n=roads.size();\\n        unordered_map<int,vector<int>> adj;\\n        vector<int> indegree(n+1,0);\\n        vector<int> fseats(n+1,1);\\n\\n        for(auto &road:roads){\\n            adj[road[0]].push_back(road[1]);\\n            adj[road[1]].push_back(road[0]);\\n            indegree[road[0]]++;\\n            indegree[road[1]]++;\\n        }\\n\\n        queue<int> nodes;\\n        for(int i=0;i<n+1;i++){\\n            if(indegree[i]==1){\\n                nodes.push(i);//node,filled_Seat\\n            }\\n        }\\n        \\n        long long fuel=0;\\n        while(!nodes.empty()){\\n            int sz=nodes.size();\\n            while(sz--){\\n                auto node=nodes.front();\\n                nodes.pop();\\n                \\n                if(node==0){break;}\\n                fuel+=ceil(fseats[node]*1.0/seats);\\n\\n                for(auto &adjNode:adj[node]){\\n                    indegree[adjNode]--;\\n                    fseats[adjNode]+=fseats[node];\\n                    \\n                    if(indegree[adjNode]==1){\\n                        nodes.push(adjNode);\\n                    }\\n                }\\n            }\\n        }\\n        return fuel;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717640,
                "title": "very-easy-intuitive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// class Solution\\n// {\\n//     public:\\n//         long long dfs(vector<int> adj[], int seats, int &ans, int i)\\n//         {\\n//             int people = 1;\\n\\n//             for (auto it: adj[i])\\n//             {\\n//                 people += dfs(adj, seats, ans, it);\\n//             }\\n//             if (i != 0)\\n//             {\\n//                 ans += people / seats;\\n//                 if (people % seats != 0)\\n//                 {\\n//                     ans++;\\n//                 }\\n//             }\\n//             return people;\\n//         }\\n\\n//     long long minimumFuelCost(vector<vector < int>> &roads, int seats)\\n//     {\\n//         int n = roads.size() + 1;\\n//         vector<int> adj[n];\\n//         for (auto edge: roads)\\n//         {\\n//             adj[edge[0]].push_back(edge[1]);\\n//             adj[edge[1]].push_back(edge[0]);\\n//         }\\n//         int ans = 0;\\n//         int i = 0;\\n//         dfs(adj, seats, ans, i);\\n//         return ans;\\n//     }\\n// };\\n\\nclass Solution\\n{\\n    public:\\n        long long dfs(vector<int> adj[], int seats, long long &ans, int i, int parent)\\n        {\\n            int people = 1;\\n\\n            for (auto it: adj[i])\\n            {\\n                if (it != parent)\\n                {\\n                    people += dfs(adj, seats, ans, it, i);\\n                }\\n            }\\n\\n            if (i != 0)\\n            {\\n                ans += (people) / seats;\\n                if (people % seats != 0)\\n                {\\n                    ans++;\\n                }\\n            }\\n\\n            return people;\\n        }\\n\\n    long long minimumFuelCost(vector<vector < int>> &roads, int seats)\\n    {\\n        int n = roads.size() + 1;\\n        vector<int> adj[n];\\n\\n        for (auto edge: roads)\\n        {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        long long ans = 0;\\n        int i = 0;\\n        dfs(adj, seats, ans, i, -1);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n// class Solution\\n// {\\n//     public:\\n//         long long dfs(vector<int> adj[], int seats, int &ans, int i)\\n//         {\\n//             int people = 1;\\n\\n//             for (auto it: adj[i])\\n//             {\\n//                 people += dfs(adj, seats, ans, it);\\n//             }\\n//             if (i != 0)\\n//             {\\n//                 ans += people / seats;\\n//                 if (people % seats != 0)\\n//                 {\\n//                     ans++;\\n//                 }\\n//             }\\n//             return people;\\n//         }\\n\\n//     long long minimumFuelCost(vector<vector < int>> &roads, int seats)\\n//     {\\n//         int n = roads.size() + 1;\\n//         vector<int> adj[n];\\n//         for (auto edge: roads)\\n//         {\\n//             adj[edge[0]].push_back(edge[1]);\\n//             adj[edge[1]].push_back(edge[0]);\\n//         }\\n//         int ans = 0;\\n//         int i = 0;\\n//         dfs(adj, seats, ans, i);\\n//         return ans;\\n//     }\\n// };\\n\\nclass Solution\\n{\\n    public:\\n        long long dfs(vector<int> adj[], int seats, long long &ans, int i, int parent)\\n        {\\n            int people = 1;\\n\\n            for (auto it: adj[i])\\n            {\\n                if (it != parent)\\n                {\\n                    people += dfs(adj, seats, ans, it, i);\\n                }\\n            }\\n\\n            if (i != 0)\\n            {\\n                ans += (people) / seats;\\n                if (people % seats != 0)\\n                {\\n                    ans++;\\n                }\\n            }\\n\\n            return people;\\n        }\\n\\n    long long minimumFuelCost(vector<vector < int>> &roads, int seats)\\n    {\\n        int n = roads.size() + 1;\\n        vector<int> adj[n];\\n\\n        for (auto edge: roads)\\n        {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        long long ans = 0;\\n        int i = 0;\\n        dfs(adj, seats, ans, i, -1);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698332,
                "title": "dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long ans = 0;\\n\\n    long long dfs(int src , vector<vector<int>>& adj , vector<int>& vis , int seats){\\n        vis[src] = 1;\\n\\n        long long count = 1;\\n        for (auto neighbour : adj[src]){\\n            if (!vis[neighbour]){\\n                count += dfs(neighbour , adj , vis , seats);\\n            }\\n        }\\n        long long x = count/seats;\\n\\n        if (count%seats)\\n            x++;\\n\\n        if (src != 0)\\n            ans += x;\\n\\n        return count;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        vector<vector<int>> adj(roads.size()+1);\\n\\n        for (int i=0 ; i<roads.size() ; i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }    \\n\\n        vector<int> vis(adj.size() , 0);\\n        dfs(0 , adj , vis , seats);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long ans = 0;\\n\\n    long long dfs(int src , vector<vector<int>>& adj , vector<int>& vis , int seats){\\n        vis[src] = 1;\\n\\n        long long count = 1;\\n        for (auto neighbour : adj[src]){\\n            if (!vis[neighbour]){\\n                count += dfs(neighbour , adj , vis , seats);\\n            }\\n        }\\n        long long x = count/seats;\\n\\n        if (count%seats)\\n            x++;\\n\\n        if (src != 0)\\n            ans += x;\\n\\n        return count;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        vector<vector<int>> adj(roads.size()+1);\\n\\n        for (int i=0 ; i<roads.size() ; i++){\\n            int u = roads[i][0];\\n            int v = roads[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }    \\n\\n        vector<int> vis(adj.size() , 0);\\n        dfs(0 , adj , vis , seats);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687762,
                "title": "using-bfs-dfs-together-easy-approach-o-e-v",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Idea behind the approach is to calculate the minimum distance(cost) of each city from captial city using bfs, and doing a dfs, once we complete the traversal of one child we count it and add one distance to the cost, at any city if we have more or equal childs than seats, then we assume that seats will directly take the car from that city to captial city and the cost we have already calculated in BFS traversal added to the cost, and the remaining will travel in the earlier fashion moving one step towards captial and calculating the cost and childs\\nHere Childs means Passenger of the Car. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApplied BFS, using node and cost as parameter and calulating the minimum distance for each city\\nApplied DFS traversal to calulate the cost and child at each city and calulating cost greedly at each city \\n\\n# Complexity\\n- Time complexity: O(E + V)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(E + V), For Adjacency list, and queue for BFS and DFS\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    pair<long long, long long> solve(vector<int> adj[], int node, int parent, vector<int> &distanceFromCaptial, int seats){\\n        long long child_cost = 0; \\n        long long child = 0;\\n        for(auto it : adj[node]){\\n            if(it != parent){\\n                auto temp = solve(adj, it, node, distanceFromCaptial, seats);\\n                child += temp.first + 1;\\n                child_cost += temp.second + 1;\\n                if(child >= seats){\\n                    child = child%seats;\\n                    child_cost += distanceFromCaptial[node];\\n                }\\n            }\\n        }\\n        \\n        return {child, child_cost};\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        // first we need to find the distance of every node from 0, like minimum distance, \\n        // Secondly we have to do the dfs and then we return {number of Passenger, number of distance consumed} and then sum these at each node and then return to the parent,\\n        int n =  roads.size();\\n        vector<int> adj[n+1];\\n        for(int i = 0; i < n; i++){\\n            adj[roads[i][0]].push_back(roads[i][1]);\\n            adj[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        vector<int> distanceFromCaptial(n+1, 1e9);\\n        queue<pair<int,pair<int,int>>> que; \\n        que.push({0,{0, -1}});\\n        distanceFromCaptial[0] = 0;\\n        while(!que.empty()){\\n            auto top = que.front();\\n            int node = top.first;\\n            int dist = top.second.first;\\n            int parent = top.second.second;\\n            que.pop();\\n            for(auto it : adj[node]){\\n                if(it != parent){\\n                    distanceFromCaptial[it] = min(distanceFromCaptial[it], dist + 1);\\n                    que.push({it, {dist + 1, node}});\\n                }\\n            }\\n        }\\n        // so distanceFromCaptial contains distance from captial \\n        auto temp = solve(adj, 0, -1, distanceFromCaptial, seats );\\n        // cost += temp.second;\\n        // for(auto it : distanceFromCaptial){\\n        //     cout << it << endl;\\n        // }\\n        return temp.second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<long long, long long> solve(vector<int> adj[], int node, int parent, vector<int> &distanceFromCaptial, int seats){\\n        long long child_cost = 0; \\n        long long child = 0;\\n        for(auto it : adj[node]){\\n            if(it != parent){\\n                auto temp = solve(adj, it, node, distanceFromCaptial, seats);\\n                child += temp.first + 1;\\n                child_cost += temp.second + 1;\\n                if(child >= seats){\\n                    child = child%seats;\\n                    child_cost += distanceFromCaptial[node];\\n                }\\n            }\\n        }\\n        \\n        return {child, child_cost};\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        // first we need to find the distance of every node from 0, like minimum distance, \\n        // Secondly we have to do the dfs and then we return {number of Passenger, number of distance consumed} and then sum these at each node and then return to the parent,\\n        int n =  roads.size();\\n        vector<int> adj[n+1];\\n        for(int i = 0; i < n; i++){\\n            adj[roads[i][0]].push_back(roads[i][1]);\\n            adj[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        vector<int> distanceFromCaptial(n+1, 1e9);\\n        queue<pair<int,pair<int,int>>> que; \\n        que.push({0,{0, -1}});\\n        distanceFromCaptial[0] = 0;\\n        while(!que.empty()){\\n            auto top = que.front();\\n            int node = top.first;\\n            int dist = top.second.first;\\n            int parent = top.second.second;\\n            que.pop();\\n            for(auto it : adj[node]){\\n                if(it != parent){\\n                    distanceFromCaptial[it] = min(distanceFromCaptial[it], dist + 1);\\n                    que.push({it, {dist + 1, node}});\\n                }\\n            }\\n        }\\n        // so distanceFromCaptial contains distance from captial \\n        auto temp = solve(adj, 0, -1, distanceFromCaptial, seats );\\n        // cost += temp.second;\\n        // for(auto it : distanceFromCaptial){\\n        //     cout << it << endl;\\n        // }\\n        return temp.second;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3687664,
                "title": "readable-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    long long fuel = 0;\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) \\n    {\\n        if(roads.empty() == true) return 0;\\n        int max = 0;\\n        for(auto i = 0; i < roads.size(); i++)\\n        {\\n            auto &road = roads[i];\\n            if(road[0] > max)\\n            {\\n                max = road[0];\\n            }\\n            if(road[1] > max)\\n            {\\n                max = road[1];\\n            }\\n        }\\n        max++;\\n        auto graph = create_graph(roads, max);\\n        roads.clear();\\n        for(auto &route : graph[0])\\n        {\\n            visit(graph, seats, route);\\n        }\\n        return fuel;\\n\\n    }\\n    vector<vector<int>> create_graph(vector<vector<int>> &roads, int max)\\n    {\\n        vector<vector<int>> result(max);\\n        for(auto &road : roads)\\n        {\\n            result[road[0]].push_back(road[1]);\\n            result[road[1]].push_back(road[0]);\\n        }\\n        return result;\\n    }\\n    long long visit(\\n        vector<vector<int>> &graph\\n        , int seats\\n        , int idx\\n        , int prev_idx = 0\\n    )\\n    {\\n        \\n        long long total = 1;\\n\\n        for(auto &route : graph[idx])\\n        {\\n            if(route != prev_idx)\\n            {\\n                total += visit(graph, seats, route, idx);\\n            }\\n        }\\n        if( seats >= total)\\n        {\\n            fuel++;\\n        }\\n        else if(total % seats == 0)\\n        {\\n            fuel += total / seats;\\n        }\\n        else if(total % seats != 0)\\n        {\\n            fuel += total / seats + 1;\\n        }\\n\\n        return total;\\n\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    long long fuel = 0;\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) \\n    {\\n        if(roads.empty() == true) return 0;\\n        int max = 0;\\n        for(auto i = 0; i < roads.size(); i++)\\n        {\\n            auto &road = roads[i];\\n            if(road[0] > max)\\n            {\\n                max = road[0];\\n            }\\n            if(road[1] > max)\\n            {\\n                max = road[1];\\n            }\\n        }\\n        max++;\\n        auto graph = create_graph(roads, max);\\n        roads.clear();\\n        for(auto &route : graph[0])\\n        {\\n            visit(graph, seats, route);\\n        }\\n        return fuel;\\n\\n    }\\n    vector<vector<int>> create_graph(vector<vector<int>> &roads, int max)\\n    {\\n        vector<vector<int>> result(max);\\n        for(auto &road : roads)\\n        {\\n            result[road[0]].push_back(road[1]);\\n            result[road[1]].push_back(road[0]);\\n        }\\n        return result;\\n    }\\n    long long visit(\\n        vector<vector<int>> &graph\\n        , int seats\\n        , int idx\\n        , int prev_idx = 0\\n    )\\n    {\\n        \\n        long long total = 1;\\n\\n        for(auto &route : graph[idx])\\n        {\\n            if(route != prev_idx)\\n            {\\n                total += visit(graph, seats, route, idx);\\n            }\\n        }\\n        if( seats >= total)\\n        {\\n            fuel++;\\n        }\\n        else if(total % seats == 0)\\n        {\\n            fuel += total / seats;\\n        }\\n        else if(total % seats != 0)\\n        {\\n            fuel += total / seats + 1;\\n        }\\n\\n        return total;\\n\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606633,
                "title": "c-bfs",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    ll minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        ll m = roads.size();\\n        ll n = m + 1;\\n        vector<ll> degree(n , 0);\\n        vector<ll> adj[n];\\n        for(ll i=0 ; i<m ; i++) {\\n            degree[roads[i][0]]++;\\n            degree[roads[i][1]]++;\\n            adj[roads[i][0]].push_back(roads[i][1]);\\n            adj[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        queue<ll> q;\\n        for(ll i=1 ; i<n ; i++) {\\n            if(degree[i] == 1) {\\n                q.push(i);\\n            }\\n        }\\n        vector<ll> rep(n , 1) , cars(n , 1) , ans(n , 0);\\n        while(!q.empty()) {\\n            ll u = q.front();\\n            q.pop();\\n            for(ll v : adj[u]) {\\n                degree[v]--;\\n                rep[v] += rep[u];\\n                cars[v] = (rep[v] / seats) + (rep[v] % seats != 0);\\n                ans[v] = ans[v] + ans[u] + cars[u];\\n                if(degree[v] == 1 && v != 0) {    \\n                    q.push(v);\\n                }\\n            }\\n        }\\n        return ans[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    ll minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        ll m = roads.size();\\n        ll n = m + 1;\\n        vector<ll> degree(n , 0);\\n        vector<ll> adj[n];\\n        for(ll i=0 ; i<m ; i++) {\\n            degree[roads[i][0]]++;\\n            degree[roads[i][1]]++;\\n            adj[roads[i][0]].push_back(roads[i][1]);\\n            adj[roads[i][1]].push_back(roads[i][0]);\\n        }\\n        queue<ll> q;\\n        for(ll i=1 ; i<n ; i++) {\\n            if(degree[i] == 1) {\\n                q.push(i);\\n            }\\n        }\\n        vector<ll> rep(n , 1) , cars(n , 1) , ans(n , 0);\\n        while(!q.empty()) {\\n            ll u = q.front();\\n            q.pop();\\n            for(ll v : adj[u]) {\\n                degree[v]--;\\n                rep[v] += rep[u];\\n                cars[v] = (rep[v] / seats) + (rep[v] % seats != 0);\\n                ans[v] = ans[v] + ans[u] + cars[u];\\n                if(degree[v] == 1 && v != 0) {    \\n                    q.push(v);\\n                }\\n            }\\n        }\\n        return ans[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568345,
                "title": "easy-to-understand-intuitive-c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(edges)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(vertices)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MinimumFuelCost(int[][] roads, int seats) {\\n        var adjacencyList = new Dictionary<int, List<int>>();\\n        foreach (var road in roads)\\n        {\\n            if (!adjacencyList.ContainsKey(road[0])) adjacencyList.Add(road[0], new List<int>());\\n            adjacencyList[road[0]].Add(road[1]);\\n\\n            if (!adjacencyList.ContainsKey(road[1])) adjacencyList.Add(road[1], new List<int>());\\n            adjacencyList[road[1]].Add(road[0]);\\n        }\\n\\n        var (people, cost) = MinimumFuelCost(adjacencyList, seats, 0, -1);\\n\\n        return cost;\\n    }\\n\\n    private (long, long) MinimumFuelCost(Dictionary<int, List<int>> adjacencyList, int seats, int curCity, int parent)\\n    {\\n        if (!adjacencyList.ContainsKey(curCity)) return (1, 0);\\n\\n        (long, long) result = (1, 0);\\n        foreach (var neighbor in adjacencyList[curCity])\\n        {\\n            if (neighbor == parent) continue;\\n\\n            var (peopleInNeighbor, fueldCostToReachNeighbor) = MinimumFuelCost(adjacencyList, seats, neighbor, curCity);\\n\\n            result.Item1 += peopleInNeighbor;\\n            result.Item2 += fueldCostToReachNeighbor;\\n            // Time to transfer all people from neighbor to current node\\n            result.Item2 += peopleInNeighbor % seats == 0 ? peopleInNeighbor / seats : (peopleInNeighbor / seats) + 1;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\npublic class Solution {\\n    public long MinimumFuelCost(int[][] roads, int seats) {\\n        var adjacencyList = new Dictionary<int, List<int>>();\\n        foreach (var road in roads)\\n        {\\n            if (!adjacencyList.ContainsKey(road[0])) adjacencyList.Add(road[0], new List<int>());\\n            adjacencyList[road[0]].Add(road[1]);\\n\\n            if (!adjacencyList.ContainsKey(road[1])) adjacencyList.Add(road[1], new List<int>());\\n            adjacencyList[road[1]].Add(road[0]);\\n        }\\n\\n        var (people, cost) = MinimumFuelCost(adjacencyList, seats, 0, -1);\\n\\n        return cost;\\n    }\\n\\n    private (long, long) MinimumFuelCost(Dictionary<int, List<int>> adjacencyList, int seats, int curCity, int parent)\\n    {\\n        if (!adjacencyList.ContainsKey(curCity)) return (1, 0);\\n\\n        (long, long) result = (1, 0);\\n        foreach (var neighbor in adjacencyList[curCity])\\n        {\\n            if (neighbor == parent) continue;\\n\\n            var (peopleInNeighbor, fueldCostToReachNeighbor) = MinimumFuelCost(adjacencyList, seats, neighbor, curCity);\\n\\n            result.Item1 += peopleInNeighbor;\\n            result.Item2 += fueldCostToReachNeighbor;\\n            // Time to transfer all people from neighbor to current node\\n            result.Item2 += peopleInNeighbor % seats == 0 ? peopleInNeighbor / seats : (peopleInNeighbor / seats) + 1;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561823,
                "title": "bfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void countchild(int index, vector<vector<int>> &graph, vector<int> &child)\\n    {\\n        child[index]=1;\\n\\n        for(auto &x: graph[index])\\n        {\\n            if(child[x]==0)\\n            {\\n                countchild(x,graph,child);\\n                child[index]+=child[x];\\n            }\\n        }\\n\\n        return;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n=roads.size()+1;\\n\\n        vector<vector<int>> graph(n);\\n\\n        for(int i=0;i<n-1;i++)\\n        {\\n            graph[roads[i][0]].push_back(roads[i][1]);\\n            graph[roads[i][1]].push_back(roads[i][0]);\\n        }\\n\\n        vector<int> child(n,0),vis(n,0);\\n\\n        countchild(0,graph,child);\\n\\n        queue<int> q;\\n        q.push(0);\\n        vis[0]=1;\\n\\n        long long minFuel = 0;\\n\\n        while(!q.empty())\\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            for(auto &x: graph[curr])\\n            {\\n                if(vis[x]==1)\\n                    continue;\\n                int cnt = child[x];\\n                minFuel+=cnt/seats;\\n\\n                if(cnt%seats)\\n                    minFuel++;\\n\\n                q.push(x);\\n                vis[x]=1;\\n            }\\n        }\\n\\n        return minFuel;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void countchild(int index, vector<vector<int>> &graph, vector<int> &child)\\n    {\\n        child[index]=1;\\n\\n        for(auto &x: graph[index])\\n        {\\n            if(child[x]==0)\\n            {\\n                countchild(x,graph,child);\\n                child[index]+=child[x];\\n            }\\n        }\\n\\n        return;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n=roads.size()+1;\\n\\n        vector<vector<int>> graph(n);\\n\\n        for(int i=0;i<n-1;i++)\\n        {\\n            graph[roads[i][0]].push_back(roads[i][1]);\\n            graph[roads[i][1]].push_back(roads[i][0]);\\n        }\\n\\n        vector<int> child(n,0),vis(n,0);\\n\\n        countchild(0,graph,child);\\n\\n        queue<int> q;\\n        q.push(0);\\n        vis[0]=1;\\n\\n        long long minFuel = 0;\\n\\n        while(!q.empty())\\n        {\\n            int curr = q.front();\\n            q.pop();\\n\\n            for(auto &x: graph[curr])\\n            {\\n                if(vis[x]==1)\\n                    continue;\\n                int cnt = child[x];\\n                minFuel+=cnt/seats;\\n\\n                if(cnt%seats)\\n                    minFuel++;\\n\\n                q.push(x);\\n                vis[x]=1;\\n            }\\n        }\\n\\n        return minFuel;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555993,
                "title": "swift-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    func minimumFuelCost(_ roads: [[Int]], _ seats: Int) -> Int {\\n        var edges = roads.reduce(into: Array(repeating: [Int](), count: roads.count + 1)) {\\n            $0[$1[0]].append($1[1])\\n            $0[$1[1]].append($1[0])\\n        }\\n\\n        var peaks = Array(repeating: (false, 1), count: roads.count + 1)\\n        var result = 0\\n\\n        var queue: [Int] = edges.enumerated().compactMap { (index, connections) in\\n            if connections.count == 1 && index != 0 { return index }\\n            return nil\\n        }\\n\\n        while !queue.isEmpty {\\n            let vertix = queue.removeFirst()\\n            let nextElement = edges[vertix].filter { !peaks[$0].0 }\\n\\n            if nextElement.count == 1 && !peaks[vertix].0 {\\n                result += peaks[vertix].1 % seats == 0 ? peaks[vertix].1 / seats : peaks[vertix].1 / seats + 1\\n\\n                if nextElement[0] == 0 {\\n                    peaks[vertix].0 = true\\n                    continue \\n                } else {\\n                    peaks[nextElement[0]].1 += peaks[vertix].1\\n                    peaks[vertix].0 = true\\n\\n                    queue.append(nextElement[0])\\n                }\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumFuelCost(_ roads: [[Int]], _ seats: Int) -> Int {\\n        var edges = roads.reduce(into: Array(repeating: [Int](), count: roads.count + 1)) {\\n            $0[$1[0]].append($1[1])\\n            $0[$1[1]].append($1[0])\\n        }\\n\\n        var peaks = Array(repeating: (false, 1), count: roads.count + 1)\\n        var result = 0\\n\\n        var queue: [Int] = edges.enumerated().compactMap { (index, connections) in\\n            if connections.count == 1 && index != 0 { return index }\\n            return nil\\n        }\\n\\n        while !queue.isEmpty {\\n            let vertix = queue.removeFirst()\\n            let nextElement = edges[vertix].filter { !peaks[$0].0 }\\n\\n            if nextElement.count == 1 && !peaks[vertix].0 {\\n                result += peaks[vertix].1 % seats == 0 ? peaks[vertix].1 / seats : peaks[vertix].1 / seats + 1\\n\\n                if nextElement[0] == 0 {\\n                    peaks[vertix].0 = true\\n                    continue \\n                } else {\\n                    peaks[nextElement[0]].1 += peaks[vertix].1\\n                    peaks[vertix].0 = true\\n\\n                    queue.append(nextElement[0])\\n                }\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555982,
                "title": "simple-and-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> edges;\\n    vector<bool> visited;\\n    long long ans;\\n\\n    int dfs(int current, int s){\\n        int count=1;\\n        visited[current]=true;\\n\\n\\n        for(int i=0;i<edges[current].size();i++)\\n        {\\n            if(!visited[edges[current][i]])\\n               count+= dfs(edges[current][i],s);\\n        }\\n        if(current!=0) ans+=(count+s-1)/s; \\n        return count;\\n\\n\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n= roads.size();\\n        edges.resize(n+1);\\n        visited.resize(n+1);\\n\\n        for(auto x: roads)\\n        {\\n            edges[x[0]].push_back(x[1]);\\n            edges[x[1]].push_back(x[0]);\\n        }\\n\\n        if(!roads.empty())dfs(0,seats);\\n        return ans;\\n\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> edges;\\n    vector<bool> visited;\\n    long long ans;\\n\\n    int dfs(int current, int s){\\n        int count=1;\\n        visited[current]=true;\\n\\n\\n        for(int i=0;i<edges[current].size();i++)\\n        {\\n            if(!visited[edges[current][i]])\\n               count+= dfs(edges[current][i],s);\\n        }\\n        if(current!=0) ans+=(count+s-1)/s; \\n        return count;\\n\\n\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n= roads.size();\\n        edges.resize(n+1);\\n        visited.resize(n+1);\\n\\n        for(auto x: roads)\\n        {\\n            edges[x[0]].push_back(x[1]);\\n            edges[x[1]].push_back(x[0]);\\n        }\\n\\n        if(!roads.empty())dfs(0,seats);\\n        return ans;\\n\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546530,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n  def minimumFuelCost(roads: Array[Array[Int]], seats: Int): Long = {\\n    import scala.collection.mutable.{Map, ListBuffer}\\n    val adjacent = Map.empty[Int, ListBuffer[Int]]\\n    for (Array(a, b) <- roads) {\\n      adjacent.getOrElseUpdate(a, new ListBuffer[Int]) += b\\n      adjacent.getOrElseUpdate(b, new ListBuffer[Int]) += a\\n    }\\n    def dfs(node: Int, parent: Int, representatives: Long = 1): (Long, Long) = {\\n      adjacent.get(node) match {\\n        case Some(neighbors) =>\\n          val res = (for {neighbor <- neighbors if neighbor != parent} yield dfs(neighbor, node))\\n          val t1 = res.map(_._1).sum + representatives\\n          if (node != 0) (t1, (t1.toDouble / seats).ceil.toLong + res.map(_._2).sum) else (t1, res.map(_._2).sum)\\n        case None => (1, 0)\\n      }\\n    }\\n    dfs(0, -1)._2\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def minimumFuelCost(roads: Array[Array[Int]], seats: Int): Long = {\\n    import scala.collection.mutable.{Map, ListBuffer}\\n    val adjacent = Map.empty[Int, ListBuffer[Int]]\\n    for (Array(a, b) <- roads) {\\n      adjacent.getOrElseUpdate(a, new ListBuffer[Int]) += b\\n      adjacent.getOrElseUpdate(b, new ListBuffer[Int]) += a\\n    }\\n    def dfs(node: Int, parent: Int, representatives: Long = 1): (Long, Long) = {\\n      adjacent.get(node) match {\\n        case Some(neighbors) =>\\n          val res = (for {neighbor <- neighbors if neighbor != parent} yield dfs(neighbor, node))\\n          val t1 = res.map(_._1).sum + representatives\\n          if (node != 0) (t1, (t1.toDouble / seats).ceil.toLong + res.map(_._2).sum) else (t1, res.map(_._2).sum)\\n        case None => (1, 0)\\n      }\\n    }\\n    dfs(0, -1)._2\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3538573,
                "title": "c-dfs-clean-and-easy-code-graph",
                "content": "# Approach\\nFirst Count subtree size of each vertex.\\nNext step by step move toward sourch.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n=roads.size();\\n        vector<int>graph[n+5];\\n        for(int i=0;i<n;i++)\\n        {\\n            int u=roads[i][0];\\n            int v=roads[i][1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        int vis[n+5];\\n        long long subtsize[n+5];\\n        for(int i=0;i<=n;i++)\\n        {\\n            vis[i]=0;\\n            subtsize[i]=0;\\n        }\\n        dfs(graph,vis,subtsize,0);\\n        long long ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n           ans+=(subtsize[i]+seats-1)/seats;\\n        }\\n        return ans;\\n    }\\n    void dfs(vector<int>graph[],int vis[],long long subtsize[],int start){\\n        vis[start]=1;\\n        subtsize[start]+=1;\\n        for(auto child:graph[start])\\n        {\\n            if(vis[child])continue;\\n            dfs(graph,vis,subtsize,child);\\n            subtsize[start]+=subtsize[child];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        int n=roads.size();\\n        vector<int>graph[n+5];\\n        for(int i=0;i<n;i++)\\n        {\\n            int u=roads[i][0];\\n            int v=roads[i][1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        int vis[n+5];\\n        long long subtsize[n+5];\\n        for(int i=0;i<=n;i++)\\n        {\\n            vis[i]=0;\\n            subtsize[i]=0;\\n        }\\n        dfs(graph,vis,subtsize,0);\\n        long long ans=0;\\n        for(int i=1;i<=n;i++)\\n        {\\n           ans+=(subtsize[i]+seats-1)/seats;\\n        }\\n        return ans;\\n    }\\n    void dfs(vector<int>graph[],int vis[],long long subtsize[],int start){\\n        vis[start]=1;\\n        subtsize[start]+=1;\\n        for(auto child:graph[start])\\n        {\\n            if(vis[child])continue;\\n            dfs(graph,vis,subtsize,child);\\n            subtsize[start]+=subtsize[child];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492362,
                "title": "clean-c-dfs",
                "content": "```\\nclass Solution {\\n    vector<int>adj[100001];\\n    int vis[100001];\\n    long long tot=0,seat;\\n\\n    int dfs(int pa){\\n         int c=1;\\n        vis[pa]=1;\\n        \\n        for(auto ch:adj[pa]){\\n            if(vis[ch]) continue;\\n            int subtree=dfs(ch);\\n          \\n            tot+=ceil((subtree*1.0)/seat);\\n            c+=subtree;\\n         \\n        }\\n          \\n        return c;\\n    }\\n        \\n    \\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& r, int seats) {\\n     int n=r.size()+1;\\n        seat=seats;\\n        \\n        for(auto i:r)adj[i[0]].push_back(i[1]),adj[i[1]].push_back(i[0]);\\n      \\n        dfs(0);\\n        return tot;\\n    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int>adj[100001];\\n    int vis[100001];\\n    long long tot=0,seat;\\n\\n    int dfs(int pa){\\n         int c=1;\\n        vis[pa]=1;\\n        \\n        for(auto ch:adj[pa]){\\n            if(vis[ch]) continue;\\n            int subtree=dfs(ch);\\n          \\n            tot+=ceil((subtree*1.0)/seat);\\n            c+=subtree;\\n         \\n        }\\n          \\n        return c;\\n    }\\n        \\n    \\npublic:\\n    long long minimumFuelCost(vector<vector<int>>& r, int seats) {\\n     int n=r.size()+1;\\n        seat=seats;\\n        \\n        for(auto i:r)adj[i[0]].push_back(i[1]),adj[i[1]].push_back(i[0]);\\n      \\n        dfs(0);\\n        return tot;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1797268,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1797260,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1797839,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1797279,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1797273,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1797244,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1798114,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1797378,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1798048,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1797267,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1797268,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1797260,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1797839,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1797279,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1797273,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1797244,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1798114,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1797378,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1798048,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1797267,
                "content": [
                    {
                        "username": "sarpalmadhav",
                        "content": "What\\'s the point of engineers grinding on leetcode if the representatives can\\'t even use some technology?? Cancel the physical meeting and have a remote one. **Zero**, Zero is the only correct answer. Save Fuel, Save Time, Save Environment!!"
                    },
                    {
                        "username": "santanusen",
                        "content": "Then think of each edge being a fiber link and being charged based on bandwidth usage slabs."
                    },
                    {
                        "username": "MoAusaf",
                        "content": "[@AlecLC](/AlecLC) dang, solved a NP hard in 3 Lines, the next knuth, glad to witness this xD"
                    },
                    {
                        "username": "Arpit_Patel_07",
                        "content": "[@AlecLC](/AlecLC)  and it is optimum as well..!"
                    },
                    {
                        "username": "AlecLC",
                        "content": "I think Mr. Sarpalmadhav just figured out the NP Easy answer to Travelling Salesman!!"
                    },
                    {
                        "username": "frederyc",
                        "content": "Medium my a$$"
                    },
                    {
                        "username": "sepac",
                        "content": "The hardest part is just conceptual. The actual implementation is basically a typical graph problem."
                    },
                    {
                        "username": "YYANN",
                        "content": "[@noob-pika](/noob-pika) UF ftw"
                    },
                    {
                        "username": "Vishal_Nemo",
                        "content": "[@noob-pika](/noob-pika) bruh"
                    },
                    {
                        "username": "noob-pika",
                        "content": "I know it should be easy right?"
                    },
                    {
                        "username": "imprayas12",
                        "content": "No meeting, everyone was laid off."
                    },
                    {
                        "username": "astroash",
                        "content": "too soon xd"
                    },
                    {
                        "username": "jssyc13",
                        "content": "I wake in the morning and I step outside\\nAnd I take a deep breath and open leetcode daily challenge\\nAnd I scream from the top of my lungs\\n\\u201CWhat\\u2019s going on?\\u201D"
                    },
                    {
                        "username": "DexterHines",
                        "content": "This should be hard lmao, and the guy who came out with this question should be fired and banned from ever contributing to any company\\'s question sheet."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Lmao I agree"
                    },
                    {
                        "username": "nat1902",
                        "content": "lol :))))"
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Let me build a solar car and then the answer to this question will be 0 for all cases"
                    },
                    {
                        "username": "_SID_",
                        "content": "lol :D"
                    },
                    {
                        "username": "greeny__fly_",
                        "content": "lolll"
                    },
                    {
                        "username": "SilentKillerOP",
                        "content": "[@aeroabrar_31](/aeroabrar_31) lets go for solar+lunar car then\\n"
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "what if the meeting was during the night times ? \\uD83D\\uDE02"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "That\\'s so funny a car with 10e5 seats ;)"
                    },
                    {
                        "username": "sepac",
                        "content": "If this problem context takes place in 3023, car could be an acronym for a spacecraft transporting human civilization from an Earth shattered by an asteroid"
                    },
                    {
                        "username": "thisannie",
                        "content": "seems like I know nothing about graph :("
                    },
                    {
                        "username": "shivam1317",
                        "content": "This might help \\n ![tip](https://cdn.discordapp.com/attachments/833787171130834951/1074273710233628672/image.png)"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "This should be upvoted, thanks.\n\nMore clarification - So unless the car is not full, it can add members and proceed to parent node with cost 1. At any point if we have members > seats, an extra car would be required. So the idea is to go to leaf node and start traversing back by taking all the members one by one and calculating cars on the way. The cost at any road would be (total members/maxSeat)"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Hint: The fact that there is exactly `n - 1` roads means that there\\'s only one path to a given node from 0"
                    },
                    {
                        "username": "Hidden_Line",
                        "content": "Yeah, as it\\'s a tree."
                    },
                    {
                        "username": "charonme",
                        "content": "yes that\\'s true for all pairs of nodes since it\\'s guaranteed it\\'s a tree, we don\\'t even need to look at the number of roads"
                    }
                ]
            },
            {
                "id": 1797989,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "everyone except me finding this question easy, why it is hard for me\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I Found this one more difficult than Shortest Path with Alternating Colors"
                    },
                    {
                        "username": "yaojintham",
                        "content": "That is BFS. This is DFS Post-Order Processing. Very different."
                    },
                    {
                        "username": "KhacLong",
                        "content": "this problem is quite easy with basic dfs and a little math"
                    },
                    {
                        "username": "DanielGindi",
                        "content": "Easy, but then TLE"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "Type casting to float `ceil((float)reps/seats)` is giving wrong answer where as to double `ceil((double)reps/seats)` is giving AC. Why is this happening?"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "thank you very much for your tip\\n"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Learned a new thing today!\\nIf you submit the same answer two three times it gives you 100%faster results"
                    },
                    {
                        "username": "jbochi",
                        "content": "When I first read the problem, I missed that all cars had the same amount of seats, and couldn\\'t think of an efficient algorithm. I tried to frame it as max flow / min cost, but failed. The problem is a lot simpler because (*spoiler* / *hint*) representatives should always use as little cars as needed for each road.\\n\\nIs there a polynomial solution if the number of seats is not fixed or is it NP-Hard?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "If the number of seats increases uniformly with distance from capital, then the greedy algo (poly) still works.  In more complicated scenarios where a large bus needs to drive the same routes multiple times, it will probably enter NP hard territory."
                    },
                    {
                        "username": "Jaiff",
                        "content": "yes, it would be NP-hard in that case."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![2477-minimum-fuel-cost-to-report-to-capital.png](https://assets.leetcode.com/users/images/05921657-c5a1-4e67-a7b8-2ca6818191b3_1676171358.7216883.png)\n\n# <span style='color:green'>Implementation</span>\n```\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adj = defaultdict(set)\n        self.ans = 0\n        visited = {0}\n        for a, b in roads:\n            adj[a].add(b)\n            adj[b].add(a)\n\n        def dfs(node):\n            reps = 1\n            if node not in adj:\n                return reps\n\n            for child in adj[node]:\n                if child not in visited:\n                    visited.add(child)\n                    reps += dfs(child)\n\n            # calculate fuel required to reach this node\n            # no fuel required to reach node 0\n            if node:\n                self.ans += math.ceil(reps / seats)\n\n            return reps\n\n        dfs(0)\n        return self.ans\n```"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@AlecLC](/AlecLC) Yes."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@kylecrowley](/kylecrowley) It's LC's official solution image with my text on top... who am I gonna credit, Leetcode itself?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "If you\\'re going to rip [other peoples images](https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/solutions/2834516/python-dfs-picture-explanation-o-n), the least you could do is credit them."
                    },
                    {
                        "username": "reassurance",
                        "content": "or even better none of them show up to the capital and make a mutiny against the crown"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "People afraid to upvote this post because they think they might get banned for supporting the Jan 6 EVENT"
                    },
                    {
                        "username": "nasibsltn",
                        "content": "Answer couldn\\'t be fit into 32 bit signed integer. "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "131st testcase is cruel\\uD83D\\uDE22\\n130/131 PASSED for me\\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Upload the failed testcases, it can help someone find bugs in their code"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "Same here, what you did?"
                    }
                ]
            },
            {
                "id": 1797858,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "everyone except me finding this question easy, why it is hard for me\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I Found this one more difficult than Shortest Path with Alternating Colors"
                    },
                    {
                        "username": "yaojintham",
                        "content": "That is BFS. This is DFS Post-Order Processing. Very different."
                    },
                    {
                        "username": "KhacLong",
                        "content": "this problem is quite easy with basic dfs and a little math"
                    },
                    {
                        "username": "DanielGindi",
                        "content": "Easy, but then TLE"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "Type casting to float `ceil((float)reps/seats)` is giving wrong answer where as to double `ceil((double)reps/seats)` is giving AC. Why is this happening?"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "thank you very much for your tip\\n"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Learned a new thing today!\\nIf you submit the same answer two three times it gives you 100%faster results"
                    },
                    {
                        "username": "jbochi",
                        "content": "When I first read the problem, I missed that all cars had the same amount of seats, and couldn\\'t think of an efficient algorithm. I tried to frame it as max flow / min cost, but failed. The problem is a lot simpler because (*spoiler* / *hint*) representatives should always use as little cars as needed for each road.\\n\\nIs there a polynomial solution if the number of seats is not fixed or is it NP-Hard?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "If the number of seats increases uniformly with distance from capital, then the greedy algo (poly) still works.  In more complicated scenarios where a large bus needs to drive the same routes multiple times, it will probably enter NP hard territory."
                    },
                    {
                        "username": "Jaiff",
                        "content": "yes, it would be NP-hard in that case."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![2477-minimum-fuel-cost-to-report-to-capital.png](https://assets.leetcode.com/users/images/05921657-c5a1-4e67-a7b8-2ca6818191b3_1676171358.7216883.png)\n\n# <span style='color:green'>Implementation</span>\n```\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adj = defaultdict(set)\n        self.ans = 0\n        visited = {0}\n        for a, b in roads:\n            adj[a].add(b)\n            adj[b].add(a)\n\n        def dfs(node):\n            reps = 1\n            if node not in adj:\n                return reps\n\n            for child in adj[node]:\n                if child not in visited:\n                    visited.add(child)\n                    reps += dfs(child)\n\n            # calculate fuel required to reach this node\n            # no fuel required to reach node 0\n            if node:\n                self.ans += math.ceil(reps / seats)\n\n            return reps\n\n        dfs(0)\n        return self.ans\n```"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@AlecLC](/AlecLC) Yes."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@kylecrowley](/kylecrowley) It's LC's official solution image with my text on top... who am I gonna credit, Leetcode itself?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "If you\\'re going to rip [other peoples images](https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/solutions/2834516/python-dfs-picture-explanation-o-n), the least you could do is credit them."
                    },
                    {
                        "username": "reassurance",
                        "content": "or even better none of them show up to the capital and make a mutiny against the crown"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "People afraid to upvote this post because they think they might get banned for supporting the Jan 6 EVENT"
                    },
                    {
                        "username": "nasibsltn",
                        "content": "Answer couldn\\'t be fit into 32 bit signed integer. "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "131st testcase is cruel\\uD83D\\uDE22\\n130/131 PASSED for me\\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Upload the failed testcases, it can help someone find bugs in their code"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "Same here, what you did?"
                    }
                ]
            },
            {
                "id": 1797321,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "everyone except me finding this question easy, why it is hard for me\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I Found this one more difficult than Shortest Path with Alternating Colors"
                    },
                    {
                        "username": "yaojintham",
                        "content": "That is BFS. This is DFS Post-Order Processing. Very different."
                    },
                    {
                        "username": "KhacLong",
                        "content": "this problem is quite easy with basic dfs and a little math"
                    },
                    {
                        "username": "DanielGindi",
                        "content": "Easy, but then TLE"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "Type casting to float `ceil((float)reps/seats)` is giving wrong answer where as to double `ceil((double)reps/seats)` is giving AC. Why is this happening?"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "thank you very much for your tip\\n"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Learned a new thing today!\\nIf you submit the same answer two three times it gives you 100%faster results"
                    },
                    {
                        "username": "jbochi",
                        "content": "When I first read the problem, I missed that all cars had the same amount of seats, and couldn\\'t think of an efficient algorithm. I tried to frame it as max flow / min cost, but failed. The problem is a lot simpler because (*spoiler* / *hint*) representatives should always use as little cars as needed for each road.\\n\\nIs there a polynomial solution if the number of seats is not fixed or is it NP-Hard?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "If the number of seats increases uniformly with distance from capital, then the greedy algo (poly) still works.  In more complicated scenarios where a large bus needs to drive the same routes multiple times, it will probably enter NP hard territory."
                    },
                    {
                        "username": "Jaiff",
                        "content": "yes, it would be NP-hard in that case."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![2477-minimum-fuel-cost-to-report-to-capital.png](https://assets.leetcode.com/users/images/05921657-c5a1-4e67-a7b8-2ca6818191b3_1676171358.7216883.png)\n\n# <span style='color:green'>Implementation</span>\n```\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adj = defaultdict(set)\n        self.ans = 0\n        visited = {0}\n        for a, b in roads:\n            adj[a].add(b)\n            adj[b].add(a)\n\n        def dfs(node):\n            reps = 1\n            if node not in adj:\n                return reps\n\n            for child in adj[node]:\n                if child not in visited:\n                    visited.add(child)\n                    reps += dfs(child)\n\n            # calculate fuel required to reach this node\n            # no fuel required to reach node 0\n            if node:\n                self.ans += math.ceil(reps / seats)\n\n            return reps\n\n        dfs(0)\n        return self.ans\n```"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@AlecLC](/AlecLC) Yes."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@kylecrowley](/kylecrowley) It's LC's official solution image with my text on top... who am I gonna credit, Leetcode itself?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "If you\\'re going to rip [other peoples images](https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/solutions/2834516/python-dfs-picture-explanation-o-n), the least you could do is credit them."
                    },
                    {
                        "username": "reassurance",
                        "content": "or even better none of them show up to the capital and make a mutiny against the crown"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "People afraid to upvote this post because they think they might get banned for supporting the Jan 6 EVENT"
                    },
                    {
                        "username": "nasibsltn",
                        "content": "Answer couldn\\'t be fit into 32 bit signed integer. "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "131st testcase is cruel\\uD83D\\uDE22\\n130/131 PASSED for me\\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Upload the failed testcases, it can help someone find bugs in their code"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "Same here, what you did?"
                    }
                ]
            },
            {
                "id": 1797781,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "everyone except me finding this question easy, why it is hard for me\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I Found this one more difficult than Shortest Path with Alternating Colors"
                    },
                    {
                        "username": "yaojintham",
                        "content": "That is BFS. This is DFS Post-Order Processing. Very different."
                    },
                    {
                        "username": "KhacLong",
                        "content": "this problem is quite easy with basic dfs and a little math"
                    },
                    {
                        "username": "DanielGindi",
                        "content": "Easy, but then TLE"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "Type casting to float `ceil((float)reps/seats)` is giving wrong answer where as to double `ceil((double)reps/seats)` is giving AC. Why is this happening?"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "thank you very much for your tip\\n"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Learned a new thing today!\\nIf you submit the same answer two three times it gives you 100%faster results"
                    },
                    {
                        "username": "jbochi",
                        "content": "When I first read the problem, I missed that all cars had the same amount of seats, and couldn\\'t think of an efficient algorithm. I tried to frame it as max flow / min cost, but failed. The problem is a lot simpler because (*spoiler* / *hint*) representatives should always use as little cars as needed for each road.\\n\\nIs there a polynomial solution if the number of seats is not fixed or is it NP-Hard?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "If the number of seats increases uniformly with distance from capital, then the greedy algo (poly) still works.  In more complicated scenarios where a large bus needs to drive the same routes multiple times, it will probably enter NP hard territory."
                    },
                    {
                        "username": "Jaiff",
                        "content": "yes, it would be NP-hard in that case."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![2477-minimum-fuel-cost-to-report-to-capital.png](https://assets.leetcode.com/users/images/05921657-c5a1-4e67-a7b8-2ca6818191b3_1676171358.7216883.png)\n\n# <span style='color:green'>Implementation</span>\n```\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adj = defaultdict(set)\n        self.ans = 0\n        visited = {0}\n        for a, b in roads:\n            adj[a].add(b)\n            adj[b].add(a)\n\n        def dfs(node):\n            reps = 1\n            if node not in adj:\n                return reps\n\n            for child in adj[node]:\n                if child not in visited:\n                    visited.add(child)\n                    reps += dfs(child)\n\n            # calculate fuel required to reach this node\n            # no fuel required to reach node 0\n            if node:\n                self.ans += math.ceil(reps / seats)\n\n            return reps\n\n        dfs(0)\n        return self.ans\n```"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@AlecLC](/AlecLC) Yes."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@kylecrowley](/kylecrowley) It's LC's official solution image with my text on top... who am I gonna credit, Leetcode itself?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "If you\\'re going to rip [other peoples images](https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/solutions/2834516/python-dfs-picture-explanation-o-n), the least you could do is credit them."
                    },
                    {
                        "username": "reassurance",
                        "content": "or even better none of them show up to the capital and make a mutiny against the crown"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "People afraid to upvote this post because they think they might get banned for supporting the Jan 6 EVENT"
                    },
                    {
                        "username": "nasibsltn",
                        "content": "Answer couldn\\'t be fit into 32 bit signed integer. "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "131st testcase is cruel\\uD83D\\uDE22\\n130/131 PASSED for me\\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Upload the failed testcases, it can help someone find bugs in their code"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "Same here, what you did?"
                    }
                ]
            },
            {
                "id": 1797731,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "everyone except me finding this question easy, why it is hard for me\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I Found this one more difficult than Shortest Path with Alternating Colors"
                    },
                    {
                        "username": "yaojintham",
                        "content": "That is BFS. This is DFS Post-Order Processing. Very different."
                    },
                    {
                        "username": "KhacLong",
                        "content": "this problem is quite easy with basic dfs and a little math"
                    },
                    {
                        "username": "DanielGindi",
                        "content": "Easy, but then TLE"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "Type casting to float `ceil((float)reps/seats)` is giving wrong answer where as to double `ceil((double)reps/seats)` is giving AC. Why is this happening?"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "thank you very much for your tip\\n"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Learned a new thing today!\\nIf you submit the same answer two three times it gives you 100%faster results"
                    },
                    {
                        "username": "jbochi",
                        "content": "When I first read the problem, I missed that all cars had the same amount of seats, and couldn\\'t think of an efficient algorithm. I tried to frame it as max flow / min cost, but failed. The problem is a lot simpler because (*spoiler* / *hint*) representatives should always use as little cars as needed for each road.\\n\\nIs there a polynomial solution if the number of seats is not fixed or is it NP-Hard?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "If the number of seats increases uniformly with distance from capital, then the greedy algo (poly) still works.  In more complicated scenarios where a large bus needs to drive the same routes multiple times, it will probably enter NP hard territory."
                    },
                    {
                        "username": "Jaiff",
                        "content": "yes, it would be NP-hard in that case."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![2477-minimum-fuel-cost-to-report-to-capital.png](https://assets.leetcode.com/users/images/05921657-c5a1-4e67-a7b8-2ca6818191b3_1676171358.7216883.png)\n\n# <span style='color:green'>Implementation</span>\n```\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adj = defaultdict(set)\n        self.ans = 0\n        visited = {0}\n        for a, b in roads:\n            adj[a].add(b)\n            adj[b].add(a)\n\n        def dfs(node):\n            reps = 1\n            if node not in adj:\n                return reps\n\n            for child in adj[node]:\n                if child not in visited:\n                    visited.add(child)\n                    reps += dfs(child)\n\n            # calculate fuel required to reach this node\n            # no fuel required to reach node 0\n            if node:\n                self.ans += math.ceil(reps / seats)\n\n            return reps\n\n        dfs(0)\n        return self.ans\n```"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@AlecLC](/AlecLC) Yes."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@kylecrowley](/kylecrowley) It's LC's official solution image with my text on top... who am I gonna credit, Leetcode itself?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "If you\\'re going to rip [other peoples images](https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/solutions/2834516/python-dfs-picture-explanation-o-n), the least you could do is credit them."
                    },
                    {
                        "username": "reassurance",
                        "content": "or even better none of them show up to the capital and make a mutiny against the crown"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "People afraid to upvote this post because they think they might get banned for supporting the Jan 6 EVENT"
                    },
                    {
                        "username": "nasibsltn",
                        "content": "Answer couldn\\'t be fit into 32 bit signed integer. "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "131st testcase is cruel\\uD83D\\uDE22\\n130/131 PASSED for me\\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Upload the failed testcases, it can help someone find bugs in their code"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "Same here, what you did?"
                    }
                ]
            },
            {
                "id": 1797291,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "everyone except me finding this question easy, why it is hard for me\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I Found this one more difficult than Shortest Path with Alternating Colors"
                    },
                    {
                        "username": "yaojintham",
                        "content": "That is BFS. This is DFS Post-Order Processing. Very different."
                    },
                    {
                        "username": "KhacLong",
                        "content": "this problem is quite easy with basic dfs and a little math"
                    },
                    {
                        "username": "DanielGindi",
                        "content": "Easy, but then TLE"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "Type casting to float `ceil((float)reps/seats)` is giving wrong answer where as to double `ceil((double)reps/seats)` is giving AC. Why is this happening?"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "thank you very much for your tip\\n"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Learned a new thing today!\\nIf you submit the same answer two three times it gives you 100%faster results"
                    },
                    {
                        "username": "jbochi",
                        "content": "When I first read the problem, I missed that all cars had the same amount of seats, and couldn\\'t think of an efficient algorithm. I tried to frame it as max flow / min cost, but failed. The problem is a lot simpler because (*spoiler* / *hint*) representatives should always use as little cars as needed for each road.\\n\\nIs there a polynomial solution if the number of seats is not fixed or is it NP-Hard?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "If the number of seats increases uniformly with distance from capital, then the greedy algo (poly) still works.  In more complicated scenarios where a large bus needs to drive the same routes multiple times, it will probably enter NP hard territory."
                    },
                    {
                        "username": "Jaiff",
                        "content": "yes, it would be NP-hard in that case."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![2477-minimum-fuel-cost-to-report-to-capital.png](https://assets.leetcode.com/users/images/05921657-c5a1-4e67-a7b8-2ca6818191b3_1676171358.7216883.png)\n\n# <span style='color:green'>Implementation</span>\n```\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adj = defaultdict(set)\n        self.ans = 0\n        visited = {0}\n        for a, b in roads:\n            adj[a].add(b)\n            adj[b].add(a)\n\n        def dfs(node):\n            reps = 1\n            if node not in adj:\n                return reps\n\n            for child in adj[node]:\n                if child not in visited:\n                    visited.add(child)\n                    reps += dfs(child)\n\n            # calculate fuel required to reach this node\n            # no fuel required to reach node 0\n            if node:\n                self.ans += math.ceil(reps / seats)\n\n            return reps\n\n        dfs(0)\n        return self.ans\n```"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@AlecLC](/AlecLC) Yes."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@kylecrowley](/kylecrowley) It's LC's official solution image with my text on top... who am I gonna credit, Leetcode itself?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "If you\\'re going to rip [other peoples images](https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/solutions/2834516/python-dfs-picture-explanation-o-n), the least you could do is credit them."
                    },
                    {
                        "username": "reassurance",
                        "content": "or even better none of them show up to the capital and make a mutiny against the crown"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "People afraid to upvote this post because they think they might get banned for supporting the Jan 6 EVENT"
                    },
                    {
                        "username": "nasibsltn",
                        "content": "Answer couldn\\'t be fit into 32 bit signed integer. "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "131st testcase is cruel\\uD83D\\uDE22\\n130/131 PASSED for me\\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Upload the failed testcases, it can help someone find bugs in their code"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "Same here, what you did?"
                    }
                ]
            },
            {
                "id": 1797259,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "everyone except me finding this question easy, why it is hard for me\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I Found this one more difficult than Shortest Path with Alternating Colors"
                    },
                    {
                        "username": "yaojintham",
                        "content": "That is BFS. This is DFS Post-Order Processing. Very different."
                    },
                    {
                        "username": "KhacLong",
                        "content": "this problem is quite easy with basic dfs and a little math"
                    },
                    {
                        "username": "DanielGindi",
                        "content": "Easy, but then TLE"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "Type casting to float `ceil((float)reps/seats)` is giving wrong answer where as to double `ceil((double)reps/seats)` is giving AC. Why is this happening?"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "thank you very much for your tip\\n"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Learned a new thing today!\\nIf you submit the same answer two three times it gives you 100%faster results"
                    },
                    {
                        "username": "jbochi",
                        "content": "When I first read the problem, I missed that all cars had the same amount of seats, and couldn\\'t think of an efficient algorithm. I tried to frame it as max flow / min cost, but failed. The problem is a lot simpler because (*spoiler* / *hint*) representatives should always use as little cars as needed for each road.\\n\\nIs there a polynomial solution if the number of seats is not fixed or is it NP-Hard?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "If the number of seats increases uniformly with distance from capital, then the greedy algo (poly) still works.  In more complicated scenarios where a large bus needs to drive the same routes multiple times, it will probably enter NP hard territory."
                    },
                    {
                        "username": "Jaiff",
                        "content": "yes, it would be NP-hard in that case."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![2477-minimum-fuel-cost-to-report-to-capital.png](https://assets.leetcode.com/users/images/05921657-c5a1-4e67-a7b8-2ca6818191b3_1676171358.7216883.png)\n\n# <span style='color:green'>Implementation</span>\n```\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adj = defaultdict(set)\n        self.ans = 0\n        visited = {0}\n        for a, b in roads:\n            adj[a].add(b)\n            adj[b].add(a)\n\n        def dfs(node):\n            reps = 1\n            if node not in adj:\n                return reps\n\n            for child in adj[node]:\n                if child not in visited:\n                    visited.add(child)\n                    reps += dfs(child)\n\n            # calculate fuel required to reach this node\n            # no fuel required to reach node 0\n            if node:\n                self.ans += math.ceil(reps / seats)\n\n            return reps\n\n        dfs(0)\n        return self.ans\n```"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@AlecLC](/AlecLC) Yes."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@kylecrowley](/kylecrowley) It's LC's official solution image with my text on top... who am I gonna credit, Leetcode itself?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "If you\\'re going to rip [other peoples images](https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/solutions/2834516/python-dfs-picture-explanation-o-n), the least you could do is credit them."
                    },
                    {
                        "username": "reassurance",
                        "content": "or even better none of them show up to the capital and make a mutiny against the crown"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "People afraid to upvote this post because they think they might get banned for supporting the Jan 6 EVENT"
                    },
                    {
                        "username": "nasibsltn",
                        "content": "Answer couldn\\'t be fit into 32 bit signed integer. "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "131st testcase is cruel\\uD83D\\uDE22\\n130/131 PASSED for me\\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Upload the failed testcases, it can help someone find bugs in their code"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "Same here, what you did?"
                    }
                ]
            },
            {
                "id": 1798452,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "everyone except me finding this question easy, why it is hard for me\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I Found this one more difficult than Shortest Path with Alternating Colors"
                    },
                    {
                        "username": "yaojintham",
                        "content": "That is BFS. This is DFS Post-Order Processing. Very different."
                    },
                    {
                        "username": "KhacLong",
                        "content": "this problem is quite easy with basic dfs and a little math"
                    },
                    {
                        "username": "DanielGindi",
                        "content": "Easy, but then TLE"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "Type casting to float `ceil((float)reps/seats)` is giving wrong answer where as to double `ceil((double)reps/seats)` is giving AC. Why is this happening?"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "thank you very much for your tip\\n"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Learned a new thing today!\\nIf you submit the same answer two three times it gives you 100%faster results"
                    },
                    {
                        "username": "jbochi",
                        "content": "When I first read the problem, I missed that all cars had the same amount of seats, and couldn\\'t think of an efficient algorithm. I tried to frame it as max flow / min cost, but failed. The problem is a lot simpler because (*spoiler* / *hint*) representatives should always use as little cars as needed for each road.\\n\\nIs there a polynomial solution if the number of seats is not fixed or is it NP-Hard?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "If the number of seats increases uniformly with distance from capital, then the greedy algo (poly) still works.  In more complicated scenarios where a large bus needs to drive the same routes multiple times, it will probably enter NP hard territory."
                    },
                    {
                        "username": "Jaiff",
                        "content": "yes, it would be NP-hard in that case."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![2477-minimum-fuel-cost-to-report-to-capital.png](https://assets.leetcode.com/users/images/05921657-c5a1-4e67-a7b8-2ca6818191b3_1676171358.7216883.png)\n\n# <span style='color:green'>Implementation</span>\n```\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adj = defaultdict(set)\n        self.ans = 0\n        visited = {0}\n        for a, b in roads:\n            adj[a].add(b)\n            adj[b].add(a)\n\n        def dfs(node):\n            reps = 1\n            if node not in adj:\n                return reps\n\n            for child in adj[node]:\n                if child not in visited:\n                    visited.add(child)\n                    reps += dfs(child)\n\n            # calculate fuel required to reach this node\n            # no fuel required to reach node 0\n            if node:\n                self.ans += math.ceil(reps / seats)\n\n            return reps\n\n        dfs(0)\n        return self.ans\n```"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@AlecLC](/AlecLC) Yes."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@kylecrowley](/kylecrowley) It's LC's official solution image with my text on top... who am I gonna credit, Leetcode itself?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "If you\\'re going to rip [other peoples images](https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/solutions/2834516/python-dfs-picture-explanation-o-n), the least you could do is credit them."
                    },
                    {
                        "username": "reassurance",
                        "content": "or even better none of them show up to the capital and make a mutiny against the crown"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "People afraid to upvote this post because they think they might get banned for supporting the Jan 6 EVENT"
                    },
                    {
                        "username": "nasibsltn",
                        "content": "Answer couldn\\'t be fit into 32 bit signed integer. "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "131st testcase is cruel\\uD83D\\uDE22\\n130/131 PASSED for me\\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Upload the failed testcases, it can help someone find bugs in their code"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "Same here, what you did?"
                    }
                ]
            },
            {
                "id": 1798419,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "everyone except me finding this question easy, why it is hard for me\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I Found this one more difficult than Shortest Path with Alternating Colors"
                    },
                    {
                        "username": "yaojintham",
                        "content": "That is BFS. This is DFS Post-Order Processing. Very different."
                    },
                    {
                        "username": "KhacLong",
                        "content": "this problem is quite easy with basic dfs and a little math"
                    },
                    {
                        "username": "DanielGindi",
                        "content": "Easy, but then TLE"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "Type casting to float `ceil((float)reps/seats)` is giving wrong answer where as to double `ceil((double)reps/seats)` is giving AC. Why is this happening?"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "thank you very much for your tip\\n"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Learned a new thing today!\\nIf you submit the same answer two three times it gives you 100%faster results"
                    },
                    {
                        "username": "jbochi",
                        "content": "When I first read the problem, I missed that all cars had the same amount of seats, and couldn\\'t think of an efficient algorithm. I tried to frame it as max flow / min cost, but failed. The problem is a lot simpler because (*spoiler* / *hint*) representatives should always use as little cars as needed for each road.\\n\\nIs there a polynomial solution if the number of seats is not fixed or is it NP-Hard?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "If the number of seats increases uniformly with distance from capital, then the greedy algo (poly) still works.  In more complicated scenarios where a large bus needs to drive the same routes multiple times, it will probably enter NP hard territory."
                    },
                    {
                        "username": "Jaiff",
                        "content": "yes, it would be NP-hard in that case."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![2477-minimum-fuel-cost-to-report-to-capital.png](https://assets.leetcode.com/users/images/05921657-c5a1-4e67-a7b8-2ca6818191b3_1676171358.7216883.png)\n\n# <span style='color:green'>Implementation</span>\n```\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adj = defaultdict(set)\n        self.ans = 0\n        visited = {0}\n        for a, b in roads:\n            adj[a].add(b)\n            adj[b].add(a)\n\n        def dfs(node):\n            reps = 1\n            if node not in adj:\n                return reps\n\n            for child in adj[node]:\n                if child not in visited:\n                    visited.add(child)\n                    reps += dfs(child)\n\n            # calculate fuel required to reach this node\n            # no fuel required to reach node 0\n            if node:\n                self.ans += math.ceil(reps / seats)\n\n            return reps\n\n        dfs(0)\n        return self.ans\n```"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@AlecLC](/AlecLC) Yes."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@kylecrowley](/kylecrowley) It's LC's official solution image with my text on top... who am I gonna credit, Leetcode itself?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "If you\\'re going to rip [other peoples images](https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/solutions/2834516/python-dfs-picture-explanation-o-n), the least you could do is credit them."
                    },
                    {
                        "username": "reassurance",
                        "content": "or even better none of them show up to the capital and make a mutiny against the crown"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "People afraid to upvote this post because they think they might get banned for supporting the Jan 6 EVENT"
                    },
                    {
                        "username": "nasibsltn",
                        "content": "Answer couldn\\'t be fit into 32 bit signed integer. "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "131st testcase is cruel\\uD83D\\uDE22\\n130/131 PASSED for me\\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Upload the failed testcases, it can help someone find bugs in their code"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "Same here, what you did?"
                    }
                ]
            },
            {
                "id": 1798417,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "everyone except me finding this question easy, why it is hard for me\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I Found this one more difficult than Shortest Path with Alternating Colors"
                    },
                    {
                        "username": "yaojintham",
                        "content": "That is BFS. This is DFS Post-Order Processing. Very different."
                    },
                    {
                        "username": "KhacLong",
                        "content": "this problem is quite easy with basic dfs and a little math"
                    },
                    {
                        "username": "DanielGindi",
                        "content": "Easy, but then TLE"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "Type casting to float `ceil((float)reps/seats)` is giving wrong answer where as to double `ceil((double)reps/seats)` is giving AC. Why is this happening?"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "thank you very much for your tip\\n"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Learned a new thing today!\\nIf you submit the same answer two three times it gives you 100%faster results"
                    },
                    {
                        "username": "jbochi",
                        "content": "When I first read the problem, I missed that all cars had the same amount of seats, and couldn\\'t think of an efficient algorithm. I tried to frame it as max flow / min cost, but failed. The problem is a lot simpler because (*spoiler* / *hint*) representatives should always use as little cars as needed for each road.\\n\\nIs there a polynomial solution if the number of seats is not fixed or is it NP-Hard?"
                    },
                    {
                        "username": "yinboshi13",
                        "content": "If the number of seats increases uniformly with distance from capital, then the greedy algo (poly) still works.  In more complicated scenarios where a large bus needs to drive the same routes multiple times, it will probably enter NP hard territory."
                    },
                    {
                        "username": "Jaiff",
                        "content": "yes, it would be NP-hard in that case."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n\n![2477-minimum-fuel-cost-to-report-to-capital.png](https://assets.leetcode.com/users/images/05921657-c5a1-4e67-a7b8-2ca6818191b3_1676171358.7216883.png)\n\n# <span style='color:green'>Implementation</span>\n```\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        adj = defaultdict(set)\n        self.ans = 0\n        visited = {0}\n        for a, b in roads:\n            adj[a].add(b)\n            adj[b].add(a)\n\n        def dfs(node):\n            reps = 1\n            if node not in adj:\n                return reps\n\n            for child in adj[node]:\n                if child not in visited:\n                    visited.add(child)\n                    reps += dfs(child)\n\n            # calculate fuel required to reach this node\n            # no fuel required to reach node 0\n            if node:\n                self.ans += math.ceil(reps / seats)\n\n            return reps\n\n        dfs(0)\n        return self.ans\n```"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@AlecLC](/AlecLC) Yes."
                    },
                    {
                        "username": "AlecLC",
                        "content": "[@kylecrowley](/kylecrowley) It's LC's official solution image with my text on top... who am I gonna credit, Leetcode itself?"
                    },
                    {
                        "username": "kylecrowley",
                        "content": "If you\\'re going to rip [other peoples images](https://leetcode.com/problems/minimum-fuel-cost-to-report-to-the-capital/solutions/2834516/python-dfs-picture-explanation-o-n), the least you could do is credit them."
                    },
                    {
                        "username": "reassurance",
                        "content": "or even better none of them show up to the capital and make a mutiny against the crown"
                    },
                    {
                        "username": "billy_homeless",
                        "content": "People afraid to upvote this post because they think they might get banned for supporting the Jan 6 EVENT"
                    },
                    {
                        "username": "nasibsltn",
                        "content": "Answer couldn\\'t be fit into 32 bit signed integer. "
                    },
                    {
                        "username": "harisriram2002",
                        "content": "131st testcase is cruel\\uD83D\\uDE22\\n130/131 PASSED for me\\n"
                    },
                    {
                        "username": "asutosh117",
                        "content": "Upload the failed testcases, it can help someone find bugs in their code"
                    },
                    {
                        "username": "bhaskar123u",
                        "content": "Same here, what you did?"
                    }
                ]
            },
            {
                "id": 1798404,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Meeting only to hear they are laid off.\\n"
                    },
                    {
                        "username": "DebayudhCodes",
                        "content": "Can someone tell me why this code is giving me TLE ??\\nIt gives TLE on submit but doesnt give TLE when I run that same testcase...\\n\\nclass Solution {\\npublic:\\n    long long ans=0;\\n    int n=0;\\n    int dfs(vector<vector<int>> adj, int node, int prev, int seats){\\n        // if(vis[adj[node][0]] && adj[node].size()==1){\\n        //     ans++;\\n        //     return 1;\\n        // }\\n        int ct=1;\\n        for(auto it: adj[node]){\\n            if(it!=prev)\\n                ct+=dfs(adj,it,node, seats);\\n        }\\n        // long long cars=ct/seats;\\n        // if(ct%seats) \\n        //     cars++;\\n        if(node>0)    \\n            ans+= (ct + seats - 1) / seats;\\n        return ct;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        n=roads.size();\\n        if(n==0)\\n            return 0;\\n        ans=0;\\n        vector<vector<int>> adj(n+1);\\n        for(auto it:roads){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        // vector<bool> visited(n+1,0);\\n\\n        dfs(adj,0,-1,seats);\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Avoid passing the adjacency list by value, it gets copied with every function call. Pass it by (a constant) reference"
                    },
                    {
                        "username": "kmp1084",
                        "content": "All the companies that ask such questions have a hiring freeze!!! How unfortunate!"
                    },
                    {
                        "username": "jems1123",
                        "content": "every day we are getting graph"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Leetcode keeps reminding me that i have to learn graphs properly\\uD83D\\uDE3F"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The problem becomes quite easy, if the graph will be directed, in this case we just need to find the nodes with indegree == 0 and start traverse from them. But it\\'s not :)"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "TestCase:[[0,1],[0,2],[1,3],[1,4]]\nMy output:5\nExpected Output:4\nwhy? Expecte output should be 5,can anyone tell why expected output is 4\nAnyone Help"
                    },
                    {
                        "username": "harshithvh",
                        "content": "TF!! representatives can also switch their cars in between, if a car still has empty seats.\\nCheck this:\\n[[3,1],[3,2],[1,0],[0,4],[0,5],[4,6],[5,7],[1,8],[6,9],[9,10],[4,11],[4,12]]\\nseats = 2\\n11th guy can sit in 12th\\'s car(or vice versa) at junction 4."
                    },
                    {
                        "username": "SG-C",
                        "content": "Today forecast Possibility of heavy rain so please stay at home do not go outside for any thing ! \\uD83D\\uDE01"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i am struggling with to find out when to create adjacency vector of n size and when of n+1  size  , how to get to know ."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "I always use an n sized adj list, can you give me an example where you needed n + 1 adj list"
                    }
                ]
            },
            {
                "id": 1798284,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Meeting only to hear they are laid off.\\n"
                    },
                    {
                        "username": "DebayudhCodes",
                        "content": "Can someone tell me why this code is giving me TLE ??\\nIt gives TLE on submit but doesnt give TLE when I run that same testcase...\\n\\nclass Solution {\\npublic:\\n    long long ans=0;\\n    int n=0;\\n    int dfs(vector<vector<int>> adj, int node, int prev, int seats){\\n        // if(vis[adj[node][0]] && adj[node].size()==1){\\n        //     ans++;\\n        //     return 1;\\n        // }\\n        int ct=1;\\n        for(auto it: adj[node]){\\n            if(it!=prev)\\n                ct+=dfs(adj,it,node, seats);\\n        }\\n        // long long cars=ct/seats;\\n        // if(ct%seats) \\n        //     cars++;\\n        if(node>0)    \\n            ans+= (ct + seats - 1) / seats;\\n        return ct;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        n=roads.size();\\n        if(n==0)\\n            return 0;\\n        ans=0;\\n        vector<vector<int>> adj(n+1);\\n        for(auto it:roads){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        // vector<bool> visited(n+1,0);\\n\\n        dfs(adj,0,-1,seats);\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Avoid passing the adjacency list by value, it gets copied with every function call. Pass it by (a constant) reference"
                    },
                    {
                        "username": "kmp1084",
                        "content": "All the companies that ask such questions have a hiring freeze!!! How unfortunate!"
                    },
                    {
                        "username": "jems1123",
                        "content": "every day we are getting graph"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Leetcode keeps reminding me that i have to learn graphs properly\\uD83D\\uDE3F"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The problem becomes quite easy, if the graph will be directed, in this case we just need to find the nodes with indegree == 0 and start traverse from them. But it\\'s not :)"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "TestCase:[[0,1],[0,2],[1,3],[1,4]]\nMy output:5\nExpected Output:4\nwhy? Expecte output should be 5,can anyone tell why expected output is 4\nAnyone Help"
                    },
                    {
                        "username": "harshithvh",
                        "content": "TF!! representatives can also switch their cars in between, if a car still has empty seats.\\nCheck this:\\n[[3,1],[3,2],[1,0],[0,4],[0,5],[4,6],[5,7],[1,8],[6,9],[9,10],[4,11],[4,12]]\\nseats = 2\\n11th guy can sit in 12th\\'s car(or vice versa) at junction 4."
                    },
                    {
                        "username": "SG-C",
                        "content": "Today forecast Possibility of heavy rain so please stay at home do not go outside for any thing ! \\uD83D\\uDE01"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i am struggling with to find out when to create adjacency vector of n size and when of n+1  size  , how to get to know ."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "I always use an n sized adj list, can you give me an example where you needed n + 1 adj list"
                    }
                ]
            },
            {
                "id": 1798203,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Meeting only to hear they are laid off.\\n"
                    },
                    {
                        "username": "DebayudhCodes",
                        "content": "Can someone tell me why this code is giving me TLE ??\\nIt gives TLE on submit but doesnt give TLE when I run that same testcase...\\n\\nclass Solution {\\npublic:\\n    long long ans=0;\\n    int n=0;\\n    int dfs(vector<vector<int>> adj, int node, int prev, int seats){\\n        // if(vis[adj[node][0]] && adj[node].size()==1){\\n        //     ans++;\\n        //     return 1;\\n        // }\\n        int ct=1;\\n        for(auto it: adj[node]){\\n            if(it!=prev)\\n                ct+=dfs(adj,it,node, seats);\\n        }\\n        // long long cars=ct/seats;\\n        // if(ct%seats) \\n        //     cars++;\\n        if(node>0)    \\n            ans+= (ct + seats - 1) / seats;\\n        return ct;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        n=roads.size();\\n        if(n==0)\\n            return 0;\\n        ans=0;\\n        vector<vector<int>> adj(n+1);\\n        for(auto it:roads){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        // vector<bool> visited(n+1,0);\\n\\n        dfs(adj,0,-1,seats);\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Avoid passing the adjacency list by value, it gets copied with every function call. Pass it by (a constant) reference"
                    },
                    {
                        "username": "kmp1084",
                        "content": "All the companies that ask such questions have a hiring freeze!!! How unfortunate!"
                    },
                    {
                        "username": "jems1123",
                        "content": "every day we are getting graph"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Leetcode keeps reminding me that i have to learn graphs properly\\uD83D\\uDE3F"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The problem becomes quite easy, if the graph will be directed, in this case we just need to find the nodes with indegree == 0 and start traverse from them. But it\\'s not :)"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "TestCase:[[0,1],[0,2],[1,3],[1,4]]\nMy output:5\nExpected Output:4\nwhy? Expecte output should be 5,can anyone tell why expected output is 4\nAnyone Help"
                    },
                    {
                        "username": "harshithvh",
                        "content": "TF!! representatives can also switch their cars in between, if a car still has empty seats.\\nCheck this:\\n[[3,1],[3,2],[1,0],[0,4],[0,5],[4,6],[5,7],[1,8],[6,9],[9,10],[4,11],[4,12]]\\nseats = 2\\n11th guy can sit in 12th\\'s car(or vice versa) at junction 4."
                    },
                    {
                        "username": "SG-C",
                        "content": "Today forecast Possibility of heavy rain so please stay at home do not go outside for any thing ! \\uD83D\\uDE01"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i am struggling with to find out when to create adjacency vector of n size and when of n+1  size  , how to get to know ."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "I always use an n sized adj list, can you give me an example where you needed n + 1 adj list"
                    }
                ]
            },
            {
                "id": 1797950,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Meeting only to hear they are laid off.\\n"
                    },
                    {
                        "username": "DebayudhCodes",
                        "content": "Can someone tell me why this code is giving me TLE ??\\nIt gives TLE on submit but doesnt give TLE when I run that same testcase...\\n\\nclass Solution {\\npublic:\\n    long long ans=0;\\n    int n=0;\\n    int dfs(vector<vector<int>> adj, int node, int prev, int seats){\\n        // if(vis[adj[node][0]] && adj[node].size()==1){\\n        //     ans++;\\n        //     return 1;\\n        // }\\n        int ct=1;\\n        for(auto it: adj[node]){\\n            if(it!=prev)\\n                ct+=dfs(adj,it,node, seats);\\n        }\\n        // long long cars=ct/seats;\\n        // if(ct%seats) \\n        //     cars++;\\n        if(node>0)    \\n            ans+= (ct + seats - 1) / seats;\\n        return ct;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        n=roads.size();\\n        if(n==0)\\n            return 0;\\n        ans=0;\\n        vector<vector<int>> adj(n+1);\\n        for(auto it:roads){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        // vector<bool> visited(n+1,0);\\n\\n        dfs(adj,0,-1,seats);\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Avoid passing the adjacency list by value, it gets copied with every function call. Pass it by (a constant) reference"
                    },
                    {
                        "username": "kmp1084",
                        "content": "All the companies that ask such questions have a hiring freeze!!! How unfortunate!"
                    },
                    {
                        "username": "jems1123",
                        "content": "every day we are getting graph"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Leetcode keeps reminding me that i have to learn graphs properly\\uD83D\\uDE3F"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The problem becomes quite easy, if the graph will be directed, in this case we just need to find the nodes with indegree == 0 and start traverse from them. But it\\'s not :)"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "TestCase:[[0,1],[0,2],[1,3],[1,4]]\nMy output:5\nExpected Output:4\nwhy? Expecte output should be 5,can anyone tell why expected output is 4\nAnyone Help"
                    },
                    {
                        "username": "harshithvh",
                        "content": "TF!! representatives can also switch their cars in between, if a car still has empty seats.\\nCheck this:\\n[[3,1],[3,2],[1,0],[0,4],[0,5],[4,6],[5,7],[1,8],[6,9],[9,10],[4,11],[4,12]]\\nseats = 2\\n11th guy can sit in 12th\\'s car(or vice versa) at junction 4."
                    },
                    {
                        "username": "SG-C",
                        "content": "Today forecast Possibility of heavy rain so please stay at home do not go outside for any thing ! \\uD83D\\uDE01"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i am struggling with to find out when to create adjacency vector of n size and when of n+1  size  , how to get to know ."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "I always use an n sized adj list, can you give me an example where you needed n + 1 adj list"
                    }
                ]
            },
            {
                "id": 1797374,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Meeting only to hear they are laid off.\\n"
                    },
                    {
                        "username": "DebayudhCodes",
                        "content": "Can someone tell me why this code is giving me TLE ??\\nIt gives TLE on submit but doesnt give TLE when I run that same testcase...\\n\\nclass Solution {\\npublic:\\n    long long ans=0;\\n    int n=0;\\n    int dfs(vector<vector<int>> adj, int node, int prev, int seats){\\n        // if(vis[adj[node][0]] && adj[node].size()==1){\\n        //     ans++;\\n        //     return 1;\\n        // }\\n        int ct=1;\\n        for(auto it: adj[node]){\\n            if(it!=prev)\\n                ct+=dfs(adj,it,node, seats);\\n        }\\n        // long long cars=ct/seats;\\n        // if(ct%seats) \\n        //     cars++;\\n        if(node>0)    \\n            ans+= (ct + seats - 1) / seats;\\n        return ct;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        n=roads.size();\\n        if(n==0)\\n            return 0;\\n        ans=0;\\n        vector<vector<int>> adj(n+1);\\n        for(auto it:roads){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        // vector<bool> visited(n+1,0);\\n\\n        dfs(adj,0,-1,seats);\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Avoid passing the adjacency list by value, it gets copied with every function call. Pass it by (a constant) reference"
                    },
                    {
                        "username": "kmp1084",
                        "content": "All the companies that ask such questions have a hiring freeze!!! How unfortunate!"
                    },
                    {
                        "username": "jems1123",
                        "content": "every day we are getting graph"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Leetcode keeps reminding me that i have to learn graphs properly\\uD83D\\uDE3F"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The problem becomes quite easy, if the graph will be directed, in this case we just need to find the nodes with indegree == 0 and start traverse from them. But it\\'s not :)"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "TestCase:[[0,1],[0,2],[1,3],[1,4]]\nMy output:5\nExpected Output:4\nwhy? Expecte output should be 5,can anyone tell why expected output is 4\nAnyone Help"
                    },
                    {
                        "username": "harshithvh",
                        "content": "TF!! representatives can also switch their cars in between, if a car still has empty seats.\\nCheck this:\\n[[3,1],[3,2],[1,0],[0,4],[0,5],[4,6],[5,7],[1,8],[6,9],[9,10],[4,11],[4,12]]\\nseats = 2\\n11th guy can sit in 12th\\'s car(or vice versa) at junction 4."
                    },
                    {
                        "username": "SG-C",
                        "content": "Today forecast Possibility of heavy rain so please stay at home do not go outside for any thing ! \\uD83D\\uDE01"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i am struggling with to find out when to create adjacency vector of n size and when of n+1  size  , how to get to know ."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "I always use an n sized adj list, can you give me an example where you needed n + 1 adj list"
                    }
                ]
            },
            {
                "id": 2054742,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Meeting only to hear they are laid off.\\n"
                    },
                    {
                        "username": "DebayudhCodes",
                        "content": "Can someone tell me why this code is giving me TLE ??\\nIt gives TLE on submit but doesnt give TLE when I run that same testcase...\\n\\nclass Solution {\\npublic:\\n    long long ans=0;\\n    int n=0;\\n    int dfs(vector<vector<int>> adj, int node, int prev, int seats){\\n        // if(vis[adj[node][0]] && adj[node].size()==1){\\n        //     ans++;\\n        //     return 1;\\n        // }\\n        int ct=1;\\n        for(auto it: adj[node]){\\n            if(it!=prev)\\n                ct+=dfs(adj,it,node, seats);\\n        }\\n        // long long cars=ct/seats;\\n        // if(ct%seats) \\n        //     cars++;\\n        if(node>0)    \\n            ans+= (ct + seats - 1) / seats;\\n        return ct;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        n=roads.size();\\n        if(n==0)\\n            return 0;\\n        ans=0;\\n        vector<vector<int>> adj(n+1);\\n        for(auto it:roads){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        // vector<bool> visited(n+1,0);\\n\\n        dfs(adj,0,-1,seats);\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Avoid passing the adjacency list by value, it gets copied with every function call. Pass it by (a constant) reference"
                    },
                    {
                        "username": "kmp1084",
                        "content": "All the companies that ask such questions have a hiring freeze!!! How unfortunate!"
                    },
                    {
                        "username": "jems1123",
                        "content": "every day we are getting graph"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Leetcode keeps reminding me that i have to learn graphs properly\\uD83D\\uDE3F"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The problem becomes quite easy, if the graph will be directed, in this case we just need to find the nodes with indegree == 0 and start traverse from them. But it\\'s not :)"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "TestCase:[[0,1],[0,2],[1,3],[1,4]]\nMy output:5\nExpected Output:4\nwhy? Expecte output should be 5,can anyone tell why expected output is 4\nAnyone Help"
                    },
                    {
                        "username": "harshithvh",
                        "content": "TF!! representatives can also switch their cars in between, if a car still has empty seats.\\nCheck this:\\n[[3,1],[3,2],[1,0],[0,4],[0,5],[4,6],[5,7],[1,8],[6,9],[9,10],[4,11],[4,12]]\\nseats = 2\\n11th guy can sit in 12th\\'s car(or vice versa) at junction 4."
                    },
                    {
                        "username": "SG-C",
                        "content": "Today forecast Possibility of heavy rain so please stay at home do not go outside for any thing ! \\uD83D\\uDE01"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i am struggling with to find out when to create adjacency vector of n size and when of n+1  size  , how to get to know ."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "I always use an n sized adj list, can you give me an example where you needed n + 1 adj list"
                    }
                ]
            },
            {
                "id": 2053505,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Meeting only to hear they are laid off.\\n"
                    },
                    {
                        "username": "DebayudhCodes",
                        "content": "Can someone tell me why this code is giving me TLE ??\\nIt gives TLE on submit but doesnt give TLE when I run that same testcase...\\n\\nclass Solution {\\npublic:\\n    long long ans=0;\\n    int n=0;\\n    int dfs(vector<vector<int>> adj, int node, int prev, int seats){\\n        // if(vis[adj[node][0]] && adj[node].size()==1){\\n        //     ans++;\\n        //     return 1;\\n        // }\\n        int ct=1;\\n        for(auto it: adj[node]){\\n            if(it!=prev)\\n                ct+=dfs(adj,it,node, seats);\\n        }\\n        // long long cars=ct/seats;\\n        // if(ct%seats) \\n        //     cars++;\\n        if(node>0)    \\n            ans+= (ct + seats - 1) / seats;\\n        return ct;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        n=roads.size();\\n        if(n==0)\\n            return 0;\\n        ans=0;\\n        vector<vector<int>> adj(n+1);\\n        for(auto it:roads){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        // vector<bool> visited(n+1,0);\\n\\n        dfs(adj,0,-1,seats);\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Avoid passing the adjacency list by value, it gets copied with every function call. Pass it by (a constant) reference"
                    },
                    {
                        "username": "kmp1084",
                        "content": "All the companies that ask such questions have a hiring freeze!!! How unfortunate!"
                    },
                    {
                        "username": "jems1123",
                        "content": "every day we are getting graph"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Leetcode keeps reminding me that i have to learn graphs properly\\uD83D\\uDE3F"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The problem becomes quite easy, if the graph will be directed, in this case we just need to find the nodes with indegree == 0 and start traverse from them. But it\\'s not :)"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "TestCase:[[0,1],[0,2],[1,3],[1,4]]\nMy output:5\nExpected Output:4\nwhy? Expecte output should be 5,can anyone tell why expected output is 4\nAnyone Help"
                    },
                    {
                        "username": "harshithvh",
                        "content": "TF!! representatives can also switch their cars in between, if a car still has empty seats.\\nCheck this:\\n[[3,1],[3,2],[1,0],[0,4],[0,5],[4,6],[5,7],[1,8],[6,9],[9,10],[4,11],[4,12]]\\nseats = 2\\n11th guy can sit in 12th\\'s car(or vice versa) at junction 4."
                    },
                    {
                        "username": "SG-C",
                        "content": "Today forecast Possibility of heavy rain so please stay at home do not go outside for any thing ! \\uD83D\\uDE01"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i am struggling with to find out when to create adjacency vector of n size and when of n+1  size  , how to get to know ."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "I always use an n sized adj list, can you give me an example where you needed n + 1 adj list"
                    }
                ]
            },
            {
                "id": 2031415,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Meeting only to hear they are laid off.\\n"
                    },
                    {
                        "username": "DebayudhCodes",
                        "content": "Can someone tell me why this code is giving me TLE ??\\nIt gives TLE on submit but doesnt give TLE when I run that same testcase...\\n\\nclass Solution {\\npublic:\\n    long long ans=0;\\n    int n=0;\\n    int dfs(vector<vector<int>> adj, int node, int prev, int seats){\\n        // if(vis[adj[node][0]] && adj[node].size()==1){\\n        //     ans++;\\n        //     return 1;\\n        // }\\n        int ct=1;\\n        for(auto it: adj[node]){\\n            if(it!=prev)\\n                ct+=dfs(adj,it,node, seats);\\n        }\\n        // long long cars=ct/seats;\\n        // if(ct%seats) \\n        //     cars++;\\n        if(node>0)    \\n            ans+= (ct + seats - 1) / seats;\\n        return ct;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        n=roads.size();\\n        if(n==0)\\n            return 0;\\n        ans=0;\\n        vector<vector<int>> adj(n+1);\\n        for(auto it:roads){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        // vector<bool> visited(n+1,0);\\n\\n        dfs(adj,0,-1,seats);\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Avoid passing the adjacency list by value, it gets copied with every function call. Pass it by (a constant) reference"
                    },
                    {
                        "username": "kmp1084",
                        "content": "All the companies that ask such questions have a hiring freeze!!! How unfortunate!"
                    },
                    {
                        "username": "jems1123",
                        "content": "every day we are getting graph"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Leetcode keeps reminding me that i have to learn graphs properly\\uD83D\\uDE3F"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The problem becomes quite easy, if the graph will be directed, in this case we just need to find the nodes with indegree == 0 and start traverse from them. But it\\'s not :)"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "TestCase:[[0,1],[0,2],[1,3],[1,4]]\nMy output:5\nExpected Output:4\nwhy? Expecte output should be 5,can anyone tell why expected output is 4\nAnyone Help"
                    },
                    {
                        "username": "harshithvh",
                        "content": "TF!! representatives can also switch their cars in between, if a car still has empty seats.\\nCheck this:\\n[[3,1],[3,2],[1,0],[0,4],[0,5],[4,6],[5,7],[1,8],[6,9],[9,10],[4,11],[4,12]]\\nseats = 2\\n11th guy can sit in 12th\\'s car(or vice versa) at junction 4."
                    },
                    {
                        "username": "SG-C",
                        "content": "Today forecast Possibility of heavy rain so please stay at home do not go outside for any thing ! \\uD83D\\uDE01"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i am struggling with to find out when to create adjacency vector of n size and when of n+1  size  , how to get to know ."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "I always use an n sized adj list, can you give me an example where you needed n + 1 adj list"
                    }
                ]
            },
            {
                "id": 1951501,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Meeting only to hear they are laid off.\\n"
                    },
                    {
                        "username": "DebayudhCodes",
                        "content": "Can someone tell me why this code is giving me TLE ??\\nIt gives TLE on submit but doesnt give TLE when I run that same testcase...\\n\\nclass Solution {\\npublic:\\n    long long ans=0;\\n    int n=0;\\n    int dfs(vector<vector<int>> adj, int node, int prev, int seats){\\n        // if(vis[adj[node][0]] && adj[node].size()==1){\\n        //     ans++;\\n        //     return 1;\\n        // }\\n        int ct=1;\\n        for(auto it: adj[node]){\\n            if(it!=prev)\\n                ct+=dfs(adj,it,node, seats);\\n        }\\n        // long long cars=ct/seats;\\n        // if(ct%seats) \\n        //     cars++;\\n        if(node>0)    \\n            ans+= (ct + seats - 1) / seats;\\n        return ct;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        n=roads.size();\\n        if(n==0)\\n            return 0;\\n        ans=0;\\n        vector<vector<int>> adj(n+1);\\n        for(auto it:roads){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        // vector<bool> visited(n+1,0);\\n\\n        dfs(adj,0,-1,seats);\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Avoid passing the adjacency list by value, it gets copied with every function call. Pass it by (a constant) reference"
                    },
                    {
                        "username": "kmp1084",
                        "content": "All the companies that ask such questions have a hiring freeze!!! How unfortunate!"
                    },
                    {
                        "username": "jems1123",
                        "content": "every day we are getting graph"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Leetcode keeps reminding me that i have to learn graphs properly\\uD83D\\uDE3F"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The problem becomes quite easy, if the graph will be directed, in this case we just need to find the nodes with indegree == 0 and start traverse from them. But it\\'s not :)"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "TestCase:[[0,1],[0,2],[1,3],[1,4]]\nMy output:5\nExpected Output:4\nwhy? Expecte output should be 5,can anyone tell why expected output is 4\nAnyone Help"
                    },
                    {
                        "username": "harshithvh",
                        "content": "TF!! representatives can also switch their cars in between, if a car still has empty seats.\\nCheck this:\\n[[3,1],[3,2],[1,0],[0,4],[0,5],[4,6],[5,7],[1,8],[6,9],[9,10],[4,11],[4,12]]\\nseats = 2\\n11th guy can sit in 12th\\'s car(or vice versa) at junction 4."
                    },
                    {
                        "username": "SG-C",
                        "content": "Today forecast Possibility of heavy rain so please stay at home do not go outside for any thing ! \\uD83D\\uDE01"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i am struggling with to find out when to create adjacency vector of n size and when of n+1  size  , how to get to know ."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "I always use an n sized adj list, can you give me an example where you needed n + 1 adj list"
                    }
                ]
            },
            {
                "id": 1825342,
                "content": [
                    {
                        "username": "sanskar01",
                        "content": "Meeting only to hear they are laid off.\\n"
                    },
                    {
                        "username": "DebayudhCodes",
                        "content": "Can someone tell me why this code is giving me TLE ??\\nIt gives TLE on submit but doesnt give TLE when I run that same testcase...\\n\\nclass Solution {\\npublic:\\n    long long ans=0;\\n    int n=0;\\n    int dfs(vector<vector<int>> adj, int node, int prev, int seats){\\n        // if(vis[adj[node][0]] && adj[node].size()==1){\\n        //     ans++;\\n        //     return 1;\\n        // }\\n        int ct=1;\\n        for(auto it: adj[node]){\\n            if(it!=prev)\\n                ct+=dfs(adj,it,node, seats);\\n        }\\n        // long long cars=ct/seats;\\n        // if(ct%seats) \\n        //     cars++;\\n        if(node>0)    \\n            ans+= (ct + seats - 1) / seats;\\n        return ct;\\n    }\\n\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        n=roads.size();\\n        if(n==0)\\n            return 0;\\n        ans=0;\\n        vector<vector<int>> adj(n+1);\\n        for(auto it:roads){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        // vector<bool> visited(n+1,0);\\n\\n        dfs(adj,0,-1,seats);\\n        return ans;\\n\\n    }\\n};"
                    },
                    {
                        "username": "theRadFad",
                        "content": "Avoid passing the adjacency list by value, it gets copied with every function call. Pass it by (a constant) reference"
                    },
                    {
                        "username": "kmp1084",
                        "content": "All the companies that ask such questions have a hiring freeze!!! How unfortunate!"
                    },
                    {
                        "username": "jems1123",
                        "content": "every day we are getting graph"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Leetcode keeps reminding me that i have to learn graphs properly\\uD83D\\uDE3F"
                    },
                    {
                        "username": "subscriber6436",
                        "content": "The problem becomes quite easy, if the graph will be directed, in this case we just need to find the nodes with indegree == 0 and start traverse from them. But it\\'s not :)"
                    },
                    {
                        "username": "Jayesh_06",
                        "content": "TestCase:[[0,1],[0,2],[1,3],[1,4]]\nMy output:5\nExpected Output:4\nwhy? Expecte output should be 5,can anyone tell why expected output is 4\nAnyone Help"
                    },
                    {
                        "username": "harshithvh",
                        "content": "TF!! representatives can also switch their cars in between, if a car still has empty seats.\\nCheck this:\\n[[3,1],[3,2],[1,0],[0,4],[0,5],[4,6],[5,7],[1,8],[6,9],[9,10],[4,11],[4,12]]\\nseats = 2\\n11th guy can sit in 12th\\'s car(or vice versa) at junction 4."
                    },
                    {
                        "username": "SG-C",
                        "content": "Today forecast Possibility of heavy rain so please stay at home do not go outside for any thing ! \\uD83D\\uDE01"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "i am struggling with to find out when to create adjacency vector of n size and when of n+1  size  , how to get to know ."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "I always use an n sized adj list, can you give me an example where you needed n + 1 adj list"
                    }
                ]
            },
            {
                "id": 1804510,
                "content": [
                    {
                        "username": "user6266U",
                        "content": " `class Solution {\\npublic:\\n\\n    int solve(vector<vector<int>> graph, int n, int &res, \\n    int city, int seats, vector<bool> visited){\\n\\n        if(city != 0 and graph.at(city).size() == 1){\\n            return 1;\\n        }\\n        \\n        int passengers = 0;\\n        for(int c : graph.at(city)){\\n            if(!visited.at(c)){\\n            visited.at(c) = true;\\n            int cpassengers = solve(graph, n, res, c, seats, visited);\\n            res+=ceil(float(cpassengers)/float(seats));\\n            passengers+=cpassengers;\\n            \\n            }\\n        }\\n        return passengers+1;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n = roads.size();\\n        vector<vector<int>> graph(n+1);\\n        if(n==1)\\n        return 0;\\n\\n        for(int i=0;i<n;i++){\\n            graph.at(roads.at(i).at(0)).push_back(roads.at(i).at(1));\\n            graph.at(roads.at(i).at(1)).push_back(roads.at(i).at(0));\\n        }\\n\\n        vector<bool> visited(n+1, false);\\n\\n        int res = 0;\\n        visited.at(0) = true;\\n        solve(graph, n, res, 0,seats, visited);\\n        return res;\\n        \\n    }\\n};`\\n\\nwhy is this giving TLE on test case 109?"
                    },
                    {
                        "username": "itzShady4u",
                        "content": "why am I stuck at 130/131 test case!!!!!"
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Their explanation is very very bad and poor English. WHy? because they did not mention anything about the seat in their examples. So in the example 2, they should say:  representative 2 goes directly to city3 and because seat = 2 hence representative 3 can go with 2(to save fuel), and then they go to the city 1. But because the seat only is 2 (and now we have representative 2 and 3) hence this car cannot add representative 1 anymore, that mean representative 1 must go by his own car. then from city 1 to city 0. There are 2 cars and cost each car 1 fuel to reach city 0. Please, leetcode, please explain for us to understand what you really want us to do. And please add information that: maximum is 1 representative in each city (we do not have any information about it.)"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I managed to solve the problem by working in reverse, and finding minimum fuel to necessary to send all the representatives back home. Used BFS & DFS to do so."
                    },
                    {
                        "username": "saha15_5764",
                        "content": "This problem is solved by using BFS and some mathematical calculation. Like when I go out my city and reach another city if seat is available then the representative don\\'t need to go another car I can ride him like when I am coming towards capital my car has 2 sites and I meet 5 city so car is needed 5/2 = 2 + 1 = 3\\nwhen I go one city to another city car need 1 Litter of fuel, so coming to every city we need the care times fuel"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "its a good example of importance of keeping things clear in your head while solving problem.. and a good example of occam\\'s razor"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "wasted my time on this question, test cases are not satisfactory and problem statement doest specify if two person can meet at one place and use each other\\'s vehicle."
                    },
                    {
                        "username": "me__nik",
                        "content": "can anyone tell me, wt i am doing wrong here? Below testcase giving me wrong answer.\nBasically the approach is updating a global answer through dfs traversal.\n\nInput:\nroads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]]\nseats = 2\n\nOutput: 11\nExpected : 7\n\n```\nclass Solution {\npublic:\n    long long ans = 0;\n    long long dfs(vector<vector<int>>& v, int curr, vector<bool>& visited, int seats){\n        long long cnt = 1;\n        visited[curr] = 1;\n        for(int i = 0; i<v[curr].size(); i++){\n            curr = v[curr][i];\n\n            if(!visited[curr]){\n                cnt+=dfs(v, curr, visited, seats);\n            }\n        }\n        long long x = cnt/seats;\n        if(cnt%seats) x++;\n        if(curr!=0) ans+=x;\n        return cnt;\n    }\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\n        int n = roads.size();\n        vector<bool> visited(n+1, 0);\n        vector<vector<int>> v(n+1);\n        ans = 0;\n        \n        if(n==0) return 0;\n\n        for(int i = 0; i<n; i++){\n            int x = roads[i][0], y = roads[i][1];\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n        dfs(v, 0, visited, seats);\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I spent half a day on this problem. Considering cities with more than 3 roads as a transit point, people will come here and rearrange their cars to move on. The hardest part for me right now is the implementation."
                    },
                    {
                        "username": "Subhankar752",
                        "content": "Can anyone explain how number of cars is equal to the number of litres of fuel?"
                    }
                ]
            },
            {
                "id": 1801155,
                "content": [
                    {
                        "username": "user6266U",
                        "content": " `class Solution {\\npublic:\\n\\n    int solve(vector<vector<int>> graph, int n, int &res, \\n    int city, int seats, vector<bool> visited){\\n\\n        if(city != 0 and graph.at(city).size() == 1){\\n            return 1;\\n        }\\n        \\n        int passengers = 0;\\n        for(int c : graph.at(city)){\\n            if(!visited.at(c)){\\n            visited.at(c) = true;\\n            int cpassengers = solve(graph, n, res, c, seats, visited);\\n            res+=ceil(float(cpassengers)/float(seats));\\n            passengers+=cpassengers;\\n            \\n            }\\n        }\\n        return passengers+1;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n = roads.size();\\n        vector<vector<int>> graph(n+1);\\n        if(n==1)\\n        return 0;\\n\\n        for(int i=0;i<n;i++){\\n            graph.at(roads.at(i).at(0)).push_back(roads.at(i).at(1));\\n            graph.at(roads.at(i).at(1)).push_back(roads.at(i).at(0));\\n        }\\n\\n        vector<bool> visited(n+1, false);\\n\\n        int res = 0;\\n        visited.at(0) = true;\\n        solve(graph, n, res, 0,seats, visited);\\n        return res;\\n        \\n    }\\n};`\\n\\nwhy is this giving TLE on test case 109?"
                    },
                    {
                        "username": "itzShady4u",
                        "content": "why am I stuck at 130/131 test case!!!!!"
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Their explanation is very very bad and poor English. WHy? because they did not mention anything about the seat in their examples. So in the example 2, they should say:  representative 2 goes directly to city3 and because seat = 2 hence representative 3 can go with 2(to save fuel), and then they go to the city 1. But because the seat only is 2 (and now we have representative 2 and 3) hence this car cannot add representative 1 anymore, that mean representative 1 must go by his own car. then from city 1 to city 0. There are 2 cars and cost each car 1 fuel to reach city 0. Please, leetcode, please explain for us to understand what you really want us to do. And please add information that: maximum is 1 representative in each city (we do not have any information about it.)"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I managed to solve the problem by working in reverse, and finding minimum fuel to necessary to send all the representatives back home. Used BFS & DFS to do so."
                    },
                    {
                        "username": "saha15_5764",
                        "content": "This problem is solved by using BFS and some mathematical calculation. Like when I go out my city and reach another city if seat is available then the representative don\\'t need to go another car I can ride him like when I am coming towards capital my car has 2 sites and I meet 5 city so car is needed 5/2 = 2 + 1 = 3\\nwhen I go one city to another city car need 1 Litter of fuel, so coming to every city we need the care times fuel"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "its a good example of importance of keeping things clear in your head while solving problem.. and a good example of occam\\'s razor"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "wasted my time on this question, test cases are not satisfactory and problem statement doest specify if two person can meet at one place and use each other\\'s vehicle."
                    },
                    {
                        "username": "me__nik",
                        "content": "can anyone tell me, wt i am doing wrong here? Below testcase giving me wrong answer.\nBasically the approach is updating a global answer through dfs traversal.\n\nInput:\nroads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]]\nseats = 2\n\nOutput: 11\nExpected : 7\n\n```\nclass Solution {\npublic:\n    long long ans = 0;\n    long long dfs(vector<vector<int>>& v, int curr, vector<bool>& visited, int seats){\n        long long cnt = 1;\n        visited[curr] = 1;\n        for(int i = 0; i<v[curr].size(); i++){\n            curr = v[curr][i];\n\n            if(!visited[curr]){\n                cnt+=dfs(v, curr, visited, seats);\n            }\n        }\n        long long x = cnt/seats;\n        if(cnt%seats) x++;\n        if(curr!=0) ans+=x;\n        return cnt;\n    }\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\n        int n = roads.size();\n        vector<bool> visited(n+1, 0);\n        vector<vector<int>> v(n+1);\n        ans = 0;\n        \n        if(n==0) return 0;\n\n        for(int i = 0; i<n; i++){\n            int x = roads[i][0], y = roads[i][1];\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n        dfs(v, 0, visited, seats);\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I spent half a day on this problem. Considering cities with more than 3 roads as a transit point, people will come here and rearrange their cars to move on. The hardest part for me right now is the implementation."
                    },
                    {
                        "username": "Subhankar752",
                        "content": "Can anyone explain how number of cars is equal to the number of litres of fuel?"
                    }
                ]
            },
            {
                "id": 1799800,
                "content": [
                    {
                        "username": "user6266U",
                        "content": " `class Solution {\\npublic:\\n\\n    int solve(vector<vector<int>> graph, int n, int &res, \\n    int city, int seats, vector<bool> visited){\\n\\n        if(city != 0 and graph.at(city).size() == 1){\\n            return 1;\\n        }\\n        \\n        int passengers = 0;\\n        for(int c : graph.at(city)){\\n            if(!visited.at(c)){\\n            visited.at(c) = true;\\n            int cpassengers = solve(graph, n, res, c, seats, visited);\\n            res+=ceil(float(cpassengers)/float(seats));\\n            passengers+=cpassengers;\\n            \\n            }\\n        }\\n        return passengers+1;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n = roads.size();\\n        vector<vector<int>> graph(n+1);\\n        if(n==1)\\n        return 0;\\n\\n        for(int i=0;i<n;i++){\\n            graph.at(roads.at(i).at(0)).push_back(roads.at(i).at(1));\\n            graph.at(roads.at(i).at(1)).push_back(roads.at(i).at(0));\\n        }\\n\\n        vector<bool> visited(n+1, false);\\n\\n        int res = 0;\\n        visited.at(0) = true;\\n        solve(graph, n, res, 0,seats, visited);\\n        return res;\\n        \\n    }\\n};`\\n\\nwhy is this giving TLE on test case 109?"
                    },
                    {
                        "username": "itzShady4u",
                        "content": "why am I stuck at 130/131 test case!!!!!"
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Their explanation is very very bad and poor English. WHy? because they did not mention anything about the seat in their examples. So in the example 2, they should say:  representative 2 goes directly to city3 and because seat = 2 hence representative 3 can go with 2(to save fuel), and then they go to the city 1. But because the seat only is 2 (and now we have representative 2 and 3) hence this car cannot add representative 1 anymore, that mean representative 1 must go by his own car. then from city 1 to city 0. There are 2 cars and cost each car 1 fuel to reach city 0. Please, leetcode, please explain for us to understand what you really want us to do. And please add information that: maximum is 1 representative in each city (we do not have any information about it.)"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I managed to solve the problem by working in reverse, and finding minimum fuel to necessary to send all the representatives back home. Used BFS & DFS to do so."
                    },
                    {
                        "username": "saha15_5764",
                        "content": "This problem is solved by using BFS and some mathematical calculation. Like when I go out my city and reach another city if seat is available then the representative don\\'t need to go another car I can ride him like when I am coming towards capital my car has 2 sites and I meet 5 city so car is needed 5/2 = 2 + 1 = 3\\nwhen I go one city to another city car need 1 Litter of fuel, so coming to every city we need the care times fuel"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "its a good example of importance of keeping things clear in your head while solving problem.. and a good example of occam\\'s razor"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "wasted my time on this question, test cases are not satisfactory and problem statement doest specify if two person can meet at one place and use each other\\'s vehicle."
                    },
                    {
                        "username": "me__nik",
                        "content": "can anyone tell me, wt i am doing wrong here? Below testcase giving me wrong answer.\nBasically the approach is updating a global answer through dfs traversal.\n\nInput:\nroads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]]\nseats = 2\n\nOutput: 11\nExpected : 7\n\n```\nclass Solution {\npublic:\n    long long ans = 0;\n    long long dfs(vector<vector<int>>& v, int curr, vector<bool>& visited, int seats){\n        long long cnt = 1;\n        visited[curr] = 1;\n        for(int i = 0; i<v[curr].size(); i++){\n            curr = v[curr][i];\n\n            if(!visited[curr]){\n                cnt+=dfs(v, curr, visited, seats);\n            }\n        }\n        long long x = cnt/seats;\n        if(cnt%seats) x++;\n        if(curr!=0) ans+=x;\n        return cnt;\n    }\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\n        int n = roads.size();\n        vector<bool> visited(n+1, 0);\n        vector<vector<int>> v(n+1);\n        ans = 0;\n        \n        if(n==0) return 0;\n\n        for(int i = 0; i<n; i++){\n            int x = roads[i][0], y = roads[i][1];\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n        dfs(v, 0, visited, seats);\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I spent half a day on this problem. Considering cities with more than 3 roads as a transit point, people will come here and rearrange their cars to move on. The hardest part for me right now is the implementation."
                    },
                    {
                        "username": "Subhankar752",
                        "content": "Can anyone explain how number of cars is equal to the number of litres of fuel?"
                    }
                ]
            },
            {
                "id": 1798636,
                "content": [
                    {
                        "username": "user6266U",
                        "content": " `class Solution {\\npublic:\\n\\n    int solve(vector<vector<int>> graph, int n, int &res, \\n    int city, int seats, vector<bool> visited){\\n\\n        if(city != 0 and graph.at(city).size() == 1){\\n            return 1;\\n        }\\n        \\n        int passengers = 0;\\n        for(int c : graph.at(city)){\\n            if(!visited.at(c)){\\n            visited.at(c) = true;\\n            int cpassengers = solve(graph, n, res, c, seats, visited);\\n            res+=ceil(float(cpassengers)/float(seats));\\n            passengers+=cpassengers;\\n            \\n            }\\n        }\\n        return passengers+1;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n = roads.size();\\n        vector<vector<int>> graph(n+1);\\n        if(n==1)\\n        return 0;\\n\\n        for(int i=0;i<n;i++){\\n            graph.at(roads.at(i).at(0)).push_back(roads.at(i).at(1));\\n            graph.at(roads.at(i).at(1)).push_back(roads.at(i).at(0));\\n        }\\n\\n        vector<bool> visited(n+1, false);\\n\\n        int res = 0;\\n        visited.at(0) = true;\\n        solve(graph, n, res, 0,seats, visited);\\n        return res;\\n        \\n    }\\n};`\\n\\nwhy is this giving TLE on test case 109?"
                    },
                    {
                        "username": "itzShady4u",
                        "content": "why am I stuck at 130/131 test case!!!!!"
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Their explanation is very very bad and poor English. WHy? because they did not mention anything about the seat in their examples. So in the example 2, they should say:  representative 2 goes directly to city3 and because seat = 2 hence representative 3 can go with 2(to save fuel), and then they go to the city 1. But because the seat only is 2 (and now we have representative 2 and 3) hence this car cannot add representative 1 anymore, that mean representative 1 must go by his own car. then from city 1 to city 0. There are 2 cars and cost each car 1 fuel to reach city 0. Please, leetcode, please explain for us to understand what you really want us to do. And please add information that: maximum is 1 representative in each city (we do not have any information about it.)"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I managed to solve the problem by working in reverse, and finding minimum fuel to necessary to send all the representatives back home. Used BFS & DFS to do so."
                    },
                    {
                        "username": "saha15_5764",
                        "content": "This problem is solved by using BFS and some mathematical calculation. Like when I go out my city and reach another city if seat is available then the representative don\\'t need to go another car I can ride him like when I am coming towards capital my car has 2 sites and I meet 5 city so car is needed 5/2 = 2 + 1 = 3\\nwhen I go one city to another city car need 1 Litter of fuel, so coming to every city we need the care times fuel"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "its a good example of importance of keeping things clear in your head while solving problem.. and a good example of occam\\'s razor"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "wasted my time on this question, test cases are not satisfactory and problem statement doest specify if two person can meet at one place and use each other\\'s vehicle."
                    },
                    {
                        "username": "me__nik",
                        "content": "can anyone tell me, wt i am doing wrong here? Below testcase giving me wrong answer.\nBasically the approach is updating a global answer through dfs traversal.\n\nInput:\nroads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]]\nseats = 2\n\nOutput: 11\nExpected : 7\n\n```\nclass Solution {\npublic:\n    long long ans = 0;\n    long long dfs(vector<vector<int>>& v, int curr, vector<bool>& visited, int seats){\n        long long cnt = 1;\n        visited[curr] = 1;\n        for(int i = 0; i<v[curr].size(); i++){\n            curr = v[curr][i];\n\n            if(!visited[curr]){\n                cnt+=dfs(v, curr, visited, seats);\n            }\n        }\n        long long x = cnt/seats;\n        if(cnt%seats) x++;\n        if(curr!=0) ans+=x;\n        return cnt;\n    }\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\n        int n = roads.size();\n        vector<bool> visited(n+1, 0);\n        vector<vector<int>> v(n+1);\n        ans = 0;\n        \n        if(n==0) return 0;\n\n        for(int i = 0; i<n; i++){\n            int x = roads[i][0], y = roads[i][1];\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n        dfs(v, 0, visited, seats);\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I spent half a day on this problem. Considering cities with more than 3 roads as a transit point, people will come here and rearrange their cars to move on. The hardest part for me right now is the implementation."
                    },
                    {
                        "username": "Subhankar752",
                        "content": "Can anyone explain how number of cars is equal to the number of litres of fuel?"
                    }
                ]
            },
            {
                "id": 1798473,
                "content": [
                    {
                        "username": "user6266U",
                        "content": " `class Solution {\\npublic:\\n\\n    int solve(vector<vector<int>> graph, int n, int &res, \\n    int city, int seats, vector<bool> visited){\\n\\n        if(city != 0 and graph.at(city).size() == 1){\\n            return 1;\\n        }\\n        \\n        int passengers = 0;\\n        for(int c : graph.at(city)){\\n            if(!visited.at(c)){\\n            visited.at(c) = true;\\n            int cpassengers = solve(graph, n, res, c, seats, visited);\\n            res+=ceil(float(cpassengers)/float(seats));\\n            passengers+=cpassengers;\\n            \\n            }\\n        }\\n        return passengers+1;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n = roads.size();\\n        vector<vector<int>> graph(n+1);\\n        if(n==1)\\n        return 0;\\n\\n        for(int i=0;i<n;i++){\\n            graph.at(roads.at(i).at(0)).push_back(roads.at(i).at(1));\\n            graph.at(roads.at(i).at(1)).push_back(roads.at(i).at(0));\\n        }\\n\\n        vector<bool> visited(n+1, false);\\n\\n        int res = 0;\\n        visited.at(0) = true;\\n        solve(graph, n, res, 0,seats, visited);\\n        return res;\\n        \\n    }\\n};`\\n\\nwhy is this giving TLE on test case 109?"
                    },
                    {
                        "username": "itzShady4u",
                        "content": "why am I stuck at 130/131 test case!!!!!"
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Their explanation is very very bad and poor English. WHy? because they did not mention anything about the seat in their examples. So in the example 2, they should say:  representative 2 goes directly to city3 and because seat = 2 hence representative 3 can go with 2(to save fuel), and then they go to the city 1. But because the seat only is 2 (and now we have representative 2 and 3) hence this car cannot add representative 1 anymore, that mean representative 1 must go by his own car. then from city 1 to city 0. There are 2 cars and cost each car 1 fuel to reach city 0. Please, leetcode, please explain for us to understand what you really want us to do. And please add information that: maximum is 1 representative in each city (we do not have any information about it.)"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I managed to solve the problem by working in reverse, and finding minimum fuel to necessary to send all the representatives back home. Used BFS & DFS to do so."
                    },
                    {
                        "username": "saha15_5764",
                        "content": "This problem is solved by using BFS and some mathematical calculation. Like when I go out my city and reach another city if seat is available then the representative don\\'t need to go another car I can ride him like when I am coming towards capital my car has 2 sites and I meet 5 city so car is needed 5/2 = 2 + 1 = 3\\nwhen I go one city to another city car need 1 Litter of fuel, so coming to every city we need the care times fuel"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "its a good example of importance of keeping things clear in your head while solving problem.. and a good example of occam\\'s razor"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "wasted my time on this question, test cases are not satisfactory and problem statement doest specify if two person can meet at one place and use each other\\'s vehicle."
                    },
                    {
                        "username": "me__nik",
                        "content": "can anyone tell me, wt i am doing wrong here? Below testcase giving me wrong answer.\nBasically the approach is updating a global answer through dfs traversal.\n\nInput:\nroads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]]\nseats = 2\n\nOutput: 11\nExpected : 7\n\n```\nclass Solution {\npublic:\n    long long ans = 0;\n    long long dfs(vector<vector<int>>& v, int curr, vector<bool>& visited, int seats){\n        long long cnt = 1;\n        visited[curr] = 1;\n        for(int i = 0; i<v[curr].size(); i++){\n            curr = v[curr][i];\n\n            if(!visited[curr]){\n                cnt+=dfs(v, curr, visited, seats);\n            }\n        }\n        long long x = cnt/seats;\n        if(cnt%seats) x++;\n        if(curr!=0) ans+=x;\n        return cnt;\n    }\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\n        int n = roads.size();\n        vector<bool> visited(n+1, 0);\n        vector<vector<int>> v(n+1);\n        ans = 0;\n        \n        if(n==0) return 0;\n\n        for(int i = 0; i<n; i++){\n            int x = roads[i][0], y = roads[i][1];\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n        dfs(v, 0, visited, seats);\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I spent half a day on this problem. Considering cities with more than 3 roads as a transit point, people will come here and rearrange their cars to move on. The hardest part for me right now is the implementation."
                    },
                    {
                        "username": "Subhankar752",
                        "content": "Can anyone explain how number of cars is equal to the number of litres of fuel?"
                    }
                ]
            },
            {
                "id": 1798189,
                "content": [
                    {
                        "username": "user6266U",
                        "content": " `class Solution {\\npublic:\\n\\n    int solve(vector<vector<int>> graph, int n, int &res, \\n    int city, int seats, vector<bool> visited){\\n\\n        if(city != 0 and graph.at(city).size() == 1){\\n            return 1;\\n        }\\n        \\n        int passengers = 0;\\n        for(int c : graph.at(city)){\\n            if(!visited.at(c)){\\n            visited.at(c) = true;\\n            int cpassengers = solve(graph, n, res, c, seats, visited);\\n            res+=ceil(float(cpassengers)/float(seats));\\n            passengers+=cpassengers;\\n            \\n            }\\n        }\\n        return passengers+1;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n = roads.size();\\n        vector<vector<int>> graph(n+1);\\n        if(n==1)\\n        return 0;\\n\\n        for(int i=0;i<n;i++){\\n            graph.at(roads.at(i).at(0)).push_back(roads.at(i).at(1));\\n            graph.at(roads.at(i).at(1)).push_back(roads.at(i).at(0));\\n        }\\n\\n        vector<bool> visited(n+1, false);\\n\\n        int res = 0;\\n        visited.at(0) = true;\\n        solve(graph, n, res, 0,seats, visited);\\n        return res;\\n        \\n    }\\n};`\\n\\nwhy is this giving TLE on test case 109?"
                    },
                    {
                        "username": "itzShady4u",
                        "content": "why am I stuck at 130/131 test case!!!!!"
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Their explanation is very very bad and poor English. WHy? because they did not mention anything about the seat in their examples. So in the example 2, they should say:  representative 2 goes directly to city3 and because seat = 2 hence representative 3 can go with 2(to save fuel), and then they go to the city 1. But because the seat only is 2 (and now we have representative 2 and 3) hence this car cannot add representative 1 anymore, that mean representative 1 must go by his own car. then from city 1 to city 0. There are 2 cars and cost each car 1 fuel to reach city 0. Please, leetcode, please explain for us to understand what you really want us to do. And please add information that: maximum is 1 representative in each city (we do not have any information about it.)"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I managed to solve the problem by working in reverse, and finding minimum fuel to necessary to send all the representatives back home. Used BFS & DFS to do so."
                    },
                    {
                        "username": "saha15_5764",
                        "content": "This problem is solved by using BFS and some mathematical calculation. Like when I go out my city and reach another city if seat is available then the representative don\\'t need to go another car I can ride him like when I am coming towards capital my car has 2 sites and I meet 5 city so car is needed 5/2 = 2 + 1 = 3\\nwhen I go one city to another city car need 1 Litter of fuel, so coming to every city we need the care times fuel"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "its a good example of importance of keeping things clear in your head while solving problem.. and a good example of occam\\'s razor"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "wasted my time on this question, test cases are not satisfactory and problem statement doest specify if two person can meet at one place and use each other\\'s vehicle."
                    },
                    {
                        "username": "me__nik",
                        "content": "can anyone tell me, wt i am doing wrong here? Below testcase giving me wrong answer.\nBasically the approach is updating a global answer through dfs traversal.\n\nInput:\nroads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]]\nseats = 2\n\nOutput: 11\nExpected : 7\n\n```\nclass Solution {\npublic:\n    long long ans = 0;\n    long long dfs(vector<vector<int>>& v, int curr, vector<bool>& visited, int seats){\n        long long cnt = 1;\n        visited[curr] = 1;\n        for(int i = 0; i<v[curr].size(); i++){\n            curr = v[curr][i];\n\n            if(!visited[curr]){\n                cnt+=dfs(v, curr, visited, seats);\n            }\n        }\n        long long x = cnt/seats;\n        if(cnt%seats) x++;\n        if(curr!=0) ans+=x;\n        return cnt;\n    }\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\n        int n = roads.size();\n        vector<bool> visited(n+1, 0);\n        vector<vector<int>> v(n+1);\n        ans = 0;\n        \n        if(n==0) return 0;\n\n        for(int i = 0; i<n; i++){\n            int x = roads[i][0], y = roads[i][1];\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n        dfs(v, 0, visited, seats);\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I spent half a day on this problem. Considering cities with more than 3 roads as a transit point, people will come here and rearrange their cars to move on. The hardest part for me right now is the implementation."
                    },
                    {
                        "username": "Subhankar752",
                        "content": "Can anyone explain how number of cars is equal to the number of litres of fuel?"
                    }
                ]
            },
            {
                "id": 1798094,
                "content": [
                    {
                        "username": "user6266U",
                        "content": " `class Solution {\\npublic:\\n\\n    int solve(vector<vector<int>> graph, int n, int &res, \\n    int city, int seats, vector<bool> visited){\\n\\n        if(city != 0 and graph.at(city).size() == 1){\\n            return 1;\\n        }\\n        \\n        int passengers = 0;\\n        for(int c : graph.at(city)){\\n            if(!visited.at(c)){\\n            visited.at(c) = true;\\n            int cpassengers = solve(graph, n, res, c, seats, visited);\\n            res+=ceil(float(cpassengers)/float(seats));\\n            passengers+=cpassengers;\\n            \\n            }\\n        }\\n        return passengers+1;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n = roads.size();\\n        vector<vector<int>> graph(n+1);\\n        if(n==1)\\n        return 0;\\n\\n        for(int i=0;i<n;i++){\\n            graph.at(roads.at(i).at(0)).push_back(roads.at(i).at(1));\\n            graph.at(roads.at(i).at(1)).push_back(roads.at(i).at(0));\\n        }\\n\\n        vector<bool> visited(n+1, false);\\n\\n        int res = 0;\\n        visited.at(0) = true;\\n        solve(graph, n, res, 0,seats, visited);\\n        return res;\\n        \\n    }\\n};`\\n\\nwhy is this giving TLE on test case 109?"
                    },
                    {
                        "username": "itzShady4u",
                        "content": "why am I stuck at 130/131 test case!!!!!"
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Their explanation is very very bad and poor English. WHy? because they did not mention anything about the seat in their examples. So in the example 2, they should say:  representative 2 goes directly to city3 and because seat = 2 hence representative 3 can go with 2(to save fuel), and then they go to the city 1. But because the seat only is 2 (and now we have representative 2 and 3) hence this car cannot add representative 1 anymore, that mean representative 1 must go by his own car. then from city 1 to city 0. There are 2 cars and cost each car 1 fuel to reach city 0. Please, leetcode, please explain for us to understand what you really want us to do. And please add information that: maximum is 1 representative in each city (we do not have any information about it.)"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I managed to solve the problem by working in reverse, and finding minimum fuel to necessary to send all the representatives back home. Used BFS & DFS to do so."
                    },
                    {
                        "username": "saha15_5764",
                        "content": "This problem is solved by using BFS and some mathematical calculation. Like when I go out my city and reach another city if seat is available then the representative don\\'t need to go another car I can ride him like when I am coming towards capital my car has 2 sites and I meet 5 city so car is needed 5/2 = 2 + 1 = 3\\nwhen I go one city to another city car need 1 Litter of fuel, so coming to every city we need the care times fuel"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "its a good example of importance of keeping things clear in your head while solving problem.. and a good example of occam\\'s razor"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "wasted my time on this question, test cases are not satisfactory and problem statement doest specify if two person can meet at one place and use each other\\'s vehicle."
                    },
                    {
                        "username": "me__nik",
                        "content": "can anyone tell me, wt i am doing wrong here? Below testcase giving me wrong answer.\nBasically the approach is updating a global answer through dfs traversal.\n\nInput:\nroads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]]\nseats = 2\n\nOutput: 11\nExpected : 7\n\n```\nclass Solution {\npublic:\n    long long ans = 0;\n    long long dfs(vector<vector<int>>& v, int curr, vector<bool>& visited, int seats){\n        long long cnt = 1;\n        visited[curr] = 1;\n        for(int i = 0; i<v[curr].size(); i++){\n            curr = v[curr][i];\n\n            if(!visited[curr]){\n                cnt+=dfs(v, curr, visited, seats);\n            }\n        }\n        long long x = cnt/seats;\n        if(cnt%seats) x++;\n        if(curr!=0) ans+=x;\n        return cnt;\n    }\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\n        int n = roads.size();\n        vector<bool> visited(n+1, 0);\n        vector<vector<int>> v(n+1);\n        ans = 0;\n        \n        if(n==0) return 0;\n\n        for(int i = 0; i<n; i++){\n            int x = roads[i][0], y = roads[i][1];\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n        dfs(v, 0, visited, seats);\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I spent half a day on this problem. Considering cities with more than 3 roads as a transit point, people will come here and rearrange their cars to move on. The hardest part for me right now is the implementation."
                    },
                    {
                        "username": "Subhankar752",
                        "content": "Can anyone explain how number of cars is equal to the number of litres of fuel?"
                    }
                ]
            },
            {
                "id": 1798006,
                "content": [
                    {
                        "username": "user6266U",
                        "content": " `class Solution {\\npublic:\\n\\n    int solve(vector<vector<int>> graph, int n, int &res, \\n    int city, int seats, vector<bool> visited){\\n\\n        if(city != 0 and graph.at(city).size() == 1){\\n            return 1;\\n        }\\n        \\n        int passengers = 0;\\n        for(int c : graph.at(city)){\\n            if(!visited.at(c)){\\n            visited.at(c) = true;\\n            int cpassengers = solve(graph, n, res, c, seats, visited);\\n            res+=ceil(float(cpassengers)/float(seats));\\n            passengers+=cpassengers;\\n            \\n            }\\n        }\\n        return passengers+1;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n = roads.size();\\n        vector<vector<int>> graph(n+1);\\n        if(n==1)\\n        return 0;\\n\\n        for(int i=0;i<n;i++){\\n            graph.at(roads.at(i).at(0)).push_back(roads.at(i).at(1));\\n            graph.at(roads.at(i).at(1)).push_back(roads.at(i).at(0));\\n        }\\n\\n        vector<bool> visited(n+1, false);\\n\\n        int res = 0;\\n        visited.at(0) = true;\\n        solve(graph, n, res, 0,seats, visited);\\n        return res;\\n        \\n    }\\n};`\\n\\nwhy is this giving TLE on test case 109?"
                    },
                    {
                        "username": "itzShady4u",
                        "content": "why am I stuck at 130/131 test case!!!!!"
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Their explanation is very very bad and poor English. WHy? because they did not mention anything about the seat in their examples. So in the example 2, they should say:  representative 2 goes directly to city3 and because seat = 2 hence representative 3 can go with 2(to save fuel), and then they go to the city 1. But because the seat only is 2 (and now we have representative 2 and 3) hence this car cannot add representative 1 anymore, that mean representative 1 must go by his own car. then from city 1 to city 0. There are 2 cars and cost each car 1 fuel to reach city 0. Please, leetcode, please explain for us to understand what you really want us to do. And please add information that: maximum is 1 representative in each city (we do not have any information about it.)"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I managed to solve the problem by working in reverse, and finding minimum fuel to necessary to send all the representatives back home. Used BFS & DFS to do so."
                    },
                    {
                        "username": "saha15_5764",
                        "content": "This problem is solved by using BFS and some mathematical calculation. Like when I go out my city and reach another city if seat is available then the representative don\\'t need to go another car I can ride him like when I am coming towards capital my car has 2 sites and I meet 5 city so car is needed 5/2 = 2 + 1 = 3\\nwhen I go one city to another city car need 1 Litter of fuel, so coming to every city we need the care times fuel"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "its a good example of importance of keeping things clear in your head while solving problem.. and a good example of occam\\'s razor"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "wasted my time on this question, test cases are not satisfactory and problem statement doest specify if two person can meet at one place and use each other\\'s vehicle."
                    },
                    {
                        "username": "me__nik",
                        "content": "can anyone tell me, wt i am doing wrong here? Below testcase giving me wrong answer.\nBasically the approach is updating a global answer through dfs traversal.\n\nInput:\nroads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]]\nseats = 2\n\nOutput: 11\nExpected : 7\n\n```\nclass Solution {\npublic:\n    long long ans = 0;\n    long long dfs(vector<vector<int>>& v, int curr, vector<bool>& visited, int seats){\n        long long cnt = 1;\n        visited[curr] = 1;\n        for(int i = 0; i<v[curr].size(); i++){\n            curr = v[curr][i];\n\n            if(!visited[curr]){\n                cnt+=dfs(v, curr, visited, seats);\n            }\n        }\n        long long x = cnt/seats;\n        if(cnt%seats) x++;\n        if(curr!=0) ans+=x;\n        return cnt;\n    }\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\n        int n = roads.size();\n        vector<bool> visited(n+1, 0);\n        vector<vector<int>> v(n+1);\n        ans = 0;\n        \n        if(n==0) return 0;\n\n        for(int i = 0; i<n; i++){\n            int x = roads[i][0], y = roads[i][1];\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n        dfs(v, 0, visited, seats);\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I spent half a day on this problem. Considering cities with more than 3 roads as a transit point, people will come here and rearrange their cars to move on. The hardest part for me right now is the implementation."
                    },
                    {
                        "username": "Subhankar752",
                        "content": "Can anyone explain how number of cars is equal to the number of litres of fuel?"
                    }
                ]
            },
            {
                "id": 1797898,
                "content": [
                    {
                        "username": "user6266U",
                        "content": " `class Solution {\\npublic:\\n\\n    int solve(vector<vector<int>> graph, int n, int &res, \\n    int city, int seats, vector<bool> visited){\\n\\n        if(city != 0 and graph.at(city).size() == 1){\\n            return 1;\\n        }\\n        \\n        int passengers = 0;\\n        for(int c : graph.at(city)){\\n            if(!visited.at(c)){\\n            visited.at(c) = true;\\n            int cpassengers = solve(graph, n, res, c, seats, visited);\\n            res+=ceil(float(cpassengers)/float(seats));\\n            passengers+=cpassengers;\\n            \\n            }\\n        }\\n        return passengers+1;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n = roads.size();\\n        vector<vector<int>> graph(n+1);\\n        if(n==1)\\n        return 0;\\n\\n        for(int i=0;i<n;i++){\\n            graph.at(roads.at(i).at(0)).push_back(roads.at(i).at(1));\\n            graph.at(roads.at(i).at(1)).push_back(roads.at(i).at(0));\\n        }\\n\\n        vector<bool> visited(n+1, false);\\n\\n        int res = 0;\\n        visited.at(0) = true;\\n        solve(graph, n, res, 0,seats, visited);\\n        return res;\\n        \\n    }\\n};`\\n\\nwhy is this giving TLE on test case 109?"
                    },
                    {
                        "username": "itzShady4u",
                        "content": "why am I stuck at 130/131 test case!!!!!"
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Their explanation is very very bad and poor English. WHy? because they did not mention anything about the seat in their examples. So in the example 2, they should say:  representative 2 goes directly to city3 and because seat = 2 hence representative 3 can go with 2(to save fuel), and then they go to the city 1. But because the seat only is 2 (and now we have representative 2 and 3) hence this car cannot add representative 1 anymore, that mean representative 1 must go by his own car. then from city 1 to city 0. There are 2 cars and cost each car 1 fuel to reach city 0. Please, leetcode, please explain for us to understand what you really want us to do. And please add information that: maximum is 1 representative in each city (we do not have any information about it.)"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I managed to solve the problem by working in reverse, and finding minimum fuel to necessary to send all the representatives back home. Used BFS & DFS to do so."
                    },
                    {
                        "username": "saha15_5764",
                        "content": "This problem is solved by using BFS and some mathematical calculation. Like when I go out my city and reach another city if seat is available then the representative don\\'t need to go another car I can ride him like when I am coming towards capital my car has 2 sites and I meet 5 city so car is needed 5/2 = 2 + 1 = 3\\nwhen I go one city to another city car need 1 Litter of fuel, so coming to every city we need the care times fuel"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "its a good example of importance of keeping things clear in your head while solving problem.. and a good example of occam\\'s razor"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "wasted my time on this question, test cases are not satisfactory and problem statement doest specify if two person can meet at one place and use each other\\'s vehicle."
                    },
                    {
                        "username": "me__nik",
                        "content": "can anyone tell me, wt i am doing wrong here? Below testcase giving me wrong answer.\nBasically the approach is updating a global answer through dfs traversal.\n\nInput:\nroads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]]\nseats = 2\n\nOutput: 11\nExpected : 7\n\n```\nclass Solution {\npublic:\n    long long ans = 0;\n    long long dfs(vector<vector<int>>& v, int curr, vector<bool>& visited, int seats){\n        long long cnt = 1;\n        visited[curr] = 1;\n        for(int i = 0; i<v[curr].size(); i++){\n            curr = v[curr][i];\n\n            if(!visited[curr]){\n                cnt+=dfs(v, curr, visited, seats);\n            }\n        }\n        long long x = cnt/seats;\n        if(cnt%seats) x++;\n        if(curr!=0) ans+=x;\n        return cnt;\n    }\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\n        int n = roads.size();\n        vector<bool> visited(n+1, 0);\n        vector<vector<int>> v(n+1);\n        ans = 0;\n        \n        if(n==0) return 0;\n\n        for(int i = 0; i<n; i++){\n            int x = roads[i][0], y = roads[i][1];\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n        dfs(v, 0, visited, seats);\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I spent half a day on this problem. Considering cities with more than 3 roads as a transit point, people will come here and rearrange their cars to move on. The hardest part for me right now is the implementation."
                    },
                    {
                        "username": "Subhankar752",
                        "content": "Can anyone explain how number of cars is equal to the number of litres of fuel?"
                    }
                ]
            },
            {
                "id": 1797765,
                "content": [
                    {
                        "username": "user6266U",
                        "content": " `class Solution {\\npublic:\\n\\n    int solve(vector<vector<int>> graph, int n, int &res, \\n    int city, int seats, vector<bool> visited){\\n\\n        if(city != 0 and graph.at(city).size() == 1){\\n            return 1;\\n        }\\n        \\n        int passengers = 0;\\n        for(int c : graph.at(city)){\\n            if(!visited.at(c)){\\n            visited.at(c) = true;\\n            int cpassengers = solve(graph, n, res, c, seats, visited);\\n            res+=ceil(float(cpassengers)/float(seats));\\n            passengers+=cpassengers;\\n            \\n            }\\n        }\\n        return passengers+1;\\n    }\\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\\n        \\n        int n = roads.size();\\n        vector<vector<int>> graph(n+1);\\n        if(n==1)\\n        return 0;\\n\\n        for(int i=0;i<n;i++){\\n            graph.at(roads.at(i).at(0)).push_back(roads.at(i).at(1));\\n            graph.at(roads.at(i).at(1)).push_back(roads.at(i).at(0));\\n        }\\n\\n        vector<bool> visited(n+1, false);\\n\\n        int res = 0;\\n        visited.at(0) = true;\\n        solve(graph, n, res, 0,seats, visited);\\n        return res;\\n        \\n    }\\n};`\\n\\nwhy is this giving TLE on test case 109?"
                    },
                    {
                        "username": "itzShady4u",
                        "content": "why am I stuck at 130/131 test case!!!!!"
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Their explanation is very very bad and poor English. WHy? because they did not mention anything about the seat in their examples. So in the example 2, they should say:  representative 2 goes directly to city3 and because seat = 2 hence representative 3 can go with 2(to save fuel), and then they go to the city 1. But because the seat only is 2 (and now we have representative 2 and 3) hence this car cannot add representative 1 anymore, that mean representative 1 must go by his own car. then from city 1 to city 0. There are 2 cars and cost each car 1 fuel to reach city 0. Please, leetcode, please explain for us to understand what you really want us to do. And please add information that: maximum is 1 representative in each city (we do not have any information about it.)"
                    },
                    {
                        "username": "AMerrill",
                        "content": "I managed to solve the problem by working in reverse, and finding minimum fuel to necessary to send all the representatives back home. Used BFS & DFS to do so."
                    },
                    {
                        "username": "saha15_5764",
                        "content": "This problem is solved by using BFS and some mathematical calculation. Like when I go out my city and reach another city if seat is available then the representative don\\'t need to go another car I can ride him like when I am coming towards capital my car has 2 sites and I meet 5 city so car is needed 5/2 = 2 + 1 = 3\\nwhen I go one city to another city car need 1 Litter of fuel, so coming to every city we need the care times fuel"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "its a good example of importance of keeping things clear in your head while solving problem.. and a good example of occam\\'s razor"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "wasted my time on this question, test cases are not satisfactory and problem statement doest specify if two person can meet at one place and use each other\\'s vehicle."
                    },
                    {
                        "username": "me__nik",
                        "content": "can anyone tell me, wt i am doing wrong here? Below testcase giving me wrong answer.\nBasically the approach is updating a global answer through dfs traversal.\n\nInput:\nroads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]]\nseats = 2\n\nOutput: 11\nExpected : 7\n\n```\nclass Solution {\npublic:\n    long long ans = 0;\n    long long dfs(vector<vector<int>>& v, int curr, vector<bool>& visited, int seats){\n        long long cnt = 1;\n        visited[curr] = 1;\n        for(int i = 0; i<v[curr].size(); i++){\n            curr = v[curr][i];\n\n            if(!visited[curr]){\n                cnt+=dfs(v, curr, visited, seats);\n            }\n        }\n        long long x = cnt/seats;\n        if(cnt%seats) x++;\n        if(curr!=0) ans+=x;\n        return cnt;\n    }\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\n        int n = roads.size();\n        vector<bool> visited(n+1, 0);\n        vector<vector<int>> v(n+1);\n        ans = 0;\n        \n        if(n==0) return 0;\n\n        for(int i = 0; i<n; i++){\n            int x = roads[i][0], y = roads[i][1];\n            v[x].push_back(y);\n            v[y].push_back(x);\n        }\n        dfs(v, 0, visited, seats);\n        return ans;\n    }\n};"
                    },
                    {
                        "username": "hoangnn451",
                        "content": "I spent half a day on this problem. Considering cities with more than 3 roads as a transit point, people will come here and rearrange their cars to move on. The hardest part for me right now is the implementation."
                    },
                    {
                        "username": "Subhankar752",
                        "content": "Can anyone explain how number of cars is equal to the number of litres of fuel?"
                    }
                ]
            }
        ]
    }
]