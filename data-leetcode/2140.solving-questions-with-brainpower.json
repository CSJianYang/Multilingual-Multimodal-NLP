[
    {
        "title": "Solving Questions With Brainpower",
        "question_content": "You are given a 0-indexed 2D integer array questions where questions[i] = [pointsi, brainpoweri].\nThe array describes the questions of an exam, where you have to process the questions in order (i.e., starting from question 0) and make a decision whether to solve or skip each question. Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions. If you skip question i, you get to make the decision on the next question.\n\n\tFor example, given questions = [[3, 2], [4, 3], [4, 4], [2, 5]]:\n\t\n\t\tIf question 0 is solved, you will earn 3 points but you will be unable to solve questions 1 and 2.\n\t\tIf instead, question 0 is skipped and question 1 is solved, you will earn 4 points but you will be unable to solve questions 2 and 3.\n\t\n\t\n\nReturn the maximum points you can earn for the exam.\n&nbsp;\nExample 1:\n\nInput: questions = [[3,2],[4,3],[4,4],[2,5]]\nOutput: 5\nExplanation: The maximum points can be earned by solving questions 0 and 3.\n- Solve question 0: Earn 3 points, will be unable to solve the next 2 questions\n- Unable to solve questions 1 and 2\n- Solve question 3: Earn 2 points\nTotal points earned: 3 + 2 = 5. There is no other way to earn 5 or more points.\n\nExample 2:\n\nInput: questions = [[1,1],[2,2],[3,3],[4,4],[5,5]]\nOutput: 7\nExplanation: The maximum points can be earned by solving questions 1 and 4.\n- Skip question 0\n- Solve question 1: Earn 2 points, will be unable to solve the next 2 questions\n- Unable to solve questions 2 and 3\n- Solve question 4: Earn 5 points\nTotal points earned: 2 + 5 = 7. There is no other way to earn 7 or more points.\n\n&nbsp;\nConstraints:\n\n\t1 <= questions.length <= 105\n\tquestions[i].length == 2\n\t1 <= pointsi, brainpoweri <= 105",
        "solutions": [
            {
                "id": 1692963,
                "title": "dp",
                "content": "Our `dp` array contains maximum points we get if we start from question `i`. \\n\\nWe calculate it going right to left, and the answer for position `i` is the maximum of:\\n- Take: `points[i] + dp[i + 1 + brainpower[i]]`,\\n- Skip: `dp[i + 1]`.\\n\\n**C++**\\nWe add a bunch of sentinel values to `dp` array to avoid the length check.\\n```cpp\\nlong long mostPoints(vector<vector<int>>& q) {\\n    long long dp[200001] = {};\\n    for (int i = q.size() - 1; i >= 0; --i)\\n        dp[i] = max(q[i][0] + dp[q[i][1] + i + 1], dp[i + 1]);\\n    return dp[0];\\n}\\n```\\n**Python 3**\\nFor those who prefer a recursive approach.\\n\\n```python\\nclass Solution:\\n    def mostPoints(self, q: List[List[int]]) -> int:\\n        @cache\\n        def dfs(i: int) -> int:\\n            return 0 if i >= len(q) else max(dfs(i + 1), q[i][0] + dfs(i + 1 + q[i][1]))\\n        return dfs(0)\\n```",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```cpp\\nlong long mostPoints(vector<vector<int>>& q) {\\n    long long dp[200001] = {};\\n    for (int i = q.size() - 1; i >= 0; --i)\\n        dp[i] = max(q[i][0] + dp[q[i][1] + i + 1], dp[i + 1]);\\n    return dp[0];\\n}\\n```\n```python\\nclass Solution:\\n    def mostPoints(self, q: List[List[int]]) -> int:\\n        @cache\\n        def dfs(i: int) -> int:\\n            return 0 if i >= len(q) else max(dfs(i + 1), q[i][0] + dfs(i + 1 + q[i][1]))\\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692920,
                "title": "python3-java-c-dfs-memoization-iterative-o-n",
                "content": "This is a typical dynamic programming problem. \\nFor each index `i` we have 2 options:\\n1. Take points<sub>i</sub>  and jump the next brainpower<sub>i</sub> indexes\\n2. Skip the current index(do not collect points<sub>i</sub>) and move to the next index\\n\\nWe need to find the maximum points we can collect given the above mentioned constraints\\n\\nNote: `dp[i]` denotes the max points that can be collected for the subarray: `questions[i... questions.size() - 1]`. So we only need to compute it once for each `i`\\n\\n**Dfs + Memoization**:\\n<iframe src=\"https://leetcode.com/playground/mLDWYTXM/shared\" frameBorder=\"0\" width=\"740\" height=\"275\"></iframe>\\n\\n**Iterative**:\\n<iframe src=\"https://leetcode.com/playground/BhdoVtcf/shared\" frameBorder=\"0\" width=\"740\" height=\"205\"></iframe>\\n\\n*Time Complextity: O(n)*\\n*Space Complexity: O(n)*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "This is a typical dynamic programming problem. \\nFor each index `i` we have 2 options:\\n1. Take points<sub>i</sub>  and jump the next brainpower<sub>i</sub> indexes\\n2. Skip the current index(do not collect points<sub>i</sub>) and move to the next index\\n\\nWe need to find the maximum points we can collect given the above mentioned constraints\\n\\nNote: `dp[i]` denotes the max points that can be collected for the subarray: `questions[i... questions.size() - 1]`. So we only need to compute it once for each `i`\\n\\n**Dfs + Memoization**:\\n<iframe src=\"https://leetcode.com/playground/mLDWYTXM/shared\" frameBorder=\"0\" width=\"740\" height=\"275\"></iframe>\\n\\n**Iterative**:\\n<iframe src=\"https://leetcode.com/playground/BhdoVtcf/shared\" frameBorder=\"0\" width=\"740\" height=\"205\"></iframe>\\n\\n*Time Complextity: O(n)*\\n*Space Complexity: O(n)*",
                "codeTag": "Unknown"
            },
            {
                "id": 3514181,
                "title": "image-explanation-recursion-memo-bottom-up-dp-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Solving Questions With Brainpower` by `Aryan Mittal`\\n![lc.png](https://assets.leetcode.com/users/images/ae5a6b7c-810a-4e23-939b-54ca59745427_1683855427.2222493.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/bc6f2da5-cd61-4668-a610-24c8ef0660cc_1683854788.4890034.png)\\n![image.png](https://assets.leetcode.com/users/images/7e5ec9c5-c854-4e93-8715-a1d3be900b9f_1683854797.0776916.png)\\n![image.png](https://assets.leetcode.com/users/images/842cd770-586f-4794-8baf-0bf4e7d6a020_1683854814.5070689.png)\\n![image.png](https://assets.leetcode.com/users/images/9738464c-cd3d-4467-828e-2d6cc1d57a07_1683854836.4135911.png)\\n![image.png](https://assets.leetcode.com/users/images/de263a7a-feac-4864-9517-07b33bfc881a_1683854847.0475883.png)\\n![image.png](https://assets.leetcode.com/users/images/978dc429-1a71-4c0e-b3e7-8e42a03b2bca_1683854858.2975023.png)\\n![image.png](https://assets.leetcode.com/users/images/1e1b8255-9848-417f-8ee3-823d390acfb2_1683854872.835333.png)\\n![image.png](https://assets.leetcode.com/users/images/1f2846df-9e49-4411-9b93-787edec1f023_1683854880.903566.png)\\n![image.png](https://assets.leetcode.com/users/images/d7a3e83e-2faf-4a26-bca1-8297aec18c93_1683854889.075166.png)\\n![image.png](https://assets.leetcode.com/users/images/27cca23f-234d-4dff-83a5-16029dc8be9a_1683854901.8978355.png)\\n\\n\\n# Code\\n```C++ []\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<ll> dp(n+1, 0);\\n        for(int i=n-1; i>=0 ;i--){\\n            int point = questions[i][0];\\n            int jump = questions[i][1];\\n\\n            int nextQuestion = min(n, i+jump+1);\\n            dp[i] = max(dp[i+1], point + dp[nextQuestion]);\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long[] dp = new long[n+1];\\n        Arrays.fill(dp, 0);\\n        for(int i=n-1; i>=0 ;i--){\\n            int point = questions[i][0];\\n            int jump = questions[i][1];\\n\\n            int nextQuestion = Math.min(n, i+jump+1);\\n            dp[i] = Math.max(dp[i+1], point + dp[nextQuestion]);\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\n```Python []\\nfrom typing import List\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n = len(questions)\\n        dp = [0] * (n+1)\\n        for i in range(n-1, -1, -1):\\n            point = questions[i][0]\\n            jump = questions[i][1]\\n\\n            nextQuestion = min(n, i+jump+1)\\n            dp[i] = max(dp[i+1], point + dp[nextQuestion])\\n        return dp[0]\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\n#define ll long long int\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<ll> dp(n+1, 0);\\n        for(int i=n-1; i>=0 ;i--){\\n            int point = questions[i][0];\\n            int jump = questions[i][1];\\n\\n            int nextQuestion = min(n, i+jump+1);\\n            dp[i] = max(dp[i+1], point + dp[nextQuestion]);\\n        }\\n        return dp[0];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long[] dp = new long[n+1];\\n        Arrays.fill(dp, 0);\\n        for(int i=n-1; i>=0 ;i--){\\n            int point = questions[i][0];\\n            int jump = questions[i][1];\\n\\n            int nextQuestion = Math.min(n, i+jump+1);\\n            dp[i] = Math.max(dp[i+1], point + dp[nextQuestion]);\\n        }\\n        return dp[0];\\n    }\\n}\\n```\n```Python []\\nfrom typing import List\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n = len(questions)\\n        dp = [0] * (n+1)\\n        for i in range(n-1, -1, -1):\\n            point = questions[i][0]\\n            jump = questions[i][1]\\n\\n            nextQuestion = min(n, i+jump+1)\\n            dp[i] = max(dp[i+1], point + dp[nextQuestion])\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694329,
                "title": "recursion-dp-fully-explained-with-amazing-visualization-c",
                "content": "index = idx\\n\\nChoices - \\n    1. Choose the element at idx and skip the next questions[idx][1] elements. Add questions[idx][0] to our answer.\\n    2. Skip/ignore the element at idx and check for all others, i.e. elements from idx+1 to n-1\\n\\nreturn the max of both choices\\n____________________________________________________________________________________\\n\\n![image](https://assets.leetcode.com/users/images/b0023629-60db-4156-8e3e-e63afceb1a5a_1642330525.9837115.png)\\n![image](https://assets.leetcode.com/users/images/ff7cd2b5-7391-4a33-a075-74cbecde85bb_1642330461.3478644.png)\\n\\n# Recurssive\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    ll getPoints(int idx, vector<vector<int>>& questions, int n){\\n        \\n        if(idx == n-1) return questions[idx][0];\\n        if(idx >= n) return 0;\\n        \\n        ll select = questions[idx][0] + getPoints(idx + questions[idx][1] + 1, questions, n);\\n        ll ignore = 0                 + getPoints(idx + 1                    , questions, n);\\n        \\n        return max(select, ignore);    \\n    }\\n    \\n    ll mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        return getPoints(0, questions, n);\\n    }\\n};\\n```\\n\\n# DP (memoization)\\n```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    ll dp[200001] = {{0}};\\n    \\n    ll getPoints(int idx, vector<vector<int>>& questions, int n){\\n        \\n        if(dp[idx] != 0) return dp[idx];\\n        \\n        if(idx == n-1) return questions[idx][0];\\n        if(idx >= n) return 0;\\n        \\n        ll select = questions[idx][0] + getPoints(idx + questions[idx][1] + 1, questions, n);\\n        ll ignore = 0                 + getPoints(idx + 1                    , questions, n);\\n        \\n        return dp[idx] = max(select, ignore);    \\n    }\\n    \\n    ll mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        return getPoints(0, questions, n);\\n    }\\n};\\n```\\n\\n\\n**Please Upvote if you like it**\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    ll getPoints(int idx, vector<vector<int>>& questions, int n){\\n        \\n        if(idx == n-1) return questions[idx][0];\\n        if(idx >= n) return 0;\\n        \\n        ll select = questions[idx][0] + getPoints(idx + questions[idx][1] + 1, questions, n);\\n        ll ignore = 0                 + getPoints(idx + 1                    , questions, n);\\n        \\n        return max(select, ignore);    \\n    }\\n    \\n    ll mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        return getPoints(0, questions, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    #define ll long long\\n    \\n    ll dp[200001] = {{0}};\\n    \\n    ll getPoints(int idx, vector<vector<int>>& questions, int n){\\n        \\n        if(dp[idx] != 0) return dp[idx];\\n        \\n        if(idx == n-1) return questions[idx][0];\\n        if(idx >= n) return 0;\\n        \\n        ll select = questions[idx][0] + getPoints(idx + questions[idx][1] + 1, questions, n);\\n        ll ignore = 0                 + getPoints(idx + 1                    , questions, n);\\n        \\n        return dp[idx] = max(select, ignore);    \\n    }\\n    \\n    ll mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        return getPoints(0, questions, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514272,
                "title": "java-easy-memoization-striver-approach",
                "content": "**It\\'s a cakewalk dp problem. The basic intuition is if you wanna solve the question let\\'s say (k) then you can\\'t solve the next brainpower(questions[k][1]) questions.  So basically I used the simple take, nottake skill. If I wanna solve the question then I will be rewarded with points i.e (questions[k][0]) and I will add it to my answer. After that we recursively move our pointer/index to current index+brainpower(questions[k][1])+1 .Else If I dont wanna take then I wont add the point to my result and recursively move the pointer/index by +1. Atlast just store the maximum of take, nottake to the dp array. \\nI hope you liked the approach \\uD83D\\uDE01**\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n=questions.length;\\n        long dp[]=new long[n];\\n        Arrays.fill(dp,-1l);\\n        return f(0,dp,questions);\\n    }\\n    public long f(int ind,long[] dp,int[][] questions){\\n        if(ind>=questions.length)\\n            return 0;\\n        if(dp[ind]!=-1l)\\n            return dp[ind];\\n        long take=questions[ind][0]+f(ind+questions[ind][1]+1,dp,questions);\\n        long nottake=f(ind+1,dp,questions);\\n        dp[ind]=Math.max(take,nottake);\\n        return dp[ind];\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/62f4ce17-89ba-428b-afd5-a150aebcb83c_1683856666.9500513.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n=questions.length;\\n        long dp[]=new long[n];\\n        Arrays.fill(dp,-1l);\\n        return f(0,dp,questions);\\n    }\\n    public long f(int ind,long[] dp,int[][] questions){\\n        if(ind>=questions.length)\\n            return 0;\\n        if(dp[ind]!=-1l)\\n            return dp[ind];\\n        long take=questions[ind][0]+f(ind+questions[ind][1]+1,dp,questions);\\n        long nottake=f(ind+1,dp,questions);\\n        dp[ind]=Math.max(take,nottake);\\n        return dp[ind];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514560,
                "title": "c-dp-recursive-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long c(int i,vector<vector<int>>& q,vector<long long>&dp){\\n        if(i>=q.size())return 0;\\n        long long ans=0;\\n        if(dp[i]!=-1)return dp[i];\\n        ans = max(q[i][0]+c(i+q[i][1]+1,q,dp),c(i+1,q,dp));\\n        dp[i]=ans;\\n        return ans;\\n    }\\n    long long mostPoints(vector<vector<int>>& q) {\\n        int n=q.size();\\n      vector<long long>dp(n,-1);\\n      return c(0,q,dp);  \\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/6274db0e-ffc2-4f88-86ec-e65b1aa24825_1683864468.6216793.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long c(int i,vector<vector<int>>& q,vector<long long>&dp){\\n        if(i>=q.size())return 0;\\n        long long ans=0;\\n        if(dp[i]!=-1)return dp[i];\\n        ans = max(q[i][0]+c(i+q[i][1]+1,q,dp),c(i+1,q,dp));\\n        dp[i]=ans;\\n        return ans;\\n    }\\n    long long mostPoints(vector<vector<int>>& q) {\\n        int n=q.size();\\n      vector<long long>dp(n,-1);\\n      return c(0,q,dp);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692918,
                "title": "python-dp-solution-with-detail-explanation-and-picture",
                "content": "## **1. Code:**\\n\\n```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        N = len(questions)\\n        DP = [0 for i in range(N+1)]\\n        for i in range(N-1, -1, -1):\\n            p, b = questions[i]\\n            DP[i] = max(p + DP[min(N, i + b + 1)], DP[i+1])\\n        return DP[0]\\n```\\n*Note: `min(N, i + b + 1)` is just a little trick to prevent index overflow*\\n\\n## **2. Explanation:**\\n\\n![image](https://assets.leetcode.com/users/images/7689ef88-0eda-414d-9373-59cb85b6496c_1642306082.1373844.png)\\n\\nFor any DP question, the most important things are *state definition* and *transition of states*.\\n\\n**a. State Definition:**\\nLet `DP[i]` means the most points we can get from question[i] to the last question.\\nSo the answer will be `DP[0]` since it means the most points we can get from question[0] to the last one.\\n\\n**b. Transition of States:**\\nLet\\'s calculate it from the last question to the first.\\n\\nIf we are at question `i` and we already know the max points we can get starting from all the questions after current one, that is, we already know `DP[i+1]`, `DP[i+2]`, ... `DP[N-1]`, we can easily calculate the max points we can get at current one, since we only have two choices:\\n\\n1. Take this points: the max points we can get is `current point + DP[i + current brainpower + 1]`  (since we need to skip all the intermediate steps)\\n2. Don\\'t take this points: the max points we can get is the same as `DP[i + 1]`\\n\\nJust like the picture shows above and of course we want to choose the larger one.\\n\\nSo the transition function is now `DP[i] = max(questions[i][0] + DP[i + questions[i][1] + 1] ,  DP[i + 1])`, and since DP[i] depends on states after, we should do it reversely from last question to first one.\\n\\n**c. For those who are still confused about why we should start from the last index instead of the first index**\\n\\nI have been confused by this question for a long time, too, until I realized the magic of the transition function.\\n\\nActually, the transition function itself will tell you which direction is right. Since our `DP[i]` need to be calculated by `combination of some DP[i + ?]`, which means, we need to know the answer of `DP[i+?]` before `DP[i]`. So we should iterate from the last index. If your transition function give you `DP[i] =  combination of some DP[i-?]`, then you should start from the first index. If you got both directions? It will be very tricky and need to do some advanced transformation first, otherwise, it can\\'t be solved by DP.\\n\\nThis concept can help you deal with some harder DP questions like: [Minimum Cost to Cut a Stick](https://leetcode.com/problems/minimum-cost-to-cut-a-stick/). After you write done the transition function, you will understand why the direction of each layer of iterations are different.\\n\\n## **3. Time Complexity**\\nO(N)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        N = len(questions)\\n        DP = [0 for i in range(N+1)]\\n        for i in range(N-1, -1, -1):\\n            p, b = questions[i]\\n            DP[i] = max(p + DP[min(N, i + b + 1)], DP[i+1])\\n        return DP[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693670,
                "title": "recursive-memoized-tabulation-variation-of-house-robber",
                "content": "This Question is a variation of [198. House Robber](https://leetcode.com/problems/house-robber/).\\n\\nThe only difference between this Question and  [198. House Robber](https://leetcode.com/problems/house-robber/) :\\n1.  The skip steps in  [198. House Robber](https://leetcode.com/problems/house-robber/) after taking amount of current index or House was fixed i.e 1 steps.\\n2.  In this question we have been given skip steps corresponding to every house(index) at every house(index) you rob or take money from.\\n\\nDP problems are mostly having same pattern but just twisting some of terms in question, like in this question.\\n\\n**The Indirect Statement of this Question** : \\n#    Find the maximum points of subsequence but with some limitations in picking elements.\\nSubsequence itself states that we have two choices for every element :\\n      1. Take.\\n      2. Discard.\\nBut the `difference between general subsequence` and this `HOUSE ROBBER kinda question` is that if we `rob the current house we have to skip next q[i][1] houses`.\\n\\n\\n* # My advice is to first figure out `Recursive solution` first as that is most important.\\n* # After recursive solution the` Memoized and Tabulation` Solution will take a minute only.\\n\\n\\n## Recursive \\n\\n    long long helper(vector<vector<int>>& q, int i,int n){ \\n        if(i >= n) return 0;\\n        return max(q[i][0] + helper(q, i + 1 + q[i][1], n), helper(q, i + 1, n));\\n    }\\n\\t\\n# Memoization= Recursion + 1D Space\\t\\n     long long helper(vector<vector<int>>& q, int i,int n){\\n           if(i >= n) return 0;\\n           if(dp[i] != -1) return dp[i];\\n           return dp[i] =  return max(q[i][0] + helper(q, i + 1 + q[i][1], n), helper(q, i + 1, n));\\n    }\\n\\t\\n# Tabulation 1D\\n       long long mostPoints(vector<vector<int>>& q) {\\n            int n = q.size(); \\n            long long dp[n+1]{};\\n            for(int i = n - 1;i >= 0; i--){\\n                 int nx = q[i][1]; \\n                 long long take   = q[i][0] + ((i+1+nx<=n) ? dp[i+1+nx] : 0 );\\n                 long long not_take = dp[i+1];\\n                 dp[i]= max(take, not_take);\\n            }\\n            return dp[0];\\n      }\\n  \\n",
                "solutionTags": [
                    "C"
                ],
                "code": "This Question is a variation of [198. House Robber](https://leetcode.com/problems/house-robber/).\\n\\nThe only difference between this Question and  [198. House Robber](https://leetcode.com/problems/house-robber/) :\\n1.  The skip steps in  [198. House Robber](https://leetcode.com/problems/house-robber/) after taking amount of current index or House was fixed i.e 1 steps.\\n2.  In this question we have been given skip steps corresponding to every house(index) at every house(index) you rob or take money from.\\n\\nDP problems are mostly having same pattern but just twisting some of terms in question, like in this question.\\n\\n**The Indirect Statement of this Question** : \\n#    Find the maximum points of subsequence but with some limitations in picking elements.\\nSubsequence itself states that we have two choices for every element :\\n      1. Take.\\n      2. Discard.\\nBut the `difference between general subsequence` and this `HOUSE ROBBER kinda question` is that if we `rob the current house we have to skip next q[i][1] houses`.\\n\\n\\n* # My advice is to first figure out `Recursive solution` first as that is most important.\\n* # After recursive solution the` Memoized and Tabulation` Solution will take a minute only.\\n\\n\\n## Recursive \\n\\n    long long helper(vector<vector<int>>& q, int i,int n){ \\n        if(i >= n) return 0;\\n        return max(q[i][0] + helper(q, i + 1 + q[i][1], n), helper(q, i + 1, n));\\n    }\\n\\t\\n# Memoization= Recursion + 1D Space\\t\\n     long long helper(vector<vector<int>>& q, int i,int n){\\n           if(i >= n) return 0;\\n           if(dp[i] != -1) return dp[i];\\n           return dp[i] =  return max(q[i][0] + helper(q, i + 1 + q[i][1], n), helper(q, i + 1, n));\\n    }\\n\\t\\n# Tabulation 1D\\n       long long mostPoints(vector<vector<int>>& q) {\\n            int n = q.size(); \\n            long long dp[n+1]{};\\n            for(int i = n - 1;i >= 0; i--){\\n                 int nx = q[i][1]; \\n                 long long take   = q[i][0] + ((i+1+nx<=n) ? dp[i+1+nx] : 0 );\\n                 long long not_take = dp[i+1];\\n                 dp[i]= max(take, not_take);\\n            }\\n            return dp[0];\\n      }\\n  \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1693049,
                "title": "java-python-3-two-codes-recursion-and-dp-w-explanation-and-analysis",
                "content": "**Method1: Recursive code**\\n\\n```java\\n    public long mostPoints(int[][] questions) {\\n        return getPoints(questions, 0, new long[questions.length]);\\n    }\\n    private long getPoints(int[][] q, int idx, long[] ans) {\\n        if (idx >= q.length) { // base cases.\\n            return 0;\\n        }else if (ans[idx] == 0) { // general case.\\n            int points = q[idx][0], brain = q[idx][1];\\n            // max points if we solve questions[i].\\n            long cur = points + getPoints(q, idx + 1 + brain, ans);\\n            // max points we can get for questions[i] \\n            // (i = idx, idx + 1, ..., questions.length - 1).\\n            ans[idx] = Math.max(cur, getPoints(q, idx + 1, ans));\\n        }\\n        return ans[idx];\\n    }\\n```\\n\\n```python\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        \\n        def getPoints(idx: int) -> int:\\n            if idx >= len(questions):\\n                return 0\\n            if idx not in idx_to_points:\\n                points, brain = questions[idx]\\n                cur = points + getPoints(idx + brain + 1) \\n                idx_to_points[idx] = max(cur, getPoints(idx + 1))\\n            return idx_to_points[idx]\\n        \\n        idx_to_points = {}\\n        return getPoints(0)\\n```\\n\\n----\\n\\n**Method 2: Reverse traversal using DP**\\n\\n**Q & A**\\n\\nQ1: Why should we traverse **reversely** to solve this problem by DP, but in a similar problem: House robber -  https://leetcode.com/problems/house-robber/, we can traverse input either direction to get a time `O(n)` solution?\\n\\nA1: According to the context, the problem [https://leetcode.com/problems/house-robber/](https://leetcode.com/problems/house-robber/) only forbids consecutive operations, no traversal direction involved; \\n\\nIn this problem, however, each given `questions[i]` specifies that **next** `questions[i][1]` questions are not allowed;  it does **NOT** restrict **previous** operations (of course, previous questions might have their own restrictions about current question). Therefore, traversal direction **DOES** matter. When traversing from right to left, we only need care the restriction of current question, then get max points for current problem based on future subproblem(s).\\n\\nOn the other hand, if we traverse from left to right, we do not need to care about the restriction of current `questions[i][1]`, but we should make sure we abide **ALL** previous restrictions: `questions[k][1] (0 <= k < i)`. Obviously, it will result a time `O(n ^ 2)` algorithm, which is not appealling, if not inapplicable, for a problem with a scale of `10^5`.\\n\\n**End of Q & A**\\n\\n----\\n\\n**Intitution:**\\nAccording to the problem: \"Solving question i will earn you points<sub>i</sub> points but you will be unable to solve each of the `next` brainpower<sub>i</sub> questions.\", it means the restrictions assiciated with furture questions will **NOT** apply to current and past questions. Hence, in order to max points, we only need to care about current restriction `questions[i][1]` if we have already solved all next questions: `questions[j] (j > i)`.\\n\\nTherefore, we can traverse input reversely to determine the optimal decision of current problem based on future subproblems. Hence, DP is a logical option.\\n```java\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long[] dp = new long[n + 1];\\n        for (int i = n - 1; i >= 0; --i) {\\n            int point = questions[i][0], brain = questions[i][1];\\n            dp[i] = point;\\n            if (i < n - brain) {\\n                dp[i] += dp[i + brain + 1];\\n            }\\n            dp[i] = Math.max(dp[i + 1], dp[i]);\\n        }\\n        return dp[0];        \\n    }\\n```\\n```python\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        dp = [0] * (len(questions) + 1)\\n        for i, (point, brain) in enumerate(reversed(questions)):\\n            dp[i + 1] = point\\n            if i > brain:\\n                dp[i + 1] += dp[i - brain] \\n            dp[i + 1] = max(dp[i + 1], dp[i])    \\n        return dp[-1]\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`, where `n = questions.length`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long mostPoints(int[][] questions) {\\n        return getPoints(questions, 0, new long[questions.length]);\\n    }\\n    private long getPoints(int[][] q, int idx, long[] ans) {\\n        if (idx >= q.length) { // base cases.\\n            return 0;\\n        }else if (ans[idx] == 0) { // general case.\\n            int points = q[idx][0], brain = q[idx][1];\\n            // max points if we solve questions[i].\\n            long cur = points + getPoints(q, idx + 1 + brain, ans);\\n            // max points we can get for questions[i] \\n            // (i = idx, idx + 1, ..., questions.length - 1).\\n            ans[idx] = Math.max(cur, getPoints(q, idx + 1, ans));\\n        }\\n        return ans[idx];\\n    }\\n```\n```python\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        \\n        def getPoints(idx: int) -> int:\\n            if idx >= len(questions):\\n                return 0\\n            if idx not in idx_to_points:\\n                points, brain = questions[idx]\\n                cur = points + getPoints(idx + brain + 1) \\n                idx_to_points[idx] = max(cur, getPoints(idx + 1))\\n            return idx_to_points[idx]\\n        \\n        idx_to_points = {}\\n        return getPoints(0)\\n```\n```java\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long[] dp = new long[n + 1];\\n        for (int i = n - 1; i >= 0; --i) {\\n            int point = questions[i][0], brain = questions[i][1];\\n            dp[i] = point;\\n            if (i < n - brain) {\\n                dp[i] += dp[i + brain + 1];\\n            }\\n            dp[i] = Math.max(dp[i + 1], dp[i]);\\n        }\\n        return dp[0];        \\n    }\\n```\n```python\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        dp = [0] * (len(questions) + 1)\\n        for i, (point, brain) in enumerate(reversed(questions)):\\n            dp[i + 1] = point\\n            if i > brain:\\n                dp[i + 1] += dp[i - brain] \\n            dp[i + 1] = max(dp[i + 1], dp[i])    \\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3514045,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. I planned to give for next 10,000 Subscribers.  **DON\\'T FORGET** to Subscribe\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n# or\\n\\n# Click the Link in my Profile\\n\\n# Approach:\\nWe can solve this problem using dynamic programming. We\\'ll create an array dp of length n+1 to store the maximum number of points that can be earned by starting at each question. We\\'ll iterate through the array in reverse order, starting at index n-1, and fill in the dp array as follows:\\n\\n- For each question, we\\'ll calculate the maximum number of points that can be earned by answering that question, and add it to the maximum number of points that can be earned by starting at the next question (i.e., the question that can be reached by jumping from the current question).\\n- We\\'ll take the maximum of the above two values and store it in dp[i].\\nOnce we\\'ve filled in the dp array, the maximum number of points that can be earned by starting at the first question (i.e., the question at index 0) will be stored in dp[0].\\n\\n\\n\\n```Python []\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n = len(questions)\\n      \\n        max_points = [0] * (n + 1)\\n     \\n        for i in range(n - 1, -1, -1):\\n            points, jump = questions[i]\\n           \\n            next_question = min(jump + i + 1, n)\\n            points_from_this_question = points + max_points[next_question]\\n            max_points[i] = max(points_from_this_question, max_points[i + 1])\\n        \\n        return max_points[0]\\n\\n```\\n```Java []\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        \\n        long[] dp = new long[n + 1];\\n\\n        \\n        for (int i = n - 1; i >= 0; --i) {\\n            int points = questions[i][0];\\n            int jump = questions[i][1];\\n\\n            \\n            int nextQuestion = Math.min(jump + i + 1, n);\\n            long pointsFromThisQuestion = points + dp[nextQuestion];\\n            dp[i] = Math.max(pointsFromThisQuestion, dp[i + 1]);\\n        }\\n\\n       \\n        return dp[0];\\n    }\\n}\\n\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n\\n        vector<long long> dp(n + 1, 0);\\n\\n        \\n        for (int i = n - 1; i >= 0; --i) {\\n            int points = questions[i][0];\\n            int jump = questions[i][1];\\n\\n            int nextQuestion = min(jump + i + 1, n);\\n            long long pointsFromThisQuestion = points + dp[nextQuestion];\\n            dp[i] = max(pointsFromThisQuestion, dp[i + 1]);\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n\\n```\\n# An Upvote will be encouraging \\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```Python []\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n = len(questions)\\n      \\n        max_points = [0] * (n + 1)\\n     \\n        for i in range(n - 1, -1, -1):\\n            points, jump = questions[i]\\n           \\n            next_question = min(jump + i + 1, n)\\n            points_from_this_question = points + max_points[next_question]\\n            max_points[i] = max(points_from_this_question, max_points[i + 1])\\n        \\n        return max_points[0]\\n\\n```\n```Java []\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        \\n        long[] dp = new long[n + 1];\\n\\n        \\n        for (int i = n - 1; i >= 0; --i) {\\n            int points = questions[i][0];\\n            int jump = questions[i][1];\\n\\n            \\n            int nextQuestion = Math.min(jump + i + 1, n);\\n            long pointsFromThisQuestion = points + dp[nextQuestion];\\n            dp[i] = Math.max(pointsFromThisQuestion, dp[i + 1]);\\n        }\\n\\n       \\n        return dp[0];\\n    }\\n}\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n\\n        vector<long long> dp(n + 1, 0);\\n\\n        \\n        for (int i = n - 1; i >= 0; --i) {\\n            int points = questions[i][0];\\n            int jump = questions[i][1];\\n\\n            int nextQuestion = min(jump + i + 1, n);\\n            long long pointsFromThisQuestion = points + dp[nextQuestion];\\n            dp[i] = max(pointsFromThisQuestion, dp[i + 1]);\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514500,
                "title": "simple-approach-ii-iterative-easy-to-understand",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt first we will create a `long` data type array to store the marks. We create long data type array because of the constrain values .i.e. `long[] mark = new long [questions.length+1];` \\n\\nWe will iterate `i` from `questions.length-1` to `0`.\\n- create a temp var `future` to store the future brain power. \\n- if `future > questions.length -1` --> we will store the value of marks fo that question. i.e. `mark[i] = questions[i][0]`.\\n- else--> we will store the value of marks fo that question in addtion with the future value. i.e. `questions[i][0] + mark[future];`\\n- then for every marks we will make the max value for the i\\'th index.\\n\\nAt last we will return the first index value of the marks.i.e. `mark[0]`\\n \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Do comment your doubts in the comment section :)\\n\\n# Code\\n```\\nclass Solution {\\n\\tpublic long mostPoints(int[][] questions) {\\n\\t\\tlong[] mark = new long [questions.length+1];\\n\\n\\t\\tfor(int i= questions.length-1; i>=0; i--){\\n\\t\\t\\tint future = questions[i][1] + i + 1;\\n\\n\\t\\t\\tif(future > questions.length -1) mark[i] = questions[i][0];\\n\\t\\t\\telse mark[i] = questions[i][0] + mark[future];\\n\\n\\t\\t\\tmark[i] = Math.max(mark[i], mark[i+1]);\\n\\t\\t}\\n\\t\\treturn mark[0];\\n\\t}\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/8e9b3371-5eed-4b49-86ea-3ec377e998a3_1683862667.9488573.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Sorting",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic long mostPoints(int[][] questions) {\\n\\t\\tlong[] mark = new long [questions.length+1];\\n\\n\\t\\tfor(int i= questions.length-1; i>=0; i--){\\n\\t\\t\\tint future = questions[i][1] + i + 1;\\n\\n\\t\\t\\tif(future > questions.length -1) mark[i] = questions[i][0];\\n\\t\\t\\telse mark[i] = questions[i][0] + mark[future];\\n\\n\\t\\t\\tmark[i] = Math.max(mark[i], mark[i+1]);\\n\\t\\t}\\n\\t\\treturn mark[0];\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514091,
                "title": "java-dp-bottom-up-beats-99-7-lines",
                "content": "# Intuition\\nThis is a classic DP problem. We can solve it in a bottom up fashion. Starting with the last `question`, if there was only a single question, we know the answer would be equal to the points which is `questions[n-1][0]`. Let\\'s save that and look at one more question at a time. For each new question, we can either pick it or skip it. We need to calculate the total points for both cases and pick the maximum out of them. So, for any `questions[i]`, max points should be the greater of `question[i+1]` (skipping the question), and `questions[i][0] +` the answer for `questions[i + brainPower[i] + 1]` where `brainpower[i] = questions[i][1]` (selecting the question).\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long mostPoints(int[][] questions) {\\n    var n = questions.length;\\n    var dp = new long[n];\\n    dp[n-1] = questions[n-1][0];\\n\\n    for (var i = n-2; i >= 0; i--) {\\n      var nextQ = i + questions[i][1] + 1;\\n      \\n      dp[i] = Math.max(\\n                questions[i][0] + (nextQ < n ? dp[nextQ] : 0),\\n                dp[i+1]);\\n    }\\n    return dp[0];\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n  public long mostPoints(int[][] questions) {\\n    var n = questions.length;\\n    var dp = new long[n];\\n    dp[n-1] = questions[n-1][0];\\n\\n    for (var i = n-2; i >= 0; i--) {\\n      var nextQ = i + questions[i][1] + 1;\\n      \\n      dp[i] = Math.max(\\n                questions[i][0] + (nextQ < n ? dp[nextQ] : 0),\\n                dp[i+1]);\\n    }\\n    return dp[0];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515199,
                "title": "recursion-memoization-tabulation-clean-codes-c-striver",
                "content": "# Intuition\\nThe usual pick and not pick type question giving the intuition of DP.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nGiving the Recursive way and then memoized version of it and finally the tabulation code. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nRecursion - Exponential (TLE)\\nMemoization - O(N)\\nTabulation - O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nRecusrion - O(1)\\nMemoization - O(N) + Recursive stack space\\nTabulation - O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n```Recursion []\\nclass Solution {\\npublic:\\n\\nlong long sumi(int ind, vector<vector<int>> &questions, int n){\\n    if(ind==n-1) return questions[n-1][0];\\n    if(ind>=n) return 0;\\n    long long take=questions[ind][0]+sumi(ind+questions[ind][1]+1,questions,n);    \\n    long long notTake=0+sumi(ind+1,questions,n);\\n    return max(take,notTake);\\n}\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n     int n=questions.size();\\n     return sumi(0,questions,n);   \\n    }\\n};\\n```\\n```Memoization []\\nclass Solution {\\npublic:\\n\\nlong long sumi(int ind, vector<vector<int>> &questions, int n, vector<long long> &dp){\\n    if(ind==n-1) return questions[n-1][0];\\n    if(ind>=n) return 0;\\n    if(dp[ind]!=-1) return dp[ind];\\n    long long take=questions[ind][0]+sumi(ind+questions[ind][1]+1,questions,n,dp);    \\n    long long notTake=0+sumi(ind+1,questions,n,dp);\\n    return dp[ind]=max(take,notTake);\\n}\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n     int n=questions.size();\\n     vector<long long> dp(n+1,-1);\\n     return sumi(0,questions,n,dp);   \\n    }\\n};\\n```\\n```Tabulation []\\nclass Solution {\\npublic:\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n     int n=questions.size();\\n     vector<long long> dp(n+1,0);\\n    for(int ind=n-1;ind>=0;ind--){\\n        long long take=0;\\n        if(ind+questions[ind][1]+1>=n)\\n        take=questions[ind][0]+dp[n];\\n        else take=questions[ind][0]+dp[ind+questions[ind][1]+1];    \\n        long long notTake=dp[ind+1];\\n        dp[ind]=max(take,notTake);\\n    }   \\n    return dp[0];\\n    }\\n    \\n};\\n```\\n# *Please upvote if this helped!*\\n***Happy coding :)***",
                "solutionTags": [
                    "C++"
                ],
                "code": "```Recursion []\\nclass Solution {\\npublic:\\n\\nlong long sumi(int ind, vector<vector<int>> &questions, int n){\\n    if(ind==n-1) return questions[n-1][0];\\n    if(ind>=n) return 0;\\n    long long take=questions[ind][0]+sumi(ind+questions[ind][1]+1,questions,n);    \\n    long long notTake=0+sumi(ind+1,questions,n);\\n    return max(take,notTake);\\n}\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n     int n=questions.size();\\n     return sumi(0,questions,n);   \\n    }\\n};\\n```\n```Memoization []\\nclass Solution {\\npublic:\\n\\nlong long sumi(int ind, vector<vector<int>> &questions, int n, vector<long long> &dp){\\n    if(ind==n-1) return questions[n-1][0];\\n    if(ind>=n) return 0;\\n    if(dp[ind]!=-1) return dp[ind];\\n    long long take=questions[ind][0]+sumi(ind+questions[ind][1]+1,questions,n,dp);    \\n    long long notTake=0+sumi(ind+1,questions,n,dp);\\n    return dp[ind]=max(take,notTake);\\n}\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n     int n=questions.size();\\n     vector<long long> dp(n+1,-1);\\n     return sumi(0,questions,n,dp);   \\n    }\\n};\\n```\n```Tabulation []\\nclass Solution {\\npublic:\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n     int n=questions.size();\\n     vector<long long> dp(n+1,0);\\n    for(int ind=n-1;ind>=0;ind--){\\n        long long take=0;\\n        if(ind+questions[ind][1]+1>=n)\\n        take=questions[ind][0]+dp[n];\\n        else take=questions[ind][0]+dp[ind+questions[ind][1]+1];    \\n        long long notTake=dp[ind+1];\\n        dp[ind]=max(take,notTake);\\n    }   \\n    return dp[0];\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1696021,
                "title": "beginner-friendly-solutions-from-recursive-memoization-to-iterative-js-easy-o-n",
                "content": "Take help from Diagram given here: https://leetcode.com/problems/solving-questions-with-brainpower/discuss/1694329/Recursion-greater-DP-or-fully-explained-with-amazing-visualization-or-C%2B%2B\\n\\n**Approach 1: Recursive Memoization**\\n\\n```\\nvar mostPoints = function(questions) {\\n    let totalQuestions = questions.length;\\n    \\n    let map = new Map();\\n    \\n    const helper = (index) => {\\n        if(map.has(index))\\n            return map.get(index);\\n        \\n        if(index >= totalQuestions) {\\n            return 0;\\n        }  \\n        \\n        let solve = questions[index][0] + helper(index + questions[index][1] + 1);\\n        \\n        let skip = helper(index + 1);\\n        \\n        let res = Math.max(solve, skip);\\n        \\n        map.set(index, res);\\n        \\n        return res;\\n    }\\n    \\n    return helper(0);\\n\\t\\n```\\n\\n**Approach 2: Iterative**\\n\\n```\\n\\nvar mostPoints = function(questions) {\\n    let totalQuestions = questions.length;\\n\\t\\n\\tlet dp = new Array(totalQuestions).fill(0);\\n    \\n    for(let i = totalQuestions - 1; i >= 0; i--) {\\n        let point = questions[i][0];\\n        let power = questions[i][1];\\n        \\n        let solve = point + (dp[i + power + 1] || 0);\\n        let skip = (dp[i + 1] || 0);\\n        \\n        dp[i] = Math.max(solve, skip);\\n    }\\n    \\n    return dp[0];\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvar mostPoints = function(questions) {\\n    let totalQuestions = questions.length;\\n    \\n    let map = new Map();\\n    \\n    const helper = (index) => {\\n        if(map.has(index))\\n            return map.get(index);\\n        \\n        if(index >= totalQuestions) {\\n            return 0;\\n        }  \\n        \\n        let solve = questions[index][0] + helper(index + questions[index][1] + 1);\\n        \\n        let skip = helper(index + 1);\\n        \\n        let res = Math.max(solve, skip);\\n        \\n        map.set(index, res);\\n        \\n        return res;\\n    }\\n    \\n    return helper(0);\\n\\t\\n```\n```\\n\\nvar mostPoints = function(questions) {\\n    let totalQuestions = questions.length;\\n\\t\\n\\tlet dp = new Array(totalQuestions).fill(0);\\n    \\n    for(let i = totalQuestions - 1; i >= 0; i--) {\\n        let point = questions[i][0];\\n        let power = questions[i][1];\\n        \\n        let solve = point + (dp[i + power + 1] || 0);\\n        let skip = (dp[i + 1] || 0);\\n        \\n        dp[i] = Math.max(solve, skip);\\n    }\\n    \\n    return dp[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1695168,
                "title": "java-dp-right-to-left-and-left-to-right-solutions",
                "content": "Right-to-left is more efficient and easier to implement. But it may be tricky to think of it in the first place.\\n\\n```\\n    public long mostPoints(int[][] questions) {\\n        long[] dp = new long[200001];\\n        \\n        for(int i = questions.length - 1; i >= 0; i--){\\n            dp[i] = Math.max(dp[i + 1], questions[i][0] + dp[i + 1 + questions[i][1]]);\\n        }\\n        \\n        return dp[0];\\n    }\\n```\\n\\nWell left-to-right solution may be more intuitive but less efficient. Basically, in the `dp` array, `dp[i][0]` stores the max points one can get before making decisions at `i`. `dp[i][1]` has the max points one can get if question `i` is taken.\\n\\n```\\n    public long mostPoints(int[][] questions) {\\n        int length = questions.length;\\n        long[][] memo = new long[length][2];\\n        \\n        for(int i = 0; i < length; i++){\\n            // take it\\n            memo[i][1] = Math.max(memo[i][0] + questions[i][0], memo[i][1]);\\n            int next = Math.min(length - 1, i + questions[i][1] + 1);\\n            long temp = next < i + questions[i][1] + 1? memo[i][1] - questions[length - 1][0] : memo[i][1];\\n            memo[next][0] = Math.max(memo[next][0], temp);\\n            \\n            // skip\\n            if(i + 1 < length){\\n                memo[i + 1][0] = Math.max(memo[i][0], memo[i + 1][0]);\\n            }\\n        }\\n        \\n        return Math.max(memo[length - 1][0], memo[length - 1][1]);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n    public long mostPoints(int[][] questions) {\\n        long[] dp = new long[200001];\\n        \\n        for(int i = questions.length - 1; i >= 0; i--){\\n            dp[i] = Math.max(dp[i + 1], questions[i][0] + dp[i + 1 + questions[i][1]]);\\n        }\\n        \\n        return dp[0];\\n    }\\n```\n```\\n    public long mostPoints(int[][] questions) {\\n        int length = questions.length;\\n        long[][] memo = new long[length][2];\\n        \\n        for(int i = 0; i < length; i++){\\n            // take it\\n            memo[i][1] = Math.max(memo[i][0] + questions[i][0], memo[i][1]);\\n            int next = Math.min(length - 1, i + questions[i][1] + 1);\\n            long temp = next < i + questions[i][1] + 1? memo[i][1] - questions[length - 1][0] : memo[i][1];\\n            memo[next][0] = Math.max(memo[next][0], temp);\\n            \\n            // skip\\n            if(i + 1 < length){\\n                memo[i + 1][0] = Math.max(memo[i][0], memo[i + 1][0]);\\n            }\\n        }\\n        \\n        return Math.max(memo[length - 1][0], memo[length - 1][1]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1693290,
                "title": "easy-javascript-js-dp",
                "content": "```\\nvar mostPoints = function(questions) {\\n    const n = questions.length;\\n    const dp = new Array(n).fill(0);\\n    let max = 0;\\n    \\n    for (let i = n - 1; i >= 0; i--) {\\n        const [point, brainpower] = questions[i];\\n        dp[i] = Math.max(max, point + (dp[i + brainpower + 1] || 0));\\n        max = Math.max(max, dp[i]);\\n    }\\n\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar mostPoints = function(questions) {\\n    const n = questions.length;\\n    const dp = new Array(n).fill(0);\\n    let max = 0;\\n    \\n    for (let i = n - 1; i >= 0; i--) {\\n        const [point, brainpower] = questions[i];\\n        dp[i] = Math.max(max, point + (dp[i + brainpower + 1] || 0));\\n        max = Math.max(max, dp[i]);\\n    }\\n\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1693198,
                "title": "easy-11-lines-in-python",
                "content": "first we need to create list of all points in a questions list lets say L. After do Backward iteration  and keep track of maximum. Two conditions to check in this process :\\n**case 1:** if brainpower+index exceeds lenght of list:\\n\\t\\t\\t\\tmaximum=max(L[i],maximum)\\n\\t\\t\\t\\twe are not adding any element to this index power value.\\n**case 2** if brainpower+index less than lenght of list:\\n\\t\\t\\t\\tmaximum=max(L[i]+L[i+questions[i][1]+1],maximum)\\n\\t\\t\\t\\twe are adding max power at index+brainpower+1 to power at i \\n\\n**code**\\n```\\ndef mostPoints(self, questions: List[List[int]]) -> int:\\n        n=len(questions)\\n        l=[x[0] for x in questions]\\n        maxi=0\\n        for i in range(n-1,-1,-1):\\n            if i+questions[i][1]+1>n-1:\\n                maxi=max(l[i],maxi)\\n            else:\\n                maxi=max(l[i]+l[i+questions[i][1]+1],maxi)\\n            l[i]=maxi\\n        return l[0]\\n```\\n**PLEASE UPVOTE. I NEED YOUR ENCOURAGEMENT.**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef mostPoints(self, questions: List[List[int]]) -> int:\\n        n=len(questions)\\n        l=[x[0] for x in questions]\\n        maxi=0\\n        for i in range(n-1,-1,-1):\\n            if i+questions[i][1]+1>n-1:\\n                maxi=max(l[i],maxi)\\n            else:\\n                maxi=max(l[i]+l[i+questions[i][1]+1],maxi)\\n            l[i]=maxi\\n        return l[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3515056,
                "title": "day-407-rec-memo-acc-dp-3-liner-100-python-java-c-explained",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\n\\n\\n# rec\\n```java []\\npublic long mostPoints(int[][] Q) {\\n    return rec(0,Q);\\n}\\nlong rec(int i,int Q[][]){\\n    if(i>=Q.length) return 0;\\n    long not = rec(i+1,Q),take=0;\\n    if(i<Q.length) take=Q[i][0]+rec(i+Q[i][1]+1,Q);\\n    return Math.max(take,not);\\n}\\n```\\nNote: TLE for larger inputs\\n# using functional args\\n\\n```java []\\nlong mostPoints(int[][] Q) {\\n    int len = Q.length;\\n    long dp[] = new long[len];\\n    return rec(0, Q, 0, dp, len);\\n}\\nlong rec(int i, int Q[][], long acc, long dp[], int len) {\\n    if (i >= len) return acc;\\n    if (dp[i] != 0) return dp[i] + acc;\\n    long not = rec(i + 1, Q, acc, dp, len);\\n    long take = 0;\\n    if (i < len) take = Q[i][0] + rec(i + Q[i][1] + 1, Q, acc, dp, len);\\n    return dp[i] = (Math.max(take - acc, not) + acc);\\n}\\n```\\n# memo\\n\\n```java []\\npublic long mostPoints(int[][] Q) {\\n    int len = Q.length;\\n    long dp[] = new long[len];\\n    return rec(0,Q,dp,len);\\n}\\nlong rec(int i,int Q[][],long dp[],int len){\\n    if(i>=len) return 0;\\n    if(dp[i]!=0) return dp[i];\\n    long not = rec(i+1,Q,dp,len),take=0;\\n    if(i<len) take=Q[i][0]+rec(i+Q[i][1]+1,Q,dp,len);\\n    return dp[i]= Math.max(take,not);\\n}\\n```\\n\\n# DP\\n```java []\\npublic long mostPoints(int[][] Q) {\\n    int len = Q.length;\\n    long dp[] = new long[len];\\n    dp[len-1]=Q[len-1][0];\\n    for(int i=len-2;i>=0;i--){\\n        long not =dp[i+1],take=0;\\n        if(i+Q[i][1]+1<len) take=Q[i][0]+dp[i+Q[i][1]+1];\\n        else take = Q[i][0];\\n        dp[i]= Math.max(take,not);\\n    } return dp[0];\\n}\\n```\\n```c++ []\\nlong long mostPoints<vector<int>>& Q) {\\n    int len = Q.size();\\n    vector<long long> dp(len);\\n    dp[len-1] = Q[len-1][0];\\n    for (int i = len-2; i >= 0; i--) {\\n        long long not = dp[i+1];\\n        long long take = 0;\\n        if (i+Q[i][1]+1 < len) {\\n            take = Q[i][0] + dp[i+Q[i][1]+1];\\n        } else {\\n            take = Q[i][0];\\n        }\\n        dp[i] = max(take, not);\\n    }\\n    return dp[0];\\n}\\n```\\n```python []\\ndef mostPoints(Q: List[List[int]]) -> int:\\n    n = len(Q)\\n    dp = [0] * n\\n    dp[n-1] = Q[n-1][0]\\n    for i in range(n-2, -1, -1):\\n        not_take = dp[i+1]\\n        take = 0\\n        if i+Q[i][1]+1 < n:\\n            take = Q[i][0] + dp[i+Q[i][1]+1]\\n        else:\\n            take = Q[i][0]\\n        dp[i] = max(take, not_take)\\n    return dp[0]\\n```\\n# Explaination \\nwe initialize dp[len-1] to the point value of the last question. We then iterate over the remaining questions in reverse order using a for loop.\\n\\nInside the loop, we compute the two cases described in the original solution: solving the current question and skipping the current question. We use an if-else statement to handle the case where we cannot solve the current question because we have not solved enough subsequent questions.\\n\\nWe then store the maximum of the two cases in dp[i], which is equivalent to the return statement of the original solution.\\n\\nFinally, we return dp[0], which is the maximum points that can be earned by solving all the questions.\\n\\n# Complexity\\n- Time complexity:o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# CLEAN CODE \\n\\n```JAVA []\\npublic long mostPoints(int[][] questions) {\\n    final int n = questions.length;\\n    long[] dp = new long[n + 1];\\n    for (int i = n - 1; i >= 0; --i) {\\n        final int points = questions[i][0];\\n        final int brainpower = questions[i][1];\\n        final int nextIndex = i + brainpower + 1;\\n        final long nextPoints = nextIndex < n ? dp[nextIndex] : 0;\\n        dp[i] = Math.max(points + nextPoints, dp[i + 1]);\\n    } return dp[0];\\n}\\n```\\n\\n# JAVA 8  3 LINER\\n\\n```JAVA []\\npublic long mostPoints(int[][] questions) {\\n    final int n = questions.length;\\n    long[] dp = new long[n + 1];\\n    IntStream.rangeClosed(0, n - 1).boxed().sorted(Collections.reverseOrder())\\n        .forEach(i -> {\\n            final int points = questions[i][0];\\n            final int brainpower = questions[i][1];\\n            final int nextIndex = i + brainpower + 1;\\n            final long nextPoints = nextIndex < n ? dp[nextIndex] : 0;\\n            dp[i] = Math.max(points + nextPoints, dp[i + 1]);\\n        });\\n    return dp[0];\\n}\\n```\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n![image.png](https://assets.leetcode.com/users/images/303fa18d-281d-49f0-87ef-1a018fc9a488_1681355186.0923774.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```java []\\npublic long mostPoints(int[][] Q) {\\n    return rec(0,Q);\\n}\\nlong rec(int i,int Q[][]){\\n    if(i>=Q.length) return 0;\\n    long not = rec(i+1,Q),take=0;\\n    if(i<Q.length) take=Q[i][0]+rec(i+Q[i][1]+1,Q);\\n    return Math.max(take,not);\\n}\\n```\n```java []\\nlong mostPoints(int[][] Q) {\\n    int len = Q.length;\\n    long dp[] = new long[len];\\n    return rec(0, Q, 0, dp, len);\\n}\\nlong rec(int i, int Q[][], long acc, long dp[], int len) {\\n    if (i >= len) return acc;\\n    if (dp[i] != 0) return dp[i] + acc;\\n    long not = rec(i + 1, Q, acc, dp, len);\\n    long take = 0;\\n    if (i < len) take = Q[i][0] + rec(i + Q[i][1] + 1, Q, acc, dp, len);\\n    return dp[i] = (Math.max(take - acc, not) + acc);\\n}\\n```\n```java []\\npublic long mostPoints(int[][] Q) {\\n    int len = Q.length;\\n    long dp[] = new long[len];\\n    return rec(0,Q,dp,len);\\n}\\nlong rec(int i,int Q[][],long dp[],int len){\\n    if(i>=len) return 0;\\n    if(dp[i]!=0) return dp[i];\\n    long not = rec(i+1,Q,dp,len),take=0;\\n    if(i<len) take=Q[i][0]+rec(i+Q[i][1]+1,Q,dp,len);\\n    return dp[i]= Math.max(take,not);\\n}\\n```\n```java []\\npublic long mostPoints(int[][] Q) {\\n    int len = Q.length;\\n    long dp[] = new long[len];\\n    dp[len-1]=Q[len-1][0];\\n    for(int i=len-2;i>=0;i--){\\n        long not =dp[i+1],take=0;\\n        if(i+Q[i][1]+1<len) take=Q[i][0]+dp[i+Q[i][1]+1];\\n        else take = Q[i][0];\\n        dp[i]= Math.max(take,not);\\n    } return dp[0];\\n}\\n```\n```c++ []\\nlong long mostPoints<vector<int>>& Q) {\\n    int len = Q.size();\\n    vector<long long> dp(len);\\n    dp[len-1] = Q[len-1][0];\\n    for (int i = len-2; i >= 0; i--) {\\n        long long not = dp[i+1];\\n        long long take = 0;\\n        if (i+Q[i][1]+1 < len) {\\n            take = Q[i][0] + dp[i+Q[i][1]+1];\\n        } else {\\n            take = Q[i][0];\\n        }\\n        dp[i] = max(take, not);\\n    }\\n    return dp[0];\\n}\\n```\n```python []\\ndef mostPoints(Q: List[List[int]]) -> int:\\n    n = len(Q)\\n    dp = [0] * n\\n    dp[n-1] = Q[n-1][0]\\n    for i in range(n-2, -1, -1):\\n        not_take = dp[i+1]\\n        take = 0\\n        if i+Q[i][1]+1 < n:\\n            take = Q[i][0] + dp[i+Q[i][1]+1]\\n        else:\\n            take = Q[i][0]\\n        dp[i] = max(take, not_take)\\n    return dp[0]\\n```\n```JAVA []\\npublic long mostPoints(int[][] questions) {\\n    final int n = questions.length;\\n    long[] dp = new long[n + 1];\\n    for (int i = n - 1; i >= 0; --i) {\\n        final int points = questions[i][0];\\n        final int brainpower = questions[i][1];\\n        final int nextIndex = i + brainpower + 1;\\n        final long nextPoints = nextIndex < n ? dp[nextIndex] : 0;\\n        dp[i] = Math.max(points + nextPoints, dp[i + 1]);\\n    } return dp[0];\\n}\\n```\n```JAVA []\\npublic long mostPoints(int[][] questions) {\\n    final int n = questions.length;\\n    long[] dp = new long[n + 1];\\n    IntStream.rangeClosed(0, n - 1).boxed().sorted(Collections.reverseOrder())\\n        .forEach(i -> {\\n            final int points = questions[i][0];\\n            final int brainpower = questions[i][1];\\n            final int nextIndex = i + brainpower + 1;\\n            final long nextPoints = nextIndex < n ? dp[nextIndex] : 0;\\n            dp[i] = Math.max(points + nextPoints, dp[i + 1]);\\n        });\\n    return dp[0];\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1693033,
                "title": "easy-dp-solution-c-with-explaination",
                "content": "Detailed thought process for these kind of problems(with Dynamic Programming)\\n\\n* Here maxPoints for each index *i* depends on other indices to the right of *i* and thus this problem had a scope for being broken down into sub problems.\\n* For base case we observe that the right most elements don\\'t depend on any other elements to the right.\\n* Similarly any element with value` x = i + brainpower[i] >=n `does not depend on any element on right.\\n* Now the only problem left is that we need to consider a case when we have to chose between all possible elements to the right. For that we used pair to store the maximum possible answer after that index in ans variable: `ans=max(ans,dp[i].first);`\\n* Finally we just compared the values and put them in dp array.\\n\\n\\n\\n```\\n\\nlong long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        long long ans=0;\\n        vector<pair<long long,long long>> dp(n);\\n        for(int i=n-1;i>=0;i--){\\n            int x=i+questions[i][1]+1;\\n            if(x<n) dp[i].first= questions[i][0] + max(dp[x].first,dp[x].second); \\n            else dp[i].first=questions[i][0];\\n            ans=max(ans,dp[i].first);\\n            dp[i].second=ans;\\n        }\\n        return ans;\\n    }\\n\\n\\tUpvote if it helped  :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "Detailed thought process for these kind of problems(with Dynamic Programming)\\n\\n* Here maxPoints for each index *i* depends on other indices to the right of *i* and thus this problem had a scope for being broken down into sub problems.\\n* For base case we observe that the right most elements don\\'t depend on any other elements to the right.\\n* Similarly any element with value` x = i + brainpower[i] >=n `does not depend on any element on right.\\n* Now the only problem left is that we need to consider a case when we have to chose between all possible elements to the right. For that we used pair to store the maximum possible answer after that index in ans variable: `ans=max(ans,dp[i].first);`\\n* Finally we just compared the values and put them in dp array.\\n\\n\\n\\n```\\n\\nlong long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        long long ans=0;\\n        vector<pair<long long,long long>> dp(n);\\n        for(int i=n-1;i>=0;i--){\\n            int x=i+questions[i][1]+1;\\n            if(x<n) dp[i].first= questions[i][0] + max(dp[x].first,dp[x].second); \\n            else dp[i].first=questions[i][0];\\n            ans=max(ans,dp[i].first);\\n            dp[i].second=ans;\\n        }\\n        return ans;\\n    }\\n\\n\\tUpvote if it helped  :)",
                "codeTag": "Unknown"
            },
            {
                "id": 3514541,
                "title": "java-easy-solution-easy-to-understand-simple-approach-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n Each question has a certain number of points associated with it, as well as a number of subsequent questions that can be skipped. We can solve this problem using dynamic programming, by computing the maximum number of points that can be earned by answering questions starting from each position.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use dynamic programming to solve this problem. We can define a 1D array \"dp\" of length \"s\", where \"n\" is the number of questions. The value of \"dp[i]\" represents the maximum number of points that can be earned by answering questions starting from position \"i\". We can start by initializing \"dp[s-1]\" to the point value of the last question. Then, we can loop through the array from right to left, and for each position \"i\", we can compute the maximum number of points that can be earned by either answering the current question and moving to the next reachable question, or by skipping the current question and moving to the next reachable question. We can then store this value in \"dp[i]\". Finally, the maximum number of points can be obtained by answering questions starting from position 0, which is stored in \"dp[0]\".\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n     int s=questions.length;\\n     long[] dp = new long[s];\\n     dp[s-1]=questions[s-1][0];\\n     for(int i=s-2;i>=0;i--){\\n         int nqp = i+questions[i][1]+1;//next question position\\n         dp[i] = Math.max(questions[i][0]+(nqp>=s ? 0:dp[nqp]),dp[i+1]);\\n     }\\n     return dp[0];\\n    }\\n}\\n```\\nupvotes are encouraging",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n     int s=questions.length;\\n     long[] dp = new long[s];\\n     dp[s-1]=questions[s-1][0];\\n     for(int i=s-2;i>=0;i--){\\n         int nqp = i+questions[i][1]+1;//next question position\\n         dp[i] = Math.max(questions[i][0]+(nqp>=s ? 0:dp[nqp]),dp[i+1]);\\n     }\\n     return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693569,
                "title": "simple-dp-memoization-solution-python-beats-100-time-and-space",
                "content": "## Intuition:\\nThis problem can be solved using simple DP with memoization through recursion. \\n**Conditions:** So essentially if you solve the ith question you would not be able to solve the next brainpower[i] questions. \\nSo at each step you have two choices:\\n1. Either to solve the ith question. If we so this then skip the next ith brainpower number of questions and give yourselves points for that question\\n2.  Not to solve the ith questions. We move to the next question without skipping anything and do not get any points for that particular question\\n```\\nFor Example: [[3,2], [4,1], [4,4], [2,5], [3,6], [4,1]]\\n\\t\\t\\t\\tA      B      C      D      E      F \\n```\\n**Now lets say we are at index B**\\n**Now we have 2 choices, either to solve B for 2 points and skip next 2 questions(move to D) or not solve B and move to next question that is C:**\\n1. For the 1st case we move to D and apply the same recursive function recursion(index=D)\\n2. For the 2nd case we will again have 2 choices for C. For here too we will have 2 choices skip or not. If we skipped C and moved to D we will again call recursion(index=D). However we had already calculated the value of recursion(index=D) in the first case and we are calling it again. \\n\\t\\nHence solving for it again is no good. Thus, not only will we solve but we will also store the results of these computations in an memo array. \\n\\n### Important: memo[i] stores the maximum marks we can get from the questions i, i+1, i+2,......,n\\n\\n## Code:\\n```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n = len(questions) # total number of questions\\n        memo = [-1] * n # memo array of size n. \\n\\t\\t# If memo[i] is not computed then its value must be -1 and we need to find memo[i]\\n\\t\\t# If memo[i] != -1, this means we have already calculated this and we dont need to recompute it\\n        def rec_func(index, current_val) -> int: # index is the current question number to process and current_val is the max marks upto this question\\n            if index >= n: # It means that we have gone through all the questions thus return the current_val\\n                return current_val\\n            if memo[index] == -1: # memo[i] == -1, not computed before and so we need to solve it\\n                points = questions[index][0] # points for current question\\n                brainpower = questions[index][1] # brainpower for current question\\n                a = rec_func(index + brainpower + 1, points) # Recursive call considering we solve the current question\\n                b = rec_func(index + 1, 0) # Recursive call considering we skip the current question\\n                memo[index] = max(a, b) # choose which ever choice yields us the best result\\n            return current_val+memo[index]\\n        return rec_func(0, 0)\\n```\\nOne might get confused why we return ```current_val+memo[index]```. It is because of the fact that memo[index] gives us the best result from that question forward forgetting about previous questions. We do not consider the previous history of current_val at all computation at any index. ***Check the important point again.***\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nFor Example: [[3,2], [4,1], [4,4], [2,5], [3,6], [4,1]]\\n\\t\\t\\t\\tA      B      C      D      E      F \\n```\n```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n = len(questions) # total number of questions\\n        memo = [-1] * n # memo array of size n. \\n\\t\\t# If memo[i] is not computed then its value must be -1 and we need to find memo[i]\\n\\t\\t# If memo[i] != -1, this means we have already calculated this and we dont need to recompute it\\n        def rec_func(index, current_val) -> int: # index is the current question number to process and current_val is the max marks upto this question\\n            if index >= n: # It means that we have gone through all the questions thus return the current_val\\n                return current_val\\n            if memo[index] == -1: # memo[i] == -1, not computed before and so we need to solve it\\n                points = questions[index][0] # points for current question\\n                brainpower = questions[index][1] # brainpower for current question\\n                a = rec_func(index + brainpower + 1, points) # Recursive call considering we solve the current question\\n                b = rec_func(index + 1, 0) # Recursive call considering we skip the current question\\n                memo[index] = max(a, b) # choose which ever choice yields us the best result\\n            return current_val+memo[index]\\n        return rec_func(0, 0)\\n```\n```current_val+memo[index]```",
                "codeTag": "Java"
            },
            {
                "id": 1693069,
                "title": "simple-java-dp-solution-with-recursion",
                "content": "DP Version: (AC: 7ms)\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long[] dp = new long[n+1];\\n        dp[n] = 0;\\n        for(int i = n - 1; i >= 0; i--){\\n            //check if it is not possible to find points after required brainpower\\n            if(questions[i][1] + i + 1 > n){\\n                dp[i] = Math.max(dp[i+1], questions[i][0]);\\n            }\\n            else{\\n                //if possible then add in current value and find maximum till now\\n                 dp[i] = Math.max(dp[i+1], questions[i][0] + dp[i + questions[i][1] + 1]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\nUPDATE:\\nRecursion version:(Gets TLE)\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        return recursion(0, questions);\\n    }\\n    private long recursion(int i, int[][] questions){\\n        if(i == questions.length){\\n            return 0;\\n        }\\n        if(questions[i][1] + i + 1 > questions.length){\\n            return Math.max(recursion(i+1, questions), questions[i][0]);\\n        }\\n        else{\\n            return Math.max(recursion(i+1, questions), questions[i][0] + recursion(i + questions[i][1] + 1, questions));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long[] dp = new long[n+1];\\n        dp[n] = 0;\\n        for(int i = n - 1; i >= 0; i--){\\n            //check if it is not possible to find points after required brainpower\\n            if(questions[i][1] + i + 1 > n){\\n                dp[i] = Math.max(dp[i+1], questions[i][0]);\\n            }\\n            else{\\n                //if possible then add in current value and find maximum till now\\n                 dp[i] = Math.max(dp[i+1], questions[i][0] + dp[i + questions[i][1] + 1]);\\n            }\\n        }\\n        return dp[0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        return recursion(0, questions);\\n    }\\n    private long recursion(int i, int[][] questions){\\n        if(i == questions.length){\\n            return 0;\\n        }\\n        if(questions[i][1] + i + 1 > questions.length){\\n            return Math.max(recursion(i+1, questions), questions[i][0]);\\n        }\\n        else{\\n            return Math.max(recursion(i+1, questions), questions[i][0] + recursion(i + questions[i][1] + 1, questions));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692906,
                "title": "java-simple-recursion-solution-with-memorization",
                "content": "So basically like House Robber. At each of the question, we can choose answer it or not:\\n* If we answer it, we skip next \"question[i][1]\" questions, so we return this by doing it recursively. \\n* If we do not answer it, we just go to next question. \\n\\nSo there are only two choices at each question, we just need to return the bigger one. \\n\\nTo save a lot of time doing recursive search, store the value of same start and same end, so with memorization, we can save a lot of time. \\n\\nI tried 2-dimentional array to save values, it shows out of memory, so HashMap on the other hand, is On, which can satisfy the memory requirement.\\n\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        Map<String, Long> map = new HashMap<>();\\n        return helper(questions, 0, questions.length - 1, map);\\n    }\\n    private long helper(int[][] questions, int start, int end, Map<String, Long> map) {\\n        if (start > end) {\\n            return 0;\\n        }\\n        String key = String.valueOf(start + \",\" + end);\\n        if (map.containsKey(key)) {\\n            return map.get(key);\\n        }\\n\\t\\t// answer the current question, skip next questions[i][1] questions\\n        long cur = questions[start][0] + helper(questions, start + questions[start][1] + 1, end, map);\\n\\t\\t// do not answer the current question, go to next question\\n        long next = helper(questions, start + 1, end, map);\\n\\t\\t\\n\\t\\t// get the bigger result\\n        long res = Math.max(cur, next);\\n\\t\\t// save it into map to save time\\n        map.put(key, res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        Map<String, Long> map = new HashMap<>();\\n        return helper(questions, 0, questions.length - 1, map);\\n    }\\n    private long helper(int[][] questions, int start, int end, Map<String, Long> map) {\\n        if (start > end) {\\n            return 0;\\n        }\\n        String key = String.valueOf(start + \",\" + end);\\n        if (map.containsKey(key)) {\\n            return map.get(key);\\n        }\\n\\t\\t// answer the current question, skip next questions[i][1] questions\\n        long cur = questions[start][0] + helper(questions, start + questions[start][1] + 1, end, map);\\n\\t\\t// do not answer the current question, go to next question\\n        long next = helper(questions, start + 1, end, map);\\n\\t\\t\\n\\t\\t// get the bigger result\\n        long res = Math.max(cur, next);\\n\\t\\t// save it into map to save time\\n        map.put(key, res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652607,
                "title": "easy-solution-memoization-begginer-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long  calculate(vector<vector<int>> &q,  int pos,  vector<long long >&dp){\\n        if(pos >= q.size()) {return 0; }\\n        long long  t1 = 0, t2 = 0; \\n        if(dp[pos+1] == -1) dp[pos+1] = calculate(q, pos+1, dp); \\n        t1 = dp[pos+1]; \\n        if(pos+1+q[pos][1] < q.size() ) {\\n\\n            if(dp[pos+1+q[pos][1]] == -1){dp[pos+1+q[pos][1]] = calculate(q, pos+1+q[pos][1], dp);}\\n            t2 += dp[pos+1+q[pos][1]]; \\n        }\\n        t2 += q[pos][0];  \\n        \\n        return max(t1, t2); \\n    }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long > dp(questions.size()+1, -1); \\n        long long ans = 0; \\n        ans = calculate(questions,0, dp); \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long  calculate(vector<vector<int>> &q,  int pos,  vector<long long >&dp){\\n        if(pos >= q.size()) {return 0; }\\n        long long  t1 = 0, t2 = 0; \\n        if(dp[pos+1] == -1) dp[pos+1] = calculate(q, pos+1, dp); \\n        t1 = dp[pos+1]; \\n        if(pos+1+q[pos][1] < q.size() ) {\\n\\n            if(dp[pos+1+q[pos][1]] == -1){dp[pos+1+q[pos][1]] = calculate(q, pos+1+q[pos][1], dp);}\\n            t2 += dp[pos+1+q[pos][1]]; \\n        }\\n        t2 += q[pos][0];  \\n        \\n        return max(t1, t2); \\n    }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long > dp(questions.size()+1, -1); \\n        long long ans = 0; \\n        ans = calculate(questions,0, dp); \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515587,
                "title": "c-recursion-memoization-tabulation-1d-dynamic-programming-beginner-friendly",
                "content": "# Recursion (TLE)\\n\\n```\\nclass Solution {\\npublic:\\n    long long dfs(int ind, vector<vector<int>>& questions, int n) {\\n        if (ind >= n) return 0;\\n\\n        long long pick = questions[ind][0] + dfs(ind + questions[ind][1] + 1, questions, n);\\n        long long notPick = 0 + dfs(ind + 1, questions, n);\\n\\n        return max(pick, notPick);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        return dfs(0, questions, n);\\n    }\\n};\\n```\\n# Memoization (Accepted)\\n```\\nclass Solution {\\npublic:\\n    long long dfs(int ind, vector<vector<int>>& questions, int n, vector<long long>& dp) {\\n        if (ind >= n) return 0;\\n        if (dp[ind] != -1) return dp[ind];\\n        long long pick = questions[ind][0] + dfs(ind + questions[ind][1] + 1, questions, n, dp);\\n        long long notPick = 0 + dfs(ind + 1, questions, n, dp);\\n\\n        return dp[ind] = max(pick, notPick);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long> dp(n, -1);\\n        return dfs(0, questions, n, dp);\\n    }\\n};\\n```\\n# Tabulation (Accepted)\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size(), jumpInd = 0;\\n        long long pick = 0, notPick = 0;\\n        vector<long long> dp(n, -1);\\n\\n        for(int ind = n - 1; ind >= 0; ind--) {\\n            jumpInd = ind + questions[ind][1] + 1;\\n\\n            pick = questions[ind][0];\\n            if (jumpInd < n) pick +=  dp[jumpInd];\\n\\n            notPick = 0;\\n            if (ind + 1 < n) notPick += dp[ind + 1];\\n\\n            dp[ind] = max(pick, notPick);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dfs(int ind, vector<vector<int>>& questions, int n) {\\n        if (ind >= n) return 0;\\n\\n        long long pick = questions[ind][0] + dfs(ind + questions[ind][1] + 1, questions, n);\\n        long long notPick = 0 + dfs(ind + 1, questions, n);\\n\\n        return max(pick, notPick);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        return dfs(0, questions, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long dfs(int ind, vector<vector<int>>& questions, int n, vector<long long>& dp) {\\n        if (ind >= n) return 0;\\n        if (dp[ind] != -1) return dp[ind];\\n        long long pick = questions[ind][0] + dfs(ind + questions[ind][1] + 1, questions, n, dp);\\n        long long notPick = 0 + dfs(ind + 1, questions, n, dp);\\n\\n        return dp[ind] = max(pick, notPick);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long> dp(n, -1);\\n        return dfs(0, questions, n, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size(), jumpInd = 0;\\n        long long pick = 0, notPick = 0;\\n        vector<long long> dp(n, -1);\\n\\n        for(int ind = n - 1; ind >= 0; ind--) {\\n            jumpInd = ind + questions[ind][1] + 1;\\n\\n            pick = questions[ind][0];\\n            if (jumpInd < n) pick +=  dp[jumpInd];\\n\\n            notPick = 0;\\n            if (ind + 1 < n) notPick += dp[ind + 1];\\n\\n            dp[ind] = max(pick, notPick);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2994161,
                "title": "o-n-dp-bottom-up-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public long MostPoints(int[][] questions) {\\n        var dp = new long[questions.Length + 1];\\n        dp[questions.Length] = 0;\\n        for(var i = questions.Length - 1; i >=0; i--){\\n            var miss = questions[i][1];\\n            long nextifanswered = (i + 1 + miss < questions.Length) ? dp[i + 1 + miss] : 0;\\n            dp[i] = Math.Max(dp[i + 1], questions[i][0] + nextifanswered);\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public long MostPoints(int[][] questions) {\\n        var dp = new long[questions.Length + 1];\\n        dp[questions.Length] = 0;\\n        for(var i = questions.Length - 1; i >=0; i--){\\n            var miss = questions[i][1];\\n            long nextifanswered = (i + 1 + miss < questions.Length) ? dp[i + 1 + miss] : 0;\\n            dp[i] = Math.Max(dp[i + 1], questions[i][0] + nextifanswered);\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831340,
                "title": "java-time-o-n-space-o-h-dfs-iterative",
                "content": "\\n**List some examples:**\\n\\n1. [[1,3]]\\n2. [[1,3], [2,2], [3,1]]\\n3. [[1,3], [2,2], [3,1], [3,1], [1,2]]\\n\\n\\n**Think aloud:**\\n1. Let\\'s look at example 1. There is only one question in the list. Obviously, we don\\'t need to care how many the next questions to skip. And we can get points directly.\\n\\t- [**[1, 3]**] -> Get 1 point\\n2. Let\\'s look at example 2. There are three questions in the list. However, we can still get points directly, because each question skips the following questions.\\n\\t- [**[1,3]**, [2,2], [3,1]] => 1 point\\n\\t   ___ | _____________________ |\\n\\t- [[1,3], **[2,2]**, [3,1]] => 2 points\\n\\t   _________ | _______________ |\\n\\t- [[1,3], [2,2], **[3,1]**] => 3 points\\n\\t   _______________ | _________ |\\n3. Let\\'s look at example 3. There are five questions in the list. So, each question will sum its points and the points that next solvable question.\\n\\t- [**[1,3]**, [2,2], [3,1], [3,1], **[1,2]**] => 1 point + 1 point = 2 points\\n\\t- [[1,3], **[2,2]**, [3,1], [3,1], **[1,2]**] => 2 points + 1 point = 3 points\\n\\t- [[1,3], [2,2], **[3,1]**, [3,1], **[1,2]**] => 3 points + 1 point = 4 points\\n\\tWe can find out if we want to have max points, we should calculate all possible and return the max points. Each question will be effect by the following questions. However, based on the previous conclusions, we can be pretty sure of the highest points for the last question.\\n4. We can start from the backend to calculate the maximum points and compare to the frontend.\\n\\t- [[1,3], [2,2], [3,1], [3,1], **[1,2]**] => 1 point\\n      [ ___ , _____ , ___ , _____ , 1 ]\\n\\t- [[1,3], [2,2], [3,1], **[3,1]**, **[1,2]**] => Max(3 points, 1 point) => 3 points\\n      [ ___ , _____ , ___ ,  3  , **1** ]\\n\\t- [[1,3], [2,2], **[3,1]**, [3,1], **[1,2]**] => 3 points + 1 point = 4 points\\n\\t  [[1,3], [2,2], **[3,1]**, **[3,1]**, [1,2]] => Max(4 points, 3 points) => 4 points\\n      [ ___ , _____ ,  4  ,  **3**  , 1 ]\\n\\t- [[1,3], **[2,2]**, [3,1], [3,1], **[1,2]**] => 2 points + 1 point = 3 points\\n\\t  [[1,3], **[2,2]**, **[3,1]**, [3,1], [1,2]] => Max(3 points, 4 points) => 4 points\\n      [ ___ , 4 ,  **4**  ,  3  , 1 ]\\n\\t- [**[1,3]**, [2,2], [3,1], [3,1], **[1,2]**] => 1 points + 1 point = 2 points\\n\\t  [**[1,3]**, **[2,2]**, [3,1], [3,1], [1,2]] => Max(2 points, 4 points) => 4 points\\n      [ 4 , **4** ,  4  ,  3  , 1 ]\\n\\n**Analyze complexity:**\\nBoth time and space complexity are O(n)\\nHowever, iterative implementation\\'s runtime is faster.\\n\\n**DFS**\\n\\n```\\nclass SolveQsWithBrainPowDFS {\\n  long[] memo;\\n  int[][] qs;\\n  \\n  public long mostPoints(int[][] questions) {\\n    // Space O(n)\\n    memo = new long[questions.length];\\n    qs = questions;\\n    return dp(0);\\n  }\\n  \\n  private long dp(int n) {\\n    if (n > qs.length - 1) return 0;\\n    if (n == qs.length - 1) return qs[n][0];\\n    /**\\n     * Time O(n)\\n     * Space O(n)\\n     */\\n    if (memo[n] == 0) memo[n] = Math.max(qs[n][0] + dp(n + 1 + qs[n][1]), dp(n + 1));\\n    return memo[n];\\n  }\\n}\\n```\\n\\n**Iterative**\\n\\n```\\nclass SolveQsWithBrainPowIterative {\\n  public long mostPoints(int[][] questions) {\\n    // Space O(n)\\n    long[] dp = new long[questions.length];\\n    dp[questions.length - 1] = questions[questions.length - 1][0];\\n    // Time O(n)\\n    for (int i = questions.length - 2; i >= 0; i--) {\\n      int idx = i + 1 + questions[i][1];\\n      if (idx < questions.length) dp[i] = Math.max(questions[i][0] + dp[idx], dp[i + 1]);\\n\\t  else dp[i] = Math.max(questions[i][0], dp[i + 1]);\\n    }\\n    return dp[0];\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass SolveQsWithBrainPowDFS {\\n  long[] memo;\\n  int[][] qs;\\n  \\n  public long mostPoints(int[][] questions) {\\n    // Space O(n)\\n    memo = new long[questions.length];\\n    qs = questions;\\n    return dp(0);\\n  }\\n  \\n  private long dp(int n) {\\n    if (n > qs.length - 1) return 0;\\n    if (n == qs.length - 1) return qs[n][0];\\n    /**\\n     * Time O(n)\\n     * Space O(n)\\n     */\\n    if (memo[n] == 0) memo[n] = Math.max(qs[n][0] + dp(n + 1 + qs[n][1]), dp(n + 1));\\n    return memo[n];\\n  }\\n}\\n```\n```\\nclass SolveQsWithBrainPowIterative {\\n  public long mostPoints(int[][] questions) {\\n    // Space O(n)\\n    long[] dp = new long[questions.length];\\n    dp[questions.length - 1] = questions[questions.length - 1][0];\\n    // Time O(n)\\n    for (int i = questions.length - 2; i >= 0; i--) {\\n      int idx = i + 1 + questions[i][1];\\n      if (idx < questions.length) dp[i] = Math.max(questions[i][0] + dp[idx], dp[i + 1]);\\n\\t  else dp[i] = Math.max(questions[i][0], dp[i + 1]);\\n    }\\n    return dp[0];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701341,
                "title": "solving-using-simple-01-knapsack-approach",
                "content": "The solution is just a modification of 01 knapsack\\n\\n```class Solution {\\npublic:\\n    \\n    long long knapsack(int idx, vector<vector<int>> &questions, vector<long long> &dp){\\n        if(idx >= questions.size()){\\n            return 0;\\n        }\\n        \\n        if(dp[idx] != -1)\\n            return dp[idx];\\n        \\n        long long op1 = knapsack(idx + questions[idx][1] + 1, questions, dp) + questions[idx][0];\\n        long long op2 = knapsack(idx + 1, questions, dp) + 0;\\n        \\n        return dp[idx] = max(op1, op2);\\n    }\\n    \\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long> dp(questions.size(), -1);\\n        return knapsack(0, questions, dp);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    long long knapsack(int idx, vector<vector<int>> &questions, vector<long long> &dp){\\n        if(idx >= questions.size()){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1693872,
                "title": "c-javascript-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>&nums) \\n    {\\n        int n=nums.size();\\n        long long dp[n+2];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            dp[i]=max(dp[i+1]+0ll,nums[i][0]+dp[min(n+1,i+nums[i][1]+1)]+0ll);\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n```\\n/**\\n * @param {number[][]} questions\\n * @return {number}\\n */\\nvar max=function(a,b)\\n{\\n    return a>b?a:b;\\n}\\nvar min=(a,b)=>{\\n    return a>b?b:a;\\n}\\nvar mostPoints = function(nums) \\n{\\n    let n=nums.length;\\n    let dp=new Array(n+1);\\n    dp.fill(0);\\n    for(let i=n-1;i>=0;i--){\\n        dp[i]=max(dp[i+1],nums[i][0]+dp[min(i+nums[i][1]+1,n)]);\\n    }\\n    return dp[0];\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>&nums) \\n    {\\n        int n=nums.size();\\n        long long dp[n+2];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            dp[i]=max(dp[i+1]+0ll,nums[i][0]+dp[min(n+1,i+nums[i][1]+1)]+0ll);\\n        }\\n        return dp[0];\\n    }\\n};\\n```\n```\\n/**\\n * @param {number[][]} questions\\n * @return {number}\\n */\\nvar max=function(a,b)\\n{\\n    return a>b?a:b;\\n}\\nvar min=(a,b)=>{\\n    return a>b?b:a;\\n}\\nvar mostPoints = function(nums) \\n{\\n    let n=nums.length;\\n    let dp=new Array(n+1);\\n    dp.fill(0);\\n    for(let i=n-1;i>=0;i--){\\n        dp[i]=max(dp[i+1],nums[i][0]+dp[min(i+nums[i][1]+1,n)]);\\n    }\\n    return dp[0];\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693185,
                "title": "dp",
                "content": "Easy top down, starightforward.\\n```\\nclass Solution {\\npublic:\\n    long long dp[100005];\\n    vector <vector<int>> a;\\n    int n;\\n    \\n    long long f(int i) {\\n        if (i >= n) return 0;\\n        long long &res = dp[i];\\n        if (res != -1) return res;\\n        res = a[i][0] + f(i + a[i][1] + 1);\\n        res = max(res, f(i + 1));\\n        return res;\\n    }\\n    \\n    long long mostPoints(vector<vector<int>>& questions) {\\n        this->a = questions;\\n        this->n = a.size();\\n        memset(dp, -1, sizeof dp);\\n        return f(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100005];\\n    vector <vector<int>> a;\\n    int n;\\n    \\n    long long f(int i) {\\n        if (i >= n) return 0;\\n        long long &res = dp[i];\\n        if (res != -1) return res;\\n        res = a[i][0] + f(i + a[i][1] + 1);\\n        res = max(res, f(i + 1));\\n        return res;\\n    }\\n    \\n    long long mostPoints(vector<vector<int>>& questions) {\\n        this->a = questions;\\n        this->n = a.size();\\n        memset(dp, -1, sizeof dp);\\n        return f(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693114,
                "title": "recursive-to-top-up-dp-step-by-step-memoization",
                "content": "First create recursive solution :\\nRecursive solution has two parts:\\n* Base part\\n* Choices (which makes this problem recursive)  can be also called as recurrence relation\\n**Base** \\nWe reach the end so we cannot go any further so we return 0\\n**Choices**\\n\\t1. Either we do not select this question the we move by one step.\\n\\t2. Or we select the solution and move question[i][1] i.e number of brainpower.\\nSince the solution wants the maximum point we use *max()*\\nUsing memoization technique to store already handled cases.\\n```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n\\t\\tN = len(questions)\\n        \\n        memo = [-1 for x in range(N+2)]\\n        def solve(n):\\n            if n>=N:\\n                return 0\\n            if memo[n]!=-1:\\n                return memo[n]\\n            memo[n] = max(solve(n+1),solve(n+questions[n][1]+1)+questions[n][0])\\n            return memo[n]\\n        return solve(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n\\t\\tN = len(questions)\\n        \\n        memo = [-1 for x in range(N+2)]\\n        def solve(n):\\n            if n>=N:\\n                return 0\\n            if memo[n]!=-1:\\n                return memo[n]\\n            memo[n] = max(solve(n+1),solve(n+questions[n][1]+1)+questions[n][0])\\n            return memo[n]\\n        return solve(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693012,
                "title": "simple-o-n-dp-solution",
                "content": "This is same as House Robber Question\\n\\n```\\nlong long mostPoints(vector<vector<int>>& questions) {\\n        typedef long long ll;\\n        \\n        ll n = size(questions);\\n        ll dp[n];\\n        memset(dp,0,sizeof dp);\\n        dp[n-1] = questions.back()[0];\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            // if skip, then ans is whatever we found at i+1\\n            dp[i] = dp[i+1];\\n            //if attempt, then ans is min of earlier and curr + max after skipping brainpower question (in case of out of bound it is 0)\\n            ll idx = i + questions[i][1] + 1;\\n            ll val = idx >= n ? 0 : dp[idx];\\n            dp[i] = max(dp[i] , questions[i][0] + val);\\n        }\\n        \\n        return dp[0];\\n    }\\n```\\n\\n**Time Complexity :** O(n)\\n**Space Complexity :** O(n)",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nlong long mostPoints(vector<vector<int>>& questions) {\\n        typedef long long ll;\\n        \\n        ll n = size(questions);\\n        ll dp[n];\\n        memset(dp,0,sizeof dp);\\n        dp[n-1] = questions.back()[0];\\n        \\n        for(int i=n-2;i>=0;i--)\\n        {\\n            // if skip, then ans is whatever we found at i+1\\n            dp[i] = dp[i+1];\\n            //if attempt, then ans is min of earlier and curr + max after skipping brainpower question (in case of out of bound it is 0)\\n            ll idx = i + questions[i][1] + 1;\\n            ll val = idx >= n ? 0 : dp[idx];\\n            dp[i] = max(dp[i] , questions[i][0] + val);\\n        }\\n        \\n        return dp[0];\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1692955,
                "title": "c-dp-approach-easy-to-understand",
                "content": "dynamic programming apporach:\\nWe will store the maximum points that can be obtained from i to n-1 (0-based indexing) in dp[i].\\n\\nwhile iterating from i=n-1 to i=0\\n\\nfor each dp[i]\\n  skip=i+quesitons[i][1]+1;\\nif(skip<n)\\n   dp[i] = max (dp[i+1] , question[i][0]+dp[skip] )\\nelse dp[i]=max( dp[i+1] , questions[i][0] )\\n\\n\\n```\\nclass Solution {\\npublic:\\n   \\n    long long mostPoints(vector<vector<int>>& q) {\\n      \\n        vector<long long> dp(q.size(),-1);  // initializing dp with -1\\n        dp[q.size()-1]=q[q.size()-1][0];  // max points by last element will be its own points only\\n        \\n        for(int i=q.size()-2;i>=0;i--)\\n        { \\n            int skip=i+q[i][1]+1; // skip is the next index after skipping brainpower no. of elements\\n            dp[i]=dp[i+1]; \\n            \\n            if(skip<q.size() && dp[i]<dp[skip]+q[i][0])\\n            dp[i]=q[i][0]+dp[skip];\\n            \\n            else if(dp[i]<q[i][0])\\n                dp[i]=q[i][0];\\n        }\\n        \\n        return dp[0];\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    long long mostPoints(vector<vector<int>>& q) {\\n      \\n        vector<long long> dp(q.size(),-1);  // initializing dp with -1\\n        dp[q.size()-1]=q[q.size()-1][0];  // max points by last element will be its own points only\\n        \\n        for(int i=q.size()-2;i>=0;i--)\\n        { \\n            int skip=i+q[i][1]+1; // skip is the next index after skipping brainpower no. of elements\\n            dp[i]=dp[i+1]; \\n            \\n            if(skip<q.size() && dp[i]<dp[skip]+q[i][0])\\n            dp[i]=q[i][0]+dp[skip];\\n            \\n            else if(dp[i]<q[i][0])\\n                dp[i]=q[i][0];\\n        }\\n        \\n        return dp[0];\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516139,
                "title": "python-3-bottom-up-dp",
                "content": "# Intuition\\ndp is the only option.\\n\\n# Approach\\nbottom up DP\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        lq = len(questions)\\n        dp = [0] * (lq + 1)\\n\\n        for i in range(len(questions) - 1, -1, -1):\\n            pt, bp = questions[i]\\n\\n            nxt = i + bp + 1\\n            nxt = lq if nxt >= lq else nxt\\n\\n            dp[i] = max(dp[i+1], pt + dp[nxt])\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        lq = len(questions)\\n        dp = [0] * (lq + 1)\\n\\n        for i in range(len(questions) - 1, -1, -1):\\n            pt, bp = questions[i]\\n\\n            nxt = i + bp + 1\\n            nxt = lq if nxt >= lq else nxt\\n\\n            dp[i] = max(dp[i+1], pt + dp[nxt])\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515773,
                "title": "c-easy-solution-dynamic-programming-top-down-approach",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Classic DP optimization, whether to take it or leave it.\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long helper(int curr, vector<vector<int>>& questions, vector<long long> &dp){\\n        if(curr >= questions.size()){\\n            return 0;\\n        }\\n        if(dp[curr] != -1){\\n            return dp[curr];\\n        }\\n        long long takeIt = questions[curr][0] + helper(curr + questions[curr][1]+1, questions, dp);\\n        long long skipIt = helper(curr+1, questions, dp);\\n        \\n        return dp[curr] = max(takeIt, skipIt);\\n    }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long> dp(questions.size(), -1);\\n        return helper(0, questions, dp);\\n    }\\n};\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/5ae8e3c1-707d-4bb4-9593-3ca4e0d947a9_1683887818.1566699.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long helper(int curr, vector<vector<int>>& questions, vector<long long> &dp){\\n        if(curr >= questions.size()){\\n            return 0;\\n        }\\n        if(dp[curr] != -1){\\n            return dp[curr];\\n        }\\n        long long takeIt = questions[curr][0] + helper(curr + questions[curr][1]+1, questions, dp);\\n        long long skipIt = helper(curr+1, questions, dp);\\n        \\n        return dp[curr] = max(takeIt, skipIt);\\n    }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long> dp(questions.size(), -1);\\n        return helper(0, questions, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515269,
                "title": "dp-recursive-and-interative-solution-easy-to-understand",
                "content": "\\n\\n# Approach\\nSolving with recusive approach and optimizing using Memoization or tabulation.\\n\\n\\n\\n# Top- Down Approach\\n```\\nclass Solution {\\npublic:\\n\\n    long long int mostPointsMemo(vector<vector<int>>& questions, long long int i, long long int n, vector<long long int> &dp)\\n    {\\n        // base cases\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        long long int inc = questions[i][0] + mostPointsMemo(questions, i + questions[i][1] + 1, n , dp);\\n        long long int exc = mostPointsMemo(questions, i + 1, n, dp);\\n\\n        return dp[i] = max(inc, exc);\\n    }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        long long int n = questions.size();\\n        vector<long long int> dp (n + 1, -1);\\n\\n        return mostPointsMemo(questions, 0, n, dp);\\n\\n        \\n    }\\n};\\n```\\n# Bottom Up Approach\\n```\\nclass Solution {\\npublic:\\n\\n    long long int mostPointsTab(vector<vector<int>>& questions) \\n    {\\n        long long int n = questions.size();\\n        vector<long long int> dp(n);\\n        dp[n - 1] = questions[n - 1][0];\\n\\n        for(long long int i = n - 2; i >= 0; i--) {\\n            dp[i] = questions[i][0];\\n            int skip = questions[i][1];\\n\\n            if(i + skip + 1 < n) {\\n                    dp[i] += dp[i + skip + 1];\\n            }\\n\\n            dp[i] = max(dp[i], dp[i + 1]);\\n        }\\n        return dp[0];\\n    }\\n\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        \\n        return mostPointsTab(questions);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long int mostPointsMemo(vector<vector<int>>& questions, long long int i, long long int n, vector<long long int> &dp)\\n    {\\n        // base cases\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        long long int inc = questions[i][0] + mostPointsMemo(questions, i + questions[i][1] + 1, n , dp);\\n        long long int exc = mostPointsMemo(questions, i + 1, n, dp);\\n\\n        return dp[i] = max(inc, exc);\\n    }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        long long int n = questions.size();\\n        vector<long long int> dp (n + 1, -1);\\n\\n        return mostPointsMemo(questions, 0, n, dp);\\n\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    long long int mostPointsTab(vector<vector<int>>& questions) \\n    {\\n        long long int n = questions.size();\\n        vector<long long int> dp(n);\\n        dp[n - 1] = questions[n - 1][0];\\n\\n        for(long long int i = n - 2; i >= 0; i--) {\\n            dp[i] = questions[i][0];\\n            int skip = questions[i][1];\\n\\n            if(i + skip + 1 < n) {\\n                    dp[i] += dp[i + skip + 1];\\n            }\\n\\n            dp[i] = max(dp[i], dp[i + 1]);\\n        }\\n        return dp[0];\\n    }\\n\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        \\n        return mostPointsTab(questions);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514952,
                "title": "100-beats-typescript-easy-to-read-easy-to-understand",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can solve this problem using dynamic programming by iterating over the questions array in reverse order, and for each question, calculating the maximum points we can earn if we either solve or skip the question. We store these maximum points in an array called dp, and finally, the maximum points we can earn for the exam will be stored in dp[0]. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nfunction mostPoints(questions: number[][]): number {\\n    const dp = new Array(questions.length);\\n    for (let i = questions.length - 1; i >= 0; i--) {\\n      const q = questions[i];\\n      const n = dp[i + 1] ?? 0;\\n      const f = dp[i + q[1] + 1] ?? 0;\\n      dp[i] = Math.max(q[0] + f, n);\\n    }\\n    return dp[0];\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction mostPoints(questions: number[][]): number {\\n    const dp = new Array(questions.length);\\n    for (let i = questions.length - 1; i >= 0; i--) {\\n      const q = questions[i];\\n      const n = dp[i + 1] ?? 0;\\n      const f = dp[i + q[1] + 1] ?? 0;\\n      dp[i] = Math.max(q[0] + f, n);\\n    }\\n    return dp[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514878,
                "title": "dp-0-1-knapsack-tabulation",
                "content": "# Intuition\\nWe can pick the current *question* then what is the **maximun score** we get and if we not pick then again what **maximun score** we get, similar to 0/1 knapsack pattern.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Start from last \\'nth\\' to \\'0th\\' index and fill this dp index.\\n2. We have two choices at current index, pick or not pick, if we pick then we check after skipping the questions what maximum score we can get.\\n3. If we don\\'t pick the ith, then assign (i + 1)th dp index to current index.\\n4. Get maximum out of 2nd and 3rd option and assign to the current index.\\n5. Atlast find maximun value dp is holding, then return this.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& v) {\\n        int n = v.size();\\n        long long ans = LLONG_MIN;\\n        vector<long long> dp(n+1, 0);\\n        for(int i=n-1; i>=0; i--){\\n            long long p = 0;\\n            // If it is exceding the n, then we will not include it.\\n            if(i + v[i][1] + 1 <= n){\\n                p = dp[i + v[i][1] + 1];\\n            }\\n            dp[i] = max(p + v[i][0], dp[i+1]);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& v) {\\n        int n = v.size();\\n        long long ans = LLONG_MIN;\\n        vector<long long> dp(n+1, 0);\\n        for(int i=n-1; i>=0; i--){\\n            long long p = 0;\\n            // If it is exceding the n, then we will not include it.\\n            if(i + v[i][1] + 1 <= n){\\n                p = dp[i + v[i][1] + 1];\\n            }\\n            dp[i] = max(p + v[i][0], dp[i+1]);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514776,
                "title": "very-easy-and-simple-solution-in-javascript-editorial-one-but-in-js-wow-you-must-look-0-0",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[][]} questions\\n * @return {number}\\n */\\nfunction mostPoints(questions) {\\n    let n = questions.length;\\n    let dp = new Array(n).fill(BigInt(0));\\n    dp[n - 1] = questions[n - 1][0];\\n        \\n    for (let i = n - 2; i >= 0; --i) {\\n        dp[i] = questions[i][0];\\n        let skip = questions[i][1];\\n        if (i + skip + 1 < n) {\\n            dp[i] += dp[i + skip + 1];\\n        }\\n        \\n        // dp[i] = max(solve it, skip it)\\n        dp[i] = Math.max(dp[i], dp[i + 1]);\\n    }\\n        \\n    return dp[0];\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} questions\\n * @return {number}\\n */\\nfunction mostPoints(questions) {\\n    let n = questions.length;\\n    let dp = new Array(n).fill(BigInt(0));\\n    dp[n - 1] = questions[n - 1][0];\\n        \\n    for (let i = n - 2; i >= 0; --i) {\\n        dp[i] = questions[i][0];\\n        let skip = questions[i][1];\\n        if (i + skip + 1 < n) {\\n            dp[i] += dp[i + skip + 1];\\n        }\\n        \\n        // dp[i] = max(solve it, skip it)\\n        dp[i] = Math.max(dp[i], dp[i + 1]);\\n    }\\n        \\n    return dp[0];\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514746,
                "title": "lc-2140-easy-c-dp-implementation-idea-code",
                "content": "# Intuition\\nFor each question we have two options, either take it or skip it.\\n\\nThink about states of taking and skipping the current question?\\nOn what states does this depends?\\n\\n# Approach\\nWe will use 1D DP, to solve above.\\ndp[i] denotes what is the max points we can get if we consider questions [i, i + 1, ... n - 1].\\nFor each question we will max of two options described above.\\n```\\ntake = current_question_points + dp[current_index + skips]\\nnot_take = dp[i + 1]\\ndp[i] = max(take, not_take);\\n```\\n\\n# Complexity\\n- Time complexity:\\n``` O(N) ```\\n\\n- Space complexity:\\n``` O(N) ```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long>dp(n);\\n        for(int i = n - 1; i >= 0; i--) {\\n            long long take = questions[i][0] + ((questions[i][1] + i + 1) < n ? dp[questions[i][1] + i + 1]: 0);\\n            long long not_take = (i == n - 1) ? 0: dp[i + 1];\\n            dp[i] = max(take, not_take);\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\nHope this helps.\\nAny suggestions or questions are welcomed in comments.\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\ntake = current_question_points + dp[current_index + skips]\\nnot_take = dp[i + 1]\\ndp[i] = max(take, not_take);\\n```\n``` O(N) ```\n``` O(N) ```\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long>dp(n);\\n        for(int i = n - 1; i >= 0; i--) {\\n            long long take = questions[i][0] + ((questions[i][1] + i + 1) < n ? dp[questions[i][1] + i + 1]: 0);\\n            long long not_take = (i == n - 1) ? 0: dp[i + 1];\\n            dp[i] = max(take, not_take);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514696,
                "title": "c-image-best-solution-recursion-memorization-tabulation-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst you have to find the recursieve solution. Then optimized that by Memoization for better time complexity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere the question is completely based on include exclude consept. in every index you have to decide that what is better include that element or exclude that. \\n>Then if you include you have to go to the index + brainpoweri + 1 index \\n>and if you exclude then go to next index.\\n\\n# Dry Run :-\\n![WhatsApp Image 2023-05-12 at 10.12.56 AM.jpeg](https://assets.leetcode.com/users/images/216187f2-3e31-47fb-9586-a6515346a5dc_1683866656.8123238.jpeg)\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Memoization\\n# Code\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n\\n    ll solveMemo(vector<vector<int>>& q, int index, vector<ll>& dp)    {\\n        if(index >= q.size()) return 0;\\n        if(dp[index] != -1)   return dp[index];\\n\\n        // include\\n        ll pointsIn = q[index][0] + solveMemo(q, index + q[index][1] + 1, dp);\\n\\n        // exclude\\n        ll pointsEx = solveMemo(q, index + 1, dp);\\n\\n        return dp[index] = (pointsIn > pointsEx) ? pointsIn : pointsEx;\\n    }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<ll> dp(questions.size() , -1);\\n        return solveMemo(questions, 0, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n# Code\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n\\n    ll solveTab(vector<vector<int>>& q)  {\\n        int n = q.size();\\n        vector<ll> dp(n+1 , 0);\\n        for(int i=n-1; i>=0; i--)    {\\n            int nextIndex= i+1+q[i][1]; \\n            long long include   = q[i][0] + ( (nextIndex<=n) ? dp[nextIndex] : 0 );\\n            long long exclude = dp[i+1];\\n            dp[i]= max(include,exclude);\\n        }\\n        return dp[0];\\n    }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        return solveTab(questions);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n\\n    ll solveMemo(vector<vector<int>>& q, int index, vector<ll>& dp)    {\\n        if(index >= q.size()) return 0;\\n        if(dp[index] != -1)   return dp[index];\\n\\n        // include\\n        ll pointsIn = q[index][0] + solveMemo(q, index + q[index][1] + 1, dp);\\n\\n        // exclude\\n        ll pointsEx = solveMemo(q, index + 1, dp);\\n\\n        return dp[index] = (pointsIn > pointsEx) ? pointsIn : pointsEx;\\n    }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<ll> dp(questions.size() , -1);\\n        return solveMemo(questions, 0, dp);\\n    }\\n};\\n```\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n\\n    ll solveTab(vector<vector<int>>& q)  {\\n        int n = q.size();\\n        vector<ll> dp(n+1 , 0);\\n        for(int i=n-1; i>=0; i--)    {\\n            int nextIndex= i+1+q[i][1]; \\n            long long include   = q[i][0] + ( (nextIndex<=n) ? dp[nextIndex] : 0 );\\n            long long exclude = dp[i+1];\\n            dp[i]= max(include,exclude);\\n        }\\n        return dp[0];\\n    }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        return solveTab(questions);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514612,
                "title": "java-solution-for-solving-questions-with-brainpower-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo maximize the points earned, we need to make a decision for each question whether to solve it or skip it. If we solve a question, we earn the points specified by that question but are unable to solve a certain number of subsequent questions based on the brainpower. The goal is to find the maximum points that can be earned by making optimal decisions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize an array dp of size n, where n is the number of questions.\\n2. Set dp[n - 1] to the points earned by solving the last question.\\n3. Iterate backward from n - 2 to 0:\\n- For each question at index i, calculate two options: skipping the question (dp[i + 1]) and solving the question (questions[i][0] + dp[i + questions[i][1] + 1]).\\n- Take the maximum of these two options and store it in dp[i].\\n4. Return dp[0], which represents the maximum points that can be earned by answering all the questions starting from index 0.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe solution iterates over the questions array once in the backward direction, resulting in a time complexity of O(n), where n is the number of questions.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe solution uses an additional array dp of size n to store the maximum points earned at each question index. Hence, the space complexity is O(n).\\n\\n# Code\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n    long[] dp = new long[n];\\n    dp[n - 1] = questions[n - 1][0];\\n\\n    for (int i = n - 2; i >= 0; i--) {\\n        dp[i] = Math.max(dp[i + 1], questions[i][0] + (i + questions[i][1] + 1 < n ? dp[i + questions[i][1] + 1] : 0));\\n    }\\n\\n    return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n    long[] dp = new long[n];\\n    dp[n - 1] = questions[n - 1][0];\\n\\n    for (int i = n - 2; i >= 0; i--) {\\n        dp[i] = Math.max(dp[i + 1], questions[i][0] + (i + questions[i][1] + 1 < n ? dp[i + questions[i][1] + 1] : 0));\\n    }\\n\\n    return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692935,
                "title": "java-dp-easy-solution-with-comments",
                "content": "DP from right end to left end.\\n\\n```class Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        if(n == 1) return questions[0][0];\\n        // dp[i] represents the maximum points that can be get from ith question to nth question. \\n        long[] dp = new long[n];\\n        // move from index n to index 0;\\n        dp[n-1] = questions[n-1][0];\\n        for(int i = n-2; i >= 0; i--){\\n            long rest = i + questions[i][1] + 1 < n ? dp[i + questions[i][1] + 1] : 0;\\n            dp[i] = Math.max(dp[i+1], questions[i][0] + rest);\\n        }\\n        return dp[0];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        if(n == 1) return questions[0][0];\\n        // dp[i] represents the maximum points that can be get from ith question to nth question. \\n        long[] dp = new long[n];\\n        // move from index n to index 0;\\n        dp[n-1] = questions[n-1][0];\\n        for(int i = n-2; i >= 0; i--){\\n            long rest = i + questions[i][1] + 1 < n ? dp[i + questions[i][1] + 1] : 0;\\n            dp[i] = Math.max(dp[i+1], questions[i][0] + rest);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1692922,
                "title": "simple-java-solution-bottom-up-dp",
                "content": "```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long dp[] = new long[n];\\n        for(int i=n-1;i>=0;i--){\\n            dp[i] = Math.max((i<n-1)?dp[i+1]:0,\\n                             questions[i][0]+((i+questions[i][1]+1<n)?dp[i+questions[i][1]+1]:0));\\n        }\\n        return dp[0];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long dp[] = new long[n];\\n        for(int i=n-1;i>=0;i--){\\n            dp[i] = Math.max((i<n-1)?dp[i+1]:0,\\n                             questions[i][0]+((i+questions[i][1]+1<n)?dp[i+questions[i][1]+1]:0));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1692911,
                "title": "python-simple-dp-solution-o-n-explained-beginner-friendly",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n```\\nclass Solution(object):\\n    def mostPoints(self, Q):\\n        dp = [0] * len(Q)  # dp[i] denoted the most points can be got if we started from i, so dp[0] is the final answer\\n        dp[-1] = Q[-1][0]  # obviously, if we started from the last position, we got Q[-1][0]\\n        for i in range(len(Q) - 2, -1, -1):  # traverse Q backward\\n            if i + Q[i][1] + 1 >= len(Q):  # if we choose the current points and need to freeze till end\\n                dp[i] = max(Q[i][0], dp[i + 1])\\n            else:\\n                dp[i] = max(Q[i][0] + dp[i + Q[i][1] + 1], dp[i + 1])\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def mostPoints(self, Q):\\n        dp = [0] * len(Q)  # dp[i] denoted the most points can be got if we started from i, so dp[0] is the final answer\\n        dp[-1] = Q[-1][0]  # obviously, if we started from the last position, we got Q[-1][0]\\n        for i in range(len(Q) - 2, -1, -1):  # traverse Q backward\\n            if i + Q[i][1] + 1 >= len(Q):  # if we choose the current points and need to freeze till end\\n                dp[i] = max(Q[i][0], dp[i + 1])\\n            else:\\n                dp[i] = max(Q[i][0] + dp[i + Q[i][1] + 1], dp[i + 1])\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692905,
                "title": "10-lines-c",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll max(ll a,ll b){\\n        return a>b?a:b;\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        vector<ll>dp(n+1,0);\\n        ll result=0;\\n        for(ll i=1;i<=n;++i){\\n            int length=questions[i-1][1];\\n            if(i+1<=n){\\n                dp[i+1]=max(dp[i],dp[i+1]);\\n            }\\n            if(i+length+1<=n){\\n                dp[i+length+1]=max(dp[i]+questions[i-1][0],dp[i+length+1]);\\n            }\\n            result=max(result,dp[i]+questions[i-1][0]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll max(ll a,ll b){\\n        return a>b?a:b;\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        vector<ll>dp(n+1,0);\\n        ll result=0;\\n        for(ll i=1;i<=n;++i){\\n            int length=questions[i-1][1];\\n            if(i+1<=n){\\n                dp[i+1]=max(dp[i],dp[i+1]);\\n            }\\n            if(i+length+1<=n){\\n                dp[i+length+1]=max(dp[i]+questions[i-1][0],dp[i+length+1]);\\n            }\\n            result=max(result,dp[i]+questions[i-1][0]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046471,
                "title": "solving-questions-with-brainpower-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDP\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n// Recursion with BackTracking - TLE\\n// class Solution {\\n// private:\\n//     void solve(vector<vector<int>>& questions, int &ans, int sum, int index)\\n//     {\\n//         if(index>=questions.size())\\n//         {\\n//             ans = max(ans, sum);\\n//             return;\\n//         }\\n\\n//         // include question\\n//         sum += questions[index][0];\\n//         solve(questions, ans, sum, index+questions[index][1]+1);\\n\\n//         // BackTracking\\n//         sum -= questions[index][0];\\n\\n//         // exclude question\\n//         solve(questions, ans, sum, index+1);\\n//         return; \\n//     }\\n// public:\\n//     long long mostPoints(vector<vector<int>>& questions) {\\n//         int ans = 0;\\n//         solve(questions, ans, 0, 0);\\n//         return ans;\\n//     }\\n// };\\n\\n\\n// Dynamic Programming\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long> dp(200001, 0);\\n        \\n        for(int i=questions.size()-1 ; i>=0 ; i--)\\n        {\\n            long long included = questions[i][0] + dp[questions[i][1]+i+1];\\n            long long not_included = dp[i+1];\\n\\n            dp[i] = max(included, not_included);\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/1f2fe808-8300-47d5-bf87-4e556a097de9_1694756983.281953.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Recursion with BackTracking - TLE\\n// class Solution {\\n// private:\\n//     void solve(vector<vector<int>>& questions, int &ans, int sum, int index)\\n//     {\\n//         if(index>=questions.size())\\n//         {\\n//             ans = max(ans, sum);\\n//             return;\\n//         }\\n\\n//         // include question\\n//         sum += questions[index][0];\\n//         solve(questions, ans, sum, index+questions[index][1]+1);\\n\\n//         // BackTracking\\n//         sum -= questions[index][0];\\n\\n//         // exclude question\\n//         solve(questions, ans, sum, index+1);\\n//         return; \\n//     }\\n// public:\\n//     long long mostPoints(vector<vector<int>>& questions) {\\n//         int ans = 0;\\n//         solve(questions, ans, 0, 0);\\n//         return ans;\\n//     }\\n// };\\n\\n\\n// Dynamic Programming\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long> dp(200001, 0);\\n        \\n        for(int i=questions.size()-1 ; i>=0 ; i--)\\n        {\\n            long long included = questions[i][0] + dp[questions[i][1]+i+1];\\n            long long not_included = dp[i+1];\\n\\n            dp[i] = max(included, not_included);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524786,
                "title": "2140-solving-questions-with-brainpower-c-solution",
                "content": "class Solution {\\npublic:\\n    long long c(int i,vector<vector<int>>& q,vector<long long>&dp){\\n        if(i>=q.size())return 0;\\n        long long ans=0;\\n        if(dp[i]!=-1)return dp[i];\\n        ans = max(q[i][0]+c(i+q[i][1]+1,q,dp),c(i+1,q,dp));\\n        dp[i]=ans;\\n        return ans;\\n    }\\n    long long mostPoints(vector<vector<int>>& q) {\\n        int n=q.size();\\n      vector<long long>dp(n,-1);\\n      return c(0,q,dp);  \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    long long c(int i,vector<vector<int>>& q,vector<long long>&dp){\\n        if(i>=q.size())return 0;\\n        long long ans=0;\\n        if(dp[i]!=-1)return dp[i];\\n        ans = max(q[i][0]+c(i+q[i][1]+1,q,dp),c(i+1,q,dp));\\n        dp[i]=ans;\\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3517165,
                "title": "naive-memoization-dp-tabulation-dp-approaches-in-c-easy",
                "content": "# 1. Naive Recursive approach (TLE)\\n- Time complexity: O(2^n)\\n- Space complexity: Stack Space\\n```\\nclass Solution {\\npublic:\\n    int count(vector<vector<int>>&questions, int n){\\n        if(n>=questions.size()) return 0;\\n        int res=0;\\n        int solve=questions[n][0]+count(questions, n+1+questions[n][1]);\\n        int skip=count(questions, n+1);\\n        return res=max(solve, skip);\\n    }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        return count(questions, 0);\\n    }\\n};\\n```\\n# 2. Memoization (DP)\\n- Time complexity: O(n)\\n- Space complexity: O(n)+Stack Space\\n\\n```\\nclass Solution {\\npublic:\\n    long long count(vector<vector<int>>&questions, int n, vector<long long>&dp){\\n        if(n>questions.size()) return 0;\\n        if(dp[n]!=-1) return dp[n];\\n        long long res=0;\\n        long long solve=questions[n-1][0]+count(questions, n+1+questions[n-1][1], dp);\\n        long long skip=count(questions, n+1, dp);\\n        res=max(solve, skip);\\n        return dp[n]=res;\\n    }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        vector<long long>dp(n+1, -1);\\n        count(questions, 1, dp);\\n        return dp[1];\\n    }\\n};\\n```\\n\\n# 3. Tabulation (DP-Best Approach)\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        vector<long long>dp(n+1);\\n        for(int i=n;i>=1;i--){\\n            long long solve=questions[i-1][0];\\n            if((i+1+questions[i-1][1])<dp.size()) solve+=dp[i+1+questions[i-1][1]];\\n\\n            long long skip=0;\\n            if(i+1<dp.size()) skip+=dp[i+1];\\n\\n            dp[i]=max(solve , skip);\\n        }\\n        return dp[1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count(vector<vector<int>>&questions, int n){\\n        if(n>=questions.size()) return 0;\\n        int res=0;\\n        int solve=questions[n][0]+count(questions, n+1+questions[n][1]);\\n        int skip=count(questions, n+1);\\n        return res=max(solve, skip);\\n    }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        return count(questions, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long count(vector<vector<int>>&questions, int n, vector<long long>&dp){\\n        if(n>questions.size()) return 0;\\n        if(dp[n]!=-1) return dp[n];\\n        long long res=0;\\n        long long solve=questions[n-1][0]+count(questions, n+1+questions[n-1][1], dp);\\n        long long skip=count(questions, n+1, dp);\\n        res=max(solve, skip);\\n        return dp[n]=res;\\n    }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        vector<long long>dp(n+1, -1);\\n        count(questions, 1, dp);\\n        return dp[1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        vector<long long>dp(n+1);\\n        for(int i=n;i>=1;i--){\\n            long long solve=questions[i-1][0];\\n            if((i+1+questions[i-1][1])<dp.size()) solve+=dp[i+1+questions[i-1][1]];\\n\\n            long long skip=0;\\n            if(i+1<dp.size()) skip+=dp[i+1];\\n\\n            dp[i]=max(solve , skip);\\n        }\\n        return dp[1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517119,
                "title": "python-simple-explained-dp-recursion",
                "content": "# Intuition\\nLooking at the problem this looks to be a dynamic programming...... as we are going to calculate multiple times at each question if we need to consider the question or skip to the next.... mutliple versions arise and each time it has repetitive task which can be avoided using dp\\nthe above problem also requires recursion. so we can easly we move to the next question by two steps consider or skip......\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwish trying to comeup with the solution without using dp.... only recursion\\nHere we write a recursion:\\n1.) in which we check for q(index of the question) if the q is more than lenght return 0 its the end\\n2.) \\n  i. consider the question.\\n      if we consider the quetion then we need to ignore the next   brainpower no of questions in the questions\\n      we do this simply by doing \\n      if present q is 0 and brainpower is 2... which means skipping next 2 questions by q+2+1=0+2+1=>3\\n  ii. skiping the question.\\n      if we skipped the present question we move to the next question.. that is q+1.\\n3.) doing these simply can be possible to solve but it gives a tle due to n^2 time complexity so..... we use dp... and store the maximum result in each question.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        dp={}\\n        #gave this functino a dfs name but we are not doing any dfs... just naming habit!!\\n        def dfs(q):\\n            if(q>len(questions)-1):return 0\\n            if(q in dp):return dp[q]\\n            res=max(questions[q][0]+dfs(q+questions[q][1]+1),dfs(q+1))\\n            dp[q]=res #storing every maximum possible value in the dp\\n            return res\\n        return dfs(0)\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        dp={}\\n        #gave this functino a dfs name but we are not doing any dfs... just naming habit!!\\n        def dfs(q):\\n            if(q>len(questions)-1):return 0\\n            if(q in dp):return dp[q]\\n            res=max(questions[q][0]+dfs(q+questions[q][1]+1),dfs(q+1))\\n            dp[q]=res #storing every maximum possible value in the dp\\n            return res\\n        return dfs(0)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516809,
                "title": "concise-memoized-solution-dp-c",
                "content": "```\\nclass Solution {\\n    long long dfs(int i, int n, vector<vector<int>> &ques, vector<long long> &dp) {\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        long long notpick = dfs(i + 1, n, ques, dp);\\n        long long pick = ques[i][0] + dfs(i + ques[i][1] + 1, n, ques, dp);\\n\\n        return dp[i] = max(pick, notpick);\\n    }\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long> dp(n, -1);\\n        return dfs(0, n, questions, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    long long dfs(int i, int n, vector<vector<int>> &ques, vector<long long> &dp) {\\n        if(i >= n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        long long notpick = dfs(i + 1, n, ques, dp);\\n        long long pick = ques[i][0] + dfs(i + ques[i][1] + 1, n, ques, dp);\\n\\n        return dp[i] = max(pick, notpick);\\n    }\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long> dp(n, -1);\\n        return dfs(0, n, questions, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516380,
                "title": "basic-pick-or-notpick",
                "content": "# Intuition\\nBasic pick/not pick problem. \\n\\n# Approach\\nAt every index we have two options either to solve(pick) or not solve (not pick)a problem.\\nSolving a problems as two comsequeces:\\n\\n1. You get some amount of brain power i.e `(ques[i][0])` hence your current score increases by `(ques[i][0])`.\\n2. And you can\\'t solve next few problems i.e.`(ques[i][1])` thus your pointer increments by `(ques[i][1])`.\\n\\nIf you decide not to solve the current problem u can simply skip to the next one and hence your pointer increments by 1 without your affecting your current score. \\n\\nAt the end we return maximum of both cases. \\n\\nAs this problem has a lot of repeating subproblems we can memoize the output for those subproblems and simply return the output if it is already computed. \\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code(Recursive Approach)\\n```\\nclass Solution \\n{\\npublic:\\n    using lli = long long int;\\n    vector<lli>dp;\\n    lli  solve(vector<vector<int>>& ques,int i )\\n    {\\n        if(i>ques.size()-1) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        return dp[i] = max(solve(ques,i+1), ques[i][0] + solve(ques,i+ques[i][1]+1));\\n    //max(pick,notPick)\\n    }\\n    long long mostPoints(vector<vector<int>>& ques) \\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        \\n        dp.resize(ques.size()+1,-1);\\n        return solve(ques,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    using lli = long long int;\\n    vector<lli>dp;\\n    lli  solve(vector<vector<int>>& ques,int i )\\n    {\\n        if(i>ques.size()-1) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        return dp[i] = max(solve(ques,i+1), ques[i][0] + solve(ques,i+ques[i][1]+1));\\n    //max(pick,notPick)\\n    }\\n    long long mostPoints(vector<vector<int>>& ques) \\n    {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        \\n        dp.resize(ques.size()+1,-1);\\n        return solve(ques,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516203,
                "title": "c-dp-tabulation",
                "content": "\\n# DP Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(vector<vector<int>>& que,int i,vector<long long> &dp){\\n        if(i>=que.size()) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n\\n        return dp[i]= max(que[i][0]+solve(que,i+1+que[i][1],dp),solve(que,i+1,dp));\\n    }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long> dp(questions.size(),-1);\\n        return solve(questions,0,dp);\\n    }\\n};\\n```\\n# Tabulation Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(vector<vector<int>>& que){\\n        vector<long long> tab(que.size()+1,0);\\n        for(long long i=que.size()-1;i>=0;--i){\\n            long long x = 0;\\n            if((i+1+que[i][1])<=que.size()) x = tab[i+1+que[i][1]];\\n\\n            tab[i]= max(que[i][0]+x,tab[i+1]);\\n        }\\n        return tab[0];\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        return solve(questions);\\n    }\\n};\\n```\\n# **UPVOTE IF IT HELPS !!**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(vector<vector<int>>& que,int i,vector<long long> &dp){\\n        if(i>=que.size()) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n\\n        return dp[i]= max(que[i][0]+solve(que,i+1+que[i][1],dp),solve(que,i+1,dp));\\n    }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long> dp(questions.size(),-1);\\n        return solve(questions,0,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long solve(vector<vector<int>>& que){\\n        vector<long long> tab(que.size()+1,0);\\n        for(long long i=que.size()-1;i>=0;--i){\\n            long long x = 0;\\n            if((i+1+que[i][1])<=que.size()) x = tab[i+1+que[i][1]];\\n\\n            tab[i]= max(que[i][0]+x,tab[i+1]);\\n        }\\n        return tab[0];\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        return solve(questions);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516022,
                "title": "easy-solution-using-memoization-c-simply-take-or-no-take",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long func(vector<vector<int>>&questions,int n,int ind, vector<long long>&dp){\\n        if(ind>=n)return 0;\\n        if(dp[ind]!=-1)return dp[ind];\\n        long long take=0;\\n        take = max(questions[ind][0]+func(questions,n,ind+questions[ind][1]+1,dp),func(questions,n,ind+1,dp));\\n        return dp[ind]=take;\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        vector<long long>dp(n,-1);\\n        return func(questions,n,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long func(vector<vector<int>>&questions,int n,int ind, vector<long long>&dp){\\n        if(ind>=n)return 0;\\n        if(dp[ind]!=-1)return dp[ind];\\n        long long take=0;\\n        take = max(questions[ind][0]+func(questions,n,ind+questions[ind][1]+1,dp),func(questions,n,ind+1,dp));\\n        return dp[ind]=take;\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        vector<long long>dp(n,-1);\\n        return func(questions,n,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515823,
                "title": "fastest-solutions-c-dp-easy-to-understandd",
                "content": "# Complexity\\n- Time complexity:\\n  $$O(n)$$\\n\\n- Space complexity:\\n  $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dp[100001]={0};\\n    int n ;\\n    long long rec(vector<vector<int>>& questions, int i){\\n        if(i>=questions.size()){\\n            return 0;\\n        }\\n        else if(dp[i]!=0){\\n            return dp[i];\\n        }\\n        long long temp1 = questions[i][0] + rec(questions,i+1+questions[i][1]);\\n        long long temp2 = rec(questions,i+1);\\n        dp[i] = max(temp1,temp2);\\n        return dp[i];\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        // n = questions.size();\\n        return rec(questions,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100001]={0};\\n    int n ;\\n    long long rec(vector<vector<int>>& questions, int i){\\n        if(i>=questions.size()){\\n            return 0;\\n        }\\n        else if(dp[i]!=0){\\n            return dp[i];\\n        }\\n        long long temp1 = questions[i][0] + rec(questions,i+1+questions[i][1]);\\n        long long temp2 = rec(questions,i+1);\\n        dp[i] = max(temp1,temp2);\\n        return dp[i];\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        // n = questions.size();\\n        return rec(questions,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515104,
                "title": "easy-o-n-solution-explanation-dp-2-approaches",
                "content": "# Intuition\\n```\\nStandard Pick and NotPick DP pattern \\uD83D\\uDE0C\\uD83D\\uDE0C\\n```\\n\\n# Approach\\n```\\nAt every index try to pick and make a jump till next Brainpower questions.\\n\\nExplore all possible ways and find out the maximum among them .\\n```\\n\\n# Complexity\\n- Time complexity:\\n``` O(2^n) \\uD83E\\uDEE3\\uD83E\\uDEE3 in the worst case we can have 0 jump with two options pick and notPick ```\\n``` After using the dp table it boils down to O(n) \\uD83D\\uDE00\\uD83D\\uDE00```\\n\\n- Space complexity:\\n``` O(N) for DP table ```\\n\\n# Memoization Code (Recursive Code)\\n```\\nclass Solution {\\npublic:\\n    long long func(int idx, vector<vector<int>>& questions, vector<long long>& dp)\\n    {\\n        if (idx >= questions.size())\\n            return 0;\\n        if (dp[idx] != -1)\\n            return dp[idx];\\n        long long Pick = questions[idx][0] + func(idx + 1 + questions[idx][1], questions, dp);\\n        long long notPick = 0 + func(idx + 1, questions, dp);\\n        return dp[idx] = max(Pick, notPick);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long> dp(questions.size() + 1, -1);\\n        return func(0, questions, dp);\\n    }\\n};\\n```\\n# Tabulation Code (Iterative Code)\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long> dp(n + 1, 0);\\n        for (int idx = n - 1; idx >= 0; idx--)\\n        {\\n            long long Pick = questions[idx][0] + dp[min(idx + 1 + questions[idx][1], n)];\\n            long long notPick = dp[idx + 1];\\n            dp[idx] = max(Pick, notPick);\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n\\n\\n```\\nPlease Upvote if You found this Answer Helpful \\uD83D\\uDE43\\uD83D\\uDE43. \\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nStandard Pick and NotPick DP pattern \\uD83D\\uDE0C\\uD83D\\uDE0C\\n```\n```\\nAt every index try to pick and make a jump till next Brainpower questions.\\n\\nExplore all possible ways and find out the maximum among them .\\n```\n``` O(2^n) \\uD83E\\uDEE3\\uD83E\\uDEE3 in the worst case we can have 0 jump with two options pick and notPick ```\n``` After using the dp table it boils down to O(n) \\uD83D\\uDE00\\uD83D\\uDE00```\n``` O(N) for DP table ```\n```\\nclass Solution {\\npublic:\\n    long long func(int idx, vector<vector<int>>& questions, vector<long long>& dp)\\n    {\\n        if (idx >= questions.size())\\n            return 0;\\n        if (dp[idx] != -1)\\n            return dp[idx];\\n        long long Pick = questions[idx][0] + func(idx + 1 + questions[idx][1], questions, dp);\\n        long long notPick = 0 + func(idx + 1, questions, dp);\\n        return dp[idx] = max(Pick, notPick);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long> dp(questions.size() + 1, -1);\\n        return func(0, questions, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long> dp(n + 1, 0);\\n        for (int idx = n - 1; idx >= 0; idx--)\\n        {\\n            long long Pick = questions[idx][0] + dp[min(idx + 1 + questions[idx][1], n)];\\n            long long notPick = dp[idx + 1];\\n            dp[idx] = max(Pick, notPick);\\n        }\\n        return dp[0];\\n    }\\n};\\n```\n```\\nPlease Upvote if You found this Answer Helpful \\uD83D\\uDE43\\uD83D\\uDE43. \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515039,
                "title": "python-short-and-clean-recursive-dp",
                "content": "# Approach\\nTL;DR, Same as the [Editorial solution](https://leetcode.com/problems/solving-questions-with-brainpower/editorial/) but short and functional.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is the number of questions.`\\n\\n# Code\\n```python\\nclass Solution:\\n    def mostPoints(self, qns: list[list[int]]) -> int:\\n        @cache\\n        def max_score(i: int) -> int:\\n            return i < len(qns) and max(qns[i][0] + max_score(i + 1 + qns[i][1]), max_score(i + 1))\\n        \\n        return max_score(0)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def mostPoints(self, qns: list[list[int]]) -> int:\\n        @cache\\n        def max_score(i: int) -> int:\\n            return i < len(qns) and max(qns[i][0] + max_score(i + 1 + qns[i][1]), max_score(i + 1))\\n        \\n        return max_score(0)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514991,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Recursive DP\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long n, dp[100005];\\n    vector<vector<int>> question;\\n    long long solve(long long id) {\\n        if(id >= n) return 0;\\n        if(dp[id] != -1) return dp[id];\\n        long long ans = question[id][0];\\n        ans = max(ans, question[id][0] + solve(id + 1 + question[id][1]));\\n        ans = max(ans, solve(id + 1));\\n        return dp[id] = ans;\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        memset(dp, -1, sizeof(dp));\\n        n = questions.size();\\n        question = questions;\\n        long long ans = solve(0);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long n, dp[100005];\\n    vector<vector<int>> question;\\n    long long solve(long long id) {\\n        if(id >= n) return 0;\\n        if(dp[id] != -1) return dp[id];\\n        long long ans = question[id][0];\\n        ans = max(ans, question[id][0] + solve(id + 1 + question[id][1]));\\n        ans = max(ans, solve(id + 1));\\n        return dp[id] = ans;\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        memset(dp, -1, sizeof(dp));\\n        n = questions.size();\\n        question = questions;\\n        long long ans = solve(0);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514438,
                "title": "c-python-dynamic-programming",
                "content": "# Code [ C++ ]\\n```\\nclass Solution {\\npublic:\\n    long long dp[100002];\\n    long long solve(vector<vector<int>>& q,int i){\\n        if(i>=q.size())return 0;\\n        if(dp[i]!=-1)return dp[i];\\n        long long skip=solve(q,i+1);\\n        long long take=q[i][0]+solve(q,i+q[i][1]+1);\\n        return dp[i]=max(skip,take);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(questions,0);\\n    }\\n};  \\n```\\n\\n# Code [ Python ]\\n```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        def dp(i):\\n            if i >= n:\\n                return 0\\n            if memo[i] != -1:\\n                return memo[i]\\n\\n            memo[i] = max(dp(i + 1), dp(i + questions[i][1] + 1) + questions[i][0])\\n            return memo[i]\\n\\n        n = len(questions)\\n        memo = [-1] * n\\n        return dp(0)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100002];\\n    long long solve(vector<vector<int>>& q,int i){\\n        if(i>=q.size())return 0;\\n        if(dp[i]!=-1)return dp[i];\\n        long long skip=solve(q,i+1);\\n        long long take=q[i][0]+solve(q,i+q[i][1]+1);\\n        return dp[i]=max(skip,take);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(questions,0);\\n    }\\n};  \\n```\n```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        def dp(i):\\n            if i >= n:\\n                return 0\\n            if memo[i] != -1:\\n                return memo[i]\\n\\n            memo[i] = max(dp(i + 1), dp(i + questions[i][1] + 1) + questions[i][0])\\n            return memo[i]\\n\\n        n = len(questions)\\n        memo = [-1] * n\\n        return dp(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514420,
                "title": "recursion-dp-fully-explained-c",
                "content": "# Explaination\\n<!-- Describe your approach to solving the problem. -->\\nThe rec method is a recursive function that takes three parameters: an integer i, a 2D vector q and a 1D vector dp. The function checks if the value of i is greater than or equal to the size of q, if so it returns 0. Otherwise, it checks if the value of dp[i] is not equal to -1, if so it returns the value of dp[i].\\n\\nThen, it initializes two variables point and jump with the values of the first and second element of the ith element of q, respectively. Finally, it returns the maximum value between the sum of point and the result of calling rec recursively with parameters jump+i+1, q, and dp, and the result of calling rec recursively with parameters i+1, q, and dp. The result of this maximum value is assigned to dp[i] before returning it.\\n\\nThe mostPoints method takes a 2D vector q as input and creates a 1D vector called dp with -1 values of size q.size()+1. It then calls the recursive function rec with parameters 0, q, and dp, and returns its result.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long rec(int i,vector<vector<int>>& q,vector<long long>& dp) {\\n        if(i>=q.size()) {\\n            return 0;\\n        }\\n        if(dp[i] != -1) {\\n            return dp[i];\\n        }\\n        int point = q[i][0] , jump = q[i][1];\\n        return dp[i]=max( point+rec(jump+i+1,q,dp) , rec(i+1,q,dp) );\\n    }\\n    long long mostPoints(vector<vector<int>>& q) {\\n        vector<long long> dp(q.size()+1,-1);\\n        return rec(0,q,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long rec(int i,vector<vector<int>>& q,vector<long long>& dp) {\\n        if(i>=q.size()) {\\n            return 0;\\n        }\\n        if(dp[i] != -1) {\\n            return dp[i];\\n        }\\n        int point = q[i][0] , jump = q[i][1];\\n        return dp[i]=max( point+rec(jump+i+1,q,dp) , rec(i+1,q,dp) );\\n    }\\n    long long mostPoints(vector<vector<int>>& q) {\\n        vector<long long> dp(q.size()+1,-1);\\n        return rec(0,q,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327455,
                "title": "easy-6-line-c-code-dp-recursion-memoization-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[100002];\\n    long long f(vector<vector<int>>& nums , int i)\\n    {\\n        if(i>=nums.size())return 0;\\n        if(dp[i]!=-1)return dp[i];\\n        return dp[i] =  max(nums[i][0]+f(nums,i+1+nums[i][1]),f(nums,i+1));\\n    }\\n    long long mostPoints(vector<vector<int>>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n      return f(nums,0);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100002];\\n    long long f(vector<vector<int>>& nums , int i)\\n    {\\n        if(i>=nums.size())return 0;\\n        if(dp[i]!=-1)return dp[i];\\n        return dp[i] =  max(nums[i][0]+f(nums,i+1+nums[i][1]),f(nums,i+1));\\n    }\\n    long long mostPoints(vector<vector<int>>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n      return f(nums,0);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741475,
                "title": "new-solution-cpp-with-dp-approach",
                "content": "class Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& q) {\\n        vector<long long int>v(q.size()+1,0);\\n        reverse(q.begin(), q.end());\\n        for(int i=0;i<q.size();i++){\\n            if(i- q[i][1]>0){\\n                int x=i-q[i][1]-1;\\n              //  v[i]= v[x]+ q[i][0];\\n                v[i] =max(v[i-1],v[x]+ q[i][0] );\\n            }\\n            else{\\n                if(i==0)\\n                v[i]= q[i][0];\\n                else{\\n                    if(v[i-1]>q[i][0]){\\n                        v[i]= v[i-1];\\n                    }\\n                    else{\\n                        v[i]= q[i][0];\\n                    }\\n                    \\n}\\n                    // v[i]= max(v[i-1],q[i][0]);\\n            }\\n        }\\n          for(int i=0;i<v.size();i++){\\n              cout<<v[i]<<\" \";\\n          }\\n        long long int ans=0;\\n        // for(int i=0;i<v.size();i++){\\n        //     ans= max(ans,v[i]);\\n        // }\\n        return v[q.size()-1];\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& q) {\\n        vector<long long int>v(q.size()+1,0);\\n        reverse(q.begin(), q.end());\\n        for(int i=0;i<q.size();i++){\\n            if(i- q[i][1]>0){\\n                int x=i-q[i][1]-1;\\n              //  v[i]= v[x]+ q[i][0];\\n                v[i] =max(v[i-1],v[x]+ q[i][0] );\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1726519,
                "title": "c-memoization-knapsack",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[100007];\\n    long long solve(vector<vector<int>>& questions , int idx){\\n        //base cases\\n        \\n        if(idx >= questions.size()) return 0;\\n        if(dp[idx] != -1) return dp[idx];\\n        long long op1 = INT_MIN, op2 = INT_MIN;\\n        \\n        op1 = (long long)questions[idx][0] + solve(questions, idx + questions[idx][1] + 1 );\\n        op2 = (long long)solve(questions, idx + 1);\\n        return dp[idx] = max(op1,op2);\\n    }\\n    \\n    long long mostPoints(vector<vector<int>>& questions) {\\n           memset(dp, -1, sizeof(dp));\\n           return solve(questions, 0);\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    long long dp[100007];\\n    long long solve(vector<vector<int>>& questions , int idx){\\n        //base cases\\n        \\n        if(idx >= questions.size()) return 0;\\n        if(dp[idx] != -1) return dp[idx];\\n        long long op1 = INT_MIN, op2 = INT_MIN;\\n        \\n        op1 = (long long)questions[idx][0] + solve(questions, idx + questions[idx][1] + 1 );\\n        op2 = (long long)solve(questions, idx + 1);\\n        return dp[idx] = max(op1,op2);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1694979,
                "title": "python3-heap-a-different-heap-solution-iterate-from-left-to-right",
                "content": "We iterate from left to right, at every step, we want to know previous **max points** we can get, **it\\'s naturally a heap structure**. \\n\\n**However, the issue is that if you access some previous questions, the current question may be unabled to be accessed.**\\n\\nSo, we use a ***candidates*** heap too, to store all points, but with **the bound index as the key** for the heap, which means every time we use *heappop()*, we can get the smallest bound index, if this index is smaller than the current index, which mean if we access this previous question, the the current question can be be accessed, we add it into heap. \\n\\n\\n```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n = len(questions)\\n        \\n        h = []    # (point, idx)\\n        candi = []  # (idx, point)\\n\\n        \\n        for i in range(n):\\n            while candi: # we have candidates\\n                if candi[0][0] < i:  # this means the current i bigger than the right bound of the candidate which has the smallest bound\\n                    idx, point = heappop(candi)\\n                    heappush(h, (point, idx))\\n                else: \\n                    break\\n                    \\n            if h:\\n                point, idx = h[0]  # h[0] is the highest points we can get from prevous questions, and we can access\\n                heappush(candi, (i + questions[i][1], point - questions[i][0]))\\n            else:\\n                heappush(candi, (i + questions[i][1], -questions[i][0]))\\n\\n\\n        r1 = -h[0][0] if h else 0\\n        r2 = max([-v[1] for v in candi]) if candi else 0\\n        \\n        return max(r1, r2)\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n = len(questions)\\n        \\n        h = []    # (point, idx)\\n        candi = []  # (idx, point)\\n\\n        \\n        for i in range(n):\\n            while candi: # we have candidates\\n                if candi[0][0] < i:  # this means the current i bigger than the right bound of the candidate which has the smallest bound\\n                    idx, point = heappop(candi)\\n                    heappush(h, (point, idx))\\n                else: \\n                    break\\n                    \\n            if h:\\n                point, idx = h[0]  # h[0] is the highest points we can get from prevous questions, and we can access\\n                heappush(candi, (i + questions[i][1], point - questions[i][0]))\\n            else:\\n                heappush(candi, (i + questions[i][1], -questions[i][0]))\\n\\n\\n        r1 = -h[0][0] if h else 0\\n        r2 = max([-v[1] for v in candi]) if candi else 0\\n        \\n        return max(r1, r2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694299,
                "title": "java-dp",
                "content": "**Approach:**\\n1. The idea is very simple. As explained in problem if I choose a `question[i]` then I can\\'t choose next `question[i][1]` questions.\\n2. The max points say `maxPoints[i]` that can be attained for index `i` will be points of i-th question and max points that can be attained from `questions[i+1]`\\n3. We can define it in in mathematical terms like\\n\\t`maxPoints[i] = maxPoints[i + questions[i][1] + 1] + questions[i][0]`\\n4. Now, above can be solved from recursion but there will be many overlapping sub problems. A clear sign of Dynamic programming\\n5. Hence, we can create a memo table. If we use iteration, then computing maxPoints[i] from left to right (`i = 0 to i = n - 1`) will be difficult because `maxPoints[i]` depends on `maxPoints[i + questions[i][1]]`\\n6. So let\\'s start from end and compute from end.\\n```\\nmaxPoints[i] = Math.max(\\n\\t\\t\\t\\t\\tmaxPoints[i + questions[i][1] + 1] + questions[i][0], \\n\\t\\t\\t\\t\\tmaxPoints[i + 1]) // if choosing current question doesn\\'t lead to optimal solution\\n```\\n7. Return `maxPoints[0]`\\n\\n**Code**\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long[] memo = new long[n];\\n        for(int i = n - 1; i >= 0; i--) {\\n            long onSkippingThisQuestion = 0;\\n            long choosingThisQuestion = 0;\\n            if (i + 1 < n) {\\n                onSkippingThisQuestion = memo[i + 1];\\n            }\\n            if (i + questions[i][1] + 1 < n) {\\n                choosingThisQuestion = memo[i + questions[i][1] + 1];\\n            }\\n            memo[i] = Math.max(questions[i][0] + choosingThisQuestion, onSkippingThisQuestion);\\n        }\\n        return memo[0];\\n    }\\n}\\n```\\n\\n**Complexity Analysis**\\n**Time:** O(n) : Iterating over array once\\n**Space:** O(n): Extra array for memoization.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nmaxPoints[i] = Math.max(\\n\\t\\t\\t\\t\\tmaxPoints[i + questions[i][1] + 1] + questions[i][0], \\n\\t\\t\\t\\t\\tmaxPoints[i + 1]) // if choosing current question doesn\\'t lead to optimal solution\\n```\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long[] memo = new long[n];\\n        for(int i = n - 1; i >= 0; i--) {\\n            long onSkippingThisQuestion = 0;\\n            long choosingThisQuestion = 0;\\n            if (i + 1 < n) {\\n                onSkippingThisQuestion = memo[i + 1];\\n            }\\n            if (i + questions[i][1] + 1 < n) {\\n                choosingThisQuestion = memo[i + questions[i][1] + 1];\\n            }\\n            memo[i] = Math.max(questions[i][0] + choosingThisQuestion, onSkippingThisQuestion);\\n        }\\n        return memo[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694167,
                "title": "c-dynamic-programming-solution-o-n-time-with-diagram",
                "content": "This was a good problem based on Knapsack DP.\\nFor each question we have 2 choices either to take it or not take it. The constraint is we can\\'t take next **poweri** questions if we take the ith question. \\nOn simple way is to run loop from last question to the 0th question and maintain the best profit in each step. We create a 2D dp array : dp[n][2]; \\ndp[i][0] : profit if we solve question number i (calculated i to n-1)\\ndp[i][1] : profit if we don\\'t solve question number i (calculated i to n-1)\\nIf we solve an ith question i then we can\\'t solve next **poweri** questions -> so check max profit at *dp[i+poweri+1].* and add **profit** to it.\\nTo skip a question i there is no constraint on us so check max profit at *dp[i+1]*\\nWe will ignore any index that is out of bounds(does not exists in questions array)\\nIn this manner The dp array will store better result at every decreasing index. Best result will be given by dp[0].\\nLet us take Sample Test Case 2:\\n[[1,1],[2,2],[3,3],[4,4],[5,5]]\\nWe iterate from n-1=4 to 0\\n**Note : Abbreveation DNE means Does not exists**\\n**For i=4** : dp[4][0] = 5  (Solve it -> check dp[4+5+1]=dp[10] = DNE)\\n\\t\\t\\t\\t\\t  dp[4][1] = 0  (Skip it ->check dp[5] = DNE)\\n**For i=3** : dp[3][0] = 4  (Solve it -> check dp[3+4+1]=dp[8] = DNE)\\n\\t\\t\\t\\t\\t  dp[3][1] = 5  (Skip it ->  check max profit at dp[4])\\n**For i=2** : dp[2][0] = 3  (Solve it -> check dp[2+3+1]=dp[6] = DNE)\\n\\t\\t\\t\\t\\t  dp[2][1] = 5  (Skip it ->  check max profit at dp[3])\\n**For i=1** : dp[1][0] = 7  (Solve it -> check dp[1+2+1]=dp[4] = 5)\\n\\t\\t\\t\\t\\t  dp[1][1] = 5  (Skip it ->  check max profit at dp[2])\\n**For i=0** : dp[0][0] = 6  (Solve it -> check dp[0+1+1]=dp[2] = 5)\\n\\t\\t\\t\\t\\t  dp[0][1] = 7  (Skip it ->  check max profit at dp[1])\\n![image](https://assets.leetcode.com/users/images/4eb1dc31-a39d-4780-8c1f-8d835e5ce951_1642326465.5755954.png)\\n\\nSolution :\\n**TC : O(n)**\\n**SC : O(n)**\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        ll n=questions.size();\\n        if(n==1)\\n            return questions[0][0];\\n        ll dp[n][2];dp[0][0]=dp[0][1]=0;//dp[i][0]->solve it ; dp[i][1]->don\\'t solve it\\n        for(ll i=n-1;i>=0;i--){\\n            ll points=questions[i][0],power=questions[i][1];\\n            //todo : Attempt this question\\n            if(power+i >= n-1)\\n                dp[i][0]=points;\\n            else\\n                dp[i][0]=points+max(dp[i+power+1][0],dp[i+power+1][1]);\\n            //todo : Don\\'t attempt this question -->Just check profit from its just right\\n            if(i==(n-1))//there is nobody on right\\n                dp[i][1]=0;\\n            else\\n                dp[i][1]=max(dp[i+1][0],dp[i+1][1]);\\n        }\\n        return max(dp[0][0],dp[0][1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        ll n=questions.size();\\n        if(n==1)\\n            return questions[0][0];\\n        ll dp[n][2];dp[0][0]=dp[0][1]=0;//dp[i][0]->solve it ; dp[i][1]->don\\'t solve it\\n        for(ll i=n-1;i>=0;i--){\\n            ll points=questions[i][0],power=questions[i][1];\\n            //todo : Attempt this question\\n            if(power+i >= n-1)\\n                dp[i][0]=points;\\n            else\\n                dp[i][0]=points+max(dp[i+power+1][0],dp[i+power+1][1]);\\n            //todo : Don\\'t attempt this question -->Just check profit from its just right\\n            if(i==(n-1))//there is nobody on right\\n                dp[i][1]=0;\\n            else\\n                dp[i][1]=max(dp[i+1][0],dp[i+1][1]);\\n        }\\n        return max(dp[0][0],dp[0][1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693977,
                "title": "python3-top-down-dp",
                "content": "Find maximum points by comparing:\\n1. don\\'t choose current question: `dfs(i+1)`\\n2. choose current question and go to next available question : `dfs(i+A[i][1]+1)`\\n```\\nclass Solution:\\n    def mostPoints(self, A: List[List[int]]) -> int:\\n        @cache\\n        def dfs(i):\\n            if i>=len(A): return 0\\n            return max(dfs(i+1), A[i][0]+dfs(i+A[i][1]+1))\\n        \\n        return dfs(0)\\n```\\n\\nKnapsack problem list: 322, 416, 474, 494, 518, 805, 879, 956, 1049, 1255, 1402, 1449, 1981.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def mostPoints(self, A: List[List[int]]) -> int:\\n        @cache\\n        def dfs(i):\\n            if i>=len(A): return 0\\n            return max(dfs(i+1), A[i][0]+dfs(i+A[i][1]+1))\\n        \\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693776,
                "title": "classic-dp-in-python",
                "content": "\"\"\"\\nclass Solution:\\n    \\n\\tdef mostPoints(self, que: List[List[int]]) -> int:\\n        len_q = len(que)\\n        dp = [0]*(len_q+1)\\n        \\n        for i in range(len_q-1, -1, -1):\\n            point, back = que[i]\\n            dp[i] = max(dp[i+1], point+dp[min(len_q, i+back+1)])\\n            \\n        return dp[0]\\n\"\"\" \\nfilling dp from back of the given input\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "\"\"\"\\nclass Solution:\\n    \\n\\tdef mostPoints(self, que: List[List[int]]) -> int:\\n        len_q = len(que)\\n        dp = [0]*(len_q+1)\\n        \\n        for i in range(len_q-1, -1, -1):\\n            point, back = que[i]\\n            dp[i] = max(dp[i+1], point+dp[min(len_q, i+back+1)])\\n            \\n        return dp[0]\\n\"\"\" \\nfilling dp from back of the given input\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1693154,
                "title": "c-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll dp[100001];\\n    ll fun(ll i, vector<vector<int>> &q){\\n        if(i>=q.size()){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        ll ans = fun(i+q[i][1]+1, q) + q[i][0];\\n        ans = max(ans, fun(i+1, q));\\n        return dp[i] = ans;\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        memset(dp, -1, sizeof(dp));\\n        return fun(0, questions);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    ll dp[100001];\\n    ll fun(ll i, vector<vector<int>> &q){\\n        if(i>=q.size()){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        ll ans = fun(i+q[i][1]+1, q) + q[i][0];\\n        ans = max(ans, fun(i+1, q));\\n        return dp[i] = ans;\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        memset(dp, -1, sizeof(dp));\\n        return fun(0, questions);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693060,
                "title": "include-exclude-method-c-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    // int count=0;\\n    long long dp[100001];\\n    long long getans(vector<vector<int>>&questions,int index, int n)\\n    {\\n        if(index>=n)\\n        {\\n            return 0;\\n        }\\n        if(dp[index]!=-1)\\n        {\\n            return dp[index];\\n        }\\n        long long exclude=0;\\n        long long include=0;\\n        include=getans(questions,index+questions[index][1]+1,n)+questions[index][0];\\n        exclude=getans(questions,index+1,n);\\n        \\n        return dp[index]=max(exclude ,include);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int index=0;\\n        int n= questions.size();\\n        memset(dp,-1,sizeof(dp));\\n        long long ans= getans(questions,index,n);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // int count=0;\\n    long long dp[100001];\\n    long long getans(vector<vector<int>>&questions,int index, int n)\\n    {\\n        if(index>=n)\\n        {\\n            return 0;\\n        }\\n        if(dp[index]!=-1)\\n        {\\n            return dp[index];\\n        }\\n        long long exclude=0;\\n        long long include=0;\\n        include=getans(questions,index+questions[index][1]+1,n)+questions[index][0];\\n        exclude=getans(questions,index+1,n);\\n        \\n        return dp[index]=max(exclude ,include);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int index=0;\\n        int n= questions.size();\\n        memset(dp,-1,sizeof(dp));\\n        long long ans= getans(questions,index,n);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1693040,
                "title": "python-dp-solution-with-detailed-explanation",
                "content": "dp[i:] = the maximum points you can earn for the exam questions[i:]\\n```\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n = len(questions)\\n        dp = [0] * n\\n        # base case\\n        dp[n-1] = questions[n-1][0]\\n        # recurrence\\n        for i in range(n - 2, -1, -1):\\n            exclude = dp[i+1] # skip the i-th questions\\n            include = questions[i][0] # solve the i-th questions\\n            j = i + questions[i][1] + 1\\n            if j < n:\\n                include += dp[j]\\n            dp[i] = max(exclude, include)\\n        return dp[0]\\n```",
                "solutionTags": [],
                "code": "```\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n = len(questions)\\n        dp = [0] * n\\n        # base case\\n        dp[n-1] = questions[n-1][0]\\n        # recurrence\\n        for i in range(n - 2, -1, -1):\\n            exclude = dp[i+1] # skip the i-th questions\\n            include = questions[i][0] # solve the i-th questions\\n            j = i + questions[i][1] + 1\\n            if j < n:\\n                include += dp[j]\\n            dp[i] = max(exclude, include)\\n        return dp[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1692915,
                "title": "c-o-n-dp",
                "content": "```\\npublic class Solution {\\n    public long MostPoints(int[][] questions) {\\n        long[][] dp = new long[questions.Length][];\\n        long res = 0;\\n        for(int i = 0; i <questions.Length; i++)\\n        {\\n            dp[i] = new long[2];\\n            dp[i][0] = questions[i][0];\\n            dp[i][1] = 0;\\n        }\\n        long curAdd = 0;\\n        for(int i = 0; i <questions.Length; i++)\\n        {\\n            curAdd = Math.Max(curAdd, dp[i][1]);\\n            dp[i][0]= questions[i][0] + curAdd;\\n            if(i+1+questions[i][1]<questions.Length)\\n            {\\n                int j = i+1+questions[i][1];\\n                dp[j][1] = Math.Max(dp[j][1], dp[i][0]);\\n            }\\n            res = Math.Max(res, dp[i][0]);\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public long MostPoints(int[][] questions) {\\n        long[][] dp = new long[questions.Length][];\\n        long res = 0;\\n        for(int i = 0; i <questions.Length; i++)\\n        {\\n            dp[i] = new long[2];\\n            dp[i][0] = questions[i][0];\\n            dp[i][1] = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1692910,
                "title": "python3-house-robber-variation-dp-bottom-up",
                "content": "Similarily to https://leetcode.com/problems/house-robber, we keep track of (Use, Skip) for every index of DP.\\n```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        dp = [(0, 0)] * (len(questions) + 1)\\n        for i in range(len(questions) - 1, -1, -1):\\n            score, delay = questions[i]\\n            dp[i] = score + (max(dp[i + delay + 1]) if i + delay + 1 < len(questions) else 0), max(dp[i + 1])\\n        return max(dp[0])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        dp = [(0, 0)] * (len(questions) + 1)\\n        for i in range(len(questions) - 1, -1, -1):\\n            score, delay = questions[i]\\n            dp[i] = score + (max(dp[i + delay + 1]) if i + delay + 1 < len(questions) else 0), max(dp[i + 1])\\n        return max(dp[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968286,
                "title": "beginners-solution-knapsack-dp-take-not-take",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long dp[100001];\\nlong long solve(int i, vector<vector<int>>& ques, int n){\\n    if(i>=ques.size()) return 0;\\n    if(dp[i]!=-1) return dp[i];\\n    long long take=ques[i][0]+solve(i+1+ques[i][1],ques, n); //just take that index ans its value\\n    long long nottake=solve(i+1,ques,n); //do not take it move forward\\n    return dp[i]=max(take,nottake); //just find the maxi of the above steps.\\n\\n}\\n    long long mostPoints(vector<vector<int>>& ques) {\\n        int n=ques.size();\\n        memset(dp,-1,sizeof(dp)); //dp initialisizing\\n        return solve(0,ques,n); //call the function\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long dp[100001];\\nlong long solve(int i, vector<vector<int>>& ques, int n){\\n    if(i>=ques.size()) return 0;\\n    if(dp[i]!=-1) return dp[i];\\n    long long take=ques[i][0]+solve(i+1+ques[i][1],ques, n); //just take that index ans its value\\n    long long nottake=solve(i+1,ques,n); //do not take it move forward\\n    return dp[i]=max(take,nottake); //just find the maxi of the above steps.\\n\\n}\\n    long long mostPoints(vector<vector<int>>& ques) {\\n        int n=ques.size();\\n        memset(dp,-1,sizeof(dp)); //dp initialisizing\\n        return solve(0,ques,n); //call the function\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934969,
                "title": "recursion-memoization",
                "content": "class Solution {\\n    long long solve(vector<vector<int>>& questions, vector<long long>& dp, int i, int n) {\\n        if (i >= n) {\\n            return 0;\\n        }\\n        if (dp[i] != -1) {\\n            return dp[i];\\n        }\\n        if(i==n-1){\\n            return questions[i][0];}\\n        long long ans1 = 0, ans2 = 0;\\n        ans1 = questions[i][0] + solve(questions, dp, i + questions[i][1]+1, n);\\n        ans2 = 0+solve(questions, dp, i + 1, n);\\n        return dp[i] = max(ans1, ans2);\\n    }\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long> dp(n + 1, -1);\\n        return solve(questions, dp, 0, n);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    long long solve(vector<vector<int>>& questions, vector<long long>& dp, int i, int n) {\\n        if (i >= n) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3852214,
                "title": "bottom-up-top-down-0-1-knapsack-approach-faster-than-96-java",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Bottom-up\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long[] dp = new long[n];\\n        dp[n-1] = questions[n-1][0];\\n        for (int i = n-2; i >= 0; i--) {\\n            dp[i] = Math.max(dp[i + 1], questions[i][0] + getValue(i + questions[i][1] + 1, dp));\\n        }\\n        return dp[0];\\n    }\\n    \\n    private long getValue(int i, long[] dp) {\\n        if(i >= dp.length) return 0L;\\n        return dp[i];\\n    }\\n}\\n```\\n\\n# Top-down\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        long[] memo = new long[questions.length];\\n        Arrays.fill(memo, -1L);\\n        return solveQuestions(0, questions, memo);\\n    }\\n\\n    private long solveQuestions(int n, int[][] questions, long[] memo) {\\n        if(n >= questions.length) return 0L;\\n        if(memo[n] != -1) return memo[n];\\n        memo[n] = Math.max(\\n                questions[n][0] + solveQuestions(n + questions[n][1] + 1, questions, memo),\\n                solveQuestions(n + 1, questions, memo)\\n        );\\n        return memo[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long[] dp = new long[n];\\n        dp[n-1] = questions[n-1][0];\\n        for (int i = n-2; i >= 0; i--) {\\n            dp[i] = Math.max(dp[i + 1], questions[i][0] + getValue(i + questions[i][1] + 1, dp));\\n        }\\n        return dp[0];\\n    }\\n    \\n    private long getValue(int i, long[] dp) {\\n        if(i >= dp.length) return 0L;\\n        return dp[i];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        long[] memo = new long[questions.length];\\n        Arrays.fill(memo, -1L);\\n        return solveQuestions(0, questions, memo);\\n    }\\n\\n    private long solveQuestions(int n, int[][] questions, long[] memo) {\\n        if(n >= questions.length) return 0L;\\n        if(memo[n] != -1) return memo[n];\\n        memo[n] = Math.max(\\n                questions[n][0] + solveQuestions(n + questions[n][1] + 1, questions, memo),\\n                solveQuestions(n + 1, questions, memo)\\n        );\\n        return memo[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773704,
                "title": "98-fastest-solution-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo options either to solve the question or not to solve the question and check the maximum points u can get after solving one question\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n=len(questions)\\n        dp=[0 for i in range(n)]\\n        dp[n-1]=questions[n-1][0]\\n        for i in range(n-2,-1,-1):\\n            if i+questions[i][1]+1<len(questions):\\n                dp[i]=max(dp[i+1],questions[i][0]+dp[i+questions[i][1]+1])\\n            else:\\n                dp[i]=max(dp[i+1],questions[i][0])\\n        return dp[0]\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n=len(questions)\\n        dp=[0 for i in range(n)]\\n        dp[n-1]=questions[n-1][0]\\n        for i in range(n-2,-1,-1):\\n            if i+questions[i][1]+1<len(questions):\\n                dp[i]=max(dp[i+1],questions[i][0]+dp[i+questions[i][1]+1])\\n            else:\\n                dp[i]=max(dp[i+1],questions[i][0])\\n        return dp[0]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749295,
                "title": "house-robber-type-question",
                "content": "\\n\\n# Approach\\n\\nThis queston is very similar to house robber question, The similarity between the two problems lies in the idea of making choices among available options to maximize the overall value. In the House Robber problem, the choice is whether to rob a house or not, while in this problem, the choice is wheather to solve a question or not.\\nThe only difference is instead of skipping adjacent house (i.e 1 house) we are asked to skip questions[i][1] houses.\\n\\nRest of the approach is same i.e we have two choices :\\n\\n1.) Either we can take the question, which implies adding questions[i][0] score but we will forced to skip next questions[i][1] questions.\\n\\n2.) Or we can skip the current question & move on to the next question.\\n\\nWe will try both of them, and save the max score in our dp vector & return it.   \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(vector<vector<int>>& questions, vector<long long> &dp, int index)\\n    {\\n        if(index>=questions.size()) return 0; //base case\\n        if(dp[index]!=-1) return dp[index];\\n\\n        long long take=questions[index][0]+solve(questions,dp,index+questions[index][1]+1); //choice 1\\n        long long dontake=solve(questions,dp,index+1); //choice 2\\n        return dp[index]=max(take,dontake); //saving the max score received from both the choices and returning it. \\n\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long> dp(questions.size(),-1);\\n        return solve(questions,dp,0);\\n    }\\n};\\n```\\n\\n# Please upvote, if you found it helpful :)\\nThanks for reading, have a nice day!",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(vector<vector<int>>& questions, vector<long long> &dp, int index)\\n    {\\n        if(index>=questions.size()) return 0; //base case\\n        if(dp[index]!=-1) return dp[index];\\n\\n        long long take=questions[index][0]+solve(questions,dp,index+questions[index][1]+1); //choice 1\\n        long long dontake=solve(questions,dp,index+1); //choice 2\\n        return dp[index]=max(take,dontake); //saving the max score received from both the choices and returning it. \\n\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long> dp(questions.size(),-1);\\n        return solve(questions,dp,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683435,
                "title": "c-recursive-tle-and-memoized-solution-using-bottom-up-approach",
                "content": "# Intuition\\nWe just have 2 options:-\\n1. Solve the question at a particular index and skip the `brainpower` number of questions to finally reach the maximum points\\n2. Just skip the question at that index and solve the next question. \\n\\n# Approach\\nBottom- up approach is needed here using the above intuition. First we calculate the maximum points from the rightmost index and then we recursively get what will be the answer if we start from the leftmost index. We also need to calculate the maximum from the 2 options mentioned above at each step.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n\\n# Recursive approach(gave TLE)\\n```\\nclass Solution {\\npublic:\\n    long long solve(vector<vector<int>> & questions, int index){\\n        if(index >= questions.size()) return 0;\\n        if(index == questions.size()-1) return questions[index][0];\\n        return max(solve(questions,index+1),questions[index][0]+solve(questions,1+index+questions[index][1]));\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n    return max(solve(questions,1),questions[0][0]+solve(questions,1+questions[0][1]));\\n    }\\n};\\n```\\n# Memoized bottom-up approach (O(N) time)\\n```\\nclass Solution {\\npublic:\\n    long long dp[100000];\\n    long long solve(vector<vector<int>> & questions, int index){\\n        if(index >= questions.size()) return 0;\\n        if(index == questions.size()-1) return dp[index] = questions[index][0];\\n        if(dp[index] != -1) return dp[index];\\n        long long ans = 0;\\n        long long right = questions[index][0]+solve(questions,index+1+questions[index][1]);\\n        long long left = solve(questions,index+1);\\n        ans = max(left,right);\\n        return dp[index] = ans;\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        memset(dp,-1,sizeof(dp));\\n        dp[n-1] = questions[n-1][0];\\n    return solve(questions,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(vector<vector<int>> & questions, int index){\\n        if(index >= questions.size()) return 0;\\n        if(index == questions.size()-1) return questions[index][0];\\n        return max(solve(questions,index+1),questions[index][0]+solve(questions,1+index+questions[index][1]));\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n    return max(solve(questions,1),questions[0][0]+solve(questions,1+questions[0][1]));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long dp[100000];\\n    long long solve(vector<vector<int>> & questions, int index){\\n        if(index >= questions.size()) return 0;\\n        if(index == questions.size()-1) return dp[index] = questions[index][0];\\n        if(dp[index] != -1) return dp[index];\\n        long long ans = 0;\\n        long long right = questions[index][0]+solve(questions,index+1+questions[index][1]);\\n        long long left = solve(questions,index+1);\\n        ans = max(left,right);\\n        return dp[index] = ans;\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        memset(dp,-1,sizeof(dp));\\n        dp[n-1] = questions[n-1][0];\\n    return solve(questions,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634121,
                "title": "c-pick-skip-top-down-bottom-up-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    long long solver(int i, vector<vector<int>>& quest, vector<long long>& dp){\\n        if(i >= quest.size()){\\n            return 0;\\n        }\\n\\n        if(dp[i] != -1) return dp[i];\\n\\n        long long skip = 0 + solver(i+1,quest,dp);\\n        long long pick = quest[i][0] + solver(i+quest[i][1]+1,quest,dp);\\n\\n        return dp[i] = max(skip,pick);\\n    }\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long> dp(n+1,0);\\n        for(int i=n-1; i>=0; i--){\\n            long long skip = 0 + dp[i+1];\\n            int index = min(i + questions[i][1] + 1, n);\\n            long long pick = questions[i][0] + dp[index];\\n\\n            dp[i] = max(skip , pick);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    long long solver(int i, vector<vector<int>>& quest, vector<long long>& dp){\\n        if(i >= quest.size()){\\n            return 0;\\n        }\\n\\n        if(dp[i] != -1) return dp[i];\\n\\n        long long skip = 0 + solver(i+1,quest,dp);\\n        long long pick = quest[i][0] + solver(i+quest[i][1]+1,quest,dp);\\n\\n        return dp[i] = max(skip,pick);\\n    }\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long> dp(n+1,0);\\n        for(int i=n-1; i>=0; i--){\\n            long long skip = 0 + dp[i+1];\\n            int index = min(i + questions[i][1] + 1, n);\\n            long long pick = questions[i][0] + dp[index];\\n\\n            dp[i] = max(skip , pick);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518734,
                "title": "easy-java-simple-recursion-memoization",
                "content": "```\\nclass Solution {\\n    long [] dp;\\n    public long mostPoints(int[][] questions) {\\n        dp = new long[questions.length +1];\\n        Arrays.fill(dp, -1);\\n        return helper(questions, 0);\\n    }\\n    \\n    \\n    public long helper(int questions [][], int i)\\n    {\\n        if(i>= questions.length)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[i]!=-1)\\n            return dp[i];\\n         \\n        // we can take or not take \\n      // if we take the option we add the points(questions[i][0]) and move forward and skip as mentioned in question \\n        long take = questions[i][0] + helper(questions, i+ questions[i][1] +1);\\n\\n // dont take just move forward \\n        long notTake = helper(questions, i+1);\\n        \\n         return dp[i]=Math.max(take, notTake);\\n\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    long [] dp;\\n    public long mostPoints(int[][] questions) {\\n        dp = new long[questions.length +1];\\n        Arrays.fill(dp, -1);\\n        return helper(questions, 0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3517474,
                "title": "python-java-c-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMemoization -> Tabulation\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\n# Memoization in Python\\nclass Solution:\\n    def find(self, questions, n, i, dp):\\n        if i >= n: return 0\\n        elif dp[i] != -1: return dp[i]\\n        dp[i] =  max(self.find(questions, n, i+1, dp), questions[i][0] + self.find(questions, n, i + questions[i][1] + 1, dp))\\n        return dp[i]\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n = len(questions)\\n        dp = [-1] * n\\n        return self.find(questions, n, 0, dp)\\n```\\n```\\n# Tabulation in Python\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n = len(questions)\\n        dp = [0] * n\\n        for i in range(n-1, -1, -1):\\n            val = questions[i][0]\\n            if i + questions[i][1] + 1 < n:\\n                val = max(val, questions[i][0] + dp[i + questions[i][1] + 1])\\n            if i + 1 < n:\\n                val = max(val, dp[i+1])\\n            dp[i] = val\\n        return dp[0]\\n```\\n```\\n// Tabulation in Java\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long dp [] =  new long [n];\\n\\n        for(int i = n-1; i >= 0; i--){\\n            long val = questions[i][0];\\n            if(i + questions[i][1] + 1 < n){\\n                val = Math.max(val, questions[i][0] + dp[i + questions[i][1] + 1]);\\n            }\\n            if(i + 1 < n){\\n                val = Math.max(val, dp[i+1]);\\n            }\\n            dp[i] = val;\\n        }\\n        return dp[0];        \\n    }\\n}\\n```\\n```\\nTabulation in C++\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long> dp(n);\\n        for(int i = n-1; i >= 0; i--){\\n            long long val = questions[i][0];\\n            if(i + questions[i][1] + 1 < n){\\n                val = max(val, questions[i][0] + dp[i + questions[i][1] + 1]);\\n            }\\n            if(i + 1 < n){\\n                val = max(val, dp[i+1]);\\n            }\\n            dp[i] = val;\\n        }\\n        return dp[0];        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\n# Memoization in Python\\nclass Solution:\\n    def find(self, questions, n, i, dp):\\n        if i >= n: return 0\\n        elif dp[i] != -1: return dp[i]\\n        dp[i] =  max(self.find(questions, n, i+1, dp), questions[i][0] + self.find(questions, n, i + questions[i][1] + 1, dp))\\n        return dp[i]\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n = len(questions)\\n        dp = [-1] * n\\n        return self.find(questions, n, 0, dp)\\n```\n```\\n# Tabulation in Python\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n = len(questions)\\n        dp = [0] * n\\n        for i in range(n-1, -1, -1):\\n            val = questions[i][0]\\n            if i + questions[i][1] + 1 < n:\\n                val = max(val, questions[i][0] + dp[i + questions[i][1] + 1])\\n            if i + 1 < n:\\n                val = max(val, dp[i+1])\\n            dp[i] = val\\n        return dp[0]\\n```\n```\\n// Tabulation in Java\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long dp [] =  new long [n];\\n\\n        for(int i = n-1; i >= 0; i--){\\n            long val = questions[i][0];\\n            if(i + questions[i][1] + 1 < n){\\n                val = Math.max(val, questions[i][0] + dp[i + questions[i][1] + 1]);\\n            }\\n            if(i + 1 < n){\\n                val = Math.max(val, dp[i+1]);\\n            }\\n            dp[i] = val;\\n        }\\n        return dp[0];        \\n    }\\n}\\n```\n```\\nTabulation in C++\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long> dp(n);\\n        for(int i = n-1; i >= 0; i--){\\n            long long val = questions[i][0];\\n            if(i + questions[i][1] + 1 < n){\\n                val = max(val, questions[i][0] + dp[i + questions[i][1] + 1]);\\n            }\\n            if(i + 1 < n){\\n                val = max(val, dp[i+1]);\\n            }\\n            dp[i] = val;\\n        }\\n        return dp[0];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517217,
                "title": "simple-c-solution-using-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(int ind, vector<vector<int>>&questions,vector<long long>&dp){\\n        if(ind>=questions.size()){\\n            return INT_MIN;\\n        }\\n        if(dp[ind]!=-1){\\n            return dp[ind];\\n        }\\n        // include the point of current question\\n        long long take = questions[ind][0];\\n        // if after skipping brainpower questions is less than array size than add the point\\n        if(ind+questions[ind][1]<questions.size())\\n            take+=solve(ind+questions[ind][1]+1,questions,dp);\\n        // skip the ith index question\\n        long long notTake = solve(ind+1,questions,dp);\\n        // take max of both take and notTake\\n        return dp[ind]=max(take,notTake);\\n\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long> dp(n+1,-1);\\n        return solve(0,questions,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(int ind, vector<vector<int>>&questions,vector<long long>&dp){\\n        if(ind>=questions.size()){\\n            return INT_MIN;\\n        }\\n        if(dp[ind]!=-1){\\n            return dp[ind];\\n        }\\n        // include the point of current question\\n        long long take = questions[ind][0];\\n        // if after skipping brainpower questions is less than array size than add the point\\n        if(ind+questions[ind][1]<questions.size())\\n            take+=solve(ind+questions[ind][1]+1,questions,dp);\\n        // skip the ith index question\\n        long long notTake = solve(ind+1,questions,dp);\\n        // take max of both take and notTake\\n        return dp[ind]=max(take,notTake);\\n\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long> dp(n+1,-1);\\n        return solve(0,questions,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517167,
                "title": "java-simple-and-optimize-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        long[] dp = new long[questions.length];\\n        Arrays.fill(dp,-1);\\n        return solve(0,questions,dp);\\n        \\n    }\\n    // public long solve(int i , int[][] arr){\\n    //     if(i>= arr.length) return 0;\\n\\n    //     // include \\n    //     long l = arr[i][0]+solve(i+arr[i][1]+1,arr);\\n        \\n    //     // exclude\\n    //     long r = solve(i+1,arr);\\n\\n    //     return Math.max(l,r);\\n    // }\\n    public long solve(int i , int[][] arr , long[] dp){\\n        if(i>= arr.length) return 0;\\n\\n        if(dp[i]!= -1) return dp[i];\\n\\n        // include \\n        long l = arr[i][0]+solve(i+arr[i][1]+1,arr,dp);\\n        \\n        // exclude\\n        long r = solve(i+1,arr,dp);\\n\\n        return dp[i] = Math.max(l,r);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        long[] dp = new long[questions.length];\\n        Arrays.fill(dp,-1);\\n        return solve(0,questions,dp);\\n        \\n    }\\n    // public long solve(int i , int[][] arr){\\n    //     if(i>= arr.length) return 0;\\n\\n    //     // include \\n    //     long l = arr[i][0]+solve(i+arr[i][1]+1,arr);\\n        \\n    //     // exclude\\n    //     long r = solve(i+1,arr);\\n\\n    //     return Math.max(l,r);\\n    // }\\n    public long solve(int i , int[][] arr , long[] dp){\\n        if(i>= arr.length) return 0;\\n\\n        if(dp[i]!= -1) return dp[i];\\n\\n        // include \\n        long l = arr[i][0]+solve(i+arr[i][1]+1,arr,dp);\\n        \\n        // exclude\\n        long r = solve(i+1,arr,dp);\\n\\n        return dp[i] = Math.max(l,r);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516983,
                "title": "beating-86-42-python-easy-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/0b9155d4-4505-49b0-9b6f-a91431b3114f_1683911559.6796672.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        lq = len(questions)\\n        dp = [0] * (lq + 1)\\n        for i in range(len(questions) - 1, -1, -1):\\n            pt, bp = questions[i]\\n            new = i + bp + 1\\n            new = lq if new >= lq else new\\n            dp[i] = max(dp[i+1], pt + dp[new])\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        lq = len(questions)\\n        dp = [0] * (lq + 1)\\n        for i in range(len(questions) - 1, -1, -1):\\n            pt, bp = questions[i]\\n            new = i + bp + 1\\n            new = lq if new >= lq else new\\n            dp[i] = max(dp[i+1], pt + dp[new])\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516846,
                "title": "java-beginner-friendly-recursion-with-caching",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe simply use recursive approch to solve this problem as given in question we simply try to do both possible conditions: \\n1) Skip current question\\n2) Select current question and perform it recursively add the points to our score.\\n\\nThis helps us to create a recursion tree(probably decision tree with max logic).\\n\\n[Note] : Not very much time good in time or space complexity but for simple understanding \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nfunction(question,index){\\n  int ifSkip = function(questions, index+1)\\n  int ifNotSkip = question[index][0] + finction(questions,index + 1 + questions[index][1] )\\n  int value = Max(ifSkip,ifNotSkip);\\n}\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    long[] cache;\\n    public long mostPoints(int[][] questions) {\\n        cache = new long[questions.length];\\n        Arrays.fill(cache,-1);  // filling cache array to check if the node/Array position is visited or not\\n        return helper(questions,0);\\n    }\\n\\n    public long helper(int[][] questions,int index){\\n        // checking for OutOfBounds for array\\n        if (index>=questions.length){\\n            return 0;\\n        }\\n\\n        // checking if node/array is alredy visited and computed then we can skip\\n        if (cache[index]==-1) {\\n\\n            // storing value in cache for the index value so that we don\\'t have to calculate value every time\\n            cache[index] = Math.max(helper(questions, index + 1), questions[index][0]+helper(questions, index + 1 + questions[index][1]));\\n\\n        // [Note: here we have to do index + 1 + skipCounts because it is zero indexed array]\\n        }\\n\\n        // returning the value\\n        return cache[index];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    long[] cache;\\n    public long mostPoints(int[][] questions) {\\n        cache = new long[questions.length];\\n        Arrays.fill(cache,-1);  // filling cache array to check if the node/Array position is visited or not\\n        return helper(questions,0);\\n    }\\n\\n    public long helper(int[][] questions,int index){\\n        // checking for OutOfBounds for array\\n        if (index>=questions.length){\\n            return 0;\\n        }\\n\\n        // checking if node/array is alredy visited and computed then we can skip\\n        if (cache[index]==-1) {\\n\\n            // storing value in cache for the index value so that we don\\'t have to calculate value every time\\n            cache[index] = Math.max(helper(questions, index + 1), questions[index][0]+helper(questions, index + 1 + questions[index][1]));\\n\\n        // [Note: here we have to do index + 1 + skipCounts because it is zero indexed array]\\n        }\\n\\n        // returning the value\\n        return cache[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516843,
                "title": "simple-c-solution-dp",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOnce we see the array in the reverse direction, we could break the problem into subproblems. After reversed `question`, `dp[i]` represents the maximum point you can earn with problem before index `i`. Then, the state transition can easily be formed by forcing the constraint of `brainpower` by transfer from the state `dp[i - 1 - questions[i][1]] + questions[i][0]` , where  `i` is the current index. (`dp[i] = max(dp[i], dp[i - 1 - questions[i][1]] + questions[i][0])`). In addition, also consider skipping current answer (`dp[i] = max(dp[i], dp[i-1])`).\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long> dp(n, 0);\\n        reverse(questions.begin(), questions.end());\\n        for(int i = 0; i<n; i++){\\n            if(i) dp[i] = max(dp[i], dp[i-1]);\\n            if(i - questions[i][1] - 1 < 0)\\n                dp[i] = max(dp[i], (long long)questions[i][0]);\\n            else\\n                dp[i] = max(dp[i], dp[i - questions[i][1] - 1] + (long long)questions[i][0]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long> dp(n, 0);\\n        reverse(questions.begin(), questions.end());\\n        for(int i = 0; i<n; i++){\\n            if(i) dp[i] = max(dp[i], dp[i-1]);\\n            if(i - questions[i][1] - 1 < 0)\\n                dp[i] = max(dp[i], (long long)questions[i][0]);\\n            else\\n                dp[i] = max(dp[i], dp[i - questions[i][1] - 1] + (long long)questions[i][0]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516807,
                "title": "pick-or-not-pick-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    long long solve(int ind, vector<vector<int>>& q,vector<long long int> &res)\\n    {\\n        if(ind >= q.size())\\n            return 0;\\n        if(res[ind]!=-1)\\n            return res[ind];\\n        long long int pick  = q[ind][0]+solve(ind+q[ind][1]+1,q,res);\\n        long long int npick  = solve(ind+1,q,res);\\n        return res[ind] = max(pick,npick);\\n    }\\n    long long mostPoints(vector<vector<int>>& q) {\\n        int n = q.size();\\n        vector<long long int> res(n,-1);\\n        return solve(0,q,res);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(int ind, vector<vector<int>>& q,vector<long long int> &res)\\n    {\\n        if(ind >= q.size())\\n            return 0;\\n        if(res[ind]!=-1)\\n            return res[ind];\\n        long long int pick  = q[ind][0]+solve(ind+q[ind][1]+1,q,res);\\n        long long int npick  = solve(ind+1,q,res);\\n        return res[ind] = max(pick,npick);\\n    }\\n    long long mostPoints(vector<vector<int>>& q) {\\n        int n = q.size();\\n        vector<long long int> res(n,-1);\\n        return solve(0,q,res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516764,
                "title": "dp-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long solve(int i,vector<vector<int>> &questions,vector<long long> &dp)\\n    {\\n         if(i >= questions.size() )\\n         {\\n             return 0;\\n         }\\n         if(dp[i]!=-1)\\n         {\\n             return dp[i];\\n         }\\n        long long x=questions[i][0]+solve(i+questions[i][1]+1,questions,dp);\\n        long long y=0+solve(i+1,questions,dp);\\n        if(x > y)\\n        {\\n            return dp[i]=x;\\n        }\\n        return dp[i]=y;\\n\\n    }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        vector<long long> dp(n+1,-1);\\n        return solve(0,questions,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long solve(int i,vector<vector<int>> &questions,vector<long long> &dp)\\n    {\\n         if(i >= questions.size() )\\n         {\\n             return 0;\\n         }\\n         if(dp[i]!=-1)\\n         {\\n             return dp[i];\\n         }\\n        long long x=questions[i][0]+solve(i+questions[i][1]+1,questions,dp);\\n        long long y=0+solve(i+1,questions,dp);\\n        if(x > y)\\n        {\\n            return dp[i]=x;\\n        }\\n        return dp[i]=y;\\n\\n    }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        vector<long long> dp(n+1,-1);\\n        return solve(0,questions,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516727,
                "title": "python3-the-most-easy-way-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Dynamic Programing or Memoization**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- we have array in given question, so we can think of something related to index.\\n- problem states that i can skip or take the question.\\n- from this our first choice is recursion because we need to try all possible ways.\\n- now in this we will encounter many overlaping sub-problems such as **if at index p we skip and go to index p+1, there might be a chance that it is previously computed by taking some index p-i**\\n- so we make dp to store these problems, we have solution.\\n\\n# Complexity\\n- Time complexity: O(2*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(2*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPoints(self, qs: List[List[int]]) -> int:\\n        n = len(qs) # get length of questions\\n        # initialise dp with -1, this will work as flag that if we found answer of sub-problem or not\\n        dp = [-1 for _ in range(n)]\\n        def f(i):\\n            if i >= n: return 0 # if jump is too far then return 0, we cannot gain point at this\\n            else:\\n                if dp[i] + 1: return dp[i] # if this sub-problem is solved then return directly\\n# now take the question to solve and move to next index which will be: brainpower + i + 1, because we have \\'0\\' based index\\n# also if we take question then add the points of it.\\n                take = f(i+qs[i][1]+1) + qs[i][0]\\n# miss the question and move to i+1 index and add point as 0\\n                miss = f(i+1) + 0\\n# update the dp to max points and return it\\n                dp[i] = max(take, miss)\\n                return dp[i]\\n        return f(0) # ofcourse we will start from 0 index and get optimal solution\\n```\\n# Please like and Comment below ( \\u0361\\u2688\\u202F\\u035C\\u0296 \\u0361\\u2688) \\uD83D\\uDC49",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mostPoints(self, qs: List[List[int]]) -> int:\\n        n = len(qs) # get length of questions\\n        # initialise dp with -1, this will work as flag that if we found answer of sub-problem or not\\n        dp = [-1 for _ in range(n)]\\n        def f(i):\\n            if i >= n: return 0 # if jump is too far then return 0, we cannot gain point at this\\n            else:\\n                if dp[i] + 1: return dp[i] # if this sub-problem is solved then return directly\\n# now take the question to solve and move to next index which will be: brainpower + i + 1, because we have \\'0\\' based index\\n# also if we take question then add the points of it.\\n                take = f(i+qs[i][1]+1) + qs[i][0]\\n# miss the question and move to i+1 index and add point as 0\\n                miss = f(i+1) + 0\\n# update the dp to max points and return it\\n                dp[i] = max(take, miss)\\n                return dp[i]\\n        return f(0) # ofcourse we will start from 0 index and get optimal solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516636,
                "title": "recursion-memoization-easy-cpp-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(vector<vector<int>>& arr,int i,vector<long long>&dp ){\\n       // BASE CASE \\n        if(i >= arr.size()) return 0;\\n\\n       // IF WE HAVE THE ANS OF ITH CASE THEN RETURN IT\\n        if(dp[i] != -1) return dp[i];\\n\\n        long long skip =  0 + solve(arr,i+1,dp); // SKIP THE QUESTION \\n        long long notskip = arr[i][0] + solve(arr,i+arr[i][1]+1,dp); // PICK THE QUESTION \\n       \\n         // STORE MAXIMUM EARN POINT \\n         return  dp[i] =  max(skip,notskip);\\n    }\\n    long long mostPoints(vector<vector<int>>& arr) {\\n\\n        vector<long long>dp(arr.size()+1,-1);  // DP ARRAY TO STORE THE ANS\\n        return solve(arr,0,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(vector<vector<int>>& arr,int i,vector<long long>&dp ){\\n       // BASE CASE \\n        if(i >= arr.size()) return 0;\\n\\n       // IF WE HAVE THE ANS OF ITH CASE THEN RETURN IT\\n        if(dp[i] != -1) return dp[i];\\n\\n        long long skip =  0 + solve(arr,i+1,dp); // SKIP THE QUESTION \\n        long long notskip = arr[i][0] + solve(arr,i+arr[i][1]+1,dp); // PICK THE QUESTION \\n       \\n         // STORE MAXIMUM EARN POINT \\n         return  dp[i] =  max(skip,notskip);\\n    }\\n    long long mostPoints(vector<vector<int>>& arr) {\\n\\n        vector<long long>dp(arr.size()+1,-1);  // DP ARRAY TO STORE THE ANS\\n        return solve(arr,0,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516567,
                "title": "2140-c-dp-8-lines-code-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we read the problem, the basic intuition for a question would either be\\n1. To solve the current question, grab the points, and skip brainpower[i] number of quesitons.\\n2. To skip the current question and solve the next question.\\n\\nAnd we would just iterate over the rest.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, in the first case,\\n1. Where the current question is solved, the points would be questions[index][0] + the maximum points of question at index+brainpower[index]+1.\\n2. If the question is skipped, points would be the maximum points of question at index+1.\\n3. The maximum points for current question will be the maximum of {1} and {2}.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs, the maximum time would be if we skip all questions and end up solving the last question, that would be ```O(n)```\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs we are keeping track of maximum points for each and every question, the extra space would be ```O(n)```\\n \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        // Create a vector to store maximum points for each question\\n        vector<long long> dp(questions.size(), -1);\\n        \\n        // The first question will eventually get the maximum points as it will go through all the questions\\n        return helper(questions, dp, 0);\\n    }\\n    long long helper(vector<vector<int>>& questions, vector<long long>& dp, int index) {\\n        // If size exceeds, return 0 so it won\\'t effect when added\\n        if(index >= questions.size()) return 0;\\n\\n        // If already computized, return the value\\n        if(dp[index] != -1) return dp[index];\\n\\n        // Calculate the values and return them\\n        // Result 1 is the prediction that we solve the current question and skip the next brainpower[i] questions\\n        long long res1 = questions[index][0] + helper(questions, dp, index+questions[index][1]+1);\\n        // Result 2 is the prediction that we skip the current question and solve the next question \\n        long long res2 = helper(questions, dp, index+1);\\n        dp[index] = res1 > res2 ? res1 : res2;\\n        return dp[index];\\n    }\\n};\\n```\\n\\n                ```Please Upvote if you like my content.```\\n\\n\\n.",
                "solutionTags": [
                    "C",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```O(n)```\n```O(n)```\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        // Create a vector to store maximum points for each question\\n        vector<long long> dp(questions.size(), -1);\\n        \\n        // The first question will eventually get the maximum points as it will go through all the questions\\n        return helper(questions, dp, 0);\\n    }\\n    long long helper(vector<vector<int>>& questions, vector<long long>& dp, int index) {\\n        // If size exceeds, return 0 so it won\\'t effect when added\\n        if(index >= questions.size()) return 0;\\n\\n        // If already computized, return the value\\n        if(dp[index] != -1) return dp[index];\\n\\n        // Calculate the values and return them\\n        // Result 1 is the prediction that we solve the current question and skip the next brainpower[i] questions\\n        long long res1 = questions[index][0] + helper(questions, dp, index+questions[index][1]+1);\\n        // Result 2 is the prediction that we skip the current question and solve the next question \\n        long long res2 = helper(questions, dp, index+1);\\n        dp[index] = res1 > res2 ? res1 : res2;\\n        return dp[index];\\n    }\\n};\\n```\n```Please Upvote if you like my content.```",
                "codeTag": "Java"
            },
            {
                "id": 3516559,
                "title": "easy-c-dp-memoization-take-and-nottake-concept",
                "content": "# Intuition \\nWe needed to find the maximum after doing all possible combinations so we need a reccursive approach , and hence dynamic programming is required.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe solve this by using the take and nottake concept using dynamic programming.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong long solve(int ind,int n,vector<long long>& dp,vector<vector<int>>& questions){\\n    if(ind>=n)\\n        return 0;\\n    if(ind==n-1)\\n        return questions[ind][0];\\n    if(dp[ind]!=-1)\\n            return dp[ind];\\n    \\n    long long take=questions[ind][0]+solve(ind+questions[ind][1]+1,n,dp,questions);\\n    long long nottake=0 + solve(ind+1,n,dp,questions);\\n    return dp[ind] = max(take,nottake);\\n}\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long> dp(questions.size()+1,-1);\\n        return solve(0,questions.size(),dp,questions);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong long solve(int ind,int n,vector<long long>& dp,vector<vector<int>>& questions){\\n    if(ind>=n)\\n        return 0;\\n    if(ind==n-1)\\n        return questions[ind][0];\\n    if(dp[ind]!=-1)\\n            return dp[ind];\\n    \\n    long long take=questions[ind][0]+solve(ind+questions[ind][1]+1,n,dp,questions);\\n    long long nottake=0 + solve(ind+1,n,dp,questions);\\n    return dp[ind] = max(take,nottake);\\n}\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long> dp(questions.size()+1,-1);\\n        return solve(0,questions.size(),dp,questions);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516520,
                "title": "memoization-tabulation-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt every position we have two choices wheter to answer that questions or leave it, hence we donot how the subsquent questions are going to be hence we donot have any other option other than trying all possible ways to answer the question.This can be done using recursion.\\nWhich can be optimized using memoization or tabulation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt every question consider two choices, they are\\n1)Answer the question, then add points to your score and skip the next questions according to the condition given in the question i.e Solving question i will earn you pointsi points but you will be unable to solve each of the next brainpoweri questions.\\n\\n2)Leave that particular question and try next question, in this case no score gets added.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nMemoization : O(N+N)\\nFor recursive stack space(N) and dp array(N);\\n\\nTabulation:O(N)\\nN for the dp array.\\n\\n# Code\\n```\\nclass Solution {\\n    //Memoization\\n    public long Util(int index,int[][] questions,long[] dp){\\n        if(index >= questions.length)\\n            return 0;\\n         if(dp[index] != -1)\\n            return dp[index];\\n\\n        long maxi = Integer.MIN_VALUE;\\n        \\n        //Take\\n        maxi = Math.max(maxi,questions[index][0]+\\n                        Util(index+questions[index][1]+1,questions,dp));\\n            \\n        //Not take\\n        maxi = Math.max(maxi,Util(index+1,questions,dp));\\n\\n        return dp[index] = maxi;\\n    }\\n    //Tabulation\\n    public long mostPoints(int[][] questions) {\\n\\n        long[] dp = new long[questions.length+questions[questions.length-1][1]+1];\\n        \\n        for(int i=questions.length;i<dp.length;i++)\\n            dp[i] = 0;\\n\\n        for(int i=questions.length-1;i>=0;i--){\\n            long maxi = Integer.MIN_VALUE;\\n        \\n            //Take\\n\\n            if(i+questions[i][1]+1>=questions.length)\\n                maxi = Math.max(maxi,questions[i][0]+0);\\n            else\\n                maxi = Math.max(maxi,questions[i][0]+dp[i+questions[i][1]+1]);\\n            \\n            //Not take\\n            if(i+1>=questions.length)\\n                maxi = Math.max(maxi,questions[i][0]+0);\\n            else\\n                maxi = Math.max(maxi,dp[i+1]);\\n\\n            dp[i] = maxi;\\n        }\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //Memoization\\n    public long Util(int index,int[][] questions,long[] dp){\\n        if(index >= questions.length)\\n            return 0;\\n         if(dp[index] != -1)\\n            return dp[index];\\n\\n        long maxi = Integer.MIN_VALUE;\\n        \\n        //Take\\n        maxi = Math.max(maxi,questions[index][0]+\\n                        Util(index+questions[index][1]+1,questions,dp));\\n            \\n        //Not take\\n        maxi = Math.max(maxi,Util(index+1,questions,dp));\\n\\n        return dp[index] = maxi;\\n    }\\n    //Tabulation\\n    public long mostPoints(int[][] questions) {\\n\\n        long[] dp = new long[questions.length+questions[questions.length-1][1]+1];\\n        \\n        for(int i=questions.length;i<dp.length;i++)\\n            dp[i] = 0;\\n\\n        for(int i=questions.length-1;i>=0;i--){\\n            long maxi = Integer.MIN_VALUE;\\n        \\n            //Take\\n\\n            if(i+questions[i][1]+1>=questions.length)\\n                maxi = Math.max(maxi,questions[i][0]+0);\\n            else\\n                maxi = Math.max(maxi,questions[i][0]+dp[i+questions[i][1]+1]);\\n            \\n            //Not take\\n            if(i+1>=questions.length)\\n                maxi = Math.max(maxi,questions[i][0]+0);\\n            else\\n                maxi = Math.max(maxi,dp[i+1]);\\n\\n            dp[i] = maxi;\\n        }\\n\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516507,
                "title": "python-solution-tc-o-n-sc-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    \\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n = len(questions)\\n        dp = [0]*n\\n        dp[-1] = questions[-1][0]\\n        for i in range(n-2, -1, -1):\\n            val = dp[i+questions[i][1]+1] if i+questions[i][1]+1<n else 0 \\n            dp[i] = max(dp[i+1], questions[i][0] + val)\\n        return dp[0]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n = len(questions)\\n        dp = [0]*n\\n        dp[-1] = questions[-1][0]\\n        for i in range(n-2, -1, -1):\\n            val = dp[i+questions[i][1]+1] if i+questions[i][1]+1<n else 0 \\n            dp[i] = max(dp[i+1], questions[i][0] + val)\\n        return dp[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516490,
                "title": "c-easy-solution-dynamic-programming-bottom-up-approach",
                "content": "\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long> dp(n+1, 0);\\n        for(int i=n-1;i>=0;i--){\\n            int points = questions[i][0];\\n            int skips = questions[i][1];\\n\\n            int nextQues = min(n, i+skips+1);\\n\\n            dp[i] = max(dp[i+1], points + dp[nextQues]);\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/1e0c7fe2-2316-453d-96f2-540bedee0bcc_1683902366.6586585.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long> dp(n+1, 0);\\n        for(int i=n-1;i>=0;i--){\\n            int points = questions[i][0];\\n            int skips = questions[i][1];\\n\\n            int nextQues = min(n, i+skips+1);\\n\\n            dp[i] = max(dp[i+1], points + dp[nextQues]);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516442,
                "title": "dp-choose-not-choose-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    vector<vector<int>>v;\\n    long long mostPoints(vector<vector<int>>& questions) \\n    {\\n        v=questions;\\n        vector<ll>dp(1e5+1,0);\\n        // return f(0,dp);\\n        return f(dp);    \\n    }\\n    ll f(ll i,vector<ll>&dp)\\n    {\\n        if (i>=v.size())\\n        {\\n            return 0;\\n        }\\n        if (dp[i]!=-1)\\n        {\\n            return dp[i];\\n        }\\n        //not choose\\n        ll ans=f(i+1,dp);\\n        //choose\\n        ans=max(ans,v[i][0]+f(i+v[i][1]+1,dp));\\n        return dp[i]=ans;\\n    }\\n    ll f(vector<ll>&dp)\\n    {\\n        int n=v.size()-1;\\n        dp[n]=v[n][0];\\n        for(int i=v.size()-2;i>=0;i--)\\n        {\\n            ll ans=dp[i+1];\\n            ll temp=v[i][0];\\n            if (v[i][1]+1+i<=n)\\n            {\\n                temp+=dp[i+v[i][1]+1];\\n            }\\n            dp[i]=max(ans,temp);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    vector<vector<int>>v;\\n    long long mostPoints(vector<vector<int>>& questions) \\n    {\\n        v=questions;\\n        vector<ll>dp(1e5+1,0);\\n        // return f(0,dp);\\n        return f(dp);    \\n    }\\n    ll f(ll i,vector<ll>&dp)\\n    {\\n        if (i>=v.size())\\n        {\\n            return 0;\\n        }\\n        if (dp[i]!=-1)\\n        {\\n            return dp[i];\\n        }\\n        //not choose\\n        ll ans=f(i+1,dp);\\n        //choose\\n        ans=max(ans,v[i][0]+f(i+v[i][1]+1,dp));\\n        return dp[i]=ans;\\n    }\\n    ll f(vector<ll>&dp)\\n    {\\n        int n=v.size()-1;\\n        dp[n]=v[n][0];\\n        for(int i=v.size()-2;i>=0;i--)\\n        {\\n            ll ans=dp[i+1];\\n            ll temp=v[i][0];\\n            if (v[i][1]+1+i<=n)\\n            {\\n                temp+=dp[i+v[i][1]+1];\\n            }\\n            dp[i]=max(ans,temp);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516397,
                "title": "clean-code-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dp(vector<vector<int>> & v,int i,vector<long long>& ch){\\n        if(i>=v.size()){\\n            return 0;\\n        }\\n        if(ch[i]!=-1){\\n            return ch[i];\\n        }\\n        long long take=dp(v,i+1+v[i][1],ch)+v[i][0];\\n        long long notake=dp(v,i+1,ch);\\n        return ch[i]=max(take,notake);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long> ch(questions.size(),-1);\\n        return dp(questions,0,ch);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp(vector<vector<int>> & v,int i,vector<long long>& ch){\\n        if(i>=v.size()){\\n            return 0;\\n        }\\n        if(ch[i]!=-1){\\n            return ch[i];\\n        }\\n        long long take=dp(v,i+1+v[i][1],ch)+v[i][0];\\n        long long notake=dp(v,i+1,ch);\\n        return ch[i]=max(take,notake);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long> ch(questions.size(),-1);\\n        return dp(questions,0,ch);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516244,
                "title": "using-dp",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing array to store the subproblem solutions (Dynamic Programming). \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int len = questions.length; \\n        if(len == 0) return 0; \\n        long[] maxPoints = new long[len];\\n        for(int i=len-1;i>=0;i--){\\n            if(i==len-1) maxPoints[i] =  questions[i][0];\\n            else{\\n                long maxBySkippingCurrentQuestion = maxPoints[i+1];\\n                long maxBySolvingCurrentQuestion = 0;\\n                if((i+questions[i][1]+1) < len){\\n                    maxBySolvingCurrentQuestion = questions[i][0] + maxPoints[i+questions[i][1]+1];\\n                }else{\\n                    maxBySolvingCurrentQuestion = questions[i][0];\\n                }\\n                maxPoints[i] = Long.max(maxBySkippingCurrentQuestion,maxBySolvingCurrentQuestion);\\n            }\\n        }\\n        return maxPoints[0];\\n    }\\n    //by without DP, takes much time & space \\n    public int mostPoints(int[][] questions,int startIndex){\\n        if (startIndex>=questions.length) return 0;\\n        return Integer.max(\\n            questions[startIndex][0]+mostPoints(questions,startIndex+questions[startIndex][1]+1),\\n            mostPoints(questions,startIndex+1)\\n        );\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int len = questions.length; \\n        if(len == 0) return 0; \\n        long[] maxPoints = new long[len];\\n        for(int i=len-1;i>=0;i--){\\n            if(i==len-1) maxPoints[i] =  questions[i][0];\\n            else{\\n                long maxBySkippingCurrentQuestion = maxPoints[i+1];\\n                long maxBySolvingCurrentQuestion = 0;\\n                if((i+questions[i][1]+1) < len){\\n                    maxBySolvingCurrentQuestion = questions[i][0] + maxPoints[i+questions[i][1]+1];\\n                }else{\\n                    maxBySolvingCurrentQuestion = questions[i][0];\\n                }\\n                maxPoints[i] = Long.max(maxBySkippingCurrentQuestion,maxBySolvingCurrentQuestion);\\n            }\\n        }\\n        return maxPoints[0];\\n    }\\n    //by without DP, takes much time & space \\n    public int mostPoints(int[][] questions,int startIndex){\\n        if (startIndex>=questions.length) return 0;\\n        return Integer.max(\\n            questions[startIndex][0]+mostPoints(questions,startIndex+questions[startIndex][1]+1),\\n            mostPoints(questions,startIndex+1)\\n        );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516184,
                "title": "different-approach-o-nlogn-using-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaintain pq of max score till each i and insert them in the pq, with the index after which these scores can be used. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen processing for a index, update the current max score by popping all the score for indexes lower than this index.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NLogN)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& a) {\\n        using ll = long long;\\n        using pii = pair<int,ll>;\\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\\n        ll max_score_till_here = 0;\\n        for(int i = 0; i < a.size(); i++) {\\n            \\n            while(!pq.empty() && pq.top().first < i) {\\n                auto [idx, use_this] = pq.top();\\n                pq.pop();\\n                // update max score.\\n                max_score_till_here = max(max_score_till_here, use_this);\\n            }\\n\\n            ll score_at_this = max_score_till_here + a[i][0];\\n            \\n            int cant_use_till = i + a[i][1]; // can use for i greater than this.\\n            \\n            pq.push({cant_use_till, score_at_this});\\n        }\\n\\n         while(!pq.empty()) {\\n            auto [idx, use_this] = pq.top();\\n            pq.pop();\\n            max_score_till_here = max(max_score_till_here, use_this);\\n        }\\n\\n        return max_score_till_here;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& a) {\\n        using ll = long long;\\n        using pii = pair<int,ll>;\\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\\n        ll max_score_till_here = 0;\\n        for(int i = 0; i < a.size(); i++) {\\n            \\n            while(!pq.empty() && pq.top().first < i) {\\n                auto [idx, use_this] = pq.top();\\n                pq.pop();\\n                // update max score.\\n                max_score_till_here = max(max_score_till_here, use_this);\\n            }\\n\\n            ll score_at_this = max_score_till_here + a[i][0];\\n            \\n            int cant_use_till = i + a[i][1]; // can use for i greater than this.\\n            \\n            pq.push({cant_use_till, score_at_this});\\n        }\\n\\n         while(!pq.empty()) {\\n            auto [idx, use_this] = pq.top();\\n            pq.pop();\\n            max_score_till_here = max(max_score_till_here, use_this);\\n        }\\n\\n        return max_score_till_here;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516154,
                "title": "java-easy-solution-dp-memorization-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        long dp[] = new long[questions.length];\\n        Arrays.fill(dp,-1);\\n        return helper(questions,0,dp);\\n    }\\n    public long helper(int nums[][],int i,long dp[]){\\n        if(i >= nums.length){\\n            return 0;\\n        }\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        long take = helper(nums,i+nums[i][1]+1,dp) + nums[i][0];\\n        long notTake = helper(nums,i+1,dp);\\n        return dp[i] = (long)Math.max(take,notTake);\\n    }\\n}\\n```\\n**Please UpVote If you like it Happy Coding :)\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        long dp[] = new long[questions.length];\\n        Arrays.fill(dp,-1);\\n        return helper(questions,0,dp);\\n    }\\n    public long helper(int nums[][],int i,long dp[]){\\n        if(i >= nums.length){\\n            return 0;\\n        }\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        long take = helper(nums,i+nums[i][1]+1,dp) + nums[i][0];\\n        long notTake = helper(nums,i+1,dp);\\n        return dp[i] = (long)Math.max(take,notTake);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516058,
                "title": "memoization-solution-java",
                "content": "# Intuition\\n<!-- Take not take solution -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        long dp[] = new long[questions.length];\\n        Arrays.fill(dp,-1);\\n        return helper(questions,0,dp);\\n    }\\n\\n    public long helper(int nums[][],int idx,long dp[]){\\n        if(idx >= nums.length)\\n            return 0;\\n        if(dp[idx] != -1)\\n            return (long)dp[idx];\\n\\n        long take = nums[idx][0] + helper(nums,idx+ nums[idx][1]+1 ,dp);\\n        long notTake = helper(nums,idx+1,dp);\\n        return dp[idx] = (long)Math.max(take,notTake);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        long dp[] = new long[questions.length];\\n        Arrays.fill(dp,-1);\\n        return helper(questions,0,dp);\\n    }\\n\\n    public long helper(int nums[][],int idx,long dp[]){\\n        if(idx >= nums.length)\\n            return 0;\\n        if(dp[idx] != -1)\\n            return (long)dp[idx];\\n\\n        long take = nums[idx][0] + helper(nums,idx+ nums[idx][1]+1 ,dp);\\n        long notTake = helper(nums,idx+1,dp);\\n        return dp[idx] = (long)Math.max(take,notTake);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516034,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size(), jumpInd = 0;\\n        long long pick = 0, notPick = 0;\\n        vector<long long> dp(n, -1);\\n\\n        for(int ind = n - 1; ind >= 0; ind--) {\\n            jumpInd = ind + questions[ind][1] + 1;\\n\\n            pick = questions[ind][0];\\n            if (jumpInd < n) pick +=  dp[jumpInd];\\n\\n            notPick = 0;\\n            if (ind + 1 < n) notPick += dp[ind + 1];\\n\\n            dp[ind] = max(pick, notPick);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size(), jumpInd = 0;\\n        long long pick = 0, notPick = 0;\\n        vector<long long> dp(n, -1);\\n\\n        for(int ind = n - 1; ind >= 0; ind--) {\\n            jumpInd = ind + questions[ind][1] + 1;\\n\\n            pick = questions[ind][0];\\n            if (jumpInd < n) pick +=  dp[jumpInd];\\n\\n            notPick = 0;\\n            if (ind + 1 < n) notPick += dp[ind + 1];\\n\\n            dp[ind] = max(pick, notPick);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516017,
                "title": "simple-solution-by-recursive-dp",
                "content": "# Recursive dp\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\t\\n\\tvector<vector<int>>v;\\n\\tlong long dp[100005];\\n\\tlong long recg(int idx)\\n\\t{\\n\\n\\t\\tif (idx >= v.size())\\n\\t\\t\\treturn 0;\\n\\t\\tif (dp[idx] != -1)\\n\\t\\t\\treturn dp[idx];\\n\\n\\t\\tint earn = v[idx][0];\\n\\t\\tint skip = v[idx][1];\\n\\n\\t\\treturn dp[idx] = max(\\n\\t\\t\\tearn + recg(idx + skip + 1),\\n\\t\\t\\trecg(idx + 1)\\n\\t\\t);\\n\\n\\n\\t}\\n\\tlong long mostPoints(vector<vector<int>>& questions) \\n\\t{\\n\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\t\\n\\t\\tv = questions;\\n\\t\\t\\n\\t\\treturn recg(0);\\n\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t\\n\\tvector<vector<int>>v;\\n\\tlong long dp[100005];\\n\\tlong long recg(int idx)\\n\\t{\\n\\n\\t\\tif (idx >= v.size())\\n\\t\\t\\treturn 0;\\n\\t\\tif (dp[idx] != -1)\\n\\t\\t\\treturn dp[idx];\\n\\n\\t\\tint earn = v[idx][0];\\n\\t\\tint skip = v[idx][1];\\n\\n\\t\\treturn dp[idx] = max(\\n\\t\\t\\tearn + recg(idx + skip + 1),\\n\\t\\t\\trecg(idx + 1)\\n\\t\\t);\\n\\n\\n\\t}\\n\\tlong long mostPoints(vector<vector<int>>& questions) \\n\\t{\\n\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\t\\n\\t\\tv = questions;\\n\\t\\t\\n\\t\\treturn recg(0);\\n\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516015,
                "title": "python-memo-recursion",
                "content": "```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        @cache\\n        def dfs(q):\\n            if q >= len(questions):\\n                return 0\\n            return max(questions[q][0] + dfs(q + questions[q][1] + 1), dfs(q + 1))\\n        return dfs(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        @cache\\n        def dfs(q):\\n            if q >= len(questions):\\n                return 0\\n            return max(questions[q][0] + dfs(q + questions[q][1] + 1), dfs(q + 1))\\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515759,
                "title": "python-backtracking-recursive-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        dp = {}\\n        def dfs(i):\\n            if i >= len(questions):\\n                return 0\\n\\n            if i in dp:\\n                return dp[i]\\n\\n            points, skipNext = questions[i]\\n            dp[i] = max(dfs(i + 1), points + dfs(i + 1 + skipNext))\\n            return dp[i]\\n\\n        return dfs(0)\\n```\\n# Please upvote if you find this helpful.",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        dp = {}\\n        def dfs(i):\\n            if i >= len(questions):\\n                return 0\\n\\n            if i in dp:\\n                return dp[i]\\n\\n            points, skipNext = questions[i]\\n            dp[i] = max(dfs(i + 1), points + dfs(i + 1 + skipNext))\\n            return dp[i]\\n\\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515733,
                "title": "c-dp-easy-solution",
                "content": "\\n# Complexity\\n- **Time complexity:\\nO(N)**\\n\\n- **Space complexity:\\nO(N)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dp[100005];\\n    long long helper(vector<vector<int>>&quest,int i)\\n    {\\n        if(i>=quest.size())return 0;\\n        if(dp[i]!=-1)return dp[i];\\n        return dp[i]=max(quest[i][0]+helper(quest,i+quest[i][1]+1),helper(quest,i+1));\\n    }\\n    long long mostPoints(vector<vector<int>>& quest) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(quest,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[100005];\\n    long long helper(vector<vector<int>>&quest,int i)\\n    {\\n        if(i>=quest.size())return 0;\\n        if(dp[i]!=-1)return dp[i];\\n        return dp[i]=max(quest[i][0]+helper(quest,i+quest[i][1]+1),helper(quest,i+1));\\n    }\\n    long long mostPoints(vector<vector<int>>& quest) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(quest,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515701,
                "title": "java-solution-with-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n   public long mostPoints(int[][] questions) {\\n        return getPoints(questions, 0, new long[questions.length]);\\n    }\\n    private long getPoints(int[][] q, int idx, long[] ans) {\\n        if (idx >= q.length) { // base cases.\\n            return 0;\\n        }else if (ans[idx] == 0) { // general case.\\n            int points = q[idx][0], brain = q[idx][1];\\n            // max points if we solve questions[i].\\n            long cur = points + getPoints(q, idx + 1 + brain, ans);\\n            // max points we can get for questions[i] \\n            // (i = idx, idx + 1, ..., questions.length - 1).\\n            ans[idx] = Math.max(cur, getPoints(q, idx + 1, ans));\\n        }\\n        return ans[idx];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n   public long mostPoints(int[][] questions) {\\n        return getPoints(questions, 0, new long[questions.length]);\\n    }\\n    private long getPoints(int[][] q, int idx, long[] ans) {\\n        if (idx >= q.length) { // base cases.\\n            return 0;\\n        }else if (ans[idx] == 0) { // general case.\\n            int points = q[idx][0], brain = q[idx][1];\\n            // max points if we solve questions[i].\\n            long cur = points + getPoints(q, idx + 1 + brain, ans);\\n            // max points we can get for questions[i] \\n            // (i = idx, idx + 1, ..., questions.length - 1).\\n            ans[idx] = Math.max(cur, getPoints(q, idx + 1, ans));\\n        }\\n        return ans[idx];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515689,
                "title": "java-recursive-and-memoization-approach",
                "content": "# Complexity\\nFor Memoization\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        // return helperRec(questions, 0);\\n\\n        long[] dp = new long[questions.length + 1];\\n        Arrays.fill(dp, -1);\\n        return helperMem(questions, 0, dp);\\n    }\\n    public long helperRec(int[][] questions, int index){\\n        if(index > questions.length - 1) return 0;\\n        long points = 0;\\n        long take = (long)questions[index][0] + helperRec(questions, index + questions[index][1] + 1);\\n        long notTake = 0 + helperRec(questions, index + 1);\\n        return Math.max(take, notTake);\\n    }\\n\\n    public long helperMem(int[][] questions, int index, long[] dp){\\n        if(index > questions.length - 1) return 0;\\n        if(dp[index] != -1) return dp[index];\\n        long points = 0;\\n        long take = (long)questions[index][0] + helperMem(questions, index + questions[index][1] + 1, dp);\\n        long notTake = 0 + helperMem(questions, index + 1, dp);\\n        return dp[index] = Math.max(take, notTake);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        // return helperRec(questions, 0);\\n\\n        long[] dp = new long[questions.length + 1];\\n        Arrays.fill(dp, -1);\\n        return helperMem(questions, 0, dp);\\n    }\\n    public long helperRec(int[][] questions, int index){\\n        if(index > questions.length - 1) return 0;\\n        long points = 0;\\n        long take = (long)questions[index][0] + helperRec(questions, index + questions[index][1] + 1);\\n        long notTake = 0 + helperRec(questions, index + 1);\\n        return Math.max(take, notTake);\\n    }\\n\\n    public long helperMem(int[][] questions, int index, long[] dp){\\n        if(index > questions.length - 1) return 0;\\n        if(dp[index] != -1) return dp[index];\\n        long points = 0;\\n        long take = (long)questions[index][0] + helperMem(questions, index + questions[index][1] + 1, dp);\\n        long notTake = 0 + helperMem(questions, index + 1, dp);\\n        return dp[index] = Math.max(take, notTake);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515610,
                "title": "easy-self-explainable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n=questions.length;\\n        long dp[]=new long[n+1]; \\n        Arrays.fill(dp,-1);\\n        return solve(0,n,questions,dp);\\n    }\\n    public long solve(int i,int n,int[][] a,long dp[])\\n    {\\n        if(i>=n)\\n        return 0;\\n        if(i==n-1)\\n        return a[i][0];\\n        if(dp[i]!=-1)\\n        return dp[i];\\n        int x=a[i][1];\\n        long l=a[i][0]+solve(i+x+1,n,a,dp);\\n        long m=solve(i+1,n,a,dp);\\n        return dp[i]=Math.max(l,m);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n=questions.length;\\n        long dp[]=new long[n+1]; \\n        Arrays.fill(dp,-1);\\n        return solve(0,n,questions,dp);\\n    }\\n    public long solve(int i,int n,int[][] a,long dp[])\\n    {\\n        if(i>=n)\\n        return 0;\\n        if(i==n-1)\\n        return a[i][0];\\n        if(dp[i]!=-1)\\n        return dp[i];\\n        int x=a[i][1];\\n        long l=a[i][0]+solve(i+x+1,n,a,dp);\\n        long m=solve(i+1,n,a,dp);\\n        return dp[i]=Math.max(l,m);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515576,
                "title": "simple-and-clean-solution-using-dynamic-programming",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        long[] dp = new long[questions.length];\\n\\n        return calcMostPoints(questions, dp, 0);\\n    }\\n\\n    private long calcMostPoints(int[][] questions, long[] dp, int i){\\n        if(i >= questions.length) return 0;\\n        if(dp[i] != 0) return dp[i];\\n        else {\\n            int points = questions[i][0];\\n            int bp = questions[i][1];\\n            \\n            dp[i] = Math.max(points + calcMostPoints(questions, dp, i + bp + 1), calcMostPoints(questions, dp, i + 1));\\n            return dp[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        long[] dp = new long[questions.length];\\n\\n        return calcMostPoints(questions, dp, 0);\\n    }\\n\\n    private long calcMostPoints(int[][] questions, long[] dp, int i){\\n        if(i >= questions.length) return 0;\\n        if(dp[i] != 0) return dp[i];\\n        else {\\n            int points = questions[i][0];\\n            int bp = questions[i][1];\\n            \\n            dp[i] = Math.max(points + calcMostPoints(questions, dp, i + bp + 1), calcMostPoints(questions, dp, i + 1));\\n            return dp[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515541,
                "title": "2-line-dp-solution",
                "content": "```\\nll dp[100001];\\n    ll f(vector<vector<int>>& q,int i=0)\\n    {\\n        if(i>=q.size()) return 0; if(dp[i]!=-1) return dp[i];\\n        return dp[i]=max(f(q,i+1),q[i][0]+f(q,i+q[i][1]+1));\\n    }\\n    long long mostPoints(vector<vector<int>>& q){\\n        memset(dp,-1,sizeof(dp));\\n        return f(q);\\n    }\\n\\t",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nll dp[100001];\\n    ll f(vector<vector<int>>& q,int i=0)\\n    {\\n        if(i>=q.size()) return 0; if(dp[i]!=-1) return dp[i];\\n        return dp[i]=max(f(q,i+1),q[i][0]+f(q,i+q[i][1]+1));\\n    }\\n    long long mostPoints(vector<vector<int>>& q){\\n        memset(dp,-1,sizeof(dp));\\n        return f(q);\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 3515513,
                "title": "swift-clean-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func mostPoints(_ questions: [[Int]]) -> Int\\n    {\\n        let n = questions.count\\n        var scoresDP: [Int] = Array(repeating: 0, count: n)\\n        var maxScore = 0, points: Int, brainpower: Int\\n        for i in scoresDP.indices.reversed()\\n        {\\n            points = questions[i][0]\\n            brainpower = questions[i][1] + 1\\n            if i + brainpower >= n {                \\n                scoresDP[i] = max(maxScore, points)\\n            } // skip to the max route somewhere next, or solve question, choose what brings more\\n            else {\\n                scoresDP[i] = max(maxScore, points + scoresDP[i + brainpower])\\n            }\\n            maxScore = max(maxScore, scoresDP[i])\\n        }\\n        return maxScore\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    func mostPoints(_ questions: [[Int]]) -> Int\\n    {\\n        let n = questions.count\\n        var scoresDP: [Int] = Array(repeating: 0, count: n)\\n        var maxScore = 0, points: Int, brainpower: Int\\n        for i in scoresDP.indices.reversed()\\n        {\\n            points = questions[i][0]\\n            brainpower = questions[i][1] + 1\\n            if i + brainpower >= n {                \\n                scoresDP[i] = max(maxScore, points)\\n            } // skip to the max route somewhere next, or solve question, choose what brings more\\n            else {\\n                scoresDP[i] = max(maxScore, points + scoresDP[i + brainpower])\\n            }\\n            maxScore = max(maxScore, scoresDP[i])\\n        }\\n        return maxScore\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515508,
                "title": "fastest-c-solution-memoization-tabulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // long long f(int idx, vector<vector<int>>& mat, vector<long long >& dp) {\\n    //     if (idx == mat.size()-1) return mat[idx][0];\\n\\n    //     if (dp[idx] != -1) return dp[idx];\\n\\n    //     long long op1 = f(idx + 1, mat, dp);\\n\\n    //     long long op2 = mat[idx][0];\\n    //     int index = mat[idx][1]+1;\\n       \\n    //     if (idx+index<mat.size()) {\\n    //         op2 += f(idx+index , mat, dp);\\n    //     }\\n\\n    //     return dp[idx] = max(op1, op2);\\n    // }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long > dp(n, -1);\\n        dp[n-1]=questions[n-1][0];\\n\\n        for(int idx=n-2;idx>=0;idx--)\\n        {\\n              long long op1 = dp[idx+1];\\n\\n                long long op2 = questions[idx][0];\\n                int index = questions[idx][1]+1;\\n            \\n                if (idx+index<n) {\\n                    op2 += dp[idx+index];\\n                }\\n\\n                dp[idx] = max(op1, op2);\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // long long f(int idx, vector<vector<int>>& mat, vector<long long >& dp) {\\n    //     if (idx == mat.size()-1) return mat[idx][0];\\n\\n    //     if (dp[idx] != -1) return dp[idx];\\n\\n    //     long long op1 = f(idx + 1, mat, dp);\\n\\n    //     long long op2 = mat[idx][0];\\n    //     int index = mat[idx][1]+1;\\n       \\n    //     if (idx+index<mat.size()) {\\n    //         op2 += f(idx+index , mat, dp);\\n    //     }\\n\\n    //     return dp[idx] = max(op1, op2);\\n    // }\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long > dp(n, -1);\\n        dp[n-1]=questions[n-1][0];\\n\\n        for(int idx=n-2;idx>=0;idx--)\\n        {\\n              long long op1 = dp[idx+1];\\n\\n                long long op2 = questions[idx][0];\\n                int index = questions[idx][1]+1;\\n            \\n                if (idx+index<n) {\\n                    op2 += dp[idx+index];\\n                }\\n\\n                dp[idx] = max(op1, op2);\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515495,
                "title": "java-runtime-6-ms-beats-88-36-memory-95-4-mb-beats-74-7",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        \\n        long[] dp = new long[n + 1];\\n\\n        \\n        for (int i = n - 1; i >= 0; --i) {\\n            int points = questions[i][0];\\n            int jump = questions[i][1];\\n\\n            \\n            int nextQuestion = Math.min(jump + i + 1, n);\\n            long pointsFromThisQuestion = points + dp[nextQuestion];\\n            dp[i] = Math.max(pointsFromThisQuestion, dp[i + 1]);\\n        }\\n\\n       \\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        \\n        long[] dp = new long[n + 1];\\n\\n        \\n        for (int i = n - 1; i >= 0; --i) {\\n            int points = questions[i][0];\\n            int jump = questions[i][1];\\n\\n            \\n            int nextQuestion = Math.min(jump + i + 1, n);\\n            long pointsFromThisQuestion = points + dp[nextQuestion];\\n            dp[i] = Math.max(pointsFromThisQuestion, dp[i + 1]);\\n        }\\n\\n       \\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515353,
                "title": "easy-to-understand-simple-code-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    long long f(int ind , vector<vector<int>>&questions, vector<long long> &dp){\\n         int n = questions.size();\\n      \\n        if(ind >= n )return 0;\\n        if(dp[ind] != -1)return dp[ind];\\n        long long notPick = f(ind + 1 ,questions,dp); \\n        long long pick =  questions[ind][0] + f(ind + questions[ind][1]+1 ,questions,dp);\\n        return dp[ind]=  max(pick,notPick);\\n    }\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n       vector<long long> dp(n,-1);\\n        return f(0,questions,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    long long f(int ind , vector<vector<int>>&questions, vector<long long> &dp){\\n         int n = questions.size();\\n      \\n        if(ind >= n )return 0;\\n        if(dp[ind] != -1)return dp[ind];\\n        long long notPick = f(ind + 1 ,questions,dp); \\n        long long pick =  questions[ind][0] + f(ind + questions[ind][1]+1 ,questions,dp);\\n        return dp[ind]=  max(pick,notPick);\\n    }\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n       vector<long long> dp(n,-1);\\n        return f(0,questions,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515305,
                "title": "dp-0-1-knapsack-tabulation-fullexplanation",
                "content": "# Intuition\\nWe can pick the current question then what is the maximun score we get and if we not pick then again what maximun score we get, similar to 0/1 knapsack pattern.\\n\\n# Approach\\n1. Start from last \\'nth\\' to \\'0th\\' index and fill this dp index.\\n2. We have two choices at current index, pick or not pick, if we pick then we check after skipping the questions what maximum score we can get.\\n3. If we don\\'t pick the ith, then assign (i + 1)th dp index to current index.\\n4. Get maximum out of 2nd and 3rd option and assign to the current index.\\n5. Atlast find maximun value dp is holding, then return this.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& v) {\\n        int n = v.size();\\n        long long ans = LLONG_MIN;\\n        vector<long long> dp(n+1, 0);\\n        for(int i=n-1; i>=0; i--){\\n            long long p = 0;\\n            // If it is exceding the n, then we will not include it.\\n            if(i + v[i][1] + 1 <= n){\\n                p = dp[i + v[i][1] + 1];\\n            }\\n            dp[i] = max(p + v[i][0], dp[i+1]);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& v) {\\n        int n = v.size();\\n        long long ans = LLONG_MIN;\\n        vector<long long> dp(n+1, 0);\\n        for(int i=n-1; i>=0; i--){\\n            long long p = 0;\\n            // If it is exceding the n, then we will not include it.\\n            if(i + v[i][1] + 1 <= n){\\n                p = dp[i + v[i][1] + 1];\\n            }\\n            dp[i] = max(p + v[i][0], dp[i+1]);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515293,
                "title": "php",
                "content": "# Code\\n```\\nclass Solution {\\n    private int $n = 0;\\n\\n    private array $cache = [];\\n\\n    /**\\n     * @param int[][] $questions\\n     * @return int\\n     */\\n    public function mostPoints(array $questions): int {\\n        $this->n = count($questions);\\n\\n        return $this->mostPointsInternal($questions, 0);\\n    }\\n\\n    /**\\n     * @param int[][] $questions\\n     * @param int $i\\n     * @return int\\n     */\\n    private function mostPointsInternal(array $questions, int $i): int {\\n        if ($i >= $this->n) {\\n            return 0;\\n        }\\n\\n        if (array_key_exists($i, $this->cache)) {\\n            return $this->cache[$i];\\n        }\\n\\n        $skipCurrentQuestionPoints = $this->mostPointsInternal($questions, $i + 1);\\n\\n        $solveCurrentQuestionPoints = $questions[$i][0] + $this->mostPointsInternal($questions, $questions[$i][1] + $i + 1);\\n\\n        $this->cache[$i] = max($solveCurrentQuestionPoints, $skipCurrentQuestionPoints);\\n\\n        return $this->cache[$i];\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private int $n = 0;\\n\\n    private array $cache = [];\\n\\n    /**\\n     * @param int[][] $questions\\n     * @return int\\n     */\\n    public function mostPoints(array $questions): int {\\n        $this->n = count($questions);\\n\\n        return $this->mostPointsInternal($questions, 0);\\n    }\\n\\n    /**\\n     * @param int[][] $questions\\n     * @param int $i\\n     * @return int\\n     */\\n    private function mostPointsInternal(array $questions, int $i): int {\\n        if ($i >= $this->n) {\\n            return 0;\\n        }\\n\\n        if (array_key_exists($i, $this->cache)) {\\n            return $this->cache[$i];\\n        }\\n\\n        $skipCurrentQuestionPoints = $this->mostPointsInternal($questions, $i + 1);\\n\\n        $solveCurrentQuestionPoints = $questions[$i][0] + $this->mostPointsInternal($questions, $questions[$i][1] + $i + 1);\\n\\n        $this->cache[$i] = max($solveCurrentQuestionPoints, $skipCurrentQuestionPoints);\\n\\n        return $this->cache[$i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515263,
                "title": "c-basic-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long f(int ind, vector<vector<int>> &ques, vector<long long> &dp){\\n        if(ind>=ques.size()) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        long long nottake=0+f(ind+1,ques,dp);\\n        long long take=ques[ind][0]+f(ind+ques[ind][1]+1,ques,dp);\\n        return dp[ind]=max(take,nottake);\\n    }\\n    long long mostPoints(vector<vector<int>> &ques) {\\n        vector<long long> dp(ques.size(),-1);\\n        return f(0,ques,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long f(int ind, vector<vector<int>> &ques, vector<long long> &dp){\\n        if(ind>=ques.size()) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        long long nottake=0+f(ind+1,ques,dp);\\n        long long take=ques[ind][0]+f(ind+ques[ind][1]+1,ques,dp);\\n        return dp[ind]=max(take,nottake);\\n    }\\n    long long mostPoints(vector<vector<int>> &ques) {\\n        vector<long long> dp(ques.size(),-1);\\n        return f(0,ques,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515242,
                "title": "go-dp-recursive-memo",
                "content": "# Intuition\\nTry all posible answer using DP, skip already known answer with memo\\n\\n# Approach\\nthere are 2 posible answer in one index, first is get the point. and second is skip the point.\\n- if you **GET** the points then we will need to **skip** (**BrainPower** of index **+ 1**) and add the point to result.\\n- if you skip the points then we just get the result of **next index**\\n \\n \\nskip condition :\\n- an index of **memo** is **not empty**, then we will return the (**value + temp**) value\\n- **index** more than questions length return the **temp** value\\n\\n# Code\\n```\\nfunc mostPoints(questions [][]int) int64 {\\n    memo := make([]int64, len(questions))\\n    return mostPointsHelper(questions,0,0, memo)\\n}\\n\\nfunc mostPointsHelper(questions [][]int, index, temp int64, memo []int64)int64{\\n    if int(index) >= len(questions){\\n        return temp\\n    }\\n    if memo[index] != 0 {\\n        return memo[index]+temp\\n    }\\n\\n    skipResult := mostPointsHelper(questions,index+int64(1),temp,memo)\\n    getResult := mostPointsHelper(questions,index+int64(questions[index][1]+1),temp+int64(questions[index][0]),memo)\\n    result := max(skipResult, getResult)\\n    memo[index] = result\\n    return result\\n}\\n\\nfunc max(a, b int64)int64{\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mostPoints(questions [][]int) int64 {\\n    memo := make([]int64, len(questions))\\n    return mostPointsHelper(questions,0,0, memo)\\n}\\n\\nfunc mostPointsHelper(questions [][]int, index, temp int64, memo []int64)int64{\\n    if int(index) >= len(questions){\\n        return temp\\n    }\\n    if memo[index] != 0 {\\n        return memo[index]+temp\\n    }\\n\\n    skipResult := mostPointsHelper(questions,index+int64(1),temp,memo)\\n    getResult := mostPointsHelper(questions,index+int64(questions[index][1]+1),temp+int64(questions[index][0]),memo)\\n    result := max(skipResult, getResult)\\n    memo[index] = result\\n    return result\\n}\\n\\nfunc max(a, b int64)int64{\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515231,
                "title": "java-recursion-memoization-tabulation",
                "content": "Memoization (Not Accepted)  (:\\n```\\nclass Solution {\\n    long[] dp ;\\n    \\n    public long solve(int[][] questions, int ind){\\n        int n = questions.length;\\n        if(ind >= n)\\n            return 0;\\n        \\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        \\n        long ret = 0;\\n        for(int i = ind ; i <n; i++){\\n            long points = questions[i][0];\\n            int skip = questions[i][1];\\n            \\n            long inc = 0, dis = 0;\\n            inc+=solve(questions,i+skip+1)+points;\\n            dis+=solve(questions,i+1);\\n        \\n            ret = Math.max(ret, Math.max(inc, dis));\\n        }\\n        dp[ind] = Math.max(dp[ind],ret);\\n        return ret;\\n    }\\n    \\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long ans = 0;\\n        dp = new long[n+2];\\n        Arrays.fill(dp,-1);\\n        ans = Math.max(ans,solve(questions, 0));\\n        return ans;\\n    }\\n}\\n```\\n\\n\\nTabulation\\n\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        long ans = 0;\\n        int n = questions.length;\\n        long[] dp = new long[n+2];\\n        dp[n] = dp[n+1] = 0;\\n        for(int i = n -1; i >= 0;i--){\\n            long points = questions[i][0];\\n            int skip = questions[i][1];\\n            \\n            long inc = points, dis = 0;\\n            if(i+skip+1 < dp.length)\\n            inc+=dp[i+skip+1];\\n            dis+=dp[i+1];\\n            dp[i] = Math.max(inc,dis);\\n            ans = Math.max(dp[i], ans);\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    long[] dp ;\\n    \\n    public long solve(int[][] questions, int ind){\\n        int n = questions.length;\\n        if(ind >= n)\\n            return 0;\\n        \\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        \\n        long ret = 0;\\n        for(int i = ind ; i <n; i++){\\n            long points = questions[i][0];\\n            int skip = questions[i][1];\\n            \\n            long inc = 0, dis = 0;\\n            inc+=solve(questions,i+skip+1)+points;\\n            dis+=solve(questions,i+1);\\n        \\n            ret = Math.max(ret, Math.max(inc, dis));\\n        }\\n        dp[ind] = Math.max(dp[ind],ret);\\n        return ret;\\n    }\\n    \\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long ans = 0;\\n        dp = new long[n+2];\\n        Arrays.fill(dp,-1);\\n        ans = Math.max(ans,solve(questions, 0));\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        long ans = 0;\\n        int n = questions.length;\\n        long[] dp = new long[n+2];\\n        dp[n] = dp[n+1] = 0;\\n        for(int i = n -1; i >= 0;i--){\\n            long points = questions[i][0];\\n            int skip = questions[i][1];\\n            \\n            long inc = points, dis = 0;\\n            if(i+skip+1 < dp.length)\\n            inc+=dp[i+skip+1];\\n            dis+=dp[i+1];\\n            dp[i] = Math.max(inc,dis);\\n            ans = Math.max(dp[i], ans);\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515153,
                "title": "c-recursive-memoisation-tabulation-easy",
                "content": "# **Recursion - TLE**\\n```\\n// RECURSION -TLE\\nclass Solution {\\npublic:\\n    long long recur(vector<vector<int>> &q, int i)\\n    {\\n        if(i >= q.size())\\n            return 0;\\n        long long include = q[i][0] + recur(q, i + q[i][1] + 1);\\n        long long exclude = recur(q, i + 1);\\n        return max(include, exclude);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        return recur(questions, 0);\\n    }\\n};\\n```\\n\\n# **Memoisation - Accepted**\\n```\\n// MEMOISATION\\nclass Solution {\\npublic:\\n    long long memo(vector<vector<int>> &q, vector<long long>&dp, int i)\\n    {\\n        if(i >= q.size())\\n            return 0;\\n        if(dp[i] != -1)\\n            return dp[i];\\n        long long include = q[i][0] + memo(q, dp,  i + q[i][1] + 1);\\n        long long exclude = memo(q, dp, i + 1);\\n        return dp[i] = max(include, exclude);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long> dp(questions.size(), -1);\\n        return memo(questions,dp, 0);\\n    }\\n};\\n```\\n# **Tabulation - Accepted**\\n```\\n// TABULATION\\nclass Solution {\\npublic:\\n    long long tab(vector<vector<int>> &q)\\n    {\\n        vector<long long> dp(q.size() + 1, 0);\\n        long long inc = 0, exc = 0, ans = 0;\\n        \\n        for(int i = q.size() - 1; i >= 0; i--)\\n        {\\n            inc = 0, exc = 0;\\n            if(i + 1 + q[i][1] < q.size())\\n                inc = dp[i + 1 + q[i][1]];\\n            \\n            dp[i] = max(inc + q[i][0], dp[i + 1]);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        return tab(questions);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// RECURSION -TLE\\nclass Solution {\\npublic:\\n    long long recur(vector<vector<int>> &q, int i)\\n    {\\n        if(i >= q.size())\\n            return 0;\\n        long long include = q[i][0] + recur(q, i + q[i][1] + 1);\\n        long long exclude = recur(q, i + 1);\\n        return max(include, exclude);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        return recur(questions, 0);\\n    }\\n};\\n```\n```\\n// MEMOISATION\\nclass Solution {\\npublic:\\n    long long memo(vector<vector<int>> &q, vector<long long>&dp, int i)\\n    {\\n        if(i >= q.size())\\n            return 0;\\n        if(dp[i] != -1)\\n            return dp[i];\\n        long long include = q[i][0] + memo(q, dp,  i + q[i][1] + 1);\\n        long long exclude = memo(q, dp, i + 1);\\n        return dp[i] = max(include, exclude);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long> dp(questions.size(), -1);\\n        return memo(questions,dp, 0);\\n    }\\n};\\n```\n```\\n// TABULATION\\nclass Solution {\\npublic:\\n    long long tab(vector<vector<int>> &q)\\n    {\\n        vector<long long> dp(q.size() + 1, 0);\\n        long long inc = 0, exc = 0, ans = 0;\\n        \\n        for(int i = q.size() - 1; i >= 0; i--)\\n        {\\n            inc = 0, exc = 0;\\n            if(i + 1 + q[i][1] < q.size())\\n                inc = dp[i + 1 + q[i][1]];\\n            \\n            dp[i] = max(inc + q[i][0], dp[i + 1]);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        return tab(questions);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514959,
                "title": "easiest-c-solution-striver-pick-not-pick-approach-memoaization-well-commented-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust simple pick not pick problem , increase the index to index+brainpower+1, and just take max of pick and not pick.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long lol(int ind, int n, vector<vector<int>> &questions, vector<long long> &dp){\\n        //base case\\n        if(ind>=n) return 0;\\n        //dp table check\\n        if(dp[ind]!=-1) return dp[ind];\\n        //if picked , new index will become ind+questions[ind][0]+1\\n        //and pointss= questions[ind][0] will be given\\n        long long pick=questions[ind][0]+lol(ind+questions[ind][1]+1,n,questions,dp);\\n        //not pick , just move to next question i.e ind+1\\n        long long notpick=lol(ind+1,n,questions,dp);\\n        //return max of the two ways\\n        return dp[ind]=max(pick,notpick);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        vector<long long> dp(n+1,-1);\\n        return lol(0,n,questions,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long lol(int ind, int n, vector<vector<int>> &questions, vector<long long> &dp){\\n        //base case\\n        if(ind>=n) return 0;\\n        //dp table check\\n        if(dp[ind]!=-1) return dp[ind];\\n        //if picked , new index will become ind+questions[ind][0]+1\\n        //and pointss= questions[ind][0] will be given\\n        long long pick=questions[ind][0]+lol(ind+questions[ind][1]+1,n,questions,dp);\\n        //not pick , just move to next question i.e ind+1\\n        long long notpick=lol(ind+1,n,questions,dp);\\n        //return max of the two ways\\n        return dp[ind]=max(pick,notpick);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        vector<long long> dp(n+1,-1);\\n        return lol(0,n,questions,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514891,
                "title": "c-beginner-friendly-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long f(vector<vector<int>>& q,int idx,int n,vector<long long>& dp){\\n        if(idx>=n){\\n            return 0;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        long long pick=0;\\n        pick=q[idx][0]+f(q,idx+q[idx][1]+1,n,dp);\\n        long long notPick=0;\\n        notPick=f(q,idx+1,n,dp);\\n        return dp[idx]=max(pick,notPick);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        vector<long long> dp(n+1,-1);\\n        return f(questions,0,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long f(vector<vector<int>>& q,int idx,int n,vector<long long>& dp){\\n        if(idx>=n){\\n            return 0;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        long long pick=0;\\n        pick=q[idx][0]+f(q,idx+q[idx][1]+1,n,dp);\\n        long long notPick=0;\\n        notPick=f(q,idx+1,n,dp);\\n        return dp[idx]=max(pick,notPick);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        vector<long long> dp(n+1,-1);\\n        return f(questions,0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514860,
                "title": "memoization",
                "content": "# Intuition\\nStraight forward pick-nonPick problem, either you \\n1. stay at ***index* *i*** and choose the question and move to ***question[i][1] + 1th question***\\n2. or you don\\'t pick ***value of index i*** and ***move to next question***\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<long long int>dp;\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        dp.resize(questions.size(),-1);\\n        return memo(questions,0);\\n    }\\n    long long memo(vector<vector<int>>& questions, int i){\\n        if(i >= questions.size()) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        long long int pick = 0, nonPick = 0;\\n        pick = questions[i][0] + memo(questions,i+questions[i][1]+1);\\n        nonPick = memo(questions,i+1);\\n        return dp[i] = max(pick,nonPick); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<long long int>dp;\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        dp.resize(questions.size(),-1);\\n        return memo(questions,0);\\n    }\\n    long long memo(vector<vector<int>>& questions, int i){\\n        if(i >= questions.size()) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        long long int pick = 0, nonPick = 0;\\n        pick = questions[i][0] + memo(questions,i+questions[i][1]+1);\\n        nonPick = memo(questions,i+1);\\n        return dp[i] = max(pick,nonPick); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514842,
                "title": "c-very-easy-solution-with-detailed-explaination",
                "content": "# Approach\\nThe main idea is to consider two cases for each question: either the question is answered or it is not. The maximum number of points that can be obtained by answering a set of questions is the maximum of the two cases.\\n\\nThe function dp takes as input a vector of vectors v representing the questions, an index i, and a vector ch to store the computed results. It returns the maximum number of points that can be obtained by answering the questions starting from index i.\\n\\nIf i is greater than or equal to the size of v, then there are no more questions to answer, so the function returns 0.\\n\\nIf the result for i has already been computed and stored in ch, then the function returns the stored result.\\n\\nOtherwise, the function computes the result by considering the two cases. The variable take represents the case where the question at index i is answered, so the function is called recursively with i+1+v[i][1] as the new index, where v[i][1] is the time required to answer the question. The result is added to the score for the current question v[i][0]. The variable notake represents the case where the question is not answered, so the function is called recursively with i+1 as the new index. The maximum of take and notake is returned, and the result is stored in ch[i] for future use.\\n\\nThe function mostPoints takes as input a vector of vectors questions representing the questions, and it creates a vector ch with the same size as questions to store the computed results. It calls dp with questions, starting index 0, and the vector ch, and returns the result.\\n\\n# Complexity\\n- Time complexity:\\n\\n**The time complexity of the code is O(n^2)**, where n is the number of questions. This is because the function dp is called once for each question, and each call to dp can make up to n-1 recursive calls (in the worst case), resulting in a total of O(n^2) function calls. Each function call requires constant time operations, so the overall time complexity is O(n^2).\\n\\n\\n- Space complexity:\\n\\n**The space complexity of the code is O(n)**, where n is the number of questions. This is because the function dp uses a vector ch to store the computed results for each index i. The size of ch is n, and each element of ch requires constant space, so the overall space complexity is O(n).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long dp(vector<vector<int>> & v,int i,vector<long long>& ch){\\n        if(i>=v.size()){\\n            return 0;\\n        }\\n        if(ch[i]!=-1){\\n            return ch[i];\\n        }\\n        long long take=dp(v,i+1+v[i][1],ch)+v[i][0];\\n        long long notake=dp(v,i+1,ch);\\n        return ch[i]=max(take,notake);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long> ch(questions.size(),-1);\\n        return dp(questions,0,ch);\\n    }\\n};\\n```\\n**Please do consider upvoting if you liked the solution :)**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp(vector<vector<int>> & v,int i,vector<long long>& ch){\\n        if(i>=v.size()){\\n            return 0;\\n        }\\n        if(ch[i]!=-1){\\n            return ch[i];\\n        }\\n        long long take=dp(v,i+1+v[i][1],ch)+v[i][0];\\n        long long notake=dp(v,i+1,ch);\\n        return ch[i]=max(take,notake);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        vector<long long> ch(questions.size(),-1);\\n        return dp(questions,0,ch);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514831,
                "title": "cpp-solution-recursive-memoization-tabulation-all-solutions-easy-to-understand",
                "content": "# Intuition\\nFor every index , we have got a choice either to take it or not to take it. This makes me to try every possible combination .I will be moving from recursive approach to tabulation.\\n\\n# Approach\\n<!-- Recursive Approach -->\\nfor every possible index i have two choices i.e take and not take\\n1. if I an taking that index, means adding those points and moving to index+questions[index][1]+1 th index ,as stated in question we can not take the next questions[index][1]+1 index\\n   therefore \\n    ****take=questions[index][0]+f(index+questions[index][1]+1)****\\n2. if i not taking that index, then I can simply move to the next index\\n    ****nottake=f(index+1)****\\n\\n\\n# Complexity\\n- Time complexity:\\n1. for recursive solution: time complexity: O(2^n) as we have two choices for every index;\\n2. for tabulation time complexity:O(n)\\n\\n# Code\\n\\n<!-- Recursive -->\\n```\\nclass Solution {\\npublic:\\n    <!-- Recursive code -->\\n    long long f(int ind,vector<vector<int>>& questions){\\n        if(ind>=questions.size()) return 0;\\n\\n        \\n        long long take=questions[ind][0]+f(ind+questions[ind][1]+1,questions);\\n        long long nottake=f(ind+1,questions);\\n        return max(take,nottake);\\n\\n    }\\n\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n       \\n        return f(0,questions);\\n    }\\n\\n\\n};\\n\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    <!-- memoization  -->\\n    long long f(int ind,vector<vector<int>>& questions,vector<long long>&dp){\\n        if(ind>=questions.size()) return 0;\\n\\n        if(dp[ind]!=-1) return dp[ind];\\n        long long take=questions[ind][0]+f(ind+questions[ind][1]+1,questions,dp);\\n        long long nottake=f(ind+1,questions,dp);\\n        return dp[ind]=max(take,nottake);\\n\\n    }\\n\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        \\n        vector<long long>dp(n,-1);\\n        return f(0,questions,dp);\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    <!-- Tabulation -->\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        \\n        vector<long long>dp(n,0);\\n\\n        for(int i=n-1;i>=0;i--){\\n            long long take=questions[i][0];\\n            int next=i+questions[i][1]+1;\\n            if(next<n){\\n                take+=dp[next];\\n            }\\n\\n            long long nottake=(i==n-1)?0:dp[i+1];\\n            dp[i]=max(take,nottake);\\n        }\\n       \\n        return dp[0];\\n       \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    <!-- Recursive code -->\\n    long long f(int ind,vector<vector<int>>& questions){\\n        if(ind>=questions.size()) return 0;\\n\\n        \\n        long long take=questions[ind][0]+f(ind+questions[ind][1]+1,questions);\\n        long long nottake=f(ind+1,questions);\\n        return max(take,nottake);\\n\\n    }\\n\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n       \\n        return f(0,questions);\\n    }\\n\\n\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    <!-- memoization  -->\\n    long long f(int ind,vector<vector<int>>& questions,vector<long long>&dp){\\n        if(ind>=questions.size()) return 0;\\n\\n        if(dp[ind]!=-1) return dp[ind];\\n        long long take=questions[ind][0]+f(ind+questions[ind][1]+1,questions,dp);\\n        long long nottake=f(ind+1,questions,dp);\\n        return dp[ind]=max(take,nottake);\\n\\n    }\\n\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        \\n        vector<long long>dp(n,-1);\\n        return f(0,questions,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    <!-- Tabulation -->\\n\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        \\n        vector<long long>dp(n,0);\\n\\n        for(int i=n-1;i>=0;i--){\\n            long long take=questions[i][0];\\n            int next=i+questions[i][1]+1;\\n            if(next<n){\\n                take+=dp[next];\\n            }\\n\\n            long long nottake=(i==n-1)?0:dp[i+1];\\n            dp[i]=max(take,nottake);\\n        }\\n       \\n        return dp[0];\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514786,
                "title": "easy-c-solution-for-dp-both-tabulation-and-recursion-codes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve(vector<vector<int>>& q,int index){\\n        if(index>=q.size()) return 0;\\n        return max(q[index][0]+solve(q,index+q[index][1]+1),solve(q,index+1));\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long> dp(n+1,0);\\n        for(int i = n-1;i>=0;i--){\\n            long long x = questions[i][0];\\n            if(i+questions[i][1]+1<n) x+=dp[i+questions[i][1]+1];\\n            if(x>dp[i+1]) dp[i] = x;\\n            else dp[i] = dp[i+1];\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve(vector<vector<int>>& q,int index){\\n        if(index>=q.size()) return 0;\\n        return max(q[index][0]+solve(q,index+q[index][1]+1),solve(q,index+1));\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n = questions.size();\\n        vector<long long> dp(n+1,0);\\n        for(int i = n-1;i>=0;i--){\\n            long long x = questions[i][0];\\n            if(i+questions[i][1]+1<n) x+=dp[i+questions[i][1]+1];\\n            if(x>dp[i+1]) dp[i] = x;\\n            else dp[i] = dp[i+1];\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514671,
                "title": "java-tabulation-memoization-beats-90",
                "content": "``` java []\\n// Tabulation\\n// TC -> O(n)\\n// SC -> O(n)\\n\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long[] dp = new long[n+1];\\n        for (int i = n - 1; i >= 0; i--) {\\n            long pick = questions[i][0] + ((i + questions[i][1] + 1) < n ? dp[i + questions[i][1] + 1] : 0);\\n            long notPick = dp[i + 1];\\n            dp[i] = Math.max(pick, notPick);\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\n\\n``` java []\\n// Memoization \\n// TC -> O(n)\\n// SC -> O(n) + Recursive stack space\\n\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        Long[] dp = new Long[questions.length];\\n        return solve(dp,questions,0);\\n    }\\n\\n    private long solve(Long[] dp, int[][] questions, int i){\\n        if(i>=questions.length){\\n            return 0;\\n        }\\n        if(dp[i]!=null){\\n            return dp[i];\\n        }\\n        long pick = questions[i][0] + solve(dp,questions,i+questions[i][1]+1);\\n        long notPick = solve(dp,questions,i+1);\\n\\n        return dp[i] = Math.max(pick,notPick);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "``` java []\\n// Tabulation\\n// TC -> O(n)\\n// SC -> O(n)\\n\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long[] dp = new long[n+1];\\n        for (int i = n - 1; i >= 0; i--) {\\n            long pick = questions[i][0] + ((i + questions[i][1] + 1) < n ? dp[i + questions[i][1] + 1] : 0);\\n            long notPick = dp[i + 1];\\n            dp[i] = Math.max(pick, notPick);\\n        }\\n        return dp[0];\\n    }\\n}\\n```\n``` java []\\n// Memoization \\n// TC -> O(n)\\n// SC -> O(n) + Recursive stack space\\n\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        Long[] dp = new Long[questions.length];\\n        return solve(dp,questions,0);\\n    }\\n\\n    private long solve(Long[] dp, int[][] questions, int i){\\n        if(i>=questions.length){\\n            return 0;\\n        }\\n        if(dp[i]!=null){\\n            return dp[i];\\n        }\\n        long pick = questions[i][0] + solve(dp,questions,i+questions[i][1]+1);\\n        long notPick = solve(dp,questions,i+1);\\n\\n        return dp[i] = Math.max(pick,notPick);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514646,
                "title": "easy-to-understand-solution-with-dp",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n*n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func mostPoints(_ questions: [[Int]]) -> Int {\\n        var dp = [Int](repeating: 0, count: questions.count)\\n        var maxm = 0\\n        for i in 0...questions.count-1 {\\n            var k = i + questions[i][1]+1\\n            dp[i] += questions[i][0]\\n             maxm = max(dp[i],maxm)\\n            if k < questions.count {\\n                for j in 0...questions[k][1] {\\n                    if j + k > questions.count-1 {\\n                        break\\n                    }\\n                    dp[j+k] = max(dp[j+k], dp[i] )\\n                }\\n            }\\n           \\n        }\\n        return maxm\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func mostPoints(_ questions: [[Int]]) -> Int {\\n        var dp = [Int](repeating: 0, count: questions.count)\\n        var maxm = 0\\n        for i in 0...questions.count-1 {\\n            var k = i + questions[i][1]+1\\n            dp[i] += questions[i][0]\\n             maxm = max(dp[i],maxm)\\n            if k < questions.count {\\n                for j in 0...questions[k][1] {\\n                    if j + k > questions.count-1 {\\n                        break\\n                    }\\n                    dp[j+k] = max(dp[j+k], dp[i] )\\n                }\\n            }\\n           \\n        }\\n        return maxm\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514604,
                "title": "sort-solutions-python-code-upvoted",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code SORT SOLUTIONS \\uD83D\\uDC4DUPVOTED\\uD83D\\uDD25\\n```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        res=[0]*(len(questions)+1)\\n        for i in range(len(questions)-1,-1,-1):\\n            point,solve=questions[i][0],questions[i][1]\\n            res[i]=max(point+res[min(solve+i+1,len(questions))],res[i+1])\\n        return res[0]\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        res=[0]*(len(questions)+1)\\n        for i in range(len(questions)-1,-1,-1):\\n            point,solve=questions[i][0],questions[i][1]\\n            res[i]=max(point+res[min(solve+i+1,len(questions))],res[i+1])\\n        return res[0]\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514598,
                "title": "tabulation-and-memoization-solutions-available",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis problem is a modified version of take- not take problem...\\nBelow code is easy to understand\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n        O(N) -- only trying N ways and sotring it in dp\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N+N) -- recursive stack space and storing previous maximums in dp\\n\\n# Memoization Code\\n```\\nclass Solution:\\n    def mostPoints(self, q: List[List[int]]) -> int:\\n        n=len(q)\\n        #memoization\\n        dp=[-1]*n\\n        def helper(ind):\\n            #when we reach end we will include definitely\\n            if ind==(n-1):\\n                return q[-1][0]\\n            #if out of bounds occured\\n            if ind>=n:\\n                return 0\\n            #if solution previously computed\\n            if dp[ind]!=-1:\\n                return dp[ind]\\n            #if not consider current element move index to next position\\n            nottake=helper(ind+1)\\n            #if we take current element we have move our index to next q[ind][1](brainpower) place\\n            take=q[ind][0]+helper(ind+q[ind][1]+1)\\n            #store maximum posible value\\n            dp[ind]=max(take,nottake)\\n            return dp[ind]\\n        return helper(0)\\n```\\nTo reduce the recursive space we can use tabulation\\n\\nAbove memoization code is converted to tabulation,\\n\\nbase case : dp[-1]=q[-1]*[0] (storing last element as it is, as last element does not effect next elements)\\n\\ncondition : if we can get current and previous max possible value we will store in dp[i] else skiping case that is dp[i]=d[i+1]\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n        O(N) -- storing previous maximums\\n# Tabulation Code\\n```\\nclass Solution:\\n    def mostPoints(self, q: List[List[int]]) -> int:\\n        n=len(q)\\n        dp=[-1]*n\\n        dp[-1]=q[-1][0]\\n        for i in range(n-2,-1,-1):\\n            dp[i]=max(dp[i+1],q[i][0])\\n            if (i+q[i][1]+1)<n:\\n                dp[i]=max(dp[i],q[i][0]+dp[i+q[i][1]+1])\\n        return dp[0]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def mostPoints(self, q: List[List[int]]) -> int:\\n        n=len(q)\\n        #memoization\\n        dp=[-1]*n\\n        def helper(ind):\\n            #when we reach end we will include definitely\\n            if ind==(n-1):\\n                return q[-1][0]\\n            #if out of bounds occured\\n            if ind>=n:\\n                return 0\\n            #if solution previously computed\\n            if dp[ind]!=-1:\\n                return dp[ind]\\n            #if not consider current element move index to next position\\n            nottake=helper(ind+1)\\n            #if we take current element we have move our index to next q[ind][1](brainpower) place\\n            take=q[ind][0]+helper(ind+q[ind][1]+1)\\n            #store maximum posible value\\n            dp[ind]=max(take,nottake)\\n            return dp[ind]\\n        return helper(0)\\n```\n```\\nclass Solution:\\n    def mostPoints(self, q: List[List[int]]) -> int:\\n        n=len(q)\\n        dp=[-1]*n\\n        dp[-1]=q[-1][0]\\n        for i in range(n-2,-1,-1):\\n            dp[i]=max(dp[i+1],q[i][0])\\n            if (i+q[i][1]+1)<n:\\n                dp[i]=max(dp[i],q[i][0]+dp[i+q[i][1]+1])\\n        return dp[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514564,
                "title": "c-top-down-dp-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int size=questions.size();\\n        vector<long long> dp(200001,0);\\n        for(int i=0;i<size;i++) {\\n            if(i!=0) {\\n                dp[i]=max(dp[i],dp[i-1]);\\n            }\\n            dp[questions[i][1]+i+1]=max(dp[questions[i][1]+i+1],dp[i]+questions[i][0]);\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int size=questions.size();\\n        vector<long long> dp(200001,0);\\n        for(int i=0;i<size;i++) {\\n            if(i!=0) {\\n                dp[i]=max(dp[i],dp[i-1]);\\n            }\\n            dp[questions[i][1]+i+1]=max(dp[questions[i][1]+i+1],dp[i]+questions[i][0]);\\n        }\\n        return *max_element(dp.begin(),dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514490,
                "title": "rust-two-dp-solutions",
                "content": "\\n```\\nimpl Solution {\\n    pub fn most_points(questions: Vec<Vec<i32>>) -> i64 {\\n        let n = questions.len();\\n        let mut f = vec![0 as i64; n + 1];\\n\\n        for i in (0..n).rev().step_by(1) {\\n            let (points, brainpower) = (questions[i][0] as i64, questions[i][1] as usize);\\n            let j = (i + brainpower + 1).min(n);\\n\\n            f[i] = f[i + 1].max(f[j] + points);\\n        }\\n\\n        f[0]\\n    }\\n}\\n```\\n\\n```\\nimpl Solution {\\n    pub fn most_points(questions: Vec<Vec<i32>>) -> i64 {\\n        let n = questions.len();\\n        let mut f = vec![0 as i64; n + 1];\\n\\n        for i in 0..n {\\n            f[i + 1] = f[i + 1].max(f[i]);\\n            let (points, brainpower) = (questions[i][0] as i64, questions[i][1] as i64);\\n            let j = (i + brainpower as usize + 1).min(n);\\n\\n            f[j] = f[j].max(f[i] + points);\\n        }\\n\\n        f[n]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn most_points(questions: Vec<Vec<i32>>) -> i64 {\\n        let n = questions.len();\\n        let mut f = vec![0 as i64; n + 1];\\n\\n        for i in (0..n).rev().step_by(1) {\\n            let (points, brainpower) = (questions[i][0] as i64, questions[i][1] as usize);\\n            let j = (i + brainpower + 1).min(n);\\n\\n            f[i] = f[i + 1].max(f[j] + points);\\n        }\\n\\n        f[0]\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn most_points(questions: Vec<Vec<i32>>) -> i64 {\\n        let n = questions.len();\\n        let mut f = vec![0 as i64; n + 1];\\n\\n        for i in 0..n {\\n            f[i + 1] = f[i + 1].max(f[i]);\\n            let (points, brainpower) = (questions[i][0] as i64, questions[i][1] as i64);\\n            let j = (i + brainpower as usize + 1).min(n);\\n\\n            f[j] = f[j].max(f[i] + points);\\n        }\\n\\n        f[n]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514488,
                "title": "2140-solving-questions-with-brainpower-java",
                "content": "```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        long dp[]=new long[questions.length+1];\\n        long ans=0;\\n        for(int i=questions.length-1;i>=0;i--)\\n        {\\n           int  pos=questions[i][1]+i+1;\\n            if(questions.length<=pos)\\n                dp[i]=questions[i][0];\\n            else\\n                dp[i]=questions[i][0]+dp[pos];\\n            ans=Math.max(ans,dp[i]);\\n            dp[i]=Math.max(dp[i],dp[i+1]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        long dp[]=new long[questions.length+1];\\n        long ans=0;\\n        for(int i=questions.length-1;i>=0;i--)\\n        {\\n           int  pos=questions[i][1]+i+1;\\n            if(questions.length<=pos)\\n                dp[i]=questions[i][0];\\n            else\\n                dp[i]=questions[i][0]+dp[pos];\\n            ans=Math.max(ans,dp[i]);\\n            dp[i]=Math.max(dp[i],dp[i+1]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514410,
                "title": "c-dp-faster-easy-to-understand",
                "content": "* ***DP***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    long long recur(vector<vector<int>>& arr, int n)\\n    {\\n        // declare a dp array\\n        \\n        vector<long long> dp(n, 0);\\n        \\n        // fill the dp array according to condition\\n        \\n        dp[n-1] = arr[n-1][0];\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            long long points = arr[i][0];\\n            \\n            int next = arr[i][1] + 1;\\n            \\n            if(i + arr[i][1] + 1 < n)\\n            {\\n                dp[i] = max((points + dp[i + next]), dp[i+1]);\\n            }\\n            \\n            else\\n            {\\n                dp[i] = max(points, dp[i+1]);\\n            }\\n        }\\n        \\n        return dp[0];\\n        \\n    }\\n    \\n    long long mostPoints(vector<vector<int>>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        return recur(arr, n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    long long recur(vector<vector<int>>& arr, int n)\\n    {\\n        // declare a dp array\\n        \\n        vector<long long> dp(n, 0);\\n        \\n        // fill the dp array according to condition\\n        \\n        dp[n-1] = arr[n-1][0];\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            long long points = arr[i][0];\\n            \\n            int next = arr[i][1] + 1;\\n            \\n            if(i + arr[i][1] + 1 < n)\\n            {\\n                dp[i] = max((points + dp[i + next]), dp[i+1]);\\n            }\\n            \\n            else\\n            {\\n                dp[i] = max(points, dp[i+1]);\\n            }\\n        }\\n        \\n        return dp[0];\\n        \\n    }\\n    \\n    long long mostPoints(vector<vector<int>>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        return recur(arr, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514395,
                "title": "dp-simple-take-and-not-take-strategy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n  because of memoisation every idx is executed once \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    long long func(int idx, vector<vector<int>>& questions,int n,vector<long long> &dp){\\n            if(idx>=n) return 0;\\n            if(dp[idx]!=-1) return dp[idx];\\n        long long take=0,not_take=0 ;\\n            //take\\n            take=questions[idx][0]+func(idx+questions[idx][1]+1,questions,n,dp);\\n\\n            //not take \\n            not_take=func(idx+1,questions,n,dp);\\n\\n            return dp[idx]= max(take,not_take);\\n    }\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n         vector<long long> dp(questions.size()+1,-1);\\n        return func(0,questions,questions.size(),dp);\\n    }\\n};\\n\\n\\n//Please upvote if this help you \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    long long func(int idx, vector<vector<int>>& questions,int n,vector<long long> &dp){\\n            if(idx>=n) return 0;\\n            if(dp[idx]!=-1) return dp[idx];\\n        long long take=0,not_take=0 ;\\n            //take\\n            take=questions[idx][0]+func(idx+questions[idx][1]+1,questions,n,dp);\\n\\n            //not take \\n            not_take=func(idx+1,questions,n,dp);\\n\\n            return dp[idx]= max(take,not_take);\\n    }\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n         vector<long long> dp(questions.size()+1,-1);\\n        return func(0,questions,questions.size(),dp);\\n    }\\n};\\n\\n\\n//Please upvote if this help you \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514375,
                "title": "golang-dp",
                "content": "# Code\\n```\\nfunc max(a, b int64) int64 {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc mostPoints(questions [][]int) int64 {\\n    var n int = len(questions)\\n    DP := make([]int64, n)\\n    DP[n - 1] = int64(questions[n - 1][0])\\n    for i := n - 2; i >= 0; i-- {\\n        next := i + 1 + questions[i][1]\\n        DP[i] = max(DP[i + 1], int64(questions[i][0]))\\n        if next < n {\\n            DP[i] = max(DP[i + 1], int64(questions[i][0]) + DP[next])\\n        } \\n    }\\n    return DP[0];\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\nfunc max(a, b int64) int64 {\\n    if a > b {return a}\\n    return b\\n}\\n\\nfunc mostPoints(questions [][]int) int64 {\\n    var n int = len(questions)\\n    DP := make([]int64, n)\\n    DP[n - 1] = int64(questions[n - 1][0])\\n    for i := n - 2; i >= 0; i-- {\\n        next := i + 1 + questions[i][1]\\n        DP[i] = max(DP[i + 1], int64(questions[i][0]))\\n        if next < n {\\n            DP[i] = max(DP[i + 1], int64(questions[i][0]) + DP[next])\\n        } \\n    }\\n    return DP[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3514363,
                "title": "python-from-recursive-to-iterative-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        memo = [-1] * len(questions)\\n        def dp(i):\\n            if i >= len(questions):\\n                return 0\\n            \\n            if memo[i] != -1:\\n                return memo[i]\\n\\n            # skip i th question and go to next \\n            skip = dp(i+1) \\n            # solve i th question and go to next available question\\n            solve = questions[i][0] + dp(i+questions[i][1]+1) \\n\\n            memo[i] = max(skip, solve)\\n            return memo[i]\\n        \\n        return dp(0)\\n```\\n```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        dp = [-1] * len(questions)\\n        dp[-1] = questions[-1][0]\\n        for i in range(len(questions)-2, -1, -1):\\n            skip = dp[i+1]\\n            solve = questions[i][0] + (dp[i+1+questions[i][1]] if i+1+questions[i][1] < len(questions) else 0)\\n            dp[i] = max(dp[i], skip, solve)\\n        return dp[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        memo = [-1] * len(questions)\\n        def dp(i):\\n            if i >= len(questions):\\n                return 0\\n            \\n            if memo[i] != -1:\\n                return memo[i]\\n\\n            # skip i th question and go to next \\n            skip = dp(i+1) \\n            # solve i th question and go to next available question\\n            solve = questions[i][0] + dp(i+questions[i][1]+1) \\n\\n            memo[i] = max(skip, solve)\\n            return memo[i]\\n        \\n        return dp(0)\\n```\n```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        dp = [-1] * len(questions)\\n        dp[-1] = questions[-1][0]\\n        for i in range(len(questions)-2, -1, -1):\\n            skip = dp[i+1]\\n            solve = questions[i][0] + (dp[i+1+questions[i][1]] if i+1+questions[i][1] < len(questions) else 0)\\n            dp[i] = max(dp[i], skip, solve)\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514243,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\n//Memoisation\\nclass Solution {\\npublic:\\n    vector<long long> dp;\\n    long long fun(int idx,int n,vector<vector<int>>& questions){\\n        if(idx>=n) return 0;\\n        if(dp[idx] != -1) return dp[idx];\\n        int points=questions[idx][0];\\n        int skip=questions[idx][1];\\n        long long pick=points+fun(idx+1+skip,n,questions);\\n        long long notpick=fun(idx+1,n,questions);\\n        return dp[idx]=max(pick,notpick);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        dp=vector<long long>(n,-1);\\n        return fun(0,n,questions);\\n    }\\n};\\n```\\n```\\n//Tabulation\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        vector<long long> dp(n+1,0);\\n        for(int idx=n-1;idx>=0;idx--){\\n            int points=questions[idx][0];\\n            int skip=questions[idx][1];\\n            long long pick=points+(idx+1+skip>=n?0:dp[idx+1+skip]);\\n            long long notpick=dp[idx+1];\\n            dp[idx]=max(pick,notpick);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//Memoisation\\nclass Solution {\\npublic:\\n    vector<long long> dp;\\n    long long fun(int idx,int n,vector<vector<int>>& questions){\\n        if(idx>=n) return 0;\\n        if(dp[idx] != -1) return dp[idx];\\n        int points=questions[idx][0];\\n        int skip=questions[idx][1];\\n        long long pick=points+fun(idx+1+skip,n,questions);\\n        long long notpick=fun(idx+1,n,questions);\\n        return dp[idx]=max(pick,notpick);\\n    }\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        dp=vector<long long>(n,-1);\\n        return fun(0,n,questions);\\n    }\\n};\\n```\n```\\n//Tabulation\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        int n=questions.size();\\n        vector<long long> dp(n+1,0);\\n        for(int idx=n-1;idx>=0;idx--){\\n            int points=questions[idx][0];\\n            int skip=questions[idx][1];\\n            long long pick=points+(idx+1+skip>=n?0:dp[idx+1+skip]);\\n            long long notpick=dp[idx+1];\\n            dp[idx]=max(pick,notpick);\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514237,
                "title": "java-2ms-100-useless-stupid-code-makes-java-run-50-faster",
                "content": "**Useless loop:**  The following two code examples are identical except for one line of useless code that is commented out in the second slower example.  The useless code simply loops for 50_000 iterations of doing nothing, but having this useless looping makes the code run 50% faster, reducing runtime from 4ms to 2ms in August 2023.\\n\\nMy guess as to why the code runs faster with the useless do-nothing loop, is that the loop for 50_000 iterations, causes the code to be changed from Java **interpreted code**, to Java **compiled code**.  Compiled code executes non-portable processor instructions to do the work, so it should be faster than the same code executing portable interpreted Java virtual-machine instructions.  Some Java interpreters/compilers will do on-the-fly compile of some or all of the code, if parts of the code are executed enough times.\\n\\nIf someone has better ideas why the uselessly extra looping makes the code faster, please let me know in the comments below.\\n\\n**Explanation of \"static\" in code:** This line of code that contains the useless loop, also references a static variable `x`.  For leetcode\\'s Java, when running multiple simultaneous test cases, such as with the SUBMIT button, the static variables will be instantiated and initialized only for the first test case, then the values in those variables will be preserved across test cases.  The value in `x` will be zero for the first test case, but will be non-zero for the other test cases of this SUBMIT.  This will cause the useless loop to executed only for the first test case of this SUBMIT.  For the next SUBMIT or RUN, the static variable will be reset by being instantiated and initialized again.\\n\\n**If useful, please upvote.**\\n\\n**--- Faster code (2ms in August 2023) ---**\\n```\\nclass Solution {\\n    static int x = 0;\\n    \\n    public long mostPoints(int[][] questions) {\\n        if (x++ == 0)  for (int i = 50_000; i >= 0; i--)  { }\\n\\n        int n = questions.length;\\n        long[] dp = new long[n + 1];\\n        for (int i = n - 1; i >= 0; i--) {\\n            int next = i + questions[i][1] + 1;\\n            if (next >= n)\\n                dp[i] = Math.max(questions[i][0], dp[i + 1]);\\n            else\\n                dp[i] = Math.max(questions[i][0] + dp[next], dp[i + 1]);\\n        }\\n        return dp[0];\\n    }\\n}\\n```\\n**--- Slower code (4ms in August 2023) ---**\\n```\\nclass Solution {\\n    static int x = 0;\\n    \\n    public long mostPoints(int[][] questions) {\\n        // if (x++ == 0)  for (int i = 50_000; i >= 0; i--)  { }\\n\\n        int n = questions.length;\\n        long[] dp = new long[n + 1];\\n        for (int i = n - 1; i >= 0; i--) {\\n            int next = i + questions[i][1] + 1;\\n            if (next >= n)\\n                dp[i] = Math.max(questions[i][0], dp[i + 1]);\\n            else\\n                dp[i] = Math.max(questions[i][0] + dp[next], dp[i + 1]);\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int x = 0;\\n    \\n    public long mostPoints(int[][] questions) {\\n        if (x++ == 0)  for (int i = 50_000; i >= 0; i--)  { }\\n\\n        int n = questions.length;\\n        long[] dp = new long[n + 1];\\n        for (int i = n - 1; i >= 0; i--) {\\n            int next = i + questions[i][1] + 1;\\n            if (next >= n)\\n                dp[i] = Math.max(questions[i][0], dp[i + 1]);\\n            else\\n                dp[i] = Math.max(questions[i][0] + dp[next], dp[i + 1]);\\n        }\\n        return dp[0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    static int x = 0;\\n    \\n    public long mostPoints(int[][] questions) {\\n        // if (x++ == 0)  for (int i = 50_000; i >= 0; i--)  { }\\n\\n        int n = questions.length;\\n        long[] dp = new long[n + 1];\\n        for (int i = n - 1; i >= 0; i--) {\\n            int next = i + questions[i][1] + 1;\\n            if (next >= n)\\n                dp[i] = Math.max(questions[i][0], dp[i + 1]);\\n            else\\n                dp[i] = Math.max(questions[i][0] + dp[next], dp[i + 1]);\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514230,
                "title": "",
                "content": "**Context:D**\\n``\\nI literary spent a hour on the problem getting no hint just trying all recursive approach I can think or even iterative too but nothing work but then I notice the pattern of this question is like Hous of robber which is fibonacci style dp problem.Then, I thought of this approach and it worked.\\n``\\n# **Approach:-)**\\n``\\nI have used a memoised approach to the problem wherein I am one time taking the current index and making it iterate recursively to end and then in next step checking whether if I have left that one out, could the answer maximise? So, to do this I just took out the maximum from take and notake situations. More about this in the code for better understanding.\\n``\\n\\n``\\nTC = O(n)\\nSC = DP( O(n) ) + stack( O(n) )\\n``\\n\\n**Code:->**\\n```\\nclass Solution {\\npublic:\\n    long long helper( vector<vector<int>> &nums, vector<long long> &dp, int i, int n ){\\n        if( i>=n ){\\n            return 0;\\n        }\\n        if( dp[i] != -1 ){\\n            return dp[i];\\n        } \\n        long long take = helper(nums, dp, i+nums[i][1]+1, n) + nums[i][0];\\n        long long notake = helper(nums, dp, i+1, n) + 0;\\n        dp[i] = max(take, notake);\\n        return dp[i];\\n    }\\n    long long mostPoints(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        vector<long long> dp(n+1, -1);\\n        long long solve= helper( nums, dp, 0, n );\\n        return solve;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long helper( vector<vector<int>> &nums, vector<long long> &dp, int i, int n ){\\n        if( i>=n ){\\n            return 0;\\n        }\\n        if( dp[i] != -1 ){\\n            return dp[i];\\n        } \\n        long long take = helper(nums, dp, i+nums[i][1]+1, n) + nums[i][0];\\n        long long notake = helper(nums, dp, i+1, n) + 0;\\n        dp[i] = max(take, notake);\\n        return dp[i];\\n    }\\n    long long mostPoints(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        vector<long long> dp(n+1, -1);\\n        long long solve= helper( nums, dp, 0, n );\\n        return solve;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514213,
                "title": "ruby-iterative-dp-solution",
                "content": "```\\ndef most_points(questions)\\n  dp = Array.new(questions.size+1, 0)\\n  (questions.size-1).downto(0) {|i|\\n    points, brainpower = questions[i]\\n    dp[i] = [points + (i + brainpower > questions.size-2 ? 0 : dp[i+brainpower+1]), dp[i+1]].max\\n  }\\n  dp[0]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef most_points(questions)\\n  dp = Array.new(questions.size+1, 0)\\n  (questions.size-1).downto(0) {|i|\\n    points, brainpower = questions[i]\\n    dp[i] = [points + (i + brainpower > questions.size-2 ? 0 : dp[i+brainpower+1]), dp[i+1]].max\\n  }\\n  dp[0]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3514157,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n=len(questions)\\n        best=[0]*(n+1)\\n        @cache\\n        def go(i):\\n            if i>=n:\\n                return 0\\n\\n            best=0\\n            best=max(go(i+1),best)\\n            best=max(go(i+questions[i][1]+1)+questions[i][0],best)\\n            return best\\n\\n\\n        return go(0)      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        n=len(questions)\\n        best=[0]*(n+1)\\n        @cache\\n        def go(i):\\n            if i>=n:\\n                return 0\\n\\n            best=0\\n            best=max(go(i+1),best)\\n            best=max(go(i+questions[i][1]+1)+questions[i][0],best)\\n            return best\\n\\n\\n        return go(0)      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514107,
                "title": "6-lines-of-code-beats-100-java-easy-to-understand-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long dp[] = new long[n + 1]; \\n        for (int i = n-1;i>= 0;i--) {\\n            int points = questions[i][0], jump = questions[i][1];\\n            dp[i] = Math.max(points+dp[Math.min(jump+i+1,n)],dp[i+1]);\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        int n = questions.length;\\n        long dp[] = new long[n + 1]; \\n        for (int i = n-1;i>= 0;i--) {\\n            int points = questions[i][0], jump = questions[i][1];\\n            dp[i] = Math.max(points+dp[Math.min(jump+i+1,n)],dp[i+1]);\\n        }\\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510267,
                "title": "ruby-solution-with-memoization",
                "content": "# Intuition\\nEasy DP with memoization\\n\\n# Approach\\n1. Create memo and question class variables\\n2. Use helper function to find the max value starting at each index (return value from index 0)\\n\\nIn the helper function:\\n1. Return 0 if you\\'re outside the range of questions\\n2. Return memoized value if you\\'ve checked here before\\n3. For index i, you have two options:\\n    - Skip that question (return function for i+1)\\n    - Answer that question (add its points to the total, but skip indices corresponding to cost)\\n4. Take whichever option gives you a higher value, memoize it, and return it.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\ndef most_points(questions)\\n    @memo = {}\\n    @questions = questions\\n\\n    max_points(0)\\nend\\n\\ndef max_points(i)\\n    return 0 if i >= @questions.length\\n    return @memo[i] if @memo[i]\\n\\n    option1 = max_points(i+1)\\n    \\n    points, cost = @questions[i]\\n    option2 = points + max_points(i+1 + cost)\\n\\n    @memo[i] = [option1,option2].max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef most_points(questions)\\n    @memo = {}\\n    @questions = questions\\n\\n    max_points(0)\\nend\\n\\ndef max_points(i)\\n    return 0 if i >= @questions.length\\n    return @memo[i] if @memo[i]\\n\\n    option1 = max_points(i+1)\\n    \\n    points, cost = @questions[i]\\n    option2 = points + max_points(i+1 + cost)\\n\\n    @memo[i] = [option1,option2].max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3325585,
                "title": "100-working-solution-in-java-using-memoization-and-recursion",
                "content": "```\\nclass Solution {\\n    public long mostPoints(int[][] q) {\\n        int n= q.length;\\n        long[] dp= new long[n+1];\\n        Arrays.fill(dp,-1);\\n        \\n        long max= 0;\\n        \\n        \\n        max= Math.max(max,solve(q,dp,0,n));\\n        \\n        \\n        return max;\\n    }\\n    \\n    public long solve(int[][] q, long[] dp, int i, int n){\\n        if(i>=n){\\n            return 0;\\n        }\\n        \\n        if(i==n-1){\\n            return q[i][0];\\n        }\\n        \\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        \\n        return dp[i]= Math.max(q[i][0]+solve(q,dp,i+q[i][1]+1,n),solve(q,dp,i+1,n));\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public long mostPoints(int[][] q) {\\n        int n= q.length;\\n        long[] dp= new long[n+1];\\n        Arrays.fill(dp,-1);\\n        \\n        long max= 0;\\n        \\n        \\n        max= Math.max(max,solve(q,dp,0,n));\\n        \\n        \\n        return max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3168891,
                "title": "java-iterative-and-recursive-solution-using-dp",
                "content": "#  Approach\\n\\n1. **make a dp array to store the maximum values.**\\n2. **Compare and store the value of current position and position at pos+len** \\n\\n# iterative Java Code\\n```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        long[] dp = new long[questions.length+1];\\n\\n        for(int i = questions.length-1;i >= 0;i--){\\n            int points = questions[i][0];\\n            int len = questions[i][1];\\n            dp[i] = points;\\n\\n            if(i+len < questions.length){\\n                dp[i] += dp[i+1+len];\\n            }\\n            dp[i] = Math.max(dp[i],dp[i+1]);\\n        }\\n\\n        return dp[0];\\n    }\\n}\\n```\\n# recursive java code\\n```\\nclass Solution {\\n\\n    long[] dp;\\n\\n    public long mostPoints(int[][] questions) {\\n        dp = new long[questions.length];\\n\\n        return solve(questions,0);\\n    }\\n\\n    private long solve(int[][] questions, int i){\\n        if(i >= questions.length){\\n            return 0;\\n        }\\n\\n        if(dp[i] != 0){\\n            return dp[i];\\n        }\\n        \\n        int points = questions[i][0];\\n        int len = questions[i][1];\\n\\n        return dp[i] = Math.max(solve(questions, i+1), points + solve(questions, i+1+len));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public long mostPoints(int[][] questions) {\\n        long[] dp = new long[questions.length+1];\\n\\n        for(int i = questions.length-1;i >= 0;i--){\\n            int points = questions[i][0];\\n            int len = questions[i][1];\\n            dp[i] = points;\\n\\n            if(i+len < questions.length){\\n                dp[i] += dp[i+1+len];\\n            }\\n            dp[i] = Math.max(dp[i],dp[i+1]);\\n        }\\n\\n        return dp[0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    long[] dp;\\n\\n    public long mostPoints(int[][] questions) {\\n        dp = new long[questions.length];\\n\\n        return solve(questions,0);\\n    }\\n\\n    private long solve(int[][] questions, int i){\\n        if(i >= questions.length){\\n            return 0;\\n        }\\n\\n        if(dp[i] != 0){\\n            return dp[i];\\n        }\\n        \\n        int points = questions[i][0];\\n        int len = questions[i][1];\\n\\n        return dp[i] = Math.max(solve(questions, i+1), points + solve(questions, i+1+len));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947649,
                "title": "kotlin-easy-few-lines",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    fun mostPoints(q: Array<IntArray>): Long {\\n        var a = LongArray(q.size)\\n        for (i in q.size - 1 downTo 0) {\\n            a[i] = Math.max(\\n                if (i + 1 < q.size) a[i + 1] else 0,\\n                q[i][0] + (if (i + q[i][1] + 1 < q.size) a[i + q[i][1] + 1] else 0))\\n        }\\n        return a[0]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Array",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    fun mostPoints(q: Array<IntArray>): Long {\\n        var a = LongArray(q.size)\\n        for (i in q.size - 1 downTo 0) {\\n            a[i] = Math.max(\\n                if (i + 1 < q.size) a[i + 1] else 0,\\n                q[i][0] + (if (i + q[i][1] + 1 < q.size) a[i + q[i][1] + 1] else 0))\\n        }\\n        return a[0]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909769,
                "title": "c",
                "content": "```\\nlong long mostPoints(int** questions, int questionsSize, int* questionsColSize){\\n    int n = questionsSize;\\n    long long* dp = malloc( (n+1) * sizeof(long long));\\n    dp[n] = 0;\\n    for(int i = n - 1; i >= 0;i--){\\n        int k = fmin( i + questions[i][1] + 1, n ) ;\\n        dp[i] = fmax(questions[i][0]+dp[k], dp[i+1]);\\n    }\\n    long long ans = dp[0] ;\\n    free(dp);\\n    return ans;    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nlong long mostPoints(int** questions, int questionsSize, int* questionsColSize){\\n    int n = questionsSize;\\n    long long* dp = malloc( (n+1) * sizeof(long long));\\n    dp[n] = 0;\\n    for(int i = n - 1; i >= 0;i--){\\n        int k = fmin( i + questions[i][1] + 1, n ) ;\\n        dp[i] = fmax(questions[i][0]+dp[k], dp[i+1]);\\n    }\\n    long long ans = dp[0] ;\\n    free(dp);\\n    return ans;    \\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1890643,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1890686,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1890765,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1890655,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1890612,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1890606,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1890626,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1890824,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1890763,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1890721,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1890643,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1890686,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1890765,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1890655,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1890612,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1890606,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1890626,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1890824,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1890763,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1890721,
                "content": [
                    {
                        "username": "daring-calf",
                        "content": "I\\'m gonna skip this cuz I have to save my brain power for the weekend\\'s hard\\'s."
                    },
                    {
                        "username": "Tangleworm",
                        "content": "Horrifyingly, this problem implies the existence of a 100,000 question exam."
                    },
                    {
                        "username": "GD18",
                        "content": "haha"
                    },
                    {
                        "username": "hardcoredummmy",
                        "content": "No spiral matrix IV today?"
                    },
                    {
                        "username": "utkarsh-009",
                        "content": "just let it go bruh... its over\\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "How is this test case expect 157 as answer. Help me please.\\nWhat is the array order of execution?\\n\\n `[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]`"
                    },
                    {
                        "username": "user0041Wx",
                        "content": "92 -> 65 == 157"
                    },
                    {
                        "username": "ottoabarriosp",
                        "content": "If you skip one question, you are not obliged to answer the following one, that\\'s the trick"
                    },
                    {
                        "username": "kumarm_",
                        "content": "[@suzain](/suzain)  92 has 3 brain power so you have to skip 3 so cant add 58."
                    },
                    {
                        "username": "pedroMF1996",
                        "content": "[@derese_anatoli](/derese_anatoli) Thanks !"
                    },
                    {
                        "username": "derese_anatoli",
                        "content": "first do 92 skip the rest and do 65\\n"
                    },
                    {
                        "username": "yudaevgo",
                        "content": "[@raushan27](/raushan27) we can skip only 1 element in every step right? \nupd: got it we can skip as much as we want"
                    },
                    {
                        "username": "raushan27",
                        "content": "[@suzain](/suzain) you must skip at least 3 indices i.e. brainpower and then decide for the next element.\\nHere if you choose [92,3] you have to skip 3 element which takes you to [5,5] and for [5,5] you get to decide whether to choose or skip."
                    },
                    {
                        "username": "suzain",
                        "content": "[@raushan27](/raushan27) but in question it is asking for maximum .If we select [92,3] skip 2 indexes add [58,2] again skip 2 index add [65,3] .this will give output as 215."
                    },
                    {
                        "username": "raushan27",
                        "content": "[@ankit_r](/ankit_r) After skipping 3 indexes\\', we don\\'t need to take that element necessarily. \\nEither we can take that element or skip that. we will be skipping [5,5], [49,4] and will be picking [65,3]\\nThus, the answer will become 157."
                    },
                    {
                        "username": "Pradeep005",
                        "content": "[@dynamo214](/dynamo214) if we skip three elements after [92,3] we reach [5,5] right? how come it is [65,3]"
                    },
                    {
                        "username": "ankit_r",
                        "content": "[@dynamo214](/dynamo214)  we can skip 3 index then how directly we reach to the index 7."
                    },
                    {
                        "username": "shtl",
                        "content": "[@dynamo214](/dynamo214) Select 92(index=1, skip next 3) + 5(index=5) = 97"
                    },
                    {
                        "username": "GopiKumaresan",
                        "content": "[@dynamo214](/dynamo214) [@Ben Huang](/manifold1985) Thanks for the help."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Only do two questions:\\n1-st: [92,3]\\n7-th: [65,3]"
                    },
                    {
                        "username": "dynamo214",
                        "content": "Select 92(index=1, skip next 3) + 65(index=7) = 157"
                    },
                    {
                        "username": "TasneemAyham",
                        "content": "At this time of the day, BrainPower == 0!!"
                    },
                    {
                        "username": "jerryy147",
                        "content": "0!! = 1! = 1 :)"
                    },
                    {
                        "username": "Maang-io",
                        "content": "Classical \"Take it or skip it\" type optimization problem."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "aka 0-1 knapsack "
                    },
                    {
                        "username": "WildPikachu",
                        "content": "One of the easier mediums"
                    },
                    {
                        "username": "yashskd1026",
                        "content": "simple take or not take problem.. in this \n1.   If you not take the item simple move to next item.\n2.   or if u take the item then add its points and move to (curr_idx+brainpower+1)."
                    },
                    {
                        "username": "anubhavanand",
                        "content": "solved it with Brainpower..\\nwho all have brainpower same as me?"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Need to skip this question, need to save brainpower for weekly content"
                    }
                ]
            },
            {
                "id": 1891522,
                "content": [
                    {
                        "username": "dudhaniayush",
                        "content": "How does it feels when second last testcase gives wrong answer :'(\nTestcase 53/54\n\nEDIT: then i realised the dp matrix I was using was of type int, and values were of long long type so changing it got my solution submitted"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Same happened with me XD"
                    },
                    {
                        "username": "9891YKYASH",
                        "content": "us bro us"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "First DP problem I solved it on my own. Just pick and don\\'t pick approach. Nice problem."
                    },
                    {
                        "username": "arghyadas",
                        "content": "53/54 passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivanshbhardwaj989",
                        "content": "[@orunnnegi01](/orunnnegi01) use long long in initialization of dp"
                    },
                    {
                        "username": "oreo_shake",
                        "content": "m getting the same issue with my code tho ive used long long in my code still\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Forgot to use ``` long long ``` my bad\\uD83D\\uDE02"
                    },
                    {
                        "username": "saransh15",
                        "content": "[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]\\nExpected answer: 157, I am getting 123. Can someone tell which questions were solved to get a score of 157?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Has been asnwered multiple times already, read the entire discussion before asking please. Answer is index 1 and 7. ( 92 + 65 )"
                    },
                    {
                        "username": "coder1666",
                        "content": "Classic recursion pattern take it or skip it, then apply dp on it.\nDisclaimer: Don't use much of your brainpower :P"
                    },
                    {
                        "username": "15o1",
                        "content": "Standard 0-1 Knapsack Problem "
                    },
                    {
                        "username": "sumeet14",
                        "content": "Why do I feel like Iamspeed \\n\\nSkip: \\nSkip:\\nwhy does this game feels good bruh \\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "A good DP problem!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Similar to buy and sell stock with cooldown problem\\nTake it or skip it"
                    },
                    {
                        "username": "Aionlasting",
                        "content": "Solution works in codelight, gives correct answer, but not in the online IDE? Using C++ on both. Any input?\\n\\nHere is my code, can uncomment the ccout and see it gives the right answers.\\n\\nlong long mostPoints(vector<vector<int>>& questions) {\\n      \\n        long long maxScore = 0;\\n         unsigned int nextIndex = 0;\\n         long long score = 0;\\n         for(std::size_t i = 0; i < questions.size(); i++) \\n        {\\n                            \\n               score = questions.at(i).at(0);\\n            \\n               nextIndex = questions.at(i).at(1) + i + 1;\\n  \\n                // cout << \"==================================\" << endl;\\n                // cout << i << \")\" <<\" Score before loop: \" << score << endl;\\n                // cout << \"nextIndex: \"<< nextIndex << endl;\\n                while(nextIndex < questions.size()) {\\n                    score += questions.at(nextIndex).at(0);\\n                    nextIndex += questions.at(nextIndex).at(1) + 1;\\n                    //cout << \"new score while: \" << score << \"with next index now \" << nextIndex << endl;\\n                \\n                }\\n\\n           \\n\\n\\n                if(score > maxScore) \\n                {\\n                    maxScore = score;\\n                   // cout << \"new max score: \" << maxScore << endl;\\n                }\\n      \\n                          \\n        }\\n        \\n        return maxScore;\\n    }"
                    }
                ]
            },
            {
                "id": 1891252,
                "content": [
                    {
                        "username": "dudhaniayush",
                        "content": "How does it feels when second last testcase gives wrong answer :'(\nTestcase 53/54\n\nEDIT: then i realised the dp matrix I was using was of type int, and values were of long long type so changing it got my solution submitted"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Same happened with me XD"
                    },
                    {
                        "username": "9891YKYASH",
                        "content": "us bro us"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "First DP problem I solved it on my own. Just pick and don\\'t pick approach. Nice problem."
                    },
                    {
                        "username": "arghyadas",
                        "content": "53/54 passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivanshbhardwaj989",
                        "content": "[@orunnnegi01](/orunnnegi01) use long long in initialization of dp"
                    },
                    {
                        "username": "oreo_shake",
                        "content": "m getting the same issue with my code tho ive used long long in my code still\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Forgot to use ``` long long ``` my bad\\uD83D\\uDE02"
                    },
                    {
                        "username": "saransh15",
                        "content": "[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]\\nExpected answer: 157, I am getting 123. Can someone tell which questions were solved to get a score of 157?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Has been asnwered multiple times already, read the entire discussion before asking please. Answer is index 1 and 7. ( 92 + 65 )"
                    },
                    {
                        "username": "coder1666",
                        "content": "Classic recursion pattern take it or skip it, then apply dp on it.\nDisclaimer: Don't use much of your brainpower :P"
                    },
                    {
                        "username": "15o1",
                        "content": "Standard 0-1 Knapsack Problem "
                    },
                    {
                        "username": "sumeet14",
                        "content": "Why do I feel like Iamspeed \\n\\nSkip: \\nSkip:\\nwhy does this game feels good bruh \\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "A good DP problem!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Similar to buy and sell stock with cooldown problem\\nTake it or skip it"
                    },
                    {
                        "username": "Aionlasting",
                        "content": "Solution works in codelight, gives correct answer, but not in the online IDE? Using C++ on both. Any input?\\n\\nHere is my code, can uncomment the ccout and see it gives the right answers.\\n\\nlong long mostPoints(vector<vector<int>>& questions) {\\n      \\n        long long maxScore = 0;\\n         unsigned int nextIndex = 0;\\n         long long score = 0;\\n         for(std::size_t i = 0; i < questions.size(); i++) \\n        {\\n                            \\n               score = questions.at(i).at(0);\\n            \\n               nextIndex = questions.at(i).at(1) + i + 1;\\n  \\n                // cout << \"==================================\" << endl;\\n                // cout << i << \")\" <<\" Score before loop: \" << score << endl;\\n                // cout << \"nextIndex: \"<< nextIndex << endl;\\n                while(nextIndex < questions.size()) {\\n                    score += questions.at(nextIndex).at(0);\\n                    nextIndex += questions.at(nextIndex).at(1) + 1;\\n                    //cout << \"new score while: \" << score << \"with next index now \" << nextIndex << endl;\\n                \\n                }\\n\\n           \\n\\n\\n                if(score > maxScore) \\n                {\\n                    maxScore = score;\\n                   // cout << \"new max score: \" << maxScore << endl;\\n                }\\n      \\n                          \\n        }\\n        \\n        return maxScore;\\n    }"
                    }
                ]
            },
            {
                "id": 1890912,
                "content": [
                    {
                        "username": "dudhaniayush",
                        "content": "How does it feels when second last testcase gives wrong answer :'(\nTestcase 53/54\n\nEDIT: then i realised the dp matrix I was using was of type int, and values were of long long type so changing it got my solution submitted"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Same happened with me XD"
                    },
                    {
                        "username": "9891YKYASH",
                        "content": "us bro us"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "First DP problem I solved it on my own. Just pick and don\\'t pick approach. Nice problem."
                    },
                    {
                        "username": "arghyadas",
                        "content": "53/54 passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivanshbhardwaj989",
                        "content": "[@orunnnegi01](/orunnnegi01) use long long in initialization of dp"
                    },
                    {
                        "username": "oreo_shake",
                        "content": "m getting the same issue with my code tho ive used long long in my code still\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Forgot to use ``` long long ``` my bad\\uD83D\\uDE02"
                    },
                    {
                        "username": "saransh15",
                        "content": "[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]\\nExpected answer: 157, I am getting 123. Can someone tell which questions were solved to get a score of 157?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Has been asnwered multiple times already, read the entire discussion before asking please. Answer is index 1 and 7. ( 92 + 65 )"
                    },
                    {
                        "username": "coder1666",
                        "content": "Classic recursion pattern take it or skip it, then apply dp on it.\nDisclaimer: Don't use much of your brainpower :P"
                    },
                    {
                        "username": "15o1",
                        "content": "Standard 0-1 Knapsack Problem "
                    },
                    {
                        "username": "sumeet14",
                        "content": "Why do I feel like Iamspeed \\n\\nSkip: \\nSkip:\\nwhy does this game feels good bruh \\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "A good DP problem!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Similar to buy and sell stock with cooldown problem\\nTake it or skip it"
                    },
                    {
                        "username": "Aionlasting",
                        "content": "Solution works in codelight, gives correct answer, but not in the online IDE? Using C++ on both. Any input?\\n\\nHere is my code, can uncomment the ccout and see it gives the right answers.\\n\\nlong long mostPoints(vector<vector<int>>& questions) {\\n      \\n        long long maxScore = 0;\\n         unsigned int nextIndex = 0;\\n         long long score = 0;\\n         for(std::size_t i = 0; i < questions.size(); i++) \\n        {\\n                            \\n               score = questions.at(i).at(0);\\n            \\n               nextIndex = questions.at(i).at(1) + i + 1;\\n  \\n                // cout << \"==================================\" << endl;\\n                // cout << i << \")\" <<\" Score before loop: \" << score << endl;\\n                // cout << \"nextIndex: \"<< nextIndex << endl;\\n                while(nextIndex < questions.size()) {\\n                    score += questions.at(nextIndex).at(0);\\n                    nextIndex += questions.at(nextIndex).at(1) + 1;\\n                    //cout << \"new score while: \" << score << \"with next index now \" << nextIndex << endl;\\n                \\n                }\\n\\n           \\n\\n\\n                if(score > maxScore) \\n                {\\n                    maxScore = score;\\n                   // cout << \"new max score: \" << maxScore << endl;\\n                }\\n      \\n                          \\n        }\\n        \\n        return maxScore;\\n    }"
                    }
                ]
            },
            {
                "id": 1891260,
                "content": [
                    {
                        "username": "dudhaniayush",
                        "content": "How does it feels when second last testcase gives wrong answer :'(\nTestcase 53/54\n\nEDIT: then i realised the dp matrix I was using was of type int, and values were of long long type so changing it got my solution submitted"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Same happened with me XD"
                    },
                    {
                        "username": "9891YKYASH",
                        "content": "us bro us"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "First DP problem I solved it on my own. Just pick and don\\'t pick approach. Nice problem."
                    },
                    {
                        "username": "arghyadas",
                        "content": "53/54 passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivanshbhardwaj989",
                        "content": "[@orunnnegi01](/orunnnegi01) use long long in initialization of dp"
                    },
                    {
                        "username": "oreo_shake",
                        "content": "m getting the same issue with my code tho ive used long long in my code still\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Forgot to use ``` long long ``` my bad\\uD83D\\uDE02"
                    },
                    {
                        "username": "saransh15",
                        "content": "[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]\\nExpected answer: 157, I am getting 123. Can someone tell which questions were solved to get a score of 157?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Has been asnwered multiple times already, read the entire discussion before asking please. Answer is index 1 and 7. ( 92 + 65 )"
                    },
                    {
                        "username": "coder1666",
                        "content": "Classic recursion pattern take it or skip it, then apply dp on it.\nDisclaimer: Don't use much of your brainpower :P"
                    },
                    {
                        "username": "15o1",
                        "content": "Standard 0-1 Knapsack Problem "
                    },
                    {
                        "username": "sumeet14",
                        "content": "Why do I feel like Iamspeed \\n\\nSkip: \\nSkip:\\nwhy does this game feels good bruh \\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "A good DP problem!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Similar to buy and sell stock with cooldown problem\\nTake it or skip it"
                    },
                    {
                        "username": "Aionlasting",
                        "content": "Solution works in codelight, gives correct answer, but not in the online IDE? Using C++ on both. Any input?\\n\\nHere is my code, can uncomment the ccout and see it gives the right answers.\\n\\nlong long mostPoints(vector<vector<int>>& questions) {\\n      \\n        long long maxScore = 0;\\n         unsigned int nextIndex = 0;\\n         long long score = 0;\\n         for(std::size_t i = 0; i < questions.size(); i++) \\n        {\\n                            \\n               score = questions.at(i).at(0);\\n            \\n               nextIndex = questions.at(i).at(1) + i + 1;\\n  \\n                // cout << \"==================================\" << endl;\\n                // cout << i << \")\" <<\" Score before loop: \" << score << endl;\\n                // cout << \"nextIndex: \"<< nextIndex << endl;\\n                while(nextIndex < questions.size()) {\\n                    score += questions.at(nextIndex).at(0);\\n                    nextIndex += questions.at(nextIndex).at(1) + 1;\\n                    //cout << \"new score while: \" << score << \"with next index now \" << nextIndex << endl;\\n                \\n                }\\n\\n           \\n\\n\\n                if(score > maxScore) \\n                {\\n                    maxScore = score;\\n                   // cout << \"new max score: \" << maxScore << endl;\\n                }\\n      \\n                          \\n        }\\n        \\n        return maxScore;\\n    }"
                    }
                ]
            },
            {
                "id": 1891189,
                "content": [
                    {
                        "username": "dudhaniayush",
                        "content": "How does it feels when second last testcase gives wrong answer :'(\nTestcase 53/54\n\nEDIT: then i realised the dp matrix I was using was of type int, and values were of long long type so changing it got my solution submitted"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Same happened with me XD"
                    },
                    {
                        "username": "9891YKYASH",
                        "content": "us bro us"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "First DP problem I solved it on my own. Just pick and don\\'t pick approach. Nice problem."
                    },
                    {
                        "username": "arghyadas",
                        "content": "53/54 passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivanshbhardwaj989",
                        "content": "[@orunnnegi01](/orunnnegi01) use long long in initialization of dp"
                    },
                    {
                        "username": "oreo_shake",
                        "content": "m getting the same issue with my code tho ive used long long in my code still\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Forgot to use ``` long long ``` my bad\\uD83D\\uDE02"
                    },
                    {
                        "username": "saransh15",
                        "content": "[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]\\nExpected answer: 157, I am getting 123. Can someone tell which questions were solved to get a score of 157?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Has been asnwered multiple times already, read the entire discussion before asking please. Answer is index 1 and 7. ( 92 + 65 )"
                    },
                    {
                        "username": "coder1666",
                        "content": "Classic recursion pattern take it or skip it, then apply dp on it.\nDisclaimer: Don't use much of your brainpower :P"
                    },
                    {
                        "username": "15o1",
                        "content": "Standard 0-1 Knapsack Problem "
                    },
                    {
                        "username": "sumeet14",
                        "content": "Why do I feel like Iamspeed \\n\\nSkip: \\nSkip:\\nwhy does this game feels good bruh \\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "A good DP problem!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Similar to buy and sell stock with cooldown problem\\nTake it or skip it"
                    },
                    {
                        "username": "Aionlasting",
                        "content": "Solution works in codelight, gives correct answer, but not in the online IDE? Using C++ on both. Any input?\\n\\nHere is my code, can uncomment the ccout and see it gives the right answers.\\n\\nlong long mostPoints(vector<vector<int>>& questions) {\\n      \\n        long long maxScore = 0;\\n         unsigned int nextIndex = 0;\\n         long long score = 0;\\n         for(std::size_t i = 0; i < questions.size(); i++) \\n        {\\n                            \\n               score = questions.at(i).at(0);\\n            \\n               nextIndex = questions.at(i).at(1) + i + 1;\\n  \\n                // cout << \"==================================\" << endl;\\n                // cout << i << \")\" <<\" Score before loop: \" << score << endl;\\n                // cout << \"nextIndex: \"<< nextIndex << endl;\\n                while(nextIndex < questions.size()) {\\n                    score += questions.at(nextIndex).at(0);\\n                    nextIndex += questions.at(nextIndex).at(1) + 1;\\n                    //cout << \"new score while: \" << score << \"with next index now \" << nextIndex << endl;\\n                \\n                }\\n\\n           \\n\\n\\n                if(score > maxScore) \\n                {\\n                    maxScore = score;\\n                   // cout << \"new max score: \" << maxScore << endl;\\n                }\\n      \\n                          \\n        }\\n        \\n        return maxScore;\\n    }"
                    }
                ]
            },
            {
                "id": 1890910,
                "content": [
                    {
                        "username": "dudhaniayush",
                        "content": "How does it feels when second last testcase gives wrong answer :'(\nTestcase 53/54\n\nEDIT: then i realised the dp matrix I was using was of type int, and values were of long long type so changing it got my solution submitted"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Same happened with me XD"
                    },
                    {
                        "username": "9891YKYASH",
                        "content": "us bro us"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "First DP problem I solved it on my own. Just pick and don\\'t pick approach. Nice problem."
                    },
                    {
                        "username": "arghyadas",
                        "content": "53/54 passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivanshbhardwaj989",
                        "content": "[@orunnnegi01](/orunnnegi01) use long long in initialization of dp"
                    },
                    {
                        "username": "oreo_shake",
                        "content": "m getting the same issue with my code tho ive used long long in my code still\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Forgot to use ``` long long ``` my bad\\uD83D\\uDE02"
                    },
                    {
                        "username": "saransh15",
                        "content": "[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]\\nExpected answer: 157, I am getting 123. Can someone tell which questions were solved to get a score of 157?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Has been asnwered multiple times already, read the entire discussion before asking please. Answer is index 1 and 7. ( 92 + 65 )"
                    },
                    {
                        "username": "coder1666",
                        "content": "Classic recursion pattern take it or skip it, then apply dp on it.\nDisclaimer: Don't use much of your brainpower :P"
                    },
                    {
                        "username": "15o1",
                        "content": "Standard 0-1 Knapsack Problem "
                    },
                    {
                        "username": "sumeet14",
                        "content": "Why do I feel like Iamspeed \\n\\nSkip: \\nSkip:\\nwhy does this game feels good bruh \\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "A good DP problem!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Similar to buy and sell stock with cooldown problem\\nTake it or skip it"
                    },
                    {
                        "username": "Aionlasting",
                        "content": "Solution works in codelight, gives correct answer, but not in the online IDE? Using C++ on both. Any input?\\n\\nHere is my code, can uncomment the ccout and see it gives the right answers.\\n\\nlong long mostPoints(vector<vector<int>>& questions) {\\n      \\n        long long maxScore = 0;\\n         unsigned int nextIndex = 0;\\n         long long score = 0;\\n         for(std::size_t i = 0; i < questions.size(); i++) \\n        {\\n                            \\n               score = questions.at(i).at(0);\\n            \\n               nextIndex = questions.at(i).at(1) + i + 1;\\n  \\n                // cout << \"==================================\" << endl;\\n                // cout << i << \")\" <<\" Score before loop: \" << score << endl;\\n                // cout << \"nextIndex: \"<< nextIndex << endl;\\n                while(nextIndex < questions.size()) {\\n                    score += questions.at(nextIndex).at(0);\\n                    nextIndex += questions.at(nextIndex).at(1) + 1;\\n                    //cout << \"new score while: \" << score << \"with next index now \" << nextIndex << endl;\\n                \\n                }\\n\\n           \\n\\n\\n                if(score > maxScore) \\n                {\\n                    maxScore = score;\\n                   // cout << \"new max score: \" << maxScore << endl;\\n                }\\n      \\n                          \\n        }\\n        \\n        return maxScore;\\n    }"
                    }
                ]
            },
            {
                "id": 1890909,
                "content": [
                    {
                        "username": "dudhaniayush",
                        "content": "How does it feels when second last testcase gives wrong answer :'(\nTestcase 53/54\n\nEDIT: then i realised the dp matrix I was using was of type int, and values were of long long type so changing it got my solution submitted"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Same happened with me XD"
                    },
                    {
                        "username": "9891YKYASH",
                        "content": "us bro us"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "First DP problem I solved it on my own. Just pick and don\\'t pick approach. Nice problem."
                    },
                    {
                        "username": "arghyadas",
                        "content": "53/54 passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivanshbhardwaj989",
                        "content": "[@orunnnegi01](/orunnnegi01) use long long in initialization of dp"
                    },
                    {
                        "username": "oreo_shake",
                        "content": "m getting the same issue with my code tho ive used long long in my code still\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Forgot to use ``` long long ``` my bad\\uD83D\\uDE02"
                    },
                    {
                        "username": "saransh15",
                        "content": "[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]\\nExpected answer: 157, I am getting 123. Can someone tell which questions were solved to get a score of 157?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Has been asnwered multiple times already, read the entire discussion before asking please. Answer is index 1 and 7. ( 92 + 65 )"
                    },
                    {
                        "username": "coder1666",
                        "content": "Classic recursion pattern take it or skip it, then apply dp on it.\nDisclaimer: Don't use much of your brainpower :P"
                    },
                    {
                        "username": "15o1",
                        "content": "Standard 0-1 Knapsack Problem "
                    },
                    {
                        "username": "sumeet14",
                        "content": "Why do I feel like Iamspeed \\n\\nSkip: \\nSkip:\\nwhy does this game feels good bruh \\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "A good DP problem!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Similar to buy and sell stock with cooldown problem\\nTake it or skip it"
                    },
                    {
                        "username": "Aionlasting",
                        "content": "Solution works in codelight, gives correct answer, but not in the online IDE? Using C++ on both. Any input?\\n\\nHere is my code, can uncomment the ccout and see it gives the right answers.\\n\\nlong long mostPoints(vector<vector<int>>& questions) {\\n      \\n        long long maxScore = 0;\\n         unsigned int nextIndex = 0;\\n         long long score = 0;\\n         for(std::size_t i = 0; i < questions.size(); i++) \\n        {\\n                            \\n               score = questions.at(i).at(0);\\n            \\n               nextIndex = questions.at(i).at(1) + i + 1;\\n  \\n                // cout << \"==================================\" << endl;\\n                // cout << i << \")\" <<\" Score before loop: \" << score << endl;\\n                // cout << \"nextIndex: \"<< nextIndex << endl;\\n                while(nextIndex < questions.size()) {\\n                    score += questions.at(nextIndex).at(0);\\n                    nextIndex += questions.at(nextIndex).at(1) + 1;\\n                    //cout << \"new score while: \" << score << \"with next index now \" << nextIndex << endl;\\n                \\n                }\\n\\n           \\n\\n\\n                if(score > maxScore) \\n                {\\n                    maxScore = score;\\n                   // cout << \"new max score: \" << maxScore << endl;\\n                }\\n      \\n                          \\n        }\\n        \\n        return maxScore;\\n    }"
                    }
                ]
            },
            {
                "id": 1890736,
                "content": [
                    {
                        "username": "dudhaniayush",
                        "content": "How does it feels when second last testcase gives wrong answer :'(\nTestcase 53/54\n\nEDIT: then i realised the dp matrix I was using was of type int, and values were of long long type so changing it got my solution submitted"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Same happened with me XD"
                    },
                    {
                        "username": "9891YKYASH",
                        "content": "us bro us"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "First DP problem I solved it on my own. Just pick and don\\'t pick approach. Nice problem."
                    },
                    {
                        "username": "arghyadas",
                        "content": "53/54 passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivanshbhardwaj989",
                        "content": "[@orunnnegi01](/orunnnegi01) use long long in initialization of dp"
                    },
                    {
                        "username": "oreo_shake",
                        "content": "m getting the same issue with my code tho ive used long long in my code still\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Forgot to use ``` long long ``` my bad\\uD83D\\uDE02"
                    },
                    {
                        "username": "saransh15",
                        "content": "[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]\\nExpected answer: 157, I am getting 123. Can someone tell which questions were solved to get a score of 157?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Has been asnwered multiple times already, read the entire discussion before asking please. Answer is index 1 and 7. ( 92 + 65 )"
                    },
                    {
                        "username": "coder1666",
                        "content": "Classic recursion pattern take it or skip it, then apply dp on it.\nDisclaimer: Don't use much of your brainpower :P"
                    },
                    {
                        "username": "15o1",
                        "content": "Standard 0-1 Knapsack Problem "
                    },
                    {
                        "username": "sumeet14",
                        "content": "Why do I feel like Iamspeed \\n\\nSkip: \\nSkip:\\nwhy does this game feels good bruh \\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "A good DP problem!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Similar to buy and sell stock with cooldown problem\\nTake it or skip it"
                    },
                    {
                        "username": "Aionlasting",
                        "content": "Solution works in codelight, gives correct answer, but not in the online IDE? Using C++ on both. Any input?\\n\\nHere is my code, can uncomment the ccout and see it gives the right answers.\\n\\nlong long mostPoints(vector<vector<int>>& questions) {\\n      \\n        long long maxScore = 0;\\n         unsigned int nextIndex = 0;\\n         long long score = 0;\\n         for(std::size_t i = 0; i < questions.size(); i++) \\n        {\\n                            \\n               score = questions.at(i).at(0);\\n            \\n               nextIndex = questions.at(i).at(1) + i + 1;\\n  \\n                // cout << \"==================================\" << endl;\\n                // cout << i << \")\" <<\" Score before loop: \" << score << endl;\\n                // cout << \"nextIndex: \"<< nextIndex << endl;\\n                while(nextIndex < questions.size()) {\\n                    score += questions.at(nextIndex).at(0);\\n                    nextIndex += questions.at(nextIndex).at(1) + 1;\\n                    //cout << \"new score while: \" << score << \"with next index now \" << nextIndex << endl;\\n                \\n                }\\n\\n           \\n\\n\\n                if(score > maxScore) \\n                {\\n                    maxScore = score;\\n                   // cout << \"new max score: \" << maxScore << endl;\\n                }\\n      \\n                          \\n        }\\n        \\n        return maxScore;\\n    }"
                    }
                ]
            },
            {
                "id": 1991369,
                "content": [
                    {
                        "username": "dudhaniayush",
                        "content": "How does it feels when second last testcase gives wrong answer :'(\nTestcase 53/54\n\nEDIT: then i realised the dp matrix I was using was of type int, and values were of long long type so changing it got my solution submitted"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Same happened with me XD"
                    },
                    {
                        "username": "9891YKYASH",
                        "content": "us bro us"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "First DP problem I solved it on my own. Just pick and don\\'t pick approach. Nice problem."
                    },
                    {
                        "username": "arghyadas",
                        "content": "53/54 passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivanshbhardwaj989",
                        "content": "[@orunnnegi01](/orunnnegi01) use long long in initialization of dp"
                    },
                    {
                        "username": "oreo_shake",
                        "content": "m getting the same issue with my code tho ive used long long in my code still\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Forgot to use ``` long long ``` my bad\\uD83D\\uDE02"
                    },
                    {
                        "username": "saransh15",
                        "content": "[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]\\nExpected answer: 157, I am getting 123. Can someone tell which questions were solved to get a score of 157?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Has been asnwered multiple times already, read the entire discussion before asking please. Answer is index 1 and 7. ( 92 + 65 )"
                    },
                    {
                        "username": "coder1666",
                        "content": "Classic recursion pattern take it or skip it, then apply dp on it.\nDisclaimer: Don't use much of your brainpower :P"
                    },
                    {
                        "username": "15o1",
                        "content": "Standard 0-1 Knapsack Problem "
                    },
                    {
                        "username": "sumeet14",
                        "content": "Why do I feel like Iamspeed \\n\\nSkip: \\nSkip:\\nwhy does this game feels good bruh \\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "A good DP problem!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Similar to buy and sell stock with cooldown problem\\nTake it or skip it"
                    },
                    {
                        "username": "Aionlasting",
                        "content": "Solution works in codelight, gives correct answer, but not in the online IDE? Using C++ on both. Any input?\\n\\nHere is my code, can uncomment the ccout and see it gives the right answers.\\n\\nlong long mostPoints(vector<vector<int>>& questions) {\\n      \\n        long long maxScore = 0;\\n         unsigned int nextIndex = 0;\\n         long long score = 0;\\n         for(std::size_t i = 0; i < questions.size(); i++) \\n        {\\n                            \\n               score = questions.at(i).at(0);\\n            \\n               nextIndex = questions.at(i).at(1) + i + 1;\\n  \\n                // cout << \"==================================\" << endl;\\n                // cout << i << \")\" <<\" Score before loop: \" << score << endl;\\n                // cout << \"nextIndex: \"<< nextIndex << endl;\\n                while(nextIndex < questions.size()) {\\n                    score += questions.at(nextIndex).at(0);\\n                    nextIndex += questions.at(nextIndex).at(1) + 1;\\n                    //cout << \"new score while: \" << score << \"with next index now \" << nextIndex << endl;\\n                \\n                }\\n\\n           \\n\\n\\n                if(score > maxScore) \\n                {\\n                    maxScore = score;\\n                   // cout << \"new max score: \" << maxScore << endl;\\n                }\\n      \\n                          \\n        }\\n        \\n        return maxScore;\\n    }"
                    }
                ]
            },
            {
                "id": 1891554,
                "content": [
                    {
                        "username": "dudhaniayush",
                        "content": "How does it feels when second last testcase gives wrong answer :'(\nTestcase 53/54\n\nEDIT: then i realised the dp matrix I was using was of type int, and values were of long long type so changing it got my solution submitted"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Same happened with me XD"
                    },
                    {
                        "username": "9891YKYASH",
                        "content": "us bro us"
                    },
                    {
                        "username": "Gangeswaran",
                        "content": "First DP problem I solved it on my own. Just pick and don\\'t pick approach. Nice problem."
                    },
                    {
                        "username": "arghyadas",
                        "content": "53/54 passed\\uD83E\\uDD72"
                    },
                    {
                        "username": "shivanshbhardwaj989",
                        "content": "[@orunnnegi01](/orunnnegi01) use long long in initialization of dp"
                    },
                    {
                        "username": "oreo_shake",
                        "content": "m getting the same issue with my code tho ive used long long in my code still\\n"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Forgot to use ``` long long ``` my bad\\uD83D\\uDE02"
                    },
                    {
                        "username": "saransh15",
                        "content": "[[21,5],[92,3],[74,2],[39,4],[58,2],[5,5],[49,4],[65,3]]\\nExpected answer: 157, I am getting 123. Can someone tell which questions were solved to get a score of 157?"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "Has been asnwered multiple times already, read the entire discussion before asking please. Answer is index 1 and 7. ( 92 + 65 )"
                    },
                    {
                        "username": "coder1666",
                        "content": "Classic recursion pattern take it or skip it, then apply dp on it.\nDisclaimer: Don't use much of your brainpower :P"
                    },
                    {
                        "username": "15o1",
                        "content": "Standard 0-1 Knapsack Problem "
                    },
                    {
                        "username": "sumeet14",
                        "content": "Why do I feel like Iamspeed \\n\\nSkip: \\nSkip:\\nwhy does this game feels good bruh \\n"
                    },
                    {
                        "username": "quanqx",
                        "content": "A good DP problem!"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "Similar to buy and sell stock with cooldown problem\\nTake it or skip it"
                    },
                    {
                        "username": "Aionlasting",
                        "content": "Solution works in codelight, gives correct answer, but not in the online IDE? Using C++ on both. Any input?\\n\\nHere is my code, can uncomment the ccout and see it gives the right answers.\\n\\nlong long mostPoints(vector<vector<int>>& questions) {\\n      \\n        long long maxScore = 0;\\n         unsigned int nextIndex = 0;\\n         long long score = 0;\\n         for(std::size_t i = 0; i < questions.size(); i++) \\n        {\\n                            \\n               score = questions.at(i).at(0);\\n            \\n               nextIndex = questions.at(i).at(1) + i + 1;\\n  \\n                // cout << \"==================================\" << endl;\\n                // cout << i << \")\" <<\" Score before loop: \" << score << endl;\\n                // cout << \"nextIndex: \"<< nextIndex << endl;\\n                while(nextIndex < questions.size()) {\\n                    score += questions.at(nextIndex).at(0);\\n                    nextIndex += questions.at(nextIndex).at(1) + 1;\\n                    //cout << \"new score while: \" << score << \"with next index now \" << nextIndex << endl;\\n                \\n                }\\n\\n           \\n\\n\\n                if(score > maxScore) \\n                {\\n                    maxScore = score;\\n                   // cout << \"new max score: \" << maxScore << endl;\\n                }\\n      \\n                          \\n        }\\n        \\n        return maxScore;\\n    }"
                    }
                ]
            },
            {
                "id": 1891517,
                "content": [
                    {
                        "username": "Rajat310",
                        "content": "This is the day of the week where our long long streaks breaks after having easy questions from past few days .."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I think this is a DP week!"
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone plz tell me whats choosing criteria in particular what does it  brainpower for?\n\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Standard DP take/not take problem"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Frog jumppppp"
                    },
                    {
                        "username": "tomhoad03",
                        "content": "keeps failing the final test case expecting to return 5000000000 but returns the integer limit 2147400000, how do I get past this (Java)?"
                    },
                    {
                        "username": "jwonz",
                        "content": "BigInt"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "leetcode trying to show some mercy ;)"
                    },
                    {
                        "username": "kausachan",
                        "content": "who solved it in first try"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "why is this slow? time beats 20%\\n\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& q) {\\n        std::vector<long long> dp(q.size() + 1, 0);\\n        for (int n=q.size() - 1; n>=0; --n) {\\n            int following = q[n][1] + n + 1;\\n            dp[n] = std::max(dp[n + 1], q[n][0] + (following < q.size()? dp[following]: 0ll));\\n        }\\n        return dp[0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "praball",
                        "content": "Damn, this question came in our semester exams this year."
                    }
                ]
            },
            {
                "id": 1891439,
                "content": [
                    {
                        "username": "Rajat310",
                        "content": "This is the day of the week where our long long streaks breaks after having easy questions from past few days .."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I think this is a DP week!"
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone plz tell me whats choosing criteria in particular what does it  brainpower for?\n\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Standard DP take/not take problem"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Frog jumppppp"
                    },
                    {
                        "username": "tomhoad03",
                        "content": "keeps failing the final test case expecting to return 5000000000 but returns the integer limit 2147400000, how do I get past this (Java)?"
                    },
                    {
                        "username": "jwonz",
                        "content": "BigInt"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "leetcode trying to show some mercy ;)"
                    },
                    {
                        "username": "kausachan",
                        "content": "who solved it in first try"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "why is this slow? time beats 20%\\n\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& q) {\\n        std::vector<long long> dp(q.size() + 1, 0);\\n        for (int n=q.size() - 1; n>=0; --n) {\\n            int following = q[n][1] + n + 1;\\n            dp[n] = std::max(dp[n + 1], q[n][0] + (following < q.size()? dp[following]: 0ll));\\n        }\\n        return dp[0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "praball",
                        "content": "Damn, this question came in our semester exams this year."
                    }
                ]
            },
            {
                "id": 1891435,
                "content": [
                    {
                        "username": "Rajat310",
                        "content": "This is the day of the week where our long long streaks breaks after having easy questions from past few days .."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I think this is a DP week!"
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone plz tell me whats choosing criteria in particular what does it  brainpower for?\n\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Standard DP take/not take problem"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Frog jumppppp"
                    },
                    {
                        "username": "tomhoad03",
                        "content": "keeps failing the final test case expecting to return 5000000000 but returns the integer limit 2147400000, how do I get past this (Java)?"
                    },
                    {
                        "username": "jwonz",
                        "content": "BigInt"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "leetcode trying to show some mercy ;)"
                    },
                    {
                        "username": "kausachan",
                        "content": "who solved it in first try"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "why is this slow? time beats 20%\\n\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& q) {\\n        std::vector<long long> dp(q.size() + 1, 0);\\n        for (int n=q.size() - 1; n>=0; --n) {\\n            int following = q[n][1] + n + 1;\\n            dp[n] = std::max(dp[n + 1], q[n][0] + (following < q.size()? dp[following]: 0ll));\\n        }\\n        return dp[0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "praball",
                        "content": "Damn, this question came in our semester exams this year."
                    }
                ]
            },
            {
                "id": 1891350,
                "content": [
                    {
                        "username": "Rajat310",
                        "content": "This is the day of the week where our long long streaks breaks after having easy questions from past few days .."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I think this is a DP week!"
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone plz tell me whats choosing criteria in particular what does it  brainpower for?\n\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Standard DP take/not take problem"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Frog jumppppp"
                    },
                    {
                        "username": "tomhoad03",
                        "content": "keeps failing the final test case expecting to return 5000000000 but returns the integer limit 2147400000, how do I get past this (Java)?"
                    },
                    {
                        "username": "jwonz",
                        "content": "BigInt"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "leetcode trying to show some mercy ;)"
                    },
                    {
                        "username": "kausachan",
                        "content": "who solved it in first try"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "why is this slow? time beats 20%\\n\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& q) {\\n        std::vector<long long> dp(q.size() + 1, 0);\\n        for (int n=q.size() - 1; n>=0; --n) {\\n            int following = q[n][1] + n + 1;\\n            dp[n] = std::max(dp[n + 1], q[n][0] + (following < q.size()? dp[following]: 0ll));\\n        }\\n        return dp[0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "praball",
                        "content": "Damn, this question came in our semester exams this year."
                    }
                ]
            },
            {
                "id": 1891346,
                "content": [
                    {
                        "username": "Rajat310",
                        "content": "This is the day of the week where our long long streaks breaks after having easy questions from past few days .."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I think this is a DP week!"
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone plz tell me whats choosing criteria in particular what does it  brainpower for?\n\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Standard DP take/not take problem"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Frog jumppppp"
                    },
                    {
                        "username": "tomhoad03",
                        "content": "keeps failing the final test case expecting to return 5000000000 but returns the integer limit 2147400000, how do I get past this (Java)?"
                    },
                    {
                        "username": "jwonz",
                        "content": "BigInt"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "leetcode trying to show some mercy ;)"
                    },
                    {
                        "username": "kausachan",
                        "content": "who solved it in first try"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "why is this slow? time beats 20%\\n\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& q) {\\n        std::vector<long long> dp(q.size() + 1, 0);\\n        for (int n=q.size() - 1; n>=0; --n) {\\n            int following = q[n][1] + n + 1;\\n            dp[n] = std::max(dp[n + 1], q[n][0] + (following < q.size()? dp[following]: 0ll));\\n        }\\n        return dp[0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "praball",
                        "content": "Damn, this question came in our semester exams this year."
                    }
                ]
            },
            {
                "id": 1891345,
                "content": [
                    {
                        "username": "Rajat310",
                        "content": "This is the day of the week where our long long streaks breaks after having easy questions from past few days .."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I think this is a DP week!"
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone plz tell me whats choosing criteria in particular what does it  brainpower for?\n\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Standard DP take/not take problem"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Frog jumppppp"
                    },
                    {
                        "username": "tomhoad03",
                        "content": "keeps failing the final test case expecting to return 5000000000 but returns the integer limit 2147400000, how do I get past this (Java)?"
                    },
                    {
                        "username": "jwonz",
                        "content": "BigInt"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "leetcode trying to show some mercy ;)"
                    },
                    {
                        "username": "kausachan",
                        "content": "who solved it in first try"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "why is this slow? time beats 20%\\n\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& q) {\\n        std::vector<long long> dp(q.size() + 1, 0);\\n        for (int n=q.size() - 1; n>=0; --n) {\\n            int following = q[n][1] + n + 1;\\n            dp[n] = std::max(dp[n + 1], q[n][0] + (following < q.size()? dp[following]: 0ll));\\n        }\\n        return dp[0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "praball",
                        "content": "Damn, this question came in our semester exams this year."
                    }
                ]
            },
            {
                "id": 1891336,
                "content": [
                    {
                        "username": "Rajat310",
                        "content": "This is the day of the week where our long long streaks breaks after having easy questions from past few days .."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I think this is a DP week!"
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone plz tell me whats choosing criteria in particular what does it  brainpower for?\n\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Standard DP take/not take problem"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Frog jumppppp"
                    },
                    {
                        "username": "tomhoad03",
                        "content": "keeps failing the final test case expecting to return 5000000000 but returns the integer limit 2147400000, how do I get past this (Java)?"
                    },
                    {
                        "username": "jwonz",
                        "content": "BigInt"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "leetcode trying to show some mercy ;)"
                    },
                    {
                        "username": "kausachan",
                        "content": "who solved it in first try"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "why is this slow? time beats 20%\\n\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& q) {\\n        std::vector<long long> dp(q.size() + 1, 0);\\n        for (int n=q.size() - 1; n>=0; --n) {\\n            int following = q[n][1] + n + 1;\\n            dp[n] = std::max(dp[n + 1], q[n][0] + (following < q.size()? dp[following]: 0ll));\\n        }\\n        return dp[0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "praball",
                        "content": "Damn, this question came in our semester exams this year."
                    }
                ]
            },
            {
                "id": 1891299,
                "content": [
                    {
                        "username": "Rajat310",
                        "content": "This is the day of the week where our long long streaks breaks after having easy questions from past few days .."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I think this is a DP week!"
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone plz tell me whats choosing criteria in particular what does it  brainpower for?\n\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Standard DP take/not take problem"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Frog jumppppp"
                    },
                    {
                        "username": "tomhoad03",
                        "content": "keeps failing the final test case expecting to return 5000000000 but returns the integer limit 2147400000, how do I get past this (Java)?"
                    },
                    {
                        "username": "jwonz",
                        "content": "BigInt"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "leetcode trying to show some mercy ;)"
                    },
                    {
                        "username": "kausachan",
                        "content": "who solved it in first try"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "why is this slow? time beats 20%\\n\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& q) {\\n        std::vector<long long> dp(q.size() + 1, 0);\\n        for (int n=q.size() - 1; n>=0; --n) {\\n            int following = q[n][1] + n + 1;\\n            dp[n] = std::max(dp[n + 1], q[n][0] + (following < q.size()? dp[following]: 0ll));\\n        }\\n        return dp[0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "praball",
                        "content": "Damn, this question came in our semester exams this year."
                    }
                ]
            },
            {
                "id": 1891288,
                "content": [
                    {
                        "username": "Rajat310",
                        "content": "This is the day of the week where our long long streaks breaks after having easy questions from past few days .."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I think this is a DP week!"
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone plz tell me whats choosing criteria in particular what does it  brainpower for?\n\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Standard DP take/not take problem"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Frog jumppppp"
                    },
                    {
                        "username": "tomhoad03",
                        "content": "keeps failing the final test case expecting to return 5000000000 but returns the integer limit 2147400000, how do I get past this (Java)?"
                    },
                    {
                        "username": "jwonz",
                        "content": "BigInt"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "leetcode trying to show some mercy ;)"
                    },
                    {
                        "username": "kausachan",
                        "content": "who solved it in first try"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "why is this slow? time beats 20%\\n\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& q) {\\n        std::vector<long long> dp(q.size() + 1, 0);\\n        for (int n=q.size() - 1; n>=0; --n) {\\n            int following = q[n][1] + n + 1;\\n            dp[n] = std::max(dp[n + 1], q[n][0] + (following < q.size()? dp[following]: 0ll));\\n        }\\n        return dp[0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "praball",
                        "content": "Damn, this question came in our semester exams this year."
                    }
                ]
            },
            {
                "id": 1891281,
                "content": [
                    {
                        "username": "Rajat310",
                        "content": "This is the day of the week where our long long streaks breaks after having easy questions from past few days .."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "I think this is a DP week!"
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone plz tell me whats choosing criteria in particular what does it  brainpower for?\n\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "Standard DP take/not take problem"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Frog jumppppp"
                    },
                    {
                        "username": "tomhoad03",
                        "content": "keeps failing the final test case expecting to return 5000000000 but returns the integer limit 2147400000, how do I get past this (Java)?"
                    },
                    {
                        "username": "jwonz",
                        "content": "BigInt"
                    },
                    {
                        "username": "shivaagarwal2000",
                        "content": "leetcode trying to show some mercy ;)"
                    },
                    {
                        "username": "kausachan",
                        "content": "who solved it in first try"
                    },
                    {
                        "username": "epiciskandar",
                        "content": "why is this slow? time beats 20%\\n\\n```\\nclass Solution {\\npublic:\\n    long long mostPoints(vector<vector<int>>& q) {\\n        std::vector<long long> dp(q.size() + 1, 0);\\n        for (int n=q.size() - 1; n>=0; --n) {\\n            int following = q[n][1] + n + 1;\\n            dp[n] = std::max(dp[n + 1], q[n][0] + (following < q.size()? dp[following]: 0ll));\\n        }\\n        return dp[0];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "praball",
                        "content": "Damn, this question came in our semester exams this year."
                    }
                ]
            },
            {
                "id": 1891236,
                "content": [
                    {
                        "username": "parashirenmehta",
                        "content": "My solution works in Spyder, but the same code shows \\'Wrong Answer\\' when I paste it in LeetCode. Can anyone point out why this is happening?\\n\\n`d = {}`\\n`def points(currindex,currpoints):`\\n\\n    if currindex>=len(ques):\\n        return currpoints\\n\\n    if (currindex+1,currpoints) in d.keys():\\n        points1 = d[(currindex+1,currpoints)]\\n\\n    else:\\n        points1 = points(currindex+1,currpoints)\\n        d[(currindex+1,currpoints)] = points1        \\n\\n    if (currindex+ques[currindex][1]+1,currpoints+ques[currindex][0]) in d.keys():\\n        points2 = d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])]\\n\\n    else:\\n        points2 = points(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])\\n        d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])] = points2\\n\\n    return max(points1,points2)\\n\\nclass Solution:\\n\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        global ques \\n        ques = questions[:]\\n        maxpoints = points(0,0)\\n        return maxpoints\\n\\nKindly let me know what I should change to make it run. Thanks!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "still causes TLE on 42/54"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "since d = {} is global, it is used in every testcase as the same object and so it will have values of previous testcases. \\nRemove it from outside and use `global d\\n        d= {}` in mostPoints function"
                    },
                    {
                        "username": "GD18",
                        "content": "somewhat similar to yesterday\\'s approach to the problem, you can use Memoization/DP to solve it."
                    },
                    {
                        "username": "Mamun_71",
                        "content": "State : In every index i have 2 choices.If i should choose\\n                or not choose whcih give maximum points.\\n\\n                choice 1 : if take then my ponts will be\\n                points1=arr[i][1]+(Skip the brainpowers count \\n                number of question)\\n\\n                choice 2 : skip this qustion next qustion will be\\n                new state.\\n                points2=solve Next qustions \\n\\n                every state\\'s result maximum(choice1,choice2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Is it really `medium` question? I am passing `Dynamic Programming I` study plan now and most `medium` question from there are much harder. I hope this study plan just made me better :) "
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "vector<int>dp(100001,-1);\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        return 0;\\n    }\\n\\ncould someone tell why iam this getting this error when i declare dp vector globally\\n\\nCOMPILER ERROR:-_______________\\nLine 3: Char 19: error: expected parameter declarator\\n    vector<int>dp(100001,-1);\\n\\n"
                    },
                    {
                        "username": "jga111",
                        "content": "Step 1: Work out the solution space. (Hint: it\\'s dynamic programming)\\nStep 2: Ok - we need a base case. What is it?....(Hint: for me, it was easy when I thought of the last question)\\nOnce you know the base case, you can work from there and devise your transition function - so I worked backwards\\n\\nI think this is a good medium"
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "[[12,46],[78,19],[63,15],[79,62],[13,10]]\\nOutput\\n91\\nExpected\\n79\\nanybody pls make me understand this test case\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since each brain power member is larger than the array size, you can only answer 1 question. 79 it is."
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "since brainpower values are more than the array size, then  if you pick any of the index that should be the answer , so we should choose ultimately the question which have highest point which is 79 \nSo that would be the expected ans , you might need check your algo you are doing it wrong somewhere\ncheck your base case \n"
                    },
                    {
                        "username": "nguyennhuhung72",
                        "content": "How can u calculate it to 91? You can just choose one of this and it just be 79."
                    },
                    {
                        "username": "ankit_r",
                        "content": "input = [[12,46],[78,19],[63,15],[79,62],[13,10]]\\nwhy the output of this input is 79.\\ncan anyone help me out.\\nmy answer is 91."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "see if you try to solve any of the question given in this array you cant solve any extra question as the power for any of the question is greater then the size of the 2D array. So the moment you solve any particular question you will be out of array so, to maximize the array solve the question which is having max points.\\ni.e 79 so the answer is 79.\\nHope this helps you understand. "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "someone : which season is going on ??\\nme : it\\'s DP season :-)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Hope ,u will survive."
                    }
                ]
            },
            {
                "id": 1891230,
                "content": [
                    {
                        "username": "parashirenmehta",
                        "content": "My solution works in Spyder, but the same code shows \\'Wrong Answer\\' when I paste it in LeetCode. Can anyone point out why this is happening?\\n\\n`d = {}`\\n`def points(currindex,currpoints):`\\n\\n    if currindex>=len(ques):\\n        return currpoints\\n\\n    if (currindex+1,currpoints) in d.keys():\\n        points1 = d[(currindex+1,currpoints)]\\n\\n    else:\\n        points1 = points(currindex+1,currpoints)\\n        d[(currindex+1,currpoints)] = points1        \\n\\n    if (currindex+ques[currindex][1]+1,currpoints+ques[currindex][0]) in d.keys():\\n        points2 = d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])]\\n\\n    else:\\n        points2 = points(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])\\n        d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])] = points2\\n\\n    return max(points1,points2)\\n\\nclass Solution:\\n\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        global ques \\n        ques = questions[:]\\n        maxpoints = points(0,0)\\n        return maxpoints\\n\\nKindly let me know what I should change to make it run. Thanks!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "still causes TLE on 42/54"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "since d = {} is global, it is used in every testcase as the same object and so it will have values of previous testcases. \\nRemove it from outside and use `global d\\n        d= {}` in mostPoints function"
                    },
                    {
                        "username": "GD18",
                        "content": "somewhat similar to yesterday\\'s approach to the problem, you can use Memoization/DP to solve it."
                    },
                    {
                        "username": "Mamun_71",
                        "content": "State : In every index i have 2 choices.If i should choose\\n                or not choose whcih give maximum points.\\n\\n                choice 1 : if take then my ponts will be\\n                points1=arr[i][1]+(Skip the brainpowers count \\n                number of question)\\n\\n                choice 2 : skip this qustion next qustion will be\\n                new state.\\n                points2=solve Next qustions \\n\\n                every state\\'s result maximum(choice1,choice2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Is it really `medium` question? I am passing `Dynamic Programming I` study plan now and most `medium` question from there are much harder. I hope this study plan just made me better :) "
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "vector<int>dp(100001,-1);\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        return 0;\\n    }\\n\\ncould someone tell why iam this getting this error when i declare dp vector globally\\n\\nCOMPILER ERROR:-_______________\\nLine 3: Char 19: error: expected parameter declarator\\n    vector<int>dp(100001,-1);\\n\\n"
                    },
                    {
                        "username": "jga111",
                        "content": "Step 1: Work out the solution space. (Hint: it\\'s dynamic programming)\\nStep 2: Ok - we need a base case. What is it?....(Hint: for me, it was easy when I thought of the last question)\\nOnce you know the base case, you can work from there and devise your transition function - so I worked backwards\\n\\nI think this is a good medium"
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "[[12,46],[78,19],[63,15],[79,62],[13,10]]\\nOutput\\n91\\nExpected\\n79\\nanybody pls make me understand this test case\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since each brain power member is larger than the array size, you can only answer 1 question. 79 it is."
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "since brainpower values are more than the array size, then  if you pick any of the index that should be the answer , so we should choose ultimately the question which have highest point which is 79 \nSo that would be the expected ans , you might need check your algo you are doing it wrong somewhere\ncheck your base case \n"
                    },
                    {
                        "username": "nguyennhuhung72",
                        "content": "How can u calculate it to 91? You can just choose one of this and it just be 79."
                    },
                    {
                        "username": "ankit_r",
                        "content": "input = [[12,46],[78,19],[63,15],[79,62],[13,10]]\\nwhy the output of this input is 79.\\ncan anyone help me out.\\nmy answer is 91."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "see if you try to solve any of the question given in this array you cant solve any extra question as the power for any of the question is greater then the size of the 2D array. So the moment you solve any particular question you will be out of array so, to maximize the array solve the question which is having max points.\\ni.e 79 so the answer is 79.\\nHope this helps you understand. "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "someone : which season is going on ??\\nme : it\\'s DP season :-)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Hope ,u will survive."
                    }
                ]
            },
            {
                "id": 1891115,
                "content": [
                    {
                        "username": "parashirenmehta",
                        "content": "My solution works in Spyder, but the same code shows \\'Wrong Answer\\' when I paste it in LeetCode. Can anyone point out why this is happening?\\n\\n`d = {}`\\n`def points(currindex,currpoints):`\\n\\n    if currindex>=len(ques):\\n        return currpoints\\n\\n    if (currindex+1,currpoints) in d.keys():\\n        points1 = d[(currindex+1,currpoints)]\\n\\n    else:\\n        points1 = points(currindex+1,currpoints)\\n        d[(currindex+1,currpoints)] = points1        \\n\\n    if (currindex+ques[currindex][1]+1,currpoints+ques[currindex][0]) in d.keys():\\n        points2 = d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])]\\n\\n    else:\\n        points2 = points(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])\\n        d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])] = points2\\n\\n    return max(points1,points2)\\n\\nclass Solution:\\n\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        global ques \\n        ques = questions[:]\\n        maxpoints = points(0,0)\\n        return maxpoints\\n\\nKindly let me know what I should change to make it run. Thanks!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "still causes TLE on 42/54"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "since d = {} is global, it is used in every testcase as the same object and so it will have values of previous testcases. \\nRemove it from outside and use `global d\\n        d= {}` in mostPoints function"
                    },
                    {
                        "username": "GD18",
                        "content": "somewhat similar to yesterday\\'s approach to the problem, you can use Memoization/DP to solve it."
                    },
                    {
                        "username": "Mamun_71",
                        "content": "State : In every index i have 2 choices.If i should choose\\n                or not choose whcih give maximum points.\\n\\n                choice 1 : if take then my ponts will be\\n                points1=arr[i][1]+(Skip the brainpowers count \\n                number of question)\\n\\n                choice 2 : skip this qustion next qustion will be\\n                new state.\\n                points2=solve Next qustions \\n\\n                every state\\'s result maximum(choice1,choice2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Is it really `medium` question? I am passing `Dynamic Programming I` study plan now and most `medium` question from there are much harder. I hope this study plan just made me better :) "
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "vector<int>dp(100001,-1);\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        return 0;\\n    }\\n\\ncould someone tell why iam this getting this error when i declare dp vector globally\\n\\nCOMPILER ERROR:-_______________\\nLine 3: Char 19: error: expected parameter declarator\\n    vector<int>dp(100001,-1);\\n\\n"
                    },
                    {
                        "username": "jga111",
                        "content": "Step 1: Work out the solution space. (Hint: it\\'s dynamic programming)\\nStep 2: Ok - we need a base case. What is it?....(Hint: for me, it was easy when I thought of the last question)\\nOnce you know the base case, you can work from there and devise your transition function - so I worked backwards\\n\\nI think this is a good medium"
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "[[12,46],[78,19],[63,15],[79,62],[13,10]]\\nOutput\\n91\\nExpected\\n79\\nanybody pls make me understand this test case\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since each brain power member is larger than the array size, you can only answer 1 question. 79 it is."
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "since brainpower values are more than the array size, then  if you pick any of the index that should be the answer , so we should choose ultimately the question which have highest point which is 79 \nSo that would be the expected ans , you might need check your algo you are doing it wrong somewhere\ncheck your base case \n"
                    },
                    {
                        "username": "nguyennhuhung72",
                        "content": "How can u calculate it to 91? You can just choose one of this and it just be 79."
                    },
                    {
                        "username": "ankit_r",
                        "content": "input = [[12,46],[78,19],[63,15],[79,62],[13,10]]\\nwhy the output of this input is 79.\\ncan anyone help me out.\\nmy answer is 91."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "see if you try to solve any of the question given in this array you cant solve any extra question as the power for any of the question is greater then the size of the 2D array. So the moment you solve any particular question you will be out of array so, to maximize the array solve the question which is having max points.\\ni.e 79 so the answer is 79.\\nHope this helps you understand. "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "someone : which season is going on ??\\nme : it\\'s DP season :-)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Hope ,u will survive."
                    }
                ]
            },
            {
                "id": 1891112,
                "content": [
                    {
                        "username": "parashirenmehta",
                        "content": "My solution works in Spyder, but the same code shows \\'Wrong Answer\\' when I paste it in LeetCode. Can anyone point out why this is happening?\\n\\n`d = {}`\\n`def points(currindex,currpoints):`\\n\\n    if currindex>=len(ques):\\n        return currpoints\\n\\n    if (currindex+1,currpoints) in d.keys():\\n        points1 = d[(currindex+1,currpoints)]\\n\\n    else:\\n        points1 = points(currindex+1,currpoints)\\n        d[(currindex+1,currpoints)] = points1        \\n\\n    if (currindex+ques[currindex][1]+1,currpoints+ques[currindex][0]) in d.keys():\\n        points2 = d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])]\\n\\n    else:\\n        points2 = points(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])\\n        d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])] = points2\\n\\n    return max(points1,points2)\\n\\nclass Solution:\\n\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        global ques \\n        ques = questions[:]\\n        maxpoints = points(0,0)\\n        return maxpoints\\n\\nKindly let me know what I should change to make it run. Thanks!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "still causes TLE on 42/54"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "since d = {} is global, it is used in every testcase as the same object and so it will have values of previous testcases. \\nRemove it from outside and use `global d\\n        d= {}` in mostPoints function"
                    },
                    {
                        "username": "GD18",
                        "content": "somewhat similar to yesterday\\'s approach to the problem, you can use Memoization/DP to solve it."
                    },
                    {
                        "username": "Mamun_71",
                        "content": "State : In every index i have 2 choices.If i should choose\\n                or not choose whcih give maximum points.\\n\\n                choice 1 : if take then my ponts will be\\n                points1=arr[i][1]+(Skip the brainpowers count \\n                number of question)\\n\\n                choice 2 : skip this qustion next qustion will be\\n                new state.\\n                points2=solve Next qustions \\n\\n                every state\\'s result maximum(choice1,choice2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Is it really `medium` question? I am passing `Dynamic Programming I` study plan now and most `medium` question from there are much harder. I hope this study plan just made me better :) "
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "vector<int>dp(100001,-1);\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        return 0;\\n    }\\n\\ncould someone tell why iam this getting this error when i declare dp vector globally\\n\\nCOMPILER ERROR:-_______________\\nLine 3: Char 19: error: expected parameter declarator\\n    vector<int>dp(100001,-1);\\n\\n"
                    },
                    {
                        "username": "jga111",
                        "content": "Step 1: Work out the solution space. (Hint: it\\'s dynamic programming)\\nStep 2: Ok - we need a base case. What is it?....(Hint: for me, it was easy when I thought of the last question)\\nOnce you know the base case, you can work from there and devise your transition function - so I worked backwards\\n\\nI think this is a good medium"
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "[[12,46],[78,19],[63,15],[79,62],[13,10]]\\nOutput\\n91\\nExpected\\n79\\nanybody pls make me understand this test case\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since each brain power member is larger than the array size, you can only answer 1 question. 79 it is."
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "since brainpower values are more than the array size, then  if you pick any of the index that should be the answer , so we should choose ultimately the question which have highest point which is 79 \nSo that would be the expected ans , you might need check your algo you are doing it wrong somewhere\ncheck your base case \n"
                    },
                    {
                        "username": "nguyennhuhung72",
                        "content": "How can u calculate it to 91? You can just choose one of this and it just be 79."
                    },
                    {
                        "username": "ankit_r",
                        "content": "input = [[12,46],[78,19],[63,15],[79,62],[13,10]]\\nwhy the output of this input is 79.\\ncan anyone help me out.\\nmy answer is 91."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "see if you try to solve any of the question given in this array you cant solve any extra question as the power for any of the question is greater then the size of the 2D array. So the moment you solve any particular question you will be out of array so, to maximize the array solve the question which is having max points.\\ni.e 79 so the answer is 79.\\nHope this helps you understand. "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "someone : which season is going on ??\\nme : it\\'s DP season :-)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Hope ,u will survive."
                    }
                ]
            },
            {
                "id": 1891087,
                "content": [
                    {
                        "username": "parashirenmehta",
                        "content": "My solution works in Spyder, but the same code shows \\'Wrong Answer\\' when I paste it in LeetCode. Can anyone point out why this is happening?\\n\\n`d = {}`\\n`def points(currindex,currpoints):`\\n\\n    if currindex>=len(ques):\\n        return currpoints\\n\\n    if (currindex+1,currpoints) in d.keys():\\n        points1 = d[(currindex+1,currpoints)]\\n\\n    else:\\n        points1 = points(currindex+1,currpoints)\\n        d[(currindex+1,currpoints)] = points1        \\n\\n    if (currindex+ques[currindex][1]+1,currpoints+ques[currindex][0]) in d.keys():\\n        points2 = d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])]\\n\\n    else:\\n        points2 = points(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])\\n        d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])] = points2\\n\\n    return max(points1,points2)\\n\\nclass Solution:\\n\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        global ques \\n        ques = questions[:]\\n        maxpoints = points(0,0)\\n        return maxpoints\\n\\nKindly let me know what I should change to make it run. Thanks!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "still causes TLE on 42/54"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "since d = {} is global, it is used in every testcase as the same object and so it will have values of previous testcases. \\nRemove it from outside and use `global d\\n        d= {}` in mostPoints function"
                    },
                    {
                        "username": "GD18",
                        "content": "somewhat similar to yesterday\\'s approach to the problem, you can use Memoization/DP to solve it."
                    },
                    {
                        "username": "Mamun_71",
                        "content": "State : In every index i have 2 choices.If i should choose\\n                or not choose whcih give maximum points.\\n\\n                choice 1 : if take then my ponts will be\\n                points1=arr[i][1]+(Skip the brainpowers count \\n                number of question)\\n\\n                choice 2 : skip this qustion next qustion will be\\n                new state.\\n                points2=solve Next qustions \\n\\n                every state\\'s result maximum(choice1,choice2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Is it really `medium` question? I am passing `Dynamic Programming I` study plan now and most `medium` question from there are much harder. I hope this study plan just made me better :) "
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "vector<int>dp(100001,-1);\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        return 0;\\n    }\\n\\ncould someone tell why iam this getting this error when i declare dp vector globally\\n\\nCOMPILER ERROR:-_______________\\nLine 3: Char 19: error: expected parameter declarator\\n    vector<int>dp(100001,-1);\\n\\n"
                    },
                    {
                        "username": "jga111",
                        "content": "Step 1: Work out the solution space. (Hint: it\\'s dynamic programming)\\nStep 2: Ok - we need a base case. What is it?....(Hint: for me, it was easy when I thought of the last question)\\nOnce you know the base case, you can work from there and devise your transition function - so I worked backwards\\n\\nI think this is a good medium"
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "[[12,46],[78,19],[63,15],[79,62],[13,10]]\\nOutput\\n91\\nExpected\\n79\\nanybody pls make me understand this test case\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since each brain power member is larger than the array size, you can only answer 1 question. 79 it is."
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "since brainpower values are more than the array size, then  if you pick any of the index that should be the answer , so we should choose ultimately the question which have highest point which is 79 \nSo that would be the expected ans , you might need check your algo you are doing it wrong somewhere\ncheck your base case \n"
                    },
                    {
                        "username": "nguyennhuhung72",
                        "content": "How can u calculate it to 91? You can just choose one of this and it just be 79."
                    },
                    {
                        "username": "ankit_r",
                        "content": "input = [[12,46],[78,19],[63,15],[79,62],[13,10]]\\nwhy the output of this input is 79.\\ncan anyone help me out.\\nmy answer is 91."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "see if you try to solve any of the question given in this array you cant solve any extra question as the power for any of the question is greater then the size of the 2D array. So the moment you solve any particular question you will be out of array so, to maximize the array solve the question which is having max points.\\ni.e 79 so the answer is 79.\\nHope this helps you understand. "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "someone : which season is going on ??\\nme : it\\'s DP season :-)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Hope ,u will survive."
                    }
                ]
            },
            {
                "id": 1891033,
                "content": [
                    {
                        "username": "parashirenmehta",
                        "content": "My solution works in Spyder, but the same code shows \\'Wrong Answer\\' when I paste it in LeetCode. Can anyone point out why this is happening?\\n\\n`d = {}`\\n`def points(currindex,currpoints):`\\n\\n    if currindex>=len(ques):\\n        return currpoints\\n\\n    if (currindex+1,currpoints) in d.keys():\\n        points1 = d[(currindex+1,currpoints)]\\n\\n    else:\\n        points1 = points(currindex+1,currpoints)\\n        d[(currindex+1,currpoints)] = points1        \\n\\n    if (currindex+ques[currindex][1]+1,currpoints+ques[currindex][0]) in d.keys():\\n        points2 = d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])]\\n\\n    else:\\n        points2 = points(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])\\n        d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])] = points2\\n\\n    return max(points1,points2)\\n\\nclass Solution:\\n\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        global ques \\n        ques = questions[:]\\n        maxpoints = points(0,0)\\n        return maxpoints\\n\\nKindly let me know what I should change to make it run. Thanks!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "still causes TLE on 42/54"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "since d = {} is global, it is used in every testcase as the same object and so it will have values of previous testcases. \\nRemove it from outside and use `global d\\n        d= {}` in mostPoints function"
                    },
                    {
                        "username": "GD18",
                        "content": "somewhat similar to yesterday\\'s approach to the problem, you can use Memoization/DP to solve it."
                    },
                    {
                        "username": "Mamun_71",
                        "content": "State : In every index i have 2 choices.If i should choose\\n                or not choose whcih give maximum points.\\n\\n                choice 1 : if take then my ponts will be\\n                points1=arr[i][1]+(Skip the brainpowers count \\n                number of question)\\n\\n                choice 2 : skip this qustion next qustion will be\\n                new state.\\n                points2=solve Next qustions \\n\\n                every state\\'s result maximum(choice1,choice2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Is it really `medium` question? I am passing `Dynamic Programming I` study plan now and most `medium` question from there are much harder. I hope this study plan just made me better :) "
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "vector<int>dp(100001,-1);\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        return 0;\\n    }\\n\\ncould someone tell why iam this getting this error when i declare dp vector globally\\n\\nCOMPILER ERROR:-_______________\\nLine 3: Char 19: error: expected parameter declarator\\n    vector<int>dp(100001,-1);\\n\\n"
                    },
                    {
                        "username": "jga111",
                        "content": "Step 1: Work out the solution space. (Hint: it\\'s dynamic programming)\\nStep 2: Ok - we need a base case. What is it?....(Hint: for me, it was easy when I thought of the last question)\\nOnce you know the base case, you can work from there and devise your transition function - so I worked backwards\\n\\nI think this is a good medium"
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "[[12,46],[78,19],[63,15],[79,62],[13,10]]\\nOutput\\n91\\nExpected\\n79\\nanybody pls make me understand this test case\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since each brain power member is larger than the array size, you can only answer 1 question. 79 it is."
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "since brainpower values are more than the array size, then  if you pick any of the index that should be the answer , so we should choose ultimately the question which have highest point which is 79 \nSo that would be the expected ans , you might need check your algo you are doing it wrong somewhere\ncheck your base case \n"
                    },
                    {
                        "username": "nguyennhuhung72",
                        "content": "How can u calculate it to 91? You can just choose one of this and it just be 79."
                    },
                    {
                        "username": "ankit_r",
                        "content": "input = [[12,46],[78,19],[63,15],[79,62],[13,10]]\\nwhy the output of this input is 79.\\ncan anyone help me out.\\nmy answer is 91."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "see if you try to solve any of the question given in this array you cant solve any extra question as the power for any of the question is greater then the size of the 2D array. So the moment you solve any particular question you will be out of array so, to maximize the array solve the question which is having max points.\\ni.e 79 so the answer is 79.\\nHope this helps you understand. "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "someone : which season is going on ??\\nme : it\\'s DP season :-)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Hope ,u will survive."
                    }
                ]
            },
            {
                "id": 1891023,
                "content": [
                    {
                        "username": "parashirenmehta",
                        "content": "My solution works in Spyder, but the same code shows \\'Wrong Answer\\' when I paste it in LeetCode. Can anyone point out why this is happening?\\n\\n`d = {}`\\n`def points(currindex,currpoints):`\\n\\n    if currindex>=len(ques):\\n        return currpoints\\n\\n    if (currindex+1,currpoints) in d.keys():\\n        points1 = d[(currindex+1,currpoints)]\\n\\n    else:\\n        points1 = points(currindex+1,currpoints)\\n        d[(currindex+1,currpoints)] = points1        \\n\\n    if (currindex+ques[currindex][1]+1,currpoints+ques[currindex][0]) in d.keys():\\n        points2 = d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])]\\n\\n    else:\\n        points2 = points(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])\\n        d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])] = points2\\n\\n    return max(points1,points2)\\n\\nclass Solution:\\n\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        global ques \\n        ques = questions[:]\\n        maxpoints = points(0,0)\\n        return maxpoints\\n\\nKindly let me know what I should change to make it run. Thanks!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "still causes TLE on 42/54"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "since d = {} is global, it is used in every testcase as the same object and so it will have values of previous testcases. \\nRemove it from outside and use `global d\\n        d= {}` in mostPoints function"
                    },
                    {
                        "username": "GD18",
                        "content": "somewhat similar to yesterday\\'s approach to the problem, you can use Memoization/DP to solve it."
                    },
                    {
                        "username": "Mamun_71",
                        "content": "State : In every index i have 2 choices.If i should choose\\n                or not choose whcih give maximum points.\\n\\n                choice 1 : if take then my ponts will be\\n                points1=arr[i][1]+(Skip the brainpowers count \\n                number of question)\\n\\n                choice 2 : skip this qustion next qustion will be\\n                new state.\\n                points2=solve Next qustions \\n\\n                every state\\'s result maximum(choice1,choice2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Is it really `medium` question? I am passing `Dynamic Programming I` study plan now and most `medium` question from there are much harder. I hope this study plan just made me better :) "
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "vector<int>dp(100001,-1);\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        return 0;\\n    }\\n\\ncould someone tell why iam this getting this error when i declare dp vector globally\\n\\nCOMPILER ERROR:-_______________\\nLine 3: Char 19: error: expected parameter declarator\\n    vector<int>dp(100001,-1);\\n\\n"
                    },
                    {
                        "username": "jga111",
                        "content": "Step 1: Work out the solution space. (Hint: it\\'s dynamic programming)\\nStep 2: Ok - we need a base case. What is it?....(Hint: for me, it was easy when I thought of the last question)\\nOnce you know the base case, you can work from there and devise your transition function - so I worked backwards\\n\\nI think this is a good medium"
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "[[12,46],[78,19],[63,15],[79,62],[13,10]]\\nOutput\\n91\\nExpected\\n79\\nanybody pls make me understand this test case\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since each brain power member is larger than the array size, you can only answer 1 question. 79 it is."
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "since brainpower values are more than the array size, then  if you pick any of the index that should be the answer , so we should choose ultimately the question which have highest point which is 79 \nSo that would be the expected ans , you might need check your algo you are doing it wrong somewhere\ncheck your base case \n"
                    },
                    {
                        "username": "nguyennhuhung72",
                        "content": "How can u calculate it to 91? You can just choose one of this and it just be 79."
                    },
                    {
                        "username": "ankit_r",
                        "content": "input = [[12,46],[78,19],[63,15],[79,62],[13,10]]\\nwhy the output of this input is 79.\\ncan anyone help me out.\\nmy answer is 91."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "see if you try to solve any of the question given in this array you cant solve any extra question as the power for any of the question is greater then the size of the 2D array. So the moment you solve any particular question you will be out of array so, to maximize the array solve the question which is having max points.\\ni.e 79 so the answer is 79.\\nHope this helps you understand. "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "someone : which season is going on ??\\nme : it\\'s DP season :-)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Hope ,u will survive."
                    }
                ]
            },
            {
                "id": 1890985,
                "content": [
                    {
                        "username": "parashirenmehta",
                        "content": "My solution works in Spyder, but the same code shows \\'Wrong Answer\\' when I paste it in LeetCode. Can anyone point out why this is happening?\\n\\n`d = {}`\\n`def points(currindex,currpoints):`\\n\\n    if currindex>=len(ques):\\n        return currpoints\\n\\n    if (currindex+1,currpoints) in d.keys():\\n        points1 = d[(currindex+1,currpoints)]\\n\\n    else:\\n        points1 = points(currindex+1,currpoints)\\n        d[(currindex+1,currpoints)] = points1        \\n\\n    if (currindex+ques[currindex][1]+1,currpoints+ques[currindex][0]) in d.keys():\\n        points2 = d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])]\\n\\n    else:\\n        points2 = points(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])\\n        d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])] = points2\\n\\n    return max(points1,points2)\\n\\nclass Solution:\\n\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        global ques \\n        ques = questions[:]\\n        maxpoints = points(0,0)\\n        return maxpoints\\n\\nKindly let me know what I should change to make it run. Thanks!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "still causes TLE on 42/54"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "since d = {} is global, it is used in every testcase as the same object and so it will have values of previous testcases. \\nRemove it from outside and use `global d\\n        d= {}` in mostPoints function"
                    },
                    {
                        "username": "GD18",
                        "content": "somewhat similar to yesterday\\'s approach to the problem, you can use Memoization/DP to solve it."
                    },
                    {
                        "username": "Mamun_71",
                        "content": "State : In every index i have 2 choices.If i should choose\\n                or not choose whcih give maximum points.\\n\\n                choice 1 : if take then my ponts will be\\n                points1=arr[i][1]+(Skip the brainpowers count \\n                number of question)\\n\\n                choice 2 : skip this qustion next qustion will be\\n                new state.\\n                points2=solve Next qustions \\n\\n                every state\\'s result maximum(choice1,choice2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Is it really `medium` question? I am passing `Dynamic Programming I` study plan now and most `medium` question from there are much harder. I hope this study plan just made me better :) "
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "vector<int>dp(100001,-1);\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        return 0;\\n    }\\n\\ncould someone tell why iam this getting this error when i declare dp vector globally\\n\\nCOMPILER ERROR:-_______________\\nLine 3: Char 19: error: expected parameter declarator\\n    vector<int>dp(100001,-1);\\n\\n"
                    },
                    {
                        "username": "jga111",
                        "content": "Step 1: Work out the solution space. (Hint: it\\'s dynamic programming)\\nStep 2: Ok - we need a base case. What is it?....(Hint: for me, it was easy when I thought of the last question)\\nOnce you know the base case, you can work from there and devise your transition function - so I worked backwards\\n\\nI think this is a good medium"
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "[[12,46],[78,19],[63,15],[79,62],[13,10]]\\nOutput\\n91\\nExpected\\n79\\nanybody pls make me understand this test case\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since each brain power member is larger than the array size, you can only answer 1 question. 79 it is."
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "since brainpower values are more than the array size, then  if you pick any of the index that should be the answer , so we should choose ultimately the question which have highest point which is 79 \nSo that would be the expected ans , you might need check your algo you are doing it wrong somewhere\ncheck your base case \n"
                    },
                    {
                        "username": "nguyennhuhung72",
                        "content": "How can u calculate it to 91? You can just choose one of this and it just be 79."
                    },
                    {
                        "username": "ankit_r",
                        "content": "input = [[12,46],[78,19],[63,15],[79,62],[13,10]]\\nwhy the output of this input is 79.\\ncan anyone help me out.\\nmy answer is 91."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "see if you try to solve any of the question given in this array you cant solve any extra question as the power for any of the question is greater then the size of the 2D array. So the moment you solve any particular question you will be out of array so, to maximize the array solve the question which is having max points.\\ni.e 79 so the answer is 79.\\nHope this helps you understand. "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "someone : which season is going on ??\\nme : it\\'s DP season :-)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Hope ,u will survive."
                    }
                ]
            },
            {
                "id": 1890941,
                "content": [
                    {
                        "username": "parashirenmehta",
                        "content": "My solution works in Spyder, but the same code shows \\'Wrong Answer\\' when I paste it in LeetCode. Can anyone point out why this is happening?\\n\\n`d = {}`\\n`def points(currindex,currpoints):`\\n\\n    if currindex>=len(ques):\\n        return currpoints\\n\\n    if (currindex+1,currpoints) in d.keys():\\n        points1 = d[(currindex+1,currpoints)]\\n\\n    else:\\n        points1 = points(currindex+1,currpoints)\\n        d[(currindex+1,currpoints)] = points1        \\n\\n    if (currindex+ques[currindex][1]+1,currpoints+ques[currindex][0]) in d.keys():\\n        points2 = d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])]\\n\\n    else:\\n        points2 = points(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])\\n        d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])] = points2\\n\\n    return max(points1,points2)\\n\\nclass Solution:\\n\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        global ques \\n        ques = questions[:]\\n        maxpoints = points(0,0)\\n        return maxpoints\\n\\nKindly let me know what I should change to make it run. Thanks!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "still causes TLE on 42/54"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "since d = {} is global, it is used in every testcase as the same object and so it will have values of previous testcases. \\nRemove it from outside and use `global d\\n        d= {}` in mostPoints function"
                    },
                    {
                        "username": "GD18",
                        "content": "somewhat similar to yesterday\\'s approach to the problem, you can use Memoization/DP to solve it."
                    },
                    {
                        "username": "Mamun_71",
                        "content": "State : In every index i have 2 choices.If i should choose\\n                or not choose whcih give maximum points.\\n\\n                choice 1 : if take then my ponts will be\\n                points1=arr[i][1]+(Skip the brainpowers count \\n                number of question)\\n\\n                choice 2 : skip this qustion next qustion will be\\n                new state.\\n                points2=solve Next qustions \\n\\n                every state\\'s result maximum(choice1,choice2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Is it really `medium` question? I am passing `Dynamic Programming I` study plan now and most `medium` question from there are much harder. I hope this study plan just made me better :) "
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "vector<int>dp(100001,-1);\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        return 0;\\n    }\\n\\ncould someone tell why iam this getting this error when i declare dp vector globally\\n\\nCOMPILER ERROR:-_______________\\nLine 3: Char 19: error: expected parameter declarator\\n    vector<int>dp(100001,-1);\\n\\n"
                    },
                    {
                        "username": "jga111",
                        "content": "Step 1: Work out the solution space. (Hint: it\\'s dynamic programming)\\nStep 2: Ok - we need a base case. What is it?....(Hint: for me, it was easy when I thought of the last question)\\nOnce you know the base case, you can work from there and devise your transition function - so I worked backwards\\n\\nI think this is a good medium"
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "[[12,46],[78,19],[63,15],[79,62],[13,10]]\\nOutput\\n91\\nExpected\\n79\\nanybody pls make me understand this test case\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since each brain power member is larger than the array size, you can only answer 1 question. 79 it is."
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "since brainpower values are more than the array size, then  if you pick any of the index that should be the answer , so we should choose ultimately the question which have highest point which is 79 \nSo that would be the expected ans , you might need check your algo you are doing it wrong somewhere\ncheck your base case \n"
                    },
                    {
                        "username": "nguyennhuhung72",
                        "content": "How can u calculate it to 91? You can just choose one of this and it just be 79."
                    },
                    {
                        "username": "ankit_r",
                        "content": "input = [[12,46],[78,19],[63,15],[79,62],[13,10]]\\nwhy the output of this input is 79.\\ncan anyone help me out.\\nmy answer is 91."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "see if you try to solve any of the question given in this array you cant solve any extra question as the power for any of the question is greater then the size of the 2D array. So the moment you solve any particular question you will be out of array so, to maximize the array solve the question which is having max points.\\ni.e 79 so the answer is 79.\\nHope this helps you understand. "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "someone : which season is going on ??\\nme : it\\'s DP season :-)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Hope ,u will survive."
                    }
                ]
            },
            {
                "id": 1890896,
                "content": [
                    {
                        "username": "parashirenmehta",
                        "content": "My solution works in Spyder, but the same code shows \\'Wrong Answer\\' when I paste it in LeetCode. Can anyone point out why this is happening?\\n\\n`d = {}`\\n`def points(currindex,currpoints):`\\n\\n    if currindex>=len(ques):\\n        return currpoints\\n\\n    if (currindex+1,currpoints) in d.keys():\\n        points1 = d[(currindex+1,currpoints)]\\n\\n    else:\\n        points1 = points(currindex+1,currpoints)\\n        d[(currindex+1,currpoints)] = points1        \\n\\n    if (currindex+ques[currindex][1]+1,currpoints+ques[currindex][0]) in d.keys():\\n        points2 = d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])]\\n\\n    else:\\n        points2 = points(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])\\n        d[(currindex+ques[currindex][1]+1,currpoints+ques[currindex][0])] = points2\\n\\n    return max(points1,points2)\\n\\nclass Solution:\\n\\n    def mostPoints(self, questions: List[List[int]]) -> int:\\n        global ques \\n        ques = questions[:]\\n        maxpoints = points(0,0)\\n        return maxpoints\\n\\nKindly let me know what I should change to make it run. Thanks!"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "still causes TLE on 42/54"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "since d = {} is global, it is used in every testcase as the same object and so it will have values of previous testcases. \\nRemove it from outside and use `global d\\n        d= {}` in mostPoints function"
                    },
                    {
                        "username": "GD18",
                        "content": "somewhat similar to yesterday\\'s approach to the problem, you can use Memoization/DP to solve it."
                    },
                    {
                        "username": "Mamun_71",
                        "content": "State : In every index i have 2 choices.If i should choose\\n                or not choose whcih give maximum points.\\n\\n                choice 1 : if take then my ponts will be\\n                points1=arr[i][1]+(Skip the brainpowers count \\n                number of question)\\n\\n                choice 2 : skip this qustion next qustion will be\\n                new state.\\n                points2=solve Next qustions \\n\\n                every state\\'s result maximum(choice1,choice2)"
                    },
                    {
                        "username": "belinskyi",
                        "content": "Is it really `medium` question? I am passing `Dynamic Programming I` study plan now and most `medium` question from there are much harder. I hope this study plan just made me better :) "
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "vector<int>dp(100001,-1);\\n    long long mostPoints(vector<vector<int>>& questions) {\\n        return 0;\\n    }\\n\\ncould someone tell why iam this getting this error when i declare dp vector globally\\n\\nCOMPILER ERROR:-_______________\\nLine 3: Char 19: error: expected parameter declarator\\n    vector<int>dp(100001,-1);\\n\\n"
                    },
                    {
                        "username": "jga111",
                        "content": "Step 1: Work out the solution space. (Hint: it\\'s dynamic programming)\\nStep 2: Ok - we need a base case. What is it?....(Hint: for me, it was easy when I thought of the last question)\\nOnce you know the base case, you can work from there and devise your transition function - so I worked backwards\\n\\nI think this is a good medium"
                    },
                    {
                        "username": "Ankur__Mishra",
                        "content": "[[12,46],[78,19],[63,15],[79,62],[13,10]]\\nOutput\\n91\\nExpected\\n79\\nanybody pls make me understand this test case\\n"
                    },
                    {
                        "username": "psionl0",
                        "content": "Since each brain power member is larger than the array size, you can only answer 1 question. 79 it is."
                    },
                    {
                        "username": "rohitk_chef15",
                        "content": "since brainpower values are more than the array size, then  if you pick any of the index that should be the answer , so we should choose ultimately the question which have highest point which is 79 \nSo that would be the expected ans , you might need check your algo you are doing it wrong somewhere\ncheck your base case \n"
                    },
                    {
                        "username": "nguyennhuhung72",
                        "content": "How can u calculate it to 91? You can just choose one of this and it just be 79."
                    },
                    {
                        "username": "ankit_r",
                        "content": "input = [[12,46],[78,19],[63,15],[79,62],[13,10]]\\nwhy the output of this input is 79.\\ncan anyone help me out.\\nmy answer is 91."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "see if you try to solve any of the question given in this array you cant solve any extra question as the power for any of the question is greater then the size of the 2D array. So the moment you solve any particular question you will be out of array so, to maximize the array solve the question which is having max points.\\ni.e 79 so the answer is 79.\\nHope this helps you understand. "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "someone : which season is going on ??\\nme : it\\'s DP season :-)"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Hope ,u will survive."
                    }
                ]
            },
            {
                "id": 1890863,
                "content": [
                    {
                        "username": "vijay97",
                        "content": "One pass solution \n\nhttps://leetcode.com/submissions/detail/948781487/\n\nauthor : jvelmurugan274"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "my bottom up and top down got 400 ms can we do any better?"
                    },
                    {
                        "username": "JayPokale",
                        "content": "Easy dynamic programming problem :)"
                    },
                    {
                        "username": "zain26134",
                        "content": "I don\\'t understand the criteria due to which we are skipping or solving the problem?  Is this random?"
                    },
                    {
                        "username": "yakode",
                        "content": "To get the maximum points? We have to choose which problems we want to solve and the cost of solving questions[i] is we can not solve(choose) next questions[i][1] problems."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Just choose the current index and save points and escape the next brainpoweri questions or escape the current index. choose best among these two . Use caching to avoid TLE."
                    },
                    {
                        "username": "vnk01",
                        "content": "LC getting personal"
                    },
                    {
                        "username": "AulySun",
                        "content": "For this case, I get 467,but correct answer is 465.\n `[[21,2],[1,2],[12,5],[7,2],[35,3],[32,2],[80,2],[91,5],[92,3],[27,3],[19,1],[37,3],[85,2],[33,4],[25,1],[91,4],[44,3],[93,3],[65,4],[82,3],[85,5],[81,3],[29,2],[25,1],[74,2],[58,1]]`\nn=26.\ndp[i] is max points from 0 to i.\nI get correct answer of dp[0]-dp[24]. dp[23]=409, questions[23][1]=1, so I think dp[25]=dp[23]+questions[25][0]=409+58=467. What is wrong with it?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "this one felt personal (the brainpower thing \\uD83D\\uDE2D\\uD83D\\uDE2D)\\n"
                    },
                    {
                        "username": "lordofthelaw",
                        "content": "Can be solved by Dynamic programing - Bottom-Up approach "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "My C runtime is 400ms , did anyone get a better time? "
                    }
                ]
            },
            {
                "id": 1890860,
                "content": [
                    {
                        "username": "vijay97",
                        "content": "One pass solution \n\nhttps://leetcode.com/submissions/detail/948781487/\n\nauthor : jvelmurugan274"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "my bottom up and top down got 400 ms can we do any better?"
                    },
                    {
                        "username": "JayPokale",
                        "content": "Easy dynamic programming problem :)"
                    },
                    {
                        "username": "zain26134",
                        "content": "I don\\'t understand the criteria due to which we are skipping or solving the problem?  Is this random?"
                    },
                    {
                        "username": "yakode",
                        "content": "To get the maximum points? We have to choose which problems we want to solve and the cost of solving questions[i] is we can not solve(choose) next questions[i][1] problems."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Just choose the current index and save points and escape the next brainpoweri questions or escape the current index. choose best among these two . Use caching to avoid TLE."
                    },
                    {
                        "username": "vnk01",
                        "content": "LC getting personal"
                    },
                    {
                        "username": "AulySun",
                        "content": "For this case, I get 467,but correct answer is 465.\n `[[21,2],[1,2],[12,5],[7,2],[35,3],[32,2],[80,2],[91,5],[92,3],[27,3],[19,1],[37,3],[85,2],[33,4],[25,1],[91,4],[44,3],[93,3],[65,4],[82,3],[85,5],[81,3],[29,2],[25,1],[74,2],[58,1]]`\nn=26.\ndp[i] is max points from 0 to i.\nI get correct answer of dp[0]-dp[24]. dp[23]=409, questions[23][1]=1, so I think dp[25]=dp[23]+questions[25][0]=409+58=467. What is wrong with it?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "this one felt personal (the brainpower thing \\uD83D\\uDE2D\\uD83D\\uDE2D)\\n"
                    },
                    {
                        "username": "lordofthelaw",
                        "content": "Can be solved by Dynamic programing - Bottom-Up approach "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "My C runtime is 400ms , did anyone get a better time? "
                    }
                ]
            },
            {
                "id": 1890832,
                "content": [
                    {
                        "username": "vijay97",
                        "content": "One pass solution \n\nhttps://leetcode.com/submissions/detail/948781487/\n\nauthor : jvelmurugan274"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "my bottom up and top down got 400 ms can we do any better?"
                    },
                    {
                        "username": "JayPokale",
                        "content": "Easy dynamic programming problem :)"
                    },
                    {
                        "username": "zain26134",
                        "content": "I don\\'t understand the criteria due to which we are skipping or solving the problem?  Is this random?"
                    },
                    {
                        "username": "yakode",
                        "content": "To get the maximum points? We have to choose which problems we want to solve and the cost of solving questions[i] is we can not solve(choose) next questions[i][1] problems."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Just choose the current index and save points and escape the next brainpoweri questions or escape the current index. choose best among these two . Use caching to avoid TLE."
                    },
                    {
                        "username": "vnk01",
                        "content": "LC getting personal"
                    },
                    {
                        "username": "AulySun",
                        "content": "For this case, I get 467,but correct answer is 465.\n `[[21,2],[1,2],[12,5],[7,2],[35,3],[32,2],[80,2],[91,5],[92,3],[27,3],[19,1],[37,3],[85,2],[33,4],[25,1],[91,4],[44,3],[93,3],[65,4],[82,3],[85,5],[81,3],[29,2],[25,1],[74,2],[58,1]]`\nn=26.\ndp[i] is max points from 0 to i.\nI get correct answer of dp[0]-dp[24]. dp[23]=409, questions[23][1]=1, so I think dp[25]=dp[23]+questions[25][0]=409+58=467. What is wrong with it?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "this one felt personal (the brainpower thing \\uD83D\\uDE2D\\uD83D\\uDE2D)\\n"
                    },
                    {
                        "username": "lordofthelaw",
                        "content": "Can be solved by Dynamic programing - Bottom-Up approach "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "My C runtime is 400ms , did anyone get a better time? "
                    }
                ]
            },
            {
                "id": 1890809,
                "content": [
                    {
                        "username": "vijay97",
                        "content": "One pass solution \n\nhttps://leetcode.com/submissions/detail/948781487/\n\nauthor : jvelmurugan274"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "my bottom up and top down got 400 ms can we do any better?"
                    },
                    {
                        "username": "JayPokale",
                        "content": "Easy dynamic programming problem :)"
                    },
                    {
                        "username": "zain26134",
                        "content": "I don\\'t understand the criteria due to which we are skipping or solving the problem?  Is this random?"
                    },
                    {
                        "username": "yakode",
                        "content": "To get the maximum points? We have to choose which problems we want to solve and the cost of solving questions[i] is we can not solve(choose) next questions[i][1] problems."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Just choose the current index and save points and escape the next brainpoweri questions or escape the current index. choose best among these two . Use caching to avoid TLE."
                    },
                    {
                        "username": "vnk01",
                        "content": "LC getting personal"
                    },
                    {
                        "username": "AulySun",
                        "content": "For this case, I get 467,but correct answer is 465.\n `[[21,2],[1,2],[12,5],[7,2],[35,3],[32,2],[80,2],[91,5],[92,3],[27,3],[19,1],[37,3],[85,2],[33,4],[25,1],[91,4],[44,3],[93,3],[65,4],[82,3],[85,5],[81,3],[29,2],[25,1],[74,2],[58,1]]`\nn=26.\ndp[i] is max points from 0 to i.\nI get correct answer of dp[0]-dp[24]. dp[23]=409, questions[23][1]=1, so I think dp[25]=dp[23]+questions[25][0]=409+58=467. What is wrong with it?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "this one felt personal (the brainpower thing \\uD83D\\uDE2D\\uD83D\\uDE2D)\\n"
                    },
                    {
                        "username": "lordofthelaw",
                        "content": "Can be solved by Dynamic programing - Bottom-Up approach "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "My C runtime is 400ms , did anyone get a better time? "
                    }
                ]
            },
            {
                "id": 1890808,
                "content": [
                    {
                        "username": "vijay97",
                        "content": "One pass solution \n\nhttps://leetcode.com/submissions/detail/948781487/\n\nauthor : jvelmurugan274"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "my bottom up and top down got 400 ms can we do any better?"
                    },
                    {
                        "username": "JayPokale",
                        "content": "Easy dynamic programming problem :)"
                    },
                    {
                        "username": "zain26134",
                        "content": "I don\\'t understand the criteria due to which we are skipping or solving the problem?  Is this random?"
                    },
                    {
                        "username": "yakode",
                        "content": "To get the maximum points? We have to choose which problems we want to solve and the cost of solving questions[i] is we can not solve(choose) next questions[i][1] problems."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Just choose the current index and save points and escape the next brainpoweri questions or escape the current index. choose best among these two . Use caching to avoid TLE."
                    },
                    {
                        "username": "vnk01",
                        "content": "LC getting personal"
                    },
                    {
                        "username": "AulySun",
                        "content": "For this case, I get 467,but correct answer is 465.\n `[[21,2],[1,2],[12,5],[7,2],[35,3],[32,2],[80,2],[91,5],[92,3],[27,3],[19,1],[37,3],[85,2],[33,4],[25,1],[91,4],[44,3],[93,3],[65,4],[82,3],[85,5],[81,3],[29,2],[25,1],[74,2],[58,1]]`\nn=26.\ndp[i] is max points from 0 to i.\nI get correct answer of dp[0]-dp[24]. dp[23]=409, questions[23][1]=1, so I think dp[25]=dp[23]+questions[25][0]=409+58=467. What is wrong with it?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "this one felt personal (the brainpower thing \\uD83D\\uDE2D\\uD83D\\uDE2D)\\n"
                    },
                    {
                        "username": "lordofthelaw",
                        "content": "Can be solved by Dynamic programing - Bottom-Up approach "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "My C runtime is 400ms , did anyone get a better time? "
                    }
                ]
            },
            {
                "id": 1890801,
                "content": [
                    {
                        "username": "vijay97",
                        "content": "One pass solution \n\nhttps://leetcode.com/submissions/detail/948781487/\n\nauthor : jvelmurugan274"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "my bottom up and top down got 400 ms can we do any better?"
                    },
                    {
                        "username": "JayPokale",
                        "content": "Easy dynamic programming problem :)"
                    },
                    {
                        "username": "zain26134",
                        "content": "I don\\'t understand the criteria due to which we are skipping or solving the problem?  Is this random?"
                    },
                    {
                        "username": "yakode",
                        "content": "To get the maximum points? We have to choose which problems we want to solve and the cost of solving questions[i] is we can not solve(choose) next questions[i][1] problems."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Just choose the current index and save points and escape the next brainpoweri questions or escape the current index. choose best among these two . Use caching to avoid TLE."
                    },
                    {
                        "username": "vnk01",
                        "content": "LC getting personal"
                    },
                    {
                        "username": "AulySun",
                        "content": "For this case, I get 467,but correct answer is 465.\n `[[21,2],[1,2],[12,5],[7,2],[35,3],[32,2],[80,2],[91,5],[92,3],[27,3],[19,1],[37,3],[85,2],[33,4],[25,1],[91,4],[44,3],[93,3],[65,4],[82,3],[85,5],[81,3],[29,2],[25,1],[74,2],[58,1]]`\nn=26.\ndp[i] is max points from 0 to i.\nI get correct answer of dp[0]-dp[24]. dp[23]=409, questions[23][1]=1, so I think dp[25]=dp[23]+questions[25][0]=409+58=467. What is wrong with it?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "this one felt personal (the brainpower thing \\uD83D\\uDE2D\\uD83D\\uDE2D)\\n"
                    },
                    {
                        "username": "lordofthelaw",
                        "content": "Can be solved by Dynamic programing - Bottom-Up approach "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "My C runtime is 400ms , did anyone get a better time? "
                    }
                ]
            },
            {
                "id": 1890793,
                "content": [
                    {
                        "username": "vijay97",
                        "content": "One pass solution \n\nhttps://leetcode.com/submissions/detail/948781487/\n\nauthor : jvelmurugan274"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "my bottom up and top down got 400 ms can we do any better?"
                    },
                    {
                        "username": "JayPokale",
                        "content": "Easy dynamic programming problem :)"
                    },
                    {
                        "username": "zain26134",
                        "content": "I don\\'t understand the criteria due to which we are skipping or solving the problem?  Is this random?"
                    },
                    {
                        "username": "yakode",
                        "content": "To get the maximum points? We have to choose which problems we want to solve and the cost of solving questions[i] is we can not solve(choose) next questions[i][1] problems."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Just choose the current index and save points and escape the next brainpoweri questions or escape the current index. choose best among these two . Use caching to avoid TLE."
                    },
                    {
                        "username": "vnk01",
                        "content": "LC getting personal"
                    },
                    {
                        "username": "AulySun",
                        "content": "For this case, I get 467,but correct answer is 465.\n `[[21,2],[1,2],[12,5],[7,2],[35,3],[32,2],[80,2],[91,5],[92,3],[27,3],[19,1],[37,3],[85,2],[33,4],[25,1],[91,4],[44,3],[93,3],[65,4],[82,3],[85,5],[81,3],[29,2],[25,1],[74,2],[58,1]]`\nn=26.\ndp[i] is max points from 0 to i.\nI get correct answer of dp[0]-dp[24]. dp[23]=409, questions[23][1]=1, so I think dp[25]=dp[23]+questions[25][0]=409+58=467. What is wrong with it?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "this one felt personal (the brainpower thing \\uD83D\\uDE2D\\uD83D\\uDE2D)\\n"
                    },
                    {
                        "username": "lordofthelaw",
                        "content": "Can be solved by Dynamic programing - Bottom-Up approach "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "My C runtime is 400ms , did anyone get a better time? "
                    }
                ]
            },
            {
                "id": 1890792,
                "content": [
                    {
                        "username": "vijay97",
                        "content": "One pass solution \n\nhttps://leetcode.com/submissions/detail/948781487/\n\nauthor : jvelmurugan274"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "my bottom up and top down got 400 ms can we do any better?"
                    },
                    {
                        "username": "JayPokale",
                        "content": "Easy dynamic programming problem :)"
                    },
                    {
                        "username": "zain26134",
                        "content": "I don\\'t understand the criteria due to which we are skipping or solving the problem?  Is this random?"
                    },
                    {
                        "username": "yakode",
                        "content": "To get the maximum points? We have to choose which problems we want to solve and the cost of solving questions[i] is we can not solve(choose) next questions[i][1] problems."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Just choose the current index and save points and escape the next brainpoweri questions or escape the current index. choose best among these two . Use caching to avoid TLE."
                    },
                    {
                        "username": "vnk01",
                        "content": "LC getting personal"
                    },
                    {
                        "username": "AulySun",
                        "content": "For this case, I get 467,but correct answer is 465.\n `[[21,2],[1,2],[12,5],[7,2],[35,3],[32,2],[80,2],[91,5],[92,3],[27,3],[19,1],[37,3],[85,2],[33,4],[25,1],[91,4],[44,3],[93,3],[65,4],[82,3],[85,5],[81,3],[29,2],[25,1],[74,2],[58,1]]`\nn=26.\ndp[i] is max points from 0 to i.\nI get correct answer of dp[0]-dp[24]. dp[23]=409, questions[23][1]=1, so I think dp[25]=dp[23]+questions[25][0]=409+58=467. What is wrong with it?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "this one felt personal (the brainpower thing \\uD83D\\uDE2D\\uD83D\\uDE2D)\\n"
                    },
                    {
                        "username": "lordofthelaw",
                        "content": "Can be solved by Dynamic programing - Bottom-Up approach "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "My C runtime is 400ms , did anyone get a better time? "
                    }
                ]
            },
            {
                "id": 1890787,
                "content": [
                    {
                        "username": "vijay97",
                        "content": "One pass solution \n\nhttps://leetcode.com/submissions/detail/948781487/\n\nauthor : jvelmurugan274"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "my bottom up and top down got 400 ms can we do any better?"
                    },
                    {
                        "username": "JayPokale",
                        "content": "Easy dynamic programming problem :)"
                    },
                    {
                        "username": "zain26134",
                        "content": "I don\\'t understand the criteria due to which we are skipping or solving the problem?  Is this random?"
                    },
                    {
                        "username": "yakode",
                        "content": "To get the maximum points? We have to choose which problems we want to solve and the cost of solving questions[i] is we can not solve(choose) next questions[i][1] problems."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Just choose the current index and save points and escape the next brainpoweri questions or escape the current index. choose best among these two . Use caching to avoid TLE."
                    },
                    {
                        "username": "vnk01",
                        "content": "LC getting personal"
                    },
                    {
                        "username": "AulySun",
                        "content": "For this case, I get 467,but correct answer is 465.\n `[[21,2],[1,2],[12,5],[7,2],[35,3],[32,2],[80,2],[91,5],[92,3],[27,3],[19,1],[37,3],[85,2],[33,4],[25,1],[91,4],[44,3],[93,3],[65,4],[82,3],[85,5],[81,3],[29,2],[25,1],[74,2],[58,1]]`\nn=26.\ndp[i] is max points from 0 to i.\nI get correct answer of dp[0]-dp[24]. dp[23]=409, questions[23][1]=1, so I think dp[25]=dp[23]+questions[25][0]=409+58=467. What is wrong with it?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "this one felt personal (the brainpower thing \\uD83D\\uDE2D\\uD83D\\uDE2D)\\n"
                    },
                    {
                        "username": "lordofthelaw",
                        "content": "Can be solved by Dynamic programing - Bottom-Up approach "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "My C runtime is 400ms , did anyone get a better time? "
                    }
                ]
            },
            {
                "id": 1890781,
                "content": [
                    {
                        "username": "vijay97",
                        "content": "One pass solution \n\nhttps://leetcode.com/submissions/detail/948781487/\n\nauthor : jvelmurugan274"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "my bottom up and top down got 400 ms can we do any better?"
                    },
                    {
                        "username": "JayPokale",
                        "content": "Easy dynamic programming problem :)"
                    },
                    {
                        "username": "zain26134",
                        "content": "I don\\'t understand the criteria due to which we are skipping or solving the problem?  Is this random?"
                    },
                    {
                        "username": "yakode",
                        "content": "To get the maximum points? We have to choose which problems we want to solve and the cost of solving questions[i] is we can not solve(choose) next questions[i][1] problems."
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Just choose the current index and save points and escape the next brainpoweri questions or escape the current index. choose best among these two . Use caching to avoid TLE."
                    },
                    {
                        "username": "vnk01",
                        "content": "LC getting personal"
                    },
                    {
                        "username": "AulySun",
                        "content": "For this case, I get 467,but correct answer is 465.\n `[[21,2],[1,2],[12,5],[7,2],[35,3],[32,2],[80,2],[91,5],[92,3],[27,3],[19,1],[37,3],[85,2],[33,4],[25,1],[91,4],[44,3],[93,3],[65,4],[82,3],[85,5],[81,3],[29,2],[25,1],[74,2],[58,1]]`\nn=26.\ndp[i] is max points from 0 to i.\nI get correct answer of dp[0]-dp[24]. dp[23]=409, questions[23][1]=1, so I think dp[25]=dp[23]+questions[25][0]=409+58=467. What is wrong with it?"
                    },
                    {
                        "username": "dumb_me",
                        "content": "this one felt personal (the brainpower thing \\uD83D\\uDE2D\\uD83D\\uDE2D)\\n"
                    },
                    {
                        "username": "lordofthelaw",
                        "content": "Can be solved by Dynamic programing - Bottom-Up approach "
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "My C runtime is 400ms , did anyone get a better time? "
                    }
                ]
            },
            {
                "id": 1890776,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "I hope this question will help developing more and more BRAIN-POWER"
                    },
                    {
                        "username": "pavan_24",
                        "content": "questions = [[12,46], [78,19], [63,15], [79,62], [13,10]]\\nIn this test case I got 91 as the max points I can earn (by taking index (0 and 3) or (1 and 4)). But the given output as 79."
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "you cannot take index (0 and 3) or (1 and 4) because you are out of range.\\nif you take index 0 you have to skip 46 questions or if you take index 1 you skip 19 questions. so answer here index 3 "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This is an easy question if you know basic dynamic programming. I don\\'t know why this question has a lower acceptance rate."
                    },
                    {
                        "username": "nat1902",
                        "content": "it depends on your experience."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Damn , its a easy take and not take DP question "
                    },
                    {
                        "username": "cy171",
                        "content": "The follow-up question could be: Can we skip the question with specific index \"brainpower\" , rather than skipping the next \"brainpower\" questions? That will be HARD,  particularly if the questions are presented in a graph with circles."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy-Peasy DP, \\nskip and take approach"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "mochy",
                        "content": "to take a question and earn `points_i` points, you must skip the next `brainpower_i` questions"
                    },
                    {
                        "username": "heisenberrg",
                        "content": "It simply tells us that if we answer the i th question, then we won\\'t be able to answer the next brainpower[i] questions. That is, the next question, we are allowed to answer is the brainpower[i+1]th question. Try to relate it with houserobber, where the robber if robs the house, cannot rob the adjacent house."
                    },
                    {
                        "username": "dynamo214",
                        "content": "LeetCode Daily Challenge: your brain be like skip this question or pick this question, in whatever way max benefit you can have\nTip:\nWatchout for integer overflow and pass  array by ref to avoid TLE"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "dynamo214",
                        "content": "yes, brainpower = no of next items to skip"
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "Approach ? "
                    }
                ]
            },
            {
                "id": 1890773,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "I hope this question will help developing more and more BRAIN-POWER"
                    },
                    {
                        "username": "pavan_24",
                        "content": "questions = [[12,46], [78,19], [63,15], [79,62], [13,10]]\\nIn this test case I got 91 as the max points I can earn (by taking index (0 and 3) or (1 and 4)). But the given output as 79."
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "you cannot take index (0 and 3) or (1 and 4) because you are out of range.\\nif you take index 0 you have to skip 46 questions or if you take index 1 you skip 19 questions. so answer here index 3 "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This is an easy question if you know basic dynamic programming. I don\\'t know why this question has a lower acceptance rate."
                    },
                    {
                        "username": "nat1902",
                        "content": "it depends on your experience."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Damn , its a easy take and not take DP question "
                    },
                    {
                        "username": "cy171",
                        "content": "The follow-up question could be: Can we skip the question with specific index \"brainpower\" , rather than skipping the next \"brainpower\" questions? That will be HARD,  particularly if the questions are presented in a graph with circles."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy-Peasy DP, \\nskip and take approach"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "mochy",
                        "content": "to take a question and earn `points_i` points, you must skip the next `brainpower_i` questions"
                    },
                    {
                        "username": "heisenberrg",
                        "content": "It simply tells us that if we answer the i th question, then we won\\'t be able to answer the next brainpower[i] questions. That is, the next question, we are allowed to answer is the brainpower[i+1]th question. Try to relate it with houserobber, where the robber if robs the house, cannot rob the adjacent house."
                    },
                    {
                        "username": "dynamo214",
                        "content": "LeetCode Daily Challenge: your brain be like skip this question or pick this question, in whatever way max benefit you can have\nTip:\nWatchout for integer overflow and pass  array by ref to avoid TLE"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "dynamo214",
                        "content": "yes, brainpower = no of next items to skip"
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "Approach ? "
                    }
                ]
            },
            {
                "id": 1890734,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "I hope this question will help developing more and more BRAIN-POWER"
                    },
                    {
                        "username": "pavan_24",
                        "content": "questions = [[12,46], [78,19], [63,15], [79,62], [13,10]]\\nIn this test case I got 91 as the max points I can earn (by taking index (0 and 3) or (1 and 4)). But the given output as 79."
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "you cannot take index (0 and 3) or (1 and 4) because you are out of range.\\nif you take index 0 you have to skip 46 questions or if you take index 1 you skip 19 questions. so answer here index 3 "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This is an easy question if you know basic dynamic programming. I don\\'t know why this question has a lower acceptance rate."
                    },
                    {
                        "username": "nat1902",
                        "content": "it depends on your experience."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Damn , its a easy take and not take DP question "
                    },
                    {
                        "username": "cy171",
                        "content": "The follow-up question could be: Can we skip the question with specific index \"brainpower\" , rather than skipping the next \"brainpower\" questions? That will be HARD,  particularly if the questions are presented in a graph with circles."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy-Peasy DP, \\nskip and take approach"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "mochy",
                        "content": "to take a question and earn `points_i` points, you must skip the next `brainpower_i` questions"
                    },
                    {
                        "username": "heisenberrg",
                        "content": "It simply tells us that if we answer the i th question, then we won\\'t be able to answer the next brainpower[i] questions. That is, the next question, we are allowed to answer is the brainpower[i+1]th question. Try to relate it with houserobber, where the robber if robs the house, cannot rob the adjacent house."
                    },
                    {
                        "username": "dynamo214",
                        "content": "LeetCode Daily Challenge: your brain be like skip this question or pick this question, in whatever way max benefit you can have\nTip:\nWatchout for integer overflow and pass  array by ref to avoid TLE"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "dynamo214",
                        "content": "yes, brainpower = no of next items to skip"
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "Approach ? "
                    }
                ]
            },
            {
                "id": 1890715,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "I hope this question will help developing more and more BRAIN-POWER"
                    },
                    {
                        "username": "pavan_24",
                        "content": "questions = [[12,46], [78,19], [63,15], [79,62], [13,10]]\\nIn this test case I got 91 as the max points I can earn (by taking index (0 and 3) or (1 and 4)). But the given output as 79."
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "you cannot take index (0 and 3) or (1 and 4) because you are out of range.\\nif you take index 0 you have to skip 46 questions or if you take index 1 you skip 19 questions. so answer here index 3 "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This is an easy question if you know basic dynamic programming. I don\\'t know why this question has a lower acceptance rate."
                    },
                    {
                        "username": "nat1902",
                        "content": "it depends on your experience."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Damn , its a easy take and not take DP question "
                    },
                    {
                        "username": "cy171",
                        "content": "The follow-up question could be: Can we skip the question with specific index \"brainpower\" , rather than skipping the next \"brainpower\" questions? That will be HARD,  particularly if the questions are presented in a graph with circles."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy-Peasy DP, \\nskip and take approach"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "mochy",
                        "content": "to take a question and earn `points_i` points, you must skip the next `brainpower_i` questions"
                    },
                    {
                        "username": "heisenberrg",
                        "content": "It simply tells us that if we answer the i th question, then we won\\'t be able to answer the next brainpower[i] questions. That is, the next question, we are allowed to answer is the brainpower[i+1]th question. Try to relate it with houserobber, where the robber if robs the house, cannot rob the adjacent house."
                    },
                    {
                        "username": "dynamo214",
                        "content": "LeetCode Daily Challenge: your brain be like skip this question or pick this question, in whatever way max benefit you can have\nTip:\nWatchout for integer overflow and pass  array by ref to avoid TLE"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "dynamo214",
                        "content": "yes, brainpower = no of next items to skip"
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "Approach ? "
                    }
                ]
            },
            {
                "id": 1890670,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "I hope this question will help developing more and more BRAIN-POWER"
                    },
                    {
                        "username": "pavan_24",
                        "content": "questions = [[12,46], [78,19], [63,15], [79,62], [13,10]]\\nIn this test case I got 91 as the max points I can earn (by taking index (0 and 3) or (1 and 4)). But the given output as 79."
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "you cannot take index (0 and 3) or (1 and 4) because you are out of range.\\nif you take index 0 you have to skip 46 questions or if you take index 1 you skip 19 questions. so answer here index 3 "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This is an easy question if you know basic dynamic programming. I don\\'t know why this question has a lower acceptance rate."
                    },
                    {
                        "username": "nat1902",
                        "content": "it depends on your experience."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Damn , its a easy take and not take DP question "
                    },
                    {
                        "username": "cy171",
                        "content": "The follow-up question could be: Can we skip the question with specific index \"brainpower\" , rather than skipping the next \"brainpower\" questions? That will be HARD,  particularly if the questions are presented in a graph with circles."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy-Peasy DP, \\nskip and take approach"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "mochy",
                        "content": "to take a question and earn `points_i` points, you must skip the next `brainpower_i` questions"
                    },
                    {
                        "username": "heisenberrg",
                        "content": "It simply tells us that if we answer the i th question, then we won\\'t be able to answer the next brainpower[i] questions. That is, the next question, we are allowed to answer is the brainpower[i+1]th question. Try to relate it with houserobber, where the robber if robs the house, cannot rob the adjacent house."
                    },
                    {
                        "username": "dynamo214",
                        "content": "LeetCode Daily Challenge: your brain be like skip this question or pick this question, in whatever way max benefit you can have\nTip:\nWatchout for integer overflow and pass  array by ref to avoid TLE"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "dynamo214",
                        "content": "yes, brainpower = no of next items to skip"
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "Approach ? "
                    }
                ]
            },
            {
                "id": 1890669,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "I hope this question will help developing more and more BRAIN-POWER"
                    },
                    {
                        "username": "pavan_24",
                        "content": "questions = [[12,46], [78,19], [63,15], [79,62], [13,10]]\\nIn this test case I got 91 as the max points I can earn (by taking index (0 and 3) or (1 and 4)). But the given output as 79."
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "you cannot take index (0 and 3) or (1 and 4) because you are out of range.\\nif you take index 0 you have to skip 46 questions or if you take index 1 you skip 19 questions. so answer here index 3 "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This is an easy question if you know basic dynamic programming. I don\\'t know why this question has a lower acceptance rate."
                    },
                    {
                        "username": "nat1902",
                        "content": "it depends on your experience."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Damn , its a easy take and not take DP question "
                    },
                    {
                        "username": "cy171",
                        "content": "The follow-up question could be: Can we skip the question with specific index \"brainpower\" , rather than skipping the next \"brainpower\" questions? That will be HARD,  particularly if the questions are presented in a graph with circles."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy-Peasy DP, \\nskip and take approach"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "mochy",
                        "content": "to take a question and earn `points_i` points, you must skip the next `brainpower_i` questions"
                    },
                    {
                        "username": "heisenberrg",
                        "content": "It simply tells us that if we answer the i th question, then we won\\'t be able to answer the next brainpower[i] questions. That is, the next question, we are allowed to answer is the brainpower[i+1]th question. Try to relate it with houserobber, where the robber if robs the house, cannot rob the adjacent house."
                    },
                    {
                        "username": "dynamo214",
                        "content": "LeetCode Daily Challenge: your brain be like skip this question or pick this question, in whatever way max benefit you can have\nTip:\nWatchout for integer overflow and pass  array by ref to avoid TLE"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "dynamo214",
                        "content": "yes, brainpower = no of next items to skip"
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "Approach ? "
                    }
                ]
            },
            {
                "id": 1890667,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "I hope this question will help developing more and more BRAIN-POWER"
                    },
                    {
                        "username": "pavan_24",
                        "content": "questions = [[12,46], [78,19], [63,15], [79,62], [13,10]]\\nIn this test case I got 91 as the max points I can earn (by taking index (0 and 3) or (1 and 4)). But the given output as 79."
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "you cannot take index (0 and 3) or (1 and 4) because you are out of range.\\nif you take index 0 you have to skip 46 questions or if you take index 1 you skip 19 questions. so answer here index 3 "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This is an easy question if you know basic dynamic programming. I don\\'t know why this question has a lower acceptance rate."
                    },
                    {
                        "username": "nat1902",
                        "content": "it depends on your experience."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Damn , its a easy take and not take DP question "
                    },
                    {
                        "username": "cy171",
                        "content": "The follow-up question could be: Can we skip the question with specific index \"brainpower\" , rather than skipping the next \"brainpower\" questions? That will be HARD,  particularly if the questions are presented in a graph with circles."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy-Peasy DP, \\nskip and take approach"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "mochy",
                        "content": "to take a question and earn `points_i` points, you must skip the next `brainpower_i` questions"
                    },
                    {
                        "username": "heisenberrg",
                        "content": "It simply tells us that if we answer the i th question, then we won\\'t be able to answer the next brainpower[i] questions. That is, the next question, we are allowed to answer is the brainpower[i+1]th question. Try to relate it with houserobber, where the robber if robs the house, cannot rob the adjacent house."
                    },
                    {
                        "username": "dynamo214",
                        "content": "LeetCode Daily Challenge: your brain be like skip this question or pick this question, in whatever way max benefit you can have\nTip:\nWatchout for integer overflow and pass  array by ref to avoid TLE"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "dynamo214",
                        "content": "yes, brainpower = no of next items to skip"
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "Approach ? "
                    }
                ]
            },
            {
                "id": 1890666,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "I hope this question will help developing more and more BRAIN-POWER"
                    },
                    {
                        "username": "pavan_24",
                        "content": "questions = [[12,46], [78,19], [63,15], [79,62], [13,10]]\\nIn this test case I got 91 as the max points I can earn (by taking index (0 and 3) or (1 and 4)). But the given output as 79."
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "you cannot take index (0 and 3) or (1 and 4) because you are out of range.\\nif you take index 0 you have to skip 46 questions or if you take index 1 you skip 19 questions. so answer here index 3 "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This is an easy question if you know basic dynamic programming. I don\\'t know why this question has a lower acceptance rate."
                    },
                    {
                        "username": "nat1902",
                        "content": "it depends on your experience."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Damn , its a easy take and not take DP question "
                    },
                    {
                        "username": "cy171",
                        "content": "The follow-up question could be: Can we skip the question with specific index \"brainpower\" , rather than skipping the next \"brainpower\" questions? That will be HARD,  particularly if the questions are presented in a graph with circles."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy-Peasy DP, \\nskip and take approach"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "mochy",
                        "content": "to take a question and earn `points_i` points, you must skip the next `brainpower_i` questions"
                    },
                    {
                        "username": "heisenberrg",
                        "content": "It simply tells us that if we answer the i th question, then we won\\'t be able to answer the next brainpower[i] questions. That is, the next question, we are allowed to answer is the brainpower[i+1]th question. Try to relate it with houserobber, where the robber if robs the house, cannot rob the adjacent house."
                    },
                    {
                        "username": "dynamo214",
                        "content": "LeetCode Daily Challenge: your brain be like skip this question or pick this question, in whatever way max benefit you can have\nTip:\nWatchout for integer overflow and pass  array by ref to avoid TLE"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "dynamo214",
                        "content": "yes, brainpower = no of next items to skip"
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "Approach ? "
                    }
                ]
            },
            {
                "id": 1890664,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "I hope this question will help developing more and more BRAIN-POWER"
                    },
                    {
                        "username": "pavan_24",
                        "content": "questions = [[12,46], [78,19], [63,15], [79,62], [13,10]]\\nIn this test case I got 91 as the max points I can earn (by taking index (0 and 3) or (1 and 4)). But the given output as 79."
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "you cannot take index (0 and 3) or (1 and 4) because you are out of range.\\nif you take index 0 you have to skip 46 questions or if you take index 1 you skip 19 questions. so answer here index 3 "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This is an easy question if you know basic dynamic programming. I don\\'t know why this question has a lower acceptance rate."
                    },
                    {
                        "username": "nat1902",
                        "content": "it depends on your experience."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Damn , its a easy take and not take DP question "
                    },
                    {
                        "username": "cy171",
                        "content": "The follow-up question could be: Can we skip the question with specific index \"brainpower\" , rather than skipping the next \"brainpower\" questions? That will be HARD,  particularly if the questions are presented in a graph with circles."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy-Peasy DP, \\nskip and take approach"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "mochy",
                        "content": "to take a question and earn `points_i` points, you must skip the next `brainpower_i` questions"
                    },
                    {
                        "username": "heisenberrg",
                        "content": "It simply tells us that if we answer the i th question, then we won\\'t be able to answer the next brainpower[i] questions. That is, the next question, we are allowed to answer is the brainpower[i+1]th question. Try to relate it with houserobber, where the robber if robs the house, cannot rob the adjacent house."
                    },
                    {
                        "username": "dynamo214",
                        "content": "LeetCode Daily Challenge: your brain be like skip this question or pick this question, in whatever way max benefit you can have\nTip:\nWatchout for integer overflow and pass  array by ref to avoid TLE"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "dynamo214",
                        "content": "yes, brainpower = no of next items to skip"
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "Approach ? "
                    }
                ]
            },
            {
                "id": 1890644,
                "content": [
                    {
                        "username": "mkprajapati1614",
                        "content": "I hope this question will help developing more and more BRAIN-POWER"
                    },
                    {
                        "username": "pavan_24",
                        "content": "questions = [[12,46], [78,19], [63,15], [79,62], [13,10]]\\nIn this test case I got 91 as the max points I can earn (by taking index (0 and 3) or (1 and 4)). But the given output as 79."
                    },
                    {
                        "username": "ABDUMALIK0",
                        "content": "you cannot take index (0 and 3) or (1 and 4) because you are out of range.\\nif you take index 0 you have to skip 46 questions or if you take index 1 you skip 19 questions. so answer here index 3 "
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "This is an easy question if you know basic dynamic programming. I don\\'t know why this question has a lower acceptance rate."
                    },
                    {
                        "username": "nat1902",
                        "content": "it depends on your experience."
                    },
                    {
                        "username": "muskankdkd",
                        "content": "Damn , its a easy take and not take DP question "
                    },
                    {
                        "username": "cy171",
                        "content": "The follow-up question could be: Can we skip the question with specific index \"brainpower\" , rather than skipping the next \"brainpower\" questions? That will be HARD,  particularly if the questions are presented in a graph with circles."
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Easy-Peasy DP, \\nskip and take approach"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "mochy",
                        "content": "to take a question and earn `points_i` points, you must skip the next `brainpower_i` questions"
                    },
                    {
                        "username": "heisenberrg",
                        "content": "It simply tells us that if we answer the i th question, then we won\\'t be able to answer the next brainpower[i] questions. That is, the next question, we are allowed to answer is the brainpower[i+1]th question. Try to relate it with houserobber, where the robber if robs the house, cannot rob the adjacent house."
                    },
                    {
                        "username": "dynamo214",
                        "content": "LeetCode Daily Challenge: your brain be like skip this question or pick this question, in whatever way max benefit you can have\nTip:\nWatchout for integer overflow and pass  array by ref to avoid TLE"
                    },
                    {
                        "username": "harsha335",
                        "content": "I am not getting the question, any one help me out... What is the use of brain power in above question.... Is the question saying if you take a element then you have to skip next 2 ??"
                    },
                    {
                        "username": "dynamo214",
                        "content": "yes, brainpower = no of next items to skip"
                    },
                    {
                        "username": "Rajsatyammm",
                        "content": "Approach ? "
                    }
                ]
            }
        ]
    }
]