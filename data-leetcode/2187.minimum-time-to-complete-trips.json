[
    {
        "title": "Number of Ways to Build Sturdy Brick Wall",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1568750,
                "content": [
                    {
                        "username": "xuyiouqd",
                        "content": "this problem should be hard? not sure if I\\'m the only one who has the feeling..."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Feels like Hard or definitely the higher end of Medium. Not straightforward to come up with how to construct the DP table. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "Definitely above medium"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "There are many HARD problems easier than this one!\\nSpent an entire day trying to get it accepted. And when it did, my solution was among the bottom 20%. :( "
                    },
                    {
                        "username": "adhyayana",
                        "content": "AnyOne please let me know the problem statement ,it\\'s confusing ,height = 2, width = 3, bricks = [1,2] , why bricks[0] = > width 1 and height =1 is not considered ?"
                    }
                ]
            },
            {
                "id": 1708150,
                "content": [
                    {
                        "username": "xuyiouqd",
                        "content": "this problem should be hard? not sure if I\\'m the only one who has the feeling..."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Feels like Hard or definitely the higher end of Medium. Not straightforward to come up with how to construct the DP table. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "Definitely above medium"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "There are many HARD problems easier than this one!\\nSpent an entire day trying to get it accepted. And when it did, my solution was among the bottom 20%. :( "
                    },
                    {
                        "username": "adhyayana",
                        "content": "AnyOne please let me know the problem statement ,it\\'s confusing ,height = 2, width = 3, bricks = [1,2] , why bricks[0] = > width 1 and height =1 is not considered ?"
                    }
                ]
            },
            {
                "id": 1955096,
                "content": [
                    {
                        "username": "xuyiouqd",
                        "content": "this problem should be hard? not sure if I\\'m the only one who has the feeling..."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Feels like Hard or definitely the higher end of Medium. Not straightforward to come up with how to construct the DP table. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "Definitely above medium"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "There are many HARD problems easier than this one!\\nSpent an entire day trying to get it accepted. And when it did, my solution was among the bottom 20%. :( "
                    },
                    {
                        "username": "adhyayana",
                        "content": "AnyOne please let me know the problem statement ,it\\'s confusing ,height = 2, width = 3, bricks = [1,2] , why bricks[0] = > width 1 and height =1 is not considered ?"
                    }
                ]
            },
            {
                "id": 1930709,
                "content": [
                    {
                        "username": "xuyiouqd",
                        "content": "this problem should be hard? not sure if I\\'m the only one who has the feeling..."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Feels like Hard or definitely the higher end of Medium. Not straightforward to come up with how to construct the DP table. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "Definitely above medium"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "There are many HARD problems easier than this one!\\nSpent an entire day trying to get it accepted. And when it did, my solution was among the bottom 20%. :( "
                    },
                    {
                        "username": "adhyayana",
                        "content": "AnyOne please let me know the problem statement ,it\\'s confusing ,height = 2, width = 3, bricks = [1,2] , why bricks[0] = > width 1 and height =1 is not considered ?"
                    }
                ]
            },
            {
                "id": 1825547,
                "content": [
                    {
                        "username": "xuyiouqd",
                        "content": "this problem should be hard? not sure if I\\'m the only one who has the feeling..."
                    },
                    {
                        "username": "XavierWantMoreMoney",
                        "content": "Feels like Hard or definitely the higher end of Medium. Not straightforward to come up with how to construct the DP table. "
                    },
                    {
                        "username": "stefan1096",
                        "content": "Definitely above medium"
                    },
                    {
                        "username": "SigmaCoder106",
                        "content": "There are many HARD problems easier than this one!\\nSpent an entire day trying to get it accepted. And when it did, my solution was among the bottom 20%. :( "
                    },
                    {
                        "username": "adhyayana",
                        "content": "AnyOne please let me know the problem statement ,it\\'s confusing ,height = 2, width = 3, bricks = [1,2] , why bricks[0] = > width 1 and height =1 is not considered ?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Counting Words With a Given Prefix",
        "question_content": "<p>You are given an array of strings <code>words</code> and a string <code>pref</code>.</p>\n\n<p>Return <em>the number of strings in </em><code>words</code><em> that contain </em><code>pref</code><em> as a <strong>prefix</strong></em>.</p>\n\n<p>A <strong>prefix</strong> of a string <code>s</code> is any leading contiguous substring of <code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;pay&quot;,&quot;<strong><u>at</u></strong>tention&quot;,&quot;practice&quot;,&quot;<u><strong>at</strong></u>tend&quot;], <code>pref </code>= &quot;at&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The 2 strings that contain &quot;at&quot; as a prefix are: &quot;<u><strong>at</strong></u>tention&quot; and &quot;<u><strong>at</strong></u>tend&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;leetcode&quot;,&quot;win&quot;,&quot;loops&quot;,&quot;success&quot;], <code>pref </code>= &quot;code&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> There are no strings that contain &quot;code&quot; as a prefix.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length, pref.length &lt;= 100</code></li>\n\t<li><code>words[i]</code> and <code>pref</code> consist of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1802497,
                "title": "c-easiest-solution-substring",
                "content": "```\\n// The easiest solution to this problem is:\\n// Step 1: Calculate length of \"pref\"\\n// Step 2: find substring of \"words\" from 0 to length of \"pref\"\\n// if both match increment count by 1;\\n\\n\\n\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n        int count=0;\\n        int preflen=pref.size();        //step 1\\n        \\n        for(auto i:words){\\n            if(i.substr(0,preflen) == pref)     //step 2\\n                count++;                        //if both matches then increment count by 1\\n            \\n        }\\n        return count;   //return count\\n        \\n    }\\n};\\n```\\nPlease Upvote, if you liked my solution.\\nDont forget to visit my repo: https://github.com/tarunsahnan/LeetCode-Solutions",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// The easiest solution to this problem is:\\n// Step 1: Calculate length of \"pref\"\\n// Step 2: find substring of \"words\" from 0 to length of \"pref\"\\n// if both match increment count by 1;\\n\\n\\n\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n        int count=0;\\n        int preflen=pref.size();        //step 1\\n        \\n        for(auto i:words){\\n            if(i.substr(0,preflen) == pref)     //step 2\\n                count++;                        //if both matches then increment count by 1\\n            \\n        }\\n        return count;   //return count\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802490,
                "title": "java-python-3-1-liners-and-a-follow-up",
                "content": "\\n\\n```java\\n    public int prefixCount(String[] words, String pref) {\\n        return (int)Stream.of(words).filter(w -> w.startsWith(pref)).count();\\n    }\\n```\\n```python\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(w.startswith(pref) for w in words)\\n```\\n\\n----\\n\\n**Follow-up:**\\n\\n*Q*: A followup question from Google: what if the words are sorted lexicographically? -- credit to **@blackspinner**\\n*A*: We can use binary search twice to locate the lower and upper bounds of the words that have the same prefix. Therefore, the time cost is O(klogn). e.g., \\nAssume `perf = \"abcd\"`, we can search `\"abcd\"` and `\"abce\"` respectively.\\n\\n\\n",
                "solutionTags": [],
                "code": "```java\\n    public int prefixCount(String[] words, String pref) {\\n        return (int)Stream.of(words).filter(w -> w.startsWith(pref)).count();\\n    }\\n```\n```python\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(w.startswith(pref) for w in words)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1803108,
                "title": "java-solution-easy",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n    int c = 0;\\n    for(String s : words) {\\n        if(s.indexOf(pref)==0) \\n            c++;\\n    }\\n    return c; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n    int c = 0;\\n    for(String s : words) {\\n        if(s.indexOf(pref)==0) \\n            c++;\\n    }\\n    return c; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802494,
                "title": "python3-java-c-find-indexof",
                "content": "\\n<iframe src=\"https://leetcode.com/playground/8dV5wFQP/shared\" frameBorder=\"0\" width=\"480\" height=\"160\"></iframe>\\n",
                "solutionTags": [],
                "code": "\\n<iframe src=\"https://leetcode.com/playground/8dV5wFQP/shared\" frameBorder=\"0\" width=\"480\" height=\"160\"></iframe>\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1802788,
                "title": "one-liner-count-if",
                "content": "**C++**\\n```cpp\\nint prefixCount(vector<string>& ws, string pref) {\\n    return count_if(begin(ws), end(ws), [&](const string &w){\\n       return w.compare(0, pref.size(), pref) == 0; \\n    });\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint prefixCount(vector<string>& ws, string pref) {\\n    return count_if(begin(ws), end(ws), [&](const string &w){\\n       return w.compare(0, pref.size(), pref) == 0; \\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1809593,
                "title": "python-one-line-simple-solution",
                "content": "**Python**\\n\\n```\\ndef prefixCount(self, words: List[str], pref: str) -> int:\\n\\treturn sum([word.startswith(pref) for word in words])\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef prefixCount(self, words: List[str], pref: str) -> int:\\n\\treturn sum([word.startswith(pref) for word in words])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1802715,
                "title": "trie-vs-brute-force-vs-find",
                "content": "**Trie Method**:\\n\\n1. First put all the words in the trie and keep on incrementing counting of prefix after every letter.\\n2. Now traverse prefix and get the count , number of word this prefix has occured.\\n\\n**It is a Standard Trie Implementation ALgorithm**\\n**C++**\\n  \\n    struct Node{\\n      Node* links[26];\\n      int prefix=0;\\n        \\n      bool contains(char c){\\n         return links[c-\\'a\\']!=0;\\n      }    \\n    \\n      void create(char c,Node* node){\\n          links[c-\\'a\\']=node;\\n      }\\n    \\n      void increment(){\\n          prefix++;\\n      }\\n    \\n      int count(){\\n          return prefix;\\n      }\\n    \\n      Node* next(char c){\\n          return links[c-\\'a\\'];\\n      }\\n    };\\n\\t\\n\\t//Trie Class\\n    class Trie{\\n      Node* root; \\n      public:\\n   \\n      Trie(){\\n          root=new Node();\\n      }\\n\\t  \\n      //insert words\\n      void insert(string word){\\n          Node* ptr=root;\\n          for(auto i:word){\\n             if(!ptr->contains(i))  ptr->create(i,new Node());\\n             ptr=ptr->next(i);\\n             ptr->increment();\\n          }\\n      }\\n\\t  \\n      //return count of given prefix\\n      int cnt_pref(string word){\\n          Node* ptr=root;\\n          for(auto i:word){\\n              if(!ptr->contains(i)) return 0;\\n              ptr=ptr->next(i);\\n          }\\n          return ptr->count();\\n      }\\n    };\\n\\t\\n\\t//input class\\n\\tclass Solution {\\n    public:\\n    int prefixCount(vector<string>& words, string pref) {\\n        Trie trie;\\n        for(auto i:words) trie.insert(i);  //no. of words*average length of strings\\n        int cnt= trie.cnt_pref(pref);  //length of prefix\\n        return cnt;\\n    }\\n    };\\n**Time** - O(number of words * average length of words + prefix_length)\\n**Space** - O(Average length * 26)\\n\\n# Find() Algorithm Method:\\n   \\n   \\n    int prefixCount(vector<string>& words, string &pref) {\\n        int cnt=0;\\n        for(auto i:words){\\n            auto q= i.find(pref);\\n            if(q!=string::npos and q==0) cnt++;\\n        }\\n        return cnt;\\n    }\\n**Time** - O(N * M)\\n**Space** - O(1)\\n\\t\\n# Brute Force\\t\\n\\n     bool check(string &x,string &y,int i){\\n\\t        if(i==y.size()) return true;\\n            return x[i]==y[i]? check(x,y,i+1) : false;\\n\\t }\\n\\t \\n     int prefixCount(vector<string>& words, string &pref){\\n        int cnt=0;\\n        for(auto i:words){\\n            if(i.size()<pref.size()) continue;\\n            cnt+= check(i,pref,0)? 1 : 0 ;\\n        }\\n        return cnt;\\n    }\\n**Time** - O(N * min(pref.size(),average length of strings)\\n**Space** - O(1)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    public:\\n    int prefixCount(vector<string>& words, string pref) {\\n        Trie trie;\\n        for(auto i:words) trie.insert(i);  //no. of words*average length of strings\\n        int cnt= trie.cnt_pref(pref);  //length of prefix\\n        return cnt;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1802447,
                "title": "c-with-explanation-easy",
                "content": "**Explanation-**\\nCheck if word contains pref, and if it contains then it should be at ```0th``` position\\n\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans=0;\\n        for(auto & word:words)\\n            if(word.find(pref)==0)\\n                ans++;\\n        return ans;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```0th```\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans=0;\\n        for(auto & word:words)\\n            if(word.find(pref)==0)\\n                ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581816,
                "title": "python-easy-and-straight-forward-approach",
                "content": "\\tclass Solution:\\n\\t\\tdef prefixCount(self, words: List[str], pref: str) -> int:\\n\\t\\t\\tn = len(pref)\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor w in words:\\n\\t\\t\\t\\tif w[:n] == pref:\\n\\t\\t\\t\\t\\tcount += 1\\n\\n\\t\\t\\treturn count",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef prefixCount(self, words: List[str], pref: str) -> int:\\n\\t\\t\\tn = len(pref)\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor w in words:\\n\\t\\t\\t\\tif w[:n] == pref:\\n\\t\\t\\t\\t\\tcount += 1\\n\\n\\t\\t\\treturn count",
                "codeTag": "Java"
            },
            {
                "id": 1814309,
                "title": "javascript-easy-to-understand-1-line",
                "content": "The core strategy for this problem is straightforward:\\n- traverse the list\\n- check each word is with a given prefix\\n\\nI guess there won\\'t be any problem with how to do the traversal. So, the only problem is how to check the prefix?\\n\\nWe could use `RegExp`, `indexOf`, `startsWith`, or even `slice` the first part.\\nJust choose anyone you like, here are 2 samples from me:\\n\\n## Sample 1\\n\\n```js\\nconst prefixCount = (words, pref) => {\\n  let count = 0;\\n  for (const word of words) {\\n    word.startsWith(pref) && ++count;\\n  }\\n  return count;\\n}\\n```\\n\\n## Sample 2\\n\\n```js\\nconst prefixCount = (words, pref) => words.filter(word => word.startsWith(pref)).length;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst prefixCount = (words, pref) => {\\n  let count = 0;\\n  for (const word of words) {\\n    word.startsWith(pref) && ++count;\\n  }\\n  return count;\\n}\\n```\n```js\\nconst prefixCount = (words, pref) => words.filter(word => word.startsWith(pref)).length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802677,
                "title": "javascript-1-line-solution",
                "content": "```\\nvar prefixCount = function(words, pref) {\\n    return words.filter(word => word.slice(0, pref.length) === pref).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function(words, pref) {\\n    return words.filter(word => word.slice(0, pref.length) === pref).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3555249,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].startsWith(pref))\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].startsWith(pref))\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848590,
                "title": "c-solution-using-substr",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans=0;\\n        for(auto x:words){\\n            if(x.substr(0,pref.size()) == pref)\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans=0;\\n        for(auto x:words){\\n            if(x.substr(0,pref.size()) == pref)\\n            {\\n                ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1802520,
                "title": "simple-solution",
                "content": "```\\nclass Solution {\\n    bool check(string &s , string &p){\\n          if(s.length() < p.length())\\n              return false;\\n          int i = 0;\\n        for(i = 0 ; i < p.length() ; i++){\\n           if(p[i] != s[i])\\n               return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt = 0;\\n        int n = words.size();\\n        for(int i = 0 ; i < n ; i++){\\n           if(check(words[i] , pref))\\n               cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool check(string &s , string &p){\\n          if(s.length() < p.length())\\n              return false;\\n          int i = 0;\\n        for(i = 0 ; i < p.length() ; i++){\\n           if(p[i] != s[i])\\n               return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt = 0;\\n        int n = words.size();\\n        for(int i = 0 ; i < n ; i++){\\n           if(check(words[i] , pref))\\n               cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3682359,
                "title": "simplest-python-solution-use-startswith",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        cnt = 0\\n        for s in words:\\n            if s.startswith(pref):\\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        cnt = 0\\n        for s in words:\\n            if s.startswith(pref):\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534682,
                "title": "simple-easy-java-solution-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].startsWith(pref))count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].startsWith(pref))count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160664,
                "title": "c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n\\n    int prefix_size = pref.size();\\n    int n=words.size();\\n    int count = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        string s1 = words[i].substr(0, prefix_size);\\n        if (s1 == pref)\\n        {\\n            count++;\\n        }\\n    }\\n    return count;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n\\n    int prefix_size = pref.size();\\n    int n=words.size();\\n    int count = 0;\\n    for (int i = 0; i < n; i++)\\n    {\\n        string s1 = words[i].substr(0, prefix_size);\\n        if (s1 == pref)\\n        {\\n            count++;\\n        }\\n    }\\n    return count;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854383,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (String word: words) {\\n            if (word.indexOf(pref) == 0) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (String word: words) {\\n            if (word.indexOf(pref) == 0) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2726749,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n    int count = 0;\\n        for(int i = 0; i<words.length; i++){\\n        if(words[i].startsWith(pref)){\\n            count++;\\n        }\\n    }\\n    return count;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n    int count = 0;\\n        for(int i = 0; i<words.length; i++){\\n        if(words[i].startsWith(pref)){\\n            count++;\\n        }\\n    }\\n    return count;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2034337,
                "title": "java-beginner-friendly-fast-solution",
                "content": "class Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0 ;\\n      for(int i = 0 ;i<words.length ;i++){\\n        int l = pref.length();\\n       if(l<=words[i].length()){\\n          String sub = words[i].substring(0,l);\\n        if(pref.equals(sub))\\n          count++;\\n       }\\n      }\\n      return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0 ;\\n      for(int i = 0 ;i<words.length ;i++){\\n        int l = pref.length();\\n       if(l<=words[i].length()){\\n          String sub = words[i].substring(0,l);\\n        if(pref.equals(sub))\\n          count++;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1823579,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Time Complexity : O(n*m)**\\n**Java**\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(String word : words){\\n            if(word.indexOf(pref) == 0) count++;   \\n        }\\n        return count;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let word of words){\\n        if(word.indexOf(pref) == 0) count++;\\n    }\\n    return count;\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def prefixCount(self, words, pref):\\n        count = 0\\n        for word in words:\\n            if pref in word and word.index(pref) == 0:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(String word : words){\\n            if(word.indexOf(pref) == 0) count++;   \\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let word of words){\\n        if(word.indexOf(pref) == 0) count++;\\n    }\\n    return count;\\n};\\n```\n```\\nclass Solution(object):\\n    def prefixCount(self, words, pref):\\n        count = 0\\n        for word in words:\\n            if pref in word and word.index(pref) == 0:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803163,
                "title": "python-1-liner-solution",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(word.find(pref) == 0 for word in words)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(word.find(pref) == 0 for word in words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802965,
                "title": "simple-short-c",
                "content": "**Counting Words With a Given Prefix**\\nTravel each word in words and check if it\\'s size is greater or equal to size if prefix and compare the substring of length n(size of prefix) with prefix, if equal increase count.\\n\\n```\\nint prefixCount(vector<string>& words, string p) {\\n        int n=p.size();\\n        int ans=0;\\n        for(auto w:words)\\n        {\\n            if(w.size()>=n and w.substr(0,n)==p)\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nint prefixCount(vector<string>& words, string p) {\\n        int n=p.size();\\n        int ans=0;\\n        for(auto w:words)\\n        {\\n            if(w.size()>=n and w.substr(0,n)==p)\\n            {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802930,
                "title": "easy-c-solution-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count = 0;\\n        for(auto it : words){\\n            bool flag = true;\\n            for(int i=0;i<pref.size();i++){\\n                if(pref[i] != it[i]) {flag = false; break;}\\n            }\\n            if(flag) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count = 0;\\n        for(auto it : words){\\n            bool flag = true;\\n            for(int i=0;i<pref.size();i++){\\n                if(pref[i] != it[i]) {flag = false; break;}\\n            }\\n            if(flag) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802627,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt=0;\\n        int n=pref.size();\\n        for(auto s:words)\\n        {\\n            if(s.size()>=pref.size())\\n            {\\n                if(s.substr(0,n)==pref)\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt=0;\\n        int n=pref.size();\\n        for(auto s:words)\\n        {\\n            if(s.size()>=pref.size())\\n            {\\n                if(s.substr(0,n)==pref)\\n                    cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802436,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans  = 0;\\n            for(int i = 0; i < words.size(); i++){\\n                    int j = 0;\\n                    int n = words[i].length();\\n                    if(n<pref.length())continue;\\n                    {\\n        while(j<pref.length()){\\n        if(pref[j] == words[i][j])\\n               j++;\\n                    }\\n                      else \\n                          break;            \\n                    }\\n                    if(j==pref.length())ans++;\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans  = 0;\\n            for(int i = 0; i < words.size(); i++){\\n                    int j = 0;\\n                    int n = words[i].length();\\n                    if(n<pref.length())continue;\\n                    {\\n        while(j<pref.length()){\\n        if(pref[j] == words[i][j])\\n               j++;\\n                    }\\n                      else \\n                          break;            \\n                    }\\n                    if(j==pref.length())ans++;\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968993,
                "title": "check-if-a-word-occurs-o-n-javascript-memory-95-45-meaningful-vars",
                "content": "```\\nvar prefixCount = function(words, pref) {\\n    for (let index = 0; index < words.length; index++) {\\n        words[index] = words[index].substring(0, pref.length);\\n    }\\n    let count = 0;\\n    for (const iterator of words) {\\n        if (iterator === pref) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/15db9f0b-0bd0-4e79-90ae-f5166da971ac_1693163848.8008177.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function(words, pref) {\\n    for (let index = 0; index < words.length; index++) {\\n        words[index] = words[index].substring(0, pref.length);\\n    }\\n    let count = 0;\\n    for (const iterator of words) {\\n        if (iterator === pref) {\\n            count++;\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3853168,
                "title": "easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(s.length)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] s, String t) {\\n        int n=s.length;\\n        int count=0;\\n        int m=t.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i].startsWith(t))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] s, String t) {\\n        int n=s.length;\\n        int count=0;\\n        int m=t.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i].startsWith(t))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579916,
                "title": "one-line-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(1 for i in words if i.startswith(pref))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(1 for i in words if i.startswith(pref))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575096,
                "title": "java-easy-solution-100-beats",
                "content": "# Approach\\n\\n1. Initialize a variable `count` to 0. This variable will keep track of the number of strings in the `words` array that contain `pref` as a prefix.\\n\\n2. Iterate through each string `word` in the `words` array using a for-each loop.\\n\\n3. For each `word`, check if it starts with the `pref` string using the `startsWith()` method. This method returns `true` if the `word` starts with the `pref` string, and `false` otherwise.\\n\\n4. If the `startsWith()` method returns `true`, increment the `count` variable by 1.\\n\\n5. After iterating through all the strings in the `words` array, the `count` variable will contain the total number of strings that have `pref` as a prefix.\\n\\n6. Return the value of the `count` variable.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(String word : words)\\n            if(word.startsWith(pref)) count++;\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(String word : words)\\n            if(word.startsWith(pref)) count++;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533558,
                "title": "simple-java-solution-for-beginners-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(String x : words) {\\n            if(x.startsWith(pref)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(String x : words) {\\n            if(x.startsWith(pref)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443720,
                "title": "substr-solution-easy-c",
                "content": "`Please Upvote If you Like !!!!`\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n = pref.size();\\n        int ans  = 0;\\n        for(auto & w : words) {\\n            if(w.substr(0,n) == pref) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n = pref.size();\\n        int ans  = 0;\\n        for(auto & w : words) {\\n            if(w.substr(0,n) == pref) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338829,
                "title": "simple-approach-explained-for-beginners",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all understand the question take your time ; \\nAfter this Google it what you want;\\nDo not use chatGPT it will directly jumps to the solution with example.\\nFor example I don\\'t know about startsWith() func;\\nJust type on google \"i want to check a string contains at prefix or not\";\\nThe only you need in programming is to apply basic if, else and for loop and that is more than enough to enter in the world of DSA\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            boolean ans = words[i].startsWith(pref);\\n            if (ans) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            boolean ans = words[i].startsWith(pref);\\n            if (ans) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254512,
                "title": "counting-words-with-a-given-prefix-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int i, j, count=0, flag=0;\\n        for(i=0 ; i<words.size() ; i++)\\n        {\\n            flag=0;\\n            for(j=0 ; j<pref.length() ; j++)\\n            {\\n                if(words[i][j]!=pref[j])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int i, j, count=0, flag=0;\\n        for(i=0 ; i<words.size() ; i++)\\n        {\\n            flag=0;\\n            for(j=0 ; j<pref.length() ; j++)\\n            {\\n                if(words[i][j]!=pref[j])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag==0)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247423,
                "title": "counting-words-with-a-given-prefix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![countingwords.PNG](https://assets.leetcode.com/users/images/8d68c99b-176b-4804-a2bf-630bc38328e6_1677757448.8018465.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        count=0\\n        for i in words:\\n            if pref in i and i.index(pref)==0:\\n                print(i)\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        count=0\\n        for i in words:\\n            if pref in i and i.index(pref)==0:\\n                print(i)\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864108,
                "title": "c-short-4-line-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(auto wd : words)\\n\\t\\t\\t\\tif(wd.find(pref) < 1) // check if first occurrence of sub-string in the specified string\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor(auto wd : words)\\n\\t\\t\\t\\tif(wd.find(pref) < 1) // check if first occurrence of sub-string in the specified string\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\treturn count;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2705558,
                "title": "cpp-simple-solution-95-00",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& arr, string pref) \\n    {\\n        int count=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            string word = arr[i];\\n            bool flag=true;\\n            \\n            int temp1=0;\\n            int temp2=0;\\n\\n            while(temp1<pref.length() and temp2<word.length())\\n            {\\n               if(pref[temp1]!=word[temp2])\\n               {\\n                  flag=false;\\n                  break;\\n               }\\n               temp1++;\\n               temp2++;\\n            }\\n            if(temp1>=pref.length() and flag==true)\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& arr, string pref) \\n    {\\n        int count=0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            string word = arr[i];\\n            bool flag=true;\\n            \\n            int temp1=0;\\n            int temp2=0;\\n\\n            while(temp1<pref.length() and temp2<word.length())\\n            {\\n               if(pref[temp1]!=word[temp2])\\n               {\\n                  flag=false;\\n                  break;\\n               }\\n               temp1++;\\n               temp2++;\\n            }\\n            if(temp1>=pref.length() and flag==true)\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695836,
                "title": "python-simple-solution-in-5-lines-faster-than-93-39",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        c,l=0,len(pref)\\n        for i in words:\\n            if i[:l]==pref:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        c,l=0,len(pref)\\n        for i in words:\\n            if i[:l]==pref:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694136,
                "title": "java-1ms-fast-solution",
                "content": "```\\n\\t\\tint count=0;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].startsWith(pref)){\\n                count++;\\n            }\\n        }\\n        return count;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tint count=0;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].startsWith(pref)){\\n                count++;\\n            }\\n        }\\n        return count;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2594345,
                "title": "java-trie",
                "content": "```\\nclass Solution {\\n    TrieNode root = new TrieNode();\\n    public int prefixCount(String[] words, String pref) {\\n        int res = 0;\\n        insertPrefix(pref);\\n        \\n        for (String word : words) {\\n            if (hasPrefix(word)) res++;\\n        }\\n        return res;\\n    }\\n    \\n    private void insertPrefix(String pref) {\\n        TrieNode node = root;\\n        for (char c : pref.toCharArray()) {\\n            if (node.children[c - \\'a\\'] == null) {\\n                node.children[c - \\'a\\'] = new TrieNode();\\n            }\\n            node = node.children[c - \\'a\\'];\\n        }\\n        node.isEnd = true;\\n    }\\n    \\n    private boolean hasPrefix(String word) {\\n        boolean res = false;\\n        TrieNode node = root;\\n        for (char c : word.toCharArray()) {\\n            if (node.children[c - \\'a\\'] == null) {\\n                break;\\n            }\\n            if (node.children[c - \\'a\\'].isEnd) { // easy to mistake as node.isEnd\\n                res = true;\\n            }\\n            node = node.children[c - \\'a\\'];\\n        }\\n        return res;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children = new TrieNode[26];\\n    boolean isEnd;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TrieNode root = new TrieNode();\\n    public int prefixCount(String[] words, String pref) {\\n        int res = 0;\\n        insertPrefix(pref);\\n        \\n        for (String word : words) {\\n            if (hasPrefix(word)) res++;\\n        }\\n        return res;\\n    }\\n    \\n    private void insertPrefix(String pref) {\\n        TrieNode node = root;\\n        for (char c : pref.toCharArray()) {\\n            if (node.children[c - \\'a\\'] == null) {\\n                node.children[c - \\'a\\'] = new TrieNode();\\n            }\\n            node = node.children[c - \\'a\\'];\\n        }\\n        node.isEnd = true;\\n    }\\n    \\n    private boolean hasPrefix(String word) {\\n        boolean res = false;\\n        TrieNode node = root;\\n        for (char c : word.toCharArray()) {\\n            if (node.children[c - \\'a\\'] == null) {\\n                break;\\n            }\\n            if (node.children[c - \\'a\\'].isEnd) { // easy to mistake as node.isEnd\\n                res = true;\\n            }\\n            node = node.children[c - \\'a\\'];\\n        }\\n        return res;\\n    }\\n}\\n\\nclass TrieNode {\\n    TrieNode[] children = new TrieNode[26];\\n    boolean isEnd;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572272,
                "title": "4-lines-java-easy-code",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(String s :words){\\n            if(s.length()>=pref.length() && s.substring(0,pref.length()).equals(pref))count++;\\n        }\\n            return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(String s :words){\\n            if(s.length()>=pref.length() && s.substring(0,pref.length()).equals(pref))count++;\\n        }\\n            return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2189043,
                "title": "java-stream-for-loop-solution",
                "content": "# For LOOP && STRING.STARTSWITH || STREAM FILTER && COUNT #\\n`Unfortunately, both functions are not as fast as you think \\uD83D\\uDE29`\\n\\n``Faster function than the latter \\uD83E\\uDD13``\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (String word : words) {\\n            if (word.startsWith(pref)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n``Eazy function \\uD83D\\uDE0E ``\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n\\t\\treturn (int) Arrays.stream(words).filter(item -> item.startsWith(pref)).count();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (String word : words) {\\n            if (word.startsWith(pref)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n\\t\\treturn (int) Arrays.stream(words).filter(item -> item.startsWith(pref)).count();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175494,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].startsWith(pref))\\n            {\\n                count++;\\n            }\\n        }\\n        return count;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(int i=0;i<words.length;i++)\\n        {\\n            if(words[i].startsWith(pref))\\n            {\\n                count++;\\n            }\\n        }\\n        return count;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048962,
                "title": "easy-python-solution-for-beginners",
                "content": "```\\ndef prefixCount(self, words: List[str], pref: str) -> int:\\n        l=len(pref)\\n        c=0\\n        for i in words:\\n            if i[:l]==pref:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef prefixCount(self, words: List[str], pref: str) -> int:\\n        l=len(pref)\\n        c=0\\n        for i in words:\\n            if i[:l]==pref:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1903737,
                "title": "easy-solution-o-n-complexity-one-liner-without-using-startswith-inbuilt-function",
                "content": "Aint no brainer to use startswith function and compare the prefix of string. \\nI came up with the easiest solution that can be easiily understood by anyone , be it a beginner or a pro!\\n\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n\\t\\treturn sum([1 for i in words if i[:len(pref)]==pref])\\n```\\n\\n**If this helped PLEASE UPVOTE!**\\nThanks for stopping by!\\nHave a good day:)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n\\t\\treturn sum([1 for i in words if i[:len(pref)]==pref])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1862998,
                "title": "java-one-liner",
                "content": "```\\npublic int prefixCount(String[] words, String pref) {\\n        return (int) Arrays.stream(words).filter(w -> w.startsWith(pref)).count();\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int prefixCount(String[] words, String pref) {\\n        return (int) Arrays.stream(words).filter(w -> w.startsWith(pref)).count();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1819619,
                "title": "kotlin-1-line",
                "content": "```\\nfun prefixCount(a: Array<String>, p: String) = a.count { it.startsWith(p) }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun prefixCount(a: Array<String>, p: String) = a.count { it.startsWith(p) }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1807311,
                "title": "c-1-liner-linq",
                "content": "```cs\\npublic int PrefixCount(string[] words, string pref) =>\\n    words.Count(w => w.StartsWith(pref));\\n```\\n\\nCheck out my other C# 1-liners!\\n* https://leetcode.com/discuss/general-discussion/2905237/c-sharp-1-liners",
                "solutionTags": [],
                "code": "```cs\\npublic int PrefixCount(string[] words, string pref) =>\\n    words.Count(w => w.StartsWith(pref));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1806042,
                "title": "java-indexof-100",
                "content": "if you like this solution pls upvote :)\\n\\nJAVA\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int res = 0;\\n        for(String word: words) \\n            res += (word.indexOf(pref) == 0) ? 1 : 0;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int res = 0;\\n        for(String word: words) \\n            res += (word.indexOf(pref) == 0) ? 1 : 0;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804613,
                "title": "c-simple-solution-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt=0;\\n        for(auto word:words){\\n            int i=0;\\n            int j=0;\\n            while(i<word.size() && j<pref.size()){\\n                if(i!=pref.size()-1 && word[i]==pref[j]){\\n                    i++;\\n                    j++;\\n                }\\n                else if(word[i]==pref[i] && i==pref.size()-1){\\n                    i++;\\n                    j++;\\n                    cnt++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt=0;\\n        for(auto word:words){\\n            int i=0;\\n            int j=0;\\n            while(i<word.size() && j<pref.size()){\\n                if(i!=pref.size()-1 && word[i]==pref[j]){\\n                    i++;\\n                    j++;\\n                }\\n                else if(word[i]==pref[i] && i==pref.size()-1){\\n                    i++;\\n                    j++;\\n                    cnt++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804393,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {\\n        words.iter().filter(|word| word.starts_with(pref.as_str())).count() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {\\n        words.iter().filter(|word| word.starts_with(pref.as_str())).count() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803276,
                "title": "leetcode-2185-counting-words-with-a-given-prefix-100-faster",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n      int c=0;\\n      int n=pref.length();\\n      for(int i=0; i<words.length; i++)\\n      {\\n          if(words[i].length()>=n && words[i].substring(0,n).equals(pref))c++;\\n      }\\n     return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n      int c=0;\\n      int n=pref.length();\\n      for(int i=0; i<words.length; i++)\\n      {\\n          if(words[i].length()>=n && words[i].substring(0,n).equals(pref))c++;\\n      }\\n     return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802865,
                "title": "javascript-startswith-method",
                "content": "```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let word of words) {\\n        if(word.startsWith(pref)) count++;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let word of words) {\\n        if(word.startsWith(pref)) count++;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802740,
                "title": "simple-python-solution",
                "content": "\\t\\tclass Solution(object):\\n\\t\\t\\tdef prefixCount(self, words, pref):\\n\\t\\t\\t  c=0\\n\\t\\t\\t  for i in words:\\n\\t\\t\\t\\t if(pref in i):\\n\\t\\t\\t\\t\\tif(i.index(pref)==0):\\n\\t\\t\\t\\t\\t  c=c+1           \\n\\t\\t\\treturn c",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t\\tclass Solution(object):\\n\\t\\t\\tdef prefixCount(self, words, pref):\\n\\t\\t\\t  c=0\\n\\t\\t\\t  for i in words:\\n\\t\\t\\t\\t if(pref in i):\\n\\t\\t\\t\\t\\tif(i.index(pref)==0):\\n\\t\\t\\t\\t\\t  c=c+1           \\n\\t\\t\\treturn c",
                "codeTag": "Java"
            },
            {
                "id": 1802639,
                "title": "c-readable-code-concise-solution",
                "content": "```\\nbool check(string s,string pre){\\n        if(pre.length()>s.length()){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<pre.length();i++){\\n            if(pre[i]!=s[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int prefixCount(vector<string>& words, string pref) {\\n        int res = 0;\\n        for(auto s:words){\\n            \\n            if(check(s,pref)){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool check(string s,string pre){\\n        if(pre.length()>s.length()){\\n            return false;\\n        }\\n        \\n        for(int i=0;i<pre.length();i++){\\n            if(pre[i]!=s[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int prefixCount(vector<string>& words, string pref) {\\n        int res = 0;\\n        for(auto s:words){\\n            \\n            if(check(s,pref)){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802620,
                "title": "can-t-be-more-easy",
                "content": "class Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n        int n = words.size(); \\n        int k = pref.length(); \\n        \\n        int count = 0; \\n        for(int i  =0; i<n; i++)\\n        {\\n            if(words[i].length() >= k)\\n            {\\n                if(words[i].substr(0,k) == pref)\\n                    count++; \\n            }\\n        }\\n        return count; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n        int n = words.size(); \\n        int k = pref.length(); \\n        \\n        int count = 0; \\n        for(int i  =0; i<n; i++)\\n        {\\n            if(words[i].length() >= k)\\n            {\\n                if(words[i].substr(0,k) == pref)\\n                    count++; \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4009632,
                "title": "different-approach-using-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n*Initialize a count variable to keep track of words with the given prefix.\\n*Iterate through each word in the array.\\n*Compare characters between the word and the prefix.\\n*If they match, increment the count.\\n*If the count reaches the length of the prefix, increment the count of words with the prefix.\\nReturn the count as the result.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int original=0;\\n        for(int i=0;i<words.length;i++){\\n            String sw=words[i];\\n            int index=0;\\n            int count=0;\\n            while(index<sw.length() && index<pref.length()){\\n                if(sw.charAt(index)==pref.charAt(index)){\\n                    count++;\\n                }\\n                if(count==pref.length()){\\n                    original++;\\n                }\\n                index++;\\n            }\\n        }\\n        return original ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int original=0;\\n        for(int i=0;i<words.length;i++){\\n            String sw=words[i];\\n            int index=0;\\n            int count=0;\\n            while(index<sw.length() && index<pref.length()){\\n                if(sw.charAt(index)==pref.charAt(index)){\\n                    count++;\\n                }\\n                if(count==pref.length()){\\n                    original++;\\n                }\\n                index++;\\n            }\\n        }\\n        return original ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656007,
                "title": "beginners-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    read the code once you will get it\\n\\n# Complexity\\n- Time complexity: O(nm)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(String word: words){\\n            if(word.length()>=pref.length() && word.substring(0,pref.length()).equals(pref)) count++;\\n        }\\nreturn count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        for(String word: words){\\n            if(word.length()>=pref.length() && word.substring(0,pref.length()).equals(pref)) count++;\\n        }\\nreturn count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3498495,
                "title": "rust-0-ms",
                "content": "\\n```\\nimpl Solution {\\n    pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {\\n        words\\n            .into_iter()\\n            .filter(|word| word.starts_with(&pref))\\n            .count() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {\\n        words\\n            .into_iter()\\n            .filter(|word| word.starts_with(&pref))\\n            .count() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3337663,
                "title": "easy-to-understand-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int pl=pref.length(),count=0,l=0; //pl is prefix length\\n\\n        for(String y:words){\\n            l=Math.min(pl,y.length());  //comparing identify the smallest length\\n           y=y.substring(0,l);   \\n           System.out.println(y);\\n            if(y.equals(pref))\\n            count++;\\n        }\\n        return count;\\n        \\n    \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int pl=pref.length(),count=0,l=0; //pl is prefix length\\n\\n        for(String y:words){\\n            l=Math.min(pl,y.length());  //comparing identify the smallest length\\n           y=y.substring(0,l);   \\n           System.out.println(y);\\n            if(y.equals(pref))\\n            count++;\\n        }\\n        return count;\\n        \\n    \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301114,
                "title": "very-easy-simple-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n    int count=0;\\n        for(int i=0;i<words.length;i++) {\\n            if(words[i].startsWith(pref)) \\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n    int count=0;\\n        for(int i=0;i<words.length;i++) {\\n            if(words[i].startsWith(pref)) \\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210317,
                "title": "java-solution-using-method",
                "content": "This method uses the method (startsWith),which is used to check the starting of both the string.\\n\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int cnt=0;\\n        for(String str:words){\\n            if(str.startsWith(pref)){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int cnt=0;\\n        for(String str:words){\\n            if(str.startsWith(pref)){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163839,
                "title": "beats-100-time-complexity",
                "content": "![Screenshot 2023-02-09 at 4.10.32 PM.png](https://assets.leetcode.com/users/images/6fee551e-5497-4942-9fc7-ab61903482cc_1675939587.9287362.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCompare the first pref.length characters of words[i] and pref, and keep count.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} pref\\n * @return {number}\\n */\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let i = 0; i<words.length; i++) {\\n        if(pref === words[i].slice(0, pref.length)) count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} pref\\n * @return {number}\\n */\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let i = 0; i<words.length; i++) {\\n        if(pref === words[i].slice(0, pref.length)) count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3161282,
                "title": "simple-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i].substr(0,pref.length())==pref)\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i].substr(0,pref.length())==pref)\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131974,
                "title": "best-c-code-easy-to-understand-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int res=0;\\n        for(int i=0;i<words.size();i++)\\n        {   \\n            int b=0;\\n            for( int j=0;j<pref.size();j++)\\n            {\\n                // if(words.size()<=pref.size())\\n                // {\\n                //     break;\\n                // }\\n                 if(words[i][j]!=pref[j])\\n                 { \\n                     break;\\n                 }\\n                 else\\n                 {\\n                     b++;\\n                 }\\n            }\\n            if(b==pref.size())\\n            {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nIF FOUND USEFULL DO UPVOTE",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int res=0;\\n        for(int i=0;i<words.size();i++)\\n        {   \\n            int b=0;\\n            for( int j=0;j<pref.size();j++)\\n            {\\n                // if(words.size()<=pref.size())\\n                // {\\n                //     break;\\n                // }\\n                 if(words[i][j]!=pref[j])\\n                 { \\n                     break;\\n                 }\\n                 else\\n                 {\\n                     b++;\\n                 }\\n            }\\n            if(b==pref.size())\\n            {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131970,
                "title": "simple-and-easy-to-understand-c-solution",
                "content": "Beats 95%+ in Runtime.....\\u270C\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int c=0;\\n        for(auto word:words){\\n            int b=0;\\n            for(int i=0;i<pref.size();i++){\\n                if(word[i]!=pref[i]){\\n                    break;\\n                }else{\\n                    b++;\\n                }\\n            }\\n            if(b==pref.size()){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\\n\\nHope you like the code implementation, make sure to upvote \\u270C\\nGood day, keep coding .....",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int c=0;\\n        for(auto word:words){\\n            int b=0;\\n            for(int i=0;i<pref.size();i++){\\n                if(word[i]!=pref[i]){\\n                    break;\\n                }else{\\n                    b++;\\n                }\\n            }\\n            if(b==pref.size()){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099858,
                "title": "c-no-built-in-functions",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int PrefixCount(string[] words, string pref) {\\n        var count = 0;\\n\\n        var j = 0;\\n        for (int i = 0; i < words.Length; i++)\\n        {\\n            if (words[i].Length < pref.Length) continue;\\n            var hasPrefix = true;\\n            while (j < pref.Length)\\n            {\\n                if (pref[j] != words[i][j])\\n                {\\n                    hasPrefix = false;\\n                    break;\\n                }\\n                j++;\\n            }\\n\\n            if (hasPrefix) count++;\\n            j = 0;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int PrefixCount(string[] words, string pref) {\\n        var count = 0;\\n\\n        var j = 0;\\n        for (int i = 0; i < words.Length; i++)\\n        {\\n            if (words[i].Length < pref.Length) continue;\\n            var hasPrefix = true;\\n            while (j < pref.Length)\\n            {\\n                if (pref[j] != words[i][j])\\n                {\\n                    hasPrefix = false;\\n                    break;\\n                }\\n                j++;\\n            }\\n\\n            if (hasPrefix) count++;\\n            j = 0;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868181,
                "title": "javascript-faster-than-98-23-memory-beats-96-25",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} words\\n * @param {string} pref\\n * @return {number}\\n */\\nvar prefixCount = function(words, pref) {\\n    let includesPref = 0\\n    for (let word in words) {\\n        if (words[word].startsWith(pref)) includesPref++;\\n    }\\n    return includesPref;\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/2d582eb8-b759-41f7-9c46-1653faf86581_1669947042.89424.png)\\n![image.png](https://assets.leetcode.com/users/images/73988b56-2668-4549-b940-e30511568004_1669946746.8101223.png)\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @param {string} pref\\n * @return {number}\\n */\\nvar prefixCount = function(words, pref) {\\n    let includesPref = 0\\n    for (let word in words) {\\n        if (words[word].startsWith(pref)) includesPref++;\\n    }\\n    return includesPref;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2825979,
                "title": "javascript",
                "content": "var prefixCount = function(words, pref) {\\n    let count=0;\\n    for( let i=0 ;i<words.length ;i++){\\n        let count1=0\\n        for( let j=0 ;j<words.length ;j++){\\n            if(words[i][j]!==pref[j]){\\n                  count1=0\\n                break;\\n              \\n            }\\n            else if(words[i][j]===pref[j]){\\n                 count1++;\\n                if(count1===pref.length){\\n             \\n                    break;\\n                }\\n               \\n                \\n            }\\n        }\\n        if(count1>0){\\n        count++\\n        }\\n      \\n    }\\n      return count;\\n    \\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var prefixCount = function(words, pref) {\\n    let count=0;\\n    for( let i=0 ;i<words.length ;i++){\\n        let count1=0\\n        for( let j=0 ;j<words.length ;j++){\\n            if(words[i][j]!==pref[j]){\\n                  count1=0\\n                break;\\n              \\n            }\\n            else if(words[i][j]===pref[j]){\\n                 count1++;\\n                if(count1===pref.length){\\n             \\n                    break;\\n                }\\n               \\n                \\n            }\\n        }\\n        if(count1>0){\\n        count++\\n        }\\n      \\n    }\\n      return count;\\n    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2825074,
                "title": "rust-oneline-beats-100-vim-user",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHave a loop go over all words, check if it starts with pref, then count a variable up that will be returned at the end.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\npub fn solution(words: Vec<String>, pref: String) -> i32 {\\n\\n    let mut count = 0;\\n\\n    for word in &words {\\n    \\n        if word.starts_with(&pref) { count += 1 }\\n\\n    }\\n\\n    count\\n}\\n\\n```\\nThen relaised I was writing rust and filter() exists so I rewrote it.\\n\\n# Code\\n```\\nimpl Solution {\\n  \\n  pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {\\n\\n    return words.into_iter().filter(|e| e.starts_with(&pref)).collect::<Vec<_>>().len() as i32;\\n\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub fn solution(words: Vec<String>, pref: String) -> i32 {\\n\\n    let mut count = 0;\\n\\n    for word in &words {\\n    \\n        if word.starts_with(&pref) { count += 1 }\\n\\n    }\\n\\n    count\\n}\\n\\n```\n```\\nimpl Solution {\\n  \\n  pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {\\n\\n    return words.into_iter().filter(|e| e.starts_with(&pref)).collect::<Vec<_>>().len() as i32;\\n\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2733892,
                "title": "trie-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    class TrieNode {\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        boolean eow = false;\\n        int count = 0;\\n    }\\n\\n    class Trie {\\n        TrieNode root = new TrieNode();\\n\\n        public void insert(String word) {\\n            TrieNode curr = root;\\n\\n            for (char ch : word.toCharArray()) {\\n                TrieNode temp = curr.children.getOrDefault(ch, new TrieNode());\\n                temp.count++;\\n                curr.children.put(ch, temp);\\n                curr = temp;\\n            }\\n            curr.eow = true;\\n        }\\n\\n        public int getCount(String word) {\\n            TrieNode curr = root;\\n\\n            for (char ch : word.toCharArray()) {\\n                TrieNode temp = curr.children.get(ch);\\n                \\n                if (temp == null) {\\n                    return 0;\\n                }\\n                curr = temp;\\n            }\\n            return curr.count;\\n        }\\n    }\\n\\n    public int prefixCount(String[] words, String pref) {\\n        Trie trie = new Trie();\\n\\n        for (String word : words) {\\n            trie.insert(word);\\n        }\\n        return trie.getCount(pref);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    class TrieNode {\\n        Map<Character, TrieNode> children = new HashMap<>();\\n        boolean eow = false;\\n        int count = 0;\\n    }\\n\\n    class Trie {\\n        TrieNode root = new TrieNode();\\n\\n        public void insert(String word) {\\n            TrieNode curr = root;\\n\\n            for (char ch : word.toCharArray()) {\\n                TrieNode temp = curr.children.getOrDefault(ch, new TrieNode());\\n                temp.count++;\\n                curr.children.put(ch, temp);\\n                curr = temp;\\n            }\\n            curr.eow = true;\\n        }\\n\\n        public int getCount(String word) {\\n            TrieNode curr = root;\\n\\n            for (char ch : word.toCharArray()) {\\n                TrieNode temp = curr.children.get(ch);\\n                \\n                if (temp == null) {\\n                    return 0;\\n                }\\n                curr = temp;\\n            }\\n            return curr.count;\\n        }\\n    }\\n\\n    public int prefixCount(String[] words, String pref) {\\n        Trie trie = new Trie();\\n\\n        for (String word : words) {\\n            trie.insert(word);\\n        }\\n        return trie.getCount(pref);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694295,
                "title": "java",
                "content": "```\\n\\n    public int prefixCount(String[] words, String pref) {\\n       int size = 0;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (words[i].indexOf(pref) == 0) {\\n                size++;\\n            }\\n        }\\n\\n        return size;\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public int prefixCount(String[] words, String pref) {\\n       int size = 0;\\n\\n        for (int i = 0; i < words.length; i++) {\\n            if (words[i].indexOf(pref) == 0) {\\n                size++;\\n            }\\n        }\\n\\n        return size;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2672549,
                "title": "java-startswith-easy",
                "content": "### Please Upvote :D\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        \\n        for (String s : words) {\\n            if (s.startsWith(pref)) count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        \\n        for (String s : words) {\\n            if (s.startsWith(pref)) count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2655074,
                "title": "javascript-easy-solution-in-one-line",
                "content": "```\\nvar prefixCount = function (words, pref) {\\n  return words.filter(word => word.startsWith(pref)).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function (words, pref) {\\n  return words.filter(word => word.startsWith(pref)).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2630977,
                "title": "3-line-c-solution",
                "content": "class Solution {\\npublic:\\nint prefixCount(vector<string>&words, string pref) {int ans=0;\\nfor(int i=0;i<words.size();i++)\\nif( words[i].substr(0,pref.size()) == pref ) ans++;\\nreturn ans;\\n}\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\nint prefixCount(vector<string>&words, string pref) {int ans=0;\\nfor(int i=0;i<words.size();i++)\\nif( words[i].substr(0,pref.size()) == pref ) ans++;\\nreturn ans;\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2627768,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n                                                                                                                        int c=0;\\n        \\n        for(int i=0;i<words.size();i++){\\n            if(words[i].length()<pref.length())continue;\\n            int j=0,f=0;string s=words[i];\\n            for( j=0;j<pref.length();j++){\\n                if(pref[j]!=s[j])f=1;\\n            }\\n            if(f==0)c++;\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n                                                                                                                        int c=0;\\n        \\n        for(int i=0;i<words.size();i++){\\n            if(words[i].length()<pref.length())continue;\\n            int j=0,f=0;string s=words[i];\\n            for( j=0;j<pref.length();j++){\\n                if(pref[j]!=s[j])f=1;\\n            }\\n            if(f==0)c++;\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608393,
                "title": "2185-javascript-1-line-solution-o-nm",
                "content": "```\\nconst prefixCount = (words, pref) => words.filter(word => word.startsWith(pref)).length;\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst prefixCount = (words, pref) => words.filter(word => word.startsWith(pref)).length;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2567197,
                "title": "simple-c-solution",
                "content": "int count=0;\\n        for(int i=0;i<words.size();i++){\\n            int ans=words[i].find(pref);\\n            if(ans==0){\\n                count++;\\n            }\\n        }\\n        return count;",
                "solutionTags": [],
                "code": "int count=0;\\n        for(int i=0;i<words.size();i++){\\n            int ans=words[i].find(pref);\\n            if(ans==0){\\n                count++;\\n            }\\n        }\\n        return count;",
                "codeTag": "Unknown"
            },
            {
                "id": 2540990,
                "title": "one-line-python-solution",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return len([word for word in words if pref==word[0:len(pref)]])\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return len([word for word in words if pref==word[0:len(pref)]])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531620,
                "title": "python-counting-words-with-a-given-prefix",
                "content": "```\\nclass Solution(object):\\n    def prefixCount(self, words, pref):\\n        \"\"\"\\n        :type words: List[str]\\n        :type pref: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for elem in words:\\n            if elem.startswith(pref):\\n                count += 1\\n        \\n        return count",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def prefixCount(self, words, pref):\\n        \"\"\"\\n        :type words: List[str]\\n        :type pref: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for elem in words:\\n            if elem.startswith(pref):\\n                count += 1\\n        \\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 2460351,
                "title": "c-faster-than-98-easy",
                "content": "class Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n\\t\\n        int count=0;\\n        for(auto  i:words){\\n            if(i.size()>=pref.size()){            \\n             int j;\\n            for(j=0;j<pref.size();j++)\\n                if(i[j]!=pref[j])break;\\n            if(j==pref.size())count++;\\n            } \\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n\\t\\n        int count=0;\\n        for(auto  i:words){\\n            if(i.size()>=pref.size()){            \\n             int j;\\n            for(j=0;j<pref.size();j++)\\n                if(i[j]!=pref[j])break;\\n            if(j==pref.size())count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2457824,
                "title": "java-solution-1ms-runtime-easy-to-understand",
                "content": "\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String s) {\\n        int cnt = 0;\\n        for (String str : words) {\\n            if (str.startsWith(s)) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String s) {\\n        int cnt = 0;\\n        for (String str : words) {\\n            if (str.startsWith(s)) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2446970,
                "title": "javascript-best-solution-easy-understanding-100-faster-approach-beginner-friendly",
                "content": "```\\nconst prefixCount = (words, pref) => {\\n    let count = 0;\\n    \\n    words.forEach(word => {\\n        if(word.startsWith(pref)) count++;\\n    })\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nconst prefixCount = (words, pref) => {\\n    let count = 0;\\n    \\n    words.forEach(word => {\\n        if(word.startsWith(pref)) count++;\\n    })\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2437628,
                "title": "easy-to-understand-implementation-java",
                "content": "Initiate linear loop in the array and check if length of word is greater then prefix length so you skip\\nelse you check for matching condition using equals.\\n\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        \\n        int ans =0;\\n        int len = words.length;\\n        int plen = pref.length();\\n        \\n        for(int i=0;i<len;i++){\\n            \\n            if(words[i].length() < plen)continue;\\n            \\n            if(pref.equals(words[i].substring(0,plen))==true)ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        \\n        int ans =0;\\n        int len = words.length;\\n        int plen = pref.length();\\n        \\n        for(int i=0;i<len;i++){\\n            \\n            if(words[i].length() < plen)continue;\\n            \\n            if(pref.equals(words[i].substring(0,plen))==true)ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398493,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            bool check=true;\\n            if(pref.size()<=words[i].size())\\n            {\\n            for(int j=0;j<pref.size();j++)\\n            {\\n                if(words[i][j]!=pref[j])\\n                {\\n                    check=false;\\n                }\\n            }\\n                if(check==true)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        \\n        for(int i=0;i<words.size();i++)\\n        {\\n            bool check=true;\\n            if(pref.size()<=words[i].size())\\n            {\\n            for(int j=0;j<pref.size();j++)\\n            {\\n                if(words[i][j]!=pref[j])\\n                {\\n                    check=false;\\n                }\\n            }\\n                if(check==true)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384110,
                "title": "python-trie-prefix-tree-solution",
                "content": "A simple python solution using [Trie](https://en.wikipedia.org/wiki/Trie)\\nDoes this problem need a trie? No! But I solved it using a Tire anyway. \\n\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        trie = {}\\n        \\n        for word in words:\\n            self.insert(trie, word)\\n        return self.getPrefixCount(trie, pref)\\n\\n    def insert(self, trie, word):\\n        for ch in word:\\n            if ch not in trie:\\n                trie[ch] = [1, {}]\\n            else:\\n                trie[ch][0] += 1\\n        \\n            trie = trie[ch][1]\\n        \\n            \\n    def getPrefixCount(self, trie, pref):\\n        lastNode = None\\n        for ch in pref:\\n            if ch not in trie:\\n                return 0\\n            \\n            lastNode = trie[ch][0]\\n            trie = trie[ch][1]\\n            \\n        return lastNode\\n```",
                "solutionTags": [
                    "Python",
                    "Trie"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        trie = {}\\n        \\n        for word in words:\\n            self.insert(trie, word)\\n        return self.getPrefixCount(trie, pref)\\n\\n    def insert(self, trie, word):\\n        for ch in word:\\n            if ch not in trie:\\n                trie[ch] = [1, {}]\\n            else:\\n                trie[ch][0] += 1\\n        \\n            trie = trie[ch][1]\\n        \\n            \\n    def getPrefixCount(self, trie, pref):\\n        lastNode = None\\n        for ch in pref:\\n            if ch not in trie:\\n                return 0\\n            \\n            lastNode = trie[ch][0]\\n            trie = trie[ch][1]\\n            \\n        return lastNode\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336912,
                "title": "counting-words-with-a-given-prefix",
                "content": "var prefixCount = function(words, pref) {\\n    let cnt=0;\\n    for(let i=0;i<words.length;i++)\\n        {\\n           if(words[i].slice(0,pref.length)==pref)\\n           cnt++;\\n        }\\n    return cnt;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "var prefixCount = function(words, pref) {\\n    let cnt=0;\\n    for(let i=0;i<words.length;i++)\\n        {\\n           if(words[i].slice(0,pref.length)==pref)\\n           cnt++;\\n        }\\n    return cnt;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2321239,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n            int count = 0;\\n        for(int i = 0 ; i < words.size() ; i++){\\n                if(!(isSubstring(pref , words[i])))\\n                        count++;\\n        }\\n            return count;\\n    }\\n     int isSubstring(string s1, string s2) {\\n             if (s2.find(s1) != string::npos)\\n             return s2.find(s1);\\n             return -1;\\n         }\\n};\\n```\\n\\n##### Please upvote\\n[https://github.com/Reehan9/Leetcode-Solutions](http://)",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n            int count = 0;\\n        for(int i = 0 ; i < words.size() ; i++){\\n                if(!(isSubstring(pref , words[i])))\\n                        count++;\\n        }\\n            return count;\\n    }\\n     int isSubstring(string s1, string s2) {\\n             if (s2.find(s1) != string::npos)\\n             return s2.find(s1);\\n             return -1;\\n         }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321058,
                "title": "easy-c-solution-using-substring-operations",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\tint count=0;\\t\\t\\n\\t\\tfor(auto i : words){\\n\\t\\t\\tif(i.substr(0,pref.size())==pref)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n};\\n```\\n\\n**Please Upvote If You Find It Useful\\n   Thank You!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\tint count=0;\\t\\t\\n\\t\\tfor(auto i : words){\\n\\t\\t\\tif(i.substr(0,pref.size())==pref)\\n\\t\\t\\t\\tcount++;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298978,
                "title": "counting-words-with-a-given-prefix-with-python3",
                "content": "\\tdef prefixcount(words,pref):\\n\\t\\tcount = 0\\n\\t\\tfor element in words:\\n\\t\\t\\tif pref == element[0:len(pref)]:\\n\\t\\t\\t\\tcount +=1\\n\\t\\treturn count\\n\\twords = [\"pay\",\"attention\",\"practice\",\"attend\"]\\n\\tpref = \"at\"\\n\\tprefixcount(words,pref)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tdef prefixcount(words,pref):\\n\\t\\tcount = 0\\n\\t\\tfor element in words:\\n\\t\\t\\tif pref == element[0:len(pref)]:\\n\\t\\t\\t\\tcount +=1\\n\\t\\treturn count\\n\\twords = [\"pay\",\"attention\",\"practice\",\"attend\"]\\n\\tpref = \"at\"\\n\\tprefixcount(words,pref)",
                "codeTag": "Python3"
            },
            {
                "id": 2278482,
                "title": "easy-javascript-solution",
                "content": "# Runtime: 58 ms, faster than 98.27% of JavaScript online submissions for Counting Words With a Given Prefix.\\nMemory Usage: 42.5 MB, less than 80.94% of JavaScript online submissions for Counting Words With a Given Prefix.\\n\\n```\\n\\nvar prefixCount = function(words, pref) {\\n    \\n    let count = 0;\\n    \\n    for(var i=0; i< words.length; i++){\\n        let matchFTwo = words[i].slice(0, pref.length);\\n        \\n        matchFTwo === pref ? count++ : count\\n        \\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar prefixCount = function(words, pref) {\\n    \\n    let count = 0;\\n    \\n    for(var i=0; i< words.length; i++){\\n        let matchFTwo = words[i].slice(0, pref.length);\\n        \\n        matchFTwo === pref ? count++ : count\\n        \\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2235920,
                "title": "c-using-substr-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int res=0;\\n        int s=pref.size();\\n        \\n        for(int i=0;i<words.size();i++){\\n            if(words[i].substr(0,s)==pref){\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int res=0;\\n        int s=pref.size();\\n        \\n        for(int i=0;i<words.size();i++){\\n            if(words[i].substr(0,s)==pref){\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221645,
                "title": "python-solution-for-beginners-by-beginner",
                "content": "**Runtime: 45 ms, faster than 84.18% of Python3 online submissions for Counting Words With a Given Prefix.\\nMemory Usage: 13.9 MB, less than 96.55% of Python3 online submissions for Counting Words With a Given Prefix.**\\n\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        ans = 0\\n        for i in words:\\n            if i[:len(pref)] == pref:\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        ans = 0\\n        for i in words:\\n            if i[:len(pref)] == pref:\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219621,
                "title": "c-one-line-count-if",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        return count_if(words.begin(), words.end(), [&](const string& w){return w.substr(0, pref.size()) == pref;});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        return count_if(words.begin(), words.end(), [&](const string& w){return w.substr(0, pref.size()) == pref;});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179351,
                "title": "easy-c-solution",
                "content": "```\\nint prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i].substr(0,pref.size())==pref)\\n                count++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i].substr(0,pref.size())==pref)\\n                count++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2117918,
                "title": "c-best-one-liner-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int c=0;\\n      for(auto x:words)  {\\n          if(x.find(pref)==0){//if pref is on the starting index of every words string then c++;\\n              c++;            \\n          }\\n      }\\n        return c;\\n    }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int c=0;\\n      for(auto x:words)  {\\n          if(x.find(pref)==0){//if pref is on the starting index of every words string then c++;\\n              c++;            \\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2104242,
                "title": "javascript-solution-without-using-any-built-in-functions",
                "content": "```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let i=0; i<words.length; i++) {\\n        if(foundPref(words[i],pref))\\n            count++;\\n    }\\n    return count;\\n};\\n\\nlet foundPref = function(word,pref) {\\n    for(let i=0; i<pref.length; i++) {\\n        if(word[i] != pref[i]) \\n\\t\\t\\treturn false;               \\n    }\\n    return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    for(let i=0; i<words.length; i++) {\\n        if(foundPref(words[i],pref))\\n            count++;\\n    }\\n    return count;\\n};\\n\\nlet foundPref = function(word,pref) {\\n    for(let i=0; i<pref.length; i++) {\\n        if(word[i] != pref[i]) \\n\\t\\t\\treturn false;               \\n    }\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2067484,
                "title": "easy-c-approach",
                "content": "```\\n    int prefixCount(vector<string>& words, string pref) {\\n       int count=0;\\n       for(auto i : words){\\n           bool check = true;\\n           for(int j = 0;j<pref.size();j++){\\n               if(i[j]!=pref[j]){\\n                   check=false;\\n                   break;\\n               }\\n           }\\n           if(check){count++;}\\n       }\\n        return count;\\n    }\\n\\t",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n    int prefixCount(vector<string>& words, string pref) {\\n       int count=0;\\n       for(auto i : words){\\n           bool check = true;\\n           for(int j = 0;j<pref.size();j++){\\n               if(i[j]!=pref[j]){\\n                   check=false;\\n                   break;\\n               }\\n           }\\n           if(check){count++;}\\n       }\\n        return count;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2044122,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count  = 0;\\n        for(int i = 0;i<words.size();i++)\\n        {\\n            string ss = words[i];\\n            int n = pref.length();\\n            string sub = ss.substr(0,n);\\n            \\n            if(sub == pref) {\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count  = 0;\\n        for(int i = 0;i<words.size();i++)\\n        {\\n            string ss = words[i];\\n            int n = pref.length();\\n            string sub = ss.substr(0,n);\\n            \\n            if(sub == pref) {\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965549,
                "title": "using-trie-data-structure",
                "content": "\\tclass TrieNode{\\n\\t\\tpublic :\\n\\t\\tchar data;\\n\\t\\tTrieNode* child[26];\\n\\t\\tint wordend;\\n\\t\\tbool is_end;\\n\\t\\tTrieNode(){\\n\\t\\t\\twordend=0;\\n\\t\\t\\tis_end=false;\\n\\t\\t\\tfor(int i=0; i<26; i++){\\n\\t\\t\\t\\tchild[i]=NULL;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvoid insert(TrieNode* root,string s){\\n\\t\\t\\tTrieNode* curr=root;\\n\\t\\t\\tfor(int i=0; i<s.size(); i++){\\n\\t\\t\\t\\tint  index=s[i]-\\'a\\';\\n\\t\\t\\t\\tif(curr->child[index]==NULL){\\n\\t\\t\\t\\t\\tcurr->child[index]= new TrieNode();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurr->child[index]->wordend++;\\n\\t\\t\\t\\tcurr=curr->child[index];\\n\\t\\t\\t}\\n\\t\\t\\tcurr->is_end=true;\\n\\t\\t}\\n\\t\\tint count_prefix(TrieNode* root,string prefix){\\n\\t\\t\\tTrieNode* curr=root;\\n\\t\\t\\tfor(int i=0; i<prefix.size(); i++){\\n\\t\\t\\t\\tint index=prefix[i]-\\'a\\';\\n\\t\\t\\t\\tif(curr->child[index]==NULL)\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\tcurr=curr->child[index];\\n\\t\\t\\t}\\n\\t\\t\\treturn curr->wordend;        \\n\\t\\t}\\n\\n\\t};\\n\\tclass Solution :public TrieNode{\\n\\tpublic:\\n\\t\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\t\\tTrieNode* root= new TrieNode();\\n\\t\\t\\tfor(string word: words){\\n\\t\\t\\t\\tinsert(root,word);\\n\\t\\t\\t}\\n\\t\\t\\treturn count_prefix(root,pref);\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution :public TrieNode{\\n\\tpublic:\\n\\t\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\t\\tTrieNode* root= new TrieNode();\\n\\t\\t\\tfor(string word: words){\\n\\t\\t\\t\\tinsert(root,word);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1960839,
                "title": "basic-c-o-n-time-complexity-code",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    bool isprefix(string word,string prefix)\\n    {\\n        int i=0;\\n        int j=0;\\n        int c=0;\\n        while(i<word.length() && j<prefix.length())\\n        {\\n            if(word[i]!=prefix[j])\\n            {\\n                break;\\n            }\\n            i++;\\n            j++;\\n            c++;\\n        }\\n        if(c==prefix.length())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(isprefix(words[i],pref))\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1925154,
                "title": "java-1ms",
                "content": "class Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].startsWith(pref)) count++;\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].startsWith(pref)) count++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1877195,
                "title": "simple-c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(string pref, string s){\\n        \\n        int n=pref.size();\\n        int i=0;\\n        int c=0;\\n        \\n        while(i<n){\\n            \\n            if(pref[i]==s[i])c++;\\n            \\n            else return false;\\n            i++;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n        int ans=0;\\n        \\n        for(string x:words){\\n            \\n            if(check(pref,x))ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string pref, string s){\\n        \\n        int n=pref.size();\\n        int i=0;\\n        int c=0;\\n        \\n        while(i<n){\\n            \\n            if(pref[i]==s[i])c++;\\n            \\n            else return false;\\n            i++;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int prefixCount(vector<string>& words, string pref) {\\n        \\n        int ans=0;\\n        \\n        for(string x:words){\\n            \\n            if(check(pref,x))ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871318,
                "title": "python3-1-line",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(el.startswith(pref) for el in words)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(el.startswith(pref) for el in words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867008,
                "title": "simple-python-solution-easy-to-understand",
                "content": "\\n\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        #basic check\\n        if words is None or len(words) == 0: return 0\\n        \\n        #initialization\\n        \\n        count = 0\\n        for word in words:\\n            if word.startswith(pref):\\n                count = count + 1\\n                \\n        return count",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        #basic check\\n        if words is None or len(words) == 0: return 0\\n        \\n        #initialization\\n        \\n        count = 0\\n        for word in words:\\n            if word.startswith(pref):\\n                count = count + 1\\n                \\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1861908,
                "title": "python-trie-solution",
                "content": "```\\nclass Node(object):\\n    def __init__(self, key, data=None):\\n        self.key = key\\n        self.data = data\\n        self.children = {}\\n\\nclass Trie:\\n    def __init__(self):\\n        self.head = Node(None)\\n        \\n    def insert(self, string: str) -> None:\\n        current_node = self.head\\n\\n        for char in string:\\n            if char not in current_node.children:\\n                current_node.children[char] = Node(char)\\n            current_node = current_node.children[char]\\n        current_node.data = string\\n        \\n    def search(self, string: str) -> bool:\\n        current_node = self.head\\n\\n        for char in string:\\n            if char in current_node.children:\\n                current_node = current_node.children[char]\\n            else:\\n                return False\\n\\n        if current_node.data:\\n            return True\\n        else:\\n            return False\\n\\n    def startsWith(self, prefix: str) -> bool:\\n        current_node = self.head\\n        words = []\\n\\n        for p in prefix:\\n            if p in current_node.children:\\n                current_node = current_node.children[p]\\n            else:\\n                return []\\n\\n        current_node = [current_node]\\n        next_node = []\\n        while True:\\n            for node in current_node:\\n                if node.data:\\n                    words.append(node.data)\\n                next_node.extend(list(node.children.values()))\\n            if len(next_node) != 0:\\n                current_node = next_node\\n                next_node = []\\n            else:\\n                break\\n\\n        return words\\n\\n\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n  \\n        trie = Trie()\\n        count = defaultdict(int)\\n        for word in words:\\n            trie.insert(word)\\n            count[word] += 1\\n        result = trie.startsWith(pref)\\n        res = 0 \\n     \\n        for word in result:\\n            res += count[word]\\n        return res \\n       \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass Node(object):\\n    def __init__(self, key, data=None):\\n        self.key = key\\n        self.data = data\\n        self.children = {}\\n\\nclass Trie:\\n    def __init__(self):\\n        self.head = Node(None)\\n        \\n    def insert(self, string: str) -> None:\\n        current_node = self.head\\n\\n        for char in string:\\n            if char not in current_node.children:\\n                current_node.children[char] = Node(char)\\n            current_node = current_node.children[char]\\n        current_node.data = string\\n        \\n    def search(self, string: str) -> bool:\\n        current_node = self.head\\n\\n        for char in string:\\n            if char in current_node.children:\\n                current_node = current_node.children[char]\\n            else:\\n                return False\\n\\n        if current_node.data:\\n            return True\\n        else:\\n            return False\\n\\n    def startsWith(self, prefix: str) -> bool:\\n        current_node = self.head\\n        words = []\\n\\n        for p in prefix:\\n            if p in current_node.children:\\n                current_node = current_node.children[p]\\n            else:\\n                return []\\n\\n        current_node = [current_node]\\n        next_node = []\\n        while True:\\n            for node in current_node:\\n                if node.data:\\n                    words.append(node.data)\\n                next_node.extend(list(node.children.values()))\\n            if len(next_node) != 0:\\n                current_node = next_node\\n                next_node = []\\n            else:\\n                break\\n\\n        return words\\n\\n\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n  \\n        trie = Trie()\\n        count = defaultdict(int)\\n        for word in words:\\n            trie.insert(word)\\n            count[word] += 1\\n        result = trie.startsWith(pref)\\n        res = 0 \\n     \\n        for word in result:\\n            res += count[word]\\n        return res \\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854979,
                "title": "1ms-java-solution-easy-to-understand",
                "content": "Hope this helps!!\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0; \\n        for(int i = 0; i<words.length; i++){\\n            if(words[i].startsWith(pref)){\\n                count++; \\n            }\\n        }\\n        return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0; \\n        for(int i = 0; i<words.length; i++){\\n            if(words[i].startsWith(pref)){\\n                count++; \\n            }\\n        }\\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852307,
                "title": "python-ez-readable-code-2-ways-regex-solution",
                "content": "```\\ndef prefixCount(words, pref):\\n\\tcount = 0\\n\\tfor word in words:\\n\\t  if word.startswith(pref):\\n\\t\\tcount += 1\\n\\n\\treturn count\\n```\\nNow, We can use the ^ if we want to attack it by way of RegEx:\\n```\\nimport re\\ndef prefixCount(words, pref):\\n\\tcount = 0\\n\\tpref = \\'^\\'+ pref\\n\\tfor word in words:\\n\\t  if re.match(pref, word):\\n\\t\\tcount += 1\\n\\n\\treturn count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef prefixCount(words, pref):\\n\\tcount = 0\\n\\tfor word in words:\\n\\t  if word.startswith(pref):\\n\\t\\tcount += 1\\n\\n\\treturn count\\n```\n```\\nimport re\\ndef prefixCount(words, pref):\\n\\tcount = 0\\n\\tpref = \\'^\\'+ pref\\n\\tfor word in words:\\n\\t  if re.match(pref, word):\\n\\t\\tcount += 1\\n\\n\\treturn count\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1842983,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            if(words[i][:len(pref)])==pref:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        c=0\\n        for i in range(len(words)):\\n            if(words[i][:len(pref)])==pref:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841783,
                "title": "simple-and-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        \\n        pref_len=len(pref)\\n        count=0\\n        for i in words:\\n            if pref==i[:pref_len]:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        \\n        pref_len=len(pref)\\n        count=0\\n        for i in words:\\n            if pref==i[:pref_len]:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838595,
                "title": "straightforward-java-solution-without-string-functions-runtime-0-ms",
                "content": "**Runtime**: 0 ms, faster than 100.00%, **Memory Usage**: 42.2 MB, less than 90.31%.\\n\\n```\\n  public int prefixCount(String[] words, String pref) {\\n    int count = 0;\\n\\n    for (String word : words) {\\n      if (startsWith(word, pref)) {\\n        count++;\\n      }\\n    }\\n    return count;\\n  }\\n\\n  private boolean startsWith(String word, String prefix) {\\n    if (word.length() < prefix.length()) {\\n      return false;\\n    }\\n    for (int i = 0; i < prefix.length(); i++) {\\n      if (word.charAt(i) != prefix.charAt(i)) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  public int prefixCount(String[] words, String pref) {\\n    int count = 0;\\n\\n    for (String word : words) {\\n      if (startsWith(word, pref)) {\\n        count++;\\n      }\\n    }\\n    return count;\\n  }\\n\\n  private boolean startsWith(String word, String prefix) {\\n    if (word.length() < prefix.length()) {\\n      return false;\\n    }\\n    for (int i = 0; i < prefix.length(); i++) {\\n      if (word.charAt(i) != prefix.charAt(i)) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1836245,
                "title": "best-simplest-easiest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n = words.size();\\n        int c = 0;\\n        for(int i=0; i<words.size(); i++)\\n        {\\n            bool res = true;\\n            string s = words[i];\\n            if(s.length()<pref.length())\\n            {\\n                continue;\\n            }\\n            int k = 0;\\n            for(int j=0; j<pref.length() && k<s.length(); j++)\\n            {\\n                if(pref[j] != s[k])\\n                {\\n                    res = false;\\n                    break;\\n                }\\n                k++;\\n            }\\n            \\n            if(res)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n\\n//pls upvote if you find solution helpful...! Thanks...!!\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n = words.size();\\n        int c = 0;\\n        for(int i=0; i<words.size(); i++)\\n        {\\n            bool res = true;\\n            string s = words[i];\\n            if(s.length()<pref.length())\\n            {\\n                continue;\\n            }\\n            int k = 0;\\n            for(int j=0; j<pref.length() && k<s.length(); j++)\\n            {\\n                if(pref[j] != s[k])\\n                {\\n                    res = false;\\n                    break;\\n                }\\n                k++;\\n            }\\n            \\n            if(res)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n\\n//pls upvote if you find solution helpful...! Thanks...!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828878,
                "title": "java-1-liner",
                "content": ">**T/S:** O(mn)/O(1), where m = size(words), n = size(pref)\\n```\\npublic int prefixCount(String[] words, String pref) {\\n\\tvar count = 0;\\n\\tfor (var word : words)\\n\\t\\tif (word.startsWith(pref))\\n\\t\\t\\tcount++;\\n\\treturn count;\\n}\\n```\\n**Version 2:** 1 liner using [Streams](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)\\n```\\npublic int prefixCount(String[] words, String pref) {\\n\\treturn (int) Arrays.stream(words)\\n\\t\\t\\t\\t\\t   .filter(word -> word.startsWith(pref))\\n\\t\\t\\t\\t\\t   .count();\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int prefixCount(String[] words, String pref) {\\n\\tvar count = 0;\\n\\tfor (var word : words)\\n\\t\\tif (word.startsWith(pref))\\n\\t\\t\\tcount++;\\n\\treturn count;\\n}\\n```\n```\\npublic int prefixCount(String[] words, String pref) {\\n\\treturn (int) Arrays.stream(words)\\n\\t\\t\\t\\t\\t   .filter(word -> word.startsWith(pref))\\n\\t\\t\\t\\t\\t   .count();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1828550,
                "title": "c-simplest-and-cleanest-code-for-quick-understanding",
                "content": "```\\n    int prefixCount(vector<string>& words, string pref)     {\\n        int ans = 0                                         ;\\n        for(auto &word : words)                             {\\n            if(word.length() < pref.length()) continue      ;\\n            int i = 0                                       ;\\n            for(i; i < pref.length(); i++)                  {\\n                if(pref[i] != word[i]) break                ;}\\n            if(i == pref.length()) ans++                    ;\\n                                                            }\\n        return ans                                          ;}\\n\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\n    int prefixCount(vector<string>& words, string pref)     {\\n        int ans = 0                                         ;\\n        for(auto &word : words)                             {\\n            if(word.length() < pref.length()) continue      ;\\n            int i = 0                                       ;\\n            for(i; i < pref.length(); i++)                  {\\n                if(pref[i] != word[i]) break                ;}\\n            if(i == pref.length()) ans++                    ;\\n                                                            }\\n        return ans                                          ;}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1826783,
                "title": "easy-c-solution",
                "content": "\\'\\'\\'\\n\\n    int prefixCount(vector<string>& words, string pref) {\\n        int l = pref.length();\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i].length()>=l)\\n            {\\n                if(words[i].substr(0,l) == pref)\\n                {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "\\'\\'\\'\\n\\n    int prefixCount(vector<string>& words, string pref) {\\n        int l = pref.length();\\n        int cnt=0;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(words[i].length()>=l)\\n            {\\n                if(words[i].substr(0,l) == pref)\\n                {\\n                    cnt++;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1825064,
                "title": "6-lines-python-code-intuitive-approach",
                "content": "Count length of prefix and check the starting part of every word in words for the prefix and increment count.\\n\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        n=len(pref)\\n        cnt=0\\n        for i in words:\\n            if i[:n] == pref:\\n                cnt+=1\\n        return cnt\\n\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        n=len(pref)\\n        cnt=0\\n        for i in words:\\n            if i[:n] == pref:\\n                cnt+=1\\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824609,
                "title": "python-97-45-faster-easy-solution",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        count = 0\\n        for i in range(len(words)):\\n            if words[i][:len(pref)] == pref:\\n                count += 1\\n        return count",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        count = 0\\n        for i in range(len(words)):\\n            if words[i][:len(pref)] == pref:\\n                count += 1\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1818658,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans = 0;\\n        \\n        for(int i = 0; i < words.size(); i++){\\n            bool check = true;\\n            for(int j = 0; j < pref.size(); j++)\\n                if(words[i][j] != pref[j]){\\n                    check = false;\\n                    break;\\n                }\\n            if(check) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans = 0, pre = pref.size();\\n        \\n        for(auto w : words){\\n            string s = w.substr(0, pre);\\n            if(s == pref) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans = 0;\\n        \\n        for(int i = 0; i < words.size(); i++){\\n            bool check = true;\\n            for(int j = 0; j < pref.size(); j++)\\n                if(words[i][j] != pref[j]){\\n                    check = false;\\n                    break;\\n                }\\n            if(check) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int ans = 0, pre = pref.size();\\n        \\n        for(auto w : words){\\n            string s = w.substr(0, pre);\\n            if(s == pref) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818362,
                "title": "simple-easy-to-understand-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int count=0;\\n        bool flag=true;\\n        for(int i=0;i<n;i++){\\n            string w = words[i];\\n            int j=0;\\n            while(j<pref.length()){\\n                if(pref[j]!=w[j]){\\n                    flag=false;\\n                    break;\\n                }\\n                j++;\\n                \\n            }\\n            if(flag) count++;\\n            else flag=!flag;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int count=0;\\n        bool flag=true;\\n        for(int i=0;i<n;i++){\\n            string w = words[i];\\n            int j=0;\\n            while(j<pref.length()){\\n                if(pref[j]!=w[j]){\\n                    flag=false;\\n                    break;\\n                }\\n                j++;\\n                \\n            }\\n            if(flag) count++;\\n            else flag=!flag;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818244,
                "title": "java-2-solutions-easy-implementations",
                "content": "**Solution 1:**\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        if(pref==null || pref.length()==0) return 0;\\n        \\n        int ans=0;\\n        for(int i=0;i<words.length;i++){\\n            String temp=\"\";\\n            if(words[i].length()>=pref.length()) temp=words[i].substring(0,pref.length());\\n            \\n            if(pref.equals(temp)) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**Solution 2:**\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        if(pref==null || pref.length()==0) return 0;\\n        \\n        int ans=0;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].indexOf(pref)==0) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        if(pref==null || pref.length()==0) return 0;\\n        \\n        int ans=0;\\n        for(int i=0;i<words.length;i++){\\n            String temp=\"\";\\n            if(words[i].length()>=pref.length()) temp=words[i].substring(0,pref.length());\\n            \\n            if(pref.equals(temp)) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        if(pref==null || pref.length()==0) return 0;\\n        \\n        int ans=0;\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].indexOf(pref)==0) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809765,
                "title": "super-easy-to-understand-c-code",
                "content": "```\\nint prefixCount(vector<string>& words, string pref) {\\n\\tint ans = 0;\\n\\tfor (auto word : words)\\n\\t{\\n\\t\\tif (word.length() >= pref.length() && word.substr(0, pref.length()) == pref)\\n\\t\\t\\tans++;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint prefixCount(vector<string>& words, string pref) {\\n\\tint ans = 0;\\n\\tfor (auto word : words)\\n\\t{\\n\\t\\tif (word.length() >= pref.length() && word.substr(0, pref.length()) == pref)\\n\\t\\t\\tans++;\\n\\t}\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1809676,
                "title": "c-easy-to-understand",
                "content": "class Solution {\\npublic:\\n\\nint prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        for(auto str:words){ \\n        //This fuction returns the first index where string pref occurs    \\n            int index=str.find(pref);\\n            if (index==0)\\n                count++;\\n            }\\n            return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\nint prefixCount(vector<string>& words, string pref) {\\n        int count=0;\\n        for(auto str:words){ \\n        //This fuction returns the first index where string pref occurs    \\n            int index=str.find(pref);\\n            if (index==0)\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1807915,
                "title": "c-one-line-linq-solution",
                "content": "```\\npublic class Solution {\\n    public int PrefixCount(string[] words, string pref) {\\n        return words.Count(o => o.StartWith(pref));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int PrefixCount(string[] words, string pref) {\\n        return words.Count(o => o.StartWith(pref));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806964,
                "title": "my-java-solution-1-straight-forward-approach-2-using-trie-ds",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int prefixCount = 0;\\n        int prefixLength = pref.length();\\n        for (String word : words) {\\n            if (word.length() < prefixLength) {\\n                continue;\\n            }\\n            int index = 0;\\n            boolean prefixFound = true;\\n            while (index < prefixLength) {\\n                if (word.charAt(index) != pref.charAt(index)) {\\n                    prefixFound = false;\\n                    break;\\n                }\\n                index++;\\n            }\\n            if (prefixFound) {\\n                prefixCount++;\\n            }\\n        }\\n        return prefixCount;\\n    }\\n}\\n```\\n\\n\\n```\\nUsing trie\\n\\nclass Solution {\\n    \\n    private TrieNode root;\\n    public Solution() {\\n        root = new TrieNode();\\n    }\\n    \\n    public void insert(String word) {\\n        TrieNode node = root;\\n        for (char ch : word.toCharArray()) {\\n            int index = ch - \\'a\\';\\n            if (node.child[index] == null) {\\n                node.child[index] = new TrieNode();\\n            }\\n            node.ch = ch;\\n            node = node.child[index];\\n            node.count++;\\n        }\\n        node.word = word;\\n    }\\n    \\n    public int prefixFinder(String prefix) {\\n        TrieNode node = root;\\n        for (char ch : prefix.toCharArray()) {\\n            int index = ch - \\'a\\';\\n            if (node.child[index] == null) {\\n                return 0;\\n            }\\n            node = node.child[index];\\n        }\\n        return node.count;\\n    }\\n    \\n    public int prefixCount(String[] words, String prefix) {\\n        int prefixCount = 0;\\n        for (String word : words) {\\n            insert(word);\\n        }\\n        return prefixFinder(prefix);\\n    }\\n}\\n\\nclass TrieNode {\\n    char ch;\\n    String word;\\n    int count = 0;\\n    TrieNode [] child;\\n    TrieNode(){\\n        this.child = new TrieNode[26];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int prefixCount = 0;\\n        int prefixLength = pref.length();\\n        for (String word : words) {\\n            if (word.length() < prefixLength) {\\n                continue;\\n            }\\n            int index = 0;\\n            boolean prefixFound = true;\\n            while (index < prefixLength) {\\n                if (word.charAt(index) != pref.charAt(index)) {\\n                    prefixFound = false;\\n                    break;\\n                }\\n                index++;\\n            }\\n            if (prefixFound) {\\n                prefixCount++;\\n            }\\n        }\\n        return prefixCount;\\n    }\\n}\\n```\n```\\nUsing trie\\n\\nclass Solution {\\n    \\n    private TrieNode root;\\n    public Solution() {\\n        root = new TrieNode();\\n    }\\n    \\n    public void insert(String word) {\\n        TrieNode node = root;\\n        for (char ch : word.toCharArray()) {\\n            int index = ch - \\'a\\';\\n            if (node.child[index] == null) {\\n                node.child[index] = new TrieNode();\\n            }\\n            node.ch = ch;\\n            node = node.child[index];\\n            node.count++;\\n        }\\n        node.word = word;\\n    }\\n    \\n    public int prefixFinder(String prefix) {\\n        TrieNode node = root;\\n        for (char ch : prefix.toCharArray()) {\\n            int index = ch - \\'a\\';\\n            if (node.child[index] == null) {\\n                return 0;\\n            }\\n            node = node.child[index];\\n        }\\n        return node.count;\\n    }\\n    \\n    public int prefixCount(String[] words, String prefix) {\\n        int prefixCount = 0;\\n        for (String word : words) {\\n            insert(word);\\n        }\\n        return prefixFinder(prefix);\\n    }\\n}\\n\\nclass TrieNode {\\n    char ch;\\n    String word;\\n    int count = 0;\\n    TrieNode [] child;\\n    TrieNode(){\\n        this.child = new TrieNode[26];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806641,
                "title": "simple-solution",
                "content": "\\n        int count=0;\\n        int preflen=pref.size();        //step 1\\n        \\n        for(auto i:words){\\n            if(i.substr(0,preflen) == pref)     //step 2\\n                count++;                        //if both matches then increment count by 1\\n            \\n        }\\n        return count;   //return count",
                "solutionTags": [],
                "code": "\\n        int count=0;\\n        int preflen=pref.size();        //step 1\\n        \\n        for(auto i:words){\\n            if(i.substr(0,preflen) == pref)     //step 2\\n                count++;                        //if both matches then increment count by 1\\n            \\n        }\\n        return count;   //return count",
                "codeTag": "Unknown"
            },
            {
                "id": 1805758,
                "title": "c-easy-to-understand-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n     int c=0;\\n        int x=pref.size();\\n        int n=words.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string s=words[i];\\n            if(s.length()<x)\\n            continue;\\n            else\\n            {\\n                \\n                string str=s.substr(0,x);\\n                if(str==pref)\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n     int c=0;\\n        int x=pref.size();\\n        int n=words.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            string s=words[i];\\n            if(s.length()<x)\\n            continue;\\n            else\\n            {\\n                \\n                string str=s.substr(0,x);\\n                if(str==pref)\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805056,
                "title": "scala-one-liner",
                "content": "```\\nobject Solution {\\n    def prefixCount(words: Array[String], pref: String): Int = {\\n        words.count(_.startsWith(pref))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def prefixCount(words: Array[String], pref: String): Int = {\\n        words.count(_.startsWith(pref))\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1804593,
                "title": "java-multiple-approaches",
                "content": "**Approach 1:** Using String charAt and comparing char by char\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        for(String word : words){\\n            if(pref.length() <= word.length() && hasPrefix(word,pref)) count++;\\n        }\\n        return count;\\n    }\\n    \\n    public boolean hasPrefix(String word, String prefix){\\n        for(int i=0; i<prefix.length(); i++){\\n            if(prefix.charAt(i) != word.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n**Approach 2:** Using string indexOf\\n```\\nint\\tindexOf(String str) - Returns the index within this string of the first occurrence of the specified substring.\\n```\\n\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        for(String word : words){\\n            if(pref.length() <= word.length() && word.indexOf(pref)==0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Approach 3:** Using String startsWith\\n```\\nboolean\\tstartsWith (String prefix) - Tests if this string starts with the specified prefix.\\n```\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        for(String word : words){\\n            if(pref.length() <= word.length() && word.startsWith(pref)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Approach 4:** Using Trie data structure. One can argue trie might not be required for this problem but its a good way to practice and implement it\\n\\n```\\npublic class Trie {\\n\\tNode root;\\n\\n\\tTrie() {\\n\\t\\tthis.root = new Node(\\'\\\\0\\');\\n\\t}\\n\\n\\tpublic void insert(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char c : word.toCharArray()) {\\n\\t\\t\\tif (curr.children[c - \\'a\\'] == null) {\\n\\t\\t\\t\\tcurr.children[c - \\'a\\'] = new Node(c);\\n\\t\\t\\t}\\n\\t\\t\\tcurr = curr.children[c - \\'a\\'];\\n            curr.wordCount++;\\n\\t\\t}\\n\\t\\tcurr.isWord = true;\\n\\t}\\n\\n\\tpublic boolean hasPrefix(String prefix) {\\n\\t\\treturn findNode(prefix) != null;\\n\\t}\\n\\n\\tpublic boolean hasWord(String word) {\\n\\t\\tNode curr = findNode(word);\\n\\t\\treturn curr != null && curr.isWord;\\n\\t}\\n\\n\\tpublic Node findNode(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char c : word.toCharArray()) {\\n\\t\\t\\tif (curr.children[c - \\'a\\'] == null)\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\tcurr = curr.children[c - \\'a\\'];\\n\\t\\t}\\n\\t\\treturn curr;\\n\\t}\\n}\\n\\nclass Node {\\n\\tboolean isWord;\\n\\tchar c;\\n\\tNode[] children;\\n    int wordCount; // maintain word count of number of words or prefixes this character is shared with\\n\\t\\n    Node(char c) {\\n\\t\\tthis.c = c;\\n\\t\\tthis.children = new Node[26];\\n\\t}\\n}\\n\\n\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        Trie trie = new Trie();\\n        for(String word : words){\\n           trie.insert(word);\\n        }\\n        // find if this prefix exists\\n        Node curr = trie.findNode(pref); \\n        if(curr != null){\\n\\t\\t\\t// if it exists return the word count i.e number of words in which this prefix exists\\n             return curr.wordCount;\\n         }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        for(String word : words){\\n            if(pref.length() <= word.length() && hasPrefix(word,pref)) count++;\\n        }\\n        return count;\\n    }\\n    \\n    public boolean hasPrefix(String word, String prefix){\\n        for(int i=0; i<prefix.length(); i++){\\n            if(prefix.charAt(i) != word.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nint\\tindexOf(String str) - Returns the index within this string of the first occurrence of the specified substring.\\n```\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        for(String word : words){\\n            if(pref.length() <= word.length() && word.indexOf(pref)==0) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nboolean\\tstartsWith (String prefix) - Tests if this string starts with the specified prefix.\\n```\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        for(String word : words){\\n            if(pref.length() <= word.length() && word.startsWith(pref)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\npublic class Trie {\\n\\tNode root;\\n\\n\\tTrie() {\\n\\t\\tthis.root = new Node(\\'\\\\0\\');\\n\\t}\\n\\n\\tpublic void insert(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char c : word.toCharArray()) {\\n\\t\\t\\tif (curr.children[c - \\'a\\'] == null) {\\n\\t\\t\\t\\tcurr.children[c - \\'a\\'] = new Node(c);\\n\\t\\t\\t}\\n\\t\\t\\tcurr = curr.children[c - \\'a\\'];\\n            curr.wordCount++;\\n\\t\\t}\\n\\t\\tcurr.isWord = true;\\n\\t}\\n\\n\\tpublic boolean hasPrefix(String prefix) {\\n\\t\\treturn findNode(prefix) != null;\\n\\t}\\n\\n\\tpublic boolean hasWord(String word) {\\n\\t\\tNode curr = findNode(word);\\n\\t\\treturn curr != null && curr.isWord;\\n\\t}\\n\\n\\tpublic Node findNode(String word) {\\n\\t\\tNode curr = root;\\n\\t\\tfor (char c : word.toCharArray()) {\\n\\t\\t\\tif (curr.children[c - \\'a\\'] == null)\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\tcurr = curr.children[c - \\'a\\'];\\n\\t\\t}\\n\\t\\treturn curr;\\n\\t}\\n}\\n\\nclass Node {\\n\\tboolean isWord;\\n\\tchar c;\\n\\tNode[] children;\\n    int wordCount; // maintain word count of number of words or prefixes this character is shared with\\n\\t\\n    Node(char c) {\\n\\t\\tthis.c = c;\\n\\t\\tthis.children = new Node[26];\\n\\t}\\n}\\n\\n\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count =0;\\n        Trie trie = new Trie();\\n        for(String word : words){\\n           trie.insert(word);\\n        }\\n        // find if this prefix exists\\n        Node curr = trie.findNode(pref); \\n        if(curr != null){\\n\\t\\t\\t// if it exists return the word count i.e number of words in which this prefix exists\\n             return curr.wordCount;\\n         }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803726,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public static int prefixCount(String[] words, String pref) {\\n        int ans = 0;\\n        for (String str : words) {\\n            if (isEqual(str, pref)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private static boolean isEqual(String str, String pref) {\\n        if (pref.length() > str.length()) return false;\\n        for (int i = 0; i < pref.length(); i++) {\\n            if (str.charAt(i) != pref.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static int prefixCount(String[] words, String pref) {\\n        int ans = 0;\\n        for (String str : words) {\\n            if (isEqual(str, pref)) {\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private static boolean isEqual(String str, String pref) {\\n        if (pref.length() > str.length()) return false;\\n        for (int i = 0; i < pref.length(); i++) {\\n            if (str.charAt(i) != pref.charAt(i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803668,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        \\n        # one-liner \\n        return sum(word.find(pref) == 0 for word in words)\\n    \\n        # detail approach \\n#         ans = 0\\n#         for i in range(len(words)):\\n#             a = words[i]\\n#             lp = len(pref)\\n#             cnt = 0\\n#             if len(a) < lp:\\n#                 continue\\n#             for j in range(lp):\\n#                 if pref[j] == a[j]:\\n#                     j += 1\\n#                     cnt += 1\\n#                 if cnt == lp:\\n#                     break\\n#                 if pref[j] != a[j]:\\n#                     break\\n                    \\n#             if cnt == lp:\\n#                 ans += 1\\n#         return ans\\n    \\n    # take each word and check if lenght is less then continue, as its not the candidate solution \\n    # else \\n    # compare with pref, increment count, if count equals length of prf, its the solution, add to ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        \\n        # one-liner \\n        return sum(word.find(pref) == 0 for word in words)\\n    \\n        # detail approach \\n#         ans = 0\\n#         for i in range(len(words)):\\n#             a = words[i]\\n#             lp = len(pref)\\n#             cnt = 0\\n#             if len(a) < lp:\\n#                 continue\\n#             for j in range(lp):\\n#                 if pref[j] == a[j]:\\n#                     j += 1\\n#                     cnt += 1\\n#                 if cnt == lp:\\n#                     break\\n#                 if pref[j] != a[j]:\\n#                     break\\n                    \\n#             if cnt == lp:\\n#                 ans += 1\\n#         return ans\\n    \\n    # take each word and check if lenght is less then continue, as its not the candidate solution \\n    # else \\n    # compare with pref, increment count, if count equals length of prf, its the solution, add to ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803656,
                "title": "c-easy-to-understand",
                "content": "*here we are watching for prefixes in every string in vector of strings.*\\n*the simple way or brtue force approach is to check for the prefixes that matches or not and for that we use **substr** function to access the substring which we require to check for the prefix* \\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\t\\tint len=pref.length(),n=words.size(),ctr=0;\\n\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring sub=words[i].substr(0,len); \\n\\t\\t\\t\\t// it takes substring from the ith string from words vector\\n\\t\\t\\t\\t// then sub matches with the pref \\n\\t\\t\\t\\t// if sub matches it will increase the counter othwerwise it will check for next\\n\\t\\t\\t\\tif(sub==pref)\\n\\t\\t\\t\\t\\tctr++;\\n\\t\\t\\t}\\n\\t\\t\\treturn ctr;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\t\\tint len=pref.length(),n=words.size(),ctr=0;\\n\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tstring sub=words[i].substr(0,len); \\n\\t\\t\\t\\t// it takes substring from the ith string from words vector\\n\\t\\t\\t\\t// then sub matches with the pref \\n\\t\\t\\t\\t// if sub matches it will increase the counter othwerwise it will check for next\\n\\t\\t\\t\\tif(sub==pref)\\n\\t\\t\\t\\t\\tctr++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1803645,
                "title": "1-liner-in-js",
                "content": "```\\nvar prefixCount = function(words, pref) {\\n    return words.filter(w=>w.substring(0,pref.length)===pref).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function(words, pref) {\\n    return words.filter(w=>w.substring(0,pref.length)===pref).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803451,
                "title": "c-very-easy-easy-to-understand-simple-code",
                "content": "Just do the dry one line by line this code, very easy to understand\\n\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count = 0;\\n        for(int i=0; i<words.size(); i++)\\n        {\\n            string w = words[i];\\n            int n = w.size();\\n            \\n            string w1 = w.substr(0,pref.size());\\n            \\n            if(w1 == pref)\\n            count++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count = 0;\\n        for(int i=0; i<words.size(); i++)\\n        {\\n            string w = words[i];\\n            int n = w.size();\\n            \\n            string w1 = w.substr(0,pref.size());\\n            \\n            if(w1 == pref)\\n            count++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803429,
                "title": "java-c-solution-100",
                "content": "**C++ Solution**\\n\\n```\\nlass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count = 0;\\n        int ans = 0;\\n\\t\\t\\n\\t\\tfor(auto &it : words)\\n\\t\\t{\\n\\t\\t\\tint i = 0;          // for iterating in the pref\\n\\t\\t\\twhile( it[i] == pref[i]){    // if starting elements are matched then keep looping\\n            count++;\\n            i++;\\n            \\n            if(i==pref.size()){        // if i reaches the size means it got all the elements\\n                break;                  // so break the while loop\\n            }\\n        }\\n        if(count == pref.size()){    // is it equal to size ?? means all elements are found??\\n            ans++;                   // no. of string in vector that have this pefix\\n        }\\n        count=0;        // for again incrementing for other strinngs in vector\\n      }\\n\\nreturn ans;\\n    }\\n};\\n```\\n\\n**JAVA Solution**\\n\\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        \\n        for(String w : words)\\n\\t\\t{\\n            if(w.indexOf(pref) == 0){\\n                count++;\\n            } else {\\n                count+= 0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nlass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int count = 0;\\n        int ans = 0;\\n\\t\\t\\n\\t\\tfor(auto &it : words)\\n\\t\\t{\\n\\t\\t\\tint i = 0;          // for iterating in the pref\\n\\t\\t\\twhile( it[i] == pref[i]){    // if starting elements are matched then keep looping\\n            count++;\\n            i++;\\n            \\n            if(i==pref.size()){        // if i reaches the size means it got all the elements\\n                break;                  // so break the while loop\\n            }\\n        }\\n        if(count == pref.size()){    // is it equal to size ?? means all elements are found??\\n            ans++;                   // no. of string in vector that have this pefix\\n        }\\n        count=0;        // for again incrementing for other strinngs in vector\\n      }\\n\\nreturn ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        \\n        for(String w : words)\\n\\t\\t{\\n            if(w.indexOf(pref) == 0){\\n                count++;\\n            } else {\\n                count+= 0;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803323,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        int n=pref.length();\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].length()>=n &&words[i].substring(0,n).equals(pref))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        int n=pref.length();\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].length()>=n &&words[i].substring(0,n).equals(pref))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803176,
                "title": "swift-1-liner-24-ms-14-8-mb",
                "content": "```\\nclass Solution {\\n    func prefixCount(_ words: [String], _ pref: String) -> Int {\\n        return words.reduce(0, {$0 + ($1.hasPrefix(pref) ? 1 : 0)})\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func prefixCount(_ words: [String], _ pref: String) -> Int {\\n        return words.reduce(0, {$0 + ($1.hasPrefix(pref) ? 1 : 0)})\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802989,
                "title": "c-easy-solution-only-5-line",
                "content": "int prefixCount(vector<string>& words, string pref) {\\n        int c=0; //count of the strings which contained prefix\\n        for(auto it:words)\\n        {\\n            if(it.find(pref)==0) // if pref found in the string at 0 \\'0--> begin index of string\\'\\n                c++;\\n        }\\n        return c;\\n    }",
                "solutionTags": [],
                "code": "int prefixCount(vector<string>& words, string pref) {\\n        int c=0; //count of the strings which contained prefix\\n        for(auto it:words)\\n        {\\n            if(it.find(pref)==0) // if pref found in the string at 0 \\'0--> begin index of string\\'\\n                c++;\\n        }\\n        return c;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1802900,
                "title": "c-solution",
                "content": "bool compare(char* s, char* pref){\\n\\n    char *temp=s;   \\n    if(strlen(pref) > strlen(s))\\n        return false;\\n    \\n    while((*temp == *pref)&& (*pref != \\'\\\\0\\')){\\n        temp ++;pref++;        \\n    }\\n    if(*pref == \\'\\\\0\\')return true;\\nreturn false;\\n}\\n\\n\\nint prefixCount(char ** words, int wordsSize, char * pref){\\n    \\n    int count=0;    \\n    for(int i=0; i <wordsSize;i++){\\n        if(compare(words[i],pref))count++;\\n    }\\n   return count;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "bool compare(char* s, char* pref){\\n\\n    char *temp=s;   \\n    if(strlen(pref) > strlen(s))\\n        return false;\\n    \\n    while((*temp == *pref)&& (*pref != \\'\\\\0\\')){\\n        temp ++;pref++;        \\n    }\\n    if(*pref == \\'\\\\0\\')return true;\\nreturn false;\\n}\\n\\n\\nint prefixCount(char ** words, int wordsSize, char * pref){\\n    \\n    int count=0;    \\n    for(int i=0; i <wordsSize;i++){\\n        if(compare(words[i],pref))count++;\\n    }\\n   return count;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1802858,
                "title": "very-simple-solution-with-explnation",
                "content": "\\tIst we traverse  then we find the  pref ans should we conatin 0th postion  then ans ++\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int c=0;\\n        for(auto it:words)\\n        {\\n            if(it.find(pref)==0)\\n                c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int c=0;\\n        for(auto it:words)\\n        {\\n            if(it.find(pref)==0)\\n                c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802840,
                "title": "easy-js-javascript",
                "content": "```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    \\n    for (const word of words) {\\n        if (word.slice(0, pref.length) === pref) count++;\\n    }\\n    \\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar prefixCount = function(words, pref) {\\n    let count = 0;\\n    \\n    for (const word of words) {\\n        if (word.slice(0, pref.length) === pref) count++;\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802793,
                "title": "java-100-solution",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        int len = pref.length();\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].length() >= len && words[i].substring(0,len).equals(pref))\\n          {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count=0;\\n        int len = pref.length();\\n        for(int i=0;i<words.length;i++){\\n            if(words[i].length() >= len && words[i].substring(0,len).equals(pref))\\n          {\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1802737,
                "title": "easy-and-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n       int count = 0;\\n       int n = pref.size();\\n       for(string s : words){\\n          if(s.size() >= n){\\n                  if(s.substr(0, n) == pref) count++;\\n          }          \\n       }\\n            return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int prefixCount(vector<string>& words, string pref) {\\n       int count = 0;\\n       int n = pref.size();\\n       for(string s : words){\\n          if(s.size() >= n){\\n                  if(s.substr(0, n) == pref) count++;\\n          }          \\n       }\\n            return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802718,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int len = pref.length();\\n        int count = 0;\\n        for(String word : words){\\n            if(word.length() < len)\\n                continue;\\n            if(check(word,pref))\\n                count++;\\n        }\\n        return count;\\n    }\\n    private static boolean check(String word, String pref){\\n        int len = pref.length();\\n        for(int i = 0; i < len; i++){\\n            if(word.charAt(i) != pref.charAt(i))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int len = pref.length();\\n        int count = 0;\\n        for(String word : words){\\n            if(word.length() < len)\\n                continue;\\n            if(check(word,pref))\\n                count++;\\n        }\\n        return count;\\n    }\\n    private static boolean check(String word, String pref){\\n        int len = pref.length();\\n        for(int i = 0; i < len; i++){\\n            if(word.charAt(i) != pref.charAt(i))\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802705,
                "title": "c-easy-to-understand-simple-solution",
                "content": "**Do upvote If this helped!!**\\n```\\n    int prefixCount(vector<string>& words, string pref) {\\n        int pre_size = pref.size();\\n        int n = words.size();\\n        \\n        int count = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            string temp = words[i];\\n            int j=0;\\n            \\n            while(j < pre_size)\\n            {\\n                if(temp[j] == pref[j])\\n                {\\n                    j++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            \\n            if(j== pre_size)\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int prefixCount(vector<string>& words, string pref) {\\n        int pre_size = pref.size();\\n        int n = words.size();\\n        \\n        int count = 0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            string temp = words[i];\\n            int j=0;\\n            \\n            while(j < pre_size)\\n            {\\n                if(temp[j] == pref[j])\\n                {\\n                    j++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            \\n            if(j== pre_size)\\n            {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802702,
                "title": "c-simple-easy-code",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\tint ans = 0;\\n\\t\\tint n = pref.size();\\n\\t\\tfor (auto s : words)\\n\\t\\t{\\n\\t\\t\\tif (s.substr(0, n) == pref)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n\\n**If find Helpful *Upvote It* \\uD83D\\uDC4D**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint prefixCount(vector<string>& words, string pref) {\\n\\t\\tint ans = 0;\\n\\t\\tint n = pref.size();\\n\\t\\tfor (auto s : words)\\n\\t\\t{\\n\\t\\t\\tif (s.substr(0, n) == pref)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802672,
                "title": "cpp-easiset-solution-begineer-friendly",
                "content": "**Apporaoch** \\n* Just Traverse through each and every word.\\n* Find if any substring from starting position and of preifix size matches to prefix.\\n```\\n   int prefixCount(vector<string>& words, string pref) {\\n        int ans=0;\\n        for(auto i:words){\\n            if(i.substr(0,pref.size())==pref) ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n   int prefixCount(vector<string>& words, string pref) {\\n        int ans=0;\\n        for(auto i:words){\\n            if(i.substr(0,pref.size())==pref) ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802644,
                "title": "python3-1-line",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/6f8a2c98f0feab59d2e0ec35f928e3ee1d3e4456) for solutions of weekly 282. \\n\\n```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(word.startswith(pref) for word in words)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        return sum(word.startswith(pref) for word in words)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802624,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            String temp = words[i];\\n            if (temp.startsWith(pref)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int prefixCount(String[] words, String pref) {\\n        int count = 0;\\n        for (int i = 0; i < words.length; i++) {\\n            String temp = words[i];\\n            if (temp.startsWith(pref)) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802623,
                "title": "java-string-startswtih-simple-solution",
                "content": "```\\n    public int prefixCount(String[] words, String pref) {\\n        int res = 0;\\n        for (String s : words)\\n        \\tif (s.startsWith(pref))\\n        \\t\\tres++;\\n        return res;\\n    }\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int prefixCount(String[] words, String pref) {\\n        int res = 0;\\n        for (String s : words)\\n        \\tif (s.startsWith(pref))\\n        \\t\\tres++;\\n        return res;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1802591,
                "title": "easiest-short-sol-99-faster",
                "content": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        count=0\\n        for i in words:\\n            if i.startswith(pref) is True:\\n                count+=1         \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        count=0\\n        for i in words:\\n            if i.startswith(pref) is True:\\n                count+=1         \\n        return count\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1857039,
                "content": [
                    {
                        "username": "hehe666",
                        "content": "the candidates who were asked this question during interview are lucky"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        l = len(pref)\\n        count =0\\n        for i in words:\\n            if i[0:l] == pref:\\n                count+=1\\n        return count\\n```"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "var prefixCount = function(words, pref) {\\n    var counter = 0;\\n    for(var i=0;i<words.length;i++){\\n        if(words[i].startsWith(pref)){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\nreturn (int) Arrays.stream(words).filter(word -> word.startsWith(pref)).count();"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "C++ | 5 LINE SOL. | BEATS 93% |\\n\\nint c = 0;\\n        for(auto &word : words){\\n            if(word.find(pref)==0)\\n            c++;\\n        }\\n        return c;"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n\\n    bool ispref(string s,string p){\\n        for(int i=0;i<p.size();i++){\\n            if(s[i]!=p[i]) return 0;\\n        }\\n        return 1;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int w=pref.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(ispref(words[i],pref)) count++;\\n        }\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1845553,
                "content": [
                    {
                        "username": "hehe666",
                        "content": "the candidates who were asked this question during interview are lucky"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        l = len(pref)\\n        count =0\\n        for i in words:\\n            if i[0:l] == pref:\\n                count+=1\\n        return count\\n```"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "var prefixCount = function(words, pref) {\\n    var counter = 0;\\n    for(var i=0;i<words.length;i++){\\n        if(words[i].startsWith(pref)){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\nreturn (int) Arrays.stream(words).filter(word -> word.startsWith(pref)).count();"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "C++ | 5 LINE SOL. | BEATS 93% |\\n\\nint c = 0;\\n        for(auto &word : words){\\n            if(word.find(pref)==0)\\n            c++;\\n        }\\n        return c;"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n\\n    bool ispref(string s,string p){\\n        for(int i=0;i<p.size();i++){\\n            if(s[i]!=p[i]) return 0;\\n        }\\n        return 1;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int w=pref.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(ispref(words[i],pref)) count++;\\n        }\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1865308,
                "content": [
                    {
                        "username": "hehe666",
                        "content": "the candidates who were asked this question during interview are lucky"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        l = len(pref)\\n        count =0\\n        for i in words:\\n            if i[0:l] == pref:\\n                count+=1\\n        return count\\n```"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "var prefixCount = function(words, pref) {\\n    var counter = 0;\\n    for(var i=0;i<words.length;i++){\\n        if(words[i].startsWith(pref)){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\nreturn (int) Arrays.stream(words).filter(word -> word.startsWith(pref)).count();"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "C++ | 5 LINE SOL. | BEATS 93% |\\n\\nint c = 0;\\n        for(auto &word : words){\\n            if(word.find(pref)==0)\\n            c++;\\n        }\\n        return c;"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n\\n    bool ispref(string s,string p){\\n        for(int i=0;i<p.size();i++){\\n            if(s[i]!=p[i]) return 0;\\n        }\\n        return 1;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int w=pref.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(ispref(words[i],pref)) count++;\\n        }\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1846487,
                "content": [
                    {
                        "username": "hehe666",
                        "content": "the candidates who were asked this question during interview are lucky"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        l = len(pref)\\n        count =0\\n        for i in words:\\n            if i[0:l] == pref:\\n                count+=1\\n        return count\\n```"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "var prefixCount = function(words, pref) {\\n    var counter = 0;\\n    for(var i=0;i<words.length;i++){\\n        if(words[i].startsWith(pref)){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\nreturn (int) Arrays.stream(words).filter(word -> word.startsWith(pref)).count();"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "C++ | 5 LINE SOL. | BEATS 93% |\\n\\nint c = 0;\\n        for(auto &word : words){\\n            if(word.find(pref)==0)\\n            c++;\\n        }\\n        return c;"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n\\n    bool ispref(string s,string p){\\n        for(int i=0;i<p.size();i++){\\n            if(s[i]!=p[i]) return 0;\\n        }\\n        return 1;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int w=pref.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(ispref(words[i],pref)) count++;\\n        }\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1837157,
                "content": [
                    {
                        "username": "hehe666",
                        "content": "the candidates who were asked this question during interview are lucky"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        l = len(pref)\\n        count =0\\n        for i in words:\\n            if i[0:l] == pref:\\n                count+=1\\n        return count\\n```"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "var prefixCount = function(words, pref) {\\n    var counter = 0;\\n    for(var i=0;i<words.length;i++){\\n        if(words[i].startsWith(pref)){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\nreturn (int) Arrays.stream(words).filter(word -> word.startsWith(pref)).count();"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "C++ | 5 LINE SOL. | BEATS 93% |\\n\\nint c = 0;\\n        for(auto &word : words){\\n            if(word.find(pref)==0)\\n            c++;\\n        }\\n        return c;"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n\\n    bool ispref(string s,string p){\\n        for(int i=0;i<p.size();i++){\\n            if(s[i]!=p[i]) return 0;\\n        }\\n        return 1;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int w=pref.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(ispref(words[i],pref)) count++;\\n        }\\n        return count;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1835596,
                "content": [
                    {
                        "username": "hehe666",
                        "content": "the candidates who were asked this question during interview are lucky"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "```class Solution:\\n    def prefixCount(self, words: List[str], pref: str) -> int:\\n        l = len(pref)\\n        count =0\\n        for i in words:\\n            if i[0:l] == pref:\\n                count+=1\\n        return count\\n```"
                    },
                    {
                        "username": "itzRAYY",
                        "content": "var prefixCount = function(words, pref) {\\n    var counter = 0;\\n    for(var i=0;i<words.length;i++){\\n        if(words[i].startsWith(pref)){\\n            counter++;\\n        }\\n    }\\n    return counter;\\n};"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line Java\\nreturn (int) Arrays.stream(words).filter(word -> word.startsWith(pref)).count();"
                    },
                    {
                        "username": "sk_aayush",
                        "content": "C++ | 5 LINE SOL. | BEATS 93% |\\n\\nint c = 0;\\n        for(auto &word : words){\\n            if(word.find(pref)==0)\\n            c++;\\n        }\\n        return c;"
                    },
                    {
                        "username": "VamsidharReddyy",
                        "content": "class Solution {\\npublic:\\n\\n    bool ispref(string s,string p){\\n        for(int i=0;i<p.size();i++){\\n            if(s[i]!=p[i]) return 0;\\n        }\\n        return 1;\\n    }\\n    int prefixCount(vector<string>& words, string pref) {\\n        int n=words.size();\\n        int w=pref.size();\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(ispref(words[i],pref)) count++;\\n        }\\n        return count;\\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Number of Steps to Make Two Strings Anagram II",
        "question_content": "<p>You are given two strings <code>s</code> and <code>t</code>. In one step, you can append <strong>any character</strong> to either <code>s</code> or <code>t</code>.</p>\n\n<p>Return <em>the minimum number of steps to make </em><code>s</code><em> and </em><code>t</code><em> <strong>anagrams</strong> of each other.</em></p>\n\n<p>An <strong>anagram</strong> of a string is a string that contains the same characters with a different (or the same) ordering.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;<strong><u>lee</u></strong>tco<u><strong>de</strong></u>&quot;, t = &quot;co<u><strong>a</strong></u>t<u><strong>s</strong></u>&quot;\n<strong>Output:</strong> 7\n<strong>Explanation:</strong> \n- In 2 steps, we can append the letters in &quot;as&quot; onto s = &quot;leetcode&quot;, forming s = &quot;leetcode<strong><u>as</u></strong>&quot;.\n- In 5 steps, we can append the letters in &quot;leede&quot; onto t = &quot;coats&quot;, forming t = &quot;coats<u><strong>leede</strong></u>&quot;.\n&quot;leetcodeas&quot; and &quot;coatsleede&quot; are now anagrams of each other.\nWe used a total of 2 + 5 = 7 steps.\nIt can be shown that there is no way to make them anagrams of each other with less than 7 steps.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;night&quot;, t = &quot;thing&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The given strings are already anagrams of each other. Thus, we do not need any further steps.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, t.length &lt;= 2 * 10<sup>5</sup></code></li>\n\t<li><code>s</code> and <code>t</code> consist of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1802438,
                "title": "python3-java-c-counter-o-len-s-len-t",
                "content": "* Count the number of characters in each string \\n* Compare the counts for each character\\n* If the counts of the characters don\\'t match, add the difference of the counts to answer\\n<iframe src=\"https://leetcode.com/playground/TrFoEYxb/shared\" frameBorder=\"0\" width=\"600\" height=\"200\"></iframe>\\n\\nTime complexity: `O(len(s) + (len(t))`",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "* Count the number of characters in each string \\n* Compare the counts for each character\\n* If the counts of the characters don\\'t match, add the difference of the counts to answer\\n<iframe src=\"https://leetcode.com/playground/TrFoEYxb/shared\" frameBorder=\"0\" width=\"600\" height=\"200\"></iframe>\\n\\nTime complexity: `O(len(s) + (len(t))`",
                "codeTag": "Unknown"
            },
            {
                "id": 1802780,
                "title": "c-o-n-hashmap",
                "content": "An **anagram** is a word or phrase formed by rearranging the letters of a different word or phrase.\\nSo in the given question we need to count the frequecy of letter which are different.\\n**APPROACH**\\nFirst counted the frequecy of charachters in s and then counted the frequecy of t and in count variable store the mod (mean the positive value) of the difference\\n`\\n\\nint minSteps(string s, string t) {\\n\\t\\tunordered_map<char, int> mp;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n            mp[s[i]]++;\\n        n=t.size();\\n        for(int i=0;i<n;i++)\\n            mp[t[i]]--;\\n        int cnt=0;\\n        for(auto i:mp)\\n            cnt+=abs(i.second);\\n        return cnt;\\n    }`\\n\\t**Time Complexity:** for both the string we are going to every letter once, therefore it is O(N).\\n\\t**Space Complexity:** here we are using unordered_map to store frequecy of every letter in string so at we can have all english letter in the string, therfore it is O(26) or O(1).\\n\\tDo like it if this you in any way!\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "An **anagram** is a word or phrase formed by rearranging the letters of a different word or phrase.\\nSo in the given question we need to count the frequecy of letter which are different.\\n**APPROACH**\\nFirst counted the frequecy of charachters in s and then counted the frequecy of t and in count variable store the mod (mean the positive value) of the difference\\n`\\n\\nint minSteps(string s, string t) {\\n\\t\\tunordered_map<char, int> mp;\\n        int n=s.size();\\n        for(int i=0;i<n;i++)\\n            mp[s[i]]++;\\n        n=t.size();\\n        for(int i=0;i<n;i++)\\n            mp[t[i]]--;\\n        int cnt=0;\\n        for(auto i:mp)\\n            cnt+=abs(i.second);\\n        return cnt;\\n    }`\\n\\t**Time Complexity:** for both the string we are going to every letter once, therefore it is O(N).\\n\\t**Space Complexity:** here we are using unordered_map to store frequecy of every letter in string so at we can have all english letter in the string, therfore it is O(26) or O(1).\\n\\tDo like it if this you in any way!\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1802572,
                "title": "c-easiest-solution",
                "content": "```\\n// The simplest solution one can think is:\\n// Find the number of different characters in both the strings.\\n\\n// I have implemented the same solution but in memory efficient solution\\n\\n\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        int count=0;\\n        //take an array of 26 size to store frequency of alphabets\\n        vector<int> arr(26,0);\\n        \\n        \\n        //increment the frequency of character by 1 in the array\\n        for(auto i:s)\\n            arr[i-\\'a\\']++;\\n        \\n        //decrement the frequency of character by 1 in the array\\n        for(auto i:t)\\n            arr[i-\\'a\\']--;\\n        \\n        // Now the array will only store the frequency of characters that are different\\n        for(auto i:arr)\\n            count+=abs(i);\\n        \\n        return count;\\n        \\n        \\n        \\n    }\\n};\\n```\\nPlease **Upvote**, if you liked my solution.\\nDont forget to visit my repo: https://github.com/tarunsahnan/LeetCode-Solutions\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// The simplest solution one can think is:\\n// Find the number of different characters in both the strings.\\n\\n// I have implemented the same solution but in memory efficient solution\\n\\n\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        int count=0;\\n        //take an array of 26 size to store frequency of alphabets\\n        vector<int> arr(26,0);\\n        \\n        \\n        //increment the frequency of character by 1 in the array\\n        for(auto i:s)\\n            arr[i-\\'a\\']++;\\n        \\n        //decrement the frequency of character by 1 in the array\\n        for(auto i:t)\\n            arr[i-\\'a\\']--;\\n        \\n        // Now the array will only store the frequency of characters that are different\\n        for(auto i:arr)\\n            count+=abs(i);\\n        \\n        return count;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802471,
                "title": "java-python-3-count-the-difference-w-analysis",
                "content": "**Java**\\n\\nA more readable Java code:\\n```java\\n    public int minSteps(String s, String t) {\\n        int[] cnt = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            ++cnt[s.charAt(i) - \\'a\\'];\\n       \\t}\\n       \\tfor (int i = 0; i < t.length(); ++i) {\\n            --cnt[t.charAt(i) - \\'a\\'];\\n       \\t}\\n       \\tint minSteps = 0;\\n       \\tfor (int c : cnt) {\\n            minSteps += Math.abs(c);\\n       \\t}\\n       \\treturn minSteps;        \\n    }\\n```\\n\\n----\\n\\n----\\n\\n\\n```java\\n    public int minSteps(String s, String t) {\\n        int[] cnt = new int[26];\\n        s.chars().forEach(c -> ++cnt[c - \\'a\\']);\\n        t.chars().forEach(c -> --cnt[c - \\'a\\']);\\n        return IntStream.of(cnt).map(i -> Math.abs(i)).sum();\\n    }\\n```\\n\\n----\\n\\n**Python 3**\\n\\n```python\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt = [0] * 26\\n        for c in s:\\n            cnt[ord(c) - ord(\\'a\\')] += 1\\n        for c in t:\\n            cnt[ord(c) - ord(\\'a\\')] -= 1\\n        return sum(map(abs, cnt))\\n```\\n\\n```python\\n    def minSteps(self, s: str, t: str) -> int:\\n        cs, ct = map(Counter, (s, t))\\n        return sum(((cs - ct) + (ct - cs)).values())\\n```\\n**Analysis for above 4 codes:**\\n\\nTime: `O(S + T)`, space: `O(1)` where `T = t.length(), S = s.length()`.",
                "solutionTags": [],
                "code": "```java\\n    public int minSteps(String s, String t) {\\n        int[] cnt = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            ++cnt[s.charAt(i) - \\'a\\'];\\n       \\t}\\n       \\tfor (int i = 0; i < t.length(); ++i) {\\n            --cnt[t.charAt(i) - \\'a\\'];\\n       \\t}\\n       \\tint minSteps = 0;\\n       \\tfor (int c : cnt) {\\n            minSteps += Math.abs(c);\\n       \\t}\\n       \\treturn minSteps;        \\n    }\\n```\n```java\\n    public int minSteps(String s, String t) {\\n        int[] cnt = new int[26];\\n        s.chars().forEach(c -> ++cnt[c - \\'a\\']);\\n        t.chars().forEach(c -> --cnt[c - \\'a\\']);\\n        return IntStream.of(cnt).map(i -> Math.abs(i)).sum();\\n    }\\n```\n```python\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt = [0] * 26\\n        for c in s:\\n            cnt[ord(c) - ord(\\'a\\')] += 1\\n        for c in t:\\n            cnt[ord(c) - ord(\\'a\\')] -= 1\\n        return sum(map(abs, cnt))\\n```\n```python\\n    def minSteps(self, s: str, t: str) -> int:\\n        cs, ct = map(Counter, (s, t))\\n        return sum(((cs - ct) + (ct - cs)).values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1802805,
                "title": "counter",
                "content": "For some reason, I misread the description, and tried to solve another problem.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cs, ct = Counter(s), Counter(t)\\n        return sum(cnt for ch, cnt in ((cs - ct) + (ct - cs)).items())\\n```\\n**C++**\\n```cpp\\nint minSteps(string s, string t) {\\n    int cnt[26] = {};\\n    for (char ch : s) \\n        ++cnt[ch - \\'a\\'];\\n    for (char ch : t) \\n        --cnt[ch - \\'a\\'];\\n    return accumulate(begin(cnt), end(cnt), 0, [](int sum, int n){ return sum + abs(n); });\\n}\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cs, ct = Counter(s), Counter(t)\\n        return sum(cnt for ch, cnt in ((cs - ct) + (ct - cs)).items())\\n```\n```cpp\\nint minSteps(string s, string t) {\\n    int cnt[26] = {};\\n    for (char ch : s) \\n        ++cnt[ch - \\'a\\'];\\n    for (char ch : t) \\n        --cnt[ch - \\'a\\'];\\n    return accumulate(begin(cnt), end(cnt), 0, [](int sum, int n){ return sum + abs(n); });\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802652,
                "title": "python3-freq-table",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/6f8a2c98f0feab59d2e0ec35f928e3ee1d3e4456) for solutions of weekly 282. \\n\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        fs, ft = Counter(s), Counter(t)\\n        return sum((fs-ft).values()) + sum((ft-fs).values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        fs, ft = Counter(s), Counter(t)\\n        return sum((fs-ft).values()) + sum((ft-fs).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802657,
                "title": "c-counting-hashmap-easy-approach",
                "content": "Increment the count of each character in the 1st string.\\nDecrease the count of characters in the 2nd string.\\n    \\n    character from \\'a\\' to \\'z\\' whose count is positive is needed to be added in string 2 and whose count is negative is needed to be added in string 1.\\n    So, the summation of abs(0-(count of character)) for each charatcer from \\'a\\' to \\'z\\' will give the result !!\\n    \\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int>freq(26,0);\\n        for(auto i: s)freq[i-\\'a\\']++;\\n        for(auto i: t)freq[i-\\'a\\']--;\\n        int steps=0;\\n        for(int i=0;i<26;i++)steps+=abs(0-freq[i]);\\n        return steps;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int>freq(26,0);\\n        for(auto i: s)freq[i-\\'a\\']++;\\n        for(auto i: t)freq[i-\\'a\\']--;\\n        int steps=0;\\n        for(int i=0;i<26;i++)steps+=abs(0-freq[i]);\\n        return steps;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1802576,
                "title": "c-java-counting",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-282/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int cnt[26] = {}, ans = 0;\\n        for (char c : s) cnt[c - \\'a\\']++;\\n        for (char c : t) cnt[c - \\'a\\']--;\\n        for (int n : cnt) ans += abs(n);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Java**\\n\\n```java\\n// OJ: https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int cnt[] = new int[26], ans = 0;\\n        for (char c : s.toCharArray()) cnt[c - \\'a\\']++;\\n        for (char c : t.toCharArray()) cnt[c - \\'a\\']--;\\n        for (int n : cnt) ans += Math.abs(n);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-282/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int cnt[26] = {}, ans = 0;\\n        for (char c : s) cnt[c - \\'a\\']++;\\n        for (char c : t) cnt[c - \\'a\\']--;\\n        for (int n : cnt) ans += abs(n);\\n        return ans;\\n    }\\n};\\n```\n```java\\n// OJ: https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int cnt[] = new int[26], ans = 0;\\n        for (char c : s.toCharArray()) cnt[c - \\'a\\']++;\\n        for (char c : t.toCharArray()) cnt[c - \\'a\\']--;\\n        for (int n : cnt) ans += Math.abs(n);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297662,
                "title": "easily-understandable-no-need-of-sorting",
                "content": "```\\nclass Solution {\\n    public static int minSteps(String s, String t) {\\n\\t\\tint[] freq = new int[26];\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tfreq[s.charAt(i) - \\'a\\']++;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < t.length(); i++) {\\n\\t\\t\\t\\tfreq[t.charAt(i) - \\'a\\']--;\\n\\t\\t}\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tcount += Math.abs(freq[i]);\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int minSteps(String s, String t) {\\n\\t\\tint[] freq = new int[26];\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tfreq[s.charAt(i) - \\'a\\']++;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < t.length(); i++) {\\n\\t\\t\\t\\tfreq[t.charAt(i) - \\'a\\']--;\\n\\t\\t}\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tcount += Math.abs(freq[i]);\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802606,
                "title": "c-easy-to-understand-hashmap",
                "content": "\\nGoal: find the minimum numbers of step to make the strings anagram.\\nApproach:\\n```\\nwe need to make all the occurances of a character in both the string equal.\\n          for example:    leetcode        c d eee l o t\\n                          coats         a c         o t  s\\n          so in the first string d eee l are present in the string 1 which is not present in string 2\\n          these 5 character need to be appended to string 2\\n          and similarly string1 doesn\\'t contain a and s which is in string 2.\\n          so these 2 character need to be added.\\n          \\n          from this we can have a array which increases the the value when a character occurs in string 1 and reduces the\\n          value when a character occurs in string 2.\\n\\n          and then we can traverse the array and add the absolute value of all the entries in the array.\\n```\\n\\nCode: \\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int cnt=0;\\n        vector<int> v(26,0);\\n        // for each character in string s we will increment the value present at the index corresponding to the character\\n        for(int i=0;i<s.size();i++)\\n            v[s[i]-\\'a\\']++;\\n        // we will decrement the value for the same\\n        for(int i=0;i<t.size();i++)\\n            v[t[i]-\\'a\\']--;\\n        for(int i=0;i<26;i++)\\n        {\\n            // add the aboslute value of every entry\\n            cnt+=abs(v[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\ntime complexity:  O(n)\\nspace complexity: O(1)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nwe need to make all the occurances of a character in both the string equal.\\n          for example:    leetcode        c d eee l o t\\n                          coats         a c         o t  s\\n          so in the first string d eee l are present in the string 1 which is not present in string 2\\n          these 5 character need to be appended to string 2\\n          and similarly string1 doesn\\'t contain a and s which is in string 2.\\n          so these 2 character need to be added.\\n          \\n          from this we can have a array which increases the the value when a character occurs in string 1 and reduces the\\n          value when a character occurs in string 2.\\n\\n          and then we can traverse the array and add the absolute value of all the entries in the array.\\n```\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int cnt=0;\\n        vector<int> v(26,0);\\n        // for each character in string s we will increment the value present at the index corresponding to the character\\n        for(int i=0;i<s.size();i++)\\n            v[s[i]-\\'a\\']++;\\n        // we will decrement the value for the same\\n        for(int i=0;i<t.size();i++)\\n            v[t[i]-\\'a\\']--;\\n        for(int i=0;i<26;i++)\\n        {\\n            // add the aboslute value of every entry\\n            cnt+=abs(v[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802531,
                "title": "javascript-frequency-map",
                "content": "**Solution: Two Frequency Arrays**\\n\\nUse two arrays of size 26 to store the frequency of each character in s and t.\\nReturn the sum of the absolute differences between each sFreq[i] and tFreq[i].\\n\\nn = s.length, m = t.length\\nTime Complexity: O(n + m)\\nSpace Complexity: O(1)\\n\\n```\\nvar minSteps = function(s, t) {\\n  let sFreq = Array(26).fill(0), tFreq = Array(26).fill(0);\\n  for (let char of s) sFreq[char.charCodeAt() - 97]++;\\n  for (let char of t) tFreq[char.charCodeAt() - 97]++;\\n  let ans = 0;\\n  for (let i = 0; i < 26; i++) {\\n    ans += Math.abs(sFreq[i] - tFreq[i]);\\n  }\\n  return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minSteps = function(s, t) {\\n  let sFreq = Array(26).fill(0), tFreq = Array(26).fill(0);\\n  for (let char of s) sFreq[char.charCodeAt() - 97]++;\\n  for (let char of t) tFreq[char.charCodeAt() - 97]++;\\n  let ans = 0;\\n  for (let i = 0; i < 26; i++) {\\n    ans += Math.abs(sFreq[i] - tFreq[i]);\\n  }\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3799022,
                "title": "very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] arrS = func(s);\\n        int[] arrT = func(t);\\n\\n        int steps = 0;\\n        for(int i = 0; i < arrS.length; i++) {\\n            steps += Math.abs(arrS[i] - arrT[i]);\\n        }\\n        return steps;\\n\\n    }\\n    public int[] func(String s){\\n        int[] arr = new int[26];\\n        for(char c : s.toCharArray()) {\\n            arr[c - \\'a\\']++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] arrS = func(s);\\n        int[] arrT = func(t);\\n\\n        int steps = 0;\\n        for(int i = 0; i < arrS.length; i++) {\\n            steps += Math.abs(arrS[i] - arrT[i]);\\n        }\\n        return steps;\\n\\n    }\\n    public int[] func(String s){\\n        int[] arr = new int[26];\\n        for(char c : s.toCharArray()) {\\n            arr[c - \\'a\\']++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218306,
                "title": "time-o-n-space-1-c-6line-code-store-frequency-of-each-element",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> v(26,0);\\n        for(auto &i: s)v[i-\\'a\\']++;\\n        for(auto &i: t)v[i-\\'a\\']--;\\n        int ans = 0;\\n        for(auto &i: v)ans += abs(i);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> v(26,0);\\n        for(auto &i: s)v[i-\\'a\\']++;\\n        for(auto &i: t)v[i-\\'a\\']--;\\n        int ans = 0;\\n        for(auto &i: v)ans += abs(i);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112227,
                "title": "python-easy-solution-using-counter",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt1=Counter(s)\\n        cnt2=Counter(t)\\n        sm=0\\n        cnt=cnt1-cnt2+(cnt2-cnt1)\\n        for i in cnt.values():\\n            sm+=i\\n        return sm\\n```",
                "solutionTags": [
                    "Python3",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt1=Counter(s)\\n        cnt2=Counter(t)\\n        sm=0\\n        cnt=cnt1-cnt2+(cnt2-cnt1)\\n        for i in cnt.values():\\n            sm+=i\\n        return sm\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848584,
                "title": "very-easy-cpp-solution-using-hashmap",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int>v(26,0);\\n        for(auto i:s){\\n            v[i-\\'a\\']++;\\n        }\\n        for(auto i:t){\\n            v[i-\\'a\\']--;\\n        }\\n        int ans=0;\\n        for(int i=0;i<26;i++){\\n            ans+=abs(v[i]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int>v(26,0);\\n        for(auto i:s){\\n            v[i-\\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1811018,
                "title": "swift-hashmap-counter",
                "content": "This is the first time I have tried to post something here :D\\n\\nAn **anagram** of a string is a string that contains the same characters with a different (or the same) ordering. The idea is to use a `counter` to keep track the difference of each character in two strings to produce the result.\\n\\n1. Iterate over every character in `s` and increase the counter by 1\\n2. Iterate over every character in `t` and decrease the counter by 1\\n3. Now, the items remaining in `counter` are the difference of each character between `s` and `t`. Let\\'s say `diff` is value of key `c`, we have 3 cases:\\n  - `diff == 0` means the occurences in `s` and `t` are the same --> We don\\'t need to append `c` neither to `s` or `t`\\n  - `diff > 0` means `s` has more character `c` than `t` --> we need to append `diff` times to `t`\\n  - `diff < 0` means `t` has more character `c` than `s` --> we need to append `diff` times to `s`\\n\\n**Swift**\\n```swift\\nclass Solution {\\n  func minSteps(_ s: String, _ t: String) -> Int {\\n    var counter = [Character: Int]()\\n    for c in s {\\n      counter[c, default: 0] += 1 \\n    }\\n    \\n    for c in t {\\n      counter[c, default: 0] -= 1 \\n    }\\n    \\n    var res = 0 \\n    for diff in counter.values {\\n      res += abs(diff)\\n    }\\n    \\n    return res\\n  }\\n} \\n\\n// Time complexity: O(m + n) where m is s.count and n is t.count. \\n// Space complexity: O(26) = O(1) since s and t only consist of lowercase English letters.\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n  func minSteps(_ s: String, _ t: String) -> Int {\\n    var counter = [Character: Int]()\\n    for c in s {\\n      counter[c, default: 0] += 1 \\n    }\\n    \\n    for c in t {\\n      counter[c, default: 0] -= 1 \\n    }\\n    \\n    var res = 0 \\n    for diff in counter.values {\\n      res += abs(diff)\\n    }\\n    \\n    return res\\n  }\\n} \\n\\n// Time complexity: O(m + n) where m is s.count and n is t.count. \\n// Space complexity: O(26) = O(1) since s and t only consist of lowercase English letters.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806796,
                "title": "python3-easy-approach-using-hashmap",
                "content": "### Kindly Upvote if you found the explanation useful.\\n\\nThe approach is pretty simple. \\n1. Create two dictionaries (hashmaps) and count the frequency of every character.\\n2. Initialize a counting variable which will count the characters required to be appended in each of the string.\\n3. First we iterate on hashmap of string `s`:\\n\\t*   For each (key, value) in hashmap of `s`, if the value is greater than or equal to the corresponding value of the character in hashmap of `t`. We simply add the difference of the two values to the variable `count`.\\n4. Then we iterate on hashmap of string `t`:\\n\\t*   For each (key, value) in hashmap of `t`, if the value is greater than or equal to the corresponding value of the character in hashmap of `s`. We simply add the difference of the two values to the variable `count`.\\n5. Finally we return `count` as our final answer.\\n\\n**Code:**\\n\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        sMap = dict()\\n        tMap = dict()\\n        \\n        for character in s:\\n            sMap[character] = sMap.get(character, 0) + 1\\n        \\n        for character in t:\\n            tMap[character] = tMap.get(character, 0) + 1\\n            \\n        count = 0\\n        \\n        for key, value in sMap.items():\\n            if value >= tMap.get(key, 0):\\n                count += (value - tMap.get(key, 0))\\n        \\n        for key, value in tMap.items():\\n            if value >= sMap.get(key, 0):\\n                count += (value - sMap.get(key, 0))\\n        \\n        return count\\n```\\n<br>\\n\\nBut, if we observe, we really don\\'t need 2 hashmaps for the same task. The approach is, \\nfor each character in string `s` **increment** the frequency in the hashmap then, \\nfor each character in string `t` **decrement** the frequency in the hashmap. \\nFinally sum up all the (absolute) values in the hashmap.\\n\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        \\n        mp = dict()\\n        \\n        for character in s:\\n            mp[character] = mp.get(character, 0) + 1\\n        \\n        for character in t:\\n            mp[character] = mp.get(character, 0) - 1\\n        \\n        count = 0\\n        for key, value in mp.items():\\n            count += abs(value)\\n        \\n        return count\\n```\\n\\n<br>\\n\\nWe can use Counter class from collections, which can count the frequencies at one. \\nThen using a simple comprehension we can count the required difference for each character from the hashmaps and print the sum of those individual differences.\\n\\n```\\nfrom collections import Counter\\nimport string\\n\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        sCount, tCount = Counter(s), Counter(t)\\n        return sum(abs(sCount[character] - tCount[character]) for character in string.ascii_lowercase)\\n                    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        sMap = dict()\\n        tMap = dict()\\n        \\n        for character in s:\\n            sMap[character] = sMap.get(character, 0) + 1\\n        \\n        for character in t:\\n            tMap[character] = tMap.get(character, 0) + 1\\n            \\n        count = 0\\n        \\n        for key, value in sMap.items():\\n            if value >= tMap.get(key, 0):\\n                count += (value - tMap.get(key, 0))\\n        \\n        for key, value in tMap.items():\\n            if value >= sMap.get(key, 0):\\n                count += (value - sMap.get(key, 0))\\n        \\n        return count\\n```\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        \\n        mp = dict()\\n        \\n        for character in s:\\n            mp[character] = mp.get(character, 0) + 1\\n        \\n        for character in t:\\n            mp[character] = mp.get(character, 0) - 1\\n        \\n        count = 0\\n        for key, value in mp.items():\\n            count += abs(value)\\n        \\n        return count\\n```\n```\\nfrom collections import Counter\\nimport string\\n\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        sCount, tCount = Counter(s), Counter(t)\\n        return sum(abs(sCount[character] - tCount[character]) for character in string.ascii_lowercase)\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803049,
                "title": "easy-understandable-freq",
                "content": "```\\nclass Solution {\\n    public static int minSteps(String s, String t) {\\n\\t\\tint[] freq = new int[26];\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tfreq[s.charAt(i) - \\'a\\']++;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < t.length(); i++) {\\n\\t\\t\\t\\tfreq[t.charAt(i) - \\'a\\']--;\\n\\t\\t}\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tcount += Math.abs(freq[i]);\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int minSteps(String s, String t) {\\n\\t\\tint[] freq = new int[26];\\n\\t\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\t\\tfreq[s.charAt(i) - \\'a\\']++;\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < t.length(); i++) {\\n\\t\\t\\t\\tfreq[t.charAt(i) - \\'a\\']--;\\n\\t\\t}\\n\\t\\tint count = 0;\\n\\t\\tfor (int i = 0; i < 26; i++) {\\n\\t\\t\\tcount += Math.abs(freq[i]);\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802784,
                "title": "javascript-hashing-170ms-easy-understanding",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar minSteps = function(s1, s2) {\\n    let count = 0;\\n    let a = \\'a\\'.charCodeAt(0);\\n    let char_count = new Array(26).fill(0);\\n     \\n    // Iterate though the String and update count\\n    for(let s of s1)\\n        char_count[s.charCodeAt(0) - a]++;      \\n \\n    for(let s of s2)\\n        char_count[s.charCodeAt(0) - a]--;\\n    \\n    for(let i = 0; i < 26; ++i)\\n        if (char_count[i] !== 0)\\n            count += Math.abs(char_count[i]);\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} t\\n * @return {number}\\n */\\nvar minSteps = function(s1, s2) {\\n    let count = 0;\\n    let a = \\'a\\'.charCodeAt(0);\\n    let char_count = new Array(26).fill(0);\\n     \\n    // Iterate though the String and update count\\n    for(let s of s1)\\n        char_count[s.charCodeAt(0) - a]++;      \\n \\n    for(let s of s2)\\n        char_count[s.charCodeAt(0) - a]--;\\n    \\n    for(let i = 0; i < 26; ++i)\\n        if (char_count[i] !== 0)\\n            count += Math.abs(char_count[i]);\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802755,
                "title": "c-brute-force-easy-to-understand",
                "content": "\\n        \\n\\t\\tvector<int> vs(26,0),vt(26,0);\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            vs[s[i] - \\'a\\']++;\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            vt[t[i] - \\'a\\']++;\\n        }\\n        \\n        int cnt = 0;\\n    \\n        for(int i=0;i<26;i++)\\n        {\\n            cnt += (abs(vs[i] - vt[i]));\\n        }\\n        return cnt;\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n        \\n\\t\\tvector<int> vs(26,0),vt(26,0);\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            vs[s[i] - \\'a\\']++;\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            vt[t[i] - \\'a\\']++;\\n        }\\n        \\n        int cnt = 0;\\n    \\n        for(int i=0;i<26;i++)\\n        {\\n            cnt += (abs(vs[i] - vt[i]));\\n        }\\n        return cnt;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1802736,
                "title": "self-understandable-python-2-methods",
                "content": "**Method 1:**\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        a=Counter(s)\\n        b=Counter(t)\\n        c=(a-b)+(b-a)\\n        \\n        count=0\\n        for i in c:\\n            count+=c[i]\\n        return count\\n```\\n**Method 2:**\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        a=Counter(s)\\n        b=Counter(t)\\n        \\n        count=0\\n        for i in set(s + t):\\n             count+=abs(a[i]-b[i])\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        a=Counter(s)\\n        b=Counter(t)\\n        c=(a-b)+(b-a)\\n        \\n        count=0\\n        for i in c:\\n            count+=c[i]\\n        return count\\n```\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        a=Counter(s)\\n        b=Counter(t)\\n        \\n        count=0\\n        for i in set(s + t):\\n             count+=abs(a[i]-b[i])\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802610,
                "title": "very-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int cnt = 0;\\n        vector<int>freq(26 , 0) , freq1(26 , 0);\\n        for(char ch : s)\\n            freq[ch - \\'a\\']++;\\n        for(char ch : t)\\n            freq1[ch - \\'a\\']++;\\n        for(int i = 0 ; i <26 ; i++)\\n            cnt += abs(freq1[i] - freq[i]);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int cnt = 0;\\n        vector<int>freq(26 , 0) , freq1(26 , 0);\\n        for(char ch : s)\\n            freq[ch - \\'a\\']++;\\n        for(char ch : t)\\n            freq1[ch - \\'a\\']++;\\n        for(int i = 0 ; i <26 ; i++)\\n            cnt += abs(freq1[i] - freq[i]);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802574,
                "title": "c-count-missing-characters-trick-explained",
                "content": "We just need to find the characters that are present in one string but not in another \\nThe trick here is not to find the missing characters for each string instead just subtract the intersection elements from the universal set.\\n\\nSince **(A-B + B-A) = (A union B) - (A int B)**\\n\\n```\\nint minSteps(string s, string t) {\\n        map<char,int> m1,m2;\\n        int ans =0;\\n\\t\\t\\n\\t\\t//count frequency of characters in each string\\n        for(auto i:s){\\n            m1[i]++;\\n        }\\n        for(auto i:t){\\n            m2[i]++;\\n        }\\n        string x = \"abcdefghijklmnopqrstuvwxyz\";\\n\\t\\t\\n\\t\\t//count characters that are present in one string but not in another\\n        for(auto i:x){\\n                ans += abs(m1[i]-m2[i]);\\n        }\\n    \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Counting"
                ],
                "code": "```\\nint minSteps(string s, string t) {\\n        map<char,int> m1,m2;\\n        int ans =0;\\n\\t\\t\\n\\t\\t//count frequency of characters in each string\\n        for(auto i:s){\\n            m1[i]++;\\n        }\\n        for(auto i:t){\\n            m2[i]++;\\n        }\\n        string x = \"abcdefghijklmnopqrstuvwxyz\";\\n\\t\\t\\n\\t\\t//count characters that are present in one string but not in another\\n        for(auto i:x){\\n                ans += abs(m1[i]-m2[i]);\\n        }\\n    \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3825726,
                "title": "approach-using-single-map-c-implementation",
                "content": "# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL) ;\\n        cout.tie(NULL);\\n        \\n        unordered_map<char, int> m1;\\n        int n = s.size(), m = t.size();\\n\\n        for(int i=0; i<n; i++) m1[s[i]]++;\\n        for(int i=0; i<m; i++) m1[t[i]]--;\\n\\n        int ans = 0;\\n        for(auto it: m1){\\n            ans += abs(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL) ;\\n        cout.tie(NULL);\\n        \\n        unordered_map<char, int> m1;\\n        int n = s.size(), m = t.size();\\n\\n        for(int i=0; i<n; i++) m1[s[i]]++;\\n        for(int i=0; i<m; i++) m1[t[i]]--;\\n\\n        int ans = 0;\\n        for(auto it: m1){\\n            ans += abs(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3712042,
                "title": "5-lines-code-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCalculate the frequency of characters in both the string s and t and calculate the **sum of the absolute differences between the character frequencies.**\\n\\n# Complexity\\n- Time complexity:O(N+M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int n = s.size(),m = t.size(),ans = 0;\\n        vector<int> v1(26,0),v2(26,0);\\n        for(int i = 0;i<n;i++)  v1[s[i]-\\'a\\']++;\\n        for(int i = 0;i<m;i++)  v2[t[i]-\\'a\\']++;\\n        for(int i = 0;i<26;i++)  ans+=(abs(v1[i]-v2[i]));\\n        return ans;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/e1dc8032-a119-4206-90e0-383ec656ec57_1688375760.472194.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int n = s.size(),m = t.size(),ans = 0;\\n        vector<int> v1(26,0),v2(26,0);\\n        for(int i = 0;i<n;i++)  v1[s[i]-\\'a\\']++;\\n        for(int i = 0;i<m;i++)  v2[t[i]-\\'a\\']++;\\n        for(int i = 0;i<26;i++)  ans+=(abs(v1[i]-v2[i]));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309103,
                "title": "java-frequency-array-easy",
                "content": "# Intuition:\\nNumber of characters to be appended into one of the strings is the difference of the frequencies of that character in the two strings.\\n\\n---\\n# Steps:\\n- Record the frequencies of the characters in strings `s` and `t`.\\n- Iterate over the frequency arrays and take the absolute difference of the character frequencies and add them to number of operations.\\n---\\n# Code:\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] sFreq = new int[26];\\n        int[] tFreq = new int[26];\\n        for (int i = 0; i < Math.max(s.length(), t.length()); i++) {\\n            if (i < s.length()) sFreq[s.charAt(i) - \\'a\\']++;\\n            if (i < t.length()) tFreq[t.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        int ops = 0;\\n        for (int i = 0; i < 26; i++) {\\n            ops += Math.abs(sFreq[i] - tFreq[i]);\\n        }\\n\\n        return ops;\\n    }\\n}\\n```\\n---\\n##### Time complexity: $$O(max(len(s), len(t)) + 26)$$\\n##### Space complexity: $$O(26) => O(1)$$",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] sFreq = new int[26];\\n        int[] tFreq = new int[26];\\n        for (int i = 0; i < Math.max(s.length(), t.length()); i++) {\\n            if (i < s.length()) sFreq[s.charAt(i) - \\'a\\']++;\\n            if (i < t.length()) tFreq[t.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        int ops = 0;\\n        for (int i = 0; i < 26; i++) {\\n            ops += Math.abs(sFreq[i] - tFreq[i]);\\n        }\\n\\n        return ops;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235478,
                "title": "simple-solution-using-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int str1[26]={},str2[26]={};\\n        for(int i=0;i<s.size();i++) str1[s[i]-\\'a\\']++;\\n        for(int i=0;i<t.size();i++) str2[t[i]-\\'a\\']++;\\n        int ans=0;\\n        for(int i=0;i<26;i++) ans+=abs(str1[i]-str2[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int str1[26]={},str2[26]={};\\n        for(int i=0;i<s.size();i++) str1[s[i]-\\'a\\']++;\\n        for(int i=0;i<t.size();i++) str2[t[i]-\\'a\\']++;\\n        int ans=0;\\n        for(int i=0;i<26;i++) ans+=abs(str1[i]-str2[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083313,
                "title": "c-4-lines-of-code-single-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int>map;\\n        int count=0;\\n        for(auto x:s) map[x]++;\\n        for(auto x:t) map[x]--;\\n        for(auto x:map) count+=abs(x.second);\\n         return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int>map;\\n        int count=0;\\n        for(auto x:s) map[x]++;\\n        for(auto x:t) map[x]--;\\n        for(auto x:map) count+=abs(x.second);\\n         return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062113,
                "title": "o-m-n-time-using-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int total=s.length()+t.length();\\n        int cnt=0;\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        for(int i=0;i<t.length();i++){\\n            if(mp.find(t[i])!=mp.end() && mp[t[i]]>0){\\n                cnt++;\\n                mp[t[i]]--;\\n            }\\n        }\\n        return total-(cnt*2);\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int total=s.length()+t.length();\\n        int cnt=0;\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<s.length();i++){\\n            mp[s[i]]++;\\n        }\\n        for(int i=0;i<t.length();i++){\\n            if(mp.find(t[i])!=mp.end() && mp[t[i]]>0){\\n                cnt++;\\n                mp[t[i]]--;\\n            }\\n        }\\n        return total-(cnt*2);\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974868,
                "title": "beats-90-easiest-java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        \\n    int[]string1=new int[26];\\n    int[]string2=new int[26];\\n\\n    for(int i=0;i<s.length();i++){\\n    \\n    string1[s.charAt(i)-\\'a\\']++;\\n    \\n    }\\n\\n    for(int i=0;i<t.length();i++){\\n\\n    string2[t.charAt(i)-\\'a\\']++;\\n    \\n    }\\n\\n    int count=0;\\n\\n    for(int i=0;i<26;i++){\\n\\n    if(string1[i]<string2[i]){\\n\\n    count+=string2[i]-string1[i];\\n\\n    }\\n    else if(string2[i]<string1[i]){\\n        count+=string1[i]-string2[i];\\n    }\\n\\n    }\\n\\n    return count;\\n\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        \\n    int[]string1=new int[26];\\n    int[]string2=new int[26];\\n\\n    for(int i=0;i<s.length();i++){\\n    \\n    string1[s.charAt(i)-\\'a\\']++;\\n    \\n    }\\n\\n    for(int i=0;i<t.length();i++){\\n\\n    string2[t.charAt(i)-\\'a\\']++;\\n    \\n    }\\n\\n    int count=0;\\n\\n    for(int i=0;i<26;i++){\\n\\n    if(string1[i]<string2[i]){\\n\\n    count+=string2[i]-string1[i];\\n\\n    }\\n    else if(string2[i]<string1[i]){\\n        count+=string1[i]-string2[i];\\n    }\\n\\n    }\\n\\n    return count;\\n\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974100,
                "title": "q-2186-accepted-c-used-count-logic-easiest-simple-explained",
                "content": "CRUX\\n1) The elements of same frequency need not to changed.\\n2) Thus, only the complement of intersection need to returned as output\\n\\t s = \"leetcode\", t = \"coats\" Intersection : c t s \\n\\t Other\\'s need to be added.\\n\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector <int> v(26,0);\\n        for(char i:s)\\n            v[i-\\'a\\']++;\\n        for(char i:t)\\n            v[i-\\'a\\']--;\\n        \\n        int count=0;\\n        for(int i=0;i<26;i++)\\n\\t\\t\\t count+=abs(v[i]);\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector <int> v(26,0);\\n        for(char i:s)\\n            v[i-\\'a\\']++;\\n        for(char i:t)\\n            v[i-\\'a\\']--;\\n        \\n        int count=0;\\n        for(int i=0;i<26;i++)\\n\\t\\t\\t count+=abs(v[i]);\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2935182,
                "title": "easiest-solution-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int v1[26]={0};\\n        int v2[26]={0};\\n        for(auto &i:s) v1[i-\\'a\\']++;\\n        for(auto &i:t) v2[i-\\'a\\']++;\\n        int ans = 0;\\n        for(int i=0;i<26;i++){\\n            ans+=abs(v2[i]-v1[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int v1[26]={0};\\n        int v2[26]={0};\\n        for(auto &i:s) v1[i-\\'a\\']++;\\n        for(auto &i:t) v2[i-\\'a\\']++;\\n        int ans = 0;\\n        for(int i=0;i<26;i++){\\n            ans+=abs(v2[i]-v1[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504506,
                "title": "cpp-o-n-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int>v(26,0);\\n        int sum=0;\\n        for(char x:s)\\n            v[x-\\'a\\']++;\\n        for(char x:t)\\n            v[x-\\'a\\']--;\\n        for(int i=0;i<26;i++){\\n            sum+=abs(v[i]);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int>v(26,0);\\n        int sum=0;\\n        for(char x:s)\\n            v[x-\\'a\\']++;\\n        for(char x:t)\\n            v[x-\\'a\\']--;\\n        for(int i=0;i<26;i++){\\n            sum+=abs(v[i]);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415115,
                "title": "c-hashing-using-2-vectors-easiest-solution-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n      \\n    vector<int>freq_S(26,0);    // frequency vectors to store frequency of letters in  each string\\n    vector<int>freq_T(26,0); \\n    int result=0;              // final result\\n    \\n     for(auto it:s)            \\n     {\\n       freq_S[it-\\'a\\']++;       // incrementing the vector index using ascii values for s\\n     }\\n      \\n     for(auto it:t)\\n     {\\n        freq_T[it-\\'a\\']++;     // incrementing the vector index using ascii values for s\\n     }\\n      \\n     for(int i=0;i<26;++i)   // taking absolute of difference between 2 frequencies\\n     {\\n        \\n        result+=abs(freq_S[i]-freq_T[i]);     \\n        \\n     }\\n      \\n      return result;   \\n     }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n      \\n    vector<int>freq_S(26,0);    // frequency vectors to store frequency of letters in  each string\\n    vector<int>freq_T(26,0); \\n    int result=0;              // final result\\n    \\n     for(auto it:s)            \\n     {\\n       freq_S[it-\\'a\\']++;       // incrementing the vector index using ascii values for s\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 2221318,
                "title": "simple-solution-without-hashing-simple-counting-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int i = 0;\\n        int j = 0;\\n        int n = s.size();\\n        int m = t.size();\\n        int count = 0;\\n\\t\\t//creating 2 arrays to count the letters and then simply just the difference between the arrays will give the ans\\n        vector<int>v(26,0), e(26,0);\\n        for(int i = 0 ; i < s.size() ; i++){\\n            v[s[i]-\\'a\\']++;\\n        }\\n        for(int i = 0 ; i < t.size() ; i++){\\n            e[t[i]-\\'a\\']++;\\n        }\\n        for(int i = 0 ; i < 26 ; i++){\\n            count += abs(v[i]-e[i]);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int i = 0;\\n        int j = 0;\\n        int n = s.size();\\n        int m = t.size();\\n        int count = 0;\\n\\t\\t//creating 2 arrays to count the letters and then simply just the difference between the arrays will give the ans\\n        vector<int>v(26,0), e(26,0);\\n        for(int i = 0 ; i < s.size() ; i++){\\n            v[s[i]-\\'a\\']++;\\n        }\\n        for(int i = 0 ; i < t.size() ; i++){\\n            e[t[i]-\\'a\\']++;\\n        }\\n        for(int i = 0 ; i < 26 ; i++){\\n            count += abs(v[i]-e[i]);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179441,
                "title": "c-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> m;\\n        int c=0;\\n        for(auto& i : s){\\n            m[i]++;\\n        }\\n        for(auto& i : t){\\n            m[i]--;\\n        }\\n        for(auto& itr : m){\\n            c += fabs(itr.second);\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> m;\\n        int c=0;\\n        for(auto& i : s){\\n            m[i]++;\\n        }\\n        for(auto& i : t){\\n            m[i]--;\\n        }\\n        for(auto& itr : m){\\n            c += fabs(itr.second);\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2020803,
                "title": "two-fast-solutions-beat-99-and-beat-60",
                "content": "The main idea is to find the differences of value frequency in s and t and sum them up.\\n\\n* Approach 1: find the difference using collections.Count\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        count_s, count_t = collections.Counter(s), collections.Counter(t)\\n        difference = (count_s - count_t) + (count_t - count_s)\\n        return sum(difference.values())\\n```\\n* Approach 2: remove the common\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n\\t\\ttotal = len(s) + len(t)\\n\\t\\tfor i in set(s):\\n\\t\\t\\ttotal -= min(s.count(i),t.count(i)) * 2\\n\\t\\treturn total\\n```\\nNote that a common element shows twice in total. \\n\\nApproach 2 is faster and beats 99% in python. The first approach beats 60%.",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        count_s, count_t = collections.Counter(s), collections.Counter(t)\\n        difference = (count_s - count_t) + (count_t - count_s)\\n        return sum(difference.values())\\n```\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n\\t\\ttotal = len(s) + len(t)\\n\\t\\tfor i in set(s):\\n\\t\\t\\ttotal -= min(s.count(i),t.count(i)) * 2\\n\\t\\treturn total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848041,
                "title": "c-hashmap-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s1, string s2) {\\n        int cnt=0;\\n       vector<int>res(26,0);\\n        for(auto x:s1){\\n            res[x-\\'a\\']++;\\n        }\\n        for(auto x:s2){\\n            res[x-\\'a\\']--;       //idea is simple we are discarding the similar words and couting the rest words\\n        }\\n        for(auto x:res){\\n            cnt+=abs(x);\\n        }\\n        return cnt;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s1, string s2) {\\n        int cnt=0;\\n       vector<int>res(26,0);\\n        for(auto x:s1){\\n            res[x-\\'a\\']++;\\n        }\\n        for(auto x:s2){\\n            res[x-\\'a\\']--;       //idea is simple we are discarding the similar words and couting the rest words\\n        }\\n        for(auto x:res){\\n            cnt+=abs(x);\\n        }\\n        return cnt;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1834487,
                "title": "java-pretty-simple-solution-with-constant-space-without-hashmap",
                "content": "***Please upvote if you like the solution!***\\n\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int steps = 0;\\n        \\n        int[] arr = new int[26];\\n        \\n        for(char c: s.toCharArray())\\n            arr[c - \\'a\\']++;\\n        \\n        for(char c: t.toCharArray())\\n            arr[c - \\'a\\']--;\\n        \\n        for(int ch: arr){\\n            steps += Math.abs(ch);\\n        }\\n            \\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int steps = 0;\\n        \\n        int[] arr = new int[26];\\n        \\n        for(char c: s.toCharArray())\\n            arr[c - \\'a\\']++;\\n        \\n        for(char c: t.toCharArray())\\n            arr[c - \\'a\\']--;\\n        \\n        for(int ch: arr){\\n            steps += Math.abs(ch);\\n        }\\n            \\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816872,
                "title": "easy-to-understand-solution-time-o-nlogn-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) \\n    {\\n\\t// Sort Both the strings.\\n        sort(s.begin(), s.end());\\n        sort(t.begin(), t.end());\\n        int i = 0, j = 0;\\n        int m = s.size(), n = t.size();\\n        int count = 0;\\n        while (i < m && j < n)\\n        {\\n\\t\\t// If character at i and j are not same increment the counter.\\n            if (s[i] != t[j])\\n            {\\n                count++;\\n            }\\n\\t\\t\\t// In case s[i] != t[j] increment the position of the smaller character.\\n\\t\\t\\t// If s[i] == t[j] increment the position of both the characters.\\n            if (s[i] < t[j])\\n                i++;\\n            else if (s[i] > t[j])\\n                j++;\\n            else\\n            {\\n                i++;\\n                j++;\\n            }\\n        }\\n\\t\\t// When one of the string is exausted you\\'ll need all the characters from the remaining string to make them anagram of one another.\\n        if (j < n)\\n            count += n - j;\\n        if (i < m)\\n            count += m - i;\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) \\n    {\\n\\t// Sort Both the strings.\\n        sort(s.begin(), s.end());\\n        sort(t.begin(), t.end());\\n        int i = 0, j = 0;\\n        int m = s.size(), n = t.size();\\n        int count = 0;\\n        while (i < m && j < n)\\n        {\\n\\t\\t// If character at i and j are not same increment the counter.\\n            if (s[i] != t[j])\\n            {\\n                count++;\\n            }\\n\\t\\t\\t// In case s[i] != t[j] increment the position of the smaller character.\\n\\t\\t\\t// If s[i] == t[j] increment the position of both the characters.\\n            if (s[i] < t[j])\\n                i++;\\n            else if (s[i] > t[j])\\n                j++;\\n            else\\n            {\\n                i++;\\n                j++;\\n            }\\n        }\\n\\t\\t// When one of the string is exausted you\\'ll need all the characters from the remaining string to make them anagram of one another.\\n        if (j < n)\\n            count += n - j;\\n        if (i < m)\\n            count += m - i;\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814946,
                "title": "python-3-counter-difference-between-counts-beats-91",
                "content": "Find the count for each character in s and t and store in counter arrays.\\nFind the absolute difference between the counts of each character.\\n\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        count1 = [0]*26\\n        count2 = [0]*26\\n        for i in s:\\n            count1[ord(i)-ord(\\'a\\')] += 1\\n        for i in t:\\n            count2[ord(i)-ord(\\'a\\')] += 1\\n        \\n        steps = 0\\n        for i in range(26):\\n            steps += abs(count1[i]-count2[i])\\n        \\n        return steps\\n```\\nTime Complexity: O(len(s)+len(t))\\nSpace Complexity: O(1)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        count1 = [0]*26\\n        count2 = [0]*26\\n        for i in s:\\n            count1[ord(i)-ord(\\'a\\')] += 1\\n        for i in t:\\n            count2[ord(i)-ord(\\'a\\')] += 1\\n        \\n        steps = 0\\n        for i in range(26):\\n            steps += abs(count1[i]-count2[i])\\n        \\n        return steps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1808958,
                "title": "c-solution-using-hashmap",
                "content": "smjh\\n```\\n unordered_map<char,int>umap;\\n        \\n        int n = s.length();\\n        int m = t.length();\\n        int count =0;\\n        for(auto it : s){\\n            umap[it]++;\\n        }\\n        for(auto it: t){\\n            umap[it]--;\\n        }\\n        for(auto it:umap){\\n            count +=abs(it.second);\\n        }\\n        return count;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n unordered_map<char,int>umap;\\n        \\n        int n = s.length();\\n        int m = t.length();\\n        int count =0;\\n        for(auto it : s){\\n            umap[it]++;\\n        }\\n        for(auto it: t){\\n            umap[it]--;\\n        }\\n        for(auto it:umap){\\n            count +=abs(it.second);\\n        }\\n        return count;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1805793,
                "title": "c-easy-solution-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> c1(26,0), c2(26,0);\\n        \\n        for(auto &x : s)    c1[x-\\'a\\']++;\\n        for(auto &x : t)    c2[x-\\'a\\']++;\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<26; i++) ans += abs(c1[i]-c2[i]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> c1(26,0), c2(26,0);\\n        \\n        for(auto &x : s)    c1[x-\\'a\\']++;\\n        for(auto &x : t)    c2[x-\\'a\\']++;\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<26; i++) ans += abs(c1[i]-c2[i]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803630,
                "title": "c-o-n-map",
                "content": "//solution\\n\\n\\tclass Solution {\\n\\tpublic :\\n\\t\\tint minSteps(string s, string t) {\\n\\t\\t\\n\\t\\t\\t//creating map and inserting values in it\\n\\t\\t\\tunordered_map<char,int> ss,ts;\\n\\t\\t\\tfor(char c:s)\\n\\t\\t\\t\\tss[c]++;\\n\\t\\t\\tfor(char c:t)\\n\\t\\t\\t\\tts[c]++;\\n\\t\\t\\n\\t\\t\\t// checking for common values and removing their count\\n\\t\\t\\tfor(auto it=t.begin();it!=t.end();it++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tss[*it]--;\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto it=s.begin();it!=s.end();it++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tts[*it]--;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// summation of all the remaining items in both the maps\\n\\t\\t\\tint cs=0,ct=0;\\n\\t\\t\\tfor(auto it=ss.begin();it!=ss.end();it++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((it->second)>0)\\n\\t\\t\\t\\t\\tcs+=it->second;\\n\\t\\t\\t} \\n\\t\\t\\tfor(auto it=ts.begin();it!=ts.end();it++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif((it->second)>0)\\n\\t\\t\\t\\t\\tct+=it->second;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// cs has total values of ss map and ct has total of ts map\\n\\t\\t\\treturn ct+cs;\\n\\t\\t}\\t\\n\\t};\\n\\t",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic :\\n\\t\\tint minSteps(string s, string t) {\\n\\t\\t\\n\\t\\t\\t//creating map and inserting values in it\\n\\t\\t\\tunordered_map<char,int> ss,ts;\\n\\t\\t\\tfor(char c:s)\\n\\t\\t\\t\\tss[c]++;\\n\\t\\t\\tfor(char c:t)\\n\\t\\t\\t\\tts[c]++;\\n\\t\\t\\n\\t\\t\\t// checking for common values and removing their count\\n\\t\\t\\tfor(auto it=t.begin();it!=t.end();it++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tss[*it]--;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1803608,
                "title": "c-frequency-array-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int sf[26],tf[26]; //frequency arrays for each string\\n        int diff=0; //for storing the number of different characters\\n        \\n        memset(sf,0,sizeof(sf)); //set both arrays to 0 first\\n        memset(tf,0,sizeof(tf));\\n        \\n        for(int i=0;i<s.size();i++) sf[s[i]-\\'a\\']++; //storing frequency of each character in s\\n        for(int i=0;i<t.size();i++) tf[t[i]-\\'a\\']++; //storing frequency of each character in t\\n        \\n        for(int i=0;i<26;i++) \\n            diff+=abs(sf[i]-tf[i]); //store the amount of different characters\\n        \\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int sf[26],tf[26]; //frequency arrays for each string\\n        int diff=0; //for storing the number of different characters\\n        \\n        memset(sf,0,sizeof(sf)); //set both arrays to 0 first\\n        memset(tf,0,sizeof(tf));\\n        \\n        for(int i=0;i<s.size();i++) sf[s[i]-\\'a\\']++; //storing frequency of each character in s\\n        for(int i=0;i<t.size();i++) tf[t[i]-\\'a\\']++; //storing frequency of each character in t\\n        \\n        for(int i=0;i<26;i++) \\n            diff+=abs(sf[i]-tf[i]); //store the amount of different characters\\n        \\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803149,
                "title": "python-solution-counting-o-n",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        table = [0]*26\\n        for ch in s:\\n            table[ord(ch)-97] += 1\\n        for ch in t:\\n            table[ord(ch)-97] -= 1\\n        return sum([abs(i) for i in table])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        table = [0]*26\\n        for ch in s:\\n            table[ord(ch)-97] += 1\\n        for ch in t:\\n            table[ord(ch)-97] -= 1\\n        return sum([abs(i) for i in table])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803004,
                "title": "java-o-n-100ms-faster-runtime-27-no-hashmap",
                "content": "Increment the freq[i] for the elements in string s and decrement the freq[i] for the elements in string t. \\nStore the absolute sum of non zero elements in the frequency map.\\n\\n\\n```\\n public int minSteps(String s, String t) {\\n            \\n        int[] freq1 = new int[26];\\n            for(int i = 0;i<s.length();i++){\\n                char ch = s.charAt(i);\\n                \\n                freq1[ch -\\'a\\']++;\\n            }\\n            \\n             for(int i = 0;i<t.length();i++){\\n                char ch = t.charAt(i);\\n                \\n                freq1[ch -\\'a\\']--;\\n            }\\n            int count = 0;\\n            for(int i = 0;i<freq1.length;i++){\\n                count += Math.abs(freq1[i]);\\n            }\\n            return count;\\n        }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n public int minSteps(String s, String t) {\\n            \\n        int[] freq1 = new int[26];\\n            for(int i = 0;i<s.length();i++){\\n                char ch = s.charAt(i);\\n                \\n                freq1[ch -\\'a\\']++;\\n            }\\n            \\n             for(int i = 0;i<t.length();i++){\\n                char ch = t.charAt(i);\\n                \\n                freq1[ch -\\'a\\']--;\\n            }\\n            int count = 0;\\n            for(int i = 0;i<freq1.length;i++){\\n                count += Math.abs(freq1[i]);\\n            }\\n            return count;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802973,
                "title": "easy-short-using-map-c",
                "content": "**Minimum Number of Steps to Make Two Strings Anagram II**\\nKeep the frequncy map of charcters of both stings s and t. take the absolut different of frqucncy for each characters in s and t.\\n\\n```\\nint minSteps(string s, string t) {\\n        unordered_map<char,int>mp;\\n        for(auto c:s)\\n        {\\n            mp[c]++;\\n        }\\n        for(auto c:t)\\n        {\\n            mp[c]--;\\n        }\\n        int ans=0;\\n        for(auto m:mp)\\n        {\\n            ans+=abs(m.second);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minSteps(string s, string t) {\\n        unordered_map<char,int>mp;\\n        for(auto c:s)\\n        {\\n            mp[c]++;\\n        }\\n        for(auto c:t)\\n        {\\n            mp[c]--;\\n        }\\n        int ans=0;\\n        for(auto m:mp)\\n        {\\n            ans+=abs(m.second);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802935,
                "title": "c-easy-solution-hashmap-bruceforce-solution",
                "content": "```\\nint minSteps(string s, string t)\\n   {\\n       unordered_map<char,int>mp;\\n       for(int i=0; i<s.size(); i++)\\n       {\\n           mp[s[i]]++;\\n       }\\n       for(int i=0; i<t.size(); i++)\\n       {\\n           mp[t[i]]--;\\n       }\\n       int steps=0;\\n       for(auto x:mp)\\n       {\\n           steps+=abs(x.second);\\n       }\\n       return steps;\\n   }\\n```\\n\\n*If you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)*",
                "solutionTags": [],
                "code": "```\\nint minSteps(string s, string t)\\n   {\\n       unordered_map<char,int>mp;\\n       for(int i=0; i<s.size(); i++)\\n       {\\n           mp[s[i]]++;\\n       }\\n       for(int i=0; i<t.size(); i++)\\n       {\\n           mp[t[i]]--;\\n       }\\n       int steps=0;\\n       for(auto x:mp)\\n       {\\n           steps+=abs(x.second);\\n       }\\n       return steps;\\n   }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802897,
                "title": "c-easy-o-n-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int a[26]={0};\\n        for(int i=0;i<s.size();i++)\\n        {\\n            a[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            a[t[i]-\\'a\\']--;\\n        }\\n        int ans=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            ans+=abs(a[i]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Hash Table",
                    "Counting"
                ],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int a[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 1802835,
                "title": "c-easiest-solution",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    int minSteps(string s1, string s2) {\\n        int ans = 0;\\n \\n\\n        int char_count[26];\\n         \\n        for (int i = 0; i < 26; i++)\\n        {\\n            char_count[i] = 0;\\n        }\\n \\n       \\n        for (int i = 0; i < s1.length(); i++)\\n            char_count[s1[i] - \\'a\\']++;\\n \\n      \\n        for (int i = 0; i < s2.length(); i++)\\n        {\\n            char_count[s2[i] - \\'a\\']--;      \\n        }\\n       \\n        for(int i = 0; i < 26; ++i)\\n        {\\n          if(char_count[i] != 0)\\n          {\\n            ans+=abs(char_count[i]);\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int minSteps(string s1, string s2) {\\n        int ans = 0;\\n \\n\\n        int char_count[26];\\n         \\n        for (int i = 0; i < 26; i++)\\n        {\\n            char_count[i] = 0;\\n        }\\n \\n       \\n        for (int i = 0; i < s1.length(); i++)\\n            char_count[s1[i] - \\'a\\']++;\\n \\n      \\n        for (int i = 0; i < s2.length(); i++)\\n        {\\n            char_count[s2[i] - \\'a\\']--;      \\n        }\\n       \\n        for(int i = 0; i < 26; ++i)\\n        {\\n          if(char_count[i] != 0)\\n          {\\n            ans+=abs(char_count[i]);\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802728,
                "title": "cpp-easiset-solution",
                "content": "**Approach**\\n* Just keep the counter of each and every word and find if how many \\n* Differences are there in both of them.\\n\\n*First Implementation.*\\n```\\nint minSteps(string s, string t) {\\n         vector<int> a(26),b(26);\\n         int ans=0;\\n         for(int i=0;i<s.size();i++) a[s[i]-\\'a\\']++;\\n         for(int i=0;i<t.size();i++) b[t[i]-\\'a\\']++;\\n         for(int i=0;i<26;i++) ans+=abs(a[i]-b[i]);\\n         return ans;\\n    }\\n```\\n*Second Implementation.*\\n\\n```\\n       int ans=0;\\n        unordered_map<int,int> m;\\n        for(auto i:s) m[i]++;\\n        for(auto i:t) m[i]--;\\n        for(auto i:m) ans+=abs(i.second);\\n        return ans;\\n```",
                "solutionTags": [],
                "code": "```\\nint minSteps(string s, string t) {\\n         vector<int> a(26),b(26);\\n         int ans=0;\\n         for(int i=0;i<s.size();i++) a[s[i]-\\'a\\']++;\\n         for(int i=0;i<t.size();i++) b[t[i]-\\'a\\']++;\\n         for(int i=0;i<26;i++) ans+=abs(a[i]-b[i]);\\n         return ans;\\n    }\\n```\n```\\n       int ans=0;\\n        unordered_map<int,int> m;\\n        for(auto i:s) m[i]++;\\n        for(auto i:t) m[i]--;\\n        for(auto i:m) ans+=abs(i.second);\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802593,
                "title": "cpp-short-and-consize-solution",
                "content": "```\\nint minSteps(string s, string t) {\\n        int ans=0;\\n        vector<int> v(26);\\n        for(char c:s)v[c-\\'a\\']++;\\n        for(char c:t)v[c-\\'a\\']--;\\n        for(int i=0;i<26;i++)ans+=abs(v[i]);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nint minSteps(string s, string t) {\\n        int ans=0;\\n        vector<int> v(26);\\n        for(char c:s)v[c-\\'a\\']++;\\n        for(char c:t)v[c-\\'a\\']--;\\n        for(int i=0;i<26;i++)ans+=abs(v[i]);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802542,
                "title": "c-easy-hash-map-easy-understanding-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n    \\n       int mps[26] = {0}; \\n        int mpt[26] = {0}; \\n        for(int i = 0 ; i< s.length(); i++)\\n        {\\n            mps[s[i] - \\'a\\']++; \\n        }\\n        for(int i =0; i<t.length(); i++)\\n        {\\n            mpt[t[i] -\\'a\\']++; \\n        }\\n        \\n        int count = 0; \\n        for(int i = 0; i<26; i++)\\n        {\\n            count += (abs(mps[i] - mpt[i])); \\n        }\\n        return count; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n    \\n       int mps[26] = {0}; \\n        int mpt[26] = {0}; \\n        for(int i = 0 ; i< s.length(); i++)\\n        {\\n            mps[s[i] - \\'a\\']++; \\n        }\\n        for(int i =0; i<t.length(); i++)\\n        {\\n            mpt[t[i] -\\'a\\']++; \\n        }\\n        \\n        int count = 0; \\n        for(int i = 0; i<26; i++)\\n        {\\n            count += (abs(mps[i] - mpt[i])); \\n        }\\n        return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802503,
                "title": "c-solution-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int  n = s.length(), m = t.length();\\n            \\n            int a[26]={0}, b[26]={0};\\n            int ans = 0;\\n            for(auto it : s)a[it-\\'a\\']++;\\n            for(auto it : t)b[it-\\'a\\']++;\\n            for(int i = 0; i < 26; i++){\\n               ans +=(abs(a[i]-b[i]));\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int  n = s.length(), m = t.length();\\n            \\n            int a[26]={0}, b[26]={0};\\n            int ans = 0;\\n            for(auto it : s)a[it-\\'a\\']++;\\n            for(auto it : t)b[it-\\'a\\']++;\\n            for(int i = 0; i < 26; i++){\\n               ans +=(abs(a[i]-b[i]));\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802464,
                "title": "python3-best-solution",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        c1,c2=Counter(s),Counter(t)\\n        c=(c1-c2)+(c2-c1)\\n        k=0\\n        for i in c:\\n            k=k+c[i]\\n        return (k)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        c1,c2=Counter(s),Counter(t)\\n        c=(c1-c2)+(c2-c1)\\n        k=0\\n        for i in c:\\n            k=k+c[i]\\n        return (k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054818,
                "title": "easy-simple",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] freq=new int[256];\\n        for(int i=0; i<s.length(); i++){\\n            freq[s.charAt(i)]++;\\n        }\\n        for(int i=0; i<t.length(); i++){\\n            freq[t.charAt(i)]--;\\n        }\\n        int count=0;\\n        for(int i=0; i<256; i++){\\n            count+=Math.abs(freq[i]);\\n        }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] freq=new int[256];\\n        for(int i=0; i<s.length(); i++){\\n            freq[s.charAt(i)]++;\\n        }\\n        for(int i=0; i<t.length(); i++){\\n            freq[t.charAt(i)]--;\\n        }\\n        int count=0;\\n        for(int i=0; i<256; i++){\\n            count+=Math.abs(freq[i]);\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010254,
                "title": "c-check-out-this-simple-and-clean-solution-beats-96",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> map (26, 0);\\n        int cnt = 0;\\n        for (char ch: s) {map[ch-\\'a\\']++; cnt++;}\\n        for (char ch: t) {\\n            if (map[ch-\\'a\\'] > 0) {map[ch-\\'a\\']--; cnt--;}\\n            else cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> map (26, 0);\\n        int cnt = 0;\\n        for (char ch: s) {map[ch-\\'a\\']++; cnt++;}\\n        for (char ch: t) {\\n            if (map[ch-\\'a\\'] > 0) {map[ch-\\'a\\']--; cnt--;}\\n            else cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592126,
                "title": "use-of-map-o-distinct-elements-in-s-distinct-elements-in-t-beginner-friendly-approach-c",
                "content": "- Approach\\n          Firstly, I create two unordered map(m,n) and declare cnt variable and store those characters in s into m map and store those characters in t into n map.\\n          Now, I firstly traverse m map and I check those elements which is present in both map and add difference of those both maps of that character into cnt variable and if that character is not  present in n map then I add simply frequency in cnt variable.\\n          After traversing of m map I traverse n map and now I add frequency of n map of that character which is not present in m map I mean those character which is present only in n map.\\n          Now, I simply return cnt varible.\\n\\n# Complexity\\n- **Time complexity: O(distinct elements in s * distinct elements in t)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity: O(distinct elements in s) + O( * distinct elements in t)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> m,n;\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int j=0;j<t.size();j++)\\n        {\\n            n[t[j]]++;\\n        }\\n        for(auto i : m)\\n        {\\n            if(n[i.first]>0)\\n            {\\n                cnt+=(max(m[i.first],n[i.first])-min(m[i.first],n[i.first]));\\n            }\\n            else{\\n                cnt+=m[i.first];\\n            }\\n        }\\n        for(auto i : n)\\n        {\\n            if(m[i.first]==0)\\n            {\\n                cnt+=n[i.first];\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/565e0f2e-4580-4df7-b629-605123069755_1685778566.6075146.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> m,n;\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int j=0;j<t.size();j++)\\n        {\\n            n[t[j]]++;\\n        }\\n        for(auto i : m)\\n        {\\n            if(n[i.first]>0)\\n            {\\n                cnt+=(max(m[i.first],n[i.first])-min(m[i.first],n[i.first]));\\n            }\\n            else{\\n                cnt+=m[i.first];\\n            }\\n        }\\n        for(auto i : n)\\n        {\\n            if(m[i.first]==0)\\n            {\\n                cnt+=n[i.first];\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562633,
                "title": "c-easy-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int ans = 0;\\n        unordered_map<char, int> mp1;\\n        unordered_map<char, int> mp2;\\n        for(int i=0;i<s.length();i++){\\n            mp1[s[i]]++;\\n        }\\n        for(int i=0;i<t.length();i++){\\n            mp2[t[i]]++;\\n        }\\n\\n        for(auto i:mp1){\\n            if(mp2.find(i.first) == mp2.end()){\\n                ans += i.second;\\n            }\\n            else if(mp2[i.first] != i.second){\\n                ans += abs(mp2[i.first] - i.second);\\n                mp2.erase(i.first);\\n            }\\nelse{\\n    mp2.erase(i.first);\\n}\\n        }\\n        for(auto i:mp2){\\n            if(mp1.find(i.first) == mp1.end()){\\n                ans += i.second;\\n            }\\n            else if(mp1[i.first] != i.second){\\n                ans += abs(mp1[i.first] - i.second);\\n                mp1.erase(i.first);\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int ans = 0;\\n        unordered_map<char, int> mp1;\\n        unordered_map<char, int> mp2;\\n        for(int i=0;i<s.length();i++){\\n            mp1[s[i]]++;\\n        }\\n        for(int i=0;i<t.length();i++){\\n            mp2[t[i]]++;\\n        }\\n\\n        for(auto i:mp1){\\n            if(mp2.find(i.first) == mp2.end()){\\n                ans += i.second;\\n            }\\n            else if(mp2[i.first] != i.second){\\n                ans += abs(mp2[i.first] - i.second);\\n                mp2.erase(i.first);\\n            }\\nelse{\\n    mp2.erase(i.first);\\n}\\n        }\\n        for(auto i:mp2){\\n            if(mp1.find(i.first) == mp1.end()){\\n                ans += i.second;\\n            }\\n            else if(mp1[i.first] != i.second){\\n                ans += abs(mp1[i.first] - i.second);\\n                mp1.erase(i.first);\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065001,
                "title": "c-easy-and-short-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int ans=0;\\n        map<char,int>mp1,mp2,temp1,temp2;\\n        for(int i=0;i<s.size();i++){\\n            mp1[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++){\\n            mp2[t[i]]++;\\n        }\\n        set<char>st;\\n        for(auto it:s)\\n        st.insert(it);\\n         for(auto it:t)\\n        st.insert(it);\\n        \\n        vector<char>v(st.begin(),st.end());\\n        for(int i=0;i<v.size();i++){\\n            ans+=abs(mp1[v[i]]-mp2[v[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int ans=0;\\n        map<char,int>mp1,mp2,temp1,temp2;\\n        for(int i=0;i<s.size();i++){\\n            mp1[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++){\\n            mp2[t[i]]++;\\n        }\\n        set<char>st;\\n        for(auto it:s)\\n        st.insert(it);\\n         for(auto it:t)\\n        st.insert(it);\\n        \\n        vector<char>v(st.begin(),st.end());\\n        for(int i=0;i<v.size();i++){\\n            ans+=abs(mp1[v[i]]-mp2[v[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996689,
                "title": "cpp-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing maps we can solve the problem easily\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int>m,m1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int i=0;i<t.length();i++)\\n        {\\n            m1[t[i]]++;\\n        }\\n        for(int i=0;i<t.length();i++)\\n        {\\n            if(m.find(t[i])!=m.end())\\n            {\\n                m[t[i]]--;\\n                if(m[t[i]]==0)\\n                {\\n                    m.erase(t[i]);\\n                }\\n            }\\n        }\\n        int ans=0,ans1=0;\\n         for(auto it:m)\\n        {\\n            ans+=it.second;\\n        }\\n        cout<<ans<<\" \";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(m1.find(s[i])!=m1.end())\\n            {\\n                m1[s[i]]--;\\n                if(m1[s[i]]==0)\\n                {\\n                    m1.erase(s[i]);\\n                }\\n            }\\n        }\\n        //if(m.size()==0)return 0;\\n        \\n        for(auto it:m1)\\n        {\\n            ans1+=it.second;\\n        }\\n        ans+=ans1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int>m,m1;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int i=0;i<t.length();i++)\\n        {\\n            m1[t[i]]++;\\n        }\\n        for(int i=0;i<t.length();i++)\\n        {\\n            if(m.find(t[i])!=m.end())\\n            {\\n                m[t[i]]--;\\n                if(m[t[i]]==0)\\n                {\\n                    m.erase(t[i]);\\n                }\\n            }\\n        }\\n        int ans=0,ans1=0;\\n         for(auto it:m)\\n        {\\n            ans+=it.second;\\n        }\\n        cout<<ans<<\" \";\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(m1.find(s[i])!=m1.end())\\n            {\\n                m1[s[i]]--;\\n                if(m1[s[i]]==0)\\n                {\\n                    m1.erase(s[i]);\\n                }\\n            }\\n        }\\n        //if(m.size()==0)return 0;\\n        \\n        for(auto it:m1)\\n        {\\n            ans1+=it.second;\\n        }\\n        ans+=ans1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2642786,
                "title": "c-very-easy-soln-hashmap",
                "content": "```\\n//TC -> O(max(len(s),len(t)))\\nint minSteps(string s, string t) {\\n        int ans = 0;\\n        unordered_map<char,int> m;\\n\\t\\t//Just map all the characters\\n        for(auto i:s) m[i]++;\\n        for(auto i:t) m[i]--;\\n\\t\\t//Retrieve the absolute value stored in the mapping\\n        for(auto j:m){\\n            ans+=abs(j.second);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//TC -> O(max(len(s),len(t)))\\nint minSteps(string s, string t) {\\n        int ans = 0;\\n        unordered_map<char,int> m;\\n\\t\\t//Just map all the characters\\n        for(auto i:s) m[i]++;\\n        for(auto i:t) m[i]--;\\n\\t\\t//Retrieve the absolute value stored in the mapping\\n        for(auto j:m){\\n            ans+=abs(j.second);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2626910,
                "title": "c-hash-table-o-max-len-s-len-t-easy-and-fastest",
                "content": "```\\nint minSteps(string s, string t) {\\n        int steps=0;\\n        vector<int>v(26,0);\\n        for(int i=0;i<size(s);i++){\\n            v[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<size(t);i++){\\n            v[t[i]-\\'a\\']--;\\n        }\\n        for(int i=0;i<size(v);i++){\\n            steps+=abs(v[i]);\\n        }\\n        return steps;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nint minSteps(string s, string t) {\\n        int steps=0;\\n        vector<int>v(26,0);\\n        for(int i=0;i<size(s);i++){\\n            v[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<size(t);i++){\\n            v[t[i]-\\'a\\']--;\\n        }\\n        for(int i=0;i<size(v);i++){\\n            steps+=abs(v[i]);\\n        }\\n        return steps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2563601,
                "title": "simplest-solution-using-hashmap-o-n",
                "content": "**PLEASE UPVOTE \\nIF YOU FIND THIS HELPFUL**\\n\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n       unordered_map<char,pair<int,int>> hash;\\n        int count=0;\\n        for(auto i:s)\\n            hash[i].first++;\\n        for(auto i:t)\\n            hash[i].second++;\\n        for(auto it:hash)\\n            count+=abs(it.second.second-it.second.first);\\n            return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n       unordered_map<char,pair<int,int>> hash;\\n        int count=0;\\n        for(auto i:s)\\n            hash[i].first++;\\n        for(auto i:t)\\n            hash[i].second++;\\n        for(auto it:hash)\\n            count+=abs(it.second.second-it.second.first);\\n            return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543370,
                "title": "c-simple-o-n-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        int n=s.length();\\n        int m=t.length();\\n        for(int i=0;i<n;i++){\\n            v1[s[i]-97]++;\\n        }\\n        for(int i=0;i<m;i++){\\n            v2[t[i]-97]++;\\n        }\\n        int commonchar=0;\\n        for(int i=0;i<26;i++){\\n            commonchar+=min(v1[i],v2[i]);\\n        }\\n        return (n+m)-2*commonchar;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        int n=s.length();\\n        int m=t.length();\\n        for(int i=0;i<n;i++){\\n            v1[s[i]-97]++;\\n        }\\n        for(int i=0;i<m;i++){\\n            v2[t[i]-97]++;\\n        }\\n        int commonchar=0;\\n        for(int i=0;i<26;i++){\\n            commonchar+=min(v1[i],v2[i]);\\n        }\\n        return (n+m)-2*commonchar;\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519197,
                "title": "python-2-liner-faster-than-95",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        ctrS, ctrT = Counter(s), Counter(t)\\n        return sum((ctrS - ctrT).values()) + sum((ctrT - ctrS).values())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        ctrS, ctrT = Counter(s), Counter(t)\\n        return sum((ctrS - ctrT).values()) + sum((ctrT - ctrS).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514404,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n     int[] sCharCount = new int[26];\\n     int[] tCharCount = new int[26];\\n     for(int i = 0; i < s.length(); i++) {\\n         sCharCount[s.charAt(i) - \\'a\\']+=1;\\n     } \\n     for(int i = 0; i < t.length(); i++) {\\n         tCharCount[t.charAt(i) - \\'a\\']+=1;\\n     }  \\n\\n        int count = 0;\\n     for(int i = 0; i < 26; i++) {\\n         count+=Math.abs(tCharCount[i]-sCharCount[i]);\\n     }   \\n        return count; \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minSteps(String s, String t) {\\n     int[] sCharCount = new int[26];\\n     int[] tCharCount = new int[26];\\n     for(int i = 0; i < s.length(); i++) {\\n         sCharCount[s.charAt(i) - \\'a\\']+=1;\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 2458230,
                "title": "c-accepted-best-approach-with-good-explanation-easy-to-understand",
                "content": "**Read the below approach to understand the logic.**\\n\\n***Please upvote if you like it!!***\\n\\n**Approach:**\\n1. Take a unordered map.\\n2. Take a loop for first string and increment by 1 for each character specific in map\\n3. Similarly take a loop for second string and decrement by 1 for each character specific in map.\\n4. At last return absolute count of all char in mp.\\n\\n**~Time Complexity: O(s.size())+O(t.size())+O(K) k=total no. of char used in string**\\n\\n**~Space Complexity: O(K) k=total no. of char used in string**\\n* **Reason:** we are using unordered map.\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++){\\n            mp[t[i]]--;\\n        }\\n        int count=0;\\n        for(auto x: mp){\\n            count+=abs(x.second);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<s.size();i++){\\n            mp[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++){\\n            mp[t[i]]--;\\n        }\\n        int count=0;\\n        for(auto x: mp){\\n            count+=abs(x.second);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2242933,
                "title": "java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character,Integer> hmap = new HashMap<>();\\n        for(char ch:s.toCharArray()) \\n            hmap.put(ch,hmap.getOrDefault(ch,0)+1);\\n        for(char ch:t.toCharArray())\\n            hmap.put(ch,hmap.getOrDefault(ch,0)-1);\\n        int count=0;\\n        for(char key:hmap.keySet())\\n            if(hmap.get(key)!=0)\\n                count+=(Math.abs(hmap.get(key)));\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character,Integer> hmap = new HashMap<>();\\n        for(char ch:s.toCharArray()) \\n            hmap.put(ch,hmap.getOrDefault(ch,0)+1);\\n        for(char ch:t.toCharArray())\\n            hmap.put(ch,hmap.getOrDefault(ch,0)-1);\\n        int count=0;\\n        for(char key:hmap.keySet())\\n            if(hmap.get(key)!=0)\\n                count+=(Math.abs(hmap.get(key)));\\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2219319,
                "title": "very-easy-solution",
                "content": "```\\n int minSteps(string s, string t) {\\n        \\n       vector<int>freq(26,0),freq1(26,0);\\n        \\n        for(auto x : s) freq[x-\\'a\\']++;\\n        \\n        for(auto x : t) freq[x-\\'a\\']--;\\n        \\n        \\n        for(auto x : t) freq1[x-\\'a\\']++;\\n        \\n        for(auto x : s) freq1[x-\\'a\\']--;\\n        \\n        int sum=0;\\n        \\n        for(auto x : freq) if(x>0) sum+=x;\\n        \\n        for(auto x : freq1) if(x>0) sum+=x;\\n        \\n        return sum;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n int minSteps(string s, string t) {\\n        \\n       vector<int>freq(26,0),freq1(26,0);\\n        \\n        for(auto x : s) freq[x-\\'a\\']++;\\n        \\n        for(auto x : t) freq[x-\\'a\\']--;\\n        \\n        \\n        for(auto x : t) freq1[x-\\'a\\']++;\\n        \\n        for(auto x : s) freq1[x-\\'a\\']--;\\n        \\n        int sum=0;\\n        \\n        for(auto x : freq) if(x>0) sum+=x;\\n        \\n        for(auto x : freq1) if(x>0) sum+=x;\\n        \\n        return sum;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2137921,
                "title": "python-counterrrrrr-2-liner",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        f,g=Counter(s),Counter(t)\\n        return sum(abs(g[i]-f[i]) for i in set(f.keys()).union(g.keys()))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        f,g=Counter(s),Counter(t)\\n        return sum(abs(g[i]-f[i]) for i in set(f.keys()).union(g.keys()))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2127187,
                "title": "java-solution-faster-than-100-easy-solution-without-hashmap",
                "content": "```\\nclass Solution {\\n\\n    public int minSteps(String s, String t) {\\n        int count[] = new int[26];\\n        for (char ch : s.toCharArray()) count[ch - \\'a\\']++;\\n        for (char ch : t.toCharArray()) count[ch - \\'a\\']--;\\n        int ans = 0;\\n        for (int i = 0; i < 26; i++) ans += Math.abs(count[i]);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int minSteps(String s, String t) {\\n        int count[] = new int[26];\\n        for (char ch : s.toCharArray()) count[ch - \\'a\\']++;\\n        for (char ch : t.toCharArray()) count[ch - \\'a\\']--;\\n        int ans = 0;\\n        for (int i = 0; i < 26; i++) ans += Math.abs(count[i]);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061604,
                "title": "java-solution-o-math-max-len-s-len-t",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int count[] = new int[26];\\n        int result = 0;\\n        int i = 0,j = 0;\\n        while( i < s.length() || j < t.length()){\\n            if(i < s.length()){\\n                count[s.charAt(i++) -\\'a\\']++;\\n            }\\n            if(j < t.length()){\\n                count[t.charAt(j++) - \\'a\\']--;\\n            }\\n        }\\n        for(i = 0; i < 26; i++){\\n            result += Math.abs(count[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int count[] = new int[26];\\n        int result = 0;\\n        int i = 0,j = 0;\\n        while( i < s.length() || j < t.length()){\\n            if(i < s.length()){\\n                count[s.charAt(i++) -\\'a\\']++;\\n            }\\n            if(j < t.length()){\\n                count[t.charAt(j++) - \\'a\\']--;\\n            }\\n        }\\n        for(i = 0; i < 26; i++){\\n            result += Math.abs(count[i]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988385,
                "title": "simple-counting-exactly-as-per-hints-c-java-and-python",
                "content": "**C++**\\n```\\nclass Solution {\\nprivate:\\n    int* getFreq(string s){\\n        int* count = new int[26];\\n        int i;\\n        \\n        for(char &ch : s){\\n            count[ch - \\'a\\']++;\\n        }\\n        \\n        return count;\\n    }\\n\\t\\npublic:\\n    int minSteps(string s, string t) {\\n        int* c1 = getFreq(s);\\n        int* c2 = getFreq(t);\\n        \\n        int total = 0;\\n        for(int i = 0; i < 26; i++){\\n            total += abs(c1[i] - c2[i]);\\n        }\\n        \\n        return total;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] c1 = getFreq(s);\\n        int[] c2 = getFreq(t);\\n        int total = 0;\\n        for(int i = 0; i < 26; i++){\\n            total += Math.abs(c1[i] - c2[i]);\\n        }\\n        \\n        return total;\\n    }\\n    \\n    private int[] getFreq(String s){\\n        int i, length = s.length();\\n        int[] count = new int[26];\\n        \\n        for(i = 0; i < length; i++){\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n\\n\\n**Python**\\n```\\nclass Solution(object):\\n    def getFreq(self, word):\\n        count = [0]*26\\n        \\n        for character in word:\\n            count[ord(character) - ord(\\'a\\')] += 1\\n        \\n        return count\\n    \\n    def minSteps(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: int\\n        \"\"\"\\n        c1 = self.getFreq(s)\\n        c2 = self.getFreq(t)\\n        total = 0\\n        \\n        for i in range(26):\\n            total += abs(c1[i] - c2[i])\\n    \\n        return total\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int* getFreq(string s){\\n        int* count = new int[26];\\n        int i;\\n        \\n        for(char &ch : s){\\n            count[ch - \\'a\\']++;\\n        }\\n        \\n        return count;\\n    }\\n\\t\\npublic:\\n    int minSteps(string s, string t) {\\n        int* c1 = getFreq(s);\\n        int* c2 = getFreq(t);\\n        \\n        int total = 0;\\n        for(int i = 0; i < 26; i++){\\n            total += abs(c1[i] - c2[i]);\\n        }\\n        \\n        return total;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] c1 = getFreq(s);\\n        int[] c2 = getFreq(t);\\n        int total = 0;\\n        for(int i = 0; i < 26; i++){\\n            total += Math.abs(c1[i] - c2[i]);\\n        }\\n        \\n        return total;\\n    }\\n    \\n    private int[] getFreq(String s){\\n        int i, length = s.length();\\n        int[] count = new int[26];\\n        \\n        for(i = 0; i < length; i++){\\n            count[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def getFreq(self, word):\\n        count = [0]*26\\n        \\n        for character in word:\\n            count[ord(character) - ord(\\'a\\')] += 1\\n        \\n        return count\\n    \\n    def minSteps(self, s, t):\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: int\\n        \"\"\"\\n        c1 = self.getFreq(s)\\n        c2 = self.getFreq(t)\\n        total = 0\\n        \\n        for i in range(26):\\n            total += abs(c1[i] - c2[i])\\n    \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968719,
                "title": "java-frequency-method-easy-90-beat",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] freqCount = new int[26];\\n        int answer = 0;\\n        for(char letter: s.toCharArray()) {\\n            freqCount[letter-\\'a\\']++;\\n        }\\n        for(char letter: t.toCharArray()) {\\n            freqCount[letter-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++) {\\n            if(freqCount[i] != 0) {\\n                answer += Math.abs(freqCount[i]);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] freqCount = new int[26];\\n        int answer = 0;\\n        for(char letter: s.toCharArray()) {\\n            freqCount[letter-\\'a\\']++;\\n        }\\n        for(char letter: t.toCharArray()) {\\n            freqCount[letter-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++) {\\n            if(freqCount[i] != 0) {\\n                answer += Math.abs(freqCount[i]);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841302,
                "title": "python-very-easy-solution-using-counter",
                "content": "# if you like the solution, Please upvote!!\\n\\tclass Solution:\\n\\t\\tdef minSteps(self, s: str, t: str) -> int:\\n\\t\\t\\tcommon = Counter(s) & Counter(t)\\n\\t\\t\\tcount = sum(common.values())\\n\\n\\t\\t\\treturn (len(s) - count) + (len(t) - count) \\n\\t\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# if you like the solution, Please upvote!!\\n\\tclass Solution:\\n\\t\\tdef minSteps(self, s: str, t: str) -> int:\\n\\t\\t\\tcommon = Counter(s) & Counter(t)\\n\\t\\t\\tcount = sum(common.values())\\n\\n\\t\\t\\treturn (len(s) - count) + (len(t) - count) \\n\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1836256,
                "title": "best-easiest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> v(26,0);\\n        for(char i: s) \\n            v[i-\\'a\\']++;\\n        for(char i: t) \\n            v[i-\\'a\\']--;\\n        \\n        int count=0;\\n        for(int i=0; i<26; i++)\\n            count+=abs(v[i]);\\n        return count;\\n    }\\n};\\n\\n//pls upvote if u find the solution helpful....!! Thanks..!!\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> v(26,0);\\n        for(char i: s) \\n            v[i-\\'a\\']++;\\n        for(char i: t) \\n            v[i-\\'a\\']--;\\n        \\n        int count=0;\\n        for(int i=0; i<26; i++)\\n            count+=abs(v[i]);\\n        return count;\\n    }\\n};\\n\\n//pls upvote if u find the solution helpful....!! Thanks..!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819613,
                "title": "c-frequency-array-easy-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int count=0;\\n        vector<int> sf(26,0);\\n        vector<int> tf(26,0);\\n        for(auto it:s)\\n            sf[it-\\'a\\']++; // count the freq of characters in s.\\n        for(auto it:t)\\n            tf[it-\\'a\\']++; // count the freq of characters in s.\\n        for(int i=0;i<26;i++){\\n            count+=abs(sf[i]-tf[i]); \\n            \\n            /* minimum count will be the total difference of frequency present in either of string\\n            eg in \"arjun\" & \"aryan\" or the same elements will cancel out each other and rest all will\\n            be returned.\\n            */\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int count=0;\\n        vector<int> sf(26,0);\\n        vector<int> tf(26,0);\\n        for(auto it:s)\\n            sf[it-\\'a\\']++; // count the freq of characters in s.\\n        for(auto it:t)\\n            tf[it-\\'a\\']++; // count the freq of characters in s.\\n        for(int i=0;i<26;i++){\\n            count+=abs(sf[i]-tf[i]); \\n            \\n            /* minimum count will be the total difference of frequency present in either of string\\n            eg in \"arjun\" & \"aryan\" or the same elements will cancel out each other and rest all will\\n            be returned.\\n            */\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816932,
                "title": "c-easiest-implementation",
                "content": "```\\nint minSteps(string s, string t) \\n    {\\n        unordered_map<int, int> mp;\\n        for(auto ch:s)\\n            mp[ch]++;\\n        for(auto ch:t)\\n            mp[ch]--;\\n        int res=0;\\n        for(auto it:mp)\\n            res+=abs(it.second);\\n        return res;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minSteps(string s, string t) \\n    {\\n        unordered_map<int, int> mp;\\n        for(auto ch:s)\\n            mp[ch]++;\\n        for(auto ch:t)\\n            mp[ch]--;\\n        int res=0;\\n        for(auto it:mp)\\n            res+=abs(it.second);\\n        return res;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1816817,
                "title": "c-hashmap-solution-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        \\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        \\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n            v1[s[i]-\\'a\\']++;\\n            \\n        }\\n        \\n        for(int i=0;i<t.size();i++){\\n            v2[t[i]-\\'a\\']++;\\n            \\n        }\\n        \\n        \\n        \\n        int count_1 =0 ;\\n        int count_2 = 0;\\n        \\n        \\n        unordered_map<char,int> m1;\\n        \\n        for(int i=0;i<t.size();i++){\\n           \\n            if(m1[t[i]]==0){\\n               \\n               int diff = (v2[t[i]-\\'a\\'] - v1[t[i]-\\'a\\']); \\n               if(diff<0) continue; \\n               count_1 += diff;\\n                \\n              \\n               v1[t[i]-\\'a\\'] += diff; \\n              \\n               \\n               m1[t[i]]++; \\n            }\\n            \\n        }\\n        \\n        \\n       \\n        unordered_map<char,int> m2;\\n        for(int i=0;i<s.size();i++){\\n            if(m2[s[i]]==0){\\n                count_2 += (v1[s[i]-\\'a\\'] - v2[s[i]-\\'a\\']);\\n                m2[s[i]]++;\\n            }\\n            \\n        }\\n        \\n\\n           \\n\\n        \\n        return count_1 + count_2;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        \\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        \\n        \\n        for(int i=0;i<s.size();i++){\\n            \\n            v1[s[i]-\\'a\\']++;\\n            \\n        }\\n        \\n        for(int i=0;i<t.size();i++){\\n            v2[t[i]-\\'a\\']++;\\n            \\n        }\\n        \\n        \\n        \\n        int count_1 =0 ;\\n        int count_2 = 0;\\n        \\n        \\n        unordered_map<char,int> m1;\\n        \\n        for(int i=0;i<t.size();i++){\\n           \\n            if(m1[t[i]]==0){\\n               \\n               int diff = (v2[t[i]-\\'a\\'] - v1[t[i]-\\'a\\']); \\n               if(diff<0) continue; \\n               count_1 += diff;\\n                \\n              \\n               v1[t[i]-\\'a\\'] += diff; \\n              \\n               \\n               m1[t[i]]++; \\n            }\\n            \\n        }\\n        \\n        \\n       \\n        unordered_map<char,int> m2;\\n        for(int i=0;i<s.size();i++){\\n            if(m2[s[i]]==0){\\n                count_2 += (v1[s[i]-\\'a\\'] - v2[s[i]-\\'a\\']);\\n                m2[s[i]]++;\\n            }\\n            \\n        }\\n        \\n\\n           \\n\\n        \\n        return count_1 + count_2;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816320,
                "title": "c-hashmap",
                "content": "```\\nint minSteps(string s, string t) {\\n        vector<int>hash1(26, 0), hash2(26,0);\\n        for(int i=0; i<s.size(); i++){\\n            hash1[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0; i<t.size(); i++){\\n            hash2[t[i]-\\'a\\']++;\\n        }\\n        int ans = 0;\\n        for(int i=0; i<26; i++){\\n            ans += abs(hash1[i]-hash2[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minSteps(string s, string t) {\\n        vector<int>hash1(26, 0), hash2(26,0);\\n        for(int i=0; i<s.size(); i++){\\n            hash1[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0; i<t.size(); i++){\\n            hash2[t[i]-\\'a\\']++;\\n        }\\n        int ans = 0;\\n        for(int i=0; i<26; i++){\\n            ans += abs(hash1[i]-hash2[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1814340,
                "title": "javascript-easy-to-understand-detailed-explanation-and-optimization",
                "content": "## CORE STRATEGY\\n\\nFirst, according to the description of the problem, an anagram could be in any order. This is a key point, which means we just need to care about the frequency of char.\\n\\nThen, let\\'s have these variables:\\n- let the same part between `s` and `t` be `same`\\n- let the special chars of `s` be `diffS`\\n- let the special chars of `t` be `diffT`\\n- let the final shortest anagram be `target`\\n\\nSo, we could have:\\n- `s = diffS + same`\\n- `t = diffT + same`\\n- `target = same + diffS + diffT`\\n\\nFinally, for what we need `(target - s) + (target - t)`, it\\'s `((same + diffS + diffT) - (diffS + same)) + ((same + diffS + diffT) - (diffT + same)) = diffT + diffS = (t - same) + (s - same) = t + s - 2 * same`, which means we only need to find the length of same chars in `s` and `t`.\\n\\nAbout how to do the counting of char frequency, try hashtable. You can do it! :P\\n\\n## SOLUTION\\n\\nHere\\'s a sample code from me (244ms):\\n\\n```js\\nconst minSteps = (s, t) => {\\n  const freq = {};\\n  let bothHave = 0;\\n\\n  for (const c of s) {\\n    freq[c] = (freq[c] || 0) + 1;\\n  }\\n  for (const c of t) {\\n    if (!freq[c]) continue;\\n    --freq[c];\\n    ++bothHave;\\n  }\\n\\n  return s.length + t.length - bothHave * 2;\\n};\\n```\\n\\n## OPTIMIZATION\\n\\nHere could be an optimization. Since what we need to deal with are only lowercase English letters, so we don\\'t really need a real hashtable, we could use a fixed-length uint array to make it faster.\\n\\nHere\\'s a sample code from me (84ms):\\n\\n```js\\nconst minSteps = (s, t) => {\\n  const freq = new Uint16Array(26);\\n  const BASE_CODE = 97;\\n  let bothHave = 0;\\n\\n  for (let i = 0; i < s.length; ++i) {\\n    ++freq[s.charCodeAt(i) - BASE_CODE];\\n  }\\n  for (let i = 0; i < t.length; ++i) {\\n    const code = t.charCodeAt(i) - BASE_CODE;\\n    freq[code] && ++bothHave && --freq[code];\\n  }\\n\\n  return s.length + t.length - (bothHave << 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst minSteps = (s, t) => {\\n  const freq = {};\\n  let bothHave = 0;\\n\\n  for (const c of s) {\\n    freq[c] = (freq[c] || 0) + 1;\\n  }\\n  for (const c of t) {\\n    if (!freq[c]) continue;\\n    --freq[c];\\n    ++bothHave;\\n  }\\n\\n  return s.length + t.length - bothHave * 2;\\n};\\n```\n```js\\nconst minSteps = (s, t) => {\\n  const freq = new Uint16Array(26);\\n  const BASE_CODE = 97;\\n  let bothHave = 0;\\n\\n  for (let i = 0; i < s.length; ++i) {\\n    ++freq[s.charCodeAt(i) - BASE_CODE];\\n  }\\n  for (let i = 0; i < t.length; ++i) {\\n    const code = t.charCodeAt(i) - BASE_CODE;\\n    freq[code] && ++bothHave && --freq[code];\\n  }\\n\\n  return s.length + t.length - (bothHave << 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1809756,
                "title": "hashmap-optimised-solution-clean-and-easy-to-understand",
                "content": "```\\ndef minSteps(self, s: str, t: str) -> int:\\n        s_dict = {}\\n        t_dict = {}\\n\\n        for i in s:\\n            if i not in s_dict:\\n                s_dict[i] = 0\\n            s_dict[i] += 1\\n\\n        for i in t:\\n            if i not in t_dict:\\n                t_dict[i] = 0\\n            t_dict[i] += 1\\n\\n        common = 0\\n        for i in s_dict:\\n            if i in t_dict:\\n                common += min(s_dict[i], t_dict[i])\\n\\n        return len(s)+len(t) - 2 * common\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minSteps(self, s: str, t: str) -> int:\\n        s_dict = {}\\n        t_dict = {}\\n\\n        for i in s:\\n            if i not in s_dict:\\n                s_dict[i] = 0\\n            s_dict[i] += 1\\n\\n        for i in t:\\n            if i not in t_dict:\\n                t_dict[i] = 0\\n            t_dict[i] += 1\\n\\n        common = 0\\n        for i in s_dict:\\n            if i in t_dict:\\n                common += min(s_dict[i], t_dict[i])\\n\\n        return len(s)+len(t) - 2 * common\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1809502,
                "title": "simple-c-solution-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char , int>mp;\\n        \\n        for(int i = 0 ; i < s.size() ; i++){\\n            mp[s[i]]++;\\n        }\\n        \\n        for(int i = 0 ; i < t.size() ; i++){\\n            mp[t[i]]--;\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(auto value : mp){\\n            if(value.second != 0){\\n                ans += abs(value.second);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char , int>mp;\\n        \\n        for(int i = 0 ; i < s.size() ; i++){\\n            mp[s[i]]++;\\n        }\\n        \\n        for(int i = 0 ; i < t.size() ; i++){\\n            mp[t[i]]--;\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(auto value : mp){\\n            if(value.second != 0){\\n                ans += abs(value.second);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806664,
                "title": "easy-solution",
                "content": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n     int freq[26]={0};\\n        for(char &c:s)\\n            freq[c-\\'a\\']++;\\n        for(char &d:t)\\n            freq[d-\\'a\\']--;\\n        int ans=0;\\n        for(int i:freq)\\n            ans+=abs(i);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n     int freq[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 1804941,
                "title": "java-using-frequency-array-counter-o-length-s-o-length-t",
                "content": "```\\nclass Solution {\\n\\n    public int minSteps(String s, String t) {\\n        int freq[] = new int[26];\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            freq[ch - \\'a\\']++;\\n        }\\n        for (int i = 0; i < t.length(); i++) {\\n            char ch = t.charAt(i);\\n            freq[ch - \\'a\\']--;\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < 26; i++) {\\n            count += Math.abs(freq[i]);\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int minSteps(String s, String t) {\\n        int freq[] = new int[26];\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            freq[ch - \\'a\\']++;\\n        }\\n        for (int i = 0; i < t.length(); i++) {\\n            char ch = t.charAt(i);\\n            freq[ch - \\'a\\']--;\\n        }\\n\\n        int count = 0;\\n        for (int i = 0; i < 26; i++) {\\n            count += Math.abs(freq[i]);\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804933,
                "title": "python-easy-solution-hashmap-o-n",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        hashS = {}\\n        hashT = {}\\n        count = 0\\n        \\n        for i in s:\\n            if i in hashS:\\n                hashS[i] += 1\\n            else:\\n                hashS[i] = 1\\n            \\n        for i in t:\\n            if i in hashT:\\n                hashT[i] += 1\\n            else:\\n                hashT[i] = 1\\n        \\n        for ind, val in hashT.items():\\n            if ind in hashS:\\n                if val == hashS[ind]:\\n                    hashS[ind] = 0\\n                    continue\\n                else:\\n                    count += abs(val-hashS[ind])\\n                    hashS[ind] = 0   \\n            else:\\n                count += val\\n        \\n        \\n        for val in hashS.values():\\n            count += val\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        hashS = {}\\n        hashT = {}\\n        count = 0\\n        \\n        for i in s:\\n            if i in hashS:\\n                hashS[i] += 1\\n            else:\\n                hashS[i] = 1\\n            \\n        for i in t:\\n            if i in hashT:\\n                hashT[i] += 1\\n            else:\\n                hashT[i] = 1\\n        \\n        for ind, val in hashT.items():\\n            if ind in hashS:\\n                if val == hashS[ind]:\\n                    hashS[ind] = 0\\n                    continue\\n                else:\\n                    count += abs(val-hashS[ind])\\n                    hashS[ind] = 0   \\n            else:\\n                count += val\\n        \\n        \\n        for val in hashS.values():\\n            count += val\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804915,
                "title": "c-easy-understanding-o-n",
                "content": "**class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        int freq[26]={0};\\n        \\n        for(auto it : s)// add the count of characters of s in freq\\n            freq[it-\\'a\\']++;\\n        \\n        for(auto it: t)// delete the count of characters of t in freq\\n            freq[it-\\'a\\']--;\\n        \\n        int c=0;\\n        // now count the remaining characters in freq which is needed \\n        // to make both strings anagram\\n        for(int i=0; i<26; i++)\\n            c+= abs(freq[i]);\\n        \\n        return c;\\n    }\\n};**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        int freq[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 1804610,
                "title": "c-o-n-100-faster-solution",
                "content": "class Solution {\\npublic:\\n\\n    int minSteps(string s, string t) {\\n        int sa[26]={0};\\n        int ta[26]={0};\\n      \\n        for(int i=0;i<s.length();i++)\\n            sa[s[i]-\\'a\\']++;\\n        for(int i=0;i<t.length();i++)\\n            ta[t[i]-\\'a\\']++;\\n        \\n        int count=0;\\n        for(int i=0;i<26;i++){\\n            count+=abs(sa[i]-ta[i]);\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int minSteps(string s, string t) {\\n        int sa[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 1804377,
                "title": "using-hashmap-java-solution-o-n-tc",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n     int l1=s.length();\\n        int l2=t.length();\\n        int c1=0;\\n        int c2=0;\\n    Map<Character,Integer> map1=new HashMap<>();\\n        Map<Character,Integer> map2=new HashMap<>();\\n        for(int i=0;i<s.length();i++){   //storing the characters\\n            map1.put(s.charAt(i),map1.getOrDefault(s.charAt(i),0)+1);\\n        }\\n         for(int i=0;i<t.length();i++){\\n            map2.put(t.charAt(i),map2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n        \\n        for(int i=0;i<t.length();i++){\\n            if(map1.containsKey(t.charAt(i)) && map1.get(t.charAt(i))>0){\\n                map1.put(t.charAt(i),map1.get(t.charAt(i))-1);  //checking if exists then reducing the count by 1\\n                c1++;\\n            }\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(map2.containsKey(s.charAt(i)) && map2.get(s.charAt(i))>0){\\n                map2.put(s.charAt(i),map2.get(s.charAt(i))-1);\\n            c2++;\\n            }\\n        }\\n        \\n        return s.length()+t.length()-c1-c2; \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minSteps(String s, String t) {\\n     int l1=s.length();\\n        int l2=t.length();\\n        int c1=0;\\n        int c2=0;\\n    Map<Character,Integer> map1=new HashMap<>();\\n        Map<Character,Integer> map2=new HashMap<>();\\n        for(int i=0;i<s.length();i++){   //storing the characters\\n            map1.put(s.charAt(i),map1.getOrDefault(s.charAt(i),0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1804026,
                "title": "easy-to-understand-using-map-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n\\t\\t// increase the frequency of character in s string\\n        for(int i=0;i<s.size();i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n\\t\\t// decrease the frequency of character in t string\\n        for(int j=0;j<t.size();j++)\\n        {\\n            mp[t[j]]--;\\n        }\\n\\t\\t// now if the frequency of a particular element in map is zero then it need no appending \\n\\t\\t// if it is not equal to zero then we will just add abs of that frequency\\n        int res = 0;\\n        for(auto x:mp)\\n        {\\n            if(x.second != 0) res+=abs(x.second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n\\t\\t// increase the frequency of character in s string\\n        for(int i=0;i<s.size();i++)\\n        {\\n            mp[s[i]]++;\\n        }\\n\\t\\t// decrease the frequency of character in t string\\n        for(int j=0;j<t.size();j++)\\n        {\\n            mp[t[j]]--;\\n        }\\n\\t\\t// now if the frequency of a particular element in map is zero then it need no appending \\n\\t\\t// if it is not equal to zero then we will just add abs of that frequency\\n        int res = 0;\\n        for(auto x:mp)\\n        {\\n            if(x.second != 0) res+=abs(x.second);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803967,
                "title": "c-frequency-array-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) \\n    {\\n        int n1,n2,i,j,ans=0;\\n        n1=s.size();\\n        n2=t.size();\\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        for(i=0;i<n1;i++) //making a frequency array for string s\\n        {\\n            v1[s[i]-\\'a\\']++;\\n        }\\n        for(i=0;i<n2;i++)//making a frequency array for string t\\n        {\\n            v2[t[i]-\\'a\\']++;\\n        }\\n        for(i=0;i<26;i++)//checking the difference between the two frequency arrays\\n        {\\n            ans=ans+abs(v1[i]-v2[i]); //keeping check of the total of absolute difference\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) \\n    {\\n        int n1,n2,i,j,ans=0;\\n        n1=s.size();\\n        n2=t.size();\\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        for(i=0;i<n1;i++) //making a frequency array for string s\\n        {\\n            v1[s[i]-\\'a\\']++;\\n        }\\n        for(i=0;i<n2;i++)//making a frequency array for string t\\n        {\\n            v2[t[i]-\\'a\\']++;\\n        }\\n        for(i=0;i<26;i++)//checking the difference between the two frequency arrays\\n        {\\n            ans=ans+abs(v1[i]-v2[i]); //keeping check of the total of absolute difference\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803825,
                "title": "c-easy-4-lines-solution-o-n",
                "content": "by counting each letter in the first word, and decreasing the letter in the other words\\nwe can get the difference in letters characters,\\nwe sum the absolute differences and return it\\n```\\npublic int MinSteps(string s, string t) {\\n\\t    var letters = new int[26];\\n        foreach (var letter in s) letters[letter - \\'a\\']++;\\n        foreach (var letter in t) letters[letter - \\'a\\']--;\\n        return letters.Sum(x => Math.Abs(x));\\n}\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(26)  = O(1)",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\npublic int MinSteps(string s, string t) {\\n\\t    var letters = new int[26];\\n        foreach (var letter in s) letters[letter - \\'a\\']++;\\n        foreach (var letter in t) letters[letter - \\'a\\']--;\\n        return letters.Sum(x => Math.Abs(x));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803623,
                "title": "python-easy-and-fast-solution-using-counter",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        c1 = Counter(s)\\n        c2 = Counter(t)\\n        a, b = c1-c2,  c2-c1\\n        ans = 0\\n        for i in (a+b):\\n            ans += (a+b)[i]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        c1 = Counter(s)\\n        c2 = Counter(t)\\n        a, b = c1-c2,  c2-c1\\n        ans = 0\\n        for i in (a+b):\\n            ans += (a+b)[i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803441,
                "title": "c-maintain-character-frequency-array-easy-to-implement",
                "content": "Idea: - The Idea is to maintain a Character Frequency array to store the frequency of each character\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int count = 0;\\n        \\n        vector<int>c_count(26,0); //to store the count of each cahracter\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            c_count[s[i] - \\'a\\']++; // store the character frequency of first string\\n        }\\n        \\n        for(int i=0; i<t.size(); i++) //iterate through the second string,update char_count\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// if character is not found in char_count then increase\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//count\\n        {\\n            c_count[t[i] - \\'a\\']--; \\n        }\\n        \\n        for(int i=0; i<26; i++)\\n        {\\n            if(c_count[i] != 0)\\n\\t\\t\\tcount += abs(c_count[i]); // take count of all values other than zero, if negative \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//take absolute of it\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int count = 0;\\n        \\n        vector<int>c_count(26,0); //to store the count of each cahracter\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            c_count[s[i] - \\'a\\']++; // store the character frequency of first string\\n        }\\n        \\n        for(int i=0; i<t.size(); i++) //iterate through the second string,update char_count\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// if character is not found in char_count then increase\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//count\\n        {\\n            c_count[t[i] - \\'a\\']--; \\n        }\\n        \\n        for(int i=0; i<26; i++)\\n        {\\n            if(c_count[i] != 0)\\n\\t\\t\\tcount += abs(c_count[i]); // take count of all values other than zero, if negative \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//take absolute of it\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803410,
                "title": "kotlin-simple-solution-explained",
                "content": "Solution pops up really quickly, when you refrase the challenge description. Basically, we need `s` and `t` to have same frequencies of all letters. And that is it. How do we do that? We just count all characters that are in `s` but not int `t` (so we need to add them to `t`) and all characters that are int `t` but not in `s` (so we need to add them to `s`), summing these counts we have the solution. As simple as that.\\n\\n```\\nimport kotlin.math.abs\\n\\nclass Solution {\\n    fun minSteps(s: String, t: String): Int {\\n\\t\\n\\t\\t// Counting letters frequencies\\n\\t\\t// If after the loop freq[i] < 0, that means that this letter is in t but not in s, if freqs[i] > 0 that means that the letter is in s but not in t.\\n\\t\\t// And the absolute value value of freqs[i] indicates how much letters we need to add to another string.\\n        val freqs = IntArray(26)\\n        for (i in 0 until maxOf(s.length, t.length)) {\\n            if (i < s.length) freqs[s[i] - \\'a\\']++\\n            if (i < t.length) freqs[t[i] - \\'a\\']--\\n        }\\n        \\n        var count = 0\\n        for (freq in freqs) count += abs(freq)\\n        return count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nimport kotlin.math.abs\\n\\nclass Solution {\\n    fun minSteps(s: String, t: String): Int {\\n\\t\\n\\t\\t// Counting letters frequencies\\n\\t\\t// If after the loop freq[i] < 0, that means that this letter is in t but not in s, if freqs[i] > 0 that means that the letter is in s but not in t.\\n\\t\\t// And the absolute value value of freqs[i] indicates how much letters we need to add to another string.\\n        val freqs = IntArray(26)\\n        for (i in 0 until maxOf(s.length, t.length)) {\\n            if (i < s.length) freqs[s[i] - \\'a\\']++\\n            if (i < t.length) freqs[t[i] - \\'a\\']--\\n        }\\n        \\n        var count = 0\\n        for (freq in freqs) count += abs(freq)\\n        return count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803231,
                "title": "intuitive-non-hash-map-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int res=0;\\n        vector<int> smap(26,0);\\n        vector<int> tmap(26,0);\\n        for(auto el:s){\\n            smap[el-\\'a\\']++;\\n        }\\n        for(int i=0; i<t.size(); i++){\\n            if(smap[t[i]-\\'a\\']){\\n                smap[t[i]-\\'a\\']--;\\n            }\\n            else{\\n                tmap[t[i]-\\'a\\']++;\\n            }\\n        }\\n        for(auto el:tmap){\\n            res+=el;\\n        }\\n        for(auto el:smap){\\n            res+=el;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int res=0;\\n        vector<int> smap(26,0);\\n        vector<int> tmap(26,0);\\n        for(auto el:s){\\n            smap[el-\\'a\\']++;\\n        }\\n        for(int i=0; i<t.size(); i++){\\n            if(smap[t[i]-\\'a\\']){\\n                smap[t[i]-\\'a\\']--;\\n            }\\n            else{\\n                tmap[t[i]-\\'a\\']++;\\n            }\\n        }\\n        for(auto el:tmap){\\n            res+=el;\\n        }\\n        for(auto el:smap){\\n            res+=el;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803188,
                "title": "two-pointer-c",
                "content": "\\n\\tint minSteps(string s, string t) \\n\\t{\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        int m=s.length();\\n        int n=t.length();\\n        int i=0, j=0, count=0;  //count to keep track of common letters\\n        while(i<m and j<n)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else if(s[i]<t[j])\\n                i++;\\n            else \\n                j++;\\n        }\\n        return (m-count)+(n-count);\\n        \\n    }",
                "solutionTags": [],
                "code": "\\n\\tint minSteps(string s, string t) \\n\\t{\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        int m=s.length();\\n        int n=t.length();\\n        int i=0, j=0, count=0;  //count to keep track of common letters\\n        while(i<m and j<n)\\n        {\\n            if(s[i]==t[j])\\n            {\\n                count++;\\n                i++;\\n                j++;\\n            }\\n            else if(s[i]<t[j])\\n                i++;\\n            else \\n                j++;\\n        }\\n        return (m-count)+(n-count);\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1803106,
                "title": "rust-counting-frequencies",
                "content": "Solution - [github](https://github.com/An7One/lc_soln_rust_leon/tree/main/src/leetcode/lvl1/lc2186)\\n\\n<b>Problem List</b>\\n#LinearScan-String - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_data_structure/string/by_technique/n_pointers/linear_scan.txt)\\n#FreqArray - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_data_structure/string/by_technique/freqs_array.txt)\\n\\n```\\n/// @author: Leon\\n/// https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/\\n/// Time Complexity:    O(max(`_len_s`, `_len_t`))\\n/// Space Complexity:   O(1)\\nimpl Solution {\\n    pub fn min_steps(s: String, t: String) -> i32 {\\n        let freqs_s: Vec<u32> = {\\n            let mut freqs: Vec<u32> = vec![0; 26];\\n            for ch in s.chars(){\\n                freqs[ch as usize - \\'a\\' as usize] += 1;\\n            }\\n            freqs\\n        };\\n        let freqs_t: Vec<u32> = {\\n            let mut freqs: Vec<u32> = vec![0; 26];\\n            for ch in t.chars(){\\n                freqs[ch as usize - \\'a\\' as usize] += 1;\\n            }\\n            freqs\\n        };\\n        let mut cnt: i32 = 0;\\n        for idx in 0..26{\\n            cnt += (freqs_s[idx] as i32 - freqs_t[idx] as i32).abs();\\n        }\\n        cnt\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n/// @author: Leon\\n/// https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/\\n/// Time Complexity:    O(max(`_len_s`, `_len_t`))\\n/// Space Complexity:   O(1)\\nimpl Solution {\\n    pub fn min_steps(s: String, t: String) -> i32 {\\n        let freqs_s: Vec<u32> = {\\n            let mut freqs: Vec<u32> = vec![0; 26];\\n            for ch in s.chars(){\\n                freqs[ch as usize - \\'a\\' as usize] += 1;\\n            }\\n            freqs\\n        };\\n        let freqs_t: Vec<u32> = {\\n            let mut freqs: Vec<u32> = vec![0; 26];\\n            for ch in t.chars(){\\n                freqs[ch as usize - \\'a\\' as usize] += 1;\\n            }\\n            freqs\\n        };\\n        let mut cnt: i32 = 0;\\n        for idx in 0..26{\\n            cnt += (freqs_s[idx] as i32 - freqs_t[idx] as i32).abs();\\n        }\\n        cnt\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1803082,
                "title": "python-python3-2-liner-easy-fast-simple",
                "content": "* return the sum of difference of count of indivisual element in both string\\n1.  prepare hashmap( or dict ) using Counter (prebuild function from collection module)  , key as unique element and value as count of that element in string\\n2.  return total sum of diff of count\\n\\n\\n\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        s,c=Counter(s),Counter(t)\\n        return sum(abs(s[chr(i)]-c[chr(i)]) for i in range(97,97+26))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        s,c=Counter(s),Counter(t)\\n        return sum(abs(s[chr(i)]-c[chr(i)]) for i in range(97,97+26))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803061,
                "title": "c-o-n-hashmap",
                "content": "**The approach according to me is :-\\n1) First convert the first  and second given string into hashmap of (Char , Freq) by iterating through them\\n2) Now we will search keys of map2 in   map 1 , if key doesnt exists than  insert the key in ,map1 with frequency 1 . If key exists than we need to check if the frequency is <= or > than the freq with respect to map 2.\\n3) If freq is <= we need to to increase the count as count +(difference of the key frequency in map1 and map2)\\n4) if key is > that means we dont need to do anything .\\n5) Repeat the step from 2->3 by substituting map 1 with map 2.\\n6) Finaly we will return the count **\\nHere is the code:\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> first;\\n        unordered_map<char,int> second;\\n        int count=0;\\n        int temp=0;\\n    \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(first.find(s[i])==first.end()) first.insert({s[i],1});\\n            else first[s[i]]++;\\n            \\n        }\\n         for(int i=0;i<t.length();i++)\\n        {\\n            if(second.find(t[i])==second.end()) second.insert({t[i],1});\\n            else second[t[i]]++;\\n        }\\n        for(auto  itr=second.begin();itr!=second.end();itr++)\\n        {\\n            auto it=first.find(itr->first);\\n            if(it==first.end()) count=count+(itr->second);\\n            else\\n            {\\n                if(first[itr->first]<second[itr->first])\\n                count= count +abs(first[itr->first]-second[itr->first]);\\n            }\\n        }\\n        for(auto  itr=first.begin();itr!=first.end();itr++)\\n        {\\n            auto it=second.find(itr->first);\\n            if(it==second.end()) count=count+(itr->second);\\n            else \\n            {\\n                if(second[itr->first]<first[itr->first])\\n                count= count +abs(first[itr->first]-second[itr->first]);\\n            }\\n        }\\n        return count ; \\n    }\\n};\\n```\\n\\n**Time complexity= inserting the (char, freq) in map 1 and 2 +Traversing the map 1 and map 2 for searching pupose= ~0(n)**\\n**Space complexity= 0(2n)~ 0(n)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> first;\\n        unordered_map<char,int> second;\\n        int count=0;\\n        int temp=0;\\n    \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(first.find(s[i])==first.end()) first.insert({s[i],1});\\n            else first[s[i]]++;\\n            \\n        }\\n         for(int i=0;i<t.length();i++)\\n        {\\n            if(second.find(t[i])==second.end()) second.insert({t[i],1});\\n            else second[t[i]]++;\\n        }\\n        for(auto  itr=second.begin();itr!=second.end();itr++)\\n        {\\n            auto it=first.find(itr->first);\\n            if(it==first.end()) count=count+(itr->second);\\n            else\\n            {\\n                if(first[itr->first]<second[itr->first])\\n                count= count +abs(first[itr->first]-second[itr->first]);\\n            }\\n        }\\n        for(auto  itr=first.begin();itr!=first.end();itr++)\\n        {\\n            auto it=second.find(itr->first);\\n            if(it==second.end()) count=count+(itr->second);\\n            else \\n            {\\n                if(second[itr->first]<first[itr->first])\\n                count= count +abs(first[itr->first]-second[itr->first]);\\n            }\\n        }\\n        return count ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803001,
                "title": "c-o-n-hashmap-frequency-array",
                "content": "Hi , everybody . This is a fairly easy question . It is a good practice for beginner level understanding of frequency arrays/hashmaps/maps. \\n\\nSo, let\\'s get started. \\n**QUESTION EXPLANATION :**\\nThe question says that we are provided with 2 strings ***s and t***. \\nWe can perform the following operation on either of them any number of times : \\n**\"Add(append) any character in the string\"**.\\nThe goal is to make the strings **anagrams of each other.**\\n\\n**WHAT ARE ANAGRAMS ?**\\nAnagram of a string is another string which has ***the same frequency of each character*** as in the given string. \\nEXAMPLE :  \"aabcde\" and \"bcaade\" are anagrams of each other , as all the characters in both the strings have same frequency. \\n\\n## SOLUTION : \\nNow , we have to make these 2 strings anagrams and the only operation allowed is that we can add any character that we want to either of the strings.\\n\\n**SO HOW DO WE DO THIS??**\\nThe first step that I see is to **store the frequency of each character in both the strings in separate hashmaps.** \\n\\nNow, what will be the minimum number of steps needed to make the strings anagrams of each other ?? \\nWe can compare the frequency of each character in both the strings. \\nIf the frequency of a character differs , then we can **add the same character abs(freq1[i] - freq2[i]) times to the string that is low on the count**. This way the frequency of this character will now be equal in both the strings. \\n\\nFor example : In a particular case : \\n**STRING_1 contains 6 \\'a\\' and STRING_2 contains 2 \\'a\\'.**\\nNow we can **add (6-2) \\'a\\' to the STRING_2 (string with low count)** . Now the frequency of \\'a\\' in both strings is 6.\\n\\n\\n### APPROACH : \\n* Store the frequency of each character in both the strings on individual hashmaps ( or frequency arrays ) .\\n* Add the absolute difference of the frequencies of each character from the hashmaps to the ***ans variable.*** ( freq1[\\'a\\'] -freq2[\\'a\\'] ).\\n* Return **ans variable**\\n\\n**TC : O(N)**\\n**SC : O(N)**\\n\\nWe can improve this approach on the SPACE COMPLEXITY. \\nThis is because we don\\'t exactly need 2 hashmaps to generate the answer. \\nWHY ?? \\n*Because if , we notice we are adding the frequency of a character from STRING1 and substracting the frequency of the same character from STRING2. \\nThen why should we store it in 2 different hashmaps ?? Well, we can increase the frequency of a character whenever it is encountered in the STRING1 and we can decrease the frequency of a character whenever it is encountered in the STRING2.*\\n\\n#### CODE : \\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int freq[26]={0};\\n        for(char &c:s)\\n            freq[c-\\'a\\']++;\\n        for(char &d:t)\\n            freq[d-\\'a\\']--;\\n        int ans=0;\\n        for(int i:freq)\\n            ans+=abs(i);\\n        return ans;\\n        \\n    }\\n};\\n```\\n***If you found this post helpful , please upvote and comment below.***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int freq[26]={0};\\n        for(char &c:s)\\n            freq[c-\\'a\\']++;\\n        for(char &d:t)\\n            freq[d-\\'a\\']--;\\n        int ans=0;\\n        for(int i:freq)\\n            ans+=abs(i);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803000,
                "title": "python-counter-with-explanation",
                "content": "3 cases:\\n1. Numbers of distinct letters in source are equal to target.\\n2. Source word has more distinct letters.\\n3. Target word has more distinct letters.\\n\\nSo I looped through the keys in source first and made comparison, then looped through target to make comparison.\\nTime complexity: O(N)\\nSpace complextiy: O(M + N) M, N are the number of distinct letters of source and target. \\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cs = Counter(s)\\n        ct = Counter(t)\\n        \\n        # print(cs, ct)\\n        ans = 0\\n        for key in cs:\\n            if key in ct:\\n                ans += abs(cs[key] - ct[key])\\n            else:\\n                ans += cs[key]\\n                \\n        for key in ct:\\n            if key not in cs:\\n                ans += ct[key]\\n                \\n        return ans\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "3 cases:\\n1. Numbers of distinct letters in source are equal to target.\\n2. Source word has more distinct letters.\\n3. Target word has more distinct letters.\\n\\nSo I looped through the keys in source first and made comparison, then looped through target to make comparison.\\nTime complexity: O(N)\\nSpace complextiy: O(M + N) M, N are the number of distinct letters of source and target. \\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cs = Counter(s)\\n        ct = Counter(t)\\n        \\n        # print(cs, ct)\\n        ans = 0\\n        for key in cs:\\n            if key in ct:\\n                ans += abs(cs[key] - ct[key])\\n            else:\\n                ans += cs[key]\\n                \\n        for key in ct:\\n            if key not in cs:\\n                ans += ct[key]\\n                \\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1802968,
                "title": "java-simple-solution-with-ascii-array",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] arr = new int[128];\\n        for (char c : s.toCharArray()) {\\n            arr[c]++;\\n        }\\n        for (char c : t.toCharArray()) {\\n            arr[c]--;\\n        }\\n        int step = 0;\\n        for (int i : arr) {\\n            if (i != 0) {\\n                step += Math.abs(i);\\n            }\\n        }\\n        return step;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] arr = new int[128];\\n        for (char c : s.toCharArray()) {\\n            arr[c]++;\\n        }\\n        for (char c : t.toCharArray()) {\\n            arr[c]--;\\n        }\\n        int step = 0;\\n        for (int i : arr) {\\n            if (i != 0) {\\n                step += Math.abs(i);\\n            }\\n        }\\n        return step;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802921,
                "title": "easy-count-approach-time-o-26",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> arr(26);\\n        for(auto it : s) arr[it - \\'a\\']++;\\n        for(auto it : t) arr[it - \\'a\\']--;\\n        int ans = 0;\\n        for(auto it : arr) ans += abs(it);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> arr(26);\\n        for(auto it : s) arr[it - \\'a\\']++;\\n        for(auto it : t) arr[it - \\'a\\']--;\\n        int ans = 0;\\n        for(auto it : arr) ans += abs(it);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802920,
                "title": "c-solution-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> m1(26,0);\\n        for(char c:s) m1[c-\\'a\\']++;\\n        for(char c:t) m1[c-\\'a\\']--;\\n        int ans=0;\\n        for(auto i:m1){\\n            ans=ans+abs(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> m1(26,0);\\n        for(char c:s) m1[c-\\'a\\']++;\\n        for(char c:t) m1[c-\\'a\\']--;\\n        int ans=0;\\n        for(auto i:m1){\\n            ans=ans+abs(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802894,
                "title": "4-line-code-very-easy-solution-hashmap-c-with-explnation",
                "content": "Ist we  count the frequecy of charachters in s and  then \\nsecond step we reduce the freq and \\n c variable store the positive value .\\n\\n```\\nclass Solution {\\npublic:\\n     int minSteps(string s, string t) { \\n         int c=0;\\n        unordered_map<char,int>map;\\n            for(auto i:s) map[i] ++;\\n         for(auto p:t) map[p]--;\\n        for(auto it:map)\\n        {    c+= abs(it.second); }\\n     return c;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n     int minSteps(string s, string t) { \\n         int c=0;\\n        unordered_map<char,int>map;\\n            for(auto i:s) map[i] ++;\\n         for(auto p:t) map[p]--;\\n        for(auto it:map)\\n        {    c+= abs(it.second); }",
                "codeTag": "Java"
            },
            {
                "id": 1802862,
                "title": "easy-simple-java-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n   public int minSteps(String s, String t) {\\n        int[] cArray = new int[\\'z\\'-\\'a\\'+1];\\n        int count=0;\\n        for(char c: s.toCharArray() ) cArray[c-\\'a\\']++;\\n        for(char c: t.toCharArray() ) cArray[c-\\'a\\']--;\\n        for(int c: cArray) count+=Math.abs(c);\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n   public int minSteps(String s, String t) {\\n        int[] cArray = new int[\\'z\\'-\\'a\\'+1];\\n        int count=0;\\n        for(char c: s.toCharArray() ) cArray[c-\\'a\\']++;\\n        for(char c: t.toCharArray() ) cArray[c-\\'a\\']--;\\n        for(int c: cArray) count+=Math.abs(c);\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802783,
                "title": "c-o-n-o-1-simple-easy-counting-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint minSteps(string s, string t) {\\n\\t\\tvector<int>freq(26, 0);\\n\\t\\tfor (auto c : s) freq[c - \\'a\\']++;\\n\\t\\tfor (auto c : t) freq[c - \\'a\\']--;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < 26; i++) ans += abs(freq[i]);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n**Time Complexity : O(max(n,m))** where `n = s.size()` & `m = t.size()`\\n**Space Complexity : O(1)** as we use constatnt size `freq` array\\n\\n\\n**If find Helpful *Upvote It* \\uD83D\\uDC4D**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint minSteps(string s, string t) {\\n\\t\\tvector<int>freq(26, 0);\\n\\t\\tfor (auto c : s) freq[c - \\'a\\']++;\\n\\t\\tfor (auto c : t) freq[c - \\'a\\']--;\\n\\t\\tint ans = 0;\\n\\t\\tfor (int i = 0; i < 26; i++) ans += abs(freq[i]);\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802726,
                "title": "c-short-and-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n          vector<int> fre1(26,0), fre2(26,0);\\n          for(char ch : s){\\n              fre1[ch - \\'a\\']++;\\n          }\\n         for(char ch : t){\\n              fre2[ch - \\'a\\']++;\\n          }\\n        int ans = 0;\\n        for(int i=0; i<26; i++){\\n            ans += abs(fre1[i] - fre2[i]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n          vector<int> fre1(26,0), fre2(26,0);\\n          for(char ch : s){\\n              fre1[ch - \\'a\\']++;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1802697,
                "title": "c-count-array-counting",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> arr(26,0);\\n        \\n        for(int i=0; i<s.length(); i++)\\n            arr[s[i] - \\'a\\']++;\\n        for(int i=0; i<t.length(); i++)\\n            arr[t[i] - \\'a\\']--;\\n        \\n        int ans = 0;\\n        for(int i=0; i<26; i++){\\n            ans += abs(arr[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> arr(26,0);\\n        \\n        for(int i=0; i<s.length(); i++)\\n            arr[s[i] - \\'a\\']++;\\n        for(int i=0; i<t.length(); i++)\\n            arr[t[i] - \\'a\\']--;\\n        \\n        int ans = 0;\\n        for(int i=0; i<26; i++){\\n            ans += abs(arr[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802688,
                "title": "c-simple-hashmap-solution",
                "content": "```\\n int ans = 0;\\n        unordered_map<char,int>mp;\\n        for(auto it:s){\\n            mp[it]++;\\n        }\\n         for(auto it:t){\\n            mp[it]--;\\n        }\\n         for(auto it:mp){\\n           ans+=abs(it.second);\\n        }\\n        return ans;\\n```",
                "solutionTags": [],
                "code": "```\\n int ans = 0;\\n        unordered_map<char,int>mp;\\n        for(auto it:s){\\n            mp[it]++;\\n        }\\n         for(auto it:t){\\n            mp[it]--;\\n        }\\n         for(auto it:mp){\\n           ans+=abs(it.second);\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802649,
                "title": "java-easy-frequency-difference",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] f1 = new int[26];\\n        int[] f2 = new int[26];\\n        \\n        for(int i=0;i<s.length();i++){\\n            f1[s.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<t.length();i++){\\n            f2[t.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<26;i++){\\n            ans += Math.abs(f1[i]-f2[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] f1 = new int[26];\\n        int[] f2 = new int[26];\\n        \\n        for(int i=0;i<s.length();i++){\\n            f1[s.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<t.length();i++){\\n            f2[t.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0;i<26;i++){\\n            ans += Math.abs(f1[i]-f2[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802619,
                "title": "python",
                "content": "\\t\\n\\tclass Solution:\\n\\t\\tdef minSteps(self, s: str, t: str) -> int:\\n\\t\\t\\ta1=[0 for i in range(26)]\\n\\t\\t\\ta2=[0 for i in range(26)]\\n        \\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\ta1[ord(s[i])-ord(\\'a\\')]+=1\\n        \\n\\t\\t\\tfor i in range(len(t)):\\n\\t\\t\\t\\ta2[ord(t[i])-ord(\\'a\\')]+=1\\n        \\n\\t\\t\\tt=0\\n\\t\\t\\tfor i in range(26):\\n\\t\\t\\t\\tt+=abs(a1[i]-a2[i])\\n\\t\\t\\treturn t\\n",
                "solutionTags": [],
                "code": "\\t\\n\\tclass Solution:\\n\\t\\tdef minSteps(self, s: str, t: str) -> int:\\n\\t\\t\\ta1=[0 for i in range(26)]\\n\\t\\t\\ta2=[0 for i in range(26)]\\n        \\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\ta1[ord(s[i])-ord(\\'a\\')]+=1\\n        \\n\\t\\t\\tfor i in range(len(t)):\\n\\t\\t\\t\\ta2[ord(t[i])-ord(\\'a\\')]+=1\\n        \\n\\t\\t\\tt=0\\n\\t\\t\\tfor i in range(26):\\n\\t\\t\\t\\tt+=abs(a1[i]-a2[i])\\n\\t\\t\\treturn t\\n",
                "codeTag": "Java"
            },
            {
                "id": 1802604,
                "title": "c-count-frequency-easy-to-understand-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> freqs(26,0);\\n        vector<int> freqt(26,0);\\n        int n=s.size(),m=t.size();\\n        for(int i=0;i<n;i++){\\n            freqs[s[i]-\\'a\\']++;//count frequency of string s\\n        }\\n        for(int i=0;i<m;i++){\\n            freqt[t[i]-\\'a\\']++;//count frequency of string t\\n        }\\n        int cnt=0;\\n        for(int i=0;i<26;i++){\\n            if(freqs[i]!=0 and freqt[i]!=0){\\n            if(freqs[i]==freqt[i])cnt+=freqs[i];\\n            else {\\n                if(freqs[i]>freqt[i])cnt+=freqt[i];\\n                else cnt+=freqs[i];\\n            }\\n            }\\n        }\\n        return n+m-2*cnt;//excluding the common strings from total length of string s + string t\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> freqs(26,0);\\n        vector<int> freqt(26,0);\\n        int n=s.size(),m=t.size();\\n        for(int i=0;i<n;i++){\\n            freqs[s[i]-\\'a\\']++;//count frequency of string s\\n        }\\n        for(int i=0;i<m;i++){\\n            freqt[t[i]-\\'a\\']++;//count frequency of string t\\n        }\\n        int cnt=0;\\n        for(int i=0;i<26;i++){\\n            if(freqs[i]!=0 and freqt[i]!=0){\\n            if(freqs[i]==freqt[i])cnt+=freqs[i];\\n            else {\\n                if(freqs[i]>freqt[i])cnt+=freqt[i];\\n                else cnt+=freqs[i];\\n            }\\n            }\\n        }\\n        return n+m-2*cnt;//excluding the common strings from total length of string s + string t\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802598,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] str1 = new int[26];\\n        int[] str2 = new int[26];\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            str1[s.charAt(i) - \\'a\\'] += 1; \\n        }\\n        \\n        \\n        for (int i = 0; i < t.length(); i++) {\\n            str2[t.charAt(i) - \\'a\\'] += 1; \\n        }\\n        \\n        boolean isAnagram = true;\\n        for (int i = 0; i < 26; i++) {\\n            if (str1[i] != str2[i]) isAnagram = false;\\n        }\\n        \\n        if (isAnagram) return 0;\\n        int count = 0;\\n        for (int i = 0; i < 26; ) {\\n            if (str1[i] == str2[i]) {\\n                i++;\\n                continue;\\n            }\\n            \\n            if (str1[i] > str2[i]) {\\n                str2[i] += 1;\\n                count++;\\n            } else if (str1[i] < str2[i]) {\\n                str1[i] += 1;\\n                count++;\\n            }\\n            \\n             if (str1[i] == str2[i]) {\\n                i++;\\n                continue;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] str1 = new int[26];\\n        int[] str2 = new int[26];\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            str1[s.charAt(i) - \\'a\\'] += 1; \\n        }\\n        \\n        \\n        for (int i = 0; i < t.length(); i++) {\\n            str2[t.charAt(i) - \\'a\\'] += 1; \\n        }\\n        \\n        boolean isAnagram = true;\\n        for (int i = 0; i < 26; i++) {\\n            if (str1[i] != str2[i]) isAnagram = false;\\n        }\\n        \\n        if (isAnagram) return 0;\\n        int count = 0;\\n        for (int i = 0; i < 26; ) {\\n            if (str1[i] == str2[i]) {\\n                i++;\\n                continue;\\n            }\\n            \\n            if (str1[i] > str2[i]) {\\n                str2[i] += 1;\\n                count++;\\n            } else if (str1[i] < str2[i]) {\\n                str1[i] += 1;\\n                count++;\\n            }\\n            \\n             if (str1[i] == str2[i]) {\\n                i++;\\n                continue;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802590,
                "title": "c-store-frequencies",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> a(26, 0);\\n        vector<int> b(26, 0);\\n        for (int i = 0; i < s.size(); i++) a[s[i] - \\'a\\']++;\\n        for (int i = 0; i < t.size(); i++) b[t[i] - \\'a\\']++;\\n        int res = 0;\\n        for (int i = 0; i < 26; i++) res += abs(a[i] - b[i]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> a(26, 0);\\n        vector<int> b(26, 0);\\n        for (int i = 0; i < s.size(); i++) a[s[i] - \\'a\\']++;\\n        for (int i = 0; i < t.size(); i++) b[t[i] - \\'a\\']++;\\n        int res = 0;\\n        for (int i = 0; i < 26; i++) res += abs(a[i] - b[i]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802589,
                "title": "c-easy-solution-using-map",
                "content": "**C++ easy solution using unoredered map**\\n\\n\\n\\tint minSteps(string s, string t) {*\\n\\t\\t\\tunordered_map<char,int>sp;\\n        unordered_map<char,int>tp;\\n        int count=0;\\n        int res=0;\\n        for(auto i:s){\\n            sp[i]++;\\n        }\\n        for(auto i:t){\\n            tp[i]++;\\n        }\\n        for(auto i:sp){\\n            count=sp[i.first]-tp[i.first];\\n            if(count<0)count=0;\\n            res+=count;\\n           \\n        }\\n        for(auto i:tp){\\n            count=tp[i.first]-sp[i.first];\\n            if(count<0)count=0;\\n            res+=count;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "**C++ easy solution using unoredered map**\\n\\n\\n\\tint minSteps(string s, string t) {*\\n\\t\\t\\tunordered_map<char,int>sp;\\n        unordered_map<char,int>tp;\\n        int count=0;\\n        int res=0;\\n        for(auto i:s){\\n            sp[i]++;\\n        }\\n        for(auto i:t){\\n            tp[i]++;\\n        }\\n        for(auto i:sp){\\n            count=sp[i.first]-tp[i.first];\\n            if(count<0)count=0;\\n            res+=count;\\n           \\n        }\\n        for(auto i:tp){\\n            count=tp[i.first]-sp[i.first];\\n            if(count<0)count=0;\\n            res+=count;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1802581,
                "title": "anagram",
                "content": "any king of suggestions and improvements are most welcomded\\n\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        int sv[26]={0};\\n        int tv[26]={0};\\n        for(int i=0; i<s.length(); i++){\\n            sv[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0; i<t.length(); i++){\\n            tv[t[i]-\\'a\\']++;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<26; i++){\\n            ans+=abs(sv[i]-tv[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        int sv[26]={0};\\n        int tv[26]={0};\\n        for(int i=0; i<s.length(); i++){\\n            sv[s[i]-\\'a\\']++;\\n        }\\n        for(int i=0; i<t.length(); i++){\\n            tv[t[i]-\\'a\\']++;\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<26; i++){\\n            ans+=abs(sv[i]-tv[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802553,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n       int n = s.size();\\n       int m = t.size();\\n       unordered_map<char, int> mp;\\n       int count = 0;\\n       for(char c : s){\\n               mp[c]++;\\n       }\\n       for(char c : t){\\n               if(mp.find(c) != mp.end()){\\n                  count++; \\n                  mp[c]--;\\n               }\\n               if(mp[c] == 0) mp.erase(c);\\n       }\\n        return n + m - 2*count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n       int n = s.size();\\n       int m = t.size();\\n       unordered_map<char, int> mp;\\n       int count = 0;\\n       for(char c : s){\\n               mp[c]++;\\n       }\\n       for(char c : t){\\n               if(mp.find(c) != mp.end()){\\n                  count++; \\n                  mp[c]--;\\n               }\\n               if(mp[c] == 0) mp.erase(c);\\n       }\\n        return n + m - 2*count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802546,
                "title": "java-simple-map",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] map1 = new int[26];\\n        int[] map2 = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            map1[s.charAt(i) - \\'a\\']++;\\n        }\\n        for (int i = 0; i < t.length(); i++) {\\n            map2[t.charAt(i) - \\'a\\']++;\\n        }\\n        int answer = 0;\\n\\t\\t//  convert one map to another\\n        for (int i = 0; i < 26; i++) {\\n            int v1 = map1[i];\\n            int v2 = map2[i];\\n            answer += Math.abs(v2 - v1);\\n        }\\n        return answer;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minSteps(String s, String t) {\\n        int[] map1 = new int[26];\\n        int[] map2 = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            map1[s.charAt(i) - \\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1802530,
                "title": "c-sorting-two-pointer-approach-with-comments",
                "content": "Please Upvote if you like the solution.\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        \\n        // If words are anagram, then sorting both of them would make the strings equal i.e s == t.\\n        if (s == t)\\n            return 0;\\n        \\n        // If the are not equal then we take two pointer approach:\\n        \\n        int i = 0,j = 0,mini = 0;\\n        int n = s.length(), m = t.length();\\n        while (i < n && j < m){\\n            int check1 = s[i]-\\'a\\';\\n            int check2 = t[j]-\\'a\\';\\n            \\n            // If \\'i\\'th and \\'j\\'th letter in both the words are same we won\\'t require any steps,\\n            // so we just continue, incrementing \\'i\\'th and \\'j\\'th pointers;\\n            \\n            if (check1 == check2){\\n                i++;\\n                j++;\\n            }\\n            \\n            // If \\'i\\'th letter of string s is less than \\'j\\'th letter of string t,\\n            // then we need to add \\'i\\'th letter of string s to string t in order to make them anagram.\\n            else if (check1 < check2){\\n                i++;\\n                mini++;\\n            }\\n            \\n            // If \\'i\\'th letter of string s is greater than \\'j\\'th letter of string t,\\n            // then we need to add \\'j\\'th letter of string t to string s in order to make them anagram.\\n            else{\\n                j++;\\n                mini++;\\n            }      \\n        }\\n        \\n        // Since length of both the strings may not be same,\\n        // we may end up ending the loop and still we may have either letters in string s or t to be processed.\\n        // So we apply this condition:\\n        if (i < n){\\n            mini += (n - i);\\n        }\\n        if (j < m){\\n            mini += (m - j);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        \\n        // If words are anagram, then sorting both of them would make the strings equal i.e s == t.\\n        if (s == t)\\n            return 0;\\n        \\n        // If the are not equal then we take two pointer approach:\\n        \\n        int i = 0,j = 0,mini = 0;\\n        int n = s.length(), m = t.length();\\n        while (i < n && j < m){\\n            int check1 = s[i]-\\'a\\';\\n            int check2 = t[j]-\\'a\\';\\n            \\n            // If \\'i\\'th and \\'j\\'th letter in both the words are same we won\\'t require any steps,\\n            // so we just continue, incrementing \\'i\\'th and \\'j\\'th pointers;\\n            \\n            if (check1 == check2){\\n                i++;\\n                j++;\\n            }\\n            \\n            // If \\'i\\'th letter of string s is less than \\'j\\'th letter of string t,\\n            // then we need to add \\'i\\'th letter of string s to string t in order to make them anagram.\\n            else if (check1 < check2){\\n                i++;\\n                mini++;\\n            }\\n            \\n            // If \\'i\\'th letter of string s is greater than \\'j\\'th letter of string t,\\n            // then we need to add \\'j\\'th letter of string t to string s in order to make them anagram.\\n            else{\\n                j++;\\n                mini++;\\n            }      \\n        }\\n        \\n        // Since length of both the strings may not be same,\\n        // we may end up ending the loop and still we may have either letters in string s or t to be processed.\\n        // So we apply this condition:\\n        if (i < n){\\n            mini += (n - i);\\n        }\\n        if (j < m){\\n            mini += (m - j);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802524,
                "title": "without-hashmap-0-1-space-complexity",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] firstCharacter = new int[26];\\n        int[] secondCharacter = new int[26];\\n        int steps = 0;\\n        for(int i = 0 ;i < s.length() ; i++){\\n            firstCharacter[s.charAt(i) - \\'a\\'] += 1;\\n        }\\n        for(int i = 0 ;i < t.length() ; i++){\\n            secondCharacter[t.charAt(i) - \\'a\\'] += 1;\\n        }\\n        for(int i = 0 ;i < firstCharacter.length ; i++){\\n            if(firstCharacter[i]  != secondCharacter[i]){\\n                steps += Math.abs(firstCharacter[i] - secondCharacter[i]);\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] firstCharacter = new int[26];\\n        int[] secondCharacter = new int[26];\\n        int steps = 0;\\n        for(int i = 0 ;i < s.length() ; i++){\\n            firstCharacter[s.charAt(i) - \\'a\\'] += 1;\\n        }\\n        for(int i = 0 ;i < t.length() ; i++){\\n            secondCharacter[t.charAt(i) - \\'a\\'] += 1;\\n        }\\n        for(int i = 0 ;i < firstCharacter.length ; i++){\\n            if(firstCharacter[i]  != secondCharacter[i]){\\n                steps += Math.abs(firstCharacter[i] - secondCharacter[i]);\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802492,
                "title": "c-with-explanation",
                "content": "**Explanation:-**\\n1. answer will be the sum of extra characters in ```s``` that are not in ```t``` and vice-versa.\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int>a1(26,0),a2(26,0);\\n        int ans=0;\\n        for(auto & i:s)  a1[i-\\'a\\']++;\\n        for(auto & i:t)  a2[i-\\'a\\']++;\\n        for(int i=0;i<26;i++){\\n            ans+=a1[i]-min(a1[i],a2[i]);\\n            ans+=a2[i]-min(a1[i],a2[i]);\\n        }\\n        return ans;\\n        }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```s```\n```t```\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int>a1(26,0),a2(26,0);\\n        int ans=0;\\n        for(auto & i:s)  a1[i-\\'a\\']++;\\n        for(auto & i:t)  a2[i-\\'a\\']++;\\n        for(int i=0;i<26;i++){\\n            ans+=a1[i]-min(a1[i],a2[i]);\\n            ans+=a2[i]-min(a1[i],a2[i]);\\n        }\\n        return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802481,
                "title": "python-solution-3-lines",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        hmap_s = collections.Counter(s)\\n        hmap_t = collections.Counter(t)\\n        return sum((hmap_s-hmap_t).values()) + sum((hmap_t-hmap_s).values())\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        hmap_s = collections.Counter(s)\\n        hmap_t = collections.Counter(t)\\n        return sum((hmap_s-hmap_t).values()) + sum((hmap_t-hmap_s).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802457,
                "title": "python-java-hashmap",
                "content": "\\tclass Solution:\\n\\t\\tdef minSteps(self, s: str, t: str) -> int:\\n\\t\\t\\tcntS = collections.Counter(s)\\n\\t\\t\\tcntT = collections.Counter(t)\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor k in cntS:\\n\\t\\t\\t\\tif k in cntT:\\n\\t\\t\\t\\t\\ttoRmove = min(cntS[k], cntT[k])\\n\\t\\t\\t\\t\\tcntS[k] -= toRmove\\n\\t\\t\\t\\t\\tcntT[k] -= toRmove\\n\\t\\t\\tfor v in cntS.values():\\n\\t\\t\\t\\tres += v\\n\\t\\t\\tfor v in cntT.values():\\n\\t\\t\\t\\tres += v\\n\\t\\t\\treturn res\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int minSteps(String s, String t) {\\n\\t\\t\\tMap<Character, Integer> cntS = new HashMap<>();\\n\\t\\t\\tMap<Character, Integer> cntT = new HashMap<>();\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor (char c: s.toCharArray()) {\\n\\t\\t\\t\\tcntS.put(c, cntS.getOrDefault(c, 0) + 1);\\n\\t\\t\\t}\\n\\t\\t\\tfor (char c: t.toCharArray()) {\\n\\t\\t\\t\\tcntT.put(c, cntT.getOrDefault(c, 0) + 1);\\n\\t\\t\\t}\\n\\t\\t\\tfor (char c: cntS.keySet()) {\\n\\t\\t\\t\\tif (cntT.containsKey(c)) {\\n\\t\\t\\t\\t\\tint toRemove = Math.min(cntS.get(c), cntT.get(c));\\n\\t\\t\\t\\t\\tcntS.put(c, cntS.get(c) - toRemove);\\n\\t\\t\\t\\t\\tcntT.put(c, cntT.get(c) - toRemove);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor (char c: cntS.keySet()) {\\n\\t\\t\\t\\tres += cntS.get(c);\\n\\t\\t\\t}\\n\\t\\t\\tfor (char c: cntT.keySet()) {\\n\\t\\t\\t\\tres += cntT.get(c);\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef minSteps(self, s: str, t: str) -> int:\\n\\t\\t\\tcntS = collections.Counter(s)\\n\\t\\t\\tcntT = collections.Counter(t)\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor k in cntS:\\n\\t\\t\\t\\tif k in cntT:\\n\\t\\t\\t\\t\\ttoRmove = min(cntS[k], cntT[k])\\n\\t\\t\\t\\t\\tcntS[k] -= toRmove\\n\\t\\t\\t\\t\\tcntT[k] -= toRmove\\n\\t\\t\\tfor v in cntS.values():\\n\\t\\t\\t\\tres += v\\n\\t\\t\\tfor v in cntT.values():\\n\\t\\t\\t\\tres += v\\n\\t\\t\\treturn res\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int minSteps(String s, String t) {\\n\\t\\t\\tMap<Character, Integer> cntS = new HashMap<>();\\n\\t\\t\\tMap<Character, Integer> cntT = new HashMap<>();\\n\\t\\t\\tint res = 0;\\n\\t\\t\\tfor (char c: s.toCharArray()) {\\n\\t\\t\\t\\tcntS.put(c, cntS.getOrDefault(c, 0) + 1);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1802430,
                "title": "python-simple-concise-solution",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cs = Counter(s)\\n        ct = Counter(t)\\n        \\n        ans = 0\\n        for c in set(s + t):\\n            ans += abs(cs.get(c,0) - ct.get(c,0))\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cs = Counter(s)\\n        ct = Counter(t)\\n        \\n        ans = 0\\n        for c in set(s + t):\\n            ans += abs(cs.get(c,0) - ct.get(c,0))\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070618,
                "title": "easy-way-to-solve-this-using-c-short-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFreq1[s[i]-\\'a\\']++;: For each character in s, this line increments the corresponding element in the Freq array. It does this by subtracting the ASCII value of \\'a\\' from the character s[i], which gives the index of the character in the array Freq. This step effectively increases the frequency count of the character in s.\\n\\nFreq2[t[i]-\\'a\\']++;: Similarly, for each character in t, this line increments the corresponding element in the Freq array. It subtracts the ASCII value of \\'a\\' from the character t[i] to get the index in the Freq array. This step effectively increases the frequency count of the character in t.\\n\\nWe check, for each frequency values of alphabets on both strings, which has greater value. if freq1 has greater value than freq2 for saome index position, it means string s has more number of that specific alphabet than t, so we add the difference in frequency values to counter t_counter. Similarly, do the same for opposite condition.\\n\\nWe add both counters and return that value (result).\\n\\n**DO UPVOTE IF YOU LIKED THE SOLUTION AND IT HELPED!**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint minSteps(char * s, char * t){\\n    int n=strlen(s);\\n    int m=strlen(t);\\n    int freq1[26]={0};\\n    int freq2[26]={0};\\n\\n    for(int i=0;i<n;i++)\\n    {\\n        freq1[s[i]-\\'a\\']++;\\n    }\\n\\n    for(int i=0;i<m;i++)\\n    {\\n        freq2[t[i]-\\'a\\']++;\\n    }\\n\\n    int s_count=0;\\n    int t_count=0;\\n\\n    for(int j=0;j<26;j++)\\n    {\\n        if(freq1[j]==freq2[j]);\\n        else if(freq1[j]>freq2[j])\\n        {\\n        t_count=t_count+(freq1[j]-freq2[j]);\\n        }\\n        else\\n        {\\n        s_count=s_count+(freq2[j]-freq1[j]);\\n        }\\n    }\\n    int result=s_count+t_count;\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minSteps(char * s, char * t){\\n    int n=strlen(s);\\n    int m=strlen(t);\\n    int freq1[26]={0};\\n    int freq2[26]={0};\\n\\n    for(int i=0;i<n;i++)\\n    {\\n        freq1[s[i]-\\'a\\']++;\\n    }\\n\\n    for(int i=0;i<m;i++)\\n    {\\n        freq2[t[i]-\\'a\\']++;\\n    }\\n\\n    int s_count=0;\\n    int t_count=0;\\n\\n    for(int j=0;j<26;j++)\\n    {\\n        if(freq1[j]==freq2[j]);\\n        else if(freq1[j]>freq2[j])\\n        {\\n        t_count=t_count+(freq1[j]-freq2[j]);\\n        }\\n        else\\n        {\\n        s_count=s_count+(freq2[j]-freq1[j]);\\n        }\\n    }\\n    int result=s_count+t_count;\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058446,
                "title": "c-using-hashmap-4-lines-of-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) \\n    {\\n        vector<int> hash(26, 0);\\n        int ans = 0;\\n\\n        for(auto x: s) ++hash[x-\\'a\\'];\\n        for(auto x: t) --hash[x-\\'a\\'];\\n\\n        for(int i=0; i<26; i++)\\n            ans += abs(hash[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) \\n    {\\n        vector<int> hash(26, 0);\\n        int ans = 0;\\n\\n        for(auto x: s) ++hash[x-\\'a\\'];\\n        for(auto x: t) --hash[x-\\'a\\'];\\n\\n        for(int i=0; i<26; i++)\\n            ans += abs(hash[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045992,
                "title": "working-java-hashmap-approach-any-feedback-is-appreciated",
                "content": "# Intuition\\nMy approach was to calculate the sum of all the letters which appear in each string but not the other\\n# Approach\\nTo do this, I used a hashmap to add the letters in the first string as the key and increment the value by 1 for every repeat letter.\\nThen I used the same hashmap to loop through each letter of the second string but instead of increasing I decrease the value because this letter is now common in both strings, for new letters I start with -1 as I am subtracting so repeat letters will continue to decrement accordingly, I will take the absolute value at the end.\\n\\nAfter both strings are looped I take the sum of the absolute values in the hashmap. This will be the steps needed and final answer. Default 0 if hashmap has no values.\\n\\nCan someone think of making this approach more efficient? \\n# Complexity\\n- Time complexity:\\nO(3n) -> so basically O(n)\\nLooping fully through string s, fully through string t, and fully through hashmap to get sum.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int steps = 0;\\n        Map<Character,Integer> hMap = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++){\\n            if (hMap.containsKey(s.charAt(i))){\\n                hMap.put(s.charAt(i), hMap.get(s.charAt(i)) + 1);\\n            }\\n            else {\\n                hMap.put(s.charAt(i), 1);\\n            }\\n        }\\n        for (int i = 0; i < t.length(); i++){\\n            if (hMap.containsKey(t.charAt(i))){\\n                hMap.put(t.charAt(i), hMap.get(t.charAt(i)) - 1);\\n            }\\n            else {\\n                hMap.put(t.charAt(i), -1);\\n            }\\n        }\\n        steps = hMap.values().stream().map(Math::abs).reduce(Integer::sum).orElse(0);\\n        return steps;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int steps = 0;\\n        Map<Character,Integer> hMap = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++){\\n            if (hMap.containsKey(s.charAt(i))){\\n                hMap.put(s.charAt(i), hMap.get(s.charAt(i)) + 1);\\n            }\\n            else {\\n                hMap.put(s.charAt(i), 1);\\n            }\\n        }\\n        for (int i = 0; i < t.length(); i++){\\n            if (hMap.containsKey(t.charAt(i))){\\n                hMap.put(t.charAt(i), hMap.get(t.charAt(i)) - 1);\\n            }\\n            else {\\n                hMap.put(t.charAt(i), -1);\\n            }\\n        }\\n        steps = hMap.values().stream().map(Math::abs).reduce(Integer::sum).orElse(0);\\n        return steps;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042056,
                "title": "simple-hashmap-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n      HashMap<Character,Integer> hs = new HashMap<>();\\n      for(Character ch : s.toCharArray()){\\n          hs.put(ch,hs.getOrDefault(ch,0)+1);\\n      }\\n      int count=0;\\n      for(Character ch : t.toCharArray()){\\n          if(hs.containsKey(ch)){\\n              int val=hs.get(ch);\\n              if(val != 0 ){\\n                  val--;\\n                  hs.put(ch,val);\\n              }else{\\n                  count++;\\n              }\\n          }else{\\n              count++;\\n          }\\n      }\\n      for(int value: hs.values()){\\n          if(value !=0){\\n              count= count+value;\\n          }\\n      }     \\n    return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n      HashMap<Character,Integer> hs = new HashMap<>();\\n      for(Character ch : s.toCharArray()){\\n          hs.put(ch,hs.getOrDefault(ch,0)+1);\\n      }\\n      int count=0;\\n      for(Character ch : t.toCharArray()){\\n          if(hs.containsKey(ch)){\\n              int val=hs.get(ch);\\n              if(val != 0 ){\\n                  val--;\\n                  hs.put(ch,val);\\n              }else{\\n                  count++;\\n              }\\n          }else{\\n              count++;\\n          }\\n      }\\n      for(int value: hs.values()){\\n          if(value !=0){\\n              count= count+value;\\n          }\\n      }     \\n    return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030775,
                "title": "simple-solution-beats-100",
                "content": "\\n```\\nimport string\\n\\nclass Solution(object):\\n    def minSteps(self, s, t):\\n        diff = 0\\n        for char in list(string.ascii_lowercase):\\n            diff += abs(s.count(char)-t.count(char))\\n        return diff\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport string\\n\\nclass Solution(object):\\n    def minSteps(self, s, t):\\n        diff = 0\\n        for char in list(string.ascii_lowercase):\\n            diff += abs(s.count(char)-t.count(char))\\n        return diff\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009537,
                "title": "12ms-98-java-map-and-no-map",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n#  Map - 115ms\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character , Integer> mp = new HashMap<>();\\n\\n        for(char c : s.toCharArray()){\\n            if(mp.containsKey(c)) mp.put( c , mp.get(c)+1);\\n            else mp.put(c,1);\\n        }\\n\\n        for(char c : t.toCharArray()){\\n            if(mp.containsKey(c)) mp.put( c , mp.get(c)-1);\\n            else mp.put(c,-1);\\n        }\\n        \\n        int count = 0;\\n\\n        for(var e : mp.values()){\\n            count += Math.abs(e);\\n        }\\n\\n        return count;\\n    }\\n}\\n```\\n\\n# No Map - 12ms\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int [] arr = new int[26];\\n\\n        for(char c : s.toCharArray()){\\n            arr[c - \\'a\\'] ++;\\n        }\\n\\n        for(char c : t.toCharArray()){\\n            arr[c - \\'a\\'] --;\\n        }\\n        \\n        int count = 0;\\n\\n        for(int i=0; i<26; i++){\\n            count += Math.abs(arr[i]);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character , Integer> mp = new HashMap<>();\\n\\n        for(char c : s.toCharArray()){\\n            if(mp.containsKey(c)) mp.put( c , mp.get(c)+1);\\n            else mp.put(c,1);\\n        }\\n\\n        for(char c : t.toCharArray()){\\n            if(mp.containsKey(c)) mp.put( c , mp.get(c)-1);\\n            else mp.put(c,-1);\\n        }\\n        \\n        int count = 0;\\n\\n        for(var e : mp.values()){\\n            count += Math.abs(e);\\n        }\\n\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int [] arr = new int[26];\\n\\n        for(char c : s.toCharArray()){\\n            arr[c - \\'a\\'] ++;\\n        }\\n\\n        for(char c : t.toCharArray()){\\n            arr[c - \\'a\\'] --;\\n        }\\n        \\n        int count = 0;\\n\\n        for(int i=0; i<26; i++){\\n            count += Math.abs(arr[i]);\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3967200,
                "title": "c-linq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinSteps(string s, string t) {\\n        return t.Aggregate(\\n                s.Aggregate(\\n                    new int[26],\\n                    (a, b) =>\\n                    {\\n                        a[b - \\'a\\']++;\\n                        return a;\\n                    }\\n                )\\n            ,\\n            (a, b) =>\\n            {\\n                a[b- \\'a\\']--;\\n                return a;\\n            }\\n            ).Select(x=>Math.Abs(x)).Sum();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinSteps(string s, string t) {\\n        return t.Aggregate(\\n                s.Aggregate(\\n                    new int[26],\\n                    (a, b) =>\\n                    {\\n                        a[b - \\'a\\']++;\\n                        return a;\\n                    }\\n                )\\n            ,\\n            (a, b) =>\\n            {\\n                a[b- \\'a\\']--;\\n                return a;\\n            }\\n            ).Select(x=>Math.Abs(x)).Sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952942,
                "title": "easy-solution-using-strings-and-hash-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n       for(auto i:s)\\n       {\\n           mp[i]++;\\n       } \\n       int count=0;\\n       for(auto i:t)\\n       {\\n           if(mp[i]>0)\\n           {\\n               mp[i]--;\\n           }\\n           else{\\n               count++;\\n           }\\n       }\\n       for(auto i:mp)\\n       {\\n           count+=i.second;\\n       }\\n       return count;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n       for(auto i:s)\\n       {\\n           mp[i]++;\\n       } \\n       int count=0;\\n       for(auto i:t)\\n       {\\n           if(mp[i]>0)\\n           {\\n               mp[i]--;\\n           }\\n           else{\\n               count++;\\n           }\\n       }\\n       for(auto i:mp)\\n       {\\n           count+=i.second;\\n       }\\n       return count;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3922544,
                "title": "beginner-friendly-easy-c",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char, int>mp;\\n\\n        for(auto x : s){\\n            mp[x]++;\\n        }\\n\\n        for(auto x : t){\\n            mp[x]--;\\n            if(mp[x]==0){\\n                mp.erase(x);\\n            }\\n        }\\n        int ans  = 0;\\n        for(auto x: mp){\\n            ans += abs(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char, int>mp;\\n\\n        for(auto x : s){\\n            mp[x]++;\\n        }\\n\\n        for(auto x : t){\\n            mp[x]--;\\n            if(mp[x]==0){\\n                mp.erase(x);\\n            }\\n        }\\n        int ans  = 0;\\n        for(auto x: mp){\\n            ans += abs(x.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897586,
                "title": "using-tree-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character,Integer> l=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            if(l.containsKey(s.charAt(i))){\\n                int g=l.get(s.charAt(i));\\n                g=g+1;\\n                l.put(s.charAt(i),g);\\n            }\\n            else{\\n                l.put(s.charAt(i),1);\\n            }\\n        }\\n    HashMap<Character,Integer>fl=new HashMap<>();\\n        for(int j=0;j<t.length();j++){\\n            if(fl.containsKey(t.charAt(j))){\\n                int g1=fl.get(t.charAt(j));\\n                g1=g1+1;\\n                fl.put(t.charAt(j),g1);\\n            }\\n            else{\\n                fl.put(t.charAt(j),1);\\n            }\\n        }\\n        System.out.println(l);\\n        System.out.println(fl);\\n        if(l.equals(fl)){\\n            return 0;\\n        }\\n        int e=0;\\n for (Map.Entry<Character, Integer> entry : l.entrySet()) {\\n            char key = entry.getKey();\\n            if(fl.containsKey(key)){\\n                if(fl.get(key)>=l.get(key)){\\n                    e=e+(fl.get(key)-l.get(key));\\n                    l.put(key,fl.get(key));\\n                    \\n                }\\n                else{\\n                    e=e+(l.get(key)-fl.get(key));\\n                    fl.put(key,l.get(key));\\n                }\\n            }\\n            else{\\n                   e=e+l.get(key);\\n                    fl.put(key,l.get(key));\\n            }\\n        }\\n        for(Map.Entry<Character,Integer> g:fl.entrySet()){\\n            char key1=g.getKey();\\n            if(l.containsKey(key1)){\\n                if(l.get(key1)>=fl.get(key1)){\\n                    e=e+(l.get(key1)-fl.get(key1));\\n                    fl.put(key1,l.get(key1));\\n                }\\n                else{\\n                    e=e+(fl.get(key1)-l.get(key1));\\n                    l.put(key1,fl.get(key1));\\n                }\\n            }\\n            else{\\n                e=e+fl.get(key1);\\n                l.put(key1,fl.get(key1));\\n            }\\n        }\\n        System.out.println(l);\\n        System.out.println(fl);\\n\\n\\n\\n        return e;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character,Integer> l=new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            if(l.containsKey(s.charAt(i))){\\n                int g=l.get(s.charAt(i));\\n                g=g+1;\\n                l.put(s.charAt(i),g);\\n            }\\n            else{\\n                l.put(s.charAt(i),1);\\n            }\\n        }\\n    HashMap<Character,Integer>fl=new HashMap<>();\\n        for(int j=0;j<t.length();j++){\\n            if(fl.containsKey(t.charAt(j))){\\n                int g1=fl.get(t.charAt(j));\\n                g1=g1+1;\\n                fl.put(t.charAt(j),g1);\\n            }\\n            else{\\n                fl.put(t.charAt(j),1);\\n            }\\n        }\\n        System.out.println(l);\\n        System.out.println(fl);\\n        if(l.equals(fl)){\\n            return 0;\\n        }\\n        int e=0;\\n for (Map.Entry<Character, Integer> entry : l.entrySet()) {\\n            char key = entry.getKey();\\n            if(fl.containsKey(key)){\\n                if(fl.get(key)>=l.get(key)){\\n                    e=e+(fl.get(key)-l.get(key));\\n                    l.put(key,fl.get(key));\\n                    \\n                }\\n                else{\\n                    e=e+(l.get(key)-fl.get(key));\\n                    fl.put(key,l.get(key));\\n                }\\n            }\\n            else{\\n                   e=e+l.get(key);\\n                    fl.put(key,l.get(key));\\n            }\\n        }\\n        for(Map.Entry<Character,Integer> g:fl.entrySet()){\\n            char key1=g.getKey();\\n            if(l.containsKey(key1)){\\n                if(l.get(key1)>=fl.get(key1)){\\n                    e=e+(l.get(key1)-fl.get(key1));\\n                    fl.put(key1,l.get(key1));\\n                }\\n                else{\\n                    e=e+(fl.get(key1)-l.get(key1));\\n                    l.put(key1,fl.get(key1));\\n                }\\n            }\\n            else{\\n                e=e+fl.get(key1);\\n                l.put(key1,fl.get(key1));\\n            }\\n        }\\n        System.out.println(l);\\n        System.out.println(fl);\\n\\n\\n\\n        return e;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895654,
                "title": "faster-than-97-65-of-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst static auto fast = [] {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> arr(26);\\n        vector<int> arr1(26);\\n        for (auto i: s){\\n            arr[i - 97]++;\\n        }\\n        for (auto j: t){\\n            arr1[j - 97]++;\\n        }\\n        int ans = 0;\\n        for (auto i: s){\\n            arr1[i - 97]--;\\n        }\\n        for (auto i: arr1){\\n            if (i > 0){\\n                ans += i;             \\n            }\\n        }\\n        for (auto i: t){\\n            arr[i - 97]--;\\n        }\\n        for (auto i: arr){\\n            if (i > 0){\\n                ans += i;             \\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst static auto fast = [] {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> arr(26);\\n        vector<int> arr1(26);\\n        for (auto i: s){\\n            arr[i - 97]++;\\n        }\\n        for (auto j: t){\\n            arr1[j - 97]++;\\n        }\\n        int ans = 0;\\n        for (auto i: s){\\n            arr1[i - 97]--;\\n        }\\n        for (auto i: arr1){\\n            if (i > 0){\\n                ans += i;             \\n            }\\n        }\\n        for (auto i: t){\\n            arr[i - 97]--;\\n        }\\n        for (auto i: arr){\\n            if (i > 0){\\n                ans += i;             \\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3895196,
                "title": "basic-c-approach",
                "content": "# Intuition\\nBring out the common characters count from the two strings\\n\\n# Approach\\nTo solve this problem, the basic idea is to calculate the count of characters that are common to both the strings, For this you can use a data structure such as map.\\nNote: We are only concerned with the numbers of the common characters and not the characters itself.\\nFirst iterate through the first string and store it in data structure\\nNext, iterate through the second string and check if it was present in data structure, if present increment the count\\nAfter the loops end the result can be calculated by difference of the string length and common characters.\\n\\n# Complexity\\n- Time complexity:\\n$O(N)$\\n\\n- Space complexity:\\n$O(N)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n        int common=0;\\n        for(auto& it:s)\\n        mp[it]++;\\n        for(auto& it:t)\\n        {\\n            if(mp[it])\\n            {\\n                mp[it]--;\\n                common++;\\n            }\\n        }\\n        return s.size()+t.size()-2*common;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Counting",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n        int common=0;\\n        for(auto& it:s)\\n        mp[it]++;\\n        for(auto& it:t)\\n        {\\n            if(mp[it])\\n            {\\n                mp[it]--;\\n                common++;\\n            }\\n        }\\n        return s.size()+t.size()-2*common;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886833,
                "title": "minimum-number-of-steps-to-make-two-strings-anagram-ii-very-simple-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        map<char,int>mpp;\\n\\n        for(auto it:s)\\n        {\\n            mpp[it]++;\\n        }\\n\\n        for(auto it:t)\\n        {\\n            mpp[it]--;\\n        }\\n\\n        int ans=0;\\n        for(auto it:mpp)\\n        {\\n            ans+=abs(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        map<char,int>mpp;\\n\\n        for(auto it:s)\\n        {\\n            mpp[it]++;\\n        }\\n\\n        for(auto it:t)\\n        {\\n            mpp[it]--;\\n        }\\n\\n        int ans=0;\\n        for(auto it:mpp)\\n        {\\n            ans+=abs(it.second);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3882237,
                "title": "very-easy-short-c-solution-unordered-map",
                "content": "# Intuition\\nThe sum of absolute difference between the occurences of all char in both the strings is our answer\\n\\n# Approach\\nJust Traverse both the strings and store the frequency of each character in the map. The sum of the difference in frequency is our answer.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char, pair<int, int>> mp;\\n        int ans = 0;\\n\\n        for(char c : s){\\n            mp[c].first++;\\n        }\\n        for(char c : t){\\n            mp[c].second++;\\n        }\\n        for(auto it : mp){\\n            ans += abs(it.second.second - it.second.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char, pair<int, int>> mp;\\n        int ans = 0;\\n\\n        for(char c : s){\\n            mp[c].first++;\\n        }\\n        for(char c : t){\\n            mp[c].second++;\\n        }\\n        for(auto it : mp){\\n            ans += abs(it.second.second - it.second.first);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874312,
                "title": "c-time-o-m-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Have an array to store the count of each character from s\\n- Iterate each character in t and decrement from the array\\n- Sum up all the absolute numer from the array to get the answer\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(m + n), where m is length of s and n is length of t\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinSteps(string s, string t) {\\n        int[] arr = new int[26];\\n\\n        foreach(char c in s)\\n        {\\n            arr[c - \\'a\\']++;\\n        }\\n\\n        foreach(char c in t)\\n        {\\n            arr[c - \\'a\\']--;\\n        }\\n\\n        return arr.Select(num => Math.Abs(num)).Sum();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinSteps(string s, string t) {\\n        int[] arr = new int[26];\\n\\n        foreach(char c in s)\\n        {\\n            arr[c - \\'a\\']++;\\n        }\\n\\n        foreach(char c in t)\\n        {\\n            arr[c - \\'a\\']--;\\n        }\\n\\n        return arr.Select(num => Math.Abs(num)).Sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873528,
                "title": "2186-minimum-number-of-steps-to-make-two-strings-anagram-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n\\n\\n        HashMap<Character,Integer> s1 = new HashMap<>();\\n\\n         for(char c : s.toCharArray()){\\n             s1.put(c,s1.getOrDefault(c,0)+1);\\n         }\\n         \\n         for(char c : t.toCharArray()){\\n             s1.put(c,s1.getOrDefault(c,0)-1);\\n         }\\n         int step = 0;\\n\\n         for(int count : s1.values()){\\n             step += Math.abs(count);\\n         }\\n         return step;\\n         \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n\\n\\n        HashMap<Character,Integer> s1 = new HashMap<>();\\n\\n         for(char c : s.toCharArray()){\\n             s1.put(c,s1.getOrDefault(c,0)+1);\\n         }\\n         \\n         for(char c : t.toCharArray()){\\n             s1.put(c,s1.getOrDefault(c,0)-1);\\n         }\\n         int step = 0;\\n\\n         for(int count : s1.values()){\\n             step += Math.abs(count);\\n         }\\n         return step;\\n         \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870790,
                "title": "slightly-improve-the-code-from-1347-minimum-number-of-steps-to-make-two-strings-anagram",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust slightly improve the code from 1347, but check in two ways now.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        s_count = Counter(s)\\n        t_count = Counter(t)\\n        result = 0\\n        print(s_count)\\n        print(t_count)\\n\\n        for key, count in s_count.items():\\n            if key not in t_count:\\n                result += count\\n            elif count > t_count[key]:\\n                result += (count - t_count[key])\\n\\n        for key, count in t_count.items():\\n            if key not in s_count:\\n                result += count\\n            elif count > s_count[key]:\\n                result += (count - s_count[key])\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        s_count = Counter(s)\\n        t_count = Counter(t)\\n        result = 0\\n        print(s_count)\\n        print(t_count)\\n\\n        for key, count in s_count.items():\\n            if key not in t_count:\\n                result += count\\n            elif count > t_count[key]:\\n                result += (count - t_count[key])\\n\\n        for key, count in t_count.items():\\n            if key not in s_count:\\n                result += count\\n            elif count > s_count[key]:\\n                result += (count - s_count[key])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866623,
                "title": "the-famous-hashmap-boi",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given solution aims to find the minimum number of steps required to make two strings, \\'s\\' and \\'t\\', anagrams of each other. It achieves this by calculating the count of characters in both strings and then identifying the characters that are exclusive to each string. By comparing these exclusive characters\\' frequencies, the solution determines how many characters need to be added or removed in each string to make them anagrams. Finally, the sum of the required changes for both strings gives the minimum steps needed to achieve an anagram.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe solution employs two unordered maps to store character frequencies for both strings. By subtracting the corresponding character frequencies between the two maps, it computes the count of characters exclusive to each string. The max function is used to ensure that only positive differences are considered, representing the characters that need to be added to one string to match the other. By summing up the changes needed for both strings, the solution provides the minimum steps necessary to make \\'s\\' and \\'t\\' anagrams.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        // char x freq for s and t\\n        unordered_map<char,int> s_chars;\\n        for(char c : s){\\n            s_chars[c]++;\\n        }\\n        unordered_map<char,int> t_chars;\\n        for(char c : t){\\n            t_chars[c]++;\\n        }      \\n\\n\\n        // count the number of characters exclusive in s\\n        int s_exclusive_count = 0;\\n        for(auto it = s_chars.begin(); it != s_chars.end(); ++it){\\n            int curr = it->second - t_chars[it->first];\\n            s_exclusive_count += max(0 , curr);\\n        }\\n        // count eh number of charactes exclusive in t  \\n        int t_exclusive_count = 0;\\n        for(auto it = t_chars.begin(); it != t_chars.end(); ++it){\\n            int curr = it->second - s_chars[it->first];\\n            t_exclusive_count += max(0 , curr);\\n        }      \\n\\n        return s_exclusive_count + t_exclusive_count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        // char x freq for s and t\\n        unordered_map<char,int> s_chars;\\n        for(char c : s){\\n            s_chars[c]++;\\n        }\\n        unordered_map<char,int> t_chars;\\n        for(char c : t){\\n            t_chars[c]++;\\n        }      \\n\\n\\n        // count the number of characters exclusive in s\\n        int s_exclusive_count = 0;\\n        for(auto it = s_chars.begin(); it != s_chars.end(); ++it){\\n            int curr = it->second - t_chars[it->first];\\n            s_exclusive_count += max(0 , curr);\\n        }\\n        // count eh number of charactes exclusive in t  \\n        int t_exclusive_count = 0;\\n        for(auto it = t_chars.begin(); it != t_chars.end(); ++it){\\n            int curr = it->second - s_chars[it->first];\\n            t_exclusive_count += max(0 , curr);\\n        }      \\n\\n        return s_exclusive_count + t_exclusive_count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862448,
                "title": "very-optimal-and-short-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s , string t){\\n        vector<int>v(26,0),u(26,0);\\n        int sum=0;\\n        for(auto i:s){\\n            v[i-\\'a\\']++;\\n        }\\n        for(auto i:t){\\n            u[i-\\'a\\']++;\\n        }\\n        for(int i=0; i<26; i++){\\n            sum+=(abs(v[i]-u[i]));\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s , string t){\\n        vector<int>v(26,0),u(26,0);\\n        int sum=0;\\n        for(auto i:s){\\n            v[i-\\'a\\']++;\\n        }\\n        for(auto i:t){\\n            u[i-\\'a\\']++;\\n        }\\n        for(int i=0; i<26; i++){\\n            sum+=(abs(v[i]-u[i]));\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825253,
                "title": "share-my-solution",
                "content": "# Intuition\\n\\nAgain. Focus on fundamentals. It should be obvious that operations, where the characters are added and everything doens\\'t matter. For two strings to be anagrams of each other, they need to contain the same characters. Okay great. But how do we contain the same characters? Just count what characters occur in each string, and get the diff and then sum all the diff up. \\n\\nOne handy trick is to subtract the elements and keep the absolute difference. \\n\\n\\n# Approach\\n\\n1. Count characters in both the strings.\\n2. Sum the absolute difference. That is the result.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n- \\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] a = new int[26];\\n        int[] b = new int[26];\\n\\n        for (char ch: s.toCharArray())\\n            a[ch - \\'a\\']++;\\n\\n        for (char ch: t.toCharArray())\\n            b[ch - \\'a\\']++;   \\n\\n        int cnt = 0;\\n        for (int i=0; i<26; i++) {\\n            cnt+=Math.abs(a[i]-b[i]);\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] a = new int[26];\\n        int[] b = new int[26];\\n\\n        for (char ch: s.toCharArray())\\n            a[ch - \\'a\\']++;\\n\\n        for (char ch: t.toCharArray())\\n            b[ch - \\'a\\']++;   \\n\\n        int cnt = 0;\\n        for (int i=0; i<26; i++) {\\n            cnt+=Math.abs(a[i]-b[i]);\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3822209,
                "title": "simple-java-solution-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n+m) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n+m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int freq_s[]=new int[26];\\n        int freq_t[]=new int[26];\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            freq_s[c-\\'a\\']+=1;\\n        }\\n        for(int i=0;i<t.length();i++){\\n            char c=t.charAt(i);\\n            freq_t[c-\\'a\\']+=1;\\n        }\\n        int count=0;\\n        for(int i=0;i<freq_s.length;i++){\\n            if(freq_s[i]>freq_t[i]){\\n                count+=(freq_s[i]-freq_t[i]);\\n            }\\n            if(freq_t[i]>freq_s[i]){\\n                count+=(freq_t[i]-freq_s[i]);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int freq_s[]=new int[26];\\n        int freq_t[]=new int[26];\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            freq_s[c-\\'a\\']+=1;\\n        }\\n        for(int i=0;i<t.length();i++){\\n            char c=t.charAt(i);\\n            freq_t[c-\\'a\\']+=1;\\n        }\\n        int count=0;\\n        for(int i=0;i<freq_s.length;i++){\\n            if(freq_s[i]>freq_t[i]){\\n                count+=(freq_s[i]-freq_t[i]);\\n            }\\n            if(freq_t[i]>freq_s[i]){\\n                count+=(freq_t[i]-freq_s[i]);\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805286,
                "title": "minimum-number-of-steps-to-make-two-strings-anagram-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int count = 0;\\n        HashMap<Character,Integer> hs = new HashMap<Character,Integer>();\\n        HashMap<Character,Integer> hp = new HashMap<Character,Integer>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            hs.put(s.charAt(i),hs.getOrDefault(s.charAt(i),0)+1);\\n        }\\n        for(int i=0;i<t.length();i++)\\n        {\\n            hp.put(t.charAt(i),hp.getOrDefault(t.charAt(i),0)+1);\\n        }\\n        for(Map.Entry<Character,Integer> e:hs.entrySet())\\n        {\\n            if(hp.containsKey(e.getKey())==false)\\n            count=count+e.getValue();\\n            else if(e.getValue()!=hp.get(e.getKey()))\\n            count = count+Math.abs(e.getValue()-hp.get(e.getKey()));\\n        }\\n        for(Map.Entry<Character,Integer> e:hp.entrySet())\\n        {\\n            if(hs.containsKey(e.getKey())==false)\\n            count=count+e.getValue();\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int count = 0;\\n        HashMap<Character,Integer> hs = new HashMap<Character,Integer>();\\n        HashMap<Character,Integer> hp = new HashMap<Character,Integer>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            hs.put(s.charAt(i),hs.getOrDefault(s.charAt(i),0)+1);\\n        }\\n        for(int i=0;i<t.length();i++)\\n        {\\n            hp.put(t.charAt(i),hp.getOrDefault(t.charAt(i),0)+1);\\n        }\\n        for(Map.Entry<Character,Integer> e:hs.entrySet())\\n        {\\n            if(hp.containsKey(e.getKey())==false)\\n            count=count+e.getValue();\\n            else if(e.getValue()!=hp.get(e.getKey()))\\n            count = count+Math.abs(e.getValue()-hp.get(e.getKey()));\\n        }\\n        for(Map.Entry<Character,Integer> e:hp.entrySet())\\n        {\\n            if(hs.containsKey(e.getKey())==false)\\n            count=count+e.getValue();\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1819493,
                "content": [
                    {
                        "username": "tuor213",
                        "content": "it\\'s a good problem but it\\'s an easy problem, definitely. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "Easy peasy japanesey"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Far too similar to  [1347](https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/). Deleted two characters from my 1347 solution to solve this. \\n\\nThis may be medium, but it\\'s on the easy side. Perhaps I\\'ve been solving too many anagram problems, but this isn\\'t very difficult to intuit or code."
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Easy one!"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "This solution is giving correct answer but why TLE?\\n\\n        int c=0;\\n        int n1=s.size();\\n        int n2=t.size();\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(m.find(t[i])!=m.end() and m[t[i]]>0)\\n            {\\n                c++;\\n                m[t[i]]--;\\n                cout<<t[i]<<endl;\\n            }\\n        }\\n        return (n1+n2-2*c);"
                    },
                    {
                        "username": "Malay107",
                        "content": "Maybe its due to the cout statement in the 4th last line I tried after removing it...it takes lesser time\\n"
                    }
                ]
            },
            {
                "id": 1746067,
                "content": [
                    {
                        "username": "tuor213",
                        "content": "it\\'s a good problem but it\\'s an easy problem, definitely. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "Easy peasy japanesey"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Far too similar to  [1347](https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/). Deleted two characters from my 1347 solution to solve this. \\n\\nThis may be medium, but it\\'s on the easy side. Perhaps I\\'ve been solving too many anagram problems, but this isn\\'t very difficult to intuit or code."
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Easy one!"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "This solution is giving correct answer but why TLE?\\n\\n        int c=0;\\n        int n1=s.size();\\n        int n2=t.size();\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(m.find(t[i])!=m.end() and m[t[i]]>0)\\n            {\\n                c++;\\n                m[t[i]]--;\\n                cout<<t[i]<<endl;\\n            }\\n        }\\n        return (n1+n2-2*c);"
                    },
                    {
                        "username": "Malay107",
                        "content": "Maybe its due to the cout statement in the 4th last line I tried after removing it...it takes lesser time\\n"
                    }
                ]
            },
            {
                "id": 1708778,
                "content": [
                    {
                        "username": "tuor213",
                        "content": "it\\'s a good problem but it\\'s an easy problem, definitely. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "Easy peasy japanesey"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Far too similar to  [1347](https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/). Deleted two characters from my 1347 solution to solve this. \\n\\nThis may be medium, but it\\'s on the easy side. Perhaps I\\'ve been solving too many anagram problems, but this isn\\'t very difficult to intuit or code."
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Easy one!"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "This solution is giving correct answer but why TLE?\\n\\n        int c=0;\\n        int n1=s.size();\\n        int n2=t.size();\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(m.find(t[i])!=m.end() and m[t[i]]>0)\\n            {\\n                c++;\\n                m[t[i]]--;\\n                cout<<t[i]<<endl;\\n            }\\n        }\\n        return (n1+n2-2*c);"
                    },
                    {
                        "username": "Malay107",
                        "content": "Maybe its due to the cout statement in the 4th last line I tried after removing it...it takes lesser time\\n"
                    }
                ]
            },
            {
                "id": 1967553,
                "content": [
                    {
                        "username": "tuor213",
                        "content": "it\\'s a good problem but it\\'s an easy problem, definitely. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "Easy peasy japanesey"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Far too similar to  [1347](https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/). Deleted two characters from my 1347 solution to solve this. \\n\\nThis may be medium, but it\\'s on the easy side. Perhaps I\\'ve been solving too many anagram problems, but this isn\\'t very difficult to intuit or code."
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Easy one!"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "This solution is giving correct answer but why TLE?\\n\\n        int c=0;\\n        int n1=s.size();\\n        int n2=t.size();\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(m.find(t[i])!=m.end() and m[t[i]]>0)\\n            {\\n                c++;\\n                m[t[i]]--;\\n                cout<<t[i]<<endl;\\n            }\\n        }\\n        return (n1+n2-2*c);"
                    },
                    {
                        "username": "Malay107",
                        "content": "Maybe its due to the cout statement in the 4th last line I tried after removing it...it takes lesser time\\n"
                    }
                ]
            },
            {
                "id": 1873949,
                "content": [
                    {
                        "username": "tuor213",
                        "content": "it\\'s a good problem but it\\'s an easy problem, definitely. "
                    },
                    {
                        "username": "ajinkode",
                        "content": "Easy peasy japanesey"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Far too similar to  [1347](https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram/). Deleted two characters from my 1347 solution to solve this. \\n\\nThis may be medium, but it\\'s on the easy side. Perhaps I\\'ve been solving too many anagram problems, but this isn\\'t very difficult to intuit or code."
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Easy one!"
                    },
                    {
                        "username": "arshikamishra",
                        "content": "This solution is giving correct answer but why TLE?\\n\\n        int c=0;\\n        int n1=s.size();\\n        int n2=t.size();\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(m.find(t[i])!=m.end() and m[t[i]]>0)\\n            {\\n                c++;\\n                m[t[i]]--;\\n                cout<<t[i]<<endl;\\n            }\\n        }\\n        return (n1+n2-2*c);"
                    },
                    {
                        "username": "Malay107",
                        "content": "Maybe its due to the cout statement in the 4th last line I tried after removing it...it takes lesser time\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Time to Complete Trips",
        "question_content": "<p>You are given an array <code>time</code> where <code>time[i]</code> denotes the time taken by the <code>i<sup>th</sup></code> bus to complete <strong>one trip</strong>.</p>\n\n<p>Each bus can make multiple trips <strong>successively</strong>; that is, the next trip can start <strong>immediately after</strong> completing the current trip. Also, each bus operates <strong>independently</strong>; that is, the trips of one bus do not influence the trips of any other bus.</p>\n\n<p>You are also given an integer <code>totalTrips</code>, which denotes the number of trips all buses should make <strong>in total</strong>. Return <em>the <strong>minimum time</strong> required for all buses to complete <strong>at least</strong> </em><code>totalTrips</code><em> trips</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> time = [1,2,3], totalTrips = 5\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\n- At time t = 1, the number of trips completed by each bus are [1,0,0]. \n  The total number of trips completed is 1 + 0 + 0 = 1.\n- At time t = 2, the number of trips completed by each bus are [2,1,0]. \n  The total number of trips completed is 2 + 1 + 0 = 3.\n- At time t = 3, the number of trips completed by each bus are [3,1,1]. \n  The total number of trips completed is 3 + 1 + 1 = 5.\nSo the minimum time needed for all buses to complete at least 5 trips is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> time = [2], totalTrips = 1\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nThere is only one bus, and it will complete its first trip at t = 2.\nSo the minimum time needed to complete 1 trip is 2.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= time.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= time[i], totalTrips &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1802416,
                "title": "c-answer-on-binary-search-list-of-related-problems",
                "content": "In this type of questions (where question want some minimum/ maximum / at least ) we use concept of Binary search more formally this is a technique which generally called as **\"Answer on Binary Search\"** (some people also say  Binary Search on Answer) .\\n\\n**Brute Force** -\\n\\nWe will check whether the minimum time can be 1 , then 2  , then 3 .......... untill we found an answer.\\n\\n**BInary Search**\\n\\nCan we do something better ? , why we have to check linearly ? instead we can try Binary search , but how ?\\n\\nLet me take a simple scenario -\\n\\nsuppose I take minimum time as 10 and this can not be the minimum time , then 9 also cannot be minimum time , 8 can\\'t in general less than 10 cannot be answer , so instead of check every value we will check using Binary search if we find some valid condition we will move our left and right pointer accordingly.\\n\\n```\\nPSUDO CODE-\\n-------------\\nint check(a,mid)\\n{\\n\\t// find answer using this mid\\n}\\nwhile(l<r)\\n{\\n\\tm = (l+r)/2;\\n\\tif(check(arr,m)>=givenK)\\n\\t//\\tmove left or right accordingly\\n\\telse\\n\\t//\\tmove left or right accordingly\\n}\\nreturn ans;\\n```\\n\\nIn this question , we have to find minimum time \\n- let\\'s take the **lowestTime can be 1** and **highestTime can be as large as 1e14** (10^14) , \\n- now we will find for given **mid** what will be the answer (which is to count totalTrips at time = mid) \\n- if we get **number of trips >= requiredTrips** , then we have to **decrease** the time , that is why I moved my right pointer which is **highestTime** ,\\n- if we get number of **trips < requiredTrips** , then we have to **increase** the time , that is why I moved my left pointer which is **lowestTime**\\n- finally **return lowestTime**\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\t// this function will count totalTrips for the given time\\n\\t// a = [1,2,3] , and at time 3 how many trips we can take? \\n\\t// 3/1 + 3/2 + 3/3 => 3 + 1 + 1 = 5 Trips\\n    long long int numberOfTripsForGivenTime(vector<int>&a , long long int givenTime)\\n    {\\n        long long int totalTrips = 0;\\n        for(auto x : a)\\n        {\\n            // convert it to long long int \\n            long long int val = x;\\n\\t\\t\\t\\n            totalTrips += (givenTime / val);\\n        }\\n        return totalTrips;\\n    }\\n    long long minimumTime(vector<int>& arr ,  int totalTrips) {\\n        long long int lowestTime = 1;\\n        long long int highestTime = 1e14;\\n        while(lowestTime<highestTime)\\n        {\\n            long long int mid = lowestTime + (highestTime-lowestTime)/2;\\n            \\n            if(numberOfTripsForGivenTime(arr , mid) >= totalTrips)\\n                highestTime = mid;\\n            else\\n                lowestTime = mid+1;\\n        }\\n        return lowestTime;\\n    }\\n};\\n```\\n**Time Complexity is - O(NlogD) , where D is 1e14\\nSpace Complexity is - O(1)**\\n\\nAlso If you want to practice more such **\"Answer on Binary Search\"** then you can **check below questions** , also if you find such more add it to comments will update.\\n\\n**Easy**\\nhttps://leetcode.com/problems/arranging-coins/\\n\\n**Medium**\\nhttps://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\\nhttps://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/\\nhttps://leetcode.com/problems/find-the-duplicate-number/\\nhttps://leetcode.com/problems/minimum-size-subarray-sum/\\nhttps://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/\\nhttps://leetcode.com/problems/koko-eating-bananas/   [google]\\nhttps://leetcode.com/problems/path-with-minimum-effort/\\nhttps://leetcode.com/problems/most-beautiful-item-for-each-query/\\nhttps://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/\\nhttps://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/\\nhttps://leetcode.com/problems/heaters/\\nhttps://leetcode.com/problems/minimum-absolute-sum-difference/\\nhttps://leetcode.com/problems/frequency-of-the-most-frequent-element/\\n\\n**Hard**\\nhttps://leetcode.com/problems/swim-in-rising-water/\\nhttps://leetcode.com/problems/split-array-largest-sum/ [ good question can be done using DP but BS is amazing][Google]\\nhttps://leetcode.com/problems/kth-smallest-number-in-multiplication-table/\\nhttps://leetcode.com/problems/nth-magical-number/\\nhttps://leetcode.com/problems/find-k-th-smallest-pair-distance/\\nhttps://leetcode.com/problems/maximum-running-time-of-n-computers/\\n\\nIf you like this , please upvote \\u2B06\\uFE0F.\\nGood Luck , keep coding \\u2764\\uFE0F.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nPSUDO CODE-\\n-------------\\nint check(a,mid)\\n{\\n\\t// find answer using this mid\\n}\\nwhile(l<r)\\n{\\n\\tm = (l+r)/2;\\n\\tif(check(arr,m)>=givenK)\\n\\t//\\tmove left or right accordingly\\n\\telse\\n\\t//\\tmove left or right accordingly\\n}\\nreturn ans;\\n```\n```\\nclass Solution {\\npublic:\\n\\t// this function will count totalTrips for the given time\\n\\t// a = [1,2,3] , and at time 3 how many trips we can take? \\n\\t// 3/1 + 3/2 + 3/3 => 3 + 1 + 1 = 5 Trips\\n    long long int numberOfTripsForGivenTime(vector<int>&a , long long int givenTime)\\n    {\\n        long long int totalTrips = 0;\\n        for(auto x : a)\\n        {\\n            // convert it to long long int \\n            long long int val = x;\\n\\t\\t\\t\\n            totalTrips += (givenTime / val);\\n        }\\n        return totalTrips;\\n    }\\n    long long minimumTime(vector<int>& arr ,  int totalTrips) {\\n        long long int lowestTime = 1;\\n        long long int highestTime = 1e14;\\n        while(lowestTime<highestTime)\\n        {\\n            long long int mid = lowestTime + (highestTime-lowestTime)/2;\\n            \\n            if(numberOfTripsForGivenTime(arr , mid) >= totalTrips)\\n                highestTime = mid;\\n            else\\n                lowestTime = mid+1;\\n        }\\n        return lowestTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266855,
                "title": "all-binary-search-problems",
                "content": "**Good Binary Search Problems**\\n* [1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/)\\n* [1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/)\\n* [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)\\n* [1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n* [1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)\\n* [1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n* [2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/)\\n* [1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/)\\n* [774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/)\\n* [410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n* [1539. Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/)\\n* [162. Find Peak Element](https://leetcode.com/problems/find-peak-element/)\\n* [441. Arranging Coins](https://leetcode.com/problems/arranging-coins/)\\n* [378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)\\n* [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\n* [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)\\n* [1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/)\\n* [1631. Path With Minimum Effort](https://leetcode.com/problems/path-with-minimum-effort/)\\n* [2070. Most Beautiful Item for Each Query](https://leetcode.com/problems/most-beautiful-item-for-each-query/)\\n* [475. Heaters](https://leetcode.com/problems/heaters/)\\n* [1818. Minimum Absolute Sum Difference](https://leetcode.com/problems/minimum-absolute-sum-difference/)\\n* [1838. Frequency of the Most Frequent Element](https://leetcode.com/problems/frequency-of-the-most-frequent-element/)\\n* [778. Swim in Rising Water](https://leetcode.com/problems/swim-in-rising-water/)\\n* [668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/)\\n* [878. Nth Magical Number](https://leetcode.com/problems/nth-magical-number/)\\n* [719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)\\n* [2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\\n* [1287. Element Appearing More Than 25% In Sorted Array](https://leetcode.com/problems/element-appearing-more-than-25-in-sorted-array/)\\n* [34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\\n* [774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/)\\n* [1150. Check If a Number Is Majority Element in a Sorted Array](https://leetcode.com/problems/check-if-a-number-is-majority-element-in-a-sorted-array/)\\n* [1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n* [981. Time Based Key-Value Store](https://leetcode.com/problems/time-based-key-value-store/)\\n* [1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/)\\n* [704. Binary Search](https://leetcode.com/problems/binary-search/)\\n* [69. Sqrt(x)](https://leetcode.com/problems/sqrtx/)\\n* [35. Search Insert Position](https://leetcode.com/problems/search-insert-position/)\\n* [278. First Bad Version](https://leetcode.com/problems/first-bad-version/)\\n* https://leetcode.com/discuss/interview-question/777057/the-painters-partition-problem \\n* https://www.codechef.com/problems/PREZ \\n* For more problems you can refer to this page :- https://leetcode.com/problemset/all/?topicSlugs=binary-search&page=1 \\n\\n![image](https://assets.leetcode.com/users/images/87bab3dd-fabf-4b71-9ac5-984d9015438e_1678160362.0612018.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Binary Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "**Good Binary Search Problems**\\n* [1552. Magnetic Force Between Two Balls](https://leetcode.com/problems/magnetic-force-between-two-balls/)\\n* [1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/)\\n* [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)\\n* [1011. Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n* [1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)\\n* [1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n* [2064. Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/)\\n* [1231. Divide Chocolate](https://leetcode.com/problems/divide-chocolate/)\\n* [774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/)\\n* [410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n* [1539. Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/)\\n* [162. Find Peak Element](https://leetcode.com/problems/find-peak-element/)\\n* [441. Arranging Coins](https://leetcode.com/problems/arranging-coins/)\\n* [378. Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)\\n* [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/)\\n* [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)\\n* [1760. Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/)\\n* [1631. Path With Minimum Effort](https://leetcode.com/problems/path-with-minimum-effort/)\\n* [2070. Most Beautiful Item for Each Query](https://leetcode.com/problems/most-beautiful-item-for-each-query/)\\n* [475. Heaters](https://leetcode.com/problems/heaters/)\\n* [1818. Minimum Absolute Sum Difference](https://leetcode.com/problems/minimum-absolute-sum-difference/)\\n* [1838. Frequency of the Most Frequent Element](https://leetcode.com/problems/frequency-of-the-most-frequent-element/)\\n* [778. Swim in Rising Water](https://leetcode.com/problems/swim-in-rising-water/)\\n* [668. Kth Smallest Number in Multiplication Table](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/)\\n* [878. Nth Magical Number](https://leetcode.com/problems/nth-magical-number/)\\n* [719. Find K-th Smallest Pair Distance](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)\\n* [2141. Maximum Running Time of N Computers](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\\n* [1287. Element Appearing More Than 25% In Sorted Array](https://leetcode.com/problems/element-appearing-more-than-25-in-sorted-array/)\\n* [34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\\n* [774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/)\\n* [1150. Check If a Number Is Majority Element in a Sorted Array](https://leetcode.com/problems/check-if-a-number-is-majority-element-in-a-sorted-array/)\\n* [1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\\n* [981. Time Based Key-Value Store](https://leetcode.com/problems/time-based-key-value-store/)\\n* [1201. Ugly Number III](https://leetcode.com/problems/ugly-number-iii/)\\n* [704. Binary Search](https://leetcode.com/problems/binary-search/)\\n* [69. Sqrt(x)](https://leetcode.com/problems/sqrtx/)\\n* [35. Search Insert Position](https://leetcode.com/problems/search-insert-position/)\\n* [278. First Bad Version](https://leetcode.com/problems/first-bad-version/)\\n* https://leetcode.com/discuss/interview-question/777057/the-painters-partition-problem \\n* https://www.codechef.com/problems/PREZ \\n* For more problems you can refer to this page :- https://leetcode.com/problemset/all/?topicSlugs=binary-search&page=1 \\n\\n![image](https://assets.leetcode.com/users/images/87bab3dd-fabf-4b71-9ac5-984d9015438e_1678160362.0612018.jpeg)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1802415,
                "title": "python3-java-c-binary-search-1-liner",
                "content": "* For any time `x`, we can have total trips = `\\u03A3(x / time[i]) where i in [0, time.size())` \\n* We need to minimize the above mentioned function total trips such that it is greater than or equal to the given variable `totalTrips`.\\n* We can use binary search.\\n* During the contest I got away with keeping `lo = 1` and `hi = 10 ^ 15`\\n* On further inspection of the problem we can deduce that max value of `x` can be `min(times) * totalTrips` . So that can be used as `hi`\\n<iframe src=\"https://leetcode.com/playground/RaXFHThN/shared\" frameBorder=\"0\" width=\"700\" height=\"300\"></iframe>\\n\\nTime Complexity: `O(nlog(min(time) * totalTrips))`\\n\\n**1 liner**:\\n```\\ndef minimumTime(self, time: List[int], totalTrips: int) -> int:\\n\\treturn bisect_left(range(1, 10**14), totalTrips, key= lambda x: sum(x // t for t in time)) + 1\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\ndef minimumTime(self, time: List[int], totalTrips: int) -> int:\\n\\treturn bisect_left(range(1, 10**14), totalTrips, key= lambda x: sum(x // t for t in time)) + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3266586,
                "title": "java-easy-binary-search-on-answers",
                "content": "**This is what we call Binary Search on Answers. First we need to see that what can be the range of time. The range of time will be lowest value of the time array and highest value will be minimum value in the time array multiplied by totalTrips because at worst case the bus with min time will do all trips which will be minimum time taken to do all trips or you can take maximum value in time array multiplied by totalTrips if you are thinking in this way that at worstcase the bus with highest time will do all the trips. As the question is asking for minimum time so first one makes more sense than later one. But both are correct because obviously it will be eliminating right half if it gets totalTrips done with that particular time. Then we just traverse through the ranges and using Binary Search we check if the totalTrips is possible to do in that time or not. If possible then it\\'s a possible answer and we are not sure that it\\'s our minimum time so we do high=mid and if it\\'s not possible then we move low to mid+1 because obviously we can\\'t perform our task within that time. Atlast we just return the low that points to the minimum time that will take to complete the totalTrips.**\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low=Long.MAX_VALUE;\\n        long high=0;\\n        long min=Long.MAX_VALUE;\\n        for(int it:time){\\n            low=Math.min(low,it);\\n            min=Math.min(min,it);\\n        }\\n        high=totalTrips*min;\\n        while(low<high){\\n            long mid=low+(high-low)/2;\\n            if(blackbox(mid,totalTrips,time)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean blackbox(long isvalidtime,int totalTrips,int[] time){\\n        long trips=0;\\n        for(int it:time){\\n            trips+=isvalidtime/it;\\n        }\\n        if(trips>=totalTrips)\\n            return true;\\n        return false;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/548ec5b7-8b53-4a1d-b750-e0c3569edfd7_1678152826.456712.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low=Long.MAX_VALUE;\\n        long high=0;\\n        long min=Long.MAX_VALUE;\\n        for(int it:time){\\n            low=Math.min(low,it);\\n            min=Math.min(min,it);\\n        }\\n        high=totalTrips*min;\\n        while(low<high){\\n            long mid=low+(high-low)/2;\\n            if(blackbox(mid,totalTrips,time)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean blackbox(long isvalidtime,int totalTrips,int[] time){\\n        long trips=0;\\n        for(int it:time){\\n            trips+=isvalidtime/it;\\n        }\\n        if(trips>=totalTrips)\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266714,
                "title": "clean-codes-full-explanation-binary-search-c-java-python3",
                "content": "# Intuition :\\n- Here we have to find the minimum time by all buses to complete at least `totalTrips` trips.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Detail Explanation to Approach :\\n- Initialize `l` to 1, and `r` to the minimum time required to complete any task multiplied by `totalTrips`. This is because the minimum time required to complete all tasks must be greater than or equal to the minimum time required to complete any single task multiplied by the number of tasks to be completed.\\n```\\n// Initialize the search range for minimum completion time\\nlong l = 1;\\nlong r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n```\\n- Now enter a binary search loop, where calculate the midpoint `m` between `l` and `r`. Then calculate the number of tasks that can be completed in `m` time using the numTrips function. \\n- If the number of completed tasks is greater than or equal to `totalTrips`, set `r` to `m`, since the minimum time required to complete all tasks must be less than or equal to `m`. Otherwise, set `l` to `m+1`, since the minimum time required to complete all tasks must be greater than `m`.\\n```\\nwhile (l < r) {\\n      // Calculate the midpoint of the search range\\n      final long m = (l + r) / 2;\\n      // Count the number of tasks that can be completed within m time\\n      if (numTrips(time, m) >= totalTrips)\\n        // If enough tasks can be completed within m time, search for smaller time\\n        r = m;\\n      else\\n        // If not enough tasks can be completed within m time, search for larger time\\n        l = m + 1;\\n    }\\n```\\n- Once the loop exits, return `l`, which is the minimum time required to complete all tasks.\\n```\\n// Return the minimum completion time\\n    return l;\\n```\\n# numTrips Function :\\n- The `numTrips` function is used to calculate the number of tasks that can be completed within a given time limit `m`. \\n- It takes an array of task completion times `time` and a time limit `m` as input, and returns the number of tasks that can be completed within that time limit.\\n# Working of numTrips Function :\\n- The function first converts the time array to a `LongStream` using the `asLongStream()` method of the Arrays class. This allows us to perform arithmetic operations on the elements of the array as long values, which avoids potential overflow issues when multiplying or dividing large integers.\\n- The function then uses the `reduce()` method of the `LongStream class` to calculate the sum of the floor division of m by each task completion time. The `reduce()` method takes an initial value of 0, which is the starting value for the reduction, and a lambda function that takes two arguments: a `subtotal`, which is the accumulated result of the reduction so far, and an `element of the stream`, which is the next value to be processed.\\n- The lambda function calculates the floor division of `m` by the task completion time, and adds the result to the `subtotal`. The `reduce()` method then returns the final result of the reduction, which is the total number of tasks that can be completed within the time limit `m`.\\n```\\nprivate long numTrips(int[] time, long m) \\n  {\\n    // Convert the time array to a LongStream to avoid overflow issues\\n    return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n    // Calculate the sum of the floor division of m by each task completion time\\n  }\\n```\\n- In summary, the `numTrips` function calculates the number of tasks that can be completed within a given time limit by iterating through the task completion times and summing the floor division of the time limit by each completion time.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : O(nlog(min(time)\\u22C5totalTrips))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n***Let\\'s Code it Up .\\nThere may be minor syntax difference in C++ and Python***\\n# Codes [C++ |Java |Python3] : With Comments\\n```Java []\\nclass Solution \\n{\\n  public long minimumTime(int[] time, int totalTrips) \\n  {\\n    // Initialize the search range for minimum completion time\\n    long l = 1;\\n    long r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n\\n    // Binary search for minimum completion time\\n    while (l < r) {\\n      // Calculate the midpoint of the search range\\n      final long m = (l + r) / 2;\\n      // Count the number of tasks that can be completed within m time\\n      if (numTrips(time, m) >= totalTrips)\\n        // If enough tasks can be completed within m time, search for smaller time\\n        r = m;\\n      else\\n        // If not enough tasks can be completed within m time, search for larger time\\n        l = m + 1;\\n    }\\n\\n    // Return the minimum completion time\\n    return l;\\n  }\\n\\n  // Helper function to count the number of tasks that can be completed within a given time\\n  private long numTrips(int[] time, long m) \\n  {\\n    // Convert the time array to a LongStream to avoid overflow issues\\n    return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n    // Calculate the sum of the floor division of m by each task completion time\\n  }\\n}\\n```\\n```C++ []\\nclass Solution {\\n public:\\n  long long minimumTime(vector<int>& time, int totalTrips) {\\n    // Initialize the search range for minimum completion time\\n    long long l = 1;\\n    long long r = *min_element(begin(time), end(time)) * static_cast<long>(totalTrips);\\n\\n    // Binary search for minimum completion time\\n    while (l < r) {\\n      // Calculate the midpoint of the search range\\n      const long long m = (l + r) / 2;\\n      // Count the number of tasks that can be completed within m time\\n      if (numTrips(time, m) >= totalTrips)\\n        // If enough tasks can be completed within m time, search for smaller time\\n        r = m;\\n      else\\n        // If not enough tasks can be completed within m time, search for larger time\\n        l = m + 1;\\n    }\\n\\n    // Return the minimum completion time\\n    return l;\\n  }\\n\\n  // Helper function to count the number of tasks that can be completed within a given time\\n  long numTrips(const vector<int>& times, long m) {\\n    // Calculate the sum of the floor division of m by each task completion time\\n    return accumulate(begin(times), end(times), 0L,\\n                      [&](long subtotal, int t) { return subtotal + m / t; });\\n  }\\n};\\n```\\n```Python []\\nclass Solution:\\n  def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n    # Initialize the search range for minimum completion time\\n    l = 1\\n    r = min(time) * totalTrips\\n\\n    # Binary search for minimum completion time\\n    while l < r:\\n      # Calculate the midpoint of the search range\\n      m = (l + r) // 2\\n      # Count the number of tasks that can be completed within m time\\n      if sum(m // t for t in time) >= totalTrips:\\n        # If enough tasks can be completed within m time, search for smaller time\\n        r = m\\n      else:\\n        # If not enough tasks can be completed within m time, search for larger time\\n        l = m + 1\\n\\n    # Return the minimum completion time\\n    return l\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/0750b919-9f6e-457f-9308-aa10888d887f_1678158066.3233209.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n// Initialize the search range for minimum completion time\\nlong l = 1;\\nlong r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n```\n```\\nwhile (l < r) {\\n      // Calculate the midpoint of the search range\\n      final long m = (l + r) / 2;\\n      // Count the number of tasks that can be completed within m time\\n      if (numTrips(time, m) >= totalTrips)\\n        // If enough tasks can be completed within m time, search for smaller time\\n        r = m;\\n      else\\n        // If not enough tasks can be completed within m time, search for larger time\\n        l = m + 1;\\n    }\\n```\n```\\n// Return the minimum completion time\\n    return l;\\n```\n```\\nprivate long numTrips(int[] time, long m) \\n  {\\n    // Convert the time array to a LongStream to avoid overflow issues\\n    return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n    // Calculate the sum of the floor division of m by each task completion time\\n  }\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```Java []\\nclass Solution \\n{\\n  public long minimumTime(int[] time, int totalTrips) \\n  {\\n    // Initialize the search range for minimum completion time\\n    long l = 1;\\n    long r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n\\n    // Binary search for minimum completion time\\n    while (l < r) {\\n      // Calculate the midpoint of the search range\\n      final long m = (l + r) / 2;\\n      // Count the number of tasks that can be completed within m time\\n      if (numTrips(time, m) >= totalTrips)\\n        // If enough tasks can be completed within m time, search for smaller time\\n        r = m;\\n      else\\n        // If not enough tasks can be completed within m time, search for larger time\\n        l = m + 1;\\n    }\\n\\n    // Return the minimum completion time\\n    return l;\\n  }\\n\\n  // Helper function to count the number of tasks that can be completed within a given time\\n  private long numTrips(int[] time, long m) \\n  {\\n    // Convert the time array to a LongStream to avoid overflow issues\\n    return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n    // Calculate the sum of the floor division of m by each task completion time\\n  }\\n}\\n```\n```C++ []\\nclass Solution {\\n public:\\n  long long minimumTime(vector<int>& time, int totalTrips) {\\n    // Initialize the search range for minimum completion time\\n    long long l = 1;\\n    long long r = *min_element(begin(time), end(time)) * static_cast<long>(totalTrips);\\n\\n    // Binary search for minimum completion time\\n    while (l < r) {\\n      // Calculate the midpoint of the search range\\n      const long long m = (l + r) / 2;\\n      // Count the number of tasks that can be completed within m time\\n      if (numTrips(time, m) >= totalTrips)\\n        // If enough tasks can be completed within m time, search for smaller time\\n        r = m;\\n      else\\n        // If not enough tasks can be completed within m time, search for larger time\\n        l = m + 1;\\n    }\\n\\n    // Return the minimum completion time\\n    return l;\\n  }\\n\\n  // Helper function to count the number of tasks that can be completed within a given time\\n  long numTrips(const vector<int>& times, long m) {\\n    // Calculate the sum of the floor division of m by each task completion time\\n    return accumulate(begin(times), end(times), 0L,\\n                      [&](long subtotal, int t) { return subtotal + m / t; });\\n  }\\n};\\n```\n```Python []\\nclass Solution:\\n  def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n    # Initialize the search range for minimum completion time\\n    l = 1\\n    r = min(time) * totalTrips\\n\\n    # Binary search for minimum completion time\\n    while l < r:\\n      # Calculate the midpoint of the search range\\n      m = (l + r) // 2\\n      # Count the number of tasks that can be completed within m time\\n      if sum(m // t for t in time) >= totalTrips:\\n        # If enough tasks can be completed within m time, search for smaller time\\n        r = m\\n      else:\\n        # If not enough tasks can be completed within m time, search for larger time\\n        l = m + 1\\n\\n    # Return the minimum completion time\\n    return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802443,
                "title": "java-python-3-binary-search-w-similar-problems",
                "content": "Similar to:\\n[1283. Find the Smallest Divisor Given a Threshold](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/discuss/446313/)\\n[1287. Element Appearing More Than 25% In Sorted Array](https://leetcode.com/problems/element-appearing-more-than-25-in-sorted-array/discuss/451290/JavaPython-3-O(n)-and-O(logn)-codes-w-brief-explanation-and-analysis.)\\n[1870. Minimum Speed to Arrive on Time](https://leetcode.com/problems/minimum-speed-to-arrive-on-time/discuss/1224657/JavaPython-3-Binary-Search-w-comment-and-brief-analysis.)\\n\\n\\nHere are more similar binary search problem list:\\n\\n[34. Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array)\\n[410. Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\\n[774. Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/)\\n[875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)\\n[1011. Capacity To Ship Packages In N Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n[1150. Check If a Number Is Majority Element in a Sorted Array: Premium](https://leetcode.com/problems/check-if-a-number-is-majority-element-in-a-sorted-array)\\n[1231. Divide Chocolate: Premium](https://leetcode.com/problems/divide-chocolate/)\\n[1482. Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets)\\n[1539. Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/)\\n\\n---\\n\\nUse binary search to locate the minimum time, which cost `O(nlog(range))`, where `n = time.length, range = upper bound - lower bound`.\\n1. Specify search space range:\\na) lower bound is `0`;\\nb) upper bound:\\n\\nWe need to find worst case in order to get upper bound. \\n\\nAccording to the ranges in the problem, `1 <= time.length <= 10^5;\\n1 <= time[i], totalTrips <= 10^7`.\\n\\nThe less the number of  buses, the greater value of `time` and `totalTrips` are, the more time are needed. We can use the extreme of each, `1`, `10 ^ 7` and `10 ^ 7` to locate the worst case.\\n\\nTherefore, the longest time, the upper bound of the binary search space, `10 ^ 7 * 10 ^ 7`, which corresponds to the worst case that only `1` bus is available and it need to finish `10 ^ 7` trips.\\n\\n2. For each search iteration, try the middle value of the current search space; If in `need` time all buses can NOT finish the `totalTrips`, set lower bound to middle value + 1; otherwise, set upper bound to middle value;\\n3. repeat 2 till lower bound and upper bound are same, and that is our solution.\\n\\n```java\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lo = 0, hi = 100_000_000_000_000L;\\n        while (lo < hi) {\\n            long need = lo + (hi - lo) / 2;\\n            long trips = 0;\\n            for (int t : time) {\\n                trips += need / t;\\n            }\\n            if (trips < totalTrips) {\\n                lo = need + 1;\\n            }else {\\n                hi = need;\\n            }\\n        }\\n        return lo;\\n    }\\n```\\n\\n```python\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        lo, hi = 0, 10 ** 14\\n        while lo < hi:\\n            need = lo + (hi - lo) // 2\\n            trips = sum(need // t for t in time)\\n            if trips < totalTrips:\\n                lo = need + 1\\n            else:\\n                hi = need\\n        return lo\\n```\\n\\nSince Python 3.10, we can simplify the above as:\\n```python\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        return bisect.bisect_left(range(10 ** 14), totalTrips, key=lambda i: sum(i // t for t in time))\\n```\\nHere `key` specifies a key function of one argument that is used to extract a comparison key from each element in the array. To support searching complex records, the key function is not applied to the `i` value.\\n\\nFor more details of the new feature, please refer to [python 3 doc](https://docs.python.org/3/library/bisect.html).\\n\\n**Analysis**\\n\\nTime: `O(nlog(range))`, space: `O(1)`, where `n = time.length, range = upper bound - lower bound`.\\n\\n----\\n\\n**Q & A**\\nQ1: Why  in the code you use `hi = need;` not `hi = need - 1;`?\\nA1: This is a boundary condition question.\\n` if (trips < totalTrips)`, the speed, `need`, is definitely less than the solution, and hence we can safely set lower bound as `lo = need + 1;`\\nIn the other `if` conditional branch, `else` statement, `trips >= totalTrips` implies that it is possible `trips == totalTrips` and `need` is solution accordingly, hence we must set upper bound `hi = need` instead of `hi = need - 1`, which could miss the correct solution.\\n\\nQ2: Why in the following code using `Long.MAX_VALUE` as upper bound of the binary search space will cause `long` overflow?\\n```java\\npublic long minimumTime(int[] time, int totalTrips) {\\n\\n    long tmax = Long.MAX_VALUE;\\n    \\n    long tmin = 0;\\n    \\n    while(tmin<=tmax){\\n        \\n        long mid = tmin + (tmax-tmin)/2;\\n        \\n        long t=0;\\n        \\n        for(int i:time){\\n            t = t+mid/i;\\n        }\\n        \\n        if(t<totalTrips){\\n            tmin = mid+1;\\n        }else{\\n            tmax = mid-1;\\n        }\\n        \\n    }\\n   \\n    return tmin;\\n```\\nA2: the summation of the time during the for loop is the culprit:\\n```\\n        for(int i:time){\\n            t = t+mid/i;\\n        }\\n```\\n\\nQ3: How the expressions below are different:\\n`100_000_000_000_000L`, `100000000000000` and `(long) 1e14` ?\\nA3: `100000000000000` is invalid in Java, and the other two are OK.\\n\\n\\n**End of Q & A**\\n\\n----\\n\\nFeel free to ask in case you have any questions. Please **upvote** if the post is helpful.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lo = 0, hi = 100_000_000_000_000L;\\n        while (lo < hi) {\\n            long need = lo + (hi - lo) / 2;\\n            long trips = 0;\\n            for (int t : time) {\\n                trips += need / t;\\n            }\\n            if (trips < totalTrips) {\\n                lo = need + 1;\\n            }else {\\n                hi = need;\\n            }\\n        }\\n        return lo;\\n    }\\n```\n```python\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        lo, hi = 0, 10 ** 14\\n        while lo < hi:\\n            need = lo + (hi - lo) // 2\\n            trips = sum(need // t for t in time)\\n            if trips < totalTrips:\\n                lo = need + 1\\n            else:\\n                hi = need\\n        return lo\\n```\n```python\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        return bisect.bisect_left(range(10 ** 14), totalTrips, key=lambda i: sum(i // t for t in time))\\n```\n```java\\npublic long minimumTime(int[] time, int totalTrips) {\\n\\n    long tmax = Long.MAX_VALUE;\\n    \\n    long tmin = 0;\\n    \\n    while(tmin<=tmax){\\n        \\n        long mid = tmin + (tmax-tmin)/2;\\n        \\n        long t=0;\\n        \\n        for(int i:time){\\n            t = t+mid/i;\\n        }\\n        \\n        if(t<totalTrips){\\n            tmin = mid+1;\\n        }else{\\n            tmax = mid-1;\\n        }\\n        \\n    }\\n   \\n    return tmin;\\n```\n```\\n        for(int i:time){\\n            t = t+mid/i;\\n        }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1802431,
                "title": "java-c-python-detailed-explanation-with-intuition-o-nlog-k-binary-search-clean-concise",
                "content": "Maximum possible time = ~10^14     (from worst case constraints)\\n\\nDue to this we cannot iterate on time. It will give TLE.\\n\\n**Intution:** If we know total time of journey, then we can get how many trips each bus made.\\n\\nLets me illustrate this with an example:\\n\\nEg:  trip_time= 15,  time=[1, 2, 5]\\nNo. of trips made by bus 0: 15/1 = 15\\nNo. of trips made by bus 1: 15/2 = 7  (not 7.5 complete trips are 7)\\nNo. of trips made by bus 2: 15/5 = 3\\n\\nAnd we can add them all to get total no of trips made by all buses = 15+7+ 3 = 25\\n\\nTotal time of trip lies between 1 and 10^14     (acc to worst case constraints)\\n**Explanation:** \\nassume there is just one bus\\nwhen time[i]=1 & totalTrips=1 : time_of_trip= **1**\\nwhen time[i]= 10^7 & totalTrips=10^7 : time_of_trip= 10^7 * 10^7 = **10^14**\\n\\nTime of trip lies in this range. And as time increases, no of trips increases. \\nSo there will be a time where the no of trips will become just >= totalTrips.\\nWe just need to binary search that time.\\n\\n**C++:** \\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long anstillnow=-1;\\n        \\n        long long left=1, right= 100000000000001;          //can also write this as 1+1e14\\n\\t\\t\\n        while(left<=right){\\n            long long mid= left+ (right-left)/2;   // find mid point like this to avoid overflow\\n            long long curr_trips=0;\\n            for(int t: time){\\n                curr_trips+= mid/t;\\n            }\\n            \\n            if(curr_trips>=totalTrips){ \\n                anstillnow=mid;\\n                right=mid-1;\\n            }\\n            \\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        \\n        return anstillnow;\\n    }\\n};\\n```\\n\\n\\n**Java:**  \\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long anstillnow=-1;\\n        \\n        long left=1, right= 100000000000001L;\\n        \\n        while(left<=right){\\n            long mid= left+ (right-left)/2;  //find mid point like this to avoid overflow\\n            long curr_trips=0;\\n            for(int t: time){\\n                curr_trips+= mid/t;\\n            }\\n            \\n            if(curr_trips>=totalTrips){\\n                anstillnow=mid;\\n                right=mid-1;\\n            }\\n            \\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        \\n        return anstillnow;        \\n    }\\n}\\n```\\n\\n**Python:** \\n```\\nclass Solution(object):\\n    def minimumTime(self, time, totalTrips):\\n        anstillnow=-1;\\n        left=1;\\n        right= 100000000000001;\\n        \\n        while(left<=right):\\n            mid= left+ (right-left)/2      #find mid point like this to avoid overflow\\n            \\n            curr_trips=0;\\n            \\n            for t in time:\\n                curr_trips+= mid/t\\n            \\n            if(curr_trips>=totalTrips):\\n                anstillnow=mid\\n                right=mid-1\\n            \\n            else:\\n                left=mid+1\\n\\n        return anstillnow\\n ```       \\n\\n\\n**Time Complexity Analysis:**\\nTime: O(N log (K))  :     where N is no of buses & K is 10^14 (range of binary search)\\nSpace: O(1) :                No extra space used. \\n\\n\\n\\n\\n**Please upvote if you liked it.**\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long anstillnow=-1;\\n        \\n        long long left=1, right= 100000000000001;          //can also write this as 1+1e14\\n\\t\\t\\n        while(left<=right){\\n            long long mid= left+ (right-left)/2;   // find mid point like this to avoid overflow\\n            long long curr_trips=0;\\n            for(int t: time){\\n                curr_trips+= mid/t;\\n            }\\n            \\n            if(curr_trips>=totalTrips){ \\n                anstillnow=mid;\\n                right=mid-1;\\n            }\\n            \\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        \\n        return anstillnow;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long anstillnow=-1;\\n        \\n        long left=1, right= 100000000000001L;\\n        \\n        while(left<=right){\\n            long mid= left+ (right-left)/2;  //find mid point like this to avoid overflow\\n            long curr_trips=0;\\n            for(int t: time){\\n                curr_trips+= mid/t;\\n            }\\n            \\n            if(curr_trips>=totalTrips){\\n                anstillnow=mid;\\n                right=mid-1;\\n            }\\n            \\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        \\n        return anstillnow;        \\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def minimumTime(self, time, totalTrips):\\n        anstillnow=-1;\\n        left=1;\\n        right= 100000000000001;\\n        \\n        while(left<=right):\\n            mid= left+ (right-left)/2      #find mid point like this to avoid overflow\\n            \\n            curr_trips=0;\\n            \\n            for t in time:\\n                curr_trips+= mid/t\\n            \\n            if(curr_trips>=totalTrips):\\n                anstillnow=mid\\n                right=mid-1\\n            \\n            else:\\n                left=mid+1\\n\\n        return anstillnow\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1802781,
                "title": "binary-search",
                "content": "For a given time `m`, we can calculate how many trips we can complete. So, we can binary-search for the minimum `m`.\\n\\nFor this problem, the tricky part is to find the maximum bound for the search. Took me a few WA to get it right.\\n\\n**C++**\\n```cpp\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n    long long l = 0, r = LLONG_MAX / time.size();\\n    while (l < r) {\\n        long long m = (l + r) / 2, trips = 0;\\n        for (int t : time)\\n            trips += m / t;\\n        if (trips < totalTrips)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n    long long l = 0, r = LLONG_MAX / time.size();\\n    while (l < r) {\\n        long long m = (l + r) / 2, trips = 0;\\n        for (int t : time)\\n            trips += m / t;\\n        if (trips < totalTrips)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802433,
                "title": "python-solution-detailed-article-on-binary-search-on-answer",
                "content": "Upvote this artice if you find this helpful\\u2B06\\uFE0F.\\n### Code: \\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        r = min(time) * totalTrips + 1 # This is the worst case answer possible for any case. Could use big values like 10^15 as well but they might slow the time down for smaller cases.\\n        l = 0\\n        ans = 0\\n\\n        def check_status(expected_time: int) -> int:\\n            nonlocal ans\\n            count = 0\\n            for i in time:\\n                count += expected_time // i # Total trips with time expected_time should be integer part of expected_time // i\\n            if count < totalTrips:\\n                return 1 # Since number of trips are less then required, left moves to mid\\n            elif count >= totalTrips:\\n                ans = expected_time # stores the latest result. This is guaranteed to be the minimum possible answer.\\n                return -1 # Since number of trips are greater/equal to required, right moves to mid\\n\\n        while l < r-1: # Till Binary Search can continue. \\n            mid = (l + r) // 2 # mid is the current expected time.\\n            status = check_status(mid) # The return values 1/-1 in check_status function determines which pointer to move.\\n            if status == 1:\\n                l = mid\\n            else:\\n                r = mid\\n                \\n        return ans\\n```\\n\\n### Concept of Binary Search on Answer:\\nThe best way to explain Binary Search the Answer is that we use binary search to guess the answer to the problem. **By guessing we mean that we will get several \\u201CYES\\u201D or \\u201CNO\\u201D feedback or maybe \\u201Ctoo high\\u201D, \\u201Ctoo low\\u201D, or \\u201Cexactly\\u201D responses.** Since we need the minimum answer Binary Search tries to converge on the smallest possible answer till the possibility exists. \\n\\n**Binary Search on Answer has 3 basic requirements:**\\n1. The problem must have multiple possible answers. ***[Range of possible solutions]***\\n2. The problem must be an optimization problem. ***[Minimizing the possible answer]***\\n3. The problem must have a function/criterion to determine when to update `left` and `right` pointers. ***[Criterion to update pointers]***\\n\\n**NOTE: *Here answers do not mean the minimum possible value (actual answer) but the values that satisfy the totalTrips condition.***\\n**NOTE: *The // operation in python returns the integer value of a division. 8/3 = 2.66 whereas 8//2 = 2. I have used this notation in this article***\\n\\n***Our problem fulfills all the requirements.*** \\n\\n**Requirement 1:** For example if `time = [1,2,3] & totalTrips = 5` then the answer is 3. Now one can easily say that if 3 satisfies the 5 totalTrips condition then 4, 5, 6, 7, ... (basically numbers greater than 3) can easily satisfy the 5 totalTrips condition. Hence their are multiple possible answers.\\n\\n**Requirement 2:** As we saw that for `time = [1,2,3] & totalTrips = 5` then the possible answers could be 3, 4, 5, 6, ... But since the problem asks the smallest time hence the correct answer is 3. Thus we also want to select the minimium possible answer as our final answer.\\n\\n**Requirement 3:** This is the most important part of the problem. For this problem this one is quite straight forward. Take a value, say 8. Traverse over `time` list. `for i = 1` the total number of trips in time 8 is 8//1 = 8 || `for i = 2` total number of trips in time 8 is 8//2 = 4 || `for i = 3` total number of trips in time 8 is 8//3 = 2. The following function is our criterion:\\n```\\ndef check_status(expected_time: int) -> int:\\n    count = 0\\n    for i in time:\\n        count += expected_time // i\\n        if count < totalTrips:\\n            return 1  # Since count is less than the totalTrips, we are searching too low\\n\\t\\t\\t# Update left pointer to mid(expected_time).\\n        elif count >= totalTrips:\\n            return -1  # Since count is greater than / equal to the totalTrips, we are searching too high or perfectly.\\n\\t\\t\\t# Update right pointer to mid(expected_time).\\n```\\nThe updation part is taken care of by the return value of the function 1 for left and -1 for right pointer.\\n\\n**Now look at the code on top of this article.** \\u2B06\\uFE0F\\n\\n### List of problems that also uses Binary Search on Answer:\\n- [https://www.codechef.com/problems/PREZ/](https://www.codechef.com/problems/PREZ)\\n- [https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/)\\n- [https://leetcode.com/problems/arranging-coins/](https://leetcode.com/problems/arranging-coins/)\\n- [https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\\n- [https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)\\n- [https://leetcode.com/problems/find-the-duplicate-number/](https://leetcode.com/problems/find-the-duplicate-number/)\\n- [https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/)\\n- [https://leetcode.com/problems/path-with-minimum-effort/](https://leetcode.com/problems/path-with-minimum-effort/)\\n- [https://leetcode.com/problems/most-beautiful-item-for-each-query/](https://leetcode.com/problems/most-beautiful-item-for-each-query/)\\n- [https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/](https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/)\\n- [https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/)\\n- [https://leetcode.com/problems/heaters/](https://leetcode.com/problems/heaters/)\\n- [https://leetcode.com/problems/minimum-absolute-sum-difference/](https://leetcode.com/problems/minimum-absolute-sum-difference/)\\n- [https://leetcode.com/problems/frequency-of-the-most-frequent-element/](https://leetcode.com/problems/frequency-of-the-most-frequent-element/)\\n- [https://leetcode.com/problems/swim-in-rising-water/](https://leetcode.com/problems/swim-in-rising-water/)\\n- [https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/](https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/)\\n- [https://leetcode.com/problems/nth-magical-number/](https://leetcode.com/problems/nth-magical-number/)\\n- [https://leetcode.com/problems/find-k-th-smallest-pair-distance/](https://leetcode.com/problems/find-k-th-smallest-pair-distance/)\\n- [https://leetcode.com/problems/maximum-running-time-of-n-computers/](https://leetcode.com/problems/maximum-running-time-of-n-computers/)\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        r = min(time) * totalTrips + 1 # This is the worst case answer possible for any case. Could use big values like 10^15 as well but they might slow the time down for smaller cases.\\n        l = 0\\n        ans = 0\\n\\n        def check_status(expected_time: int) -> int:\\n            nonlocal ans\\n            count = 0\\n            for i in time:\\n                count += expected_time // i # Total trips with time expected_time should be integer part of expected_time // i\\n            if count < totalTrips:\\n                return 1 # Since number of trips are less then required, left moves to mid\\n            elif count >= totalTrips:\\n                ans = expected_time # stores the latest result. This is guaranteed to be the minimum possible answer.\\n                return -1 # Since number of trips are greater/equal to required, right moves to mid\\n\\n        while l < r-1: # Till Binary Search can continue. \\n            mid = (l + r) // 2 # mid is the current expected time.\\n            status = check_status(mid) # The return values 1/-1 in check_status function determines which pointer to move.\\n            if status == 1:\\n                l = mid\\n            else:\\n                r = mid\\n                \\n        return ans\\n```\n```\\ndef check_status(expected_time: int) -> int:\\n    count = 0\\n    for i in time:\\n        count += expected_time // i\\n        if count < totalTrips:\\n            return 1  # Since count is less than the totalTrips, we are searching too low\\n\\t\\t\\t# Update left pointer to mid(expected_time).\\n        elif count >= totalTrips:\\n            return -1  # Since count is greater than / equal to the totalTrips, we are searching too high or perfectly.\\n\\t\\t\\t# Update right pointer to mid(expected_time).\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267566,
                "title": "simple-bruteforce-to-crazy-binary-search-code-like-a-pro",
                "content": "# Similar Problems:\\nA very good similar problem is this one:\\n- [875. Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/description/) You can follow my solution [\\uD83D\\uDC12 KOKO finds Hints then tries Binary Search || \\uD83D\\uDC12\\uD83D\\uDE80 Java C++\\n](https://leetcode.com/problems/koko-eating-bananas/solutions/3273872/koko-finds-hints-then-tries-binary-search-java-c/) The solution is pretty much the same.\\n\\n# Intuition\\nThe very first thing is coding how your mind thinks it should be done. Gradually increasing the time value and incrementing the trips done by each bus.\\n\\nThe bruteforce code:\\n\\n``` Java []\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        int[] trips = new int[time.length];\\n        int tripsDone = 0;\\n        int t = 0;\\n        while(tripsDone < totalTrips){\\n            t++;\\n            for(int i=0; i<time.length; i++){\\n                trips[i] = (trips[i]+1)%time[i];\\n                if(trips[i]==0){\\n                    tripsDone++;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n}\\n```\\nThis will result in TLE.\\nSee the problem statement. It clearly says that:\\n![image.png](https://assets.leetcode.com/users/images/05fc1f3f-ed20-43ee-bbb3-e9826e357a49_1678172112.3413932.png)\\n\\nSo, we cannot directly go with the iterative approach.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nThis is an application of binary search. We should try to include binary search. \\n**But how?**\\n**What will be the low and high variables?**\\n\\nThe value of time is very high. So, we better think of this as the high and low value. Then for current time value, we can iterate the loop to calculate the trips completed by each bus.\\n\\nIf the current time is **t** and a bus requires **bt** time to complete a trip, then by t time the bus will complete $$\\\\frac{t}{bt}$$ trips.\\nFor example let\\'s say t = 5. and bus trip completion time is $$bt = 2$$.\\nThen, by time $$t = 5$$, the bus will be able to complete $$5/2 = 2$$ trips.\\n\\n# Binary Search:\\n\\n``` Java []\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lowestTime = 1;\\n        long maxTime = 100000000000000L;\\n        while(lowestTime < maxTime){\\n            long mid = lowestTime + (maxTime-lowestTime)/2;\\n            if(tripsCompleted(time, mid) >= totalTrips){\\n                maxTime = mid;\\n            }\\n            else{\\n                lowestTime = mid+1;\\n            }\\n        }\\n        return lowestTime;\\n    }\\n\\n    private long tripsCompleted(int[] time, long currentTime){\\n        long totalTrips = 0;\\n        for(int t : time){\\n            long tmp = (long) t;\\n            totalTrips += (currentTime/tmp);\\n        }\\n        return totalTrips;\\n    }\\n}\\n\\n```\\n\\nThis problem has a flaw. This will be less efficient. A more efficient solution is:\\n\\n# Efficient Binary Search - [Beats 94%]\\n\\n``` Java []\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lowestTime = 1;\\n        long maxTime = 100000000000000L;\\n        while(lowestTime < maxTime){\\n            long mid = lowestTime + (maxTime-lowestTime)/2;\\n            long tripsDone = tripsCompleted(time, mid, totalTrips);\\n            if(tripsDone >= totalTrips){\\n                maxTime = mid;\\n            }\\n            else{\\n                lowestTime = mid+1;\\n            }\\n        }\\n        return lowestTime;\\n    }\\n\\n    private long tripsCompleted(int[] time, long currentTime, int totalTrips){\\n        long tripsDone = 0;\\n        for(int t : time){\\n            long tmp = (long) t;\\n            tripsDone += (currentTime/tmp);\\n            // instead of iterating the loop any further, break the loop.\\n            if(tripsDone >= totalTrips ){\\n                break;\\n            }\\n        }\\n        return tripsDone;\\n    }\\n}\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/f3cd7f8b-9553-4665-9191-d9e536538fa9_1678172716.6669576.png)\\n\\n\\n![No Upvotes, Have a Good Day.png](https://assets.leetcode.com/users/images/9e0340e0-c08e-4a47-af6e-a350027c72ee_1678190433.0235791.png)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "``` Java []\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        int[] trips = new int[time.length];\\n        int tripsDone = 0;\\n        int t = 0;\\n        while(tripsDone < totalTrips){\\n            t++;\\n            for(int i=0; i<time.length; i++){\\n                trips[i] = (trips[i]+1)%time[i];\\n                if(trips[i]==0){\\n                    tripsDone++;\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n}\\n```\n``` Java []\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lowestTime = 1;\\n        long maxTime = 100000000000000L;\\n        while(lowestTime < maxTime){\\n            long mid = lowestTime + (maxTime-lowestTime)/2;\\n            if(tripsCompleted(time, mid) >= totalTrips){\\n                maxTime = mid;\\n            }\\n            else{\\n                lowestTime = mid+1;\\n            }\\n        }\\n        return lowestTime;\\n    }\\n\\n    private long tripsCompleted(int[] time, long currentTime){\\n        long totalTrips = 0;\\n        for(int t : time){\\n            long tmp = (long) t;\\n            totalTrips += (currentTime/tmp);\\n        }\\n        return totalTrips;\\n    }\\n}\\n\\n```\n``` Java []\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lowestTime = 1;\\n        long maxTime = 100000000000000L;\\n        while(lowestTime < maxTime){\\n            long mid = lowestTime + (maxTime-lowestTime)/2;\\n            long tripsDone = tripsCompleted(time, mid, totalTrips);\\n            if(tripsDone >= totalTrips){\\n                maxTime = mid;\\n            }\\n            else{\\n                lowestTime = mid+1;\\n            }\\n        }\\n        return lowestTime;\\n    }\\n\\n    private long tripsCompleted(int[] time, long currentTime, int totalTrips){\\n        long tripsDone = 0;\\n        for(int t : time){\\n            long tmp = (long) t;\\n            tripsDone += (currentTime/tmp);\\n            // instead of iterating the loop any further, break the loop.\\n            if(tripsDone >= totalTrips ){\\n                break;\\n            }\\n        }\\n        return tripsDone;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266509,
                "title": "binary-search-optimized-approach-easy-to-understand-detailed-explanation",
                "content": "\\n# Approach\\n1. minimum time can be 1, less than 1 can not possible.\\n2. maximum time can be (minimum element of given time array * total trips).\\n3. we use binary search to chose optimally minimum time that can be required to complete total trips\\n4. when number of trips completed by \\'mid\\' time >= total trips, then our ans can be \\'mid\\' time, but less than \\'mid\\' time can be possible, so we reduce our search space.\\n5. when number of trips completed by \\'mid\\' time < total trips, then our ans can not be \\'mid\\' time, but greater than \\'mid\\' time can be possible, so we increase our start to increase mid.\\n# Complexity\\n- Time complexity:$$O(N*logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long func(vector<int>&time, long long k)\\n    {\\n        long long ans=0;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            ans+= k/time[i];\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) \\n    {\\n        long long s=1,e,ans=LONG_MAX;\\n        e = 1LL*(*min_element(time.begin(),time.end())) * totalTrips;\\n        while(s<=e)\\n        {\\n            long long mid = s + (e-s)/2;\\n            long long x = func(time,mid);\\n            if(x>=totalTrips)\\n            {\\n                ans = min(ans,mid);\\n                e = mid-1;\\n            }\\n            else\\n            {\\n                s = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If you feel this helpful then plz like and upvote this solution \\uD83D\\uDE0A\\nKEEP LEETCODING.............**\\n![upvote.png](https://assets.leetcode.com/users/images/01c55ef2-d34a-413f-b2cd-cc638dfc6117_1678151467.055072.png)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long func(vector<int>&time, long long k)\\n    {\\n        long long ans=0;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            ans+= k/time[i];\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) \\n    {\\n        long long s=1,e,ans=LONG_MAX;\\n        e = 1LL*(*min_element(time.begin(),time.end())) * totalTrips;\\n        while(s<=e)\\n        {\\n            long long mid = s + (e-s)/2;\\n            long long x = func(time,mid);\\n            if(x>=totalTrips)\\n            {\\n                ans = min(ans,mid);\\n                e = mid-1;\\n            }\\n            else\\n            {\\n                s = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266915,
                "title": "white-board-solution-easiest-binary-search-video-solution",
                "content": "# Video Solution\\nhttps://www.youtube.com/watch?v=NsXc-YNqnfE\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/73825ad0-f66c-4f7e-a372-c12538816db5_1678162987.0952618.png)\\n![image.png](https://assets.leetcode.com/users/images/edc9d287-1793-4912-bc9d-71e51c86107f_1678163002.0131874.png)\\n![image.png](https://assets.leetcode.com/users/images/bd7fe1b1-6594-40b7-93bc-f55fb5fe3c61_1678163020.4106433.png)\\n![image.png](https://assets.leetcode.com/users/images/c6612f6b-22cf-45e6-96a5-c87bbf249033_1678163032.5668771.png)\\n![image.png](https://assets.leetcode.com/users/images/27acffb8-af92-4113-9881-5a7cebb7c61a_1678163050.3291006.png)\\n![image.png](https://assets.leetcode.com/users/images/5a20110f-873b-4961-8f51-47ebe7fdb057_1678163064.138637.png)\\n![image.png](https://assets.leetcode.com/users/images/2ab6d9d8-507d-46cb-925c-d6fd4baf3981_1678163071.8577886.png)\\n![image.png](https://assets.leetcode.com/users/images/87fc699d-0ff2-4b56-83ff-3e7edf30fdbc_1678163085.2459826.png)\\n\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n\\n    bool is_possible(ll max_time, vector<int>& time, int totalTrips){\\n        ll number_of_trips_completed = 0;\\n        for(auto t : time){\\n            number_of_trips_completed += max_time/t;\\n        }\\n        return (number_of_trips_completed >= totalTrips);\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        ll l=1, r=(1e14);\\n        while(l < r){\\n            ll mid = (l+r)/2;\\n            if(is_possible(mid, time, totalTrips)){\\n                r = mid;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n\\n    bool is_possible(ll max_time, vector<int>& time, int totalTrips){\\n        ll number_of_trips_completed = 0;\\n        for(auto t : time){\\n            number_of_trips_completed += max_time/t;\\n        }\\n        return (number_of_trips_completed >= totalTrips);\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        ll l=1, r=(1e14);\\n        while(l < r){\\n            ll mid = (l+r)/2;\\n            if(is_possible(mid, time, totalTrips)){\\n                r = mid;\\n            }else{\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266718,
                "title": "leetcode-the-hard-way-binary-search",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [YouTube Channel](https://www.youtube.com/@leetcodethehardway) if you are interested.\\n\\n---\\n\\nThis is a classic problem of finding the smallest integer given a bound under a monotonic function.\\n\\nWe can perform binary search on the time needed to finish the trips, and we check that if we are able to complete totalTrips within the given amount of time. There are two components to this solution:\\n\\n- Binary Searching the smallest amount of time\\n- Checking if totalTrips can be completed given a time\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l = 0;\\n        long long r = 1LL * time[0] * totalTrips;\\n        while (l < r) {\\n            long long m = l + (r - l) / 2, trips = 0;\\n            for (auto x : time) trips += (m / x);\\n            if (trips < totalTrips) l = m + 1;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```\\n\\n```py\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        l, r = 0, time[0] * totalTrips\\n        while l < r:\\n            m = (l + r) // 2\\n            if sum(m // t for t in time) < totalTrips:\\n                l = m + 1\\n            else:\\n                r = m\\n        return l\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Binary Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l = 0;\\n        long long r = 1LL * time[0] * totalTrips;\\n        while (l < r) {\\n            long long m = l + (r - l) / 2, trips = 0;\\n            for (auto x : time) trips += (m / x);\\n            if (trips < totalTrips) l = m + 1;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n};\\n```\n```py\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        l, r = 0, time[0] * totalTrips\\n        while l < r:\\n            m = (l + r) // 2\\n            if sum(m // t for t in time) < totalTrips:\\n                l = m + 1\\n            else:\\n                r = m\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802813,
                "title": "c-binary-search-are-you-getting-tle-for-hidden-testcase-try-this",
                "content": "**Use long long and upper bound for end = 1e16.\\nmaximum bound = min(time) * totalTrips\\nIn worst case, we only use the fastest bus to complete all trips.\\nCredits - [tbne1905](https://leetcode.com/tbne1905/)\\nExplanation ->**\\nThis problem follows the same patterns a Koko eating bananas or Cutting Ropes or Shipping Packages problems.\\n\\nWhen we identify a range of possibilties and we are asked to minimize or maximize, think binary search. Here, the maximum possibleTime we can take is just getting the sum of all times and multiplying them with total trips. Minimum possible time is the minimum time in the list of times given.\\n\\nNow that we have our range, we apply bianry search on it. Cumpute the midTime. With this as our totalTime, see if it is possible to make the totalTrips. Since our goal is to MINIMIZE, we have 2 options:\\n\\n1.Reduce the range by moving the right ptr towards mid if we CAN make totalTrips.\\n2.Increase the range of values by moving left towards mid if we CAN\\'T make totalTrips\\n\\n```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n\\n\\tlong long start = 0 , end = 1e16;\\n\\n\\tlong long c = 1e16;\\n\\n\\twhile(start <= end)\\n\\t{\\n\\t\\tlong long mid = start + ((end-start)/2);\\n\\n\\t\\tlong long trip = 0;\\n\\t\\tfor(auto &val : time)\\n\\t\\t{\\n\\t\\t\\tlong long b = val;\\n\\t\\t\\ttrip += (mid/b);\\n\\t\\t\\tif(trip > totalTrips)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tif(trip >= totalTrips) \\n\\t\\t{\\n\\t\\t\\tc = min(c,mid);\\n\\t\\t\\tend = mid-1;\\n\\t\\t}\\n\\t\\telse start = mid+1;\\n\\n        }\\n        \\n        return c;\\n    }",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "**Use long long and upper bound for end = 1e16.\\nmaximum bound = min(time) * totalTrips\\nIn worst case, we only use the fastest bus to complete all trips.\\nCredits - [tbne1905](https://leetcode.com/tbne1905/)\\nExplanation ->**\\nThis problem follows the same patterns a Koko eating bananas or Cutting Ropes or Shipping Packages problems.\\n\\nWhen we identify a range of possibilties and we are asked to minimize or maximize, think binary search. Here, the maximum possibleTime we can take is just getting the sum of all times and multiplying them with total trips. Minimum possible time is the minimum time in the list of times given.\\n\\nNow that we have our range, we apply bianry search on it. Cumpute the midTime. With this as our totalTime, see if it is possible to make the totalTrips. Since our goal is to MINIMIZE, we have 2 options:\\n\\n1.Reduce the range by moving the right ptr towards mid if we CAN make totalTrips.\\n2.Increase the range of values by moving left towards mid if we CAN\\'T make totalTrips\\n\\n```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n\\n\\tlong long start = 0 , end = 1e16;\\n\\n\\tlong long c = 1e16;\\n\\n\\twhile(start <= end)\\n\\t{\\n\\t\\tlong long mid = start + ((end-start)/2);\\n\\n\\t\\tlong long trip = 0;\\n\\t\\tfor(auto &val : time)\\n\\t\\t{\\n\\t\\t\\tlong long b = val;\\n\\t\\t\\ttrip += (mid/b);\\n\\t\\t\\tif(trip > totalTrips)\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\tif(trip >= totalTrips) \\n\\t\\t{\\n\\t\\t\\tc = min(c,mid);\\n\\t\\t\\tend = mid-1;\\n\\t\\t}\\n\\t\\telse start = mid+1;\\n\\n        }\\n        \\n        return c;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1802710,
                "title": "python-easy-binary-search",
                "content": "```\\ndef minimumTime(self, time: List[int], totalTrips: int) -> int:\\n\\tif len(time) == 1:\\n\\t\\treturn totalTrips * time[0]\\n\\n\\tl, r = 0, 10**15\\n\\twhile l < r:\\n\\t\\tmid = (l + r) // 2\\n\\n\\t\\tres = 0\\n\\t\\tfor t in time:\\n\\t\\t\\tres += mid // t\\n\\n\\t\\tif res >= totalTrips:\\n\\t\\t\\tr = mid\\n\\t\\telse:\\n\\n\\t\\t\\tl = mid + 1\\n\\n\\treturn l\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef minimumTime(self, time: List[int], totalTrips: int) -> int:\\n\\tif len(time) == 1:\\n\\t\\treturn totalTrips * time[0]\\n\\n\\tl, r = 0, 10**15\\n\\twhile l < r:\\n\\t\\tmid = (l + r) // 2\\n\\n\\t\\tres = 0\\n\\t\\tfor t in time:\\n\\t\\t\\tres += mid // t\\n\\n\\t\\tif res >= totalTrips:\\n\\t\\t\\tr = mid\\n\\t\\telse:\\n\\n\\t\\t\\tl = mid + 1\\n\\n\\treturn l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1802463,
                "title": "c-easy-to-understand-binary-seach-o-nlogn",
                "content": "Goal: find the minimum time required to complete atleast totalTrips.\\nApproach: \\n```\\nwe can find the maximum number of trips for a given amount of time.\\n          let\\'s t be the time then \\n                maximum trips = (time[0]/t)+(time[1]/t)+...+(time[n-1]/t)\\n                                          where n is the size of time\\n          if the maximum trips are greater and equal to totalTrips then \\n                    assign the ans to t and search in the left of t\\n          else search in the right of t\\n```\\n\\ncode: \\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        // sort the time in non-decreasing order\\n        sort(time.begin(),time.end());\\n        \\n        long long l=0,h=(long long)time.back()*totalTrips;\\n        long long ans;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            long long cnt=0;\\n            // for a given amount of time (i.e. mid) caluculate the maximum number of trips\\n            for(int i=0;i<time.size();i++)\\n            {\\n                if(time[i]>mid)\\n                    break;\\n                cnt+=(mid/time[i]);\\n            }\\n            // if count is greater than the trips then assume that to be answer\\n            // and search in the range [l,mid-1]\\n            if(cnt>=totalTrips)\\n            {\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            // else search in the range [mid+1,h]\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\ntime complexity:  O(nlogn)\\nspace complexity: O(1)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nwe can find the maximum number of trips for a given amount of time.\\n          let\\'s t be the time then \\n                maximum trips = (time[0]/t)+(time[1]/t)+...+(time[n-1]/t)\\n                                          where n is the size of time\\n          if the maximum trips are greater and equal to totalTrips then \\n                    assign the ans to t and search in the left of t\\n          else search in the right of t\\n```\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        // sort the time in non-decreasing order\\n        sort(time.begin(),time.end());\\n        \\n        long long l=0,h=(long long)time.back()*totalTrips;\\n        long long ans;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            long long cnt=0;\\n            // for a given amount of time (i.e. mid) caluculate the maximum number of trips\\n            for(int i=0;i<time.size();i++)\\n            {\\n                if(time[i]>mid)\\n                    break;\\n                cnt+=(mid/time[i]);\\n            }\\n            // if count is greater than the trips then assume that to be answer\\n            // and search in the range [l,mid-1]\\n            if(cnt>=totalTrips)\\n            {\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            // else search in the range [mid+1,h]\\n            else l=mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802526,
                "title": "simple-binary-search-with-explanation-c",
                "content": "We find the minimum element in the given vector, So this is the minimum time taken by a single bus to complete one trip.\\n\\nNow, if we consider we are only using that single bus, the time taken to complete all the trips would be ( (time taken by the bus) * (total no. of trips) ). So the answer could be the this value or below it.\\nNow, we can binary search over the time range to get minimum time.\\n\\n```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& time, long long trips, long long t){\\n        int n = time.size();\\n        long long cnt = 0;\\n        for(int i=0;i<n;i++){ // for present t, evaluating how many trips are possible.\\n            cnt += (t/time[i]);\\n        }\\n        if(cnt>=trips) return true; // if the cnt is greater than or equal to required trips, then return true, else false.\\n        return false;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int trips) {\\n        int minm = INT_MAX;\\n        for(int i=0;i<time.size();i++){ // finding minm element\\n            minm = min(minm,time[i]);\\n        }\\n        long long l=0, r=((long long)minm)*trips; // lower bound and upper bound for ans.\\n        long long ans = 0;\\n        while(l<=r){ // binary search over the time range\\n            long long mid = l + (r-l)/2;\\n            if(solve(time,trips,mid)){\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Upvote if it helps**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<int>& time, long long trips, long long t){\\n        int n = time.size();\\n        long long cnt = 0;\\n        for(int i=0;i<n;i++){ // for present t, evaluating how many trips are possible.\\n            cnt += (t/time[i]);\\n        }\\n        if(cnt>=trips) return true; // if the cnt is greater than or equal to required trips, then return true, else false.\\n        return false;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int trips) {\\n        int minm = INT_MAX;\\n        for(int i=0;i<time.size();i++){ // finding minm element\\n            minm = min(minm,time[i]);\\n        }\\n        long long l=0, r=((long long)minm)*trips; // lower bound and upper bound for ans.\\n        long long ans = 0;\\n        while(l<=r){ // binary search over the time range\\n            long long mid = l + (r-l)/2;\\n            if(solve(time,trips,mid)){\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802440,
                "title": "simple-java-solution-binary-search",
                "content": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        Arrays.sort(time);\\n        long low = 1, high = Long.MAX_VALUE;\\n        long minTime = Long.MAX_VALUE;\\n        while(low<=high){\\n            long mid = low + (high-low)/2;\\n            long numTrips = 0;\\n            for(int t: time){\\n                // if repeated summation of large mid values(comparable to Long.MAX_VALUE) and small trip time \\'t\\' causes overflow - identify, bring upper bound down and break the loop\\n                numTrips += mid/t;\\n                if(numTrips<0)\\n                {\\n                    high = mid-1;\\n                    break;\\n                }\\n            }\\n            if(numTrips<0)\\n                continue;\\n\\n            if( numTrips >= totalTrips){\\n                high = mid-1;\\n                minTime = Math.min(mid, minTime);\\n            }else if(numTrips < totalTrips){\\n                low = mid+1;\\n            }\\n        }\\n        return minTime;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        Arrays.sort(time);\\n        long low = 1, high = Long.MAX_VALUE;\\n        long minTime = Long.MAX_VALUE;\\n        while(low<=high){\\n            long mid = low + (high-low)/2;\\n            long numTrips = 0;\\n            for(int t: time){\\n                // if repeated summation of large mid values(comparable to Long.MAX_VALUE) and small trip time \\'t\\' causes overflow - identify, bring upper bound down and break the loop\\n                numTrips += mid/t;\\n                if(numTrips<0)\\n                {\\n                    high = mid-1;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3269256,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        #define ll long long\\n        ll start = 1;\\n        ll end = 1e14;\\n        while(start <= end){\\n            ll trip = 0;\\n            ll mid = start + (end - start)/2;\\n            for(int i=0;i<time.size();i++)\\n                trip += mid / time[i];\\n            if(trip < totalTrips){\\n                start = mid + 1;\\n            }\\n            else \\n                end = mid - 1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        #define ll long long\\n        ll start = 1;\\n        ll end = 1e14;\\n        while(start <= end){\\n            ll trip = 0;\\n            ll mid = start + (end - start)/2;\\n            for(int i=0;i<time.size();i++)\\n                trip += mid / time[i];\\n            if(trip < totalTrips){\\n                start = mid + 1;\\n            }\\n            else \\n                end = mid - 1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267547,
                "title": "binary-search-and-brute-force-solution-approach-explained",
                "content": "# Intuition\\nThe brute force approach would be to start from time t=1 and increase it to check whether we can achieve the required number of trips in time t. This approach would cause TLE because of the constraints given.\\n\\n\\n# Approach\\nNow from the brute force approach we can work towards a better solution. In the brute force approach we are using all values of time between t=1 to the maximum time needed. The maximum time needed would be totalTrips*(maximum time taken by a bus to complete one trip).\\n\\nNow, instead of exploring all the values in the range, we can use binary search to find the minimum value.\\n1. The minimum time would be 1 second. So, **low=1**. The maximum time would be **high=totalTrips * (maximum value in time array)** .\\n2. Until low<high we will do the following:\\n    - Find the mid value: **mid=(low+high)/2**.\\n    - Now, we would check whether it is enough to complete the totalTrips in mid time. Each bus would do **mid/time[i]** trips. We can iterate the array time to calculate the total trips. \\n    - If the mid value is more than enough to take  totalTrips number of trips. Then our range would become low to mid (we are including mid as it can be the lowest value too).\\n    But if it\\'s not enough the range would be mid+1 to high.\\n    \\n\\n# Code\\n### 1. Brute force \\n```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n        long long trips=0;  // trips would store the trips completed until t time\\n        int t=1; \\n        while(trips<totalTrips){ // if trips==totalTrips, we can break out of the loop \\n            for(int i=0;i<time.size();++i){ \\n                if(t%time[i]==0) trips++; // if t is divisble by time[i] that means bus i has completed one more trip in time t.\\n            }\\n            t++;\\n        }\\n        return t-1;\\n}\\n    \\n```\\n### 2. Binary Search\\n```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n    long long maxtime=*max_element(time.begin(),time.end()); // maximum time taken by a bus to complete one trip\\n    long long l=1, r=totalTrips*maxtime; // time range in which minimum time lies\\n    while(l<r){\\n        long long mid=(l+r)/2, actualTrips=0; // actualTrips would store the trips completed in time 0 to mid.\\n        for(int i=0;i<time.size();i++){\\n            actualTrips+=mid/time[i]; \\n        }\\n        if(actualTrips<totalTrips) l=mid+1; // if the time mid is not enough, then the range would become  mid+1 to r.\\n        else r=mid; // if the time mid is enough than the minimum lies in the range l to mid.\\n    }\\n    return l;\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n        long long trips=0;  // trips would store the trips completed until t time\\n        int t=1; \\n        while(trips<totalTrips){ // if trips==totalTrips, we can break out of the loop \\n            for(int i=0;i<time.size();++i){ \\n                if(t%time[i]==0) trips++; // if t is divisble by time[i] that means bus i has completed one more trip in time t.\\n            }\\n            t++;\\n        }\\n        return t-1;\\n}\\n    \\n```\n```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n    long long maxtime=*max_element(time.begin(),time.end()); // maximum time taken by a bus to complete one trip\\n    long long l=1, r=totalTrips*maxtime; // time range in which minimum time lies\\n    while(l<r){\\n        long long mid=(l+r)/2, actualTrips=0; // actualTrips would store the trips completed in time 0 to mid.\\n        for(int i=0;i<time.size();i++){\\n            actualTrips+=mid/time[i]; \\n        }\\n        if(actualTrips<totalTrips) l=mid+1; // if the time mid is not enough, then the range would become  mid+1 to r.\\n        else r=mid; // if the time mid is enough than the minimum lies in the range l to mid.\\n    }\\n    return l;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3266483,
                "title": "simple-solution-based-on-similar-problems-binary-search",
                "content": "# Intuition\\nIt doesn\\'t get apparent at first how Binary Search can be applied here but you have to notice that the answer lies between a range. It is either:\\n-Minimum value of $$time[i]$$ (when totalTrips=1)\\n-Maximum value of $$time[i]*totalTrips$$ (when time has only 1 element)\\nThis pattern will repeat for every test case. The first one is the most intuitive, if we only had to make one round. \\n\\n# Approach\\nHow exactly do we fit Binary Search into this? We need to find the $$left$$ and $$right$$ pointers. \\nI just assumed $$left$$ to be 1, as in any imaginable testcase, the best answer will be 1.\\nFor $$right$$, there are a couple of techniques but the simplest is to find the maximum value of any $$time[i]*totalTrips$$. Think about the case when all elements in the array have the same value. \\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long l=1; \\n        long max=0;\\n        for(int x:time) max=Math.max(max,x);\\n        long h=max*totalTrips; //compute upper limit\\n\\n        while(l<h){\\n            long mid=l+(h-l)/2;\\n            if(compute(time,mid,totalTrips)){\\n                h=mid; \\n            //if mid is a valid answer, it can be the answer\\n            } \\n            else l=mid+1;\\n        }\\n        return h;\\n    }\\n    public boolean compute(int[] time,long key,int totalTrips){\\n//This part of the code has been used in problems like \\n// Leetcode 1011\\n        long trips=0;\\n        for(int x:time){\\n            trips+= key/x; \\n        //number of trips made by a bus is total time/time it takes \\n        //the bus to complete one trip\\n\\n            if(trips>=totalTrips) break;\\n        //early return when we already satisfy our trips condition\\n        }\\n        if(trips>=totalTrips) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long l=1; \\n        long max=0;\\n        for(int x:time) max=Math.max(max,x);\\n        long h=max*totalTrips; //compute upper limit\\n\\n        while(l<h){\\n            long mid=l+(h-l)/2;\\n            if(compute(time,mid,totalTrips)){\\n                h=mid; \\n            //if mid is a valid answer, it can be the answer\\n            } \\n            else l=mid+1;\\n        }\\n        return h;\\n    }\\n    public boolean compute(int[] time,long key,int totalTrips){\\n//This part of the code has been used in problems like \\n// Leetcode 1011\\n        long trips=0;\\n        for(int x:time){\\n            trips+= key/x; \\n        //number of trips made by a bus is total time/time it takes \\n        //the bus to complete one trip\\n\\n            if(trips>=totalTrips) break;\\n        //early return when we already satisfy our trips condition\\n        }\\n        if(trips>=totalTrips) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266465,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved using binary search by setting the search space as the range of possible minimum times required for all buses to complete at least totalTrips trips. We can then use a helper function to calculate the total number of trips completed for each bus at any given time, and based on that, determine whether the current minimum time is too high or too low. We can continue updating the search space until we find the minimum time required to complete totalTrips trips.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize the search space as the range of possible minimum times required for all buses to complete at least totalTrips trips. The minimum time required for each bus to complete totalTrips trips is the minimum time taken by any bus multiplied by totalTrips, and the maximum time required is the sum of times taken by all buses multiplied by totalTrips.\\n2. Use binary search to find the minimum time required to complete totalTrips trips. For each mid-point time value, calculate the total number of trips completed for each bus using a helper function.\\n3. If the total number of trips completed is greater than or equal to totalTrips, the current mid-point time is a valid candidate for the minimum time required. Therefore, update the search space to the lower half of the current range.\\n4. If the total number of trips completed is less than totalTrips, the current mid-point time is too high, and we need to increase the minimum time required. Therefore, update the search space to the upper half of the current range.\\n5. Continue updating the search space until the minimum time required to complete totalTrips trips is found.\\n\\n\\n# Complexity\\n- Time complexity: The time complexity of the binary search algorithm used in the solution is $$O(log n)$$, where n is the range of possible minimum times required for all buses to complete at least totalTrips trips. For each mid-point time value, the helper function calculates the total number of trips completed by all buses, which takes $$O(n)$$ time. Therefore, the overall time complexity of the solution is $$O(n log n)$$, where n is the length of the input array time.\\n\\n- Space complexity: The space complexity of the solution is $$O(1)$$, as we are only using constant space to store the input array and a few variables.\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n```Java []\\nclass Solution {\\n  public long minimumTime(int[] time, int totalTrips) {\\n    long l = 1;\\n    long r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n\\n    while (l < r) {\\n      final long m = (l + r) / 2;\\n      if (numTrips(time, m) >= totalTrips)\\n        r = m;\\n      else\\n        l = m + 1;\\n    }\\n\\n    return l;\\n  }\\n\\n  private long numTrips(int[] time, long m) {\\n    return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n  }\\n}\\n\\n```\\n```Python []\\nclass Solution(object):\\n    def minimumTime(self, time, totalTrips):\\n        l = 1\\n        r = min(time) * totalTrips\\n\\n        while l < r:\\n            m = (l + r) // 2\\n            if self.numTrips(time, m) >= totalTrips:\\n                r = m\\n            else:\\n                l = m + 1\\n\\n        return l\\n\\n    def numTrips(self, time, m):\\n        return sum(m // t for t in time)\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l = 1;\\n        long long r = *min_element(time.begin(), time.end()) * (long long) totalTrips;\\n\\n        while (l < r) {\\n            long long m = (l + r) / 2;\\n            if (numTrips(time, m) >= totalTrips)\\n                r = m;\\n            else\\n                l = m + 1;\\n        }\\n\\n        return l;\\n    }\\n\\n    long long numTrips(vector<int>& time, long long m) {\\n        long long num = 0;\\n        for (int t : time) {\\n            num += m / t;\\n        }\\n        return num;\\n    }\\n};\\n\\n```\\n```\\n# Commented  version of Java code for better understanding \\n\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        // Initialize the search space as the range of possible minimum times required for all buses to complete at least totalTrips trips.\\n        // The minimum time required for each bus to complete totalTrips trips is the minimum time taken by any bus multiplied by totalTrips, and the maximum time required is the sum of times taken by all buses multiplied by totalTrips.\\n        long l = 1;\\n        long r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n        \\n        // Use binary search to find the minimum time required to complete totalTrips trips.\\n        while (l < r) {\\n            // Calculate the mid-point time value.\\n            final long m = (l + r) / 2;\\n            \\n            // Calculate the total number of trips completed for all buses at the mid-point time value.\\n            long numTrips = numTrips(time, m);\\n            \\n            // If the total number of trips completed is greater than or equal to totalTrips, the current mid-point time is a valid candidate for the minimum time required.\\n            // Therefore, update the search space to the lower half of the current range.\\n            if (numTrips >= totalTrips)\\n                r = m;\\n            // If the total number of trips completed is less than totalTrips, the current mid-point time is too high, and we need to increase the minimum time required.\\n            // Therefore, update the search space to the upper half of the current range.\\n            else\\n                l = m + 1;\\n        }\\n        \\n        // Return the minimum time required to complete totalTrips trips.\\n        return l;\\n    }\\n    \\n    // Helper function to calculate the total number of trips completed by all buses at any given time.\\n    private long numTrips(int[] time, long m) {\\n        // Calculate the total number of trips completed for each bus at the mid-point time value.\\n        // The total number of trips completed for a bus is the floor division of m by the time taken by the bus.\\n        // We then sum up the total number of trips completed for all buses.\\n        return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n    }\\n}\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```Java []\\nclass Solution {\\n  public long minimumTime(int[] time, int totalTrips) {\\n    long l = 1;\\n    long r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n\\n    while (l < r) {\\n      final long m = (l + r) / 2;\\n      if (numTrips(time, m) >= totalTrips)\\n        r = m;\\n      else\\n        l = m + 1;\\n    }\\n\\n    return l;\\n  }\\n\\n  private long numTrips(int[] time, long m) {\\n    return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n  }\\n}\\n\\n```\n```Python []\\nclass Solution(object):\\n    def minimumTime(self, time, totalTrips):\\n        l = 1\\n        r = min(time) * totalTrips\\n\\n        while l < r:\\n            m = (l + r) // 2\\n            if self.numTrips(time, m) >= totalTrips:\\n                r = m\\n            else:\\n                l = m + 1\\n\\n        return l\\n\\n    def numTrips(self, time, m):\\n        return sum(m // t for t in time)\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l = 1;\\n        long long r = *min_element(time.begin(), time.end()) * (long long) totalTrips;\\n\\n        while (l < r) {\\n            long long m = (l + r) / 2;\\n            if (numTrips(time, m) >= totalTrips)\\n                r = m;\\n            else\\n                l = m + 1;\\n        }\\n\\n        return l;\\n    }\\n\\n    long long numTrips(vector<int>& time, long long m) {\\n        long long num = 0;\\n        for (int t : time) {\\n            num += m / t;\\n        }\\n        return num;\\n    }\\n};\\n\\n```\n```\\n# Commented  version of Java code for better understanding \\n\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        // Initialize the search space as the range of possible minimum times required for all buses to complete at least totalTrips trips.\\n        // The minimum time required for each bus to complete totalTrips trips is the minimum time taken by any bus multiplied by totalTrips, and the maximum time required is the sum of times taken by all buses multiplied by totalTrips.\\n        long l = 1;\\n        long r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n        \\n        // Use binary search to find the minimum time required to complete totalTrips trips.\\n        while (l < r) {\\n            // Calculate the mid-point time value.\\n            final long m = (l + r) / 2;\\n            \\n            // Calculate the total number of trips completed for all buses at the mid-point time value.\\n            long numTrips = numTrips(time, m);\\n            \\n            // If the total number of trips completed is greater than or equal to totalTrips, the current mid-point time is a valid candidate for the minimum time required.\\n            // Therefore, update the search space to the lower half of the current range.\\n            if (numTrips >= totalTrips)\\n                r = m;\\n            // If the total number of trips completed is less than totalTrips, the current mid-point time is too high, and we need to increase the minimum time required.\\n            // Therefore, update the search space to the upper half of the current range.\\n            else\\n                l = m + 1;\\n        }\\n        \\n        // Return the minimum time required to complete totalTrips trips.\\n        return l;\\n    }\\n    \\n    // Helper function to calculate the total number of trips completed by all buses at any given time.\\n    private long numTrips(int[] time, long m) {\\n        // Calculate the total number of trips completed for each bus at the mid-point time value.\\n        // The total number of trips completed for a bus is the floor division of m by the time taken by the bus.\\n        // We then sum up the total number of trips completed for all buses.\\n        return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n    }\\n}\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802834,
                "title": "javascript-100-faster-easy-clean-code",
                "content": "![image](https://assets.leetcode.com/users/images/35d4495c-5c3a-4fd4-a1ab-3fee1c822970_1645936250.7609615.png)\\n\\n```\\nvar minimumTime = function(time, totalTrips) {\\n    let low = 1;\\n    let high = Number.MAX_SAFE_INTEGER;\\n    let ans = 0;\\n    \\n    while(low <= high) {\\n        let mid = Math.floor(low + (high - low) / 2); // to prevent overflow\\n        \\n        if(isPossible(time, mid, totalTrips)) {\\n            ans = mid\\n            high = mid - 1;\\n        } else {\\n            low = mid + 1;\\n        }\\n    }\\n    return ans;\\n};\\n\\nfunction isPossible(arr, mid, totalTrips) {\\n    let trips = 0;\\n    for (let i = 0; i < arr.length; i++) {\\n      trips += Math.floor(mid / arr[i]);\\n    }\\n    return trips >= totalTrips;\\n}\\n```\\n\\nhard luck today : / , just after the contest My solution got accepted, happens...",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar minimumTime = function(time, totalTrips) {\\n    let low = 1;\\n    let high = Number.MAX_SAFE_INTEGER;\\n    let ans = 0;\\n    \\n    while(low <= high) {\\n        let mid = Math.floor(low + (high - low) / 2); // to prevent overflow\\n        \\n        if(isPossible(time, mid, totalTrips)) {\\n            ans = mid\\n            high = mid - 1;\\n        } else {\\n            low = mid + 1;\\n        }\\n    }\\n    return ans;\\n};\\n\\nfunction isPossible(arr, mid, totalTrips) {\\n    let trips = 0;\\n    for (let i = 0; i < arr.length; i++) {\\n      trips += Math.floor(mid / arr[i]);\\n    }\\n    return trips >= totalTrips;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802621,
                "title": "c-binary-search",
                "content": "```\\n// I have implemented this by Binary Search\\n\\n\\nclass Solution {\\npublic:\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        \\n        long long left =0, right=1e14,mid;\\n        \\n        while(left <= right){\\n            \\n            mid=(left +right)/2; // calculating the mid value\\n            long long ans=0;     //store the number of days\\n            \\n            for(int i=0;i<time.size();i++)  //find the sum of time taken by buses till the \"mid\" index of array\\n                ans+= mid/time[i];\\n            \\n            if(ans < totalTrips) left =mid+1;   //if ans < totalTrips, then we have to go to right block\\n            \\n            else right=mid-1;       // go to the left block\\n            \\n        }\\n            \\n        return left;    \\n            \\n        \\n    }\\n};\\n```\\nPlease **Upvote**, if you liked my solution.\\nDont forget to visit my repo: https://github.com/tarunsahnan/LeetCode-Solutions\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n// I have implemented this by Binary Search\\n\\n\\nclass Solution {\\npublic:\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        \\n        long long left =0, right=1e14,mid;\\n        \\n        while(left <= right){\\n            \\n            mid=(left +right)/2; // calculating the mid value\\n            long long ans=0;     //store the number of days\\n            \\n            for(int i=0;i<time.size();i++)  //find the sum of time taken by buses till the \"mid\" index of array\\n                ans+= mid/time[i];\\n            \\n            if(ans < totalTrips) left =mid+1;   //if ans < totalTrips, then we have to go to right block\\n            \\n            else right=mid-1;       // go to the left block\\n            \\n        }\\n            \\n        return left;    \\n            \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802466,
                "title": "java-binary-search-with-explanation",
                "content": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        //The idea is given value mid, can we finish totalTrips within mid time. \\n        //We have left and right bound, we want to find mid in the boundary.\\n        \\n        //Key point: We CANNOT directly set right to Long.MAX_VALUE\\n        //Reason: \\n        //We will get very large  (right - left) / 2 + left, and it will cause overflow if our elements in time array is small\\n        //Therefore, we set right bound to maximum time we need which is (the min value in time array * totalTrips)\\n        \\n        long left = 1;\\n        //find min value in time array\\n        long min = time[0];\\n        for(int t : time){\\n            min = Math.min(min, t);\\n        }\\n        long right = totalTrips * min;\\n        \\n        while(left < right){\\n            long mid = (right - left) / 2 + left;\\n            \\n            //How many trip we can do\\n            long total = 0;\\n            for(int t : time){\\n                total += mid / t;\\n            }\\n            \\n            //We cannot reach totalTrips, means mid is too small\\n            if(total < totalTrips){\\n                left = mid + 1;\\n            }else{\\n                //We can reach totalTrips, but we want right to be as small as possible \\n                //Therefore, we don\\'t need to + 1\\n                right = mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n}\\n```\\nNote (idea from [@rizbanul08](https://leetcode.com/rizbanul08)):\\nYou can use Long.MAX_VALUE if you change the total\\'s \"long\" type to \"double\" type.\\nHowever,  total is always integer, and it might cause some problems using double in other question.\\nYou can store larger numbers in a double, but you will lose precision.\\nExample:\\n```\\nclass Solution\\n{\\n\\n    public static void main(String[] args)\\n    {\\n        long   long1 = Long.MAX_VALUE - 100L;\\n        double dbl1  = long1;\\n        long   long2 = long1+1;\\n        double dbl2  = dbl1+1;\\n\\n        System.out.printf(\"%d %d\\\\n%f %f\", long1, long2, dbl1, dbl2);\\n    }\\n\\n}\\n```\\nThis outputs:\\n9223372036854775707 9223372036854775708\\n9223372036854776000.000000 9223372036854776000.000000",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        //The idea is given value mid, can we finish totalTrips within mid time. \\n        //We have left and right bound, we want to find mid in the boundary.\\n        \\n        //Key point: We CANNOT directly set right to Long.MAX_VALUE\\n        //Reason: \\n        //We will get very large  (right - left) / 2 + left, and it will cause overflow if our elements in time array is small\\n        //Therefore, we set right bound to maximum time we need which is (the min value in time array * totalTrips)\\n        \\n        long left = 1;\\n        //find min value in time array\\n        long min = time[0];\\n        for(int t : time){\\n            min = Math.min(min, t);\\n        }\\n        long right = totalTrips * min;\\n        \\n        while(left < right){\\n            long mid = (right - left) / 2 + left;\\n            \\n            //How many trip we can do\\n            long total = 0;\\n            for(int t : time){\\n                total += mid / t;\\n            }\\n            \\n            //We cannot reach totalTrips, means mid is too small\\n            if(total < totalTrips){\\n                left = mid + 1;\\n            }else{\\n                //We can reach totalTrips, but we want right to be as small as possible \\n                //Therefore, we don\\'t need to + 1\\n                right = mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n\\n    public static void main(String[] args)\\n    {\\n        long   long1 = Long.MAX_VALUE - 100L;\\n        double dbl1  = long1;\\n        long   long2 = long1+1;\\n        double dbl2  = dbl1+1;\\n\\n        System.out.printf(\"%d %d\\\\n%f %f\", long1, long2, dbl1, dbl2);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271339,
                "title": "simplest-solution-binary-search-well-explained-c-easy-to-understand",
                "content": "**Approach: Binary Search**\\n\\n**Intuition**\\n\\nTo efficiently find the minimum valid time to finish total trips, we can use binary search instead of a brute force approach. This is because trying every time from the smallest is likely to exceed the time limit, given the constraints in the question.\\n\\nTo use binary search, we can observe that there is a pattern in the time taken for each bus to complete total trips. By combining this pattern with the fact that we know the maximum time taken by one trip, we can determine whether a given time is long enough to finish all trips or not.\\n\\nTo implement binary search, we first initialize the search space with the left boundary set to 1 and the right boundary set to totalTrips times the maximum time taken by one trip. This ensures that the minimum time is included in the search space.\\n\\nWe then check if the middle time is long enough. If it is not, we cut the half of the search space containing smaller times. Otherwise, we cut the half containing larger times. We repeat this process until there is only one time left, which is the minimum valid time.\\n\\nTo check if a given time is sufficient, we iterate over the input and use the formula introduced above (each bus can complete mid / time[i] trips). This allows us to efficiently find the minimum valid time to finish total trips without exceeding the time limit.\\n\\n**C++ Code:**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool check(vector<int>& time,long long n,long long totalTrips){\\n\\t\\t\\tlong long sum=0;\\n\\t\\t\\tfor(int i=0;i<time.size();i++){\\n\\t\\t\\t\\tsum+=(n/time[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn sum>=totalTrips;\\n\\t\\t}\\n\\n\\t\\tlong long minimumTime(vector<int>& time, int totalTrips) {\\n\\t\\t\\tlong long l=-1,r=1e14,mid;\\n\\t\\t\\twhile(r-l>1){\\n\\t\\t\\t\\tmid=(l+r)/2;\\n\\t\\t\\t\\tif(check(time,mid,totalTrips)){\\n\\t\\t\\t\\t\\tr=mid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tl=mid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn r;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool check(vector<int>& time,long long n,long long totalTrips){\\n\\t\\t\\tlong long sum=0;\\n\\t\\t\\tfor(int i=0;i<time.size();i++){\\n\\t\\t\\t\\tsum+=(n/time[i]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3269955,
                "title": "c-easy-sol-beats-100-with-full-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can see from the constraints that our solution must be in $$O(nlogn)$$ format so I decided to formulate a set of time in which our answer is also present and using binary search to find the minimum time.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n - **How guess Time complexity required for question using contraints :-**\\nConstraints were :- Array of max 10^5 length \\nNow imgaine you were fomulating a solution of $$O(n^2)$$ so total time unit taken would be 10^10 and for $$O(nlogn)$$ around 10^6. One thing that you need to know is that in general 10^8 operations take 1 second time and it is usually the time limit of the questions if not given. So for the given question time complexity must be $$O(nlogn)$$ or lower.\\n - **How to make the set** \\n We can see that max length and trip is 10^7 so in my solution i took max time to be 10^14 because it won\\'t reach beyond that. Minimum time taken cannot be lower than 1.\\n - **Check function**\\n It calculate the trips that can be made in particular time and than check if the trips are more or less than required and if conditions are met returns true else false;\\n - **Dividing Condition**\\n if particular selected time i.e $$mid$$ trips can be made than we store that in answer and search for another answer in lesser time (lower half) as we need to find it in minimum possible time. We we cannot make the trips in that time than we need to search in upper half. \\n# Complexity\\n- Time complexity: $$O(NlogK)$$\\nwhere N is the length of the array and K is 10^14\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int totalTrips,vector<int>&time,long long trips)\\n    {\\n        long long count=0;\\n        for(auto i:time)\\n        {\\n            count+=trips/i;\\n            if(count>=totalTrips)return true;\\n        }\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l=1,h=10e14;\\n        long long ans;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            if(check(totalTrips,time,mid))\\n            {\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int totalTrips,vector<int>&time,long long trips)\\n    {\\n        long long count=0;\\n        for(auto i:time)\\n        {\\n            count+=trips/i;\\n            if(count>=totalTrips)return true;\\n        }\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l=1,h=10e14;\\n        long long ans;\\n        while(l<=h)\\n        {\\n            long long mid=l+(h-l)/2;\\n            if(check(totalTrips,time,mid))\\n            {\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268560,
                "title": "c-binary-search-easiest-approach-100-faster",
                "content": "# Intuition\\nSince it was a minimise the maximum kind of problem a very classic problem usually solved by binary search \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSo we should use $$binary\\\\ search$$ as well \\nHere we will assume an aswer and try to verify that our assumed answer is possible or not. Our answer may lie between 1 sec to the time taken if all the trip was made by the maximum time taking bus. \\nFinding maximum will be adding another O(N) to our solution, avoiding that in our case, so according to the constraints the maximum possible answer will be LONG_MAX so we set our high limit as the same. Then we will use binary search to search our answer in the range if answer exists then we will find another better answer that is minimum then the previous.\\nFor determining whether the probable answer is possible or not we can iterate over the array and count how many trips would be completed by each bus in the probable time(mid).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*log(LLONG\\\\_MAX))$$ where in n is the size of the array time\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ as no extra space used \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& time, int totalTrips, long long mid){\\n        long long count = 0;\\n        for(int i = 0; i < time.size(); i++){\\n            count += mid / time[i];\\n            if(count >= totalTrips) return true;\\n        }\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long low = 1;\\n        long long high = LLONG_MAX;\\n        long long ans;\\n        while(low <= high){\\n            long long mid = low + (high - low) / 2;\\n            if(isPossible(time, totalTrips, mid)){\\n                ans = mid;\\n                high = mid - 1;\\n            } else{\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Please Upvote my Solution\\n<img align=\"centre\" src = \"https://assets.leetcode.com/users/images/1e169185-d032-4861-8f46-bd971f57ad4f_1678191359.4894545.png\" \\nstyle=\"display: block; margin-right: auto; margin-left: auto;\" width= \"300\" height=\"300\">",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>& time, int totalTrips, long long mid){\\n        long long count = 0;\\n        for(int i = 0; i < time.size(); i++){\\n            count += mid / time[i];\\n            if(count >= totalTrips) return true;\\n        }\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long low = 1;\\n        long long high = LLONG_MAX;\\n        long long ans;\\n        while(low <= high){\\n            long long mid = low + (high - low) / 2;\\n            if(isPossible(time, totalTrips, mid)){\\n                ans = mid;\\n                high = mid - 1;\\n            } else{\\n                low = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266954,
                "title": "c-binary-search",
                "content": "# Code\\n```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    long long minimumTime(vector<int>& v, int t) {\\n        long long i=1,j=1LL*(v[v.size()-1])*t;\\n        long long ans=j;\\n        while(i<=j){\\n            ll m=(i+j)/2;\\n            ll tot=0;\\n            for(int k=0;k<v.size();k++)tot+=m/v[k];\\n            if(tot>=t){\\n                ans=m;\\n                j=m-1;\\n            }\\n            else i=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/65b6449b-6f58-45e6-80d7-7852dab98c19_1678163677.5049846.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    long long minimumTime(vector<int>& v, int t) {\\n        long long i=1,j=1LL*(v[v.size()-1])*t;\\n        long long ans=j;\\n        while(i<=j){\\n            ll m=(i+j)/2;\\n            ll tot=0;\\n            for(int k=0;k<v.size();k++)tot+=m/v[k];\\n            if(tot>=t){\\n                ans=m;\\n                j=m-1;\\n            }\\n            else i=m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266933,
                "title": "detailed-solution-with-approach",
                "content": "- Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\\n- Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\\n- In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\\n- Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\\n- If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\\n- Otherwise, update the lower bound lo to the mid value plus one.\\n- Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\\n- Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array.\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n    long lo = 1;\\n    long hi = Long.MAX_VALUE;\\n\\n    while (lo < hi) {\\n        long mid = lo + (hi - lo) / 2;\\n        long completedTrips=0;\\n        for (int t : time) {\\n            completedTrips += mid / t;\\n            if (completedTrips >= totalTrips) break;\\n        }\\n        if (completedTrips>=totalTrips) {\\n            hi = mid;\\n        } else {\\n            lo = mid + 1;\\n        }\\n    }\\n    return lo;\\n    }\\n}\\n```\\n# UPVOTE if you liked the approach",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n    long lo = 1;\\n    long hi = Long.MAX_VALUE;\\n\\n    while (lo < hi) {\\n        long mid = lo + (hi - lo) / 2;\\n        long completedTrips=0;\\n        for (int t : time) {\\n            completedTrips += mid / t;\\n            if (completedTrips >= totalTrips) break;\\n        }\\n        if (completedTrips>=totalTrips) {\\n            hi = mid;\\n        } else {\\n            lo = mid + 1;\\n        }\\n    }\\n    return lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266795,
                "title": "minimum-time-to-complete-trips-solving-the-leetcode-challenge-march-7-2023-explained",
                "content": "![image.png](https://assets.leetcode.com/users/images/d5bd5c46-5f44-4fa7-820f-dd165a96fb91_1677816522.0925934.png)\\n\\n# Full explaination at : [Solution](https://yoichiisagi.hashnode.dev/minimum-time-to-complete-trips-solving-the-leetcode-challenge-march-7-2023)\\n\\n![image.png](https://assets.leetcode.com/users/images/6907ce4f-a766-4668-bd51-1cedade65e46_1677816533.0083919.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        int n = time.length;\\n        double tripsPerUnitTime = 0.0;\\n        int minimumTime = Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++) {\\n            tripsPerUnitTime += (double)1/time[i];\\n            if(minimumTime>time[i]) {\\n                minimumTime = time[i];\\n            }\\n        }\\n\\n        long timeForTrips = (int)Math.ceil((double)totalTrips/tripsPerUnitTime);\\n        // find the number of trips in timeForTrips and find remaining time for partial trips\\n        long minTime = timeForTrips;\\n        long maxTime = Integer.MAX_VALUE;\\n        long trips = 0;\\n        for(int i=0;i<n;i++) {\\n            trips += timeForTrips/time[i];\\n        }\\n        if(trips>=totalTrips) {\\n            return timeForTrips;\\n        }\\n\\n        minTime = timeForTrips;\\n        maxTime = timeForTrips+(totalTrips-trips)*minimumTime;\\n        do {\\n            timeForTrips = (minTime+maxTime)/2;\\n            trips=0;\\n            minimumTime = Integer.MAX_VALUE;\\n            for(int i=0;i<n;i++) {\\n                trips += timeForTrips/time[i];\\n            }\\n            if(trips < totalTrips) {\\n                minTime = timeForTrips;\\n            } else {\\n                maxTime = timeForTrips;\\n            }\\n        } while(maxTime - minTime>1);\\n        \\n        return maxTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        int n = time.length;\\n        double tripsPerUnitTime = 0.0;\\n        int minimumTime = Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++) {\\n            tripsPerUnitTime += (double)1/time[i];\\n            if(minimumTime>time[i]) {\\n                minimumTime = time[i];\\n            }\\n        }\\n\\n        long timeForTrips = (int)Math.ceil((double)totalTrips/tripsPerUnitTime);\\n        // find the number of trips in timeForTrips and find remaining time for partial trips\\n        long minTime = timeForTrips;\\n        long maxTime = Integer.MAX_VALUE;\\n        long trips = 0;\\n        for(int i=0;i<n;i++) {\\n            trips += timeForTrips/time[i];\\n        }\\n        if(trips>=totalTrips) {\\n            return timeForTrips;\\n        }\\n\\n        minTime = timeForTrips;\\n        maxTime = timeForTrips+(totalTrips-trips)*minimumTime;\\n        do {\\n            timeForTrips = (minTime+maxTime)/2;\\n            trips=0;\\n            minimumTime = Integer.MAX_VALUE;\\n            for(int i=0;i<n;i++) {\\n                trips += timeForTrips/time[i];\\n            }\\n            if(trips < totalTrips) {\\n                minTime = timeForTrips;\\n            } else {\\n                maxTime = timeForTrips;\\n            }\\n        } while(maxTime - minTime>1);\\n        \\n        return maxTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266733,
                "title": "java-binary-search-easiest-solution",
                "content": "```\\n\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low=Long.MAX_VALUE;\\n        long high=0;\\n        long min=Long.MAX_VALUE;\\n        for(int it:time){\\n            low=Math.min(low,it);\\n            min=Math.min(min,it);\\n        }\\n        high=totalTrips*min;\\n        while(low<high){\\n            long mid=low+(high-low)/2;\\n            if(blackbox(mid,totalTrips,time)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean blackbox(long isvalidtime,int totalTrips,int[] time){\\n        long trips=0;\\n        for(int it:time){\\n            trips+=isvalidtime/it;\\n        }\\n        if(trips>=totalTrips)\\n            return true;\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low=Long.MAX_VALUE;\\n        long high=0;\\n        long min=Long.MAX_VALUE;\\n        for(int it:time){\\n            low=Math.min(low,it);\\n            min=Math.min(min,it);\\n        }\\n        high=totalTrips*min;\\n        while(low<high){\\n            long mid=low+(high-low)/2;\\n            if(blackbox(mid,totalTrips,time)){\\n                high=mid;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return low;\\n    }\\n    public boolean blackbox(long isvalidtime,int totalTrips,int[] time){\\n        long trips=0;\\n        for(int it:time){\\n            trips+=isvalidtime/it;\\n        }\\n        if(trips>=totalTrips)\\n            return true;\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266698,
                "title": "javascript-rust-easy-to-understand-solution",
                "content": "## JavaScript Solution\\n```javascript\\n/**\\n * @param {number[]} time\\n * @param {number} totalTrips\\n * @return {number}\\n */\\nvar minimumTime = function (time, totalTrips) {\\n  let maxTime = Math.min.apply(null, time) * totalTrips;\\n  let minTime = 1;\\n\\n  while (minTime < maxTime) {\\n    const midTime = Math.floor((minTime + maxTime) / 2);\\n    let trips = 0;\\n    for (const tripTime of time) {\\n      trips += Math.floor(midTime / tripTime);\\n    }\\n\\n    trips < totalTrips ? (minTime = midTime + 1) : (maxTime = midTime);\\n  }\\n\\n  return minTime;\\n};\\n\\n```\\n\\n## Rust Solution\\n\\n```rust\\nimpl Solution {\\n    pub fn minimum_time(time: Vec<i32>, total_trips: i32) -> i64 {\\n        let total_trips = total_trips as i64;\\n        let mut max_time = time.iter().min().unwrap().clone() as i64 * total_trips;\\n        let mut min_time = 1 as i64;\\n\\n        while min_time < max_time {\\n            let mid_time = (min_time + max_time) / 2;\\n            let trips = time.iter().fold(0, |subtotal, trip_time| {\\n                subtotal + mid_time / trip_time.clone() as i64\\n            });\\n\\n            if trips < total_trips {\\n                min_time = mid_time + 1;\\n            } else {\\n                max_time = mid_time;\\n            }\\n        }\\n\\n        min_time\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Rust",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} time\\n * @param {number} totalTrips\\n * @return {number}\\n */\\nvar minimumTime = function (time, totalTrips) {\\n  let maxTime = Math.min.apply(null, time) * totalTrips;\\n  let minTime = 1;\\n\\n  while (minTime < maxTime) {\\n    const midTime = Math.floor((minTime + maxTime) / 2);\\n    let trips = 0;\\n    for (const tripTime of time) {\\n      trips += Math.floor(midTime / tripTime);\\n    }\\n\\n    trips < totalTrips ? (minTime = midTime + 1) : (maxTime = midTime);\\n  }\\n\\n  return minTime;\\n};\\n\\n```\n```rust\\nimpl Solution {\\n    pub fn minimum_time(time: Vec<i32>, total_trips: i32) -> i64 {\\n        let total_trips = total_trips as i64;\\n        let mut max_time = time.iter().min().unwrap().clone() as i64 * total_trips;\\n        let mut min_time = 1 as i64;\\n\\n        while min_time < max_time {\\n            let mid_time = (min_time + max_time) / 2;\\n            let trips = time.iter().fold(0, |subtotal, trip_time| {\\n                subtotal + mid_time / trip_time.clone() as i64\\n            });\\n\\n            if trips < total_trips {\\n                min_time = mid_time + 1;\\n            } else {\\n                max_time = mid_time;\\n            }\\n        }\\n\\n        min_time\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3266423,
                "title": "daily-leetcoding-challenge-march-day-7",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 7.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-time-to-complete-trips/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-time-to-complete-trips/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1811056,
                "title": "swift-binary-search",
                "content": "By asking **Minimum Time to do something**, it sounds very likely that we can use Binary Search. The tricky part is to identify the upper bound which costed me 4 failed attempts in a row (I indeed need to improve my carefullness :(( ).\\n\\nLet\\'s say the longest bus takes `longestTime` to complete a trip, in the worst scenario we\\'ll need `longestTime * totalTrips` time to fulfill the requirement (I guess there could be a better formula, please enlighten me :pray:).\\n\\nOnce we\\'ve identified the upper bound, binary search will just kick in. So if a bus takes `busTime` to complete a trip, given a period time of `t`, the bus will be able to finish `t / busTime` trips. If the number of completed trips of all buses is greater or equal to `totalTrips`, `t` is a valid candidate. Otherwise, we\\'ll need more time.\\n\\n**Swift**\\n```swift\\nclass Solution {\\n  func minimumTime(_ time: [Int], _ totalTrips: Int) -> Int {\\n    func isValid(_ t: Int) -> Bool {\\n      var numberOfTrips = 0\\n      for busTime in time {\\n        numberOfTrips += (t / busTime)\\n\\t\\t\\n\\t\\t// as soon as we\\'ve completed at least `totalTrips`, t is valid candidate\\n\\t\\tif numberOfTrips >= totalTrips {\\n\\t\\t   return true\\n\\t\\t}\\n      }\\n      \\n      return false\\n    }\\n    \\n    let longestTime = time.max() ?? 0    \\n    var res = 0\\n    var (low, high) = (1, longestTime * totalTrips)\\n    while low <= high {\\n      let mid = low + (high - low) / 2\\n      if isValid(mid) {\\n        res = mid\\n        high = mid - 1 \\n      } else {\\n        low = mid + 1\\n      }\\n    }\\n    \\n    return res\\n  }\\n}\\n\\n// Time complextiy: O(nlogk) where n is time.count and k = 10^7 * 10^7 = 10^14\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Tree"
                ],
                "code": "```swift\\nclass Solution {\\n  func minimumTime(_ time: [Int], _ totalTrips: Int) -> Int {\\n    func isValid(_ t: Int) -> Bool {\\n      var numberOfTrips = 0\\n      for busTime in time {\\n        numberOfTrips += (t / busTime)\\n\\t\\t\\n\\t\\t// as soon as we\\'ve completed at least `totalTrips`, t is valid candidate\\n\\t\\tif numberOfTrips >= totalTrips {\\n\\t\\t   return true\\n\\t\\t}\\n      }\\n      \\n      return false\\n    }\\n    \\n    let longestTime = time.max() ?? 0    \\n    var res = 0\\n    var (low, high) = (1, longestTime * totalTrips)\\n    while low <= high {\\n      let mid = low + (high - low) / 2\\n      if isValid(mid) {\\n        res = mid\\n        high = mid - 1 \\n      } else {\\n        low = mid + 1\\n      }\\n    }\\n    \\n    return res\\n  }\\n}\\n\\n// Time complextiy: O(nlogk) where n is time.count and k = 10^7 * 10^7 = 10^14\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803205,
                "title": "binary-search-based-implementation-c",
                "content": "As we need to find the minimum time to complete, so we can observe that if the time is more than the answer than it will anyways satisfy one possible answer, so it follows binary search, \\nlike: if possible at 50 than possible at 100 also:\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int n=time.size();  \\n        unsigned long long int left=1; \\n        unsigned long long int right= 1e18;  \\n        unsigned long long ans; \\n        while(left<=right){\\n            unsigned  long long int mid=left+(right-left)/2; \\n            unsigned  long long temp=0; \\n            for(int i=0;i<n;i++){\\n                temp+=(mid/time[i]); \\n            }\\n            if(temp>=totalTrips){\\n                ans=mid; \\n                right=mid-1; \\n            }\\n            else {\\n                left=mid+1; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int n=time.size();  \\n        unsigned long long int left=1; \\n        unsigned long long int right= 1e18;  \\n        unsigned long long ans; \\n        while(left<=right){\\n            unsigned  long long int mid=left+(right-left)/2; \\n            unsigned  long long temp=0; \\n            for(int i=0;i<n;i++){\\n                temp+=(mid/time[i]); \\n            }\\n            if(temp>=totalTrips){\\n                ans=mid; \\n                right=mid-1; \\n            }\\n            else {\\n                left=mid+1; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802899,
                "title": "python-heap-no-binary-search-o-n-log-n",
                "content": "Idea, estimate a lower bound, and then refine.\\n\\n**Step 1:**\\nHow do we estimate the time needed?\\n\\nFor each truck `t` in `time`, we know that in every minute, `1/t` trip is completed.\\n\\nTherefore, `sum(1/t)` trips are completed per minute.\\n\\nAs a rough estimate, we will need `T = totalTrips/sum(1/t)` minutes to finish `totalTrips`.\\n\\n**Step 2:**\\nThe estimate in step 1 is only a lower bound. The reason is, we need complete trips.\\n\\nTherefore, assuming that partial trips are count, we will complete `totalTrips` trips in `T` minute.\\n\\nHowever, we need to round down evey trip, so there are only\\n`sum( floor(T/t) )` trips completed.\\n\\nAfter taking floor, for each truck, at most 1 trip is discarded, so the `N` trucks will waste at most `N` trips.\\n\\n**Step 3:**\\nFind a systematic way to fill up the underestimated `totalTrips - sum( floor(T/t) ) <= N` trips.\\n\\nI will do this by heap.\\n\\nAt time `est`, For each truck `t`, we will compute the next time for `t` to finish its next trip (implemented in the function `ceiling(est, t)` below).\\n\\nThen, we push the tuple `(ceiling(est, t), t)` to the heap.\\n\\nThen, for each pop in the heap, we know there is another trip completed, so we increment the trip count by 1 and push the next trip completion time to the heap.\\n\\n**Complexity analysis:**\\nEvery thing up to step 2 is O(N).\\n\\nFrom the analysis in step 2, we know that in the worst case we need to emulate N trips.\\n\\nConstructing the heap is O(N log N)\\n\\nPoping and pushing in the loop is O(log N). Multiply by N, the worst case, the loop takes at most O(N log N).\\n\\nSo the overall algorithm is O(N log N).\\n\\n2076 ms, beats 90%.\\n\\n```\\nimport heapq\\n\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        # Return the smallest multiple of b strictly greater than a.\\n        def ceiling(a, b):\\n            return a // b * b + b\\n        \\n\\t\\t# Step 1: Find est, an initial lower bound\\n        speed = sum(1/t for t in time)\\n        est = int(totalTrips/speed)\\n        \\n\\t\\t# Step 2: Construct the heap\\n        trips = 0\\n        hp = []\\n        for t in time:\\n\\t\\t    # ceiling(est, t) is the next returning time for the truck t\\n            heappush(hp, (ceiling(est, t), t))\\n\\t\\t\\t# Compute trips, the number of trips actually finished at time est\\n            trips += est // t\\n            \\n\\t    # Step 3: Heap update\\n        answer = est\\n        while trips < totalTrips:\\n\\t\\t    # Update the returning time as answer for every incoming trip\\n            answer, t = heappop(hp)\\n\\t\\t\\t# Push back the next returning time for the same truck which just returned.\\n            heappush(hp, (ceiling(answer, t), t))\\n            trips += 1\\n            \\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        # Return the smallest multiple of b strictly greater than a.\\n        def ceiling(a, b):\\n            return a // b * b + b\\n        \\n\\t\\t# Step 1: Find est, an initial lower bound\\n        speed = sum(1/t for t in time)\\n        est = int(totalTrips/speed)\\n        \\n\\t\\t# Step 2: Construct the heap\\n        trips = 0\\n        hp = []\\n        for t in time:\\n\\t\\t    # ceiling(est, t) is the next returning time for the truck t\\n            heappush(hp, (ceiling(est, t), t))\\n\\t\\t\\t# Compute trips, the number of trips actually finished at time est\\n            trips += est // t\\n            \\n\\t    # Step 3: Heap update\\n        answer = est\\n        while trips < totalTrips:\\n\\t\\t    # Update the returning time as answer for every incoming trip\\n            answer, t = heappop(hp)\\n\\t\\t\\t# Push back the next returning time for the same truck which just returned.\\n            heappush(hp, (ceiling(answer, t), t))\\n            trips += 1\\n            \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270314,
                "title": "java-binary-search-10-lines-beats-99",
                "content": "# Complexity\\n- Time complexity: $$O(n*log(1e14))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long minimumTime(int[] time, int totalTrips) {\\n    long l = 1, r = (long) 1e14;\\n\\n    while (l < r) {\\n      var m = l + (r-l) / 2;\\n      var trips = 0L;\\n\\n      for (var i=0; i < time.length && trips < totalTrips; i++)\\n        trips += m / time[i];\\n      \\n      if (trips < totalTrips) l = m+1;\\n      else r = m;\\n    }\\n    return l;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  public long minimumTime(int[] time, int totalTrips) {\\n    long l = 1, r = (long) 1e14;\\n\\n    while (l < r) {\\n      var m = l + (r-l) / 2;\\n      var trips = 0L;\\n\\n      for (var i=0; i < time.length && trips < totalTrips; i++)\\n        trips += m / time[i];\\n      \\n      if (trips < totalTrips) l = m+1;\\n      else r = m;\\n    }\\n    return l;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267813,
                "title": "solution-with-clear-explanation-and-example-with-a-plot",
                "content": "# Intuition\\n--> Since number of trips possible for a given number of days with respect to time array is monotonic, we can use Binary search on the ouput limit.\\n\\n--> Output is monotonic because when output increases trips you can make is non decresing with respect to time array.\\n\\n--> Example to understand it is monotonic, if time = [5,10,10] ,totalTrips = 9 .\\n\\nTrips Vs Days is non decreasing or monotonic.\\n\\n![Image 3-7-23 at 4.25 AM.jpeg](https://assets.leetcode.com/users/images/281a8410-b1e8-40c1-8fbe-0617976f6f67_1678181163.4239738.jpeg)\\n\\n\\n\\n\\n# Approach\\n--> Trip counter function is calculating number of trips you can make when you are given some number of days\\n--> Since answer remains between 1 and totalTrips*min(time) we can use binary search.\\n--> lets say you have time = [5,10,10] ,totalTrips = 9 , then your output limits are 1 and 9 multpipied by 5.\\n\\n\\n# Complexity\\n- Time complexity:\\n--> Worst case complexity is O(Nlogk)\\n--> N is number of elememts in time\\n--> k is 10**14 in worst case\\n\\n- Space complexity:\\n--> O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n\\n        def trip_counter(num):\\n\\n            i = 0\\n\\n            trips = 0\\n\\n            while i < len(time):\\n\\n                trips += num // time[i]\\n                i+=1\\n                if trips > totalTrips:\\n                    break\\n\\n            return trips\\n        \\n        start = 1\\n        end = totalTrips*min(time) \\n\\n        while start <= end:\\n\\n            mid = (start+end)//2\\n\\n            trips = trip_counter(mid)\\n\\n            if trips >= totalTrips:\\n                end = mid-1\\n            \\n            else:\\n                start = mid+1\\n        \\n\\n        return start\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n\\n        def trip_counter(num):\\n\\n            i = 0\\n\\n            trips = 0\\n\\n            while i < len(time):\\n\\n                trips += num // time[i]\\n                i+=1\\n                if trips > totalTrips:\\n                    break\\n\\n            return trips\\n        \\n        start = 1\\n        end = totalTrips*min(time) \\n\\n        while start <= end:\\n\\n            mid = (start+end)//2\\n\\n            trips = trip_counter(mid)\\n\\n            if trips >= totalTrips:\\n                end = mid-1\\n            \\n            else:\\n                start = mid+1\\n        \\n\\n        return start\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374139,
                "title": "c-easy-and-simple-c-code-82-time-o-nlogn",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int Trips(long long mid, vector<int>& time, int totalTrips)\\n    {\\n        long long n = time.size(), ans = 0;\\n        for(int &num : time)\\n            ans += mid/num;\\n        if(ans >= totalTrips)\\n            return true;\\n        return false;\\n    }\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int m = time.size();\\n        long long i = 1, ans = 0;\\n        long long j = (long long)time[0]*totalTrips;\\n        while(i <= j)\\n        {\\n            long long mid = i + (j-i)/2;\\n            if(Trips(mid, time, totalTrips))\\n            {\\n                ans = mid;\\n                j = mid-1;\\n            }\\n            else\\n            {\\n                i = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int Trips(long long mid, vector<int>& time, int totalTrips)\\n    {\\n        long long n = time.size(), ans = 0;\\n        for(int &num : time)\\n            ans += mid/num;\\n        if(ans >= totalTrips)\\n            return true;\\n        return false;\\n    }\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int m = time.size();\\n        long long i = 1, ans = 0;\\n        long long j = (long long)time[0]*totalTrips;\\n        while(i <= j)\\n        {\\n            long long mid = i + (j-i)/2;\\n            if(Trips(mid, time, totalTrips))\\n            {\\n                ans = mid;\\n                j = mid-1;\\n            }\\n            else\\n            {\\n                i = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802789,
                "title": "javascript-binary-search-916ms",
                "content": "```\\nlet a, tot;\\nconst minimumTime = (time, totalTrips) => {\\n    a = time,\\n    tot = totalTrips;\\n    let min = Math.min(...a);\\n    if (tot == 1) return min;\\n    return BinarySearch(0, 1e14);\\n};\\n\\nconst BinarySearch = (low, high) => {\\n    while (low <= high) {\\n        let mid = parseInt((low + high) / 2);\\n        if (possible(mid)) { // if current sum < tot, we need make low increasing, otherwise high decreasing\\n            low = mid + 1;\\n        } else {\\n            high = mid - 1;\\n        }\\n    }\\n    return low;\\n};\\n\\nconst possible = (t) => { // accumlate sum of trips of current t\\n    let sum = 0;\\n    for (const x of a) sum += parseInt(t / x);\\n    return sum < tot;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nlet a, tot;\\nconst minimumTime = (time, totalTrips) => {\\n    a = time,\\n    tot = totalTrips;\\n    let min = Math.min(...a);\\n    if (tot == 1) return min;\\n    return BinarySearch(0, 1e14);\\n};\\n\\nconst BinarySearch = (low, high) => {\\n    while (low <= high) {\\n        let mid = parseInt((low + high) / 2);\\n        if (possible(mid)) { // if current sum < tot, we need make low increasing, otherwise high decreasing\\n            low = mid + 1;\\n        } else {\\n            high = mid - 1;\\n        }\\n    }\\n    return low;\\n};\\n\\nconst possible = (t) => { // accumlate sum of trips of current t\\n    let sum = 0;\\n    for (const x of a) sum += parseInt(t / x);\\n    return sum < tot;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802733,
                "title": "c-binary-search-approach-easy-to-understand",
                "content": "``` \\nbool check(vector<int>& arr,long long int trip,long long int m){\\n        long res = 0;\\n        for(int i : arr){\\n            res += (m/i);\\n            \\n            if(res>=trip){\\n                return true;\\n            }\\n        }\\n        return res>=trip;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long int s = 0;\\n        long long int e = 1e18;\\n        \\n        while(e-s>1){\\n            long m = (s+e)/2;\\n            \\n            if(check(time,totalTrips,m)){\\n                e = m;\\n            }else{\\n                s = m+1;\\n            }\\n        }\\n        \\n        if(check(time,totalTrips,s)) return s;\\n        return e;\\n    }\\n\\t```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "``` \\nbool check(vector<int>& arr,long long int trip,long long int m){\\n        long res = 0;\\n        for(int i : arr){\\n            res += (m/i);\\n            \\n            if(res>=trip){\\n                return true;\\n            }\\n        }\\n        return res>=trip;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long int s = 0;\\n        long long int e = 1e18;\\n        \\n        while(e-s>1){\\n            long m = (s+e)/2;\\n            \\n            if(check(time,totalTrips,m)){\\n                e = m;\\n            }else{\\n                s = m+1;\\n            }\\n        }\\n        \\n        if(check(time,totalTrips,s)) return s;\\n        return e;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802667,
                "title": "python3-binary-search",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/6f8a2c98f0feab59d2e0ec35f928e3ee1d3e4456) for solutions of weekly 282. \\n\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        lo, hi = 0, max(time) * totalTrips\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if sum(mid//x for x in time) < totalTrips: lo = mid + 1\\n            else: hi = mid \\n        return lo \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        lo, hi = 0, max(time) * totalTrips\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if sum(mid//x for x in time) < totalTrips: lo = mid + 1\\n            else: hi = mid \\n        return lo \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802647,
                "title": "very-easy-binary-search",
                "content": "```\\nclass Solution {\\n    bool valid(vector<int>& time , long long mid , long long totalTrips){\\n        int n = time.size();\\n        long long sum = 0;\\n        for(int i = 0 ; i  < n; i++){\\n            sum += (mid/time[i]);\\n\\n        }\\n        return sum >= totalTrips;\\n    }\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int n = time.size();\\n        long long l = 0 , r = 100000000000002;\\n        long long ans = 0;\\n        while(l <= r){\\n            long long mid = (l + r)/2;\\n            if(valid(time , mid , totalTrips)){\\n                ans = mid ;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    bool valid(vector<int>& time , long long mid , long long totalTrips){\\n        int n = time.size();\\n        long long sum = 0;\\n        for(int i = 0 ; i  < n; i++){\\n            sum += (mid/time[i]);\\n\\n        }\\n        return sum >= totalTrips;\\n    }\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int n = time.size();\\n        long long l = 0 , r = 100000000000002;\\n        long long ans = 0;\\n        while(l <= r){\\n            long long mid = (l + r)/2;\\n            if(valid(time , mid , totalTrips)){\\n                ans = mid ;\\n                r = mid - 1;\\n            }\\n            else\\n                l = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802537,
                "title": "with-logic-and-intuition-o-1-space",
                "content": "**using binary search** \\nIntuition : **if (we can do toatalTrips in x second):**\\n                  then the **minimum time** required must be **in range [start,x]**\\n             **else:**\\n                  the **minimum time** required must be **in range [x+1,end]**\\n**where start = 1, end = LLONG_MAX**\\n```\\nclass Solution {\\npublic:\\n    bool doit(vector<int>& time, long long avail, long long todo) {\\n        long long total(0);\\n        for (auto& t : time) {\\n            if (t > avail)   break;\\n            total += (avail/t);\\n            if (total >= todo)  return true;\\n        }\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int total) {\\n        \\n        sort(begin(time), end(time));\\n        long long start=1, end=LLONG_MAX; \\n        while (start < end) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0long long mid = start + (end - start) / 2;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (doit(time, mid, total))  end = mid;\\n            else    start = mid+1;\\n        }\\n        return end;\\n    }\\n};\\n```\\n**Upvote it if it helps :)**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool doit(vector<int>& time, long long avail, long long todo) {\\n        long long total(0);\\n        for (auto& t : time) {\\n            if (t > avail)   break;\\n            total += (avail/t);\\n            if (total >= todo)  return true;\\n        }\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int total) {\\n        \\n        sort(begin(time), end(time));\\n        long long start=1, end=LLONG_MAX; \\n        while (start < end) {\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0long long mid = start + (end - start) / 2;\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0if (doit(time, mid, total))  end = mid;\\n            else    start = mid+1;\\n        }\\n        return end;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276740,
                "title": "solution-in-java-2187-minimum-time-to-complete-trips",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public long minimumTime(int[] time, int totalTrips) {\\n    long l = 1;\\n    long r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n\\n    while (l < r) {\\n      final long m = (l + r) / 2;\\n      if (numTrips(time, m) >= totalTrips)\\n        r = m;\\n      else\\n        l = m + 1;\\n    }\\n\\n    return l;\\n  }\\n\\n  private long numTrips(int[] time, long m) {\\n    return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public long minimumTime(int[] time, int totalTrips) {\\n    long l = 1;\\n    long r = Arrays.stream(time).min().getAsInt() * (long) totalTrips;\\n\\n    while (l < r) {\\n      final long m = (l + r) / 2;\\n      if (numTrips(time, m) >= totalTrips)\\n        r = m;\\n      else\\n        l = m + 1;\\n    }\\n\\n    return l;\\n  }\\n\\n  private long numTrips(int[] time, long m) {\\n    return Arrays.stream(time).asLongStream().reduce(0L, (subtotal, t) -> subtotal + m / t);\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269907,
                "title": "c-solution-easy-and-simple-explanation-binary-search-o-n-long-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere the Binary Search concept is used.  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Apply the binary search on the maximum possible time which is 10^14 deduced from the constraints given. \\n2. Every time find the total number of trips that are possible, which are calculated by the dividing the particular time by time taken by ith bus.\\n\\n# Complexity\\n- Time complexity: O(N*log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int tt) {\\n        long long i = 1, j = 1e14, mid;\\n        while(i < j){\\n            mid = i+(j-i)/2;\\n            long long ans = 0;\\n            for (auto i : time){\\n                ans+= mid/i;\\n            }\\n            if (ans >= tt){\\n                j = mid;\\n            }\\n            else i = mid+1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int tt) {\\n        long long i = 1, j = 1e14, mid;\\n        while(i < j){\\n            mid = i+(j-i)/2;\\n            long long ans = 0;\\n            for (auto i : time){\\n                ans+= mid/i;\\n            }\\n            if (ans >= tt){\\n                j = mid;\\n            }\\n            else i = mid+1;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269432,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Binary Search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N * logN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        ll l = 1, r = 1e14;\\n        while(l <= r) {\\n            ll trip = 0, mid = (l + r) / 2;\\n            for(int i=0; i<time.size(); i++) trip += mid / time[i];\\n            if(trip < totalTrips) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        ll l = 1, r = 1e14;\\n        while(l <= r) {\\n            ll trip = 0, mid = (l + r) / 2;\\n            for(int i=0; i<time.size(); i++) trip += mid / time[i];\\n            if(trip < totalTrips) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269370,
                "title": "c-detailed-image-explanation-binary-search-easy-to-understand",
                "content": "**general observation :-**\\n\\t\\t1.here we use concept of binary search . our main motive is to find minimum time required for all buses to complete at least totalTrips trips.\\n\\t\\t2.whenever there is **uncertenty in selecting any number** then we use **binary search** . we have to use number line for binary search and given Time array is used for validating whether assumed value(mid ) leads to answer or not . if it leads to answer then ok , in this question totalTrips is target with the help of time array . if we have multiple mid then return minimum all among them .\\n\\n**STEPS :-**\\n1.define **left=0 , right=1e14 or totalTrips x (long long)time[0**] . this is beacuse total time may be 10 to the power 14 (see constriants below)\\n2.calculate **mid** as we do in **binary search.**\\n3.when we have mid treat this mid , as time to complete TotalTrips.\\nwe have to minimise it since in question it is said to calculate least time to complete TotalTrips trips .\\n4.see if using that time **we exceed or equal to TotalTrips or not** . if yes then there may be less time which can complete given trips .so make **right =mid** and do same for left subpart .\\n5.otherwise select right subpart and make **left=mid+1.**\\n6.repeat it untill **left<right.**\\n\\n![image](https://assets.leetcode.com/users/images/f8a8aff3-155b-4a82-9353-e89774d45f16_1678206231.6091678.png)\\n\\n```\\nPLEASE upvote if you like my solution . it motivates me lot \\n```\\n![image](https://assets.leetcode.com/users/images/b70153ab-a3a1-4219-ad40-1b77728c79ba_1678206758.7823985.png)\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    long long solve(vector<int> reqTime, int totalTrips) {\\n        long long start = 0;\\n        long long end = 1e14;\\n        long long ans = 0;\\n        \\n        while(start <= end) {\\n            \\n            long long mid = start +(end-start) / 2;\\n            long long trips = 0;\\n            \\n            // Considering mid as required time. If we get desired count of totalTrips by using time == mid.\\n            // it will store that ans, else if(required trips < totalTrips), start = mid + 1.\\n            for(auto reqTimee : reqTime) {\\n                trips += mid / reqTimee;\\n            }\\n            \\n            if(trips >= totalTrips) {\\n                ans = mid;\\n                end = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        return solve(time, totalTrips);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nPLEASE upvote if you like my solution . it motivates me lot \\n```\n```\\nclass Solution {\\npublic:\\n    long long solve(vector<int> reqTime, int totalTrips) {\\n        long long start = 0;\\n        long long end = 1e14;\\n        long long ans = 0;\\n        \\n        while(start <= end) {\\n            \\n            long long mid = start +(end-start) / 2;\\n            long long trips = 0;\\n            \\n            // Considering mid as required time. If we get desired count of totalTrips by using time == mid.\\n            // it will store that ans, else if(required trips < totalTrips), start = mid + 1.\\n            for(auto reqTimee : reqTime) {\\n                trips += mid / reqTimee;\\n            }\\n            \\n            if(trips >= totalTrips) {\\n                ans = mid;\\n                end = mid-1;\\n            }\\n            else {\\n                start = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        return solve(time, totalTrips);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269178,
                "title": "wow-very-easy-dart-binary-search-solution-100-beats-o-n-logn-time-complexity",
                "content": "\\n# Complexity\\n- Time complexity: $$O(N*logN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int minimumTime(List<int> time, int totalTrips) {\\n      int maxTime = time.reduce(min) * totalTrips;\\n      int minTime = 0;\\n\\n      while (minTime <= maxTime) {\\n          int middle = (maxTime + minTime) ~/ 2;\\n\\n          //count trips(middle)\\n          int trips = 0;\\n          for (int busTime in time) {\\n              trips += middle ~/ busTime;\\n          }\\n\\n          if (trips >= totalTrips) {\\n              maxTime = middle - 1;\\n          }\\n          else {\\n              minTime = middle + 1;\\n          }\\n      }\\n\\n      return minTime;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int minimumTime(List<int> time, int totalTrips) {\\n      int maxTime = time.reduce(min) * totalTrips;\\n      int minTime = 0;\\n\\n      while (minTime <= maxTime) {\\n          int middle = (maxTime + minTime) ~/ 2;\\n\\n          //count trips(middle)\\n          int trips = 0;\\n          for (int busTime in time) {\\n              trips += middle ~/ busTime;\\n          }\\n\\n          if (trips >= totalTrips) {\\n              maxTime = middle - 1;\\n          }\\n          else {\\n              minTime = middle + 1;\\n          }\\n      }\\n\\n      return minTime;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269047,
                "title": "python3-1737-ms-faster-than-97-75-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/dd9c3714-4bca-483d-8fc6-8411cb7a43e4_1678200467.7560015.png)\\n```\\ndef minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        def check(t):\\n            res = 0\\n            for e in time:\\n                res += t//e\\n            return res >= totalTrips\\n        maxt = max(time)\\n        left, right = 1, (totalTrips//sum([maxt//e for e in time]) + 1)*maxt\\n        while left < right:\\n            m = (left + right)//2\\n            if check(m):\\n                right = m\\n            else:\\n                left = m + 1\\n        return left\\n```\\nhere\\'s a step-by-step explanation of the code:\\n\\n1. Define a function check(t) that takes an integer t and returns True if the number of trips that can be completed in t time is greater than or equal to the total number of trips needed (totalTrips), otherwise returns False.\\n1. Initialize a variable maxt to the maximum value in the time list.\\n1. Initialize left to 1 and right to a value that guarantees that there will be enough time to complete all the trips. This value is calculated as follows:\\n\\t1. For each element e in the time list, calculate the number of trips that can be completed in maxt time (i.e., maxt//e).\\n\\t1. Add up all these values to get the total number of trips that can be completed in maxt time.\\n\\t1. Divide totalTrips by this total number of trips to get an estimate of the minimum amount of time needed to complete all the trips.\\n\\t1. Multiply this estimate by maxt to get an upper bound on the time needed to complete all the trips.\\n1. While left is less than right, do the following:\\n\\t1. Calculate the midpoint m between left and right.\\n\\t1. If check(m) returns True, set right to m.\\n\\t1. Otherwise, set left to m + 1.\\n1. When the while loop terminates, return left, which represents the minimum amount of time needed to complete all the trips.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        def check(t):\\n            res = 0\\n            for e in time:\\n                res += t//e\\n            return res >= totalTrips\\n        maxt = max(time)\\n        left, right = 1, (totalTrips//sum([maxt//e for e in time]) + 1)*maxt\\n        while left < right:\\n            m = (left + right)//2\\n            if check(m):\\n                right = m\\n            else:\\n                left = m + 1\\n        return left\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3268958,
                "title": "python-solution-faster-than-96-of-other-solutions",
                "content": "Please Upvote if you like it.\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        a, b = 1, totalTrips * min(time)\\n\\n        def f(x):\\n            return sum(x // t for t in time) >= totalTrips\\n    \\n        while a < b:\\n            m = (a + b) // 2\\n            if not f(m): a = m + 1\\n            else: b = m\\n        return a",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "Please Upvote if you like it.\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        a, b = 1, totalTrips * min(time)\\n\\n        def f(x):\\n            return sum(x // t for t in time) >= totalTrips\\n    \\n        while a < b:\\n            m = (a + b) // 2\\n            if not f(m): a = m + 1\\n            else: b = m\\n        return a",
                "codeTag": "Java"
            },
            {
                "id": 3268852,
                "title": "java-easy-binary-search-with-explain-t-c-o-nlogn-s-c-o-1",
                "content": "```\\n    class Solution {\\n\\t// TC : O(nlogn)\\n\\t// SC: O(1)\\n\\tpublic long minimumTime(int[] time, int totalTrips) {\\n\\n\\n\\t\\tlong left = 1;\\n\\t\\tlong min = time[0];\\n\\t\\tfor(int t : time){\\n\\t\\t\\tmin = Math.min(min, t);\\n\\t\\t}\\n\\t\\tlong right = totalTrips * min;\\n\\n\\t\\twhile(left < right){\\n\\t\\t\\tlong mid = (right - left) / 2 + left;\\n\\n\\t\\t\\t//How many trip we can do\\n\\t\\t\\tlong total = totalTripInGivenTime(time, mid);\\n\\t\\t\\t//We cannot reach totalTrips, means mid is too small\\n\\t\\t\\tif(total < totalTrips){\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\t//We can reach totalTrips, but we want right to be as small as possible\\n\\t\\t\\t\\t//Therefore, we don\\'t need to + 1\\n\\t\\t\\t\\tright = mid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn left;\\n\\t}\\n\\n\\tprivate long totalTripInGivenTime(int[] time, long givenTime){\\n\\t\\tlong totalTrips = 0l;\\n\\t\\tfor(int tripTime : time){\\n\\t\\t\\ttotalTrips += ((long)givenTime) / tripTime;\\n\\t\\t}\\n\\t\\treturn totalTrips;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    class Solution {\\n\\t// TC : O(nlogn)\\n\\t// SC: O(1)\\n\\tpublic long minimumTime(int[] time, int totalTrips) {\\n\\n\\n\\t\\tlong left = 1;\\n\\t\\tlong min = time[0];\\n\\t\\tfor(int t : time){\\n\\t\\t\\tmin = Math.min(min, t);\\n\\t\\t}\\n\\t\\tlong right = totalTrips * min;\\n\\n\\t\\twhile(left < right){\\n\\t\\t\\tlong mid = (right - left) / 2 + left;\\n\\n\\t\\t\\t//How many trip we can do\\n\\t\\t\\tlong total = totalTripInGivenTime(time, mid);\\n\\t\\t\\t//We cannot reach totalTrips, means mid is too small\\n\\t\\t\\tif(total < totalTrips){\\n\\t\\t\\t\\tleft = mid + 1;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\t//We can reach totalTrips, but we want right to be as small as possible\\n\\t\\t\\t\\t//Therefore, we don\\'t need to + 1\\n\\t\\t\\t\\tright = mid;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn left;\\n\\t}\\n\\n\\tprivate long totalTripInGivenTime(int[] time, long givenTime){\\n\\t\\tlong totalTrips = 0l;\\n\\t\\tfor(int tripTime : time){\\n\\t\\t\\ttotalTrips += ((long)givenTime) / tripTime;\\n\\t\\t}\\n\\t\\treturn totalTrips;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268548,
                "title": "c-java-solution-using-binary-search-minimum-time-to-complete-trips",
                "content": "# Complexity\\n- Time complexity: $$O(nlog(x))$$ $$where$$ $$x=100000000000000$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    bool numberOfTripsForGivenTime(vector<int>&a, long long int givenTime, int totalTrips)\\n    {\\n        long long int currTotalTrips = 0;\\n        for(auto x : a)\\n            currTotalTrips += (givenTime /(long long int) x);\\n\\n        return currTotalTrips >= totalTrips;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long int lowestTime = 1;\\n        long long int highestTime = 1e14;\\n        while(lowestTime<highestTime)\\n        {\\n            long long int mid = lowestTime + (highestTime-lowestTime)/2;\\n            \\n            if(numberOfTripsForGivenTime(time , mid, totalTrips))\\n                highestTime = mid;\\n            else\\n                lowestTime = mid+1;\\n        }\\n        return lowestTime;\\n    }\\n};\\n```\\n``` Java []\\nclass Solution {\\n    private boolean numberOfTripsForGivenTime(int [] a, long givenTime, int totalTrips)\\n    {\\n        long currTotalTrips = 0;\\n        for(int x : a)\\n            currTotalTrips += (givenTime / (long)x);\\n\\n        return currTotalTrips >= totalTrips;\\n    }\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lowestTime = 1;\\n        long highestTime = 100000000000000L;\\n        while(lowestTime<highestTime)\\n        {\\n            long mid = lowestTime + (highestTime-lowestTime)/2;\\n            \\n            if(numberOfTripsForGivenTime(time , mid, totalTrips))\\n                highestTime = mid;\\n            else\\n                lowestTime = mid+1;\\n        }\\n        return lowestTime;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    bool numberOfTripsForGivenTime(vector<int>&a, long long int givenTime, int totalTrips)\\n    {\\n        long long int currTotalTrips = 0;\\n        for(auto x : a)\\n            currTotalTrips += (givenTime /(long long int) x);\\n\\n        return currTotalTrips >= totalTrips;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long int lowestTime = 1;\\n        long long int highestTime = 1e14;\\n        while(lowestTime<highestTime)\\n        {\\n            long long int mid = lowestTime + (highestTime-lowestTime)/2;\\n            \\n            if(numberOfTripsForGivenTime(time , mid, totalTrips))\\n                highestTime = mid;\\n            else\\n                lowestTime = mid+1;\\n        }\\n        return lowestTime;\\n    }\\n};\\n```\n``` Java []\\nclass Solution {\\n    private boolean numberOfTripsForGivenTime(int [] a, long givenTime, int totalTrips)\\n    {\\n        long currTotalTrips = 0;\\n        for(int x : a)\\n            currTotalTrips += (givenTime / (long)x);\\n\\n        return currTotalTrips >= totalTrips;\\n    }\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lowestTime = 1;\\n        long highestTime = 100000000000000L;\\n        while(lowestTime<highestTime)\\n        {\\n            long mid = lowestTime + (highestTime-lowestTime)/2;\\n            \\n            if(numberOfTripsForGivenTime(time , mid, totalTrips))\\n                highestTime = mid;\\n            else\\n                lowestTime = mid+1;\\n        }\\n        return lowestTime;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268137,
                "title": "minimum-time-to-complete-trips-easy-to-understand-optimal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. firstly we can think for the maximum and minimum ans can be possible. so, we can get that the minimum ans can 1 and maximum ans can be 1e14.\\n2. so we got the range where we can run our binary search approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. now we run will binary search from 0 to 1e14\\n2. where every time mid represents how much time had already happend\\n3. if we divide mid by the given time vector. so, we will get how much trips can be completed by all the buses in that time.\\n4. finally we can sum up to get total trips \\n5. And then follow the two conditions of binary search to increase start or reduce end.\\n6. finally, as the loop ends will will get our ans.\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long start=1,end=1e14,ans;\\n        while(start<=end){\\n            long long mid=start+(end-start)/2,sum=0;\\n            for(auto it:time){\\n                sum+=mid/it;\\n            }\\n            if(sum<totalTrips){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long start=1,end=1e14,ans;\\n        while(start<=end){\\n            long long mid=start+(end-start)/2,sum=0;\\n            for(auto it:time){\\n                sum+=mid/it;\\n            }\\n            if(sum<totalTrips){\\n                start=mid+1;\\n            }\\n            else{\\n                end=mid-1;\\n                ans=mid;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267852,
                "title": "beats-100-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nas the question requires as to find the minimum time required to finish the total trip. first i needed to find the range in which the solution can lay and traverse through that inorder to reach an optimal solution. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used binary search to solve the question in which i first looked for the left and right bound of the solution in which i found that the potential left boundary that is lowest possible answer is the minimum time taken to finish one trip. as the minimum amount of trip required can only be one. and also the maximum time taken is also can be calculated as (minimum time taken * the total trip required).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n)) - for the sorting the values in descending order \\nO(nlog(n)) - for the search for the valid trip\\noverall - O(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe don\\'t have addtional space to store value that grows as our answer changes hence :- O(1)\\n# Code\\n```\\nclass Solution:\\n    def satisfiesTrip(self,mid, time, totalTrip):\\n        trip = 0\\n        for t in time:\\n            trip += mid//t\\n            if trip >= totalTrip:\\n                return True\\n        return False\\n\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        time.sort(reverse=True)\\n        minimum = min(time)\\n        left = minimum\\n        right = minimum*totalTrips\\n        while left < right:\\n            mid = (left+ right)//2\\n\\n            if self.satisfiesTrip(mid, time, totalTrips):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return right\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def satisfiesTrip(self,mid, time, totalTrip):\\n        trip = 0\\n        for t in time:\\n            trip += mid//t\\n            if trip >= totalTrip:\\n                return True\\n        return False\\n\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        time.sort(reverse=True)\\n        minimum = min(time)\\n        left = minimum\\n        right = minimum*totalTrips\\n        while left < right:\\n            mid = (left+ right)//2\\n\\n            if self.satisfiesTrip(mid, time, totalTrips):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return right\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267530,
                "title": "easy-c-solution",
                "content": "# Intuition\\nSo we need to find the min time to complete the totaltrips.We already know the time for each bus to complete one trip.From it we can find the range of time to complete the totalTrips;\\n# Approach\\nFirst we will find the range of possible time,\\nmintime=min value in time * totalTrips;\\n(form constraints it is clear that both time[i]and totalTrips has a min value of 1.Therefore mintime=1 always);\\nmaxtime=max value in time * totalTrips;\\n(this we will find by extracting max value in vector time)\\n\\nNow we have our time range(start=mintime and end=maxtime) now we will apply binary search  and check if this mid (time) can complete totalTrips.\\nif YES than store it in ans and do maxtime=mid-1;\\nelse mintime=mid+1;\\n\\nTo check if time is feasible we will create a function \"isSafe\" which find the value of total trip which can be completed in time(value of mid); \\n\\n# Complexity\\n- Time complexity:O(nlogk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isSafe(vector<int>& time, long long possible_time,int totalTrips){\\n        long long possible_trips=0;\\n        for(auto value:time){\\n            possible_trips+=possible_time/value;\\n           \\n        }\\n         if(possible_trips>=totalTrips)\\n            return true;\\n            return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxArray=INT_MIN;\\n        for(auto i:time){\\n            if(i>maxArray)\\n            maxArray=i;\\n        }\\n        long long ans=1;\\n        long long minTime=1,maxTime=totalTrips*maxArray;\\n        while(minTime<=maxTime){\\n            long long mid=minTime+(maxTime-minTime)/2;\\n            if(isSafe(time, mid,totalTrips)){\\n                ans=mid;\\n                maxTime=mid-1;\\n            }\\n            else{\\n                minTime=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe(vector<int>& time, long long possible_time,int totalTrips){\\n        long long possible_trips=0;\\n        for(auto value:time){\\n            possible_trips+=possible_time/value;\\n           \\n        }\\n         if(possible_trips>=totalTrips)\\n            return true;\\n            return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxArray=INT_MIN;\\n        for(auto i:time){\\n            if(i>maxArray)\\n            maxArray=i;\\n        }\\n        long long ans=1;\\n        long long minTime=1,maxTime=totalTrips*maxArray;\\n        while(minTime<=maxTime){\\n            long long mid=minTime+(maxTime-minTime)/2;\\n            if(isSafe(time, mid,totalTrips)){\\n                ans=mid;\\n                maxTime=mid-1;\\n            }\\n            else{\\n                minTime=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267309,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips)\\n     {\\n        long long left=0,right=totalTrips*(long long)time[0],ans=right;\\n        while(left<right)\\n        {\\n            long long mid=(left+right)/2;\\n            long long count=0;\\n            for(int i=0;i<time.size();++i)\\n            {\\n                count+=mid/time[i];     \\n            } \\n            if(count>=totalTrips)\\n            {\\n                ans=min(ans,mid);\\n                right=mid;\\n            }\\n            else\\n            {\\n                left=mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips)\\n     {\\n        long long left=0,right=totalTrips*(long long)time[0],ans=right;\\n        while(left<right)\\n        {\\n            long long mid=(left+right)/2;\\n            long long count=0;\\n            for(int i=0;i<time.size();++i)\\n            {\\n                count+=mid/time[i];     \\n            } \\n            if(count>=totalTrips)\\n            {\\n                ans=min(ans,mid);\\n                right=mid;\\n            }\\n            else\\n            {\\n                left=mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267249,
                "title": "java-brute-force-approach",
                "content": "```\\n// Approach: Brute Force - TLE\\n\\n// Time complexity: O(n * t)\\n// Space complexity: O(n)\\n\\npublic long minimumTime(int[] time, int totalTrips) {\\n\\tint currTime = 1;\\n\\n\\twhile (true) {\\n\\t\\tint trips = 0;\\n\\n\\t\\tfor (int t : time) \\n\\t\\t\\ttrips += currTime / t;\\n\\n\\t\\tif (trips >= totalTrips)\\n\\t\\t\\tbreak;\\n\\n\\t\\tcurrTime++;\\n\\t}\\n\\n\\treturn currTime;\\n}\\n```\\n\\n**Note:** This solution gives TLE. It\\'s provided just for understanding purpose.\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Approach: Brute Force - TLE\\n\\n// Time complexity: O(n * t)\\n// Space complexity: O(n)\\n\\npublic long minimumTime(int[] time, int totalTrips) {\\n\\tint currTime = 1;\\n\\n\\twhile (true) {\\n\\t\\tint trips = 0;\\n\\n\\t\\tfor (int t : time) \\n\\t\\t\\ttrips += currTime / t;\\n\\n\\t\\tif (trips >= totalTrips)\\n\\t\\t\\tbreak;\\n\\n\\t\\tcurrTime++;\\n\\t}\\n\\n\\treturn currTime;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3267150,
                "title": "java-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n      long low=1;\\n      long end=0;\\n     for(int i:time)end=Math.max(end,i);\\n       end=end*totalTrips;\\n      while(low<end)\\n      {\\n          long mid=(low+end)/2;\\n          long r=0;\\n          for(int i: time)\\n          {\\n             if(i<=mid){\\n                r+=mid/i;   \\n             }\\n             if(r>totalTrips)break;\\n          }\\n          if(r<totalTrips)low=mid+1;\\n          else end=mid; \\n      }\\n      return low;\\n\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n      long low=1;\\n      long end=0;\\n     for(int i:time)end=Math.max(end,i);\\n       end=end*totalTrips;\\n      while(low<end)\\n      {\\n          long mid=(low+end)/2;\\n          long r=0;\\n          for(int i: time)\\n          {\\n             if(i<=mid){\\n                r+=mid/i;   \\n             }\\n             if(r>totalTrips)break;\\n          }\\n          if(r<totalTrips)low=mid+1;\\n          else end=mid; \\n      }\\n      return low;\\n\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267098,
                "title": "python-one-liner-two-liner",
                "content": "# Approach\\nBinary search (or rather, bisect) the minimum time required to fulfill all trips.\\n\\n# Code\\n\\n### Two liner\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        check = lambda t: sum(t // bus for bus in time) >= totalTrips\\n        return bisect_left(range(time[0] * totalTrips), True, key=check)\\n\\n```\\n\\n### One liner\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        return bisect_left(range(time[0] * totalTrips), True, key=lambda t: sum(t // bus for bus in time) >= totalTrips)\\n\\n```\\n\\n### Without bisect library\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        check = lambda t: sum(t // bus for bus in time) >= totalTrips\\n\\n        lo, hi = 1, time[0] * totalTrips\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if check(mid):\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        \\n        return lo\\n\\n\\n```\\n\\nBy the way, this is the article that solved binary search for me once and for all: http://coldattic.info/post/95/",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        check = lambda t: sum(t // bus for bus in time) >= totalTrips\\n        return bisect_left(range(time[0] * totalTrips), True, key=check)\\n\\n```\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        return bisect_left(range(time[0] * totalTrips), True, key=lambda t: sum(t // bus for bus in time) >= totalTrips)\\n\\n```\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        check = lambda t: sum(t // bus for bus in time) >= totalTrips\\n\\n        lo, hi = 1, time[0] * totalTrips\\n        while lo < hi:\\n            mid = (lo + hi) // 2\\n            if check(mid):\\n                hi = mid\\n            else:\\n                lo = mid + 1\\n        \\n        return lo\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267035,
                "title": "c-easy-solution-binary-search-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFBinary Search Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n```\\nclass Solution {\\npublic:\\n    long long isSafe(vector<int>&time,long long val){\\n        long long a=0;\\n        for(int i=0;i<time.size();i++){\\n            a+=val/time[i];\\n        }\\n        return a;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        //we will use Binary Search to find optimal ans\\n        //we will initialize the low to 1 and high to 1e14 \\n        //beacause we can have constraints 1e7*1e7\\n        long long low=1,high=1e14;\\n        \\n        //basic synatax of binary search\\n        while(low<high){\\n            //finding mid with tackling the overflow\\n            long long mid=low+(high-low)/2;\\n            \\n            //checking the trips possible with mid time the totalTrips \\n            if(isSafe(time,mid)>=totalTrips){\\n                //if safe the make high= mid\\n                high=mid;\\n            }\\n            else{\\n                //else make low to mid+1 as not found on mid\\n                low=mid+1;\\n            }\\n        }\\n        //return the mid\\n        return low;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/7f423b57-81a2-46ce-9ab2-72ad38f668f7_1675480558.466273.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long isSafe(vector<int>&time,long long val){\\n        long long a=0;\\n        for(int i=0;i<time.size();i++){\\n            a+=val/time[i];\\n        }\\n        return a;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        //we will use Binary Search to find optimal ans\\n        //we will initialize the low to 1 and high to 1e14 \\n        //beacause we can have constraints 1e7*1e7\\n        long long low=1,high=1e14;\\n        \\n        //basic synatax of binary search\\n        while(low<high){\\n            //finding mid with tackling the overflow\\n            long long mid=low+(high-low)/2;\\n            \\n            //checking the trips possible with mid time the totalTrips \\n            if(isSafe(time,mid)>=totalTrips){\\n                //if safe the make high= mid\\n                high=mid;\\n            }\\n            else{\\n                //else make low to mid+1 as not found on mid\\n                low=mid+1;\\n            }\\n        }\\n        //return the mid\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266953,
                "title": "java-beats-98-6-easy-to-understand-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low=1;\\n        long high=Long.MAX_VALUE-100000;\\n        long ans=high;\\n        while(low<=high)\\n        {\\n            long mid=(low+high)/2;\\n            if(valid(time,mid,totalTrips))\\n            {\\n                ans=Math.min(ans,mid);\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return ans;\\n\\n    }\\n    public boolean valid(int[]time,long t,long totalTrips)\\n    {\\n        long temp=0;\\n      for(int x:time)\\n      {\\n          temp+=(t/x);\\n          if(temp>=totalTrips)\\n          return true;\\n      }\\n      return temp>=totalTrips;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low=1;\\n        long high=Long.MAX_VALUE-100000;\\n        long ans=high;\\n        while(low<=high)\\n        {\\n            long mid=(low+high)/2;\\n            if(valid(time,mid,totalTrips))\\n            {\\n                ans=Math.min(ans,mid);\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return ans;\\n\\n    }\\n    public boolean valid(int[]time,long t,long totalTrips)\\n    {\\n        long temp=0;\\n      for(int x:time)\\n      {\\n          temp+=(t/x);\\n          if(temp>=totalTrips)\\n          return true;\\n      }\\n      return temp>=totalTrips;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266895,
                "title": "binary-search-solution-nlog-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long r=*min(time.begin(),time.end())*(long long)totalTrips,l=0,ans=r;\\n        while(l<r)\\n        {\\n            long long cnt=0;\\n            long long mid=(l+r)/2;\\n            for(int i=0;i<time.size();i++)\\n            {\\n                cnt+=(mid/time[i]);\\n            }\\n            if(cnt>=totalTrips)\\n            {\\n                ans=min(ans,mid);\\n                r=mid;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long r=*min(time.begin(),time.end())*(long long)totalTrips,l=0,ans=r;\\n        while(l<r)\\n        {\\n            long long cnt=0;\\n            long long mid=(l+r)/2;\\n            for(int i=0;i<time.size();i++)\\n            {\\n                cnt+=(mid/time[i]);\\n            }\\n            if(cnt>=totalTrips)\\n            {\\n                ans=min(ans,mid);\\n                r=mid;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266735,
                "title": "v-v-v-v-easy-solutions-in-c-do-upvote-it",
                "content": "# Intuition\\nThe problem can be solved using binary search by setting the search space as the range of possible minimum times required for all buses to complete at least totalTrips trips. We can then use a helper function to calculate the total number of trips completed for each bus at any given time, and based on that, determine whether the current minimum time is too high or too low. We can continue updating the search space until we find the minimum time required to complete totalTrips trips.\\n\\n# Approach\\nInitialize the search space as the range of possible minimum times required for all buses to complete at least totalTrips trips. The minimum time required for each bus to complete totalTrips trips is the minimum time taken by any bus multiplied by totalTrips, and the maximum time required is the sum of times taken by all buses multiplied by totalTrips.\\nUse binary search to find the minimum time required to complete totalTrips trips. For each mid-point time value, calculate the total number of trips completed for each bus using a helper function.\\nIf the total number of trips completed is greater than or equal to totalTrips, the current mid-point time is a valid candidate for the minimum time required. Therefore, update the search space to the lower half of the current range.\\nIf the total number of trips completed is less than totalTrips, the current mid-point time is too high, and we need to increase the minimum time required. Therefore, update the search space to the upper half of the current range.\\nContinue updating the search space until the minimum time required to complete totalTrips trips is found.\\n\\n# Complexity\\n- Time complexity:\\nTime complexity: The time complexity of the binary search algorithm used in the solution is O(logn)O(log n)O(logn), where n is the range of possible minimum times required for all buses to complete at least totalTrips trips. For each mid-point time value, the helper function calculates the total number of trips completed by all buses, which takes O(n)O(n)O(n) time. Therefore, the overall time complexity of the solution is O(nlogn)O(n log n)O(nlogn), where n is the length of the input array time.\\n\\n- Space complexity:\\nSpace complexity: The space complexity of the solution is O(1)O(1)O(1), as we are only using constant space to store the input array and a few variables.\\n\\n# Code\\n```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        ll start = 1;\\n        ll end = 1e14;\\n        while(start <= end){\\n            ll trip = 0;\\n            ll mid = start + (end - start)/2;\\n            for(int i=0;i<time.size();i++)\\n                trip += mid / time[i];\\n            if(trip < totalTrips){\\n                start = mid + 1;\\n            }\\n            else \\n                end = mid - 1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        ll start = 1;\\n        ll end = 1e14;\\n        while(start <= end){\\n            ll trip = 0;\\n            ll mid = start + (end - start)/2;\\n            for(int i=0;i<time.size();i++)\\n                trip += mid / time[i];\\n            if(trip < totalTrips){\\n                start = mid + 1;\\n            }\\n            else \\n                end = mid - 1;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218376,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int x) {\\n        long long int mx = LONG_LONG_MAX/time.size(), mn = 1,mid,ans,k;\\n        // for(auto &i: time){\\n        //     mx += i;\\n        //     mn = min(mn,(long long int)i);\\n        // }\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            k = 0;\\n            for(auto &i: time){\\n                k += (mid/i);\\n            }\\n            if(k>=x){\\n                ans = mid;\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int x) {\\n        long long int mx = LONG_LONG_MAX/time.size(), mn = 1,mid,ans,k;\\n        // for(auto &i: time){\\n        //     mx += i;\\n        //     mn = min(mn,(long long int)i);\\n        // }\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            k = 0;\\n            for(auto &i: time){\\n                k += (mid/i);\\n            }\\n            if(k>=x){\\n                ans = mid;\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218359,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int x) {\\n        long long int mx = LONG_LONG_MAX/time.size(), mn = 1,mid,ans,k;\\n        // for(auto &i: time){\\n        //     mx += i;\\n        //     mn = min(mn,(long long int)i);\\n        // }\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            k = 0;\\n            for(auto &i: time){\\n                k += (mid/i);\\n            }\\n            if(k>=x){\\n                ans = mid;\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int x) {\\n        long long int mx = LONG_LONG_MAX/time.size(), mn = 1,mid,ans,k;\\n        // for(auto &i: time){\\n        //     mx += i;\\n        //     mn = min(mn,(long long int)i);\\n        // }\\n        while(mn<=mx){\\n            mid = (mx-mn)/2+mn;\\n            k = 0;\\n            for(auto &i: time){\\n                k += (mid/i);\\n            }\\n            if(k>=x){\\n                ans = mid;\\n                mx = mid-1;\\n            }else{\\n                mn = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877745,
                "title": "easy-understand-80-faster-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n    long long l = 0, r = LONG_MAX/time.size(),m,trips;\\n    while (l < r) {\\n        m = ((r-l)>>1)+l, trips = 0;\\n        for (int t : time)\\n            trips += m / t;\\n        if (trips < totalTrips)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l;\\n}\\n};```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n    long long l = 0, r = LONG_MAX/time.size(),m,trips;\\n    while (l < r) {\\n        m = ((r-l)>>1)+l, trips = 0;\\n        for (int t : time)\\n            trips += m / t;\\n        if (trips < totalTrips)\\n            l = m + 1;\\n        else\\n            r = m;\\n    }\\n    return l;\\n}\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2552192,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Binary Search***\\n\\n* ***Time Complexity :- O(Nlog(high - low))***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool is_possible(vector<int>& time, long long mid, int totalTrips)\\n    {\\n        int n = time.size();\\n        \\n        // find total_trips possible\\n        \\n        long long trips = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            trips += (mid / time[i]);\\n        }\\n        \\n        return trips >= totalTrips;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        \\n        int n = time.size();\\n        \\n        // apply binary search\\n        \\n        // and check for every mid is it possible to make atleast totalTrips\\n        \\n        // if possible then store in ans and move high to mid - 1\\n        \\n        // otherwise move low to mid + 1\\n        \\n        long long low = 1;\\n        \\n        long long high = 1e14;\\n        \\n        long long ans = 1;\\n        \\n        while(low <= high)\\n        {\\n            long long mid = low + (high - low) / 2;\\n            \\n            if(is_possible(time, mid, totalTrips))\\n            {\\n                ans = mid;\\n                \\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool is_possible(vector<int>& time, long long mid, int totalTrips)\\n    {\\n        int n = time.size();\\n        \\n        // find total_trips possible\\n        \\n        long long trips = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            trips += (mid / time[i]);\\n        }\\n        \\n        return trips >= totalTrips;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        \\n        int n = time.size();\\n        \\n        // apply binary search\\n        \\n        // and check for every mid is it possible to make atleast totalTrips\\n        \\n        // if possible then store in ans and move high to mid - 1\\n        \\n        // otherwise move low to mid + 1\\n        \\n        long long low = 1;\\n        \\n        long long high = 1e14;\\n        \\n        long long ans = 1;\\n        \\n        while(low <= high)\\n        {\\n            long long mid = low + (high - low) / 2;\\n            \\n            if(is_possible(time, mid, totalTrips))\\n            {\\n                ans = mid;\\n                \\n                high = mid - 1;\\n            }\\n            else\\n            {\\n                low = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507143,
                "title": "java-faster-97-82-binary-search",
                "content": "```\\nclass Solution {\\n    // binary search!\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long result = 0;\\n        // low starts from 1 since min of both time[i] and totalTrips is 1.\\n        long low = 1;\\n        // high ends with 10^14 since the Max value for time[i] and totalTrips are 10^7.\\n        // so the worst case is when a bus takes 10^7 seconds for a trip, and need to finish 10^7 trips.\\n        // Thus, it\\'s 10^7 * 10^7 = 10^14\\n        long high = 100000000000000L;\\n        \\n        // if low = high it means that there is only one number in our range, so found\\n        while (low <= high) {\\n            long mid = low + (high - low) / 2;\\n            boolean pass = isValid(time, mid, totalTrips);\\n            \\n            if (pass) {\\n                // can finish, so store for possible better solution    \\n                result = mid;\\n                high = mid - 1;\\n            } else {\\n                // no enough time, so go up for a valid solution\\n                low = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public boolean isValid(int[] time, long mid, int totalTrips){\\n        long finish = 0;\\n        for (int each : time) {\\n            finish += mid / each;\\n            if (finish >= totalTrips) { return true; }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // binary search!\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long result = 0;\\n        // low starts from 1 since min of both time[i] and totalTrips is 1.\\n        long low = 1;\\n        // high ends with 10^14 since the Max value for time[i] and totalTrips are 10^7.\\n        // so the worst case is when a bus takes 10^7 seconds for a trip, and need to finish 10^7 trips.\\n        // Thus, it\\'s 10^7 * 10^7 = 10^14\\n        long high = 100000000000000L;\\n        \\n        // if low = high it means that there is only one number in our range, so found\\n        while (low <= high) {\\n            long mid = low + (high - low) / 2;\\n            boolean pass = isValid(time, mid, totalTrips);\\n            \\n            if (pass) {\\n                // can finish, so store for possible better solution    \\n                result = mid;\\n                high = mid - 1;\\n            } else {\\n                // no enough time, so go up for a valid solution\\n                low = mid + 1;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public boolean isValid(int[] time, long mid, int totalTrips){\\n        long finish = 0;\\n        for (int each : time) {\\n            finish += mid / each;\\n            if (finish >= totalTrips) { return true; }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1834177,
                "title": "98-faster-92-space-binary-search",
                "content": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long l = 1;\\n        long r = Long.MAX_VALUE-100000;\\n        long ans = r;\\n        while(l<=r){\\n            long mid = (l+r)/2;\\n            boolean result = possible(time , mid , totalTrips);\\n            if(result){\\n                ans = Math.min(ans , mid);\\n                r = mid-1;\\n            }\\n            else\\n                l = mid+1;\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean possible(int a[] , long time , long total){\\n        long now = 0;\\n        for(int i : a){\\n            now += (time/i);\\n            if(now >= total)\\n                return true;\\n        }\\n        return now >= total;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long l = 1;\\n        long r = Long.MAX_VALUE-100000;\\n        long ans = r;\\n        while(l<=r){\\n            long mid = (l+r)/2;\\n            boolean result = possible(time , mid , totalTrips);\\n            if(result){\\n                ans = Math.min(ans , mid);\\n                r = mid-1;\\n            }\\n            else\\n                l = mid+1;\\n        }\\n        return ans;\\n    }\\n    \\n    public boolean possible(int a[] , long time , long total){\\n        long now = 0;\\n        for(int i : a){\\n            now += (time/i);\\n            if(now >= total)\\n                return true;\\n        }\\n        return now >= total;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817102,
                "title": "c-binary-search",
                "content": "```\\n\\tpublic long MinimumTime(int[] time, int totalTrips) {\\n        long left = 1;\\n        long right = long.MaxValue;\\n        while (left < right) {\\n            var middle = left + (right-left)/2;\\n            if (TripsCount(time, middle, totalTrips) < totalTrips)\\n                left = middle+1;\\n            else\\n                right = middle;\\n        }\\n        return left;\\n    }\\n    \\n    long TripsCount(int[] busTime, long totalTime, long target) {\\n        long sum = 0;\\n        var i = 0;\\n        while (i < busTime.Length && sum <= target) {\\n            sum += totalTime/busTime[i++];\\n        }   \\n        return sum;\\n    }\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\n\\tpublic long MinimumTime(int[] time, int totalTrips) {\\n        long left = 1;\\n        long right = long.MaxValue;\\n        while (left < right) {\\n            var middle = left + (right-left)/2;\\n            if (TripsCount(time, middle, totalTrips) < totalTrips)\\n                left = middle+1;\\n            else\\n                right = middle;\\n        }\\n        return left;\\n    }\\n    \\n    long TripsCount(int[] busTime, long totalTime, long target) {\\n        long sum = 0;\\n        var i = 0;\\n        while (i < busTime.Length && sum <= target) {\\n            sum += totalTime/busTime[i++];\\n        }   \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1805032,
                "title": "binary-search-c-nlog-n-commented",
                "content": "**class Solution {\\npublic:\\n    \\n    //func to calculate trips covered in given time frame \\n    long long tripsTaken(vector<int>& time, long long mid){\\n        \\n        long long cnt=0;\\n        for(auto it: time)\\n        {\\n            cnt+= mid/it;\\n        }\\n        return cnt;\\n    }\\n    \\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        \\n        long long low=0, high=1e14;\\n        //here maximum high time= time*totaltrips= 1e7*1e7(look the constraints)\\n        long long res= high;\\n        \\n        while(low<=high)\\n        {\\n            //because right shift (>>) operator works faster than \\'/\\'\\n            //both will work fine\\n            long long mid= (low+high) >> 1;\\n            //long long mid= (low+high) / 2;\\n            \\n            if(tripsTaken(time, mid) >= totalTrips)\\n            {\\n                res=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low= mid+1;  \\n            } \\n        }\\n        return res;\\n    }\\n};**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    //func to calculate trips covered in given time frame \\n    long long tripsTaken(vector<int>& time, long long mid){\\n        \\n        long long cnt=0;\\n        for(auto it: time)\\n        {\\n            cnt+= mid/it;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1803475,
                "title": "c-binary-search-approach",
                "content": "```\\nclass Solution {\\n    using lli = unsigned long long;\\npublic:\\n    bool check(vector<int>& time,lli mid ,int totalTrips){\\n        lli cnt = 0;\\n        for(int i=0;i<time.size();i++){\\n            cnt += (mid/(1ll * time[i]));\\n        }\\n        return cnt >= 1ll * totalTrips;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        lli lo = 0, hi = 1e18 , ans = 0;\\n        while(lo <= hi){\\n            lli mid = lo + (hi -lo)/2;\\n            if(check(time,mid,totalTrips)){\\n                ans = mid;\\n                hi = mid - 1;\\n            }else{\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nanother good article explaining binary search : https://leetcode.com/problems/max-consecutive-ones-iii/discuss/1796568/java-binary-search-sliding-window-approach-explained",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    using lli = unsigned long long;\\npublic:\\n    bool check(vector<int>& time,lli mid ,int totalTrips){\\n        lli cnt = 0;\\n        for(int i=0;i<time.size();i++){\\n            cnt += (mid/(1ll * time[i]));\\n        }\\n        return cnt >= 1ll * totalTrips;\\n    }\\n    \\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        lli lo = 0, hi = 1e18 , ans = 0;\\n        while(lo <= hi){\\n            lli mid = lo + (hi -lo)/2;\\n            if(check(time,mid,totalTrips)){\\n                ans = mid;\\n                hi = mid - 1;\\n            }else{\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803155,
                "title": "c-binary-search-o-nlogm-why-binary-search",
                "content": "This is a good question . Lots of people are discussing on how to use binary search in this question. I want to share ***why are we using binary search ??***\\n\\nThe question says that we are provided with an array containing time taken by each bus to complete one trip. If any/all buses are allowed to travel simultaneously , then we have to return the **minimum time** in which all the buses can complete ***total_trips*** all together. \\nWhich means we have to find the minimum time such that , \\n\\t\\t*****(minimum_time/ time[0] ) + (minimum_time/ time[1] ) + ..... (minimum_time / time[n-1] ) >=totaltrips*****   \\n\\t\\tWe have to make sure that **minimum_time** is as small as possible. \\n\\nHow do we solve this question ?? \\n \\nWell , the first thing that comes to my mind is , that : \\n1. Keep a time variable , start it from 1 (time=1) .\\n2. Check if we can make total_trips within ***time*** or not. \\n3. If **yes, then this is our answer** , as we started from the lower end , and we have  recieved our first possible value ( which will be minimum of all further possible values ). \\n4. If , **no** , then **increment the time variable** and follow from STEP 2. \\n\\nThis is not a good approach as , if our answer is close to the upper end , then this approach will take a hell lot of time. \\n\\n***So , how do we move ahead ??***\\nThere is another way . We can move from the other end , ie , the right end and the last value that we encounter which will satisfy our condition , will be our answer. \\n\\n***If we observe the 2 approaches we can come to the following conclusions :***\\n1. The time variable has a range of values for which the condition will be satisfied. \\n2. If  for a particular value of time , the condition is satisfied , it will be satisfied for all values > time. \\n3. If for a particular value of time , the condition is not satisfied , it will not be satisfied for all values < time.\\n4. Time variable will have a sorted set of values. ( 1,2,3,4,5.....) \\n\\n***Using the above observations we can think that we can use BINARY SEARCH based on the DIVIDE AND CONQUER ALGORITHM***. \\n* We will check set the lower and upper bounds of the range. \\n* We will check if the mid_value satisfies the condition ,if it does , then we will update our answer and reduce our upper_bound to mid_value -1. ( WITH THE INTENTION TO SEARCH FOR EVEN SMALLER POSSIBLE ANSWER ) .\\n* If mid_value doesn\\'t satisfy the condition , we will increase our lower_bound to mid_value +1 ( AS ANY VALUE LOWER THAN THE CURRENT MID WON\\'T BE ANSWER ).\\n\\n### CODE : \\n```\\nclass Solution {\\npublic:\\n    bool tripsPossible(vector<int> &time , int totalTrips, long long int minTime)\\n    {\\n        long long int trips=0;\\n        for(int i:time)\\n        {   \\n            trips+=(minTime/i);\\n            if(trips>=totalTrips)\\n                return true;\\n        }\\n         return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        \\n        long long ans=-1,low=1,high,mid;\\n        high=(long long)totalTrips*(*min_element(time.begin(),time.end()));\\n        \\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(tripsPossible(time,totalTrips,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n                       \\n    }\\n};\\n```\\n\\n***If you found this post helpful , do upvote and comment below.***\\n\\n\\n\\n\\n \\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool tripsPossible(vector<int> &time , int totalTrips, long long int minTime)\\n    {\\n        long long int trips=0;\\n        for(int i:time)\\n        {   \\n            trips+=(minTime/i);\\n            if(trips>=totalTrips)\\n                return true;\\n        }\\n         return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        \\n        long long ans=-1,low=1,high,mid;\\n        high=(long long)totalTrips*(*min_element(time.begin(),time.end()));\\n        \\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(tripsPossible(time,totalTrips,mid))\\n            {\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        return ans;\\n                       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803087,
                "title": "clearly-explained-python3-faster-than-100-numpy-binary-search",
                "content": "![image](https://assets.leetcode.com/users/images/4abdaa11-50d2-403f-80b6-3c048fc7969a_1645939023.0960097.png)\\n\\nI will divide this post into two sections. First, I will show my accepted code, then, I will explain my thought process. \\n\\n__Code__\\n\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        \\n        from collections import Counter\\n        import numpy as np\\n        \\n        dic = Counter(time)\\n        k_arr, v_arr = np.array(list(dic.keys())), np.array(list(dic.values()))\\n        \\n\\t\\t# deal with edge cases, eg. time = [1, 1, 1, 1, 1], totalTrip = 5\\n        if np.size(k_arr) == 1 and k_arr[0] == 1: \\n            if totalTrips % v_arr[0] == 0: return totalTrips // v_arr[0]\\n            else: return totalTrips // v_arr[0] + 1\\n        \\n\\t\\t# binary search\\n        l, r = min(k_arr), min(k_arr) * totalTrips\\n        idx = (l + r) // 2   # mid\\n        \\n        while l + 1 < r:\\n            temp = np.sum((idx * np.ones_like(k_arr) // k_arr) * v_arr)\\n            if temp >= totalTrips:\\n                r = idx\\n                idx = (r + l) // 2\\n            else:\\n                l = idx\\n                idx = (r + l) // 2\\n            \\n        return r\\n\\t\\t\\n```\\n\\n\\n__Thought Process__\\n\\nTake the first test case, **time = [1, 2, 3], totalTrip = 5** as an example:\\nMy initial idea was, we can loop from t = 1, and increment t by 1 at each step, until we find a time that will produce a result >= totalTrip. \\n\\nt = 1, reminder of t over time is [0, 1, 1], total trips we can complete *by adding 1 to t* is sum(time[0, 1, 1]) = 1\\nt = 2, reminder of t over time is [0, 0, 1], total trips we can complete *by adding 1 to t* is sum(time[0, 0, 1]) = 2 \\nt = 3, reminder of t over time is [0, 1, 0], total trips we can complete *by adding 1 to t* is sum(time[0, 1, 0]) = 2\\n\\nI found that while looping, we don\\'t need to find how many trips a specific truck can complete. Instead, since we are incrementing t by 1, we just need to find how many trucks completed a new trip at time t + 1. Namely, we just need to find the reminder of t over time[i]. If the reminder == 0, our current total trip increment by 1. \\n\\nAnd since we are doing vector/array operations in python, numpy, in most cases, is our best friend. \\n\\n**CODE BELOW WILL LEAD TO TLE**\\n\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        \\n        from collections import Counter\\n        import numpy as np\\n        \\n        dic = Counter(time)\\n        \\n        k_arr, v_arr = np.array(list(dic.keys())), np.array(list(dic.values()))\\n        \\n        idx, res = 1, 0\\n        \\n        while 1:\\n            temp = idx * np.ones_like(k_arr)\\n            left = np.remainder(temp, k_arr)\\n            res += sum(v_arr[left == 0])\\n            if res >= totalTrips: return idx\\n            idx += 1\\n```\\n\\nApparently, this will lead to TLE. So instead of iterating from 1 to infinity, I decided to do binary search to find the tight bound. While if we want to do binary search, the incrementing by 1 and finding the reminder trick will never work. Hence, I have to choose the regular track: true divide my current t vector over the time vector, and get the sum of (result of true division * number of each type of truck).\\n\\nIn my code:\\n\\n```\\ntemp = np.sum((idx * np.ones_like(k_arr) // k_arr) * v_arr)\\n```\\n\\nIn details:\\n\\n```\\n# idx -> mid of binary search\\ncurr_time = idx * np.ones_like(k_arr)\\ncurr_weight = curr_time // k_arr\\ncurr_sum = np.sum(curr_weight * v_arr)\\n```\\n\\n__Open Discussion__\\n\\nPlease help!\\n\\nI added the first chunk of ugly code:\\n\\n```\\n# deal with edge cases, eg. time = [1, 1, 1, 1, 1], totalTrip = 5\\nif np.size(k_arr) == 1 and k_arr[0] == 1: \\n\\tif totalTrips % v_arr[0] == 0: return totalTrips // v_arr[0]\\n\\telse: return totalTrips // v_arr[0] + 1\\n```\\n\\nonly to pass the test case **time = [1, 1, 1, 1, 1], totalTrip = 5**.\\n\\nIf you have any better ideas for dealing with edge cases based on this approach, please let me know in the comment section. Thank you!\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        \\n        from collections import Counter\\n        import numpy as np\\n        \\n        dic = Counter(time)\\n        k_arr, v_arr = np.array(list(dic.keys())), np.array(list(dic.values()))\\n        \\n\\t\\t# deal with edge cases, eg. time = [1, 1, 1, 1, 1], totalTrip = 5\\n        if np.size(k_arr) == 1 and k_arr[0] == 1: \\n            if totalTrips % v_arr[0] == 0: return totalTrips // v_arr[0]\\n            else: return totalTrips // v_arr[0] + 1\\n        \\n\\t\\t# binary search\\n        l, r = min(k_arr), min(k_arr) * totalTrips\\n        idx = (l + r) // 2   # mid\\n        \\n        while l + 1 < r:\\n            temp = np.sum((idx * np.ones_like(k_arr) // k_arr) * v_arr)\\n            if temp >= totalTrips:\\n                r = idx\\n                idx = (r + l) // 2\\n            else:\\n                l = idx\\n                idx = (r + l) // 2\\n            \\n        return r\\n\\t\\t\\n```\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        \\n        from collections import Counter\\n        import numpy as np\\n        \\n        dic = Counter(time)\\n        \\n        k_arr, v_arr = np.array(list(dic.keys())), np.array(list(dic.values()))\\n        \\n        idx, res = 1, 0\\n        \\n        while 1:\\n            temp = idx * np.ones_like(k_arr)\\n            left = np.remainder(temp, k_arr)\\n            res += sum(v_arr[left == 0])\\n            if res >= totalTrips: return idx\\n            idx += 1\\n```\n```\\ntemp = np.sum((idx * np.ones_like(k_arr) // k_arr) * v_arr)\\n```\n```\\n# idx -> mid of binary search\\ncurr_time = idx * np.ones_like(k_arr)\\ncurr_weight = curr_time // k_arr\\ncurr_sum = np.sum(curr_weight * v_arr)\\n```\n```\\n# deal with edge cases, eg. time = [1, 1, 1, 1, 1], totalTrip = 5\\nif np.size(k_arr) == 1 and k_arr[0] == 1: \\n\\tif totalTrips % v_arr[0] == 0: return totalTrips // v_arr[0]\\n\\telse: return totalTrips // v_arr[0] + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802985,
                "title": "c-binary-search",
                "content": "**Minimum Time to Complete Trips**\\n\\nUse binary search here, as total trip and time[i] can go upto 10^7 so, trip time can vary in between 1 and 10^14. Here I took start=1 and end=10^17 and go for binary search, each time assume the trip time to be mid and calculate the number of trips we can have, if it greater than totaltrips than this mid can be asnwer and will go in left part for smaller value else go in right part.\\n\\n```\\n #define ll long long \\n    long long minimumTime(vector<int>& time, int to) {\\n        \\n        ll s=1,e=1e17,ans=0;\\n        while(s<=e)\\n        {\\n            ll mid=(s+e)/2;\\n            ll cnt=0;\\n            \\n            for(auto t:time)\\n            {\\n                cnt+=(mid/t);\\n                if(cnt>=to)\\n                    break;\\n            }\\n            \\n            if(cnt>=to)\\n            {\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else\\n                s=mid+1;\\n        }\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n #define ll long long \\n    long long minimumTime(vector<int>& time, int to) {\\n        \\n        ll s=1,e=1e17,ans=0;\\n        while(s<=e)\\n        {\\n            ll mid=(s+e)/2;\\n            ll cnt=0;\\n            \\n            for(auto t:time)\\n            {\\n                cnt+=(mid/t);\\n                if(cnt>=to)\\n                    break;\\n            }\\n            \\n            if(cnt>=to)\\n            {\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else\\n                s=mid+1;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802957,
                "title": "python3-100-faster-binary-search",
                "content": "![image](https://assets.leetcode.com/users/images/4081b7f5-14ba-4541-8cec-183c1c90514d_1645938325.1900375.png)\\n\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        l, h = 0, min(time) * totalTrips\\n        while l < h:\\n            mid = (l + h) // 2\\n            if sum([mid // i for i in time]) < totalTrips: l = mid + 1\\n            else: h = mid\\n        return l\\n```\\n\\n**Please upvote if you find it helpful and interesting!!!\\nThank you.**",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        l, h = 0, min(time) * totalTrips\\n        while l < h:\\n            mid = (l + h) // 2\\n            if sum([mid // i for i in time]) < totalTrips: l = mid + 1\\n            else: h = mid\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802886,
                "title": "c-binary-search-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int to) {\\n        long long l=0,h=LLONG_MAX,ans;\\n        while(l<=h)\\n        {\\n            long long mid=h-(h-l)/2;\\n            long long cnt=0;\\n            for(int i=0;i<time.size();i++)\\n            {\\n                cnt+=1ll*mid/time[i];\\n                if(cnt>INT_MAX)\\n                    break;\\n            }\\n            //cout<<mid<<\" \"<<cnt<<endl;\\n            if(cnt>=to)\\n            {\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else\\n            {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int to) {\\n        long long l=0,h=LLONG_MAX,ans;\\n        while(l<=h)\\n        {\\n            long long mid=h-(h-l)/2;\\n            long long cnt=0;\\n            for(int i=0;i<time.size();i++)\\n            {\\n                cnt+=1ll*mid/time[i];\\n                if(cnt>INT_MAX)\\n                    break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1802848,
                "title": "c-easy-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l = 1, r = 1e16, ans = -1;\\n        int n = time.size();\\n        auto ok = [&](long long x) {\\n            long long tot = 0;\\n           for (int i = 0; i < n; ++i) {\\n               tot += x / time[i];\\n               if (tot >= totalTrips) return true;\\n           } \\n            return tot >= totalTrips;\\n        };  \\n        while (l <= r) {\\n            long long mid = (l + r) >> 1;\\n            if (ok(mid)) {\\n                ans = mid;\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l = 1, r = 1e16, ans = -1;\\n        int n = time.size();\\n        auto ok = [&](long long x) {\\n            long long tot = 0;\\n           for (int i = 0; i < n; ++i) {\\n               tot += x / time[i];\\n               if (tot >= totalTrips) return true;\\n           } \\n            return tot >= totalTrips;\\n        };  \\n        while (l <= r) {\\n            long long mid = (l + r) >> 1;\\n            if (ok(mid)) {\\n                ans = mid;\\n                r = mid - 1;\\n            } else {\\n                l = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802822,
                "title": "cpp-solution-binary-search",
                "content": "**APPROACH**\\n* Just a binary search question,as the constraints are high.\\n* Find the possible predicate function.\\n* Varieties of such question are there on leetcode.\\n\\n```\\nlong long minimumTime(vector<int>& time, int t) {\\n        sort(begin(time),end(time));\\n        long long l=1,h=1e18;\\n        while(l<=h){\\n            long long mid=l+(h-l)/2;\\n            (bin_search(mid,time,t))?h=mid-1:l=mid+1;\\n        }\\n        return l;\\n    }\\n    bool bin_search(long long mid,vector<int> &time,int &t){\\n        long long trip=0;\\n        for(auto i:time){\\n            trip+=(mid/i);\\n            if(trip>=t) return 1;\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nlong long minimumTime(vector<int>& time, int t) {\\n        sort(begin(time),end(time));\\n        long long l=1,h=1e18;\\n        while(l<=h){\\n            long long mid=l+(h-l)/2;\\n            (bin_search(mid,time,t))?h=mid-1:l=mid+1;\\n        }\\n        return l;\\n    }\\n    bool bin_search(long long mid,vector<int> &time,int &t){\\n        long long trip=0;\\n        for(auto i:time){\\n            trip+=(mid/i);\\n            if(trip>=t) return 1;\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802767,
                "title": "c-binary-search",
                "content": "```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n        unsigned long long sum = 0;\\n        long long beg = 1, end = LLONG_MAX, mid;\\n        \\n        while(beg < end) {\\n            mid = beg + (end - beg) / 2;\\n            sum = 0;\\n            for(int idx = 0; idx < time.size(); idx++) {\\n                sum += mid / time[idx];\\n                if(sum >= totalTrips) {\\n                    end = mid;\\n                    break;\\n                }\\n            }\\n            \\n            if(sum >= totalTrips) {\\n                end = mid;\\n            } else {\\n                beg = mid + 1;\\n            }\\n        }\\n        \\n        return beg;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n        unsigned long long sum = 0;\\n        long long beg = 1, end = LLONG_MAX, mid;\\n        \\n        while(beg < end) {\\n            mid = beg + (end - beg) / 2;\\n            sum = 0;\\n            for(int idx = 0; idx < time.size(); idx++) {\\n                sum += mid / time[idx];\\n                if(sum >= totalTrips) {\\n                    end = mid;\\n                    break;\\n                }\\n            }\\n            \\n            if(sum >= totalTrips) {\\n                end = mid;\\n            } else {\\n                beg = mid + 1;\\n            }\\n        }\\n        \\n        return beg;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1802709,
                "title": "c-binary-search-predicate-function-algorithm-sortings",
                "content": "Algorithm ->\\n1) first we will have to think of what is the minimum and maximum time we reuired to\\n    make trips!\\n2) than we take the mid value and check that using this time (mid value) we can make totalTrip or not\\n3) if we can make totalTrip than it is sure that with all the values greater than this, we can also make toatlTrip so we will check for smaller values keeping this(mid) as our candidate answer and try to find more optimal value than this(mid)!\\n4) similarly if we cant make totalTrip with mid value than it is sure that with all values smaller than mid, we cant make toatlTrip so we will increase the mid value\\n5) and at the end we will return the answer\\n\\n```\\nclass Solution {\\npublic:\\n   // predicate function which will check if we can make totalTrips in time = mid\\n    bool isPossible(long long mid, vector<int>& time, int totalTrips){\\n             long long trips = 0;\\n             for(int ti : time){\\n                  trips = trips + (long long) mid / ti;\\n                  if(trips >= totalTrips) return true;\\n             }\\n          return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n                int n = time.size();\\n                if( n == 1){\\n                    long long ans =(long long) time[0] * totalTrips;\\n                    return ans;\\n                }\\n                sort(time.begin(), time.end());\\n                long long lo = 1;  // lowest value for our convineance\\n                long long hi = 1e13; // highest value for our convineance\\n                 long long ans; \\n\\t\\t\\t\\t // typical binary search algorithm\\n                while(lo <= hi){\\n                    long long mid = lo + (hi - lo) / 2;\\n                    if(isPossible(mid,time,totalTrips)){   // if we can make trip than we look for smaller value\\n                        ans = mid;\\n                        hi = mid - 1;\\n                    }\\n                    else lo = mid + 1;  // if we can not make trip than we look for higher value\\n                }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n   // predicate function which will check if we can make totalTrips in time = mid\\n    bool isPossible(long long mid, vector<int>& time, int totalTrips){\\n             long long trips = 0;\\n             for(int ti : time){\\n                  trips = trips + (long long) mid / ti;\\n                  if(trips >= totalTrips) return true;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1802703,
                "title": "java-solution-binary-search",
                "content": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n\\t// sort the array for binary-search\\n        Arrays.sort(time);\\n\\t\\t// convert to long type\\n        long newTotalTrips = totalTrips;\\n        long l = 0L, r = newTotalTrips*time[0];\\n        while(l < r){\\n            long mid = l + (r-l)/2;\\n            if(check(mid, time) >= totalTrips){\\n                r = mid;\\n            }\\n            else{\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n    // To get the number of trips based on the time\\n    private static long check(long minTime, int[] time){\\n        long tripNum = 0;\\n        for(int t : time)\\n            tripNum += minTime/t;\\n        return tripNum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n\\t// sort the array for binary-search\\n        Arrays.sort(time);\\n\\t\\t// convert to long type\\n        long newTotalTrips = totalTrips;\\n        long l = 0L, r = newTotalTrips*time[0];\\n        while(l < r){\\n            long mid = l + (r-l)/2;\\n            if(check(mid, time) >= totalTrips){\\n                r = mid;\\n            }\\n            else{\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n    // To get the number of trips based on the time\\n    private static long check(long minTime, int[] time){\\n        long tripNum = 0;\\n        for(int t : time)\\n            tripNum += minTime/t;\\n        return tripNum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802687,
                "title": "binary-search-detailed-explanation-from-brute-force-to-optimized-solution",
                "content": "***Please upvote or comment if you find this explanation helpful :)***\\n\\nThe problem is looking for the minimum seconds taken to achive the `totalTrips`. Therefore, to calculate number of trips that can be completed each second, the formula will be:\\n\\n**Number of Trips = sum(second // time[i])**\\n\\nFor example: \\n```\\ntime = [1,2,3], totalTrips = 5\\nAt time t = 2, the number of trips completed is (2 + 1 + 0) = 3\\n```\\n\\nTherefore, we can simply start with a **brute force solution**: loop from `t = 1` until trips completed in time `t` is greater or equal to `totalTrips`.\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        n = len(time)\\n        t = 0\\n        while True:\\n            trip = 0\\n\\t\\t\\t# compute the trips completed in time t\\n            for i in range(n):\\n                trip += (t // time[i])\\n\\t\\t\\t# if the trips completed is greater to or equal to total trips needed\\n\\t\\t\\t# mission completed\\n            if trip >= totalTrips:\\n                return t\\n\\t\\t\\t# else, we have to add 1 to t and continue looping\\n            t += 1\\n```\\nUnfortunately, the time complexity is O(tN), where n is the length of the array and t is the time needed to complete the trip. This solution ends up with TLE, which is not acceptable. However, it is always nice to start with a brute-force soluton since it at least means that you understand the problem.\\n\\nBefore starting with the optimized solution, we can start with a easier quesiton: \\n\\n**What is the maximum time needed to satisfy the problem?**\\n\\nIt would definitly be finding out the single bus that cost the most time to complete a single trip. With the same example:\\n\\n```\\ntime = [1,2,3], totalTrips = 5\\nmaximum time needed = max(time) * totalTrips\\n=> 3 * 5 = 15 (having only the third bus running)\\n```\\n\\nTherefore, back to the brute-force solution:\\nWe are simply looping through` t = 1` unitl `t = max(time) * totalTrips`.\\nTo **find a solution in a sorted array [1, max(time) * totalTrips], it\\'s nothing but Binary Search**!\\n\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], total: int) -> int:\\n        # Finding the maximum time in the array\\n\\t\\t# in order to define the upper bound of the time needed\\n        maxtime = max(time)\\n        return self.binarySearch(time, len(time), total, maxtime * total)\\n    \\n    def findTrip(self, arr, n, second):\\n        trips = 0\\n        for i in range(n):\\n            trips += second // arr[i]\\n        return trips\\n    \\n    def binarySearch(self, arr, n, total, high):\\n        low = 1\\n        while low < high:\\n            mid = (low + high) >> 1\\n            trips = self.findTrip(arr, n, mid)\\n            if trips < total: low = mid + 1\\n            else: high = mid\\n        return high\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\ntime = [1,2,3], totalTrips = 5\\nAt time t = 2, the number of trips completed is (2 + 1 + 0) = 3\\n```\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        n = len(time)\\n        t = 0\\n        while True:\\n            trip = 0\\n\\t\\t\\t# compute the trips completed in time t\\n            for i in range(n):\\n                trip += (t // time[i])\\n\\t\\t\\t# if the trips completed is greater to or equal to total trips needed\\n\\t\\t\\t# mission completed\\n            if trip >= totalTrips:\\n                return t\\n\\t\\t\\t# else, we have to add 1 to t and continue looping\\n            t += 1\\n```\n```\\ntime = [1,2,3], totalTrips = 5\\nmaximum time needed = max(time) * totalTrips\\n=> 3 * 5 = 15 (having only the third bus running)\\n```\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], total: int) -> int:\\n        # Finding the maximum time in the array\\n\\t\\t# in order to define the upper bound of the time needed\\n        maxtime = max(time)\\n        return self.binarySearch(time, len(time), total, maxtime * total)\\n    \\n    def findTrip(self, arr, n, second):\\n        trips = 0\\n        for i in range(n):\\n            trips += second // arr[i]\\n        return trips\\n    \\n    def binarySearch(self, arr, n, total, high):\\n        low = 1\\n        while low < high:\\n            mid = (low + high) >> 1\\n            trips = self.findTrip(arr, n, mid)\\n            if trips < total: low = mid + 1\\n            else: high = mid\\n        return high\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802684,
                "title": "easy-binary-search-cpp-solution",
                "content": "\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long ans=0;\\n        // if(time.size()==1)\\n        // {\\n        //     return time[0]*totalTrips;\\n        // }\\n        sort(time.begin(),time.end());\\n        long long sum=0;\\n        for(auto i:time) sum+=i;\\n        long long low=1; long long high = 1e14;\\n        vector<long long> res;\\n        while(low<high)\\n        {\\n            long long mid= low + (high-low)/2;;\\n            long long check=0;\\n            // cout<<mid<<\"a\"<<endl;\\n            for(auto i:time)\\n            {\\n                long long temp= mid/i;\\n                check+=temp;\\n            }\\n           // cout<<check<<\"b\"<<endl;\\n             if(check >= totalTrips)\\n            {\\n                res.push_back(mid);\\n                high = mid;\\n            }\\n            else\\n            {\\n                low= mid+1;\\n            }\\n        }\\n       \\n        return low;\\n    }\\n};\\n///",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long ans=0;\\n        // if(time.size()==1)\\n        // {\\n        //     return time[0]*totalTrips;\\n        // }",
                "codeTag": "Java"
            },
            {
                "id": 1802679,
                "title": "binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n    long long minimumTime(vector<int>& time, int t) {\\n        \\n        ll mn = INT_MAX;\\n        for(auto &tm : time) mn =min(mn,(ll)tm);\\n        \\n        \\n        auto check = [&](ll xt){\\n          ll cnt = 0;\\n            for(auto &tm : time){\\n                cnt += (xt/tm);\\n            }\\n            \\n            return cnt >= t;\\n        };\\n        \\n       ll l=-1,r=mn*t+1;    \\n\\t   // min time = 0\\n\\t   // max time  = smallest  time taken by bus * no of round\\n        \\n       while(r-l > 1) {\\n           ll mid = l+(r-l)/2;\\n           if(check(mid))\\n               r = mid;\\n           else\\n               l = mid;\\n       }\\n        \\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n    long long minimumTime(vector<int>& time, int t) {\\n        \\n        ll mn = INT_MAX;\\n        for(auto &tm : time) mn =min(mn,(ll)tm);\\n        \\n        \\n        auto check = [&](ll xt){\\n          ll cnt = 0;\\n            for(auto &tm : time){\\n                cnt += (xt/tm);\\n            }\\n            \\n            return cnt >= t;\\n        };\\n        \\n       ll l=-1,r=mn*t+1;    \\n\\t   // min time = 0\\n\\t   // max time  = smallest  time taken by bus * no of round\\n        \\n       while(r-l > 1) {\\n           ll mid = l+(r-l)/2;\\n           if(check(mid))\\n               r = mid;\\n           else\\n               l = mid;\\n       }\\n        \\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802661,
                "title": "easy-understanding-binary-search",
                "content": "```\\nbool isvalid(vector<int>&time,long long k, long long mid){\\n      long long cnt=0;\\n        for(long long i=0; i<time.size(); i++){\\n            cnt+=mid/time[i];\\n        }\\n        return cnt>=k;\\n    }\\n    long long minimumTime(vector<int>& time, int k) {\\n        long long  l=*min_element(time.begin(),time.end());\\n        long long  h=1e14 + 1;\\n        long long  ans=h;\\n        while(l<=h){\\n            long long mid=l+(h-l)/2;\\n            if(isvalid(time,k,mid)){\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return ans;\\n        \\n    }",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nbool isvalid(vector<int>&time,long long k, long long mid){\\n      long long cnt=0;\\n        for(long long i=0; i<time.size(); i++){\\n            cnt+=mid/time[i];\\n        }\\n        return cnt>=k;\\n    }\\n    long long minimumTime(vector<int>& time, int k) {\\n        long long  l=*min_element(time.begin(),time.end());\\n        long long  h=1e14 + 1;\\n        long long  ans=h;\\n        while(l<=h){\\n            long long mid=l+(h-l)/2;\\n            if(isvalid(time,k,mid)){\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1802488,
                "title": "c-binary-search-on-answer-on-time-search-space",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& time, long long currTime,int totalTrips){\\n        long long curr = 0;\\n        for(int i=0; i<time.size(); i++){\\n            curr += currTime/time[i];\\n        }\\n        return (curr >= totalTrips);\\n    }\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int n = time.size();\\n        \\n        long long start = 1;\\n        long long mini = (long long) *min_element(time.begin(),time.end());\\n        long long tot = (long long) totalTrips;\\n        long long end = mini * tot;\\n        long long ans = -1;\\n        \\n        while(start <= end){\\n            long long mid = start + (end - start)/2;\\n            if(isValid(time,mid,totalTrips)){\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isValid(vector<int>& time, long long currTime,int totalTrips){\\n        long long curr = 0;\\n        for(int i=0; i<time.size(); i++){\\n            curr += currTime/time[i];\\n        }\\n        return (curr >= totalTrips);\\n    }\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int n = time.size();\\n        \\n        long long start = 1;\\n        long long mini = (long long) *min_element(time.begin(),time.end());\\n        long long tot = (long long) totalTrips;\\n        long long end = mini * tot;\\n        long long ans = -1;\\n        \\n        while(start <= end){\\n            long long mid = start + (end - start)/2;\\n            if(isValid(time,mid,totalTrips)){\\n                ans = mid;\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802422,
                "title": "simple-c-solution",
                "content": "```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n        long long sum = 0, low = 0, high, mid;\\n        int n = time.size();\\n\\t\\thigh = 1;\\n        while(sum < totalTrips){\\n            low = high;\\n            sum = 0;\\n            for(auto i: time)\\n                sum += high/i;\\n            high <<= 1;\\n        }\\n        high = low;\\n        low >>= 1;\\n        while((high - low) > 1000){\\n            sum = 0;\\n            mid = low + (high - low)/2;   \\n            for(auto i: time)\\n                sum += mid/i;\\n            if(sum > totalTrips)\\n                high = mid;\\n            else if(sum < totalTrips)\\n                low = mid;\\n            else\\n                break;\\n          }\\n        for(; low <= high; low++)\\n        {\\n            sum = 0;\\n            for(auto i: time)\\n                sum += low/i;\\n            if(sum >= totalTrips)\\n            {\\n                return low;\\n            }      \\n        }\\n        return 1;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nlong long minimumTime(vector<int>& time, int totalTrips) {\\n        long long sum = 0, low = 0, high, mid;\\n        int n = time.size();\\n\\t\\thigh = 1;\\n        while(sum < totalTrips){\\n            low = high;\\n            sum = 0;\\n            for(auto i: time)\\n                sum += high/i;\\n            high <<= 1;\\n        }\\n        high = low;\\n        low >>= 1;\\n        while((high - low) > 1000){\\n            sum = 0;\\n            mid = low + (high - low)/2;   \\n            for(auto i: time)\\n                sum += mid/i;\\n            if(sum > totalTrips)\\n                high = mid;\\n            else if(sum < totalTrips)\\n                low = mid;\\n            else\\n                break;\\n          }\\n        for(; low <= high; low++)\\n        {\\n            sum = 0;\\n            for(auto i: time)\\n                sum += low/i;\\n            if(sum >= totalTrips)\\n            {\\n                return low;\\n            }      \\n        }\\n        return 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3876115,
                "title": "c-binary-search-based-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>&arr , long long int  time ,long long int number){\\n       \\n        int n = arr.size();\\n        long long int result = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            result += (time/(long long int)arr[i]);\\n        }\\n        return result>=number;\\n    }\\n    long long minimumTime(vector<int>& arr, int trip) {\\n         sort(arr.begin() , arr.end());\\n         long long int low = 0 , high = (long long int)arr[0]*(long long int)trip ;\\n         long long int result = 0;\\n         while(low <= high){\\n             long long int mid = low + (high - low)/2;\\n             if(isValid(arr , mid , (long long int)trip)){\\n                   result = mid;\\n                   high = mid - 1;\\n             }else{\\n                 low = mid + 1;\\n             }\\n         }\\n         return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(vector<int>&arr , long long int  time ,long long int number){\\n       \\n        int n = arr.size();\\n        long long int result = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            result += (time/(long long int)arr[i]);\\n        }\\n        return result>=number;\\n    }\\n    long long minimumTime(vector<int>& arr, int trip) {\\n         sort(arr.begin() , arr.end());\\n         long long int low = 0 , high = (long long int)arr[0]*(long long int)trip ;\\n         long long int result = 0;\\n         while(low <= high){\\n             long long int mid = low + (high - low)/2;\\n             if(isValid(arr , mid , (long long int)trip)){\\n                   result = mid;\\n                   high = mid - 1;\\n             }else{\\n                 low = mid + 1;\\n             }\\n         }\\n         return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358703,
                "title": "binary-search-c-solution",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(long long tm, vector<int>& time, int totalTrips){\\n        long long curr=0;\\n        for (auto vl: time){\\n            curr+= (tm/vl);\\n        }\\n        if (curr>= (long long)(totalTrips))return true;\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long low=0;\\n        long long high= (*min_element(time.begin(),time.end()))*(1LL)*(totalTrips);\\n        sort(time.begin(),time.end());\\n        long long ans=1;\\n        while (low<=high){\\n            long long mid= low+ (high-low)/2;\\n            if (isPossible(mid,time,totalTrips)){\\n                ans= mid;\\n                high= mid-1;\\n            }\\n            else{\\n                low= mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(long long tm, vector<int>& time, int totalTrips){\\n        long long curr=0;\\n        for (auto vl: time){\\n            curr+= (tm/vl);\\n        }\\n        if (curr>= (long long)(totalTrips))return true;\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long low=0;\\n        long long high= (*min_element(time.begin(),time.end()))*(1LL)*(totalTrips);\\n        sort(time.begin(),time.end());\\n        long long ans=1;\\n        while (low<=high){\\n            long long mid= low+ (high-low)/2;\\n            if (isPossible(mid,time,totalTrips)){\\n                ans= mid;\\n                high= mid-1;\\n            }\\n            else{\\n                low= mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270137,
                "title": "java-simplest-solution-beats-99-o-log-10-7-k-n",
                "content": "# Approach\\nBest approach is to play around with brute force solution and find out how can I tell how many trips can all busses take in time t. \\nFrom this I can consider my t somewhere between 1 and 10^7 * totalTrips (worst case scenario). From this I can tell at index i if my time t lies before or after it, \\nbecause if I can do totalTrips in time t, it means I can do totalTrips in every number after t. \\nSame applies to case when I can\\'t do totalTrips in t, then I can\\'t do it before t.\\n\\nThis means I can find it in log(10^7*k) * n - because it costs n in worst case to determine max number of trips at time t.\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(10^7*k)*n)$$ - it is better to scale up maximum to prevent large array iteration, because it costs only a few operation to cut it out in binary search.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low = 1;\\n        long high = 10000000L * totalTrips;\\n\\n        while (low < high) {\\n            long mid = (low+high)/2;\\n\\n            if (!canComplete(mid, time, totalTrips)) {\\n                low = mid+1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n    private boolean canComplete (long t, int[] time, int totalTrips) {\\n        long sum = 0;\\n        for (int item: time) {\\n            sum += t / item;\\n            if (sum >= totalTrips) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low = 1;\\n        long high = 10000000L * totalTrips;\\n\\n        while (low < high) {\\n            long mid = (low+high)/2;\\n\\n            if (!canComplete(mid, time, totalTrips)) {\\n                low = mid+1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n\\n        return low;\\n    }\\n\\n    private boolean canComplete (long t, int[] time, int totalTrips) {\\n        long sum = 0;\\n        for (int item: time) {\\n            sum += t / item;\\n            if (sum >= totalTrips) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3270051,
                "title": "c-solution-beats-100-in-performance-binary-search-with-some-extra-optimization",
                "content": "# Intuition\\nAt a given time, the number of trips are the sum of the trips that the buses have done. The $$i$$th bus have done $$givenTime / time[i]$$ integer division trips at a given time, we don\\'t care about the remainder (modulus) as only the full trips count. We need to find the smallest time where this sum is greater than the given totalTrips value.\\n\\n# Approach\\nIf we have a look at the sums, we can find that it is an *equal or increasing* sequence, as with the extra next day the sum can\\'t be less than the previous one (it can be equal on some days for relatively larger time[i] values). This would indicate that if we find a value range that we can identify for the sums, we can do a more optimal binary search algorithm.\\n\\nAs totalTrips cannot be 0, the minimum value for the days count could be 1. In the worst case, to get totalTrips we should do maximum $$min * totalTrips$$ days where min is the minimum value of the time array: if we would have only that bus and it would go for $$min * totalTrips$$ with a $$min$$ total cost of a roundtrip, that would mean it alone did the preferred $$totalTrip$$ count of trips. So these values would be the lower and upper boundaries of the binary search.\\n\\nSo first we will need to find minimum value with a simple min search. Next we will have to do a binary search with the range of 1 to min * totalTrip to check which is the first sum that is actualy greater then totalTrips. Here comes another trick: we don\\'t have to calculate the actual sum values in all cases, we just\\nhave to say if a give day is less than the totalTrips value or not. That means that while iterating through the time collection and calculating the sum value from the integer divisions, if we find that the current sum is already greater than totalTrips, we can short circuit the result and don\\'t have to iterate through the rest of the times for that given day.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(totalTrips * min)$$ where n is the number of buses, and min is the minimum amount of the times array\\n    -   minimum search with $$O(n)$$\\n    -   the binary search for finding the smallest number that is greater or equal to the totalnumber in range of [1.. totalTrips * min] is log(totalTrips * min)\\n    - and for each item we need to sum all the n times as a worst case (for sums greater than totalTrips we don\\'t have to iterate on all, but for smaller ones we do have to)\\n\\n- Space complexity:\\n$$O(1)$$ constant time as only a couple of longs and ints are used for storing min value, left and right pointers, and temp counts\\n\\n# Code\\n```\\npublic class Solution {\\n    public long MinimumTime(int[] time, int totalTrips) {\\n        int min = time[0];\\n        for(int i = 1; i < time.Length; i++)\\n        {\\n            if (min > time[i])\\n            {\\n                min = time[i];\\n            }\\n        }\\n\\n        long left = 1;\\n        long right = (long)totalTrips * min;\\n        while (left < right)\\n        {\\n            long mid = left + (right - left) / 2;\\n            if (IsLess(time, mid, totalTrips))\\n            {\\n                left = mid + 1;\\n            }\\n            else\\n            {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n\\n    private bool IsLess(int[] time, long current, int totalTrips)\\n    {\\n        long total = 0;\\n        for(int j = 0; j < time.Length; j++)\\n        {\\n            total += current / time[j];\\n            if (total >= totalTrips)\\n            {\\n                return false;\\n            } \\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution {\\n    public long MinimumTime(int[] time, int totalTrips) {\\n        int min = time[0];\\n        for(int i = 1; i < time.Length; i++)\\n        {\\n            if (min > time[i])\\n            {\\n                min = time[i];\\n            }\\n        }\\n\\n        long left = 1;\\n        long right = (long)totalTrips * min;\\n        while (left < right)\\n        {\\n            long mid = left + (right - left) / 2;\\n            if (IsLess(time, mid, totalTrips))\\n            {\\n                left = mid + 1;\\n            }\\n            else\\n            {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n\\n    private bool IsLess(int[] time, long current, int totalTrips)\\n    {\\n        long total = 0;\\n        for(int j = 0; j < time.Length; j++)\\n        {\\n            total += current / time[j];\\n            if (total >= totalTrips)\\n            {\\n                return false;\\n            } \\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269891,
                "title": "java-solution-using-binary-search",
                "content": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low = 1;\\n        long min = Integer.MAX_VALUE;\\n        for(int t:time){\\n            min = Math.min(min,t);\\n        }\\n        long high = min*totalTrips;\\n        \\n        while(low<high){\\n            long samay = (low+high)/2;\\n            \\n            if(validSamay(time,totalTrips,samay)){\\n                high = samay;\\n            }else{\\n                low = samay+1;\\n            }\\n        }\\n        return low;\\n    }\\n    \\n    public boolean validSamay(int[]time,int totalTrips,long samay){\\n        long trips = 0;\\n        for(int t:time){\\n            trips += samay/t;\\n        }\\n        return trips >= totalTrips;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long low = 1;\\n        long min = Integer.MAX_VALUE;\\n        for(int t:time){\\n            min = Math.min(min,t);\\n        }\\n        long high = min*totalTrips;\\n        \\n        while(low<high){\\n            long samay = (low+high)/2;\\n            \\n            if(validSamay(time,totalTrips,samay)){\\n                high = samay;\\n            }else{\\n                low = samay+1;\\n            }\\n        }\\n        return low;\\n    }\\n    \\n    public boolean validSamay(int[]time,int totalTrips,long samay){\\n        long trips = 0;\\n        for(int t:time){\\n            trips += samay/t;\\n        }\\n        return trips >= totalTrips;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269780,
                "title": "c-easy-as-possible-binary-search",
                "content": "**Bold**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long isPos(vector<int> &v, long long mid){\\n        long long time=0;\\n        for(auto  x:v) time+=mid/x;\\n        return time;\\n    }\\n    long long m(vector<int> &v){\\n        int j=INT_MAX;\\n        for(auto x:v){\\n            j= min(x,j);\\n        }\\n        return j;\\n    }\\n    long long minimumTime(vector<int>& v, int k) {\\n        long long ans=0,i=0,j=m(v)*k;\\n        while(i<=j){\\n            long long mid=(i+j)/2;\\n            if(isPos(v,mid)>=k){\\n                ans=mid;\\n                j=mid-1;\\n            }else{\\n                i=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long isPos(vector<int> &v, long long mid){\\n        long long time=0;\\n        for(auto  x:v) time+=mid/x;\\n        return time;\\n    }\\n    long long m(vector<int> &v){\\n        int j=INT_MAX;\\n        for(auto x:v){\\n            j= min(x,j);\\n        }\\n        return j;\\n    }\\n    long long minimumTime(vector<int>& v, int k) {\\n        long long ans=0,i=0,j=m(v)*k;\\n        while(i<=j){\\n            long long mid=(i+j)/2;\\n            if(isPos(v,mid)>=k){\\n                ans=mid;\\n                j=mid-1;\\n            }else{\\n                i=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269723,
                "title": "simple-optimsed-solution-using-binary-search-no-need-to-linearly-iterate-over-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        vector<long long>tr(time.size(),0);\\n        // long long tr[time.size()+1]\\n        //tr[i]-number of trips the ith buses has done\\n        long long total=0;\\n        long long low=1;\\n        long long high=1e14;\\n        long long t;\\n        long long best=0;\\n        while(low<=high){\\n            t=(low+high)/2;\\n            fill(tr.begin(),tr.end(),0);\\n            total=0;\\n            \\n            //we will manually try to break this loops\\n            for(int i=0;i<time.size();i++){\\n                \\n                    tr[i]=floor(t/time[i]);\\n                    total+=tr[i];\\n                \\n            }\\n            if(total>=totalTrips){\\n                best=t;\\n                high=t-1;\\n            }else{\\n                low=t+1;\\n            }\\n            \\n        }\\n        return best;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        vector<long long>tr(time.size(),0);\\n        // long long tr[time.size()+1]\\n        //tr[i]-number of trips the ith buses has done\\n        long long total=0;\\n        long long low=1;\\n        long long high=1e14;\\n        long long t;\\n        long long best=0;\\n        while(low<=high){\\n            t=(low+high)/2;\\n            fill(tr.begin(),tr.end(),0);\\n            total=0;\\n            \\n            //we will manually try to break this loops\\n            for(int i=0;i<time.size();i++){\\n                \\n                    tr[i]=floor(t/time[i]);\\n                    total+=tr[i];\\n                \\n            }\\n            if(total>=totalTrips){\\n                best=t;\\n                high=t-1;\\n            }else{\\n                low=t+1;\\n            }\\n            \\n        }\\n        return best;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269689,
                "title": "ordered-binary-search",
                "content": "```\\nlong long check(long long mid,vector<int>&v,long long t){\\n       long long c=0;\\n        for(int i=0;i<v.size();i++){\\n            c+=mid/v[i];\\n        }\\n        return c;\\n    }\\n    long long minimumTime(vector<int>& time, long long t) {\\n       sort(time.begin(),time.end());\\n       long long l = 1, h = time[0]*t;\\n        while(l<h){\\n            long long mid=l+(h-l)/2;\\n            if(check(mid,time,t)>=t)\\n                h=mid;\\n            else\\n                l=mid+1;\\n        }\\n        return l;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nlong long check(long long mid,vector<int>&v,long long t){\\n       long long c=0;\\n        for(int i=0;i<v.size();i++){\\n            c+=mid/v[i];\\n        }\\n        return c;\\n    }\\n    long long minimumTime(vector<int>& time, long long t) {\\n       sort(time.begin(),time.end());\\n       long long l = 1, h = time[0]*t;\\n        while(l<h){\\n            long long mid=l+(h-l)/2;\\n            if(check(mid,time,t)>=t)\\n                h=mid;\\n            else\\n                l=mid+1;\\n        }\\n        return l;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3269669,
                "title": "binarysearch-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogm), where n = time, m=totalTrips.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} time\\n * @param {number} totalTrips\\n * @return {number}\\n */\\nvar minimumTime = function(time, totalTrips) {\\n    let min = 10**9;\\n    for(let t of time) {\\n        min = Math.min(t, min);\\n    }\\n    let left = 1;\\n    let right = min * totalTrips;\\n    function canComplete(possibleTime) {\\n        let curTrip = 0;\\n        for(let busTime of time) {\\n            curTrip += Math.floor(possibleTime/busTime);\\n            if(curTrip >= totalTrips) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    while(left < right) {\\n        let midTime = left + Math.floor((right - left)/2);\\n        let possible = canComplete(midTime);\\n        if(possible) {\\n            right = midTime;\\n        } else {\\n            left = midTime + 1;\\n        }\\n    }\\n    return right;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} time\\n * @param {number} totalTrips\\n * @return {number}\\n */\\nvar minimumTime = function(time, totalTrips) {\\n    let min = 10**9;\\n    for(let t of time) {\\n        min = Math.min(t, min);\\n    }\\n    let left = 1;\\n    let right = min * totalTrips;\\n    function canComplete(possibleTime) {\\n        let curTrip = 0;\\n        for(let busTime of time) {\\n            curTrip += Math.floor(possibleTime/busTime);\\n            if(curTrip >= totalTrips) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    while(left < right) {\\n        let midTime = left + Math.floor((right - left)/2);\\n        let possible = canComplete(midTime);\\n        if(possible) {\\n            right = midTime;\\n        } else {\\n            left = midTime + 1;\\n        }\\n    }\\n    return right;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3269666,
                "title": "simple-solution-using-range-binary-search-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long trip(vector<int>& time,long mid){\\n        long total=0;\\n        for(long c:time){\\n            total+=mid/c;\\n        }\\n        return total;\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long x=0;\\n        if(time.size()==1){\\n            x=time[0];\\n            long long y=totalTrips;\\n            return x*y;\\n        }\\n        sort(time.begin(),time.end());\\n        long l=1;\\n        long j=time[0];\\n        long r=j*totalTrips;\\n        \\n        while(l<r){\\n            long mid=(r-l)/2 +l;\\n            long total = trip(time,mid);\\n\\n            if(total<totalTrips){\\n                l=mid+1;\\n            }else{\\n                r=mid;\\n            }\\n        }\\n\\n        return l;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long trip(vector<int>& time,long mid){\\n        long total=0;\\n        for(long c:time){\\n            total+=mid/c;\\n        }\\n        return total;\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long x=0;\\n        if(time.size()==1){\\n            x=time[0];\\n            long long y=totalTrips;\\n            return x*y;\\n        }\\n        sort(time.begin(),time.end());\\n        long l=1;\\n        long j=time[0];\\n        long r=j*totalTrips;\\n        \\n        while(l<r){\\n            long mid=(r-l)/2 +l;\\n            long total = trip(time,mid);\\n\\n            if(total<totalTrips){\\n                l=mid+1;\\n            }else{\\n                r=mid;\\n            }\\n        }\\n\\n        return l;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269595,
                "title": "2187-minimum-time-to-complete-trips-java",
                "content": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        int n=time.length;\\n        long sta=0,end=totalTrips;\\n        end*=time[n-1];\\n        long ans=Long.MAX_VALUE;\\n        while(sta<=end)\\n        {\\n            long mid=sta+(end-sta)/2;\\n            long cnt=0;\\n            for(int sum:time)\\n                cnt+=(mid/sum);\\n            if(cnt>=totalTrips)\\n            {\\n               ans=Math.min(ans,mid);\\n                end=mid-1;\\n            }  \\n            else\\n                sta=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        int n=time.length;\\n        long sta=0,end=totalTrips;\\n        end*=time[n-1];\\n        long ans=Long.MAX_VALUE;\\n        while(sta<=end)\\n        {\\n            long mid=sta+(end-sta)/2;\\n            long cnt=0;\\n            for(int sum:time)\\n                cnt+=(mid/sum);\\n            if(cnt>=totalTrips)\\n            {\\n               ans=Math.min(ans,mid);\\n                end=mid-1;\\n            }  \\n            else\\n                sta=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269586,
                "title": "clean-code-python",
                "content": "**Please upvote if u liked the solution**\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        return bisect_left(range(time[0] * totalTrips + 1), True, key=lambda t: sum(t // bus for bus in time) >= totalTrips)\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        return bisect_left(range(time[0] * totalTrips + 1), True, key=lambda t: sum(t // bus for bus in time) >= totalTrips)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269482,
                "title": "c-solution-binary-search-on-answer-explained-solution",
                "content": "# Intuition\\nWe need to minimize the time so we can think of applying binary search on answer concept and create a minimum and maximum limit on time possible and try to minimize the time by applying binary search on that interval.\\n\\n# Approach\\nWe create a lower limit (l) on time which will be the lowest time in the array and an upper limit (h) on time which will be ( lowest time in the array * totaltrips ), because the least maximum time in which totaltrips can be completed will be the lowest time in the array mutiplied by totaltrips. Now we have an interval on time. We calculate the middle value and check whether it can be our possible answer or not. If it is a valid answer then we store it and we move h = mid-1 and we check for a better answer in the left interval. If it cannot be a valid answer then we check for an answer in the right interval(a larger time can become an answer). In the end we return our answer.  \\n\\n# Complexity\\n- Time complexity:\\nO(NlogN) where N is length of times array\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        sort(time.begin(), time.end());\\n        long long l = time[0];\\n        long long h = (long long)((long long)time[0]*(long long)totalTrips);\\n        long long mid = l+(h-l)/2;\\n        long long ans = LONG_LONG_MAX;\\n        while(l <= h)\\n        {\\n            mid = l+(h-l)/2;\\n            if(check(mid, time, totalTrips))\\n            {\\n                ans = mid;\\n                h = mid-1;\\n            }else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    bool check(long long time, vector<int>& times, int totaltrips)\\n    {\\n        bool valid = false;\\n        int currenttrips = 0;\\n        for(int i = 0;i < times.size(); i++)\\n        {\\n            if(times[i] > time)\\n            {\\n                break;\\n            }\\n            currenttrips += (time/times[i]);\\n            if(currenttrips >= totaltrips)\\n            {\\n                valid = true;\\n                break;\\n            }\\n        }\\n        return valid;\\n    }\\n};\\n```\\n\\n**Please upvote if you found it helpful ! \\uD83D\\uDE00\\uD83D\\uDE00**",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        sort(time.begin(), time.end());\\n        long long l = time[0];\\n        long long h = (long long)((long long)time[0]*(long long)totalTrips);\\n        long long mid = l+(h-l)/2;\\n        long long ans = LONG_LONG_MAX;\\n        while(l <= h)\\n        {\\n            mid = l+(h-l)/2;\\n            if(check(mid, time, totalTrips))\\n            {\\n                ans = mid;\\n                h = mid-1;\\n            }else\\n            {\\n                l = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    bool check(long long time, vector<int>& times, int totaltrips)\\n    {\\n        bool valid = false;\\n        int currenttrips = 0;\\n        for(int i = 0;i < times.size(); i++)\\n        {\\n            if(times[i] > time)\\n            {\\n                break;\\n            }\\n            currenttrips += (time/times[i]);\\n            if(currenttrips >= totaltrips)\\n            {\\n                valid = true;\\n                break;\\n            }\\n        }\\n        return valid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269444,
                "title": "python3-simple-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can reduce half the search space for time, in eac iteration of binary search.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbinay search\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nLet n be the length of time, m be the upper limit of totalTrips and k be the maximum time taken by one trip.\\nO(n.log(m.k))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        #binary search\\n        def checkIfTotalTripsCanHappen(timee):\\n            trips=0\\n            for i in time:\\n                trips+=(timee//i)\\n            return trips>=totalTrips\\n        #print(checkIfTotalTripsCanHappen(3))\\n        #print(checkIfTotalTripsCanHappen(2))\\n        #print(checkIfTotalTripsCanHappen(4))\\n\\n        left=1\\n        right=max(time)*totalTrips\\n        while(left<right):\\n            mid=left+(right-left)//2\\n            if(checkIfTotalTripsCanHappen(mid)):\\n                right=mid\\n            else:\\n                left=mid+1\\n        return left\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        #binary search\\n        def checkIfTotalTripsCanHappen(timee):\\n            trips=0\\n            for i in time:\\n                trips+=(timee//i)\\n            return trips>=totalTrips\\n        #print(checkIfTotalTripsCanHappen(3))\\n        #print(checkIfTotalTripsCanHappen(2))\\n        #print(checkIfTotalTripsCanHappen(4))\\n\\n        left=1\\n        right=max(time)*totalTrips\\n        while(left<right):\\n            mid=left+(right-left)//2\\n            if(checkIfTotalTripsCanHappen(mid)):\\n                right=mid\\n            else:\\n                left=mid+1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269435,
                "title": "c-solution-easy-and-full-explanation-binary-search",
                "content": "\\n# Approach\\nTo solve this problem, we can use binary search. We can assume a range of possible values for the minimum time required for all buses to complete at least totalTrips trips. We can start with the range [0, max(time) * totalTrips], where max(time) is the maximum time taken by any bus for one trip.\\n\\nWe can then perform binary search on this range to find the minimum time required. For each mid value in the range, we can calculate the total number of trips that can be completed in that time by all the buses. If the total number of trips is less than totalTrips, then we can search for a higher value of mid. Otherwise, we can search for a lower value of mid.\\n\\n# Complexity\\n- Time complexity:\\nO(n log m)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long left = 0;\\n        long long right = *max_element(time.begin(), time.end()) * (long long)totalTrips;\\n        \\n        while (left < right) {\\n            long long mid = (left + right) / 2;\\n            long long trips = 0;\\n            \\n            for (int t : time) {\\n                trips += mid / t;\\n            }\\n            \\n            if (trips < totalTrips) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long left = 0;\\n        long long right = *max_element(time.begin(), time.end()) * (long long)totalTrips;\\n        \\n        while (left < right) {\\n            long long mid = (left + right) / 2;\\n            long long trips = 0;\\n            \\n            for (int t : time) {\\n                trips += mid / t;\\n            }\\n            \\n            if (trips < totalTrips) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269374,
                "title": "swift-easy-to-understand-and-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    func minimumTime(_ time: [Int], _ totalTrips: Int) -> Int {\\n        let minimumTime = time.min()!\\n\\n        var l = minimumTime\\n        var r = minimumTime * totalTrips\\n\\n        while l <= r {\\n            let mid = (l + r) / 2\\n            let trips = time.reduce(0, { $0 + mid / $1 })\\n            if trips < totalTrips {\\n                l = mid + 1\\n            } else {\\n                r = mid - 1\\n            }\\n        }\\n\\n        return l\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumTime(_ time: [Int], _ totalTrips: Int) -> Int {\\n        let minimumTime = time.min()!\\n\\n        var l = minimumTime\\n        var r = minimumTime * totalTrips\\n\\n        while l <= r {\\n            let mid = (l + r) / 2\\n            let trips = time.reduce(0, { $0 + mid / $1 })\\n            if trips < totalTrips {\\n                l = mid + 1\\n            } else {\\n                r = mid - 1\\n            }\\n        }\\n\\n        return l\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269314,
                "title": "c-using-binary-saerch-explained-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can find whether the totalTrips can be completed in given time in O(n) complexity. We just need the appropriate time. If we have minTime and maxTime then we can easily find the appropriate time in O(logn) complexity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First sort the time array. time[0] will be the smallest element and time[n-1] will be the greatest element.\\n2. The maxTime to complete all trips will be -> time[n-1] * totalTrips.\\n3. The minTime will be 1 day.\\n4. int mid = (minTime + maxTime) / 2; If totalTrips are completed within mid time then maxTime = mid. Else we require more time. Then minTime = mid + 1.\\n5. This process will be repeated until minTime < maxTime. Once the condition fails we will return minTime. The complexity of this process will be O(logn).\\n6. To check if the totalTrips are completed within mid time, we will iterate through loop and check if summation of mid/ time[i] is greater than mid time. If it is grater the totalTrips can\\'t be completed in mid time and we will return false. If the summation sis less than mid time then we will return true. The complexity of this process will be O(n).\\n7. The total complexity of the solution will be O(nlogn).\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mo = 1e9+7;\\n    bool f(long long x,vector<int>&time,int totalTrips){\\n        long long int ans = 0;\\n        for(int i = 0;i < time.size();i++){\\n            ans += (long long)(x / time[i]);\\n        }\\n        if(ans >= totalTrips)return true;\\n        return false;\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        sort(time.begin(),time.end());\\n        int n = time.size();\\n        long long  minTime = 1;\\n        long long  maxTime = ((long long)(time[n-1]) * (long long)(totalTrips));\\n        while(minTime < maxTime){\\n            long long  mid = (minTime + maxTime) / 2;\\n            // cout << minTime << \" \" << maxTime << endl;\\n            if(f(mid,time,totalTrips)){\\n                maxTime = mid;\\n            }\\n            else{\\n                minTime = mid + 1;\\n            }\\n        }\\n        return minTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mo = 1e9+7;\\n    bool f(long long x,vector<int>&time,int totalTrips){\\n        long long int ans = 0;\\n        for(int i = 0;i < time.size();i++){\\n            ans += (long long)(x / time[i]);\\n        }\\n        if(ans >= totalTrips)return true;\\n        return false;\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        sort(time.begin(),time.end());\\n        int n = time.size();\\n        long long  minTime = 1;\\n        long long  maxTime = ((long long)(time[n-1]) * (long long)(totalTrips));\\n        while(minTime < maxTime){\\n            long long  mid = (minTime + maxTime) / 2;\\n            // cout << minTime << \" \" << maxTime << endl;\\n            if(f(mid,time,totalTrips)){\\n                maxTime = mid;\\n            }\\n            else{\\n                minTime = mid + 1;\\n            }\\n        }\\n        return minTime;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3269244,
                "title": "easy-to-remember-binary-search-approach",
                "content": "# Approach\\nGuess the minimum value using binary search\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogm)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    long long getTrips(vector<int>& time, long long val) {\\n        long long count = 0;\\n        for(auto itr:time) {\\n            count += val/itr;\\n        }\\n        return count;\\n    }\\n\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long high = 100000000000000LL, low = 1;\\n        long long ans = high;\\n\\n        while(low <= high) {\\n            long long mid = (low + high)/2;\\n            if(totalTrips<= getTrips(time, mid)) {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPlease upvote if you like the approach",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    long long getTrips(vector<int>& time, long long val) {\\n        long long count = 0;\\n        for(auto itr:time) {\\n            count += val/itr;\\n        }\\n        return count;\\n    }\\n\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long high = 100000000000000LL, low = 1;\\n        long long ans = high;\\n\\n        while(low <= high) {\\n            long long mid = (low + high)/2;\\n            if(totalTrips<= getTrips(time, mid)) {\\n                ans = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268986,
                "title": "o-n-log-k-solution-1378-ms-in-python3-beats-100",
                "content": "Here is a solution which is more efficient that the solutions using only the minimum of `time` for computing the upper bound.\\n\\nEDIT: I added an improvement whose worst-case complexity only depends on $$n$$: no matter `totalTrips` and the values in `time`, it runs in at most $$O(n \\\\log(n))$$, and it can be faster depending on the values in `time`.\\n\\n# Intuition\\n- Provide improved bounds on the time required before starting the binary search.\\n\\n# Approach\\n\\nThis assumes that you understood properly the simple solution.\\n\\n## Computation of the bounds\\nLet $$x_1, ..., x_n$$ be the values in the array `time`, let $$p$$ be `totalTrips`, let $$T_0$$ be the result and let $$S = \\\\displaystyle \\\\sum_{i = 1}^{n} \\\\displaystyle \\\\frac{1}{x_i}$$.\\n\\nFor a given time $$t$$, the maximal number of trips is $$f(t) = \\\\displaystyle \\\\sum_{i = 1}^{n} \\\\left \\\\lfloor \\\\displaystyle \\\\frac{t}{x_i} \\\\right \\\\rfloor$$.\\n\\n**Lower bound** \\n$$T_0 \\\\geqslant \\\\left \\\\lceil \\\\displaystyle \\\\frac{p}{S} \\\\right \\\\rceil$$\\n\\n**Proof of the lower bound**\\nOn the one hand, $$f(T_0) = \\\\displaystyle \\\\sum_{i = 1}^{n} \\\\left \\\\lfloor \\\\displaystyle \\\\frac{T_0}{x_i} \\\\right \\\\rfloor \\\\leqslant \\\\displaystyle \\\\sum_{i = 1}^{n} \\\\displaystyle \\\\frac{T_0}{x_i} = T_0 S$$. \\nOn the other hand, $$f(T_0) \\\\geqslant p$$ by definition of $$T_0$$.\\nTherefore, $$T_0 \\\\geqslant \\\\displaystyle \\\\frac{p}{S}$$.\\n\\n\\n**Upper bound**\\n$$T_0 \\\\leqslant 1 + \\\\left \\\\lfloor \\\\displaystyle \\\\frac{p + n - 1}{S}\\\\right \\\\rfloor$$\\n**Proof of the upper bound**\\nFirst, $$f(T_0 - 1) = \\\\displaystyle \\\\sum_{i = 1}^{n} \\\\left \\\\lfloor \\\\displaystyle \\\\frac{T_0 - 1}{x_i} \\\\right \\\\rfloor > \\\\displaystyle \\\\sum_{i = 1}^{n} \\\\left( \\\\displaystyle \\\\frac{T_0 - 1}{x_i} - 1 \\\\right) = (T_0 - 1) S - n$$.\\nBesides, $$f(T_0 - 1) \\\\leqslant p - 1$$ by definition of $$T_0$$.\\nThen $$T_0 < 1 + \\\\displaystyle \\\\frac{p + n - 1}{S}$$.\\n\\n## Floating point caveat\\nComputing the sum of the inverses of the elements of `time` is subject to rounding errors because it uses float. This is why in the code I use `fsum` instead of `sum` for a more accurate computation as well as `float_safety = 1e-3` so if that the result is really close to an integer I actually move pass that integer.\\n\\n## EDIT: An improvement with an even better complexity\\nNote: this is slower in practice unless the integers in `time` are quite big.\\n\\n**Observation:** $$T_0$$ is necessarily a multiple of some $$x_i$$ (consequence of the minimality of $$T_0$$).\\n\\nWhat makes the binary search slow down when the $$x_i$$\\'s get really big in comparision to $$n$$ is that we might do little steps whereas the multiples are sparse.\\n\\nHere is an example (not realistic, just to convey the idea):\\n- We are looking for a multiple of $$2^{1000}$$\\n- $$left = 5 \\\\times 2^{1000} - 42$$ and $$right = 6 \\\\times 2^{1000} - 42$$\\n    - Simple binary search would need 1000 iterations.\\n    - Jumping to multiples would require 2 iterations.\\n\\n**Algorithm: Modified binary search**\\nInstead of updating `right` or `left` with the middle value, we use the following updating rule.\\n\\n- If we want to update `right` to `mid`, run through the array to find to largest multiple not greater than `mid` and use this value for the update.\\n- If we want to update `left` to `mid + 1`, run through the array to find to smallest multiple greater than `mid` and use this value for the update.\\n\\nEach update runs in $$O(n)$$ so the complexity of each iteration of the binary search is still the same.\\n\\n# Complexity\\nLet $$n$$ be the length of time, $$k$$ be the maximum time taken by one trip, and $$l$$ be the maximum time taken by one trip.\\n- Time complexity: $$O(n \\\\log(\\\\min(k, nl))$$ (actually $$O(n \\\\log\\\\frac{n}{S})$$)\\n    - $$S \\\\geqslant \\\\displaystyle \\\\frac{n}{k}$$ and $$S \\\\geqslant \\\\displaystyle \\\\frac{1}{l}$$.\\n    - For the binary search, the size of the search space is less than $$ 1 + \\\\displaystyle \\\\frac{n}{S} \\\\leqslant 1 + \\\\min(k, nl)$$ so it requires $$O(\\\\log(\\\\min(k, nl)))$$ iterations.\\n    - Each binary search iteration runs in $$O(n)$$.\\n    - Computation of the bounds is done in $$O(n)$$.\\n- EDIT: Time complexity of the improved version: $$O(n \\\\log(n \\\\min(1, S^{-1})))$$\\n    - The number of iteration of the modified binary search depends on the number of multiples of $$x_i$$\\'s in the search interval which is less than $$length\\\\_of\\\\_interval \\\\times S + n$$, that is $$O(n)$$.\\n\\n\\n# Code\\nNote: this code is a simplified version of my submission for users who are not very familiar with python. My actual submission uses a python specific trick to have a faster running code although with the same complexity (see below).\\n\\n```python []\\nfrom math import ceil, floor, fsum\\n\\n\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        n = len(time)\\n        # use fsum instead of sum for improved float accuracy\\n        sum_inv = fsum(1 / t for t in time)\\n        # add an extra margin because of rounding errors\\n        float_safety = 1e-3\\n        left = ceil(totalTrips / sum_inv - float_safety)\\n        right = floor((totalTrips + n - 1) / sum_inv + float_safety)\\n\\n        while left != right:\\n            mid = (left + right) // 2\\n            if sum((mid // t for t in time)) >= totalTrips:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        return left\\n```\\n\\nMy actual code uses the map builtin with a dunder method twice because it is faster than a handwritten generator.\\n\\n```python []\\nfsum(map((1).__truediv__, time))\\n# instead of\\nfsum(1 / t for t in time)\\n\\n# and\\n\\nsum(map(mid.__floordiv__, time))\\n# instead of\\nsum((mid // t for t in time))\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nfrom math import ceil, floor, fsum\\n\\n\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        n = len(time)\\n        # use fsum instead of sum for improved float accuracy\\n        sum_inv = fsum(1 / t for t in time)\\n        # add an extra margin because of rounding errors\\n        float_safety = 1e-3\\n        left = ceil(totalTrips / sum_inv - float_safety)\\n        right = floor((totalTrips + n - 1) / sum_inv + float_safety)\\n\\n        while left != right:\\n            mid = (left + right) // 2\\n            if sum((mid // t for t in time)) >= totalTrips:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        return left\\n```\n```python []\\nfsum(map((1).__truediv__, time))\\n# instead of\\nfsum(1 / t for t in time)\\n\\n# and\\n\\nsum(map(mid.__floordiv__, time))\\n# instead of\\nsum((mid // t for t in time))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268735,
                "title": "simple-binary-search-c-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n       long long n =time.size();\\n       sort(time.begin(), time.end()); \\n       long long low = 0 ,high = totalTrips*(long long)time[0];\\n       while(low < high){\\n           long long mid = low + (high - low) / 2;\\n           long long completed = 0;\\n           for(auto x:time){\\n              completed += mid/x;\\n           }\\n           if(completed < totalTrips)\\n               low = mid + 1;\\n           else \\n              high = mid;\\n       }\\n       return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n       long long n =time.size();\\n       sort(time.begin(), time.end()); \\n       long long low = 0 ,high = totalTrips*(long long)time[0];\\n       while(low < high){\\n           long long mid = low + (high - low) / 2;\\n           long long completed = 0;\\n           for(auto x:time){\\n              completed += mid/x;\\n           }\\n           if(completed < totalTrips)\\n               low = mid + 1;\\n           else \\n              high = mid;\\n       }\\n       return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268725,
                "title": "whole-trips",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n * log(totalTrips * minTripTime))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canMakeTrips(vector<int>& time, int totalTrips, long long Ttime) {\\n        long long trips = 0;\\n        for(int t: time)\\n            trips += Ttime / t;\\n        return trips >= totalTrips;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long mint = *min_element(time.begin(), time.end());\\n        long long mid, l = mint, r = totalTrips * mint;\\n        while(l <= r) {\\n            mid = l + (r - l) / 2;\\n            if(canMakeTrips(time, totalTrips, mid))\\n                r = mid - 1;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canMakeTrips(vector<int>& time, int totalTrips, long long Ttime) {\\n        long long trips = 0;\\n        for(int t: time)\\n            trips += Ttime / t;\\n        return trips >= totalTrips;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long mint = *min_element(time.begin(), time.end());\\n        long long mid, l = mint, r = totalTrips * mint;\\n        while(l <= r) {\\n            mid = l + (r - l) / 2;\\n            if(canMakeTrips(time, totalTrips, mid))\\n                r = mid - 1;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268706,
                "title": "python3-solution-beats-84-75",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        def check(n):\\n            s = 0\\n            for i in time:\\n                s += n // i\\n            return s >= totalTrips\\n\\n        l = -1\\n        r = totalTrips * min(time)\\n        while l + 1 < r:\\n            mid = (l + r) >> 1\\n            if check(mid):\\n                r = mid\\n            else:\\n                l = mid\\n        return r\\n```\\n\\n# Complexity\\n- Time complexity: O(len(time) * log(totalTrips * min(time))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        def check(n):\\n            s = 0\\n            for i in time:\\n                s += n // i\\n            return s >= totalTrips\\n\\n        l = -1\\n        r = totalTrips * min(time)\\n        while l + 1 < r:\\n            mid = (l + r) >> 1\\n            if check(mid):\\n                r = mid\\n            else:\\n                l = mid\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268566,
                "title": "get-the-range-and-do-binary-search",
                "content": "tle:\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& a, int tt) {\\n        \\n        int n = a.size();\\n        vector<int> mp(n);\\n        \\n        mp = a;\\n        long long int t = 0, res=0;\\n        \\n        while(1)\\n        {\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                mp[i]--;\\n                \\n                if(mp[i] == 0)\\n                {\\n                    res++;\\n                    mp[i] = a[i];\\n                }\\n                \\n            }\\n            \\n            t++;\\n            \\n            if(res>=tt)\\n                break;\\n        }\\n        \\n        return t;\\n            \\n        \\n    }\\n};\\n```\\n\\naccepted:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>& a, int tt,long long int val)\\n    {\\n        long long int cnt=0;\\n        for(auto i: a)\\n        {\\n            cnt+=(val/i);\\n        }\\n        \\n        return cnt>=tt;\\n    }\\n    long long minimumTime(vector<int>& a, int tt) {\\n        \\n        int n = a.size();\\n        long long int l,r,ans;\\n        l = INT_MAX;\\n        r = INT_MIN;\\n        \\n        for(long long int i: a)\\n        {\\n            l = min(i,l);\\n            r = max(i,r); \\n        }\\n        \\n        r*=tt;\\n        \\n        while(l<=r)\\n        {\\n            long long int mid = l+(r-l)/2;\\n            if(check(a,tt,mid))\\n            {\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n            \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& a, int tt) {\\n        \\n        int n = a.size();\\n        vector<int> mp(n);\\n        \\n        mp = a;\\n        long long int t = 0, res=0;\\n        \\n        while(1)\\n        {\\n            \\n            for(int i=0;i<n;i++)\\n            {\\n                mp[i]--;\\n                \\n                if(mp[i] == 0)\\n                {\\n                    res++;\\n                    mp[i] = a[i];\\n                }\\n                \\n            }\\n            \\n            t++;\\n            \\n            if(res>=tt)\\n                break;\\n        }\\n        \\n        return t;\\n            \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<int>& a, int tt,long long int val)\\n    {\\n        long long int cnt=0;\\n        for(auto i: a)\\n        {\\n            cnt+=(val/i);\\n        }\\n        \\n        return cnt>=tt;\\n    }\\n    long long minimumTime(vector<int>& a, int tt) {\\n        \\n        int n = a.size();\\n        long long int l,r,ans;\\n        l = INT_MAX;\\n        r = INT_MIN;\\n        \\n        for(long long int i: a)\\n        {\\n            l = min(i,l);\\n            r = max(i,r); \\n        }\\n        \\n        r*=tt;\\n        \\n        while(l<=r)\\n        {\\n            long long int mid = l+(r-l)/2;\\n            if(check(a,tt,mid))\\n            {\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else\\n            {\\n                l = mid+1;\\n            }\\n            \\n            \\n        }\\n        \\n        return ans;\\n            \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268529,
                "title": "java-binary-search-on-answer",
                "content": "```\\nclass Solution {\\n    \\n    public long possibleTrips(long mid,int[] time){\\n        long trips = 0;\\n        for(int t : time){\\n            trips+=(mid/t);\\n        }\\n        return trips;\\n    }\\n    \\n    long ans = Long.MAX_VALUE;\\n    \\n    public void solve(long i, long j, int[] time, int totalTrips){\\n        while(i<=j){\\n            long mid = i+ ( (j-i)/2 );\\n            long tripsPossible = possibleTrips(mid,time);\\n            if(tripsPossible >= totalTrips){\\n                ans = Math.min(mid,ans);\\n                j = mid - 1;\\n            }else\\n                i = mid + 1;\\n        }\\n    }\\n    \\n    public long minimumTime(int[] time, int totalTrips) {\\n        long i = 0, j = totalTrips;\\n        int n = time.length;\\n        j*=time[n-1];\\n        solve(i,j,time,totalTrips);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public long possibleTrips(long mid,int[] time){\\n        long trips = 0;\\n        for(int t : time){\\n            trips+=(mid/t);\\n        }\\n        return trips;\\n    }\\n    \\n    long ans = Long.MAX_VALUE;\\n    \\n    public void solve(long i, long j, int[] time, int totalTrips){\\n        while(i<=j){\\n            long mid = i+ ( (j-i)/2 );\\n            long tripsPossible = possibleTrips(mid,time);\\n            if(tripsPossible >= totalTrips){\\n                ans = Math.min(mid,ans);\\n                j = mid - 1;\\n            }else\\n                i = mid + 1;\\n        }\\n    }\\n    \\n    public long minimumTime(int[] time, int totalTrips) {\\n        long i = 0, j = totalTrips;\\n        int n = time.length;\\n        j*=time[n-1];\\n        solve(i,j,time,totalTrips);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268525,
                "title": "swift-with-image",
                "content": "# Intuition\\nMake init range from **min** value to **max * totalTrips**. Our answer in this range. (In the example below 1...15)\\n\\nUse binary search for getting full time and count all bus tours for each busses.\\n\\n**Input: time = [1,2,3], totalTrips = 5**\\n![Screenshot 2023-03-07 at 16.02.04.png](https://assets.leetcode.com/users/images/f632753f-721b-427c-a895-3acdf9c01070_1678190558.5573187.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    func minimumTime(_ time: [Int], _ totalTrips: Int) -> Int {\\n        var left = time.min()!\\n        var right = time.max()! * totalTrips\\n\\n        func timeEnough(_ int: Int) -> Bool {\\n            var tripsCount = 0\\n\\n            for t in time {\\n                tripsCount += (int / t)\\n            }\\n\\n            return tripsCount >= totalTrips\\n        }\\n\\n        while left < right {\\n            let mid = (left + right) / 2\\n\\n            if timeEnough(mid) {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n\\n        return left\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumTime(_ time: [Int], _ totalTrips: Int) -> Int {\\n        var left = time.min()!\\n        var right = time.max()! * totalTrips\\n\\n        func timeEnough(_ int: Int) -> Bool {\\n            var tripsCount = 0\\n\\n            for t in time {\\n                tripsCount += (int / t)\\n            }\\n\\n            return tripsCount >= totalTrips\\n        }\\n\\n        while left < right {\\n            let mid = (left + right) / 2\\n\\n            if timeEnough(mid) {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n\\n        return left\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268521,
                "title": "brute-force-to-optimal-c-binary-search",
                "content": "\\n# Brute Force (TLE)\\n\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n\\n        long long CurrentTime = 0;\\n\\n\\n        while(1)\\n        {\\n            CurrentTime++;\\n\\n            for(int i = 0; i<time.size(); i++)\\n            {\\n                if(CurrentTime%time[i]==0)\\n                {\\n                    totalTrips--;\\n                }\\n\\n                if(totalTrips<=0) break;\\n            }\\n\\n            if(totalTrips<=0) break;\\n        }\\n\\n\\n        return CurrentTime;\\n        \\n    }\\n};\\n```\\n\\n# Binary Search (Accepted)\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>&time, long long currentTime, int totalTrips)\\n    {\\n        long long maximumTrip = 0;\\n\\n\\n        for(auto &it : time)\\n        {\\n            maximumTrip+= currentTime/it;\\n        }\\n\\n        return maximumTrip>=totalTrips;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n\\n        int n = time.size();\\n\\n\\n        long long start = 1;\\n\\n        long long last = (long long) *min_element(begin(time), end(time)) * totalTrips;\\n\\n        // Apply Binary Search in this range\\n\\n\\n        while(start<last)\\n        {\\n            long long mid = start + (last-start)/2;\\n\\n            if(isPossible(time,mid,totalTrips))\\n            {\\n                // if it is true then no need to search in the part which is grater than mid; so reduce the search space and check for left side if there any minimum number is possible.\\n\\n                last = mid;\\n            }\\n            else\\n            {\\n                start = mid+1;\\n            }\\n        }\\n\\n\\n        return start;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n\\n        long long CurrentTime = 0;\\n\\n\\n        while(1)\\n        {\\n            CurrentTime++;\\n\\n            for(int i = 0; i<time.size(); i++)\\n            {\\n                if(CurrentTime%time[i]==0)\\n                {\\n                    totalTrips--;\\n                }\\n\\n                if(totalTrips<=0) break;\\n            }\\n\\n            if(totalTrips<=0) break;\\n        }\\n\\n\\n        return CurrentTime;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPossible(vector<int>&time, long long currentTime, int totalTrips)\\n    {\\n        long long maximumTrip = 0;\\n\\n\\n        for(auto &it : time)\\n        {\\n            maximumTrip+= currentTime/it;\\n        }\\n\\n        return maximumTrip>=totalTrips;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n\\n        int n = time.size();\\n\\n\\n        long long start = 1;\\n\\n        long long last = (long long) *min_element(begin(time), end(time)) * totalTrips;\\n\\n        // Apply Binary Search in this range\\n\\n\\n        while(start<last)\\n        {\\n            long long mid = start + (last-start)/2;\\n\\n            if(isPossible(time,mid,totalTrips))\\n            {\\n                // if it is true then no need to search in the part which is grater than mid; so reduce the search space and check for left side if there any minimum number is possible.\\n\\n                last = mid;\\n            }\\n            else\\n            {\\n                start = mid+1;\\n            }\\n        }\\n\\n\\n        return start;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268475,
                "title": "minimum-time-to-complete-trips-using-binary-search",
                "content": "# Solution Roadmap\\n- The problem statement asks us to find the minimum time required for all buses to complete at least totalTrips trips. Since each bus can make multiple trips successively, we can assume that the trips of one bus do not influence the trips of any other bus. Therefore, we can focus on finding the minimum time required for a single bus to complete at least totalTrips trips, and then multiply that time by the number of buses we have.\\n- One way to find the minimum time required for a single bus to complete at least totalTrips trips is to use binary search. We can start by sorting the time array in increasing order, and then use binary search to search for the minimum time.\\n- In each iteration of the binary search, we calculate the mid time and count the number of trips that can be completed in mid time. We do this by dividing the mid time by the time taken by each bus, and summing up the results. If the number of trips is greater than or equal to totalTrips, we adjust the search range to the left; otherwise, we adjust the search range to the right.\\n- Once we find the minimum time required for a single bus to complete at least totalTrips trips, we can multiply that time by the number of buses we have to get the minimum time required for all buses to complete at least totalTrips trips.\\n- The time complexity of the solution is O(n log T), where n is the length of the time array and T is the maximum time taken by a bus to complete one trip. The space complexity of the solution is O(1), as we only use a constant amount of extra space to store the variables.\\n- Finally, we can implement the solution in Python by defining a Solution class with a minimumTime method that takes an array of times and the total number of trips as input, and returns the minimum time required for all buses to complete at least totalTrips trips. We can then create an instance of the Solution class and call its minimumTime method with the input parameters.\\n\\n# Code (Python Program)\\n```\\nclass Solution(object):\\n    def minimumTime(self, time, totalTrips):\\n        \"\"\"\\n        :type time: List[int]\\n        :type totalTrips: int\\n        :rtype: int\\n        \"\"\"\\n        # Sort the time array in increasing order\\n        time.sort()\\n        \\n        # Initialize the variables\\n        n = len(time)\\n        l = 0\\n        r = time[n-1] * totalTrips\\n        \\n        # Binary search for the minimum time\\n        while l < r:\\n            mid = (l + r) // 2\\n            trips = 0\\n            \\n            # Count the number of trips that can be completed in mid time\\n            for i in range(n):\\n                trips += (mid // time[i])\\n                if trips >= totalTrips:\\n                    break\\n            \\n            # Adjust the search range\\n            if trips >= totalTrips:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        \\n        # Return the minimum time\\n        return l\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumTime(self, time, totalTrips):\\n        \"\"\"\\n        :type time: List[int]\\n        :type totalTrips: int\\n        :rtype: int\\n        \"\"\"\\n        # Sort the time array in increasing order\\n        time.sort()\\n        \\n        # Initialize the variables\\n        n = len(time)\\n        l = 0\\n        r = time[n-1] * totalTrips\\n        \\n        # Binary search for the minimum time\\n        while l < r:\\n            mid = (l + r) // 2\\n            trips = 0\\n            \\n            # Count the number of trips that can be completed in mid time\\n            for i in range(n):\\n                trips += (mid // time[i])\\n                if trips >= totalTrips:\\n                    break\\n            \\n            # Adjust the search range\\n            if trips >= totalTrips:\\n                r = mid\\n            else:\\n                l = mid + 1\\n        \\n        # Return the minimum time\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268194,
                "title": "explanation-of-each-line-of-code-in-binary-search-best-and-easy-solution-using-c",
                "content": "# Intuition\\nchecking possible time to complete totaltrips in binary search function:\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*log(n))\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& t, int ttl) {\\n        if(t.size() == 1){\\n            return (long long)t[0] * ttl; //result will total time to complete totaltrip by bus 0\\n        }\\n        sort(t.begin(),t.end());\\n        long long s = 0;\\n        int n = t.size();\\n        long long e = (long long)t[n-1]*ttl;  // max time taken will be the bus with maximum time \\n        long long res  = e;\\n        while(s<=e){\\n            long long mid = s+(e-s)/2;\\n            long long ans = 0;\\n            for(int i  = 0;i<t.size();i++){\\n                ans += (long long)(mid/t[i]); //checking each bus that how much trips does i^th bus take in mid time\\n            }\\n            if(ans>=ttl){\\n                res = mid;\\n                e = mid-1;\\n            }else{\\n                s = mid+1;\\n            }\\n        }        \\n        return res;\\n    }\\n};\\n\\n\\n```\\n\\n\\n![025a6e75-7e39-4bdd-8ecd-ea9c6023729a_1672712882.8563874.png](https://assets.leetcode.com/users/images/1a527f43-ae41-4ef2-b067-db7c8c564f33_1678184344.4992063.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& t, int ttl) {\\n        if(t.size() == 1){\\n            return (long long)t[0] * ttl; //result will total time to complete totaltrip by bus 0\\n        }\\n        sort(t.begin(),t.end());\\n        long long s = 0;\\n        int n = t.size();\\n        long long e = (long long)t[n-1]*ttl;  // max time taken will be the bus with maximum time \\n        long long res  = e;\\n        while(s<=e){\\n            long long mid = s+(e-s)/2;\\n            long long ans = 0;\\n            for(int i  = 0;i<t.size();i++){\\n                ans += (long long)(mid/t[i]); //checking each bus that how much trips does i^th bus take in mid time\\n            }\\n            if(ans>=ttl){\\n                res = mid;\\n                e = mid-1;\\n            }else{\\n                s = mid+1;\\n            }\\n        }        \\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268189,
                "title": "golang-binarysearch",
                "content": "# Code\\n```\\nfunc minimumTime(time []int, totalTrips int) int64 {\\n    maxTime := 0\\n    for i := 0; i < len(time); i++ {\\n        if time[i] > maxTime {\\n            maxTime = time[i]\\n        }\\n    }\\n\\n    left, right := 1, maxTime * totalTrips\\n    for left < right {\\n        mid := (left+right)/2\\n        if isTimeEnough(time, mid, totalTrips) {\\n            right = mid\\n        } else {\\n            left = mid+1\\n        }\\n    }\\n\\n    return int64(left)\\n}\\n\\nfunc isTimeEnough(time []int, pivot, totalTrips int) bool {\\n    count := 0\\n    for i := 0; i < len(time); i++ {\\n        count += pivot / time[i]\\n    }\\n    \\n    return count >= totalTrips\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minimumTime(time []int, totalTrips int) int64 {\\n    maxTime := 0\\n    for i := 0; i < len(time); i++ {\\n        if time[i] > maxTime {\\n            maxTime = time[i]\\n        }\\n    }\\n\\n    left, right := 1, maxTime * totalTrips\\n    for left < right {\\n        mid := (left+right)/2\\n        if isTimeEnough(time, mid, totalTrips) {\\n            right = mid\\n        } else {\\n            left = mid+1\\n        }\\n    }\\n\\n    return int64(left)\\n}\\n\\nfunc isTimeEnough(time []int, pivot, totalTrips int) bool {\\n    count := 0\\n    for i := 0; i < len(time); i++ {\\n        count += pivot / time[i]\\n    }\\n    \\n    return count >= totalTrips\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3268053,
                "title": "c-binary-search",
                "content": "# Approach\\nUse binary search to find lowest number of trips.\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public long MinimumTime(int[] time, int totalTrips)\\n    {\\n        var left = 1L;\\n        var right = long.MaxValue;\\n\\n        while (left < right)\\n        {\\n            var mid = left + (right - left) / 2;\\n\\n            var trips = 0L;\\n            \\n            foreach (var t in time)\\n            {\\n                trips += mid / t;\\n                if (trips >= totalTrips)\\n                {\\n                    // To avoid sum overflow\\n                    break;\\n                }\\n            }\\n\\n            if (trips >= totalTrips)\\n            {\\n                right = mid;\\n            }\\n            else\\n            {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public long MinimumTime(int[] time, int totalTrips)\\n    {\\n        var left = 1L;\\n        var right = long.MaxValue;\\n\\n        while (left < right)\\n        {\\n            var mid = left + (right - left) / 2;\\n\\n            var trips = 0L;\\n            \\n            foreach (var t in time)\\n            {\\n                trips += mid / t;\\n                if (trips >= totalTrips)\\n                {\\n                    // To avoid sum overflow\\n                    break;\\n                }\\n            }\\n\\n            if (trips >= totalTrips)\\n            {\\n                right = mid;\\n            }\\n            else\\n            {\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268011,
                "title": "range-bs-very-easy-to-understand-must-see",
                "content": "# Code\\n```\\n//for fast input and output\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\n//code begins here\\nclass Solution \\n{\\npublic:\\n    long long minimumTime(vector<int>& arr, int totalTrips) \\n    {\\n         long long int minele = *min_element(arr.begin(),arr.end());\\n\\n         long long int left = 0;\\n         long long int right = 1LL*minele * totalTrips;\\n          \\n         long long int ans = LONG_MAX;\\n         while(left <= right)\\n         {\\n             long long int Tmid = (1LL*left) + ((right - left)/2); \\n             \\n             //checking how many trips can be completed at time = Tmid\\n             long long int trip_count = fun(arr,Tmid);\\n\\n             if(trip_count < totalTrips)\\n             {\\n                 left = Tmid+1;\\n             }\\n             else if(trip_count > totalTrips)\\n             {\\n                if(Tmid < ans) ans = Tmid;\\n                right = Tmid-1;\\n             }\\n             else if(trip_count == totalTrips)\\n             {\\n                if(Tmid < ans) ans = Tmid;\\n                right = Tmid-1;\\n             }\\n         }\\n         return ans;\\n    }\\n    long long int fun(vector<int>&arr,long long int time)\\n    {\\n        long long int count = 0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            long long int temp = (time/arr[i]);\\n            count = count + temp;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n//for fast input and output\\nstatic int fast_io = []() \\n{ \\n    std::ios::sync_with_stdio(false); \\n    cin.tie(nullptr); \\n    cout.tie(nullptr); \\n    return 0; \\n}();\\n\\n#ifdef LOCAL\\n    freopen(\"input.txt\", \"r\" , stdin);\\n    freopen(\"output.txt\", \"w\", stdout);\\n#endif\\n\\n//code begins here\\nclass Solution \\n{\\npublic:\\n    long long minimumTime(vector<int>& arr, int totalTrips) \\n    {\\n         long long int minele = *min_element(arr.begin(),arr.end());\\n\\n         long long int left = 0;\\n         long long int right = 1LL*minele * totalTrips;\\n          \\n         long long int ans = LONG_MAX;\\n         while(left <= right)\\n         {\\n             long long int Tmid = (1LL*left) + ((right - left)/2); \\n             \\n             //checking how many trips can be completed at time = Tmid\\n             long long int trip_count = fun(arr,Tmid);\\n\\n             if(trip_count < totalTrips)\\n             {\\n                 left = Tmid+1;\\n             }\\n             else if(trip_count > totalTrips)\\n             {\\n                if(Tmid < ans) ans = Tmid;\\n                right = Tmid-1;\\n             }\\n             else if(trip_count == totalTrips)\\n             {\\n                if(Tmid < ans) ans = Tmid;\\n                right = Tmid-1;\\n             }\\n         }\\n         return ans;\\n    }\\n    long long int fun(vector<int>&arr,long long int time)\\n    {\\n        long long int count = 0;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            long long int temp = (time/arr[i]);\\n            count = count + temp;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3267984,
                "title": "c-code-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nc++ easy way to solve\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nc++\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n(o1)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        sort(time.begin(),time.end());\\n        long long l=0,r=1e14,ans=1e14;\\n        while(l<r){\\n          long long  mid=l+(r-l)/2;\\n           long long cnt=0;\\n           for(int i=0;i<time.size();i++){\\n               cnt+=(mid/time[i]);\\n           } \\n           if(cnt>=totalTrips){\\n               ans=mid;\\n               r=mid;\\n           }\\n           else\\n           l=mid+1;\\n\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        sort(time.begin(),time.end());\\n        long long l=0,r=1e14,ans=1e14;\\n        while(l<r){\\n          long long  mid=l+(r-l)/2;\\n           long long cnt=0;\\n           for(int i=0;i<time.size();i++){\\n               cnt+=(mid/time[i]);\\n           } \\n           if(cnt>=totalTrips){\\n               ans=mid;\\n               r=mid;\\n           }\\n           else\\n           l=mid+1;\\n\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267933,
                "title": "simple-c-solution-binary-search-upvote-if-helpful",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    bool check(vector<int>& time,ll mid,ll t){\\n        ll trips=0;\\n        for(auto &i:time){\\n            trips+=(mid/i);\\n            if(trips>=t) return true;\\n        }\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int t) {\\n        int n=time.size();\\n        sort(time.begin(),time.end());\\n        ll r=(ll)time[0];\\n        ll h=(ll)time[n-1]*(ll)t;\\n        while(r<h){\\n            ll mid=r+(h-r)/2;\\n            if(check(time,mid,t)){\\n                h=mid;\\n            }else r=mid+1;\\n        }\\n        return r;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    bool check(vector<int>& time,ll mid,ll t){\\n        ll trips=0;\\n        for(auto &i:time){\\n            trips+=(mid/i);\\n            if(trips>=t) return true;\\n        }\\n        return false;\\n    }\\n    long long minimumTime(vector<int>& time, int t) {\\n        int n=time.size();\\n        sort(time.begin(),time.end());\\n        ll r=(ll)time[0];\\n        ll h=(ll)time[n-1]*(ll)t;\\n        while(r<h){\\n            ll mid=r+(h-r)/2;\\n            if(check(time,mid,t)){\\n                h=mid;\\n            }else r=mid+1;\\n        }\\n        return r;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267865,
                "title": "video-explanation-how-to-approch-this-type-of-problem-binary-search-c",
                "content": "If you don\\'t know hind skip video and read the solution article below , Hindi Video Explanation :- https://youtu.be/YLPtZiFaVKU\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhenever we get any problem , we should find all the useful hints/ details from the problem . \\nHere looking at constraints we can find than **O(n log n)** is the **worst allowed time complexity** .\\n\\nWe can use **binary_search** to get O(n log n) solution . We need to get more strong details to used binary_search , can we bound \\'time_taken\\' ?\\nYes **minimun time** possible = 1, and **max_time_taken** = (max_value* tot_trips)  in worst case **max_vaue = 10^7** and **tot_trips = 10^7** ,\\nso **max_time_taken = 10^14** for all the test cases .\\n\\n\\nNow we can confirm that **Binary search** can be implemented.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe implemetn binary serach in range [1,10^14] ,\\nand for each **mid** value we will find the tot_trips_possible ,\\nif (tot_trips_possible >= tot_trips),\\nthen we reduce the range from [start,end] -- > [start,mid-1]\\nelse if not possible then we change from [start,end] -- > [mid+1,end]\\ncomputer the **mid = (start+end)/2**  again and continue.\\nUntil our binary seearch continue and update the answer too.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Why I was not able to understand this is binary search\\n    \\n    long long minimumTime(vector<int>& A, int tot_trip) {\\n        long long ans = 1e18;\\n        \\n        //upper bound in worst case is max_value*tot_trip , tot_trip can be upto 10^7 and max_value = 10^7 \\n        //so 10^14 in worst case .  \\n         \\n        \\n        long long start = 1,end = 1e14,mid = (start+end)/2;\\n         \\n        \\n        while(start<=end){\\n            \\n            long long current_trip = 0;\\n\\n            for(auto&x:A){\\n                current_trip +=(mid/x);\\n                \\n                //if current number of trips in time \\'mid\\' is greater\\n                //than equal to required total_trip we go out of loop as we have achieved total trip\\n                if(current_trip >= tot_trip){\\n                    break;\\n                }\\n            }\\n            if(current_trip >= tot_trip){\\n                end = mid-1;\\n                ans = min(ans,mid);\\n                mid = (start+end)/2;\\n            }\\n            else{\\n                start = mid+1;\\n                mid = (start+end)/2;\\n            }\\n        }\\n        return ans;\\n    }\\n} ;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Why I was not able to understand this is binary search\\n    \\n    long long minimumTime(vector<int>& A, int tot_trip) {\\n        long long ans = 1e18;\\n        \\n        //upper bound in worst case is max_value*tot_trip , tot_trip can be upto 10^7 and max_value = 10^7 \\n        //so 10^14 in worst case .  \\n         \\n        \\n        long long start = 1,end = 1e14,mid = (start+end)/2;\\n         \\n        \\n        while(start<=end){\\n            \\n            long long current_trip = 0;\\n\\n            for(auto&x:A){\\n                current_trip +=(mid/x);\\n                \\n                //if current number of trips in time \\'mid\\' is greater\\n                //than equal to required total_trip we go out of loop as we have achieved total trip\\n                if(current_trip >= tot_trip){\\n                    break;\\n                }\\n            }\\n            if(current_trip >= tot_trip){\\n                end = mid-1;\\n                ans = min(ans,mid);\\n                mid = (start+end)/2;\\n            }\\n            else{\\n                start = mid+1;\\n                mid = (start+end)/2;\\n            }\\n        }\\n        return ans;\\n    }\\n} ;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267770,
                "title": "c-simplest-solution-binary-search-beats-90",
                "content": "# Intuition\\n**Binary Search from min value of time to min value of time * totalTrips**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n**Binary Search**\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, long long totalTrips) {\\n        long long low = *min_element(begin(time), end(time));\\n        long long high = low * totalTrips;\\n        long long mid, currTrips;\\n        while (low <= high) {\\n            mid = (low + high) >> 1;\\n            currTrips = 0;\\n            for (auto &it: time) currTrips += (mid / it);\\n            if (currTrips == totalTrips) high = mid-1;\\n\\n            if (currTrips > totalTrips) high = mid - 1;\\n\\n            if (currTrips < totalTrips) low = mid + 1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, long long totalTrips) {\\n        long long low = *min_element(begin(time), end(time));\\n        long long high = low * totalTrips;\\n        long long mid, currTrips;\\n        while (low <= high) {\\n            mid = (low + high) >> 1;\\n            currTrips = 0;\\n            for (auto &it: time) currTrips += (mid / it);\\n            if (currTrips == totalTrips) high = mid-1;\\n\\n            if (currTrips > totalTrips) high = mid - 1;\\n\\n            if (currTrips < totalTrips) low = mid + 1;\\n        }\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267703,
                "title": "binary-search-c-easy",
                "content": "```\\nclass Solution {\\n    bool canComplete(vector<int>& time, int totalTrips, long long days) {\\n        long long n = size(time), trips = 0;\\n        for(int i = 0; i < n; i++) {\\n            \\n            trips += days/(time[i]*1LL);\\n        }\\n        \\n        return trips >= totalTrips;\\n    }\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        \\n        long long low = 1, high = 1LL * (*min_element(begin(time), end(time))) *  totalTrips, mid;\\n        \\n        while(low < high) {\\n            mid = low + (high - low) / 2LL;\\n            \\n            if(canComplete(time,totalTrips,mid))high = mid;\\n            else low = mid+1;\\n        }\\n        \\n        return low;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    bool canComplete(vector<int>& time, int totalTrips, long long days) {\\n        long long n = size(time), trips = 0;\\n        for(int i = 0; i < n; i++) {\\n            \\n            trips += days/(time[i]*1LL);\\n        }\\n        \\n        return trips >= totalTrips;\\n    }\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        \\n        long long low = 1, high = 1LL * (*min_element(begin(time), end(time))) *  totalTrips, mid;\\n        \\n        while(low < high) {\\n            mid = low + (high - low) / 2LL;\\n            \\n            if(canComplete(time,totalTrips,mid))high = mid;\\n            else low = mid+1;\\n        }\\n        \\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267685,
                "title": "python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        left = 1\\n        right = max(time) * totalTrips\\n\\n        while right > left:\\n            mid = (left + right)//2\\n            sums = sum([mid//t for t in time])\\n            if sums >= totalTrips:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        return left   \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        left = 1\\n        right = max(time) * totalTrips\\n\\n        while right > left:\\n            mid = (left + right)//2\\n            sums = sum([mid//t for t in time])\\n            if sums >= totalTrips:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        \\n        return left   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267572,
                "title": "binary-search-small-and-clear-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBinary search on answer (time).bin\\n\\n# Complexity\\n- Time complexity: O(N log(N))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&time, int trips, long long timeAvl){\\n        unsigned long long count=0;\\n        for(int i=0;i<time.size();i++){\\n            count+= (timeAvl/time[i]);\\n        }\\n        if(count>=trips) return true;\\n        else return false;\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long low=1;\\n        long long high=*max_element(time.begin(),time.end())*1LL*totalTrips;\\n\\n        while(low<=high){\\n            long long mid= low+(high-low)/2;\\n            if(check(time,totalTrips,mid)) high=mid-1;\\n            else low=mid+1;\\n        }\\n        return low;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>&time, int trips, long long timeAvl){\\n        unsigned long long count=0;\\n        for(int i=0;i<time.size();i++){\\n            count+= (timeAvl/time[i]);\\n        }\\n        if(count>=trips) return true;\\n        else return false;\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long low=1;\\n        long long high=*max_element(time.begin(),time.end())*1LL*totalTrips;\\n\\n        while(low<=high){\\n            long long mid= low+(high-low)/2;\\n            if(check(time,totalTrips,mid)) high=mid-1;\\n            else low=mid+1;\\n        }\\n        return low;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267496,
                "title": "simple-python-solution-47-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        if totalTrips <= 0:\\n            return 0\\n        left, right = min(time), max(time) * totalTrips\\n        ans = right\\n        while left < right:\\n            mid = (left + right) //2\\n            trips = 0\\n            for t in time:\\n                trips += mid // t\\n            if trips >= totalTrips:\\n                ans = min(ans, mid)\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left                  \\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        if totalTrips <= 0:\\n            return 0\\n        left, right = min(time), max(time) * totalTrips\\n        ans = right\\n        while left < right:\\n            mid = (left + right) //2\\n            trips = 0\\n            for t in time:\\n                trips += mid // t\\n            if trips >= totalTrips:\\n                ans = min(ans, mid)\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left                  \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267486,
                "title": "kotlin-binary-search",
                "content": "#### Join me on telergam\\nhttps://t.me/leetcode_daily_unstoppable/140\\n#### Intuition\\nNaive approach is just to simulate the `time` running, but given the problem range it is not possible.\\nHowever, observing the `time` simulation results, we can notice, that by each `given time` there is a certain `number of trips`. And `number of trips` growths continuously with the growth of the `time`. This is a perfect condition to do a binary search in a space of the `given time`. \\nWith `given time` we can calculate number of trips in a $$O(n)$$ complexity.\\n\\n#### Approach\\nDo a binary search. For the `hi` value, we can peak a $$10^7$$ or just compute all the time it takes for every bus to trip.\\nFor a more robust binary search:\\n* use inclusive `lo` and `hi`\\n* use inclusive check for the last case `lo == hi`\\n* compute the result on every step instead of computing it after the search\\n* always move the borders `mid + 1`, `mid - 1`\\n\\n#### Complexity\\n- Time complexity:\\n$$O(nlog_2(m))$$, $$m$$ - is a time range\\n- Space complexity:\\n$$O(1)$$\\n#### Code\\n```\\n    fun minimumTime(time: IntArray, totalTrips: Int): Long {\\n        fun tripCount(timeGiven: Long): Long {\\n            var count = 0L\\n            for (t in time) count += timeGiven / t.toLong()\\n            return count\\n        }\\n        var lo = 0L\\n        var hi = time.asSequence().map { it.toLong() * totalTrips }.max()!!\\n        var minTime = hi\\n        while (lo <= hi) {\\n            val timeGiven = lo + (hi - lo) / 2\\n            val trips = tripCount(timeGiven)\\n            if (trips >= totalTrips) {\\n                minTime = minOf(minTime, timeGiven)\\n                hi = timeGiven - 1\\n            } else {\\n                lo = timeGiven + 1\\n            }\\n        }\\n        return minTime\\n    }\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Search"
                ],
                "code": "```\\n    fun minimumTime(time: IntArray, totalTrips: Int): Long {\\n        fun tripCount(timeGiven: Long): Long {\\n            var count = 0L\\n            for (t in time) count += timeGiven / t.toLong()\\n            return count\\n        }\\n        var lo = 0L\\n        var hi = time.asSequence().map { it.toLong() * totalTrips }.max()!!\\n        var minTime = hi\\n        while (lo <= hi) {\\n            val timeGiven = lo + (hi - lo) / 2\\n            val trips = tripCount(timeGiven)\\n            if (trips >= totalTrips) {\\n                minTime = minOf(minTime, timeGiven)\\n                hi = timeGiven - 1\\n            } else {\\n                lo = timeGiven + 1\\n            }\\n        }\\n        return minTime\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3267361,
                "title": "simple-and-optimised-javascript-solution-beats-100",
                "content": "# Approach\\nTo solve this problem, we use binary search on the minimum time needed to complete all trips. We start by calculating a minimum value of 1 and a maximum value of 1e18, then loop until the minimum time is less than or equal to the maximum time. At each iteration, we calculate the mid-point of the search range and check how many trips can be completed by all buses in that time. If the number of completed trips is greater than or equal to the total number of trips, we search left; otherwise, we search right. We continue this process until both numbers are equal. The time complexity is O(n log t), where n is the number of buses and t is their maximum times; and space complexity is O(1).\\n\\n# Code\\n```\\nfunction minimumTime(time, totalTrips) {\\n  let left = 1; // minimum time needed to complete all trips\\n  let right = 1e18; // maximum time (for practical purposes)\\n  while (left < right) {\\n    const mid = Math.floor((left + right) / 2); // mid-point of the search range\\n    let tripsCompleted = 0;\\n    for (let i = 0; i < time.length && tripsCompleted < totalTrips; i++) {\\n      tripsCompleted += Math.floor(mid / time[i]); // number of trips completed by this bus in mid time\\n    }\\n    if (tripsCompleted >= totalTrips) {\\n      right = mid; // search the left half of the range\\n    } else {\\n      left = mid + 1; // search the right half of the range\\n    }\\n  }\\n  return left;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nfunction minimumTime(time, totalTrips) {\\n  let left = 1; // minimum time needed to complete all trips\\n  let right = 1e18; // maximum time (for practical purposes)\\n  while (left < right) {\\n    const mid = Math.floor((left + right) / 2); // mid-point of the search range\\n    let tripsCompleted = 0;\\n    for (let i = 0; i < time.length && tripsCompleted < totalTrips; i++) {\\n      tripsCompleted += Math.floor(mid / time[i]); // number of trips completed by this bus in mid time\\n    }\\n    if (tripsCompleted >= totalTrips) {\\n      right = mid; // search the left half of the range\\n    } else {\\n      left = mid + 1; // search the right half of the range\\n    }\\n  }\\n  return left;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3267325,
                "title": "c-solution-commented-fully-binary-search",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(log N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long h=INT_MAX, l=0; // h = end(high) time limit and l= start(low) time limit\\n        for(int i=0;i<time.size();i++)\\n        {\\n            if(time[i]<h){\\n                h=time[i];  // give the time of the fastest bus or the min. time\\n            }\\n        }\\n        h=totalTrips*h; // time taken by the fastest bus to complete all the trips individually\\n        while(l<=h){\\n            // cout<<l<<\" \"<<h<<endl;\\n            long long midTime=l+(h-l)/2;  //min time that may be possbile\\n            long long curTrips=0;  // no. of total trips that could be done by all the buses cumulative within the midTime \\n            for(int j=0;j<time.size();j++)\\n            {\\n                curTrips+=(midTime/time[j]);  \\n            }\\n            if(curTrips>=totalTrips){  // if total trip within midTime > totaltrips => midTime is more than the actual time so decreasing the end-time limit\\n                h=midTime-1;\\n            }else {\\n                l=midTime+1; //else increasing the start-time limit\\n            }\\n        }\\n        return l;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long h=INT_MAX, l=0; // h = end(high) time limit and l= start(low) time limit\\n        for(int i=0;i<time.size();i++)\\n        {\\n            if(time[i]<h){\\n                h=time[i];  // give the time of the fastest bus or the min. time\\n            }\\n        }\\n        h=totalTrips*h; // time taken by the fastest bus to complete all the trips individually\\n        while(l<=h){\\n            // cout<<l<<\" \"<<h<<endl;\\n            long long midTime=l+(h-l)/2;  //min time that may be possbile\\n            long long curTrips=0;  // no. of total trips that could be done by all the buses cumulative within the midTime \\n            for(int j=0;j<time.size();j++)\\n            {\\n                curTrips+=(midTime/time[j]);  \\n            }\\n            if(curTrips>=totalTrips){  // if total trip within midTime > totaltrips => midTime is more than the actual time so decreasing the end-time limit\\n                h=midTime-1;\\n            }else {\\n                l=midTime+1; //else increasing the start-time limit\\n            }\\n        }\\n        return l;  \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3267274,
                "title": "simple-binary-search-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n         long ans=-1;\\n          long left=1, right= 1+1e14;          \\n\\t\\t\\n        while(left<=right){\\n             long mid= left+ (right-left)/2;  \\n            long long trips=0;\\n            for(int i=0;i<time.size();i++){\\n                trips+= mid/time[i];\\n            }\\n            \\n            if(trips>=totalTrips){ \\n                ans=mid;\\n                right=mid-1;\\n            }\\n            \\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n         long ans=-1;\\n          long left=1, right= 1+1e14;          \\n\\t\\t\\n        while(left<=right){\\n             long mid= left+ (right-left)/2;  \\n            long long trips=0;\\n            for(int i=0;i<time.size();i++){\\n                trips+= mid/time[i];\\n            }\\n            \\n            if(trips>=totalTrips){ \\n                ans=mid;\\n                right=mid-1;\\n            }\\n            \\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267245,
                "title": "java-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lo = 0, hi = 100_000_000_000_000L;\\n        while (lo < hi) {\\n            long need = lo + (hi - lo) / 2;\\n            long trips = 0;\\n            for (int t : time) {\\n                trips += need / t;\\n            }\\n            if (trips < totalTrips) {\\n                lo = need + 1;\\n            }else {\\n                hi = need;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long lo = 0, hi = 100_000_000_000_000L;\\n        while (lo < hi) {\\n            long need = lo + (hi - lo) / 2;\\n            long trips = 0;\\n            for (int t : time) {\\n                trips += need / t;\\n            }\\n            if (trips < totalTrips) {\\n                lo = need + 1;\\n            }else {\\n                hi = need;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267243,
                "title": "python3-binary-search-o-nlogn-time-complexity",
                "content": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        low = 1\\n        high = min(time) * totalTrips\\n        def helper(curr):\\n            trips = 0 \\n            for t in time:\\n                trips += (curr // t)\\n                if trips >= totalTrips:\\n                    return True\\n            return False\\n        \\n        ans = high\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if helper(mid):\\n                ans = mid \\n                high = mid - 1 \\n            else:\\n                low = mid + 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        low = 1\\n        high = min(time) * totalTrips\\n        def helper(curr):\\n            trips = 0 \\n            for t in time:\\n                trips += (curr // t)\\n                if trips >= totalTrips:\\n                    return True\\n            return False\\n        \\n        ans = high\\n        while low <= high:\\n            mid = (low + high) // 2\\n            if helper(mid):\\n                ans = mid \\n                high = mid - 1 \\n            else:\\n                low = mid + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267027,
                "title": "typescript-binary-search",
                "content": "```\\nfunction minimumTime(time: number[], totalTrips: number): number {\\n  // t is in [1, 10 ** 14]\\n  let left = 1;\\n  let right = 10 ** 14;\\n\\n  while (left <= right) {\\n    // using binary search to guess a t\\n    let mid = left + Math.floor((right - left) / 2);\\n    // how many trips we could finish\\n    let total = 0;\\n    for (var t of time) {\\n      total += Math.floor(mid / t);\\n    }\\n    // not enough, guess a larger t in next round\\n    if (total < totalTrips) {\\n      left = mid + 1;\\n    } else {\\n      // to find the smallest t\\n      right = mid -1;\\n    }\\n  }\\n\\n  return left;\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minimumTime(time: number[], totalTrips: number): number {\\n  // t is in [1, 10 ** 14]\\n  let left = 1;\\n  let right = 10 ** 14;\\n\\n  while (left <= right) {\\n    // using binary search to guess a t\\n    let mid = left + Math.floor((right - left) / 2);\\n    // how many trips we could finish\\n    let total = 0;\\n    for (var t of time) {\\n      total += Math.floor(mid / t);\\n    }\\n    // not enough, guess a larger t in next round\\n    if (total < totalTrips) {\\n      left = mid + 1;\\n    } else {\\n      // to find the smallest t\\n      right = mid -1;\\n    }\\n  }\\n\\n  return left;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3267005,
                "title": "c-binary-search-explained-c-code-easy-to-understand",
                "content": "### I Kept code very consise and very clean with proper comment. Once read the Code You will understand the logic. \\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int n=time.size();\\n        sort(time.begin(),time.end()); // Just did for my end variable \\n        long long st=1;  // start_time\\n        long long end=(long long)totalTrips*(long long)time[0];  //end_time\\n        long long mini=end;  // i will store here the minimum time\\n     \\n        //BINARY SEARCH\\n        while(st<=end){\\n             long long mid= st + (end-st)/2;\\n             long long trips_took=0;          // AT mid time, How much trips has been travelled \\n            for( long long i=0;i<n;i++){\\n                trips_took+=(mid/time[i]);\\n            }\\n            // if it is less then we should increase time so Start is shifted to mid + 1\\n            if(trips_took<totalTrips){         \\n                st=mid+1;\\n            }\\n            //ELse end is shifted to mid -1 to get minimum time\\n            else{\\n                if(mini>=mid){\\n                    mini=mid;\\n                }\\n                end=mid-1; \\n            }\\n            \\n        }\\n        return mini;\\n        return 0;\\n        \\n        \\n    }\\n};\\n\\n```\\n\\n### If it helped do upvote.",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int n=time.size();\\n        sort(time.begin(),time.end()); // Just did for my end variable \\n        long long st=1;  // start_time\\n        long long end=(long long)totalTrips*(long long)time[0];  //end_time\\n        long long mini=end;  // i will store here the minimum time\\n     \\n        //BINARY SEARCH\\n        while(st<=end){\\n             long long mid= st + (end-st)/2;\\n             long long trips_took=0;          // AT mid time, How much trips has been travelled \\n            for( long long i=0;i<n;i++){\\n                trips_took+=(mid/time[i]);\\n            }\\n            // if it is less then we should increase time so Start is shifted to mid + 1\\n            if(trips_took<totalTrips){         \\n                st=mid+1;\\n            }\\n            //ELse end is shifted to mid -1 to get minimum time\\n            else{\\n                if(mini>=mid){\\n                    mini=mid;\\n                }\\n                end=mid-1; \\n            }\\n            \\n        }\\n        return mini;\\n        return 0;\\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267004,
                "title": "ruby-binary-search-solution",
                "content": "```\\ndef minimum_time(time, total_trips)\\n  left, right = 0, total_trips*time[0]\\n  while left < right\\n    mid = (left + right) / 2\\n    trips = time.sum{|t| mid/t}\\n    if trips >= total_trips\\n      right = mid\\n    else\\n      left = mid + 1\\n    end\\n  end\\n  left\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef minimum_time(time, total_trips)\\n  left, right = 0, total_trips*time[0]\\n  while left < right\\n    mid = (left + right) / 2\\n    trips = time.sum{|t| mid/t}\\n    if trips >= total_trips\\n      right = mid\\n    else\\n      left = mid + 1\\n    end\\n  end\\n  left\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3266998,
                "title": "java-simple-binary-search",
                "content": "Min Time will be 1 sec and Max will be 10^7 * totalTrips.\\nWhy 10^7? Because according to constarints max of time[] can be 10^7.\\n# Code\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n       int n = time.length;\\n  //     Arrays.sort(time);\\n       long low = 1,  high = (long)Math.pow(10,7)*totalTrips;\\n       System.out.println(high);\\n       long ans = 0;\\n       while(low <= high){\\n           long mid = low + (high - low)/2;\\n           if(isPossible(time, totalTrips,mid)){\\n               ans = mid;\\n               high = mid - 1;\\n           }\\n           else{\\n               low = mid+1;\\n           }\\n       }\\n       return ans;\\n    }\\n    private boolean isPossible(int[] arr, int trips, long mid){\\n        long poss = 0;\\n        for(int x : arr){\\n           poss += mid/x;\\n        }\\n        if(poss >= trips) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n       int n = time.length;\\n  //     Arrays.sort(time);\\n       long low = 1,  high = (long)Math.pow(10,7)*totalTrips;\\n       System.out.println(high);\\n       long ans = 0;\\n       while(low <= high){\\n           long mid = low + (high - low)/2;\\n           if(isPossible(time, totalTrips,mid)){\\n               ans = mid;\\n               high = mid - 1;\\n           }\\n           else{\\n               low = mid+1;\\n           }\\n       }\\n       return ans;\\n    }\\n    private boolean isPossible(int[] arr, int trips, long mid){\\n        long poss = 0;\\n        for(int x : arr){\\n           poss += mid/x;\\n        }\\n        if(poss >= trips) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266978,
                "title": "python-short-and-clean-binary-search",
                "content": "# Approach\\nNotice that the time needed can never be greater than `min(time) * total_trips`.\\nLeveraging this, binary search for `min_time` in the range `[0, min(time) * total_trips]`\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n * k))$$\\n\\n- Space complexity: $$O(1)$$\\n\\nwhere,\\n`n is length of time`,\\n`k is total_trips`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def minimumTime(self, time: list[int], total_trips: int) -> int:\\n        l, r = 0, min(time) * total_trips\\n        while l <= r:\\n            m = (l + r) // 2\\n            trips = sum(m // t for t in time)\\n            l, r = (l, m - 1) if trips >= total_trips else (m + 1, r)\\n        return l\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumTime(self, time: list[int], total_trips: int) -> int:\\n        l, r = 0, min(time) * total_trips\\n        while l <= r:\\n            m = (l + r) // 2\\n            trips = sum(m // t for t in time)\\n            l, r = (l, m - 1) if trips >= total_trips else (m + 1, r)\\n        return l\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266945,
                "title": "java-with-beginner-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        //range based binary search\\n        //the start we will make the minimum value possible\\n        long s = 1;\\n        //end we will make the max time possible \\n        //which will be the time required by minimum speed bus to complete n no. of trips   \\n        long min = time[0];\\n        for(int i = 0;i < time.length;i++){\\n            min = Math.min(min, time[i]);\\n        }\\n        long e = min * totalTrips;\\n        //so we know that our answer will lye btw the start s and end e\\n        while(s < e){\\n            long m = s + (e - s) / 2;\\n            //now check how many trips can be completed in this m amount of time\\n            long trips = 0;\\n            for(int i = 0;i < time.length;i++){\\n                trips += m / time[i];\\n            }\\n            if(trips < totalTrips){\\n                //we have to move the start pointer\\n                //since our trips is not enough\\n                s = m + 1;\\n            }else{\\n                //we have to move our end point\\n                e = m;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        //range based binary search\\n        //the start we will make the minimum value possible\\n        long s = 1;\\n        //end we will make the max time possible \\n        //which will be the time required by minimum speed bus to complete n no. of trips   \\n        long min = time[0];\\n        for(int i = 0;i < time.length;i++){\\n            min = Math.min(min, time[i]);\\n        }\\n        long e = min * totalTrips;\\n        //so we know that our answer will lye btw the start s and end e\\n        while(s < e){\\n            long m = s + (e - s) / 2;\\n            //now check how many trips can be completed in this m amount of time\\n            long trips = 0;\\n            for(int i = 0;i < time.length;i++){\\n                trips += m / time[i];\\n            }\\n            if(trips < totalTrips){\\n                //we have to move the start pointer\\n                //since our trips is not enough\\n                s = m + 1;\\n            }else{\\n                //we have to move our end point\\n                e = m;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266870,
                "title": "java-solution-using-binary-search",
                "content": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n      long lo = 0, hi = 100000000000000L;\\n      while(lo<hi){\\n         long req=(lo+hi)/2;\\n         long trips = 0;\\n         for (int t : time) {\\n            trips += req / t;\\n            }\\n          if (trips < totalTrips) {\\n                lo = req + 1;\\n            }else {\\n                hi = req;\\n            }\\n        }\\n        return lo;\\n      }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n      long lo = 0, hi = 100000000000000L;\\n      while(lo<hi){\\n         long req=(lo+hi)/2;\\n         long trips = 0;\\n         for (int t : time) {\\n            trips += req / t;\\n            }\\n          if (trips < totalTrips) {\\n                lo = req + 1;\\n            }else {\\n                hi = req;\\n            }\\n        }\\n        return lo;\\n      }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266858,
                "title": "straight-forward-binary-search-solution-in-c-predicate-function-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to minimize the time to complete totalTrips, this gives an intutition that binary search can be applied. The problem will be having a predicate function with respect to time taken like this\\n\\nF F F F ... F F T T T ... T T\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all find the range in which the time can vary. So, the total time required will have a minimum value equal to the minimum value in the array and we can take a safe maximum value equal to the sum of the elements of the array multiply by the totalTrips.\\n\\n# Complexity\\n- Time complexity: O(log(sum*totalTrips))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool canComplete(long long t, int totalTrips, vector<int> &time){\\n\\n        long long trips = 0;\\n        for(long long i = 0;i<time.size();i++){\\n            trips += (t/time[i]);\\n            if(trips >= totalTrips){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n\\n        long long sum = 0;\\n        for(auto v : time){\\n            sum += v;\\n        }\\n\\n        long long lo =  *min_element(time.begin(), time.end());\\n        long long hi = sum * totalTrips;\\n        long long mid;\\n\\n        while(lo < hi){\\n            mid = lo + (hi-lo)/2;\\n            if(canComplete(mid,totalTrips,time)){\\n                hi = mid;\\n            }\\n            else{\\n                lo = mid+1;\\n            }\\n        }\\n\\n        return lo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool canComplete(long long t, int totalTrips, vector<int> &time){\\n\\n        long long trips = 0;\\n        for(long long i = 0;i<time.size();i++){\\n            trips += (t/time[i]);\\n            if(trips >= totalTrips){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n\\n        long long sum = 0;\\n        for(auto v : time){\\n            sum += v;\\n        }\\n\\n        long long lo =  *min_element(time.begin(), time.end());\\n        long long hi = sum * totalTrips;\\n        long long mid;\\n\\n        while(lo < hi){\\n            mid = lo + (hi-lo)/2;\\n            if(canComplete(mid,totalTrips,time)){\\n                hi = mid;\\n            }\\n            else{\\n                lo = mid+1;\\n            }\\n        }\\n\\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266846,
                "title": "c-binary-search-clean-code-easy-to-understandbi",
                "content": "\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$ \\n<!-- Add your time complexity here, e.g. $$O(nlogn)$$ -->\\n\\n- Space complexity:$$O(1)$$ \\n<!-- Add your space complexity here, e.g. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(long long int mid, vector<int>&a, int k){\\n        long long int total = 0;\\n        for(int i=0;i<a.size();i++){\\n            total+=(mid/a[i]);\\n        }\\n        return total>=k;\\n    }\\n    long long minimumTime(vector<int>& time, int k) {\\n        int n = time.size();\\n        if(n==1){\\n            return (long long int)k*time[0];\\n        }\\n        long long int low = 0;\\n        long long int high = 1e12;\\n        while(low<high){\\n            long long int mid = low + (high - low)/2;\\n            if(check(mid,time,k)){\\n                high = mid;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(long long int mid, vector<int>&a, int k){\\n        long long int total = 0;\\n        for(int i=0;i<a.size();i++){\\n            total+=(mid/a[i]);\\n        }\\n        return total>=k;\\n    }\\n    long long minimumTime(vector<int>& time, int k) {\\n        int n = time.size();\\n        if(n==1){\\n            return (long long int)k*time[0];\\n        }\\n        long long int low = 0;\\n        long long int high = 1e12;\\n        while(low<high){\\n            long long int mid = low + (high - low)/2;\\n            if(check(mid,time,k)){\\n                high = mid;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return high;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266792,
                "title": "c-binary-search-o-n-log-n-short-code",
                "content": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        ll l = 1, r = 100000000000000;\\n        ll ans = r;\\n        while (l <= r) {\\n            ll m = (l+r)/2;\\n            \\n            ll trips = 0;\\n            for (int n : time)\\n                trips += m / n;\\n            if (trips >= totalTrips)\\n                ans = m, r = m-1;\\n            else\\n                l = m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    #define ll long long\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        ll l = 1, r = 100000000000000;\\n        ll ans = r;\\n        while (l <= r) {\\n            ll m = (l+r)/2;\\n            \\n            ll trips = 0;\\n            for (int n : time)\\n                trips += m / n;\\n            if (trips >= totalTrips)\\n                ans = m, r = m-1;\\n            else\\n                l = m+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266638,
                "title": "minimum-time-to-complete-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBeing brute force setting the time line from 1 we can go through but as we donnot know the end it does not work hence the array is sorted and check the minimum time to complete we will go for Binary Search\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis is a classical binary search problem the lower time is 0 and the higher limit is 10**14 now we will find the mid value and check is it possible to make the trips if it is possible then we try to decrement the higher time and continue till the binary search algorithm works and note down the answer to be minimum...\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(NlogN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        low=0\\n        high=10**14\\n        ans=high\\n        while low<high:\\n            mid=(low+high)//2\\n            c=0\\n            #Checking how many trips are possible for this mid time,..\\n            for i in time:\\n                c+=(mid//i)\\n            if(c>=totalTrips):\\n                ans=min(ans,mid)\\n                high=mid\\n            else:\\n                low=mid+1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        low=0\\n        high=10**14\\n        ans=high\\n        while low<high:\\n            mid=(low+high)//2\\n            c=0\\n            #Checking how many trips are possible for this mid time,..\\n            for i in time:\\n                c+=(mid//i)\\n            if(c>=totalTrips):\\n                ans=min(ans,mid)\\n                high=mid\\n            else:\\n                low=mid+1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266554,
                "title": "python-brute-force-bs",
                "content": "**Brute force:**\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        for t in range(0, totalTrips * min(time) + 1):\\n            trips = sum((t // trip_time for trip_time in time))\\n            if trips == totalTrips:\\n                return t\\n ```\\n**Optimized with BS:**\\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        left = 0\\n        right = totalTrips * min(time)\\n        while left < right:\\n            mid = (left + right) // 2\\n            trips = sum((mid // trip_time for trip_time in time))\\n            if trips >= totalTrips:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        for t in range(0, totalTrips * min(time) + 1):\\n            trips = sum((t // trip_time for trip_time in time))\\n            if trips == totalTrips:\\n                return t\\n ```\n```\\nclass Solution:\\n    def minimumTime(self, time: List[int], totalTrips: int) -> int:\\n        left = 0\\n        right = totalTrips * min(time)\\n        while left < right:\\n            mid = (left + right) // 2\\n            trips = sum((mid // trip_time for trip_time in time))\\n            if trips >= totalTrips:\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3266546,
                "title": "go-binary-search",
                "content": "# Code\\n```\\nfunc minimumTime(time []int, totalTrips int) int64 {\\n\\tleft, right := 0, math.MaxInt\\n\\tfor left < right {\\n\\t\\tmid := (left + right) >> 1\\n\\t\\tif check(time, totalTrips, mid) {\\n\\t\\t\\tright = mid\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\t}\\n\\treturn int64(left)\\n}\\n\\nfunc check(time []int, totalTrips, mid int) bool {\\n\\tcnt := 0\\n\\tfor _, t := range time {\\n\\t\\tcnt += mid / t\\n\\t\\tif cnt >= totalTrips {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```\\nfunc minimumTime(time []int, totalTrips int) int64 {\\n\\tleft, right := 0, math.MaxInt\\n\\tfor left < right {\\n\\t\\tmid := (left + right) >> 1\\n\\t\\tif check(time, totalTrips, mid) {\\n\\t\\t\\tright = mid\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\t}\\n\\treturn int64(left)\\n}\\n\\nfunc check(time []int, totalTrips, mid int) bool {\\n\\tcnt := 0\\n\\tfor _, t := range time {\\n\\t\\tcnt += mid / t\\n\\t\\tif cnt >= totalTrips {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3266496,
                "title": "easy-solution",
                "content": "# Approach\\nBinary search\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l = 1;\\n        long long r = *min_element(time.begin(), time.end()) * (long long)totalTrips;\\n        while (l < r) {\\n            long long mid = (l + r) / 2;\\n            long long res = 0;\\n            for (int t : time) res += mid / t;\\n            if (res >= totalTrips) r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n- Space complexity: $$O(1)$$",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long l = 1;\\n        long long r = *min_element(time.begin(), time.end()) * (long long)totalTrips;\\n        while (l < r) {\\n            long long mid = (l + r) / 2;\\n            long long res = 0;\\n            for (int t : time) res += mid / t;\\n            if (res >= totalTrips) r = mid;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263349,
                "title": "java-binary-search-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse binary search over the time space. left=1 , right=min(time) * totalTrips. Given a fixed time (mid), we can easily check to see how many trips the buses can make. If this is >= totalTrips, we store ans and try to minimise the time more. Otherwise we set left = mid + 1.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n       // Arrays.sort(time);\\n        long min = Long.MAX_VALUE;\\n        for(int i: time){\\n            min = Math.min(i,min);\\n        }\\n        long low = 1, high = min*totalTrips; \\n        long ans=0;\\n        while(low<=high){\\n            long mid = (low+high)/2;\\n            long trips = 0;\\n            for(int i: time)\\n                trips+=(mid/i);\\n            if(trips<totalTrips)\\n                low = mid+1;\\n            else{\\n                ans = mid;\\n                high = mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n       // Arrays.sort(time);\\n        long min = Long.MAX_VALUE;\\n        for(int i: time){\\n            min = Math.min(i,min);\\n        }\\n        long low = 1, high = min*totalTrips; \\n        long ans=0;\\n        while(low<=high){\\n            long mid = (low+high)/2;\\n            long trips = 0;\\n            for(int i: time)\\n                trips+=(mid/i);\\n            if(trips<totalTrips)\\n                low = mid+1;\\n            else{\\n                ans = mid;\\n                high = mid-1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1824736,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824593,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1631784,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824678,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824577,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824927,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824770,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1688252,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824656,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1570806,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824736,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824593,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1631784,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824678,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824577,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824927,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824770,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1688252,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1824656,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1570806,
                "content": [
                    {
                        "username": "jems1123",
                        "content": "Btw Happy Holi guys"
                    },
                    {
                        "username": "nitin2003",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "jsbagul",
                        "content": "Holi, Happy Holi!"
                    },
                    {
                        "username": "Hemant3112",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "Happy Holi \\n"
                    },
                    {
                        "username": "guptatanish145",
                        "content": "Happy Holi"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Happy Holi Bhailog"
                    },
                    {
                        "username": "user4401w",
                        "content": "happy holi\\n"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "aye we celebrating it tomorrow, but happy holi 2023 nonetheless"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Today is Holika Dahana"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "holi kab hai....kab hai holi..."
                    },
                    {
                        "username": "adarshpie",
                        "content": "Happy Holi\\n"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "It is tomorrow, right?"
                    },
                    {
                        "username": "aitachii",
                        "content": "Given time taken per trip = [1,2,3].\nLet's say that at t = 0, trips = [0,0,0] since all three buses are on standby.\nAt t = 1, trips = [1,0,0], bus 1 has completed 1 trip, bus 2 has completed 1/2 a trip, and bus 3 has completed 1/3 of a trip.\nAt t = 2, trips = [2,1,0], bus 1 has completed 2 trips, bus 2 has completed 2/2 a trip or 1 trip, and bus 3 is still at 2/3 of a trip.\nAt t = 3, trips = [3,1,1], bus 1 has completed 3 trips, bus 2 has completed 1 + 1/2 trips, and bus 3 has completed 3/3 == 1 trip."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "I think leetcode should replace the original explanation with yours."
                    },
                    {
                        "username": "Sinan6942069",
                        "content": "This question is only hard because its explained so poorly"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "Am i the only one who felt problem description is messy?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "i think if u read the explanations in the examples carefully, you can definitely understand it. But it isn\\'t very intuitive, i\\'ll give you that. "
                    },
                    {
                        "username": "phamtuan199911",
                        "content": "[@user5313X](/user5313X) I understand your point, but this is where we solve very specifics problems with specific constraints and very specific solutions, there is no BA or PO for me to complaining about the fuzzy specification."
                    },
                    {
                        "username": "user2418K",
                        "content": "[@user5313X](/user5313X) Are you an author of the question?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "messy but understandable. I think it\\'s part of your necessary skillset as a programmer to understand a messy problem specification. I believe it will serve you much more than knowing how to do a binary search by heart"
                    },
                    {
                        "username": "jems1123",
                        "content": "mai bhi hu jise question hi smjh nhi aa rha h\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25\\uD83D\\uDE25"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "I didn\\'t even understood what the buses were doing here... what the hell?"
                    },
                    {
                        "username": "parthK57",
                        "content": "I feel like I don\\'t even know english after reading this question :)"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "us bro us"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Approach Using Binary Search :-\n\n\n1.Initialize a lower bound lo to 1 and an upper bound hi to the maximum possible long value.\n\n2.Enter a loop that continues until the lower bound is greater than or equal to the upper bound.\n\n3.In each iteration of the loop, calculate the midpoint between the lower and upper bounds using the formula mid = lo + (hi - lo) / 2.\n\n4.Calculate the number of completed trips that can be made in the mid time using a for loop that iterates over each time in the time array.\n\n5.If the number of completed trips is greater than or equal to the total number of trips required, update the upper bound hi to the mid value.\n\n6.Otherwise, update the lower bound lo to the mid value plus one.\n\n7.Repeat steps 3 to 6 until the lower bound is greater than or equal to the upper bound.\n\n8.Return the lower bound, which represents the minimum time required to complete the given number of trips based on the times in the array."
                    },
                    {
                        "username": "matthewjiao",
                        "content": "The upper bound shouldn\\'t have be the max long value ... that\\'s pretty wasteful,\\nA more strict upper bound is: min(time) * totalTrips."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link for Reference :-\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3266933/binarysearch-approach-explained-in-steps/"
                    },
                    {
                        "username": "topswe",
                        "content": "Hint: use binary search over the solution space. left, right = 1, min(time) * totalTrips. Given a fixed time, we can easily check to see how many trips the buses can make. If this is >= totalTrips, we set right = mid. Otherwise we set left = mid + 1."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "that\\'s not a hint man, that\\'s the solution"
                    },
                    {
                        "username": "kshitijkale30",
                        "content": "You could even keep left = totalTrips * min(time) / size(time). As in best case all enteries are equal to min & all of them will help equally. "
                    },
                    {
                        "username": "hiper2d",
                        "content": "Binary Search is a huge hint. It\\'s quite hard to come up with it before hitting TLE in the brute force solution."
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Hint</span>\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/1.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/2.png)\n\n### Binary Search\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/3.png)\n![](https://leetcode.com/problems/minimum-time-to-complete-trips/Figures/2187/4.png)"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@UchihaKim](/UchihaKim) he copy-pasted from the official solution "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "nice tip! would you mind teaching me how to do this type of image?"
                    },
                    {
                        "username": "jainkrunal",
                        "content": "Building a min heap with optimised solution will take O(n*logK). Anybody knows why using min heap is giving TLE?"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@yxt](/yxtyan), the search space has nothing to do with the number of trips."
                    },
                    {
                        "username": "coderinterview",
                        "content": "I believe the your question is already answered pretty well, just elaborating why it\\'s not n*log K. It\\'s because with mean heap you have to consistently find the bus which can finish the trip at the earliest. When you find such bus, you have to update it\\'s next earliest trip possible and push it back into the min head, so the total time will come out to be:\\nn*log n //for inital min Heap\\n+ K*log n // you will pop and push elements in heap K times\\ntotal time Complexity: (n+k)*(log n)\\nBinary search goes upto: n*(log(m*k)), m being minimum element in array.\\nAs you can see, K is very large in comparison to log m hence TLE."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "[@0xatul](/0xatul) It is  because the complexity of binary search is the log of the difference between your initial values for left and right. In this case, left is m because you have to do at least the shortest trip and right is k * m because you can do everything with the fastest bus. You can actually improve the complexity by working on the bounds as I explain here: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "0xatul",
                        "content": "[@beardedone](/beardedone) Care to explain why is it log(k*m) ?"
                    },
                    {
                        "username": "yxtyan",
                        "content": "[@cecilia5](/cecilia5) Is the binary search space smaller than `n`? I don\\'t understand why min heap solution is slower."
                    },
                    {
                        "username": "beardedone",
                        "content": "The time complexity with a min heap is O(k*n*log n), where k is the total trips, and n is the size of the time array.  The binary search has a time complexity of O(n * log(k*m)), where n is the size of the time array, m is the minimum value in the array, and k is the total trips."
                    },
                    {
                        "username": "AlecLC",
                        "content": "You need O (log n) for this problem, O(n) is too slow"
                    },
                    {
                        "username": "cecilia5",
                        "content": "`n` can be `10^7`, so it is slow"
                    }
                ]
            },
            {
                "id": 1825380,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1824842,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1824609,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1824620,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1825108,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1824889,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1824790,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1576470,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1825456,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1825196,
                "content": [
                    {
                        "username": "prathmesh_24",
                        "content": "Not even single neuron of brain spotted that it was suppose to be a binary search problem even after staring at problem for an hour. ( \\uFF89 \\uFF9F\\uFF70\\uFF9F)\\uFF89"
                    },
                    {
                        "username": "ashish0401",
                        "content": "The Buses are making trips to drop us to our respective homes for Holi XD..\\nHappy Holi Guys!"
                    },
                    {
                        "username": "anwendeng",
                        "content": "It\\'s hard to understand what will be done."
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "So frustrating to understand the problem."
                    },
                    {
                        "username": "stackAndQueue",
                        "content": "If you find this problem messy, and want a very very similar problem:\\n\\n[https://leetcode.com/problems/koko-eating-bananas/](https://leetcode.com/problems/koko-eating-bananas/) \\n\\nIf you figure the above problem, this one is a breeze.\\n\\nEnjoy! Happy Holi :)"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is an Example dry Run:-\\n\\nfor time=[1,2,3] and totaltrips=5\\nlow=1, high=3*5=15                    (i.e high=maxvalue of(time) * totaltrips  )\\n\\nstart iterating\\nmid=8           (low=1 and high=15)\\niterate in time\\ncompletetrips=8/1=8\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=4          (low=1 and high=8)\\niterate in time\\ncompletetrips=4/1+4/2=6\\ncompletetrips>=totaltrips (break);\\nhigh=mid\\n\\nmid=2         (low=1 and high=4)\\niterate in time\\ncompletetrips=2/1+2/2+2/3=3\\ncompletetrips<=totaltrips \\nlow=mid+1\\n\\nnow low has passed the high\\nso we will return low (i.e 3)\\n"
                    },
                    {
                        "username": "Vaibhav_Potdar",
                        "content": "Here i think high can be = smallest number * totaltrips , because that bus can itself cover all the trips without requirement of other buses, other buses only minimize the min required time.\\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@dasarisairam](/dasarisairam)You\\'re welcome! I\\'m glad I could help you understand the code better."
                    },
                    {
                        "username": "dasarisairam",
                        "content": "This really helps ranvir ,I some how came up with the code by understanding what I am doing thanks.Keep doing the good work."
                    },
                    {
                        "username": "purple_Lion",
                        "content": "is time sorted??"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Time is tracking the speed of the ith bus"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "No,"
                    },
                    {
                        "username": "AdiDu",
                        "content": "I participated in Leetcode Weekly 282 and solved this question. I was awarded points for this question. But now When I see, it\\'s showing WA even for the answer that was accepted. They also changed by contest status. This doesn\\'t make any sense to me. Please let me know how this works."
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "This is because test cases are added afterwards. For instance, after the contests, I check some solutions from other people, and once I found one which got AC but actually was incorrect so I submitted a new test case to LC."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Wondering that no one faced signed integer overflow :|"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "Abe, kuch bhi ho raha hai, Leetcode problem setters, plis dhang se explain kiya crow yar problem statement ko.\\n"
                    }
                ]
            },
            {
                "id": 1825088,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 1825085,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 1815796,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 1825022,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 2044683,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 2010065,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 1987685,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 1973176,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 1965239,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 1887372,
                "content": [
                    {
                        "username": "Naman-Srivastav",
                        "content": "Testcases are only making the problem more confusing... :)"
                    },
                    {
                        "username": "bohkoval",
                        "content": "How you understand that it\\'s actually binary search problem? I initially though of DP problems, where we start with 1 trip and move on to totalTrips.\\nThose who initially came up with binary search solution - can you please explain you thought process? which pieces gave you the clue?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "I also thought about DP at first but there didn\\'t seem to be any obvious way to do it. Then I tried to estimate the lower and upper boundary of what the answer could look like in different cases and realized that the solution will DEFINITELY get TLE unless I use some smart method to at narrow it down to something sensible.\\nThen there is also the idea that we can easily find out how many trips we can make if we have the time, cutting out all numbers to the left or to the right (depending on whether it is less than totalTrips or not), and thereby liberating us from a huge chunk of iterations. And that\\'s basically binary search.\\nThat\\'s how I figured it out, at least"
                    },
                    {
                        "username": "angularui06",
                        "content": "time = [3,6,6] , totalTrips = 7\\nTrips is monotonic wrt t , so we can apply binary search on trips. \\nt= 0 , trips = 0\\nt=1 ,trips = 0\\nt= 2 ,trips = 0\\nt =3, trips = 1\\nt=4 ,trips = 1\\nt=5 ,trips = 1\\nt =6, trips = 4\\nt=7 ,trips = 4\\nt= 8 ,trips = 4\\nt =9, trips = 5\\nt=10,trips = 5\\nt = 11, trips = 5\\nt = 12 , trips = 8 > totalTrips = 7"
                    },
                    {
                        "username": "vickyshankar23",
                        "content": "This is bordering on hard. The thinking of sliding puzzle problem is the same, i.e., to search for the optimal answer over the solution space. There it was a graph so we had to BFS. Here it's an array and binary search.\nEasy once you realize we need to search the solution space but that's a hard thing to realize and harder to understand the boundaries of the solution space."
                    },
                    {
                        "username": "kshzz24",
                        "content": "Ez question basic Binary Search"
                    },
                    {
                        "username": "Limon020",
                        "content": "These binary search questions are tricky, this one is one of the easier ones I\\'ve seen"
                    },
                    {
                        "username": "ByteBikerVaas",
                        "content": "123/124 test cases passed and this one failed :/\\ntime =\\n[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1..."
                    },
                    {
                        "username": "myjscoffee",
                        "content": "whats wrong with this code. Last testcase is failing\n `class Solution {\n  public long minimumTime(int[] time, int totalTrips) {\n    long min = Long.MAX_VALUE;\n    for (int i: time) {\n      min = Math.min(i, min);\n    }\n    long i = 1, j = min * totalTrips;\n    long minTime = -1;\n    while (i <= j) {\n      long mid = i + (j - i) / 2;\n      if (isPossible(time, totalTrips, mid)) {\n        minTime = mid;\n        j = mid - 1;\n      } else {\n        i = mid + 1;\n      }\n    }\n    return minTime;\n  }\n\n  boolean isPossible(int[] time, int totalTrips, long t) {\n    int c = 0;\n    for (int i = 0; i < time.length; i++) {\n      c += (t) / time[i];\n    }\n    return c >= totalTrips;\n  }\n}`"
                    },
                    {
                        "username": "Tesla_Arc",
                        "content": "I\\'m repeatedly failing the 86th Test case. I checked it its working fine. Used Binary Search, but its not working. Can Anyone just some changes...\\n\\n86th Test Case- \\ntotalTrips =  9765277\\nExpected Output = 34766088\\nOutput = 867618159880\\n\\nMy code ----\\nclass Solution {\\npublic:\\n    bool check(int mid,vector<int>& time, int totalTrips)\\n    {\\n        long long trips = 0;\\n\\n        for(int i=0;i<time.size();i++)\\n        {\\n            trips+= (long long)mid/(long long)time[i];\\n        }\\n\\n        if(trips>=(long long)totalTrips) return true;\\n        else return false;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        int maxi=-1;\\n        for(int i=0;i<time.size();i++)\\n        {\\n            maxi=max(maxi,time[i]);\\n        }\\n\\n        long long lo=1;\\n        long long hi=((long long)maxi)*((long long)totalTrips);\\n        long long ans =-1;\\n\\n        while(lo<=hi)\\n        {\\n            long long mid = lo +(hi-lo)/2;\\n\\n            if(check(mid,time,totalTrips))\\n            {\\n                ans = mid;\\n                hi = mid-1;\\n            }\\n            else \\n                lo = mid+1;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "atharva598",
                        "content": "This problem can be marked as easy, imo. The last sentence should be changed to\\n\"Return the minimum time required for all buses **together** to complete at least totalTrips trips\" for better understanding."
                    },
                    {
                        "username": "shubhi4",
                        "content": "Nice boundary conditions"
                    }
                ]
            },
            {
                "id": 1884010,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1833815,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1827293,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1826064,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1825625,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1825595,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1825558,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1825553,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1825460,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1825458,
                "content": [
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "is time[i] sorted?"
                    },
                    {
                        "username": "user2418K",
                        "content": "It\\'s not mentioned explicitly in the description of the problem, so you should expect non sorted array as an input."
                    },
                    {
                        "username": "SkyFullOfStars1005",
                        "content": "My bad. Misunderstood the problem. Ignore my question here. lol"
                    },
                    {
                        "username": "xpertcoder",
                        "content": "Following code has 2 almost similar code, but one fails for 4 test cases out of 124 and current code passes all the test cases.\\nCan anyone point out mistake in my code ?\\n\\nclass Solution {\\npublic:\\n    long long tripsInTime(int t, vector<int> &arr){\\n\\n        long long ans =0;\\n\\n        for(auto x: arr){\\n            if(x == 0) continue;\\n            ans += t/x;\\n        }\\n        return ans;\\n    }\\n    long long minimumTime(vector<int>& time, int totalTrips) {\\n        long long maxTime = 0, minTime = 0, ansTime = 0, totTrips = totalTrips;\\n        int minVal = time[0];\\n        for(int i = 1; i < time.size(); i++)\\n            minVal = min(minVal, time[i]);\\n        maxTime = (long long) minVal * totalTrips;\\n        ansTime = maxTime;\\n        while (minTime <= maxTime){\\n            long long medTime = (minTime + maxTime)/2;\\n            long long totalTripsPossible = 0;\\n            for(int i = 0; i < time.size(); i++){\\n                if(time[i] == 0)\\n                    continue;\\n                totalTripsPossible += medTime/time[i];\\n            }\\n            if(totalTripsPossible >= totalTrips){\\n                //it is possible that with less time also we can make totalTrips\\n                ansTime = medTime;\\n                maxTime = medTime - 1;\\n            }else{\\n                minTime = medTime + 1;\\n            }\\n        }\\n        return ansTime;\\n        \\n        // long long low =1, high;\\n\\n        // sort(time.begin(), time.end());\\n        // long long minV = time[0];\\n        // for(auto x: time)  minV = min(minV, (long long)x);\\n        // high = totTrips * minV;\\n        // long long ans = high;\\n        // while(low <= high){\\n        //     long long mid = (high + low)/2;\\n\\n        //     long long trips = tripsInTime(mid, time);\\n\\n        //     if(trips >= totTrips){\\n        //         ans = mid;\\n        //         high = mid -1;\\n        //         // if(low == high) break;\\n        //     }\\n        //     else{\\n        //        low = mid+1; \\n        //     }\\n        // }\\n        // return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Maha-Lax-M",
                        "content": "anyone tell me, why here to use binary search ?"
                    },
                    {
                        "username": "raghav2130",
                        "content": "Is the time array already sorted,,,if possibly not how can we apply binary search ?? "
                    },
                    {
                        "username": "udaygupta2801",
                        "content": "I tried applying binary search by taking Minimum time as 0 and then Maximum time as 1e14\\nthen calculated mid value and for all buses then calculated no of trips made till that time \\nif no of trips came out to be more than reqrd trips\\n      then i stored mid that i calcualated in a Minimum time variable to be retuerned now Maximum i bring to \\n      mid-1 and continue with finding Mid and repeating process till Minimum is lesser than or equal to \\n      Maximum"
                    },
                    {
                        "username": "educatedguess",
                        "content": "Naming of the variables and method is poor, problem description is overcomplicated."
                    },
                    {
                        "username": "rammanoj",
                        "content": "Hint 1: Use binary search on answer.\\n\\nDifficulties in figuring out range for end ? \\nHint 2: try max possible value 10^14 / 10^15 --> this passes the solution\\n\\nHow to find out exact end value ?\\nHint 3: \\n- Find how many trips all busses take till the maximum timed bus complete 1 trip and store it in tripCount. \\n- Do temp = ceil(totalTrips / tripCount) to get what could be the possible value of time.\\n- en = temp * maxv (maximum timed bus time )\\n\\nFor detailed solution:\\nCheck: https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3270079/beats-97-with-intuition-and-explanation/"
                    },
                    {
                        "username": "Msey",
                        "content": "worst explanation ever"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "Any idea why my code isnt working for testcase time=[5,10,10]. I tried with mid=(low+high)/2 as well as mid = low +(high-low)/2\\n\\n```\\nclass Solution {\\n    public long minimumTime(int[] time, int totalTrips) {\\n        long left=0, right=10^14, ans=right;\\n        while(left<right)\\n        {\\n            long mid= left + (right-left)/2;      //yahan integer overflow shayad nhi hoga  kyonki long hai, dats why (LOw+high )/2 kiye instead of low+(high-low)/2\\n            long count=0;\\n            for(int i=0; i<time.length; i++)\\n            {\\n                count+= mid/time[i];\\n            }\\n            if(count>=totalTrips)\\n            {\\n                //whats d logic behind dis?\\n                ans=Math.min(ans,mid);\\n                right=mid;\\n            }\\n            else left=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "bunkov",
                        "content": "the worst explaine in the world...Even freelance client cant explane so badly the task..."
                    }
                ]
            },
            {
                "id": 1825452,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825382,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825374,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825372,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825304,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825293,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825275,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825274,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825253,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825195,
                "content": [
                    {
                        "username": "arandkarv",
                        "content": "how do we know that we can apply binary search for this? can anyone help me ?"
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "One suggestion is that whenever , you see something like range then always look for the binary search there ."
                    },
                    {
                        "username": "sarthak6596",
                        "content": "can understand the problem can someone please explain it to me??"
                    },
                    {
                        "username": "AshokNanda",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "souvik_avro",
                        "content": "happy holi guys\\n"
                    },
                    {
                        "username": "Karan-Yadav",
                        "content": "can anyone tell why for time=[3,3,8] and totalTrips=8 the t_min = 9\\nI am getting 12 as the answer"
                    },
                    {
                        "username": "Rinaa",
                        "content": "dooh not again...Time Limit Exceeded....62/123 testcases passed\\n"
                    },
                    {
                        "username": "ajesk",
                        "content": "I feel like all these masked binary search questions are \"gotchas!\". It\\'s cool how they are constructed, but damn are they quite messy to read and difficult to parse what is being asked."
                    },
                    {
                        "username": "nayan-khemka",
                        "content": "I don\\'t get why my approach didn\\'t work. I tried to find out a value of x arithmetically as totaltrips/sum of (1/time[i]) now i check if for summation of floor(x/time[i]) give me total trips or not if not then i increase the value of x; how does this take more time than the binary search approach?"
                    },
                    {
                        "username": "BusyBeaver42",
                        "content": "You cannot obtain directly the result with this method. But from that you can derive bounds which actually improve the time complexity of the solution.\\nI explain it there https://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3268986/o-n-log-k-solution-1378-ms-in-python3-beats-100/."
                    },
                    {
                        "username": "vishwajeet20my",
                        "content": "what will be the Output for this Testcase\\nINTPUT:- \\ntime=[5,10,10]\\ntotalTrips= 9\\nOUTPUT:\\n?????"
                    },
                    {
                        "username": "Rinaa",
                        "content": "The output will be 25, because:\n* For t from 1 to 4 the trips completed by each bus will be [0, 0, 0]\n* When t = 5, the first bus finish his first trip, so trips completed will be [1, 0, 0]\n* For t from 6 till 9, trips completed remain the same ([1, 0, 0])\n* When t = 10, the first bus finish his second trip, also bus2 and bus3 will finish their first trip => [2, 1, 1]\n* For t from 11 till 14 => [2, 1, 1]\n* When t = 15, the first bus finish his third trip => [3, 1, 1]\n* When t = 20, the first bus finish his fourth trip, also bus2 and bus3 will finish their second trip => [4, 2, 2]\n* When t = 25, the first bus finish his fifth trip => [5, 2, 2] and the sum of this array is 9 = total trips... So thats why we return t = 25  \n"
                    }
                ]
            },
            {
                "id": 1825102,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            },
            {
                "id": 1825091,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            },
            {
                "id": 1825048,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            },
            {
                "id": 1824989,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            },
            {
                "id": 1824987,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            },
            {
                "id": 1824866,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            },
            {
                "id": 1824861,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            },
            {
                "id": 1824799,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            },
            {
                "id": 1824776,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            },
            {
                "id": 1824767,
                "content": [
                    {
                        "username": "_Tanmay",
                        "content": "Happy Holi y\\'all! \\uD83E\\uDD73\\uD83C\\uDF89"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "First tried O(N) solution which passed 62/123 TestCases with TLE\n\nDeveloped almost 80% solution for Binary Search Passed 70/123 TestCases, just to meet to overflow  at 100th TestCase and after 2hr I had to look the solution tab just to find out that I was putting conditions wrong such I had separate conditions for '==', & '>'. As Binary Search is used for searching element which I learned in general such we arrive at the same point i.e. 'lo' & 'hi' are equal. One should get 'lo' < 'hi' and 'sum' >= 'totalTrips'  to 'hi=mid' otherwise 'lo=mid+1'. OMG for me. This taught me so much to be honest. Long way to learn.\n\nTip : Be careful of overflow & conditions like '>=', '<='.\n\nHint: Find the minimum point where your sum is '>=' to totalTrips for hi=mid otherwise lo=mid+1. You will surely find the 'lo' ans."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Next question to practice for you\\n[2528. Maximize the Minimum Powered City](https://leetcode.com/problems/maximize-the-minimum-powered-city/)"
                    },
                    {
                        "username": "shivam9935",
                        "content": "Ah you are leetcoding on Holi.\\nThis is for you \\nhttps://leetcode.com/static/images/coin.gif"
                    },
                    {
                        "username": "harshdevs",
                        "content": "For people who didn\\'t understand the problem description:\\n\\nThis question involves finding the minimum amount of time required for a set of buses to complete a certain number of trips. You are given an array called time, where time[i] represents the amount of time required for the ith bus to complete one trip. Each bus can make multiple trips consecutively, and the trips of one bus do not affect the trips of another. You are also given an integer called totalTrips, which represents the total number of trips that all buses should make combined.\\n\\nYour task is to determine the minimum amount of time it will take for all the buses to complete at least totalTrips trips.\\n\\nFor example, consider time = [1, 2, 3] and totalTrips = 5. The output should be 3. Here\\'s how we arrive at that answer:\\n\\nAt time t = 1, the first bus completes one trip, while the other two buses have not completed any trips yet. So the total number of trips completed is 1.\\nAt time t = 2, the first bus completes its second trip, while the second bus completes its first trip. The third bus still hasn\\'t completed any trips. So the total number of trips completed is 3.\\nAt time t = 3, the first bus completes its third trip, while the second and third buses each complete their first trip. Now the total number of trips completed is 5.\\nTherefore, the minimum time required for all buses to complete at least 5 trips is 3."
                    },
                    {
                        "username": "shivansh157",
                        "content": "While doing this I immediately got the idea of Binary Search while in contest I would have struggled even to understand the question.\\n\\nHint: The answer always lies in a range and follows FFFFTTTT.... type of pattern so binary search can be applied."
                    },
                    {
                        "username": "saintmeteo",
                        "content": "yep , [@Shivansh Pandey](/shivansh157) can you please say what do you mean by \"FFFFTTTT..\" type of pattern ?"
                    },
                    {
                        "username": "harshdevs",
                        "content": "what do yo mean by \"FFFFTTTT\" pattern?"
                    },
                    {
                        "username": "uttarandas501",
                        "content": "Put a condition, if the number of possible trips is >= totalTrips, break out of the loop, otherwise overflow will happen. Otherwise its an easy question!"
                    },
                    {
                        "username": "anoyash",
                        "content": "can anyone help me to understand how to get the <b>intuition</b> of this type of problem, where required answer lies in some search space. ? In the past I have done couple of <b>Binary search (medium)</b> problem where we need to figure out the monotonic search space. \n\nSimilar other problems :\n1. https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/\n2. https://leetcode.com/problems/koko-eating-bananas/"
                    },
                    {
                        "username": "angularui06",
                        "content": "Explained with a plot , go through it let me know if any questions\\n\\nhttps://leetcode.com/problems/minimum-time-to-complete-trips/solutions/3267813/solution-with-clear-explanation-and-example/"
                    },
                    {
                        "username": "Mohd_Asad",
                        "content": "Once you figure out that the answer lies only in a certain range of numbers, then the only thing which is left to do is optimize the answer which we found ( in this question we need to minimize it as much as possible, so as soon as we find a potential answer we move to the left of mid searching for a potential answer that is of much less value)"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "🔥+1\nHint: Click `Related Topics`"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Very Hard \\uD83D\\uDE16\\uD83E\\uDD15"
                    }
                ]
            }
        ]
    }
]